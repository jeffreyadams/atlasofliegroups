/*
  This is interactive_lattice.cpp

  Copyright (C) 2004,2005 Fokko du Cloux
  part of the Atlas of Reductive Lie Groups

  For license information see the LICENSE file
*/

#include "interactive_lattice.h"

#include <iostream>
#include <sstream>

#include "arithmetic.h"
#include "basic_io.h"
#include "input.h"
#include "interactive.h"
#include "lattice.h"
#include "ioutils.h"
#include "prerootdata.h"
#include "smithnormal.h"
#include "topology.h"

/*****************************************************************************

  ... explain here when it is stable ....

******************************************************************************/

namespace atlas {

namespace {

  enum GeneratorError { NoError = 0, FormatError, BadDenominator,
			NegDenominator, TooFew };

  GeneratorError checkGenerator(input::InputBuffer&, size_t&,
				latticetypes::LatticeCoeff&,
				const latticetypes::Weight&);

  void makeOrthogonal(latticetypes::LatticeMatrix&, latticetypes::CoeffList&,
		      const latticetypes::RatWeightList&, size_t);

  std::ostream& printCenter(std::ostream&, const latticetypes::CoeffList&);

  void readGenerator(latticetypes::RatWeight&,
		     const latticetypes::CoeffList& u,
		     input::InputBuffer&);
}

/*****************************************************************************

        Chapter I -- Functions declared in interactive_lattice.h

  ... explain here when it is stable ...

******************************************************************************/

namespace interactive_lattice {

void adjustBasis(latticetypes::WeightList& b, latticetypes::CoeffList& invf,
		 const latticetypes::WeightList& lb,
		 const latticetypes::CoeffList& linvf)

/*
  In this function, b holds a Smith basis of the weight lattice w.r.t. the
  root lattice. In this basis, we have marked the indices where the quotient
  is not zero; lb holds a basis of the subgroup generated by this subset
  of b, which is Smith w.r.t. the purported group lattice; linvf holds the
  corresponding invariant factors.

  Then we replace the part of b corresponding to these indices, by the
  Smith basis thus constructed; this now is a Smith basis of the weight
  lattice w.r.t. the group lattice.

  Finally, we multiply the elements of by their invariant factors, so as
  to get a basis of the group lattice.
*/

{
  using namespace latticetypes;
  using namespace matrix;

  // replace the elements in b corresponding to lb by the elements of lb;
  // also adjust invariant factors
  size_t i = 0;

  for (size_t j = 0; j < invf.size(); ++j)
    if (invf[j] != 1) {
      const Weight& v = lb[i];
      b[j] = v;
      invf[j] = linvf[i];
      ++i;
    }

  // scale b to the lattice basis

  for (size_t j = 0; j < invf.size(); ++j)
    if (invf[j] != 1) {
      LatticeCoeff a = invf[j];
      b[j] *= a;
    }

  return;
}

void getGenerators(latticetypes::RatWeightList& d_rwl,
		   const latticetypes::CoeffList& u)
  throw(error::InputError)

/*
  Gets the generators of X/Q, where Q is the root lattice, from the user.

  It throws an InputError if the interaction with the user does not conclude
  successfully. In that case, d_gl is not modified.
*/

{
  using namespace basic_io;
  using namespace error;
  using namespace input;
  using namespace interactive;
  using namespace latticetypes;
  using namespace matrix;
  using namespace topology;

  latticetypes::RatWeightList rwl;

  std::string genString;
  inputLine() >> genString;

  if (genString.find("sc") == 0)
    goto simplyconnected;
  if (genString.find("ad") == 0)
    goto adjoint;

  if (isTrivial(u))
    goto simplyconnected;

  std::cout
    << "elements of finite order in the center of the simply connected group:"
    << std::endl;

  printCenter(std::cout,u) << std::endl;

  std::cout << "enter kernel generators, one per line" << std::endl;
  std::cout << "(ad for adjoint, ? to abort):"
	    << std::endl;

  {
    HistoryBuffer ib;

    while (true) {
      ib.getline(std::cin,"");
      if (hasQuestionMark(ib))
	throw InputError();
      genString.clear();
      ib >> genString;
      if (genString.empty()) // done
	break;
      if (genString.find("sc") == 0)
	goto simplyconnected;
      if (genString.find("ad") == 0)
	goto adjoint;
      ib.reset();
      size_t j;
      LatticeCoeff d;
      switch (checkGenerator(ib,j,d,u)) {
      case NoError:
	break;
      case FormatError:
	std::cerr << "bad format in entry #" << j+1
		  << " (should be of the form a/";
	if (u[j])
	  std::cerr << u[j] << ")" << std::endl;
	else
	  std::cerr << "b, b > 0)" << std::endl;
	std::cerr << "bad input line --- ignored" << std::endl;
	continue;
      case BadDenominator:
	std::cerr << "denominator in entry #" << j+1
		  << " should be " << u[j] << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      case NegDenominator:
	std::cerr << "denominator in entry #" << j+1
		  << " should be positive" << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      case TooFew:
	std::cerr << "too few valid entries" << std::endl
		  << "bad input line --- ignored" << std::endl;
	continue;
      }
      rwl.push_back(RatWeight(u.size(),d));
      readGenerator(rwl.back(),u,ib);
    }
  }

  goto finish;

 adjoint: // return the full center of the _derived_ group
  // put in rwl a list of ratvectors of 0/1's
  rwl.assign(u.size(),RatWeight(Weight(u.size(),ZeroCoeff),OneCoeff));

  for (size_t j = 0; j < rwl.size(); ++j)
    if (u[j]) {
      rwl[j].numerator()[j] = 1;
      rwl[j].denominator() = u[j];
    }

  goto finish;

 simplyconnected: // return the empty list
  rwl.clear();

  goto finish;

 finish:
  d_rwl.swap(rwl);
  return;
}

void getLattice(latticetypes::CoeffList& invf, latticetypes::WeightList& b)
  throw(error::InputError)

/*
  Gets the lattice interactively from the user.

  This works as follows. Initially, b is a Smith normal basis of the root
  lattice w.r.t. the weight lattice (or more precisely, a concatenation of
  one such basis for each factor in the complex Lie type); invf is the
  corresponding invariant factor type. Adding one free generator for each
  torus factor (corresponding to zeroes in invf), we get a decomposition
  of the weight lattice modulo the root lattice, as a direct product of
  finite cyclic and infinite cyclic groups. The user has to specify a group
  of finite index of this quotient, in terms of generators.

  Adding the generators of the root lattice, we then get generators for the
  group lattice. Applying Smith normal form again, we can get a basis for the
  group lattice, and the invariant factors w.r.t. the weight lattice. We only
  need to do modify the basis vectors that have a non-zero image in the
  quotient.

  Then the appropriate elements of this final Smith normal basis are multiplied
  by the corresponding invariant factor, to get a basis of the group lattice.

  Throws an InputError if the interaction with the user fails. In that case,
  b and invf are not modified.
*/

{
  using namespace error;
  using namespace latticetypes;

  Weight u;
  getUniversal(u,invf);  // ... put an explanatory comment here ...

  // get generators of character group

  RatWeightList rwl;         // generator list
  getGenerators(rwl,u);      // get the generators interactively
                             // might throw an InputError

  // make basis elements corresponding to the central elements

  LatticeMatrix q;
  CoeffList linvf;
  makeOrthogonal(q,linvf,rwl,u.size());

  WeightList lb;
  localBasis(lb,b,invf);

  LatticeMatrix m(lb);
  m *= q;
  for (size_t j = 0; j < lb.size(); ++j)
    m.column(lb[j],j);

  // make actual basis

  adjustBasis(b,invf,lb,linvf);

  return;
}

void getUniversal(latticetypes::CoeffList& u,
		  const latticetypes::CoeffList& invf)

/*
  Extracts from invf the coefficients that are not one; these will define
  the fundamental group of the adjoint group, as a product of cyclic groups
  (not necessarily canonically normalized.)
*/

{
  u.clear();

  for (size_t j = 0; j < invf.size(); ++j) {
    if (invf[j] != 1)
      u.push_back(invf[j]);
  }

  return;
}

void localBasis(latticetypes::WeightList& lb,
		const latticetypes::WeightList& b,
		const latticetypes::CoeffList& invf)

/*
  Extracts from b the part corresponding to non-1 terms in invf.
*/

{
  for (size_t j = 0; j < invf.size(); ++j)
    if (invf[j] != 1)
      lb.push_back(b[j]);

  return;
}

void smithBasis(latticetypes::CoeffList& invf, latticetypes::WeightList& b,
		const lietype::LieType& lt)

/*
  The Lie type is defined as a sequence of simple and torus factors inside
  lt. This function constructs a "blockwise smith normal" basis for the
  root lattice inside the weight lattice (i.e., it does just that for each
  semisimple block, and returns the canonical basis for the torus blocks.)

  The purpose of doing this blockwise instead of globally is to permit a
  better reading of the quotient group : this will be presented as a sequence
  of factors, corresponding to each simple block.

  Of course, it is still assumed that the caller is a "savvy" user, and knows
  that some blocks will not contribute (because the adjoint group is simply
  connected), and that blocks D_n, n even, contribute _two_ factors Z_2.
  Torus blocks T_n contribute n factors Z (this will be reflected in the
  "missing" invariant factors.)
*/

{
  using namespace latticetypes;
  using namespace lietype;
  using namespace matrix;
  using namespace prerootdata;
  using namespace smithnormal;

  // smith-normalize for each simple factor

  initBasis(b,rank(lt));
  WeightList::iterator bp = b.begin();

  for (size_t j = 0; j < lt.size(); ++j) {

    size_t r = rank(lt[j]);

    if (type(lt[j]) == 'T') { // torus type
      invf.insert(invf.end(),r,ZeroCoeff);
      bp += r;
      continue;
    }

    LatticeMatrix ms;
    cartanMatrix(ms,lt[j]);
    ms.transpose();
    smithNormal(invf,bp,ms);

    if (type(lt[j]) == 'D' and (rank(lt[j])&1UL) == 0) {
      //make a small adjustment
      bp[r-2] += bp[r-1];
    }

    bp += r;

  }

  return;
}

}

/*****************************************************************************

        Chapter II -- Functions local to interactive_lattice.cpp

  ... explain here when it is stable ...

******************************************************************************/

namespace {

GeneratorError checkGenerator(input::InputBuffer& buf, size_t& r,
			      latticetypes::LatticeCoeff& d,
			      const latticetypes::Weight& u)

/*
  Synposis: checks if buf contains data compatible with u.

  Precondition: buf should contain a comma-separated list, with one entry for
  each member of u (extra entries are ignored). The entries should be of the
  form a/b, where b = u[j] if u[j] > 0, b > 0 arbitrary otherwise.

  Explanation: the element a/b (with b = u[j] if u[j] > 0) represents the
  element exp(2i.pi.a/b) in a one-dimensional torus factor.

  In case of failure, the entry number where the rank occurs is put in r. In
  case of success, the l.c.m. of the various b's and u[j]'s is put in d.

  NOTE: no overflow checking is done on d.
*/

{
  using namespace arithmetic;
  using namespace latticetypes;

  std::streampos pos = buf.tellg();
  unsigned long lc = 1;

  for (size_t j = 0; j < u.size(); ++j) {

    if (buf.peek() == EOF) {
      buf.reset(pos);
      return TooFew;
    }

    LatticeCoeff a;
    buf >> a;
    char x = 0;
    buf >> x;
    if (x != '/') {
      r = j;
      buf.reset(pos);
      return FormatError;
    }

    LatticeCoeff b = 0;
    buf >> b;

    // check denominator
    if (u[j] == 0) {
      if (b <= 0) { // negative denominator error
	r = j;
	buf.reset(pos);
	return NegDenominator;
      }
    } else if (b != u[j]) { // bad denominator error
      r = j;
      buf.reset(pos);
      return BadDenominator;
    }

    // update lowest common denominator
    if (a)
      lc = lcm(lc,b);

    if (j+1 < u.size()) { // next non-white character should be a comma
      char x = 0;
      buf >> x;
      if (x != ',') {
	buf.reset(pos);
	return TooFew;
      }
    }
  }

  buf.reset(pos);
  d = lc;

  return NoError;
}

void makeOrthogonal(latticetypes::LatticeMatrix& q,
		    latticetypes::CoeffList& invf,
		    const latticetypes::RatWeightList& d_rwl, size_t r)

/*
  Synopsis: puts in q the matrix of a Smith basis for the lattice orthogonal
  to d_rwl, and in invf the corresponding invariant factors.

  Precondition: r is the dimension of the elements of d_rwl.

  Explanation: here the elements of d_rwl are interpreted as elements of finite
  order in the torus (more precisely, the order divides the denominator.) So
  "orthogonal" means sending the rational vector to an integer.

  Algorithm: reduce all the vectors to a common denominator d; then we have
  the problem of finding a basis for the lattice that takes a given bunch
  of vectors into d.Z. Find a Smith normal basis for the bunch; this reduces
  to the case where the given vectors are multiples of some of the basis
  vectors, so the condition is a congruence condition on the corresponding
  coordinates. Example: if we reduce to 2e_1, 3e_2, and d = 6, we get that
  lambda_1 must be multiple of 3, lambda_2 multiple of 2.

  NOTE: this is a sloppy implementation; we don't worry about overflow.
*/

{
  using namespace arithmetic;
  using namespace lattice;
  using namespace latticetypes;
  using namespace matrix;
  using namespace smithnormal;

  // reduce to same denominator
  RatWeightList rwl;
  toCommonDenominator(rwl,d_rwl);

  // make matrix of numerator vectors
  LatticeMatrix m;
  numeratorMatrix(m,rwl);

  // smith-normalize
  WeightList b;
  initBasis(b,r);

  CoeffList linvf;
  smithNormal(linvf,b.begin(),m);

  // write matrix
  q = LatticeMatrix(b).inverse().transposed();

  // write invariant factors of orthogonal lattice
  invf.resize(b.size(),1UL);

  if (rwl.size()) {
    unsigned long d = rwl[0].denominator();
    for (size_t j = 0; j < linvf.size(); ++j) {
      unsigned long c = linvf[j];
      c = gcd(c,d);
      invf[j] = d/c;
    }
  }

  return;
}

std::ostream& printCenter(std::ostream& strm, const latticetypes::CoeffList& u)

/*
  Synposis: prints the sencter of the simply connected group.

  Precondition: u contains the necessary data: the orders of a natural set of
  generators for the center of the derived group, and a zero for each torus
  factor.
*/

{
  for (size_t j = 0; j < u.size(); ++j) {
    if (u[j]) {
      strm << "Z/";
      strm << u[j];
    } else {
      strm << "Q/Z";
    }
    if (j < u.size()-1)
      strm << ".";
  }

  return strm;
}

void readGenerator(latticetypes::RatWeight& v,
		   const latticetypes::CoeffList& u,
		   input::InputBuffer& buf)

/*
  Synopsis: reads a generator from buf to v.

  Precondition: checkGenerator returns NoError on buf; v has been initialized
  with the correct denominator, as provided by checkGenerator;
*/

{
  using namespace latticetypes;

  LatticeCoeff d = v.denominator();

  for (size_t j = 0; j < v.size(); ++j) {

    LatticeCoeff a = 0;
    buf >> a;

    char x;
    buf >> x; // get rid of / sign

    LatticeCoeff b;
    buf >> b;
    v.numerator()[j] = d/b;
    v.numerator()[j] *= a;

    buf >> x; // get rid of the comma-separator
  }

  return;
}

}

}
