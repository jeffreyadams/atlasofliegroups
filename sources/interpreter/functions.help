operators +, -, *: (int,int->int): usual integer arithmetic operations
operator - : (int->int): integral unary minus
operator ^ : (int,int->int): integer exponentiation (whenever result integral)
operators \, % : (int,int->int): integer (Euclidian) division and remainder
operator \% :(int,int->int,int): Euclidian division with remainder
operators +, -, *, / : (rat,rat->rat): usual rational arithmetic operations
operator - : (rat->rat): rational unary minus
operator / : (rat->rat): rational unary divide (in other words: inverse)
operator ^ : (rat,int->rat): rational exponentiation (whenever result defined)
operator % : (rat->int,int): pair of numerator and denominator
operator * : (mat,vec->vec): matrix-vector product.
operator * : (mat,mat->mat): matrix-matrix product.
operator * : (vec,mat->mat): vector-matrix product (vector is transposed)
operator ^ : (mat->mat): (unary use of ^) matrix transpostion
operator ^ : (vec->mat): (unary use of ^) (transposed) vector as 1-line matrix
operator / : (vec,int->ratvec): vector division giving rational vector
operator % : (ratvec->vec,int): pair of numerator vector and denominator
operators +, -: (ratvec,ratvec->ratvec): additive rational vector arithmetic

operators >, >=, <, <=, =, != : (int,int->bool): usual relational operators
operators >, >=, <, <=, =, != : (rat,rat->bool): usual relational operators
operators =, != : (bool,bool->bool): Boolean equivalence, inequivalence (xor)
operators =, != : (string,string->bool): string equality and inequality
operators =, != : (vec,vec->bool): vector equality and inequality
operators =, != : (mat,mat->bool): matrix equality and inequality

operator # : (string->int) : length of string
operator # : (vec->int) : number of components of vector
operator # : (mat->int,int) : dimensions (rows*columns) of a matrix
operator # : ([T]->int) : number of components of row (T is any type)

operator # : (string,string->string): string concatenation
operator # : (vec,vec->vec) : concatenation of vectors
operator # : (vec,int->vec) : append element to a vector
operator # : (int,vec->vec) : prepend element to a vector
operator # : ([T],[T]->[T]) : concatenation of rows (T is any type)
operator # : ([T],T->[T]) : append element to a row (T is any type)
operator # : (T,[T]->[T]) : prepend element to a row (T is any type)


error: (string->*) : abort computation, reporting a runtime error

int_format: (int->string): representation of integer as digit string
print: (*->*): print value, followed by newline; return same value
prints: (*,...->): print values raw (no quotes or commas) followed by newline

null: (int->vec): null vector of given length
null: (int,int->mat): null matrix with given number of rows and columns
id_mat: (int->mat): identity matrix of given size.
diagonal: (vec->mat): square diagonal matrix with given diagonal entries.

echelon: (mat->mat,[int]): make column echelon form, and return pivots as well
  This applies column operations, and possibly removal of null columns; the
  number of remaining columns is the rank. The result is a pair (M,s) with s
  increasing sequence, and M[i,j] is nonzero for i=s[j] and zero for i>s[j]
diagonalise: (mat->vec,mat,mat): partial Smith reduction, without divisibility
  Applies row and column operations to the matrix to obtain diagonal form;
  returns the list of non-zero diagonal entries (all except the first are
  assured to be positive), and the pair of determinant 1 integral matrices
  that have been applied to left and right respectively.
adapted_basis: (mat->mat,vec): find basis whose integer multiples span image
  Returns for M a pair (B,c) of a basis (as columns of B) and matching list c
  of integers, such that the column span of M is the same as the span of the
  multiples c_j*B_j of the columns B_j of the matrix B by the scalars c_j
kernel: (mat->mat): find matrix whose columns span kernel of the given matrix
eigen_lattice: (mat,int->mat): eigen-lattice of matrix (at integer eigenvalue)
  eigen_lattice(M,lambda) = kernel(M-lambda*id_mat(n)), where #M=(n,n)
row_saturate: (mat->mat): keep same kernel, but row-span saturated sublattice
  Interpreting rows of the matrix as linear forms, this transforms the system
  into an equivalent one, and whose Z-linear application is made surjective.
  In other words, the rows are made linearly independent, and the sublattice
  they generate saturated: if an integer multiple of v is in it, then so is v.

inv_fact: (mat->vec): invariant factors in Smith normal form (no zeros).
Smith_basis: (mat->mat): a basis on which the Smith normal form is assumed.
Smith: (mat->mat,vec): Smith(M)= ( Smith_basis(M), inv_fact(M) ) (almost).
  Smith(M) describes explicitly the sublattice spanned by the columns of M.
  The first component is an invertible matrix, whose columns, multiplied by
  the corresponding entries of the second component, span that sublattice.
  inv_fact(M) is the list of the invariant factors of M, which are like the
  second component of Smith but with additional requirement that each one
  divides the next; this may involve using a different basis. Smith_basis(M)
  is that basis corresponding to inv_fact(M), an invertible (over Z) square
  matrix of height equal to that of M, with the same property as the first
  component of Smith but relative to the true invariant factors inv_fact(M).

invert: (mat->mat,int): invert(M)=inv,d such that M*inv=d*Id, with d minimal.
  The inverse matrix, represented as an integral numerator matrix and a
  minimal common denominator

Lie_type: (string->LieType): interpret string as Lie type.
  Factors are one of "ABCDEFGT" followed by a number; several factors can be
  concatenated in a string with optional punctuation. Must have total rank<=16
Lie_type: (RootDatum->LieType): Lie type of a root datum.

Cartan_matrix: (LieType->mat): Cartan matrix of Lie type (square of size rank).
  A block form Cartan matrix, with zeros in rows and columns of torus factors
Cartan_matrix: (RootDatum->mat): Cartan matrix of root datum.
  This pairs roots and coroots, so it is square of size the semisimple rank

Cartan_matrix_type: (mat->LieType,vec): type given by Cartan matrix.
  The input should be a Cartan matrix for a semisimple type (no zero rows or
  columns). The function returns the semisimple type, and the permutation of
  mapping the standard (Bourbaki) ordering of the diagram of that type to the
  ordering of the corresponding simple roots in matrix rows and columns.

rank: (LieType->int) Rank of the weight lattice for this Lie type.
semisimple_rank: (LieType->int) Rank of the root lattice of  this Lie type.
nr_factors: (LieType->int) Number of (simple or T1) factors in this Lie type

Smith_Cartan: (LieType->mat,vec): compute generators of weights modulo roots.
  Find a Smith basis for the weight lattice relative to the sublattice of
  roots, with corresponding invariant factors; almost equivalent to
  Smith(^Cartan_matrix(type)), except that (1) each simple or
  torus factor is normalised separately, (2) for torus factors there is
  a '1' is on the diagonal and a '0' appears as invariant factor, and (3) for
  factors D_{2n} an equivalent basis is given, which has been tweaked so that
  the final two vectors are standard basis vectors

filter_units: (mat,vec->mat,vec): discard entries '1' and their columns.
  The input is presumably produced by 'Smith_Cartan'; all entries '1' in the
  vector and the corresponding columns of the matrix are thrown away

ann_mod: (mat,int->mat): find maximal matrix with product divisible by d.
  The call ann_mod(M,d) finds a square matrix A whose columns have the same
  height as those of M and span a maximal sublattice subject to the condition
  that the scalar product of every column of A with every column of M is
  divisible by d (the matrix product ^A*M vanishes modulo d).

replace_gen: ((mat,vec),mat->mat): replace generators of weight lattice.
  For every entry different from '1' in the vector argument, replace a column
  from the first matrix by a column from the second matrix

involution: (LieType,string->mat): diagram involution for inner class.
  Return an involution matrix corresponding to the diagram involution
  described symbolically by the string, which is interpreted as the inner
  class string is in the Atlas, where 'e' or 'c' mean compact (equal rank),
  'u' means unequal rank (for types A_n with n>1, D_n and E_6), 's' means
  split and 'C' means Complex. This is essentially a permutation matrix,
  except that for the split type on torus factors there is a diagonal entry -1
involution: (LieType,mat,string->mat): basic involution on given basis.
  This is like previous 'involution' for the same Lie type and inner class
  string, but the involution matrix is now expressed the given basis given by
  the columns of the matrix specified as second argument; this expression must
  be possible, so the sublattice spanned should be stable under the involution

root_datum: (LieType,mat->RootDatum): root datum for given type and sublattice.
  The columns of the matrix argument are interpreted as specifying the basis
  of a sublattice of the character lattice of the "simply connected" group G
  of the given Lie type (which is a direct product of a simply connected
  semisimple group G' and a central torus S), expressed in the basis of
  fundamental weights of G' and an arbitrary basis for characters of S). For
  this to be possible, it is required that the sublattice contain the root
  lattice of G'. The sublattice becomes the standard lattice for working with
  the root datum, and is identified with Z^n using the given basis, which thus
  becomes the standard basis of the sublattice, henceforth called lattice.
root_datum: ([vec],[vec],int->RootDatum): root datum from simple (co)roots.
  In root_datum(roots,coroots,r), the list of vectors roots and coroots must
  have the same length (the semisimple rank), and each of their elements
  should have size r (which argument is necessary in case the lists are
  empty). A root datum is returned in which roots are the simple roots
  expressed in some basis of the character lattice, and coroots are the simple
  coroots expressed in the dual basis of the cocharacter lattice. For this to
  be possible, it is necessary and sufficient that the matrix of scalar
  products of the proposed simple roots with the proposed simple coroots form
  a valid Cartan matrix (if not the function call fails)
root_datum: (InnerClass->RootDatum): root datum of inner class.
  Extract the root datum from the InnerClass value

quotient_basis: (LieType,[ratvec]->mat): sublattice given by kernel generators.
  Interpret the rational vectors as kernel generators for the given type, as
  in the Atlas software, and return the corresponding sublattice as a matrix
  whose column are its generators; if M is the matrix whose columns are the
  numerators of the kernel generators, brought to a common denominator d, this
  amounts to setting S=Smith_Cartan(type); (C,v)=filter_units(S) and then
  returning the value replace_gen(S,mm_prod(C,ann_mod(M,d)))

root_datum: (LieType,[ratvec]->RootDatum): root datum as entrered in Atlas.
    set root_datum(LieType type,[ratvec] gens) =
    root_datum(type,quotient_basis(type,gens))

simply_connected: (LieType->RootDatum): simply connected datum for given type.
  This gives the root datum for the "simply connected" group of the given
  type (the direct product of a simply conneted G' with a central torus):
    set simply_connected_datum(LieType type) = root_datum(type,id_mat(rank))

adjoint: (LieType->RootDatum): adjoint root datum for given type.
  Here the sublattice for the semisimple factor is the root lattice, with
  simple roots as basis; for the central torus an arbitrary basis is used.
  Therefore the this function could be defined as
    set adjoint_datum(LieType type) =
    let M= for alpha@j in ^Cartan_matrix(type)
           do for entry@i in alpha
              do if i=j and entry=0 then 1 else entry fi
              od
           od
    in root_datum(type,M)

SL: (int->RootDatum): SL(n) gives root datum for SL(n,C).
  Make this root datum using the most pleasant "epsilon" basis for sub-lattice
GL: (int->RootDatum): GL(n) gives root datum for GL(n,C).
  Make this root datum using the most pleasant "epsilon" basis for sub-lattice

simple_roots: (RootDatum->mat): matrix of simple roots in the root datum.
simple_coroots: (RootDatum->mat): matrix of simple coroots in the root datum.
roots: (RootDatum->mat): set of roots in the root datum (columns of result).
coroots: (RootDatum->mat): set of coroots in the root datum (as columns).
root_coradical: (RootDatum->mat): simple roots and coradical basis.
  With respect to simple_roots, add columns for coradical basis generators
coroot_radical: (RootDatum->mat): simple coroots and radical basis.
  With respect to simple_coroots, add columns for radical basis generators
dual: (RootDatum->RootDatum): dual of given root datum.
rank: (RootDatum->int) Rank of the weight lattice for this Lie type.
semisimple_rank: (RootDatum->int) Rank of the root lattice of  this Lie type.

integrality_datum: (RootDatum,ratvec->RootDatum): integral coroots subdatum
  Forms the root datum for the coroot subsystem of coroots that take an
  integral value on the given ration vector.

integrality_points: (RootDatum,ratvec->[rat]): fractions with integrality
  The call integrality_points(rd,lambda) returns the increasing list of
  positive fractions f<=1 so f*lambda has more integrality than generically:
  for some coroot alphav one has integral and nonzero value <f*lambda,alphav>.

classify_involution: (mat->int,int,int): determine type of lattice involution
  For any linear involution of Z^n, there is a basis consisting of certain
  vectors that are eigenvectors with eigenvalues 1 or -1 for the involution,
  and of pairs of vectors that are interchanged by the involution. The numbers
  of such vectors for each eigenvalue and of interchanged pairs determine the
  involution up to base change. This function, which requires its argument to
  be the matrix of an involution, returns these three numbers in the following
  order: eigenvectors for 1 (compact rank), pairs of interchanged vectors
  (Complex rank), eigenvectors for -1 (split rank).

inner_class: (RootDatum,mat->InnerClass): inner_class of G from involution
  This is the basic function for building a complex reductive group equipped
  with an involution from the root datum and that involution; the latter is
  given on the lattice basis of the root datum, and must describe an
  involutive automorphism of the root datum. The involution is converted to a
  based root datum involution if necessary, using the Weyl group.
twisted_involution (RootDatum,mat->InnerClass,vec): inner_class and Weyl word
  Build an inner class as the above function, and also return a Weyl word
  (twisted involution) that expresses the given involution in that inner class
inner_class: (RootDatum,string->InnerClass): get inner class of G symbolically
  Build a complex reductive group directly from a root datum, but compute
  the distinguished involution from the string describing it symbolically.
    set inner_class(RootDatum rd,string type)=
    let t=Lie_type(rd); basis = ^coroot_radical(rd)
    in inner_class(rd,involution(t,basis,type))
inner_class: (Lie_type,[ratvec],string->InnerClass): inner class as in Atlas
    set inner_class(Lie_type lt,[ratvec] gens,string ic_string) =
    let basis=quotient_basis(lt,gens)
    ; rd=root_datum(lt,basis), inv=based_involution(lt,basis,ic_string)
    in inner_class(rd,inv).

distinguished_involution: (InnerClass->mat): involution of the inner class.
  Extract the distinguised involution from the InnerClass value
dual: (InnerClass->InnerClass): dual inner class for dual complex group

nr_of_real_forms: (InnerClass->int): number of real forms in inner class
nr_of_dual_real_forms: (InnerClass->int): number of dual forms in inner class
nr_of_Cartan_classes: (InnerClass->int): total number of Cartans in inner class

block_sizes: (InnerClass->mat): matrix giving the block sizes.
  This is essentially the same as the output of 'blocksizes' in Atlas; the
  rows of the matrix correspond to real forms for the inner class, and the
  columns correspond to dual real forms for the inner class

form_names: (InnerClass->[string]): list of names of real forms.
  These are the same names used in atlas, describing real Lie algebras
dual_form_names: (InnerClass->[string]): ist of names of dual real forms.
  These are the names for the real forms of the dual InnerClass value

occurrence_matrix: (InnerClass->mat): real form-Cartan class incidence matrix
  For the given inner class, construct a matrix whose rows are parametrized by
  the real forms, and whose columns are parametrized by the Cartan classes,
  showing whether (1) or not (0) the Cartan class occurs for the real form
dual_occurrence_matrix: (InnerClass->mat): dual real form-Cartan class matrix
  This is like occurrence_matrix, but with rows representing dual real forms

real_form: (InnerClass,int->RealForm): select a real form from inner class.
  The result of form_names describes the valid range and names of real forms;
  this function actually constructs a real form from the list, selected by its
  position (starting from 0). The list is always the same for a given inner
  class (independent of other computations), unlike the list of Cartan classes
  for a real form as discussed below
real_form: (DualRealForm->RealForm): interpret dual real form as real form
  This function allows a DualRealForm value to be interpreted as a real form
  for the dual group (and dual inner class), so that functions like KGB_size
  can be applied to the result

quasisplit_form: (InnerClass->RealForm): quasisplit form for the inner class
  This is the last one in the list of real forms for the inner class

components_rank: (RealForm->int): rank of the component group
  The group of connected components of the real Lie group defined by a real
  form is an elementary 2-group (Z/2Z vector space); this function gives its
  rank, so the number of connected components is 2^components_rank(rf)

count_Cartans: (RealForm->int): number of Cartan classes for this real form
  The Cartan classes are actually constructed, and remembered, by this command
  whence its first execution for some real form may take some time

KGB_size: (RealForm->int): size of the set K\G/B for this real form

Cartan_order: (RealForm->mat): matrix describing ordering of Cartan classes
  The Cartan classes for a given real form form a partially ordered set; this
  function returns this partial ordering in the form of a square 0-1 matrix

dual_real_form: (InnerClass,int->DualRealForm): select a dual real form
  This is like real_form, but selects a dual real form for the inner class
  (whose names are given by dual_form_names) by index, which is given type
  DualRealForm. This is intended for functions that require both a real form
  and a dual real form for a given inner class
dual_quasisplit_form: (InnerClass->DualRealForm): quasisplit dual real form

Cartan_class: (InnerClass,int->CartanClass): Cartan class selected by number
  This selects a Cartan class by number in the list of all Cartan classes for
  this inner class. The numbering is fixed, and compatible with  the partial
  ordering on Cartan classes where more split ones are considered greater

Cartan_class: (RealForm,int->CartanClass): Cartan class selected by number
  This selects a Cartan class by number in the list of Cartan classes defined
  for this real form. The numbering is not the same as when selecting a Cartan
  class directly from an inner class, unless the real form is quasisplit.

most_split_Cartan: (RealForm->CartanClass): most split Cartan class for form
  The most split Cartan class of a given real form is the last one in the list
  of its Cartan classes, so
    set most_split_Cartan(RealForm rf)=Cartan_class(rf,count_Cartans(rf)-1)

print_Cartan_info: (CartanClass->): print information about the Cartan class
  This produces essentially the output of 'cartan' in the Atlas, except for
  the final partition corresponding to the real forms for this Cartan class.
  So it prints the number of split (GL(1,R)), compact (U(1)) and complex
  (GL(1,C)) factors of the real torus defined by this Cartan class, the number
  of distinct twisted involutions defining this same Cartan class, and the
  types of the imaginary, real, and complex root subsystems

real_forms: (CartanClass->[RealForm]): list of real forms with given Cartan
  Returns a list of the real forms for which this Cartan class occurs
dual_real_forms: (CartanClass->[DualRealForm]): list Cartan's dual real forms
  Returns a list of the dual real forms for which this Cartan class occurs

fiber_part: (CartanClass,RealForm->[int]): part of fiber group for real form
  This produces an increasing sequence of integers that characterizes the real
  form relative to the CartanClass. It describes a part of the adjoint fiber
  group associated to the Cartan class (and elementary 2-group of rank r equal
  to the number of compact factors of the real torus in the adjoint group
  defined by the Cartan class), whose elements are represented by numbers 0 to
  2^r-1; as the real form traverses all those for which this Cartan class
  occurs, the results of the function form a partition of that set of numbers.

KGB: (RealFrom,int->KGBElt): select a KGB element x among those of a real form
  The call KGB(i,rf) selects the element in line i of the print_KGB(rf)
  output.
real_form: (KGBElt->RealForm): the real form for which the argument is defined
involution: (KGBElt->mat): the involution associated to the KGB element

param: (KGBElt,vec,ratvec->Param): form parameter from (x,lambda-rho,nu)
operator %: (Param->KGBElt,vec,ratvec): recover (x,lambda-rho,nu) from param
infinitesimal_character: (Param->ratvec): infinitesimal character of parameter
is_standard: (Param->bool): whether parameter defines a standard module
is_zero: (Param->bool): whether parameter defines a zero standard module
is_final: (Param->bool): whether parameter defines a zero standard module
orientation_nr: (Param->int): the orientation number
dominant: (Param->Param): make gamma dominant and do singular complex descents
operator =: (Param,Param->bool): test equivalence of parameters
  This is implemented by applying make_dominant and testing identity of all
  three components x, lambda (defined modulo (1-theta_x)X^*) and nu.
print_n_block: (Param->): print (nonintegral) block generated from parameter
n_block: (Param->[Param],int): return block as list of parameters, and index
  The second component is the index into the first of the original parameter.
deform: (Param->[(int,Param)]): compute deformation terms when nu decreases
  The non-integral block for the parameter and its KL polynomials are
  computed, from which the deformation terms involing other members of the
  block are computed. They are returned as a list of (coefficient,parameter)
  pairs, where the coefficient gives the multiple of (1-s) in the formula.

null_module: (RealForm->ParamPol): empty sum of parameters for the real form
operator +: (ParamPol,Param->ParamPol): add parameter to formal sum
operator +: (ParamPol,(int,Param)->ParamPol): add parameter with coefficient
operator +: (ParamPol,[(int,Param)]->ParamPol): add terms to formal sum
operator %: (ParamPol->[(int,Param)]): break up formal sum into terms

raw_KL: (RealForm,DualRealForm->mat,[vec],vec): Kazhdan-Lusztig data, raw form
  The call raw_KL(rf,drf) produces a matrix of numbers identifying
  polynomials, a list of those polynomials in the form of coefficient vectors,
  and a sequence of length boundaries that allow deducing the "lengths" of the
  integers used to index the matrix. These integers identify block elements
  for the block print_block(rf,drf). If (M,L,len)=raw_KL(rf,drf), and v,w are
  integers identifying block elements, then the vector L[M[v,w]] gives the
  coefficients of the KL polynomial P_{v,w}. The length of v is the lergest
  index i such that len[i]<=v, so the length difference between v and w is the
  number of indices with v<len[i]<=w.

print_gradings: (CartanClass,RealForm->): print gradings defined by real form
  This more or less gives the output of the 'gradings' command in the Atlas
  software, for the selected real form. The type of the imaginary root system
  is printed, with the numbers of the roots that span this root subsytem as
  simple roots, in the Bourbaki ordering for its type. Then for each element
  in the list produced by fiber_part for the same arguments, the grading of
  the imaginary root system is given as a sequence of bits 0 (compact) or 1
  (non-compact), to be interpreted on the simple roots in the given order, and
  extended to the whole imaginary root subsystem as a Z/2Z grading.

print_real_Weyl: (RealForm,CartanClass->)
print_strong_real: (CartanClass->)

print_block: (RealForm,DualRealForm->):
print_blocku: (RealForm,DualRealForm->):
print_blockd: (RealForm,DualRealForm->):
print_blockstabilizer: (RealForm,DualRealForm,CartanClass->):
print_KGB: (RealForm->):
print_KL_basis: (RealForm,DualRealForm->): :print_KL_basis:
print_prim_KL: (RealForm,DualRealForm->): :print_prim_KL:
print_KL_list: (RealForm,DualRealForm->): :print_KL_list:
print_W_cells: (RealForm,DualRealForm->): :print_W_cells:
print_W_graph: (RealForm,DualRealForm->):
  These commands give the output of the corresponding commands of the Atlas
  software. It is required that the real form and dual real form (and in
  relevant cases the Cartan class) be associated to the same inner class,
  and that they have at least one Cartan class (respectively the given Cartan
  class) in common.

test_rep (KGBElt,vec,ratvec->): print the global dual KGB for this parameter
