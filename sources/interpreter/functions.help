vec: (vec->vec): identity function on vectors.
mat: (mat->mat): identity function on matrices.
print: (string->): print string without quotes, followed by newline
id_mat: (int->mat): identity matrix of given size.
transpose_mat: (mat->mat): matrix transposition.
diagonal_mat: (vec->mat): square diagonal matrix with given diagonal entries.
mv_prod: (mat,vec->vec): matrix-vector product.
mm_prod: (mat,mat->mat): matrix-matrix product.

inv_fact: (mat->vec): invariant factors in Smith normal form (no zeros).
Smith_basis: (mat->mat): a basis on which the Smith normal form is assumed.
Smith: (mat->mat,vec): Smith(M)= ( Smith_basis(M), inv_fact(M) ).
  Smith(M) describes explicitly the sublattice spanned by the columns of M.
  inv_fact(M) is the list of invariant factors, each one dividing the next,
  and Smith_basis(M) a square matrix of height equal to that of M and
  determinant 1, such that multiplying each column corresponding to an
  invariant factor by that factor, and the remaining ones by 0, gives a matrix
  whose columns span the same lattice as the columns of M.

invert: (mat->mat,int): invert(M)=inv,d such that M*inv=d*Id, with d minimal.
  The inverse matrix, represented as an integral numerator matrix and a
  minimal common denominator

Lie_type: (string->LieType): interpret string as Lie type.
  Factors are one of "ABCDEFGT" followed by a number; several factors can be
  concatenated in a string with optional punctuation. Must have total rank<=16

Cartan_matrix: (LieType->mat): Cartan matrix of Lie type (square of size rank).
  A block form Cartan matrix, with zeros in rows and columns of torus factors

type_of_Cartan_matrix: (mat->LieType): semisimple type given by Cartan matrix.
  The input should be a Cartan matrix without zero rows or columns, otherwise
  this function gets confused

Smith_Cartan: (LieType->mat,vec): compute generators of weights modulo roots.
  Find a Smith basis for the weight lattice relative to the sublattice of
  roots, with corresponding invariant factors; almost equivalent to
  Smith(transpose_mat(Cartan_matrix(type))), except that (1) each simple of
  torus factor is normalised separately, (2) for torus factors there is
  a '1' is on the diagonal and a '0' appears as invariant factor, and (3) for
  factors D_{2n} an equivalent basis is given, which has been tweaked so that
  the final two vectors are standard basis vectors

filter_units: (mat,vec->mat,vec): discard entries '1' and their columns.
  The input is presumably produced by 'Smith_Cartan'; all entries '1' in the
  vector and the corresponding columns of the matrix are thrown away

ann_mod: (mat,int->mat): find maximal matrix with product divisible by d.
  The call ann_mod(M,d) finds a square matrix A whose columns have the same
  height as those of M and span a maximal sublattice subject to the condition
  that the scalar product of every column of A with every column of M is
  divisible by d (the matrix product transpose_mat(A)*M vanishes modulo d).

replace_gen: ((mat,vec),mat->mat): replace generators of weight lattice.
  For every entry different from '1' in the vector argument, replace a column
  from the first matrix by a column from the second matrix

quotient_basis: (LieType,mat->mat): sublattice given by kernel generators.
  Interpret the columns of the matrix as denominators of the kernel generators
  as one would input in the Atlas software for the given type (the
  denominators are imposed, except for torus factors, where the least common
  multiple d of all imposed columns is taken), and return the corresponding
  sublattice as a matrix whose column are its generators; if M' is the matrix
  adjusted for bringing everything on a common denominator d, this amounts to
  setting S=Smith_Cartan(type); C,v=filter_units(S) and then returning the
  value replace_gen(S,mm_prod(C,ann_mod(M',d)))

basic_involution: (LieType,string->mat): diagram involution for inner class.
  Return an involution matrix corresponding to the diagram involution
  described by the string, which is interpreted as the inner class string is
  in the Atlas; this is essentially a permutation matrix, except that for the
  split type on torus factors there is a diagonal entry -1

based_involution: (LieType,mat,string->mat): basic involution on given basis.
  This is like basic_involution for the same Lie type and inner class string,
  but the involution matrix is now expressed the given basis given by the
  columns of the matrix specified as second argument; this expression must be
  possible, so the sublattice spanned should be stable inder the involution

root_datum: (LieType,mat->RootDatum): root datum for given type and sublattice.
type_of_root_datum: (RootDatum->LieType): Lie type of a root datum.
  This may differ from original type, by torus factors being moved to the end

quotient_datum: (LieType,mat->RootDatum): root datum as entrered in Atlas.
  quotient_datum(type,gens)=root_datum(type,quotient_basis(type,gens))

simply_connected_datum: (LieType->RootDatum): simply connected datum for type.
  simply_connected_datum(type) = root_datum(type,id_mat(rank))

adjoint_datum: (LieType->RootDatum): adjoint root datum for type.
  adjoint_datum(type) = root_datum(type,transpose_mat(Cartan_matrix(type))),
  except that diagonal entries '1' are inserted for torus factors

SL: (int->RootDatum): SL(n) gives root datum for SL(n,C).
  Make this root datum using the most pleasant "epsilon" basis for sub-lattice
GL: (int->RootDatum): GL(n) gives root datum for GL(n,C).
  Make this root datum using the most pleasant "epsilon" basis for sub-lattice

simple_roots: (RootDatum->mat): matrix of simple roots in the root datum.
simple_coroots: (RootDatum->mat): matrix of simple coroots in the root datum.
Cartan_matrix_of_datum: (RootDatum->mat): Cartan matrix of root datum.
  This pairs roots and coroots, so it is square of size the semisimple rank
roots: (RootDatum->mat): set of roots in the root datum (columns of result).
coroots: (RootDatum->mat): set of coroots in the root datum (as columns).
root_coradical: (RootDatum->mat): simple roots and coradical basis.
  With respect to simple_roots, add columns for coradical basis generators
coroot_radical: (RootDatum->mat): simple coroots and radical basis.
  With respect to simple_coroots, add columns for radical basis generators
dual_datum: (RootDatum->RootDatum): dual of given root datum.

classify_involution: (mat->int,int,int): determine type of lattice involution
  For any linear involution of Z^n, there is a basis consisting of certain
  vectors that are eigenvectors with eigenvalues 1 or -1 for the involution,
  and of pairs of vectors that are interchanged by the involution. The numbers
  of such vectors for each eigenvalue and of interchanged pairs determine the
  involution up to base change. This function, which requires its argument to
  be the matrix of an involution, returns these three numbers in the following
  order: eigenvectors for 1 (compact rank), pairs of interchanged vectors
  (Complex rank), eigenvectors for -1 (split rank).

fix_involution: (RootDatum,mat->InnerClass): define G by involution matrix.
  This is the basic function for building a complex reductive group equipped
  with a distinguished involution from the root datum and that involution;
  the involution must be on the (sub-)lattice basis of the root datum, and it
  is checked for describing an involutive automorphism of the based root datum

set_type: (string,mat,string->InnerClass): define G as in Atlas interface.
  The call set_type(type_string,gens,inner_class) essentially sets
  t=Lie_type(type_string); basis=quotient_basis(t,gens), and then returns
  fix_involution(root_datum(t,basis),inner(t,basis,inner_class))

set_inner_class: (RootDatum,string->InnerClass): define G by inner class.
  Build a complex reductive group directly from a root datum, but compute
  the distinguished involution using an inner class string;
  set_inner_class(rd,inner_class) is essentially computed by setting
  t=type_of_root_datum(rd); basis=transpose_mat(coroot_radical(rd)), and then
  returning fix_involution(rd,inner(t,basis,inner_class))

distinguished_involution: (InnerClass->mat): involution of the inner class.
  Extract the distinguised involution from the InnerClass value
root_datum_of_inner_class: (InnerClass->RootDatum): root datum of inner class.
  Extract the root datum from the InnerClass value
dual_inner_class; (InnerClass->InnerClass): dual inner class for dual group

block_sizes: (InnerClass->mat): matrix giving the block sizes.
  This is essentially the same as the output of 'blocksizes' in Atlas; the
  rows of the matrix correspond to real forms for the inner class, and the
  columns correspond to dual real forms for the inner class

form_names: (InnerClass->[string]): list of names of real forms.
  These are the same names used in atlas, describing real Lie algebras
dual_form_names: (InnerClass->[string]): ist of names of dual real forms.
  These are the names for the real forms of the dual InnerClass value

real_form: (InnerClass,int->RealForm): select a real form from inner class.
  The result of form_names describes the valid range and names of real forms;
  this function actually constructs a real form from the list, selected by its
  position (starting from 0). The list is always the same for a given inner
  class (independent of other computations), unlike the list of Cartan classes
  for a real form as discussed below
quasisplit_form: (InnerClass->RealForm): quasisplit form for the inner class
  This is the last one in the list of real forms for the inner class

components_rank: (RealForm->int): rank of the component group
  The group of connected components of the real Lie group defined by a real
  form is an elementary 2-group (Z/2Z vector space); this function gives its
  rank, so the number of connected components is 2^components_rank(rf)

count_Cartans: (RealForm->int): number of Cartan classes for this real form
  The Cartan classes are actually constructed, and remembered, by this command
  whence its first execution for some real form may take some time

KGB_size: (RealForm->int): size of the set K\G/B for this real form

dual_real_form: (InnerClass,int->DualRealForm): select a dual real form
  This is like real_form, but selects a dual real form for the inner class
  (whose names are given by dual_form_names) by index, which is given type
  DualRealForm. This is intended for functions that require both a real form
  and a dual real form for a given inner class
dual_quasisplit_form: (InnerClass->DualRealForm): quasisplit dual real form

real_form_from_dual: (DualRealForm->RealForm): convert dual real form
  This function allows a DualRealForm value to be interpreted as a real form
  for the dual group (and dual inner class), so that functions like KGB_size
  can be applied to the result

Cartan_class: (RealForm,int->CartanClass): Cartan class selected by number
  This constructs all Cartan classes for this real form, and then selects the
  one with the given sequence number. The numbering of the Cartan classes for
  a given real form may depend on computation of Cartan classes for other real
  forms in the same inner class: those Cartan classes that have already been
  constructed for other real form come first in the sequence

most_split_Cartan: (RealForm->CartanClass): most split Cartan class for form
  The most split Cartan class of a given real form is the last one in the list
  of its Cartan classes (so it is Cartan_class(rf,count_Cartans(rf)-1)

occurrence_matrix: (InnerClass->mat): real form-Cartan class incidence matrix
  For the given inner class, construct a matrix whose rows are parametrized by
  the real forms, and whose columns are parametrized by the Cartan classes,
  showing whether (1) or not (0) the Cartan class occurs for the real form
dual_occurrence_matrix: (InnerClass->mat): dual real form-Cartan class matrix
  This is like occurrence_matrix, but with rows representing dual real forms

Cartan_order_matrix: (RealForm->mat): matrix for ordering of Cartan classes
  The Cartan classes for a given real form form a partially ordered set; this
  function returns this partial ordering in the form of a square 0-1 matrix

print_Cartan_info: (CartanClass->): print information about the Cartan class
  This produces essentially the output of 'cartan' in the Atlas, except for
  the final partition corresponding to the real forms for this Cartan class.
  So it prints the number of split (GL(1,R)), compact (U(1)) and complex
  (GL(1,C)) factors of the real torus defined by this Cartan class, the number
  of distinct twisted involutions defining this same Cartan class, and the
  types of the imaginary, real, and complex root subsystems

fiber_part: (CartanClass,RealForm->[int]): part of fiber group for real form
  This produces an increasing sequence of integers that characterizes the real
  form relative to the CartanClass. It describes a part of the fiber group
  associated to the Cartan class (and elementary 2-group of rank r equal to the
  number of compact factors of the real torus in the adjoint group defined by
  the Cartan class), whose elements are represented by numbers 0 to 2^r; as
  the real form traverses all those for which this Cartan class occurs, the
  results of the function form a partition of that set of numbers.

print_gradings: (CartanClass,RealForm->): print gradings defined by real form
  This more or less gives the output of the 'gradings' command in the Atlas
  software, for the selected real form. The type of the imaginary root system
  is printed, with the numbers of the roots that span this root subsytem as
  simple roots, in the Bourbaki ordering for its type. Then for each element
  in the list produced by fiber_part for the same arguments, the grading of
  the imaginary root system is given as a sequence of bits 0 (compact) or 1
  (non-compact), to be interpreted on the simple roots in the given order, and
  extended to the whose root subsystem as a Z/2Z grading.

set_modulus: (int->): set modulus for coefficients in KL computations

print_block: (RealForm,DualRealForm->):
print_blocku: (RealForm,DualRealForm->):
print_blockd: (RealForm,DualRealForm->):
print_blockstabilizer: (RealForm,DualRealForm,CartanClass->):
print_KGB: (RealForm->):
print_KL_basis: (RealForm,DualRealForm->): :print_KL_basis:
print_prim_KL: (RealForm,DualRealForm->): :print_prim_KL:
print_KL_list: (RealForm,DualRealForm->): :print_KL_list:
print_W_cells: (RealForm,DualRealForm->): :print_W_cells:
print_W_graph: (RealForm,DualRealForm->):
  These commands give the output of the corresponding commands of the Atlas
  software. It is required that the real form and dual real form (and in case
  of blockstabilizer the Cartan class) be associated to the same inner class,
  and that they have at least one Cartan class (respectively the given Cartan
  class) in common.