Brief introduction to 'realex', the new interface to the Atlas software
'realex' stands for Rewritten Expression-based  Atlas of Lie groups EXecutable


1 Introduction

The program 'realex', built from the files in this directory and from a large
part of the source files of the 'atlas' program, provides access to its
functions in an expression-oriented fashion. Whereas 'atlas' will enter a
dialogue whenever it needs some parameter to be set (inner class, real form,
Cartan class,...) these parameters can be defined by expressions in 'realex'.
As a consequence such parameters can be more flexibly handled, results of
computations can be reused, and scripting and programming become possible.

To compile realex, you need the latest release of the 'cwebx' system, unless
the output files produced by 'cwebx' were already included in your copy of the
atlas sources; check the presence in atlas/sources/interpreter of the files
{buffer,built-in-types,evaluator,lexer,main,parsetree,types} with extensions
.cpp and (except for main) .h to see if this is the case. If these files do
not exist, get 'cwebx' by clicking on the indicated link at

http://www-math.univ-poitiers.fr/~maavl/CWEBx/

unpack in some directory, type make, then make sure that the resulting
programs 'ctanglex' and 'cweavex' are in your $PATH (possibly by making
symbolic links to them from you ~/bin directory, if you use one), and that the
macro file cwebxmac.tex is in some place where TeX will find it (check your
$TEXINPUTS environment variable; a quick solution is to copy the file to this
atlas/sources/interpreter directory). Once these tools are in place, the
'make' facility will automatically invoke them to create all the files
mentioned above when they are needed.

Apart from that, you need tools like (GNU) 'make', 'bison', and a compiler
like 'g++' which you already need to compile the atlas program (but contrary
to atlas, you need at least version 4.0 of gcc/g++ to compile realex, since
realex uses the TR1 library extension whose support was introduced in their
version 4.0). Once you are set, type 'make headers realex' in the
atlas/sources/interpreter directory (or 'make realex' in the atlas directory)
to build realex. Again you can install a symbolic link from somewhere in your
$PATH to atlas/sources/interpreter/realex to ensure that it will be executed
by the command 'realex'. If atlas was compiled before you build realex, the
latter compilation will use the existing object files; if not it will do the
necessary compilations itself (this involves nearly all atlas modules, but not
all), and take quite a bit longer.


2 Comparison with atlas

Consider for instance the following session

  $ atlas
  This is the Atlas of Reductive Lie Groups Software Package version...
  Enter "help" if you need assistance.

  empty: blocksizes
  Lie type: B5.A3.T1
  elements of finite order in the center of the simply connected group:
  Z/2.Z/4.Q/Z
  enter kernel generators, one per line
  (ad for adjoint, ? to abort):
  1/2,0/4,0/4
  0/2,2/4,2/4

  enter inner class(es): scc
	0      0      0      0      0      0      0      1
	0      0      0      0      0      0      0     11
	0      0      0      0      0      0      0     10
	0      0      0      0      0      0      0     75
	0      0      0      0      0      0      0    110
	0      0      0      0      0      0      3     21
	0      0      0      0      0      0      0    305
	0      0      0      0      0      0      0    750
	0      0      0      0      0      0     33    231
	0      0      0      0      0      0      0    810
	0      0      0      0      0      0      0   3050
	0      0      0      0      0      0    225   1575
	0      0      0      1     25    130      0   1342
	0      0      0      0      0      0      0   8100
	0      0      0      0      0      0    915   6405
	0      0      0     10    250   1300      0  13420
	0      0      0      0      0      0   2430  17010
	3     75    390     21    525   2730   4026  28182
  main: qq
  $

Using realex, the same result can be obtained as follows

  $ realex
  Enter expressions:
  expr> set ic=inner_class("B5.A3.T1",[[1/2,0,0],[0,1/2,1/2]],"scc")
  Identifier ic: InnerClass
  expr> ic
  Value: Complex reductive group of type B5.A3.T1, with involution defining
  inner class of type 'ccc', with 18 real forms and 8 dual real forms
  expr> block_sizes(ic)
  Value:
  | 0,  0,   0,  0,   0,    0,    0,     1 |
  | 0,  0,   0,  0,   0,    0,    0,    11 |
  | 0,  0,   0,  0,   0,    0,    0,    10 |
  | 0,  0,   0,  0,   0,    0,    0,    75 |
  | 0,  0,   0,  0,   0,    0,    0,   110 |
  | 0,  0,   0,  0,   0,    0,    3,    21 |
  | 0,  0,   0,  0,   0,    0,    0,   305 |
  | 0,  0,   0,  0,   0,    0,    0,   750 |
  | 0,  0,   0,  0,   0,    0,   33,   231 |
  | 0,  0,   0,  0,   0,    0,    0,   810 |
  | 0,  0,   0,  0,   0,    0,    0,  3050 |
  | 0,  0,   0,  0,   0,    0,  225,  1575 |
  | 0,  0,   0,  1,  25,  130,    0,  1342 |
  | 0,  0,   0,  0,   0,    0,    0,  8100 |
  | 0,  0,   0,  0,   0,    0,  915,  6405 |
  | 0,  0,   0, 10, 250, 1300,    0, 13420 |
  | 0,  0,   0,  0,   0,    0, 2430, 17010 |
  | 3, 75, 390, 21, 525, 2730, 4026, 28182 |

  expr> quit
  Bye.
  $

(The 'inner_class' function does essentially the same as the dialogue from the
line 'Lie type:' up to and including the one with 'enter inner class(es):' in
the atlas. Note however that the specification [[1/2,0,0],[0,1/2,1/2]], of the
kernel generators is somewhat more liberal than allowed in the atlas program.)

So one difference is that rather than being asked to specify a complex group
and an in inner class after calling the blocksizes command, one needs to
construct an inner class value first, and then invoke the block_sizes function
with the inner class as argument. In the realex session above the variable
'ic' was set to the computed inner class; the reply confirms (only) its type
InnerClass. Typing 'ic' after this produces a more elaborate description of
the inner class, reporting the Lie type, inner class type (note that the 's'
for the factor 'B5' was converted to 'c') and numbers of (dual) real forms.
Then the variable 'ic' was used as argument to block_sizes, and it could
subsequently be used in other function calls as well. Alternatively one could
have called directly:

  block_sizes(set_type("B5.A3.T1",[[1/2,0,0],[0,1/2,1/2]],"scc"))

but then of course the inner class would not have been available afterwards in
the variable 'ic'. The matrix resulting from the call was printed, but it
could instead have been assigned to a variable as well. One can define any
number of variables, with values of any of the types available. This provides
more flexibility of use than the atlas interface, which can basically remember
just one inner class and one real form between different commands. In addition
the realex program provides programming constructions, and allows you to
define scripts and functions for later use.

The set of functions provided is described in the file 'functions.help' in
this directory; here we shall document other aspects of the realex program.


3 Current limitations

The data types currently available for values only concern those of the
structure theory (root data, inner classes, real forms, Cartan classes) while
many data types used internally (such as Weyl groups, polynomials) may appear
in printed output but cannot be further manipulated. The programming language
is fairly complete, with constructions like variables, loops and conditionals,
as well as functions and operators (both built-in and user defined).


4 Types

The realex interpreter is strongly and statically typed: it first analyses the
expressions and definitions given by the user to verify that types can be
attributed to all subexpressions, and all operations are defined for the types
they are applied to; only if the expression passes this test does the system
attempt to evaluate the expression. Thus many computations that would produce
problems on execution are signalled. For instance realex complains about

  expr> block_sizes (GL(5))
    Type error:
      Subexpression GL(5) has wrong type: found RootDatum while InnerClass was
      needed.
    Type check failed

because the built-in function 'block_sizes' requires an 'InnerClass' value but
'GL' produces a value of type 'RootDatum'. In the following example

  expr> Lie_type(Cartan_matrix(GL(5)))
  Error during analysis of expression Lie_type(Cartan_matrix(GL(5)))
    Failed to match `Lie_type' with argument type mat
  Type check failed

the message is somewhat different, because the name `Lie_type' corresponds to
several functions, and realex can only report that none of them applies for
the given expression. To find out which instances are known, one can enter:

  expr> whattype Lie_type ?
  Overloaded instances of Lie_type
    string->LieType
    RootDatum->LieType

showing that either a string or a RootDatum value would have worked instead of
a (Cartan) matrix. For instance

  expr> Lie_type(GL(5))
  Value: Lie type 'A4.T1'
  expr> Lie_type("E6.T1.D4")
  Value: Lie type 'E6.T1.D4'

All built-in operators and functions are defined as "overloaded" symbols, even
if only one meaning is built-in as for 'block_sizes'; this allows the user to
add new definitions of those symbols without overriding those built in. On the
other hand all non-function values are stored in a different table, which
allows only one value to be associated at any time to a given identifier.

The interpreter knows about several "primitive" types, which it distinguishes
but for which (in contrast to "composite" types discussed below) it usually
does not provide specific language constructions (although it does know for
instance that a Boolean value can be tested in a conditional expression).
These basic types are:

type		represents
-----------------------------------
bool		truth values
int		machine integers (32 or 64 bits depending on the machine)
rat		rational numbers (quotient of two machine integers)
string		string of characters
vec		vector of machine integers
mat		matrix of machine integers
ratvec          rational vector (vector numerator with common denominator)
LieType		Lie type (such as D4.A2.T1.E8)
RootDatum	root datum, specifying a connected Complex reductive group
InnerClass      inner class of real forms (based root datum with involution)
RealForm	real form within an inner class
DualRealForm    dual real form within an inner class
CartanClass     class of Cartan subgroups within an inner class

Constant values of type bool, int and string can be typed as usual (use 'true'
or 'false' (without quotes) for truth values, and a string in double-quotes
(with any contained double-quote characters doubled) for strings. Strings
cannot contain newline characters. Values of other basic types can only be
obtained by using appropriate operators and functions (for instance 22/7 has
type 'rat' and GL(5) has type 'RootDatum'), or sometimes via implicit
conversions (see below).

Composite types are either array (list) types, tuple types or function types.
Array and tuple types both construct aggregates by combining a sequence of
component values; for array types all components must have the same type and
there could be any number of them (including none at all), while for tuple
types the type explicitly enumerates the types of the components, so in
particular the number of components is determined by the type. A function type
specifies zero or more argument and result types; for either, unless exactly
one such type is specified the argument or result type is actually a tuple
type. Thus if t0,t1,t2,t3 are types, one has composite types like:

[t0]		array of elements all of which have type t0
[[t0]]		array of elements all of which have type [t0] (a list of lists)
...		etc
(t0,t1)		2-tuple formed of components of types t0 and t1 respectively
(t0,t1,t2)	3-tuple, with components of types t0,t1,t2 respectively
(t0,t1,t2,t3)	4-tuple, with components of types t0,t1,t2,t3 respectively
...		etc
void		0-tuple (irrelevant value)
(t0->t1)	function with argument of type t0 and result of type t1
(t0,t1->t2)	function with argument of type (t0,t1) and result of type t2
(t0->t1,t2)	function with argument of type t0 and result of type (t1,t2)
(t0,t1->t2,t3)	function with argument of type (t0,t1), result of type (t2,t3)
(t0,t1->)	function with argument of type (t0,t1) and no useful result
...		etc

Often the user does not have to write any types, and the system will take care
of deriving primitive and composite types as implicitly specified by the
expression. However when writing user defined functions, the types of the
arguments must be specified, so that types can be checked for the function
body; once this check succeeds, a type is attributed to the function, and it
will henceforth be treated just like a built-in function of that type would be
(and one can in fact for instance form an array that contains both built-in
and user-defined functions, provided they all have the same (function) type.

Array values can be constructed by enclosing a comma-separated lists of
component expressions (all of the same type) in brackets, as in [1,-4,3*6],
which is called a row display. If 'v' is an identifier holding an array value,
its individual components can be accessed by subscripting, as in 'v[i]' (in
fact 'v' could be replaced here by any row-valued expression, although
computing such a value just to retain one of its component seems wasteful).

If instead of brackets of a row display one uses parentheses to enclose a
sequence of expressions, then a tuple rather than an array is formed (except
if there is exactly one expression in the sequence: then parentheses just
imply grouping as used for instance to override operator precedence). Such a
"tuple display" can be used as a function argument without additional
parentheses, so for instance 'f(x,y)' applies the function 'f' to a 2-tuple
with components 'x' and 'y'. But one is not obliged to write a tuple display
for function arguments; for instance after 'set z=(3,4)' the variable 'z'
holds a 2-tuple, and (the same instance of) 'f' may also be called as 'f(z)'.
One could even for instance multiply the components of 'z' by writing '*z';
indeed the expression '3*4' is transformed by the parser into '*(3,4)', and
(currently) this form is also used in error messages, for instance in

  expr> GL(10/2)
  Type error:
    Subexpression /(10,2) has wrong type: found rat while int was needed.
  Type check failed

(The operator '/' on integers produces a rational number; for integer division
ignoring the remainder one should write 10\2 instead).

To decompose tuples, a simple form of pattern matching is provided: wherever
an identifier can be introduced, one may also specify a tuple of identifiers,
if the type of the value is appropriate, and the components will be bound to
the corresponding identifiers. So whereas

  expr> set x=E

introduces the identifier 'x' whose value (and type) are set to that of the
expression 'E', one can alternatively say

  expr> set (x,y)=E

provided that E produces a pair (some value of some 2-tuple type), and the
variable 'x' will be set to the first component of the pair, and 'y' to the
second component. In either case, the types of the variables introduced will
be reported, as in

  expr> set (q,r) = 22 \% 7   { Euclidean division with remainder }
  Identifiers q: int, r: int
  expr> q    { quotient }
  Value: 3
  expr> r    { remainder }
  Value: 1

The same pattern-matching is also allowed when introducing parameters of
user-defined functions, or when introducing local variables; the latter uses a
syntax like that of 'set' used above,, but with 'let' instead of 'set', and
followed by 'in' and the "body" if the let-expression, the expression where
the local variable is in scope. So to interchange the components of 'z', say

  let (x,y)=z in (y,x)

If only the first component is needed, there is no need to give a name to the
other one, so one can write

  let (x,)=z in x

Local variables get their value and type from the expression between '=' and
'in', and are independent of any meaning that might previously be associated
to the identifier; after evaluation of the body, the local identifiers
introduced are forgotten (except it the body managed to capture a reference to
some of them in a local user-defined function, as will be explained later).

Using a local variable, the initial example could have been given in a form
that does not permanently bind the identifier 'ic':

  expr> let ic = inner_class("B5.A3.T1",[[1/2,0,0],[0,1/2,1/2]],"scc")
  L > in block_sizes(ic)
  Value:
  | 0,  0,   0,  0,   0,    0,    0,     1 |
  ...

Note that realex recognised that the let-expression was incomplete after the
first line, and changed the prompt in the second line to indicate this.


5 Implicit conversions

When type do not match exactly, realex will sometimes insert implicit type
conversions that are accompanied by conversions of the corresponding values.
For instance, although the 'vec' type, which function of the atlas library
use, models the same values as '[int]' (pronounced "row of int"), the two
types have different internal representations (that of 'vec' is more compact),
and a row display will only produce '[int]'. What makes it nevertheless
possible to provide 'vec' values to functions that need it is the fact that
realex will convert between 'vec' and '[int]' in contexts that require this.

Here is a list of all implicit type conversions

  vec    <-> [int]
  mat    <-> [vec]    (vectors are columns of the matrix)
  mat    <-> [[int]]  (inner arrays are columns of the matrix)
  int     -> rat      (denominator 1)
  ratvec <-> [rat]    (ratvec has least common denominator)
  string  -> LieType  (applies Lie_type function)

The one-directional conversions int->rat and string->LieType are mainly a
convenience to users, as these conversion could be written out explicitly:

  expr> 3+1/7       { same as 3/1+1/7 }
  Value: 22/7
  expr> Cartan_matrix("E8")  { same as Cartan_matrix(LieType("E8")) }
  Value:
  |  2,  0, -1,  0,  0,  0,  0,  0 |
  |  0,  2,  0, -1,  0,  0,  0,  0 |
  | -1,  0,  2, -1,  0,  0,  0,  0 |
  |  0, -1, -1,  2, -1,  0,  0,  0 |
  |  0,  0,  0, -1,  2, -1,  0,  0 |
  |  0,  0,  0,  0, -1,  2, -1,  0 |
  |  0,  0,  0,  0,  0, -1,  2, -1 |
  |  0,  0,  0,  0,  0,  0, -1,  2 |

If desired, a context requiring a given type can be created by giving the type
name followed by a colon. So while one gets an error for

  expr> [1,1/2,1/3,1/4]
  Type error:
    Subexpression /(1,2) has wrong type: found rat while int was needed.
  Type check failed

this can be repaired by asking for a list of 'rat'

  expr> [rat]: [1,1/2,1/3,1/4]
  Value: [1/1,1/2,1/3,1/4]

Alternatively this input could be turned into a 'ratvec'

  expr> ratvec: [1,1/2,1/3,1/4]
  Value: [ 12,  6,  4,  3 ]/12

This conversion is applied whenever a list of rationals (or integers) is given
in place of a 'ratvec'; for instance inner_class takes a list of 'ratvec'
values as second "kernel generators" argument, but they can be specified as

  expr> inner_class ("D4.A3",[[0,1/2,1/4],[0,0,1/2]],"ss")
  Value: Complex reductive group of type D4.A3, with involution defining
  inner class of type 'cs', with 10 real forms and 15 dual real forms

There could be one kernel generator, say [[0,1/2,1/4]], or none at all [];
however just [0,1/2,1/4] is not accepted since a list of vectors is required,
and realex will not turn a value into a singleton list automatically.

Matrices can be built from lists of lists of integers by requiring 'mat':

  expr> mat: [[1,2],[3,4,5]]
  Value:
  | 1, 3 |
  | 2, 4 |
  | 0, 5 |

In place of each list of integers one can also use a vector-valued expression
(for instance an identifier bound to a vector value); these become columns of
the matrix. For specifying a matrix by rows, a special syntax is provided:

  expr> [ 1,2 | 3,5,4 | 7 ]
  Value:
  | 1, 2, 0 |
  | 3, 5, 4 |
  | 7, 0, 0 |

Note that 'mat:' is not required here, the syntax itself forces a matrix
result. On the other hand it will not accept 'vec' values as lines; to
construct a matrix from its row vectors do ^[r_0,r_1,...], where the caret
is a prefix operator indicating transposition.

For most implicit conversions the opposite conversion is also available, so to
decompose a matrix M into the list of its column vectors, just write

  expr> [vec]: M

For values of the types RootDatum, ..., CartanClass, it is not practical to
print a complete description of the value stored, so upon returning such
values, only a summary of their properties is printed (for instance:
"simply connected adjoint root datum of Lie type 'A6.T1'"). In many cases
functions exists that allow more detailed information to be extracted from
these values.

6 Defining and modifying identifiers

As shown in the examples above, global identifiers are introduced using 'set',
while local identifiers are introduced with 'let'; the latter are valid only
in the expression after the following 'in'. Note that in both cases the
initial keyword is necessary; without it the '=' would be interpreted as
equality test (probably leading to an error due to an undefined left operand).

For modifying an existing variable, global or local, the assignment operator
':=' is provided. It is mainly intended for programming use rather than for
expression evaluation. For instance, a function computing the first n natural
numbers 0,...,n-1 may be written as follows (while-loops are explained later)

  expr> set first(int n) = let i=0 in while i<n do i next i:=i+1 od
  Defined first: (int->[int])

Here the part 'let i=0 in' serves to introduce 'i' as a variable, whose value
is then repeatedly modified by the assignment 'i:=i+1'. Any identifier can be
used as a variable, including function arguments, so for a decreasing list of
the same values one could write

  expr> set first_downwards(int n) = while (n:=n-1)>=0 do n od
  Defined first_downwards: (int->[int])

For identifiers holding a list, vector or matrix, one can also assign to
individual entries, as in 'v[i]:=x' or 'm[i,j]=0'. An assignment to an entry
has the same effect as assigning a new value to the entire row, vector or
matrix value, which differs only at the indicated entry from the old value.

As a convenience one can write 'x +:= y' instead of 'x := x + y', and
similarly for any operator in the place of '+', so in the above examples one
could say i+:=1 and n-:=1. This is a transformation performed in the parser,
so '+:=' is not really an operator (and is composed of separate '+' and ':=').
It should be noted that this requires a simple variable as left operand: the
parser will reject for instance v[i]+:=1; this should be written v[i]:=v[i]+1.

Whatever the nature of the identifier assigned to, the assignment never
changes any values other than those referred to by that identifier; for
instance the assignment to its argument in the function 'first_downwards' does
not have any affect for callers of this function, who do not know about the
identifier 'n' that 'first_downwards' uses to name its argument. In general
the only way a function call affects the caller is by the value it returns, or
possibly by assignments to non-local variables also in scope for the caller.

The rules for assignment are quite different from the introduction of a
variable: the variable must have been introduced beforehand, and the value
assigned must have the same type as the previously held value. An assignment
need not be used exclusively for the change to its variable it causes; it is
also a subexpression in its own right (as is used in the definition of
'first_downwards'), and as such it represents the value that was assigned.

7 Defining functions

One can also define functions. The normal way to do so is using a variation of
the 'set ' syntax (which has no counterpart for 'let'), as in

  expr> set f (LieType lt)=
  = > let rd = simply_connected_datum (lt)
  L > ; ic = inner_class(rd,"s")
  L > ; rf = quasisplit_form (ic) , drf = dual_quasisplit_form (ic)
  L > in print_block(rf,drf)
  Defined f: (LieType->)
  expr> f("A2")
  entering block construction... K\G/B and dual generated... done
  0(0,5):  0  0  [C+,C+]  2  1   (*,*)  (*,*)   e
  1(1,4):  1  0  [i2,C-]  1  0   (3,4)  (*,*)   2,1
  2(2,3):  1  0  [C-,i2]  0  2   (*,*)  (3,5)   1,2
  3(3,0):  2  1  [r2,r2]  4  5   (1,*)  (2,*)   1,2,1
  4(3,1):  2  1  [r2,rn]  3  4   (1,*)  (*,*)   1,2,1
  5(3,2):  2  1  [rn,r2]  5  3   (*,*)  (2,*)   1,2,1
  expr> f("G2")
  entering block construction... K\G/B and dual generated... done
   0(0,9):  0  0  [i1,i1]   1   2   ( 3, *)  ( 4, *)   e
   1(1,9):  0  0  [i1,ic]   0   1   ( 3, *)  ( *, *)   e
   2(2,9):  0  0  [ic,i1]   2   0   ( *, *)  ( 4, *)   e
   3(3,8):  1  1  [r1,C+]   3   6   ( 0, 1)  ( *, *)   1
   4(4,7):  1  2  [C+,r1]   5   4   ( *, *)  ( 0, 2)   2
   5(5,6):  2  2  [C-,C+]   4   8   ( *, *)  ( *, *)   1,2,1
   6(6,5):  2  1  [C+,C-]   7   3   ( *, *)  ( *, *)   2,1,2
   7(7,4):  3  1  [C-,i2]   6   7   ( *, *)  ( 9,11)   1,2,1,2,1
   8(8,3):  3  2  [i2,C-]   8   5   ( 9,10)  ( *, *)   2,1,2,1,2
   9(9,0):  4  3  [r2,r2]  10  11   ( 8, *)  ( 7, *)   2,1,2,1,2,1
  10(9,1):  4  3  [r2,rn]   9  10   ( 8, *)  ( *, *)   2,1,2,1,2,1
  11(9,2):  4  3  [rn,r2]  11   9   ( *, *)  ( 7, *)   2,1,2,1,2,1

The syntax for defining functions is: after 'set' and the function name first
a parameter list, formed of pairs of the form '<type> <identifier>' separated
by commas and enclosed in parentheses, then a colon (optionally preceded by a
return type), then '=', and then the expression giving the function body. In
the example the function body is a 'let' construction introducing first the
local variable 'rd', then (preceded by a semicolon, which is equivalent to 'in
let') 'ic', and finally (after another semicolon) 'rf' and 'drf' (in parallel,
separated by a comma) and finally calling (after 'in') the function
'print_block'. The latter returns no value, whence the function 'f' does not
either, and gets type (LieType->). Note that after calling the function 'f'
the 'Value' indication before the output is suppressed (the printed output is
not a (composite) value, and is not accessible for further manipulation).

Functions defined by this syntax are stored in a different table than
variables introduced by 'set xxx = ...', which means they can coexist with a
value of the same name; more importantly this other table can store multiple
definitions for the same function name, whence it is called the overload
table. So after the above definition one could continue with

  expr> set f(int n)=n+1
  Added definition [2] of f: (int->int)
  expr> [f(4),f(f(6))]
  Value: [5,8]
  expr> f("A1")
  entering block construction... K\G/B and dual generated... done
  0(0,1):  0  0  [i1]  1   (2,*)   e
  1(1,1):  0  0  [i1]  0   (2,*)   e
  2(2,0):  1  1  [r1]  2   (0,1)   1

Note how the response after the second 'set f' mentions the addition of a
definition and the total number [2] of definitions for 'f' now known. When
encountering a call of 'f', realex finds out which definition to apply based
on the type of the argument (list). All functions (and operators) built into
realex are defined in the overload table, often with more than one initial
definition for a function name. The user can add definitions to names that
also refer to built-in functions, they will be overloaded together with the
original definitions. If they had not been built in, the user could define

  set inner_class (LieType lt,[ratvec] gen,string ict) =
  let basis = quotient_basis(lt,gen)
  ;   rd    = root_datum(lt,basis)
  ;   inv   = involution(lt, basis, ict)
  in inner_class(rd,inv)

  set inner_class (RootDatum rd, string ict)=
  let lt = type (rd), basis=transpose_mat(coroot_radical(rd))
  in inner_class(rd, involution(lt, basis, ict))

to add two new meanings to the inner_class function; the fact that these
definitions themselves use a more basic version of inner_class is no problem,
because they can be distinguished by the argument types.

Since the definitions above are essentially the same as the ones built in, it
is in fact legal to give them: by a special language rule, a new definition
for identical argument types as an existing one will replace the old
definition rather than add a new overload. The realex response reflects this:

  Redefined inner_class: (LieType,[ratvec],string->InnerClass)
  Redefined inner_class: (RootDatum,string->InnerClass)

New meanings of operator symbols can also be defined in this way. So while
currently addition is only defined for integers and rationals, one could say

  set +(vec v,vec w) = vec: for vi@i in v do vi+w[i] od
  Added definition [4] of +: (vec,vec->vec)

to define addition of vectors. It is not possible though to introduce new
operator symbols or alternative priorities for the existing ones.

On the other an attempt to add a definition for a different but closely
related argument type may be refused, as in the following attempt to replace
[ratvec] by [[rat]]:

  set inner_class (LieType lt,[[rat]] gen,string ict)=
  inner_class(lt,for g in gen do ratvec: g od,ict)

gives the somewhat elaborate error message

  Cannot overload `inner_class', existing type
  (LieType,[ratvec],string) is close to (LieType,[[rat]],string),
  and either converts to the other, definition aborted.

Functions can also be unnamed values, which is particularly useful if the are
to be passed as arguments to other functions. So supposing g was defined by

expr> set g ((int->int) f) = vec: [f(0),f(f(1)),f(5)]
Defined g: ((int->int)->vec)

one could call g with the increment function without naming the latter:

expr> g((int n):n+1)
Value: [ 1, 3, 6 ]

One could define an identiier to have a function value using this syntax

expr> set incr = (int n):n+1
Identifier incr: (int->int)

but in this case the binding is stored in the ordinary (not overloaded)
identifier table. A new function value of the same type can now be assigned to
the same identifier, to replace the old one, which is not possible with
overloaded function definitions. An ordinary global identifier defined as a
function value can coexist with one or more overloaded instances for the same
name, but when the name is then used in function-call syntax, only the
overloaded instances will be visible (however if any local bindings of a name
exist, this renders all overloaded instances of the same name inaccessible).

8 Control structures

The language provides conditional expressions and loops. Both can deliver
values (which is somewhat unusual for loops), though they can also serve more
conventionally for selecting/iterating actions. Conditionals take the form

  if ... then ... else ... fi

for a simple 2-way branch, or a more elaborate multi-way branch

  if   ... then ...
  elif ... then ...
  elif ... then ...
  ...
  else ...
  fi

The expressions after 'then' and 'else' should all have the same type that
will become the type of the conditional expression (or they should be
implicitly convertible to the type expected for the conditional expression,
and exactly one of them will deliver the actual value of the conditional. The
branches can be formed of a list of expressions separated by ';', of which the
last one determines the value returned (and its type), while the preceding
ones have void type and deliver no useful value (but since every type can be
converted to void, any valid expression will be allowed for them). This is in
fact a separate construction, the "sequence expression", which can be used in
any place an expression is required (for instance a function argument),
although in some contexts parentheses around the sequence expression are
required to hold them together. The 'else' branch of a conditional may be
absent, but in that case the conditional delivers no value, and only servers
to select a branch for the side effects of its execution (for instance through
assignments). Indeed the parser substitutes an empty tuple '()' for the
else-branch in this case, and all other branches will be converted to its void
type in this case (just like expressions before ';' in a sequence expression).

In conditions (and in Boolean expressions in general) one can use connectives
'or', 'and' and 'not', which behave like operators of priority less than any
other ones except assignment (but increasing in the order given); they are
however handled in the parser, which will for instance transform 'x and y'
into 'if x then y else false fi' so they are not stored in any tables.

Loops come in various flavors, each one returning a row value with one
component for each iteration of the loop (except if the context demands a void
result). There are simple while loops

  while ... do ... od

with as usual a continuation condition after 'while'. If some pre-test action
is required on each iteration, it suffices to use a sequence expression as
continuation condition. The other expression is the loop body that determines
an entry of the row value returned by the loop; obviously at least one of the
component expressions must involve an action susceptible of changing the value
of the continuation condition if the loop is to terminate. So a loop

  let i=0 in while i<=n do i+:=1 od

will produce a row [1,2,...,n]. Often an advancement action is required to
take place after an entry of the result is contributed; to that end one has

  while ... do ... next ... od

where the entry is contributed before 'next', and the remaining expression is
only evaluated for its side effect (it has void type). So for instance

  let i=0 in while i<=n do i next i+:=i od

produces the row [0,1,...,n-1].

The remaining loops are 'for' loops, which determine the number of iterations
at the beginning rather than dynamically. The syntax is somewhat unusual, in
that it does not specify the starting and ending values of the iteration, but
rather the number of iterations and the smallest index; thus an iteration from
0 to n-1 is specified as n iterations with lowest index 0. More specifically,
one specifies (in this order) the number of iterations, the direction
(increasing or decreasing) and the lower bound of the range (only unit steps
are supported; a negative iteration count is interpreted as 0). The iteration
count is preceded by ':', the direction by the keyword 'from' (increasing) or
'downto' (decreasing), and the lower bound follows. The direction and lower
bound may be omitted, in which case 'from 0' is assumed. So

  for i : n from 0 do i od

is an alternative way to produce [0,1,...,n-1], and it may be abbrevieted

  for i : n do i od .

To obtain a more traditional range [1,2,...,n], one may say

  for i : n from 1 do i od .

For the reverse list [n-1,...,1,0] use

  for i : n downto 0 do i od

and the shifted reversed list [n,...,1] is produced by

  for i : n downto 1 do i od

As for the while loop, the body may be a sequence expression with side
effects, but assignments to the loop variable only have effect until the end
of the iteration; the next iteration is started at the next value in sequence.

Rather than counted iteration, it is often convenient to use iteration over an
existing composite value. If V is a row value, or vector or matrix then

  for e in V do ... od

iterates over the components of V (for a matrix these are its columns),
setting e to such a component before evaluating the loop body. For instance,
one can produce the scalar multiple by 3 of a vector V using

  vec: for e in V do 3*e od

(the 'vec:' serves to assemble the entries in a vector rather than a list).
In some cases it is useful to know the index of the component taken as well
inside the loop body, in other words the iteration count starting from 0; this
can be accessed by writing '@ index' before 'in' where 'index' is an
identifier used to bind the index to, This explains the vector addition above:

  set +(vec v,vec w) = vec: for vi@i in v do vi+w[i] od

where the index i is needed to select the corresponding entry from the other
vector. These value-returning loops are quite flexible, for instance

  mat: for j = n do for i = m do if i=j then 1 else 0 od od

produces an m*n matrix with unit diagonal entries and zeroes elsewhere. Of
course the case m=n of the identity matrix is most common, be we allowed
distinct values of m and n to stress that the column-oriented convention
forces the outer loop to be over the columns and the inner loop to be over the
rows. To add such a matrix to an existing matrix M it suffices to write

  for col@j in M do for entry@i in col do entry+if i=j then 1 else 0 fi od od

Conditionals can be used to do rudimentary recursive functions. The language
itself does not directly support recursion (a function expression has no means
to refer to itself from inside), but using assignment to a global function
variable we can nevertheless get recursion into place. The trick is to first
introduce a dummy function name with the correct type, so that the "recursive"
function body can pass the type check, and then by assignment replace it by a
properly recursive expression (note that the requirement that assignments do
not change types guarantees the type check continues to makes sense). One is
forced to assign an anonymous function to the name, as follows:

  expr> set fac = (int n): 0
  Identifier fac: (int->int)
  expr> fac := ((int n): if n>0 then n*fac(n-1) else 1 fi);
  expr> fac(7)
  Value: 5040

The assignement is necessary to make the recursive call identify a function
object with value defined by the function body; if we would have used the
usual syntax 'set fac (int n)=' instead, we would have created a new function
object 'fac' whose body refers to the old (and not otherwise accessible)
function object also called 'fac'; there would have been no recursion and any
execution (with argument n>0) would return 0. The semicolon after the
assignment to 'fac' serves to suppress printing of the internal representation
of the function object as value of the assignment. Note that the dummy initial
definition does not use 'set fac (int n)=' either, since that would not create
a function valued variable, but rather an entry in the overload table, which
cannot be modified via assignment (the subsequent asignment would be refused
because of an "undefined identifier" 'fac'). Indeed overloading is always
resolved during expression analysis, and there is no run-time lookup of
overloaded functions.

Since the initial function value is to be never actually used (only its type
serves) one might as well not specify it at all, by writing:

  expr> fac : (int->int)

will give the global identifier 'fac' the indicated type but an undefined
value, with which nothing can be done except assigning another value of the
same type to it, which is exactly what we need for the recursive definition.
One can use the same syntax to create undefined values of any type, but this
does not have much practical use, since a value must be supplied anyway before
it can be used.


9 Splitting commands across lines

Normally each line contains a command (an expression to evaluate, an
identifier or function definition, or a miscellaneous command) which is
executed as soon as the line is scanned and found to be syntactically correct
(and well typed). However various mechanisms are provided to allow commands to
extend across multiple lines. First of all, a command is not considered
complete if it contains unclosed parentheses or brackets, in which case it is
automatically extended to the following line. The unclosed symbols are
prefixed to the continuation prompt as an indication of what still needs to be
closed (unclosed string quotes are also tested for, but since strings cannot
contain newlines, they are simply closed by force at the end of the line). If
there are no unclosed parentheses or brackets but the line ends in a binary
operator or ':', then the line is also automatically continued. Finally the
user can force continuation of the line by typing '\' as the last non-space
character of the line (the backslash is removed, and actually joins the line
with the following one before analysis, so you could do this even to break in
the middle of an identifier or string or other token). Note that is the _only_
use of backslash as an escape character, anywhere else on the line it
designates the integer division-without-remainder operator (the forward slash
is division producing a rational number).


10 Output and input redirection

Some function calls return a value without printing anything, which value will
be printed by the interpreter (preceded by "Value:") if it is not assigned to
a variable or passed to another function. Other functions print output to the
terminal but do not return a useful value (the names to these functions start
with "print"). In either case the user may decide to write the result to a
file rather than to the terminal. To that end start the command line with ">"
or with ">>" followed by a file name (taken to be delimited by white space;
alternatively the file name may be enclosed in double quotes, in which case it
can contain spaces) followed by the (complex) function call producing the
desired output. In case of ">" a new file will be created, in case of ">>" the
output is appended to an existing file. For instance

  expr> >output_file block_sizes(ic)
  expr> >> output_file print_KGB(real_form(ic,2))
  expr> >> output_file print_KL_list(real_form(ic,2),dual_quasisplit_form(ic))
  expr>

will produce in the current directory the file 'output_file' with the results
of the indicated calls to block_sizes', 'print_KGB', and 'print_KL_list'.

One can also redirect command input from a file. Simply type

  expr> < filename

on a line by itself to execute the contents of 'filename' as a series of
commands. The output still goes to the terminal, unless the file contains
lines that themselves start with '>'. Note that, in spite of similar syntax,
output and input redirection have rather different characteristics. Output
redirection only applies to a single command, which must be an expression
evaluation (function call or variable, not an assignment or other statement).
Input redirection should not be followed by anything on the same line, but it
can invoke any number of commands from the given file. It can even be used
recursively to include commands from other files that be initial include file.
One cannot globally redirect the output produced from the commands of an
included file. If a command from a file included at any level produces a
syntax or runtime error, a message reporting the place of the error is printed,
all included files are abandoned, and control is given back to the terminal.


11 Miscellaneous commands

Some operations, including the type checker, can be made more verbose by
giving the command

  expr> verbose

which remains in effect until a subsequent command

  expr> quiet

is given.


One can ask the state of all known identifiers by typing

  expr> showall

which prints the type and value of every defined function and variable. If one
just needs to know the type of one expression, one can type

  expr> whattype expr

This performs type analysis of the expression and prints the result, but does
not evaluate anything. Unfortunately, since an overloaded function name in
itself is not a valid expression, this cannot currently be used to find out
the types of functions; these types are however given by showall. Finally when
you get tired of using realex, type

  expr> quit
  Bye.


12 Syntax summary

A formal syntax is given in the parser generator source file "parser.y", which
should be fairly readable for those used to BNF syntax. Here we summarize its
contents informally.

The syntax is very largely centered around a single "part of speech", the
expression. There is no distinction between expressions and statements: every
expression may have side effects (if it contains assignments for instance) and
yields a value (although it might be void, or ignored). The only parts of the
syntax not directly concerned with expressions is the part defining commands,
which are only allowed at the outermost level, and some small categories such
as type specifications and formal parameter lists that are used to form
certain kinds of expressions without themselves being expressions. The command
level will be described at the beginning, the non-expressions categories at
the end. In between we enumerate the different kinds of expressions, in order
from most loosely bound to most tightly bound; using a loosely bound form in
more tightly bound context requires enclosing the expression in parentheses.

(a) Command level.

The most common command is an expression, possibly followed by a semicolon;
the result of evaluation will be printed if the semicolon is absent. Also
common is the 'set' command, which has overloading and non-overloading forms.
In an overloading form, 'set' is followed by a single function or operator
name, a non-empty parameter list, '=' and an expression (function body). In
non-overloading form 'set' is followed by a an identifier pattern, an '=' and
an expression; a single function name followed by an empty parameter list, '='
and a function body is also taken as a non-overloading form of 'set' (since
parameterless overloads are forbidden). To get rid of a variable altogether
the command 'forget name' can be used. Individual instances in the overload
table can be removed (which might be useful in case of overloading conflicts)
using 'forget' with the function or operator name followed by '@' and the
argument type(s) as in 'forget +@(int,int)'. A shorter alternative to the
syntax 'set x = expr' is provided as 'x : expr'. The latter syntax with a type
instead of expr creates a variable of the given type but undefined value.

The command 'quit' terminates the interpreter, 'showall' shows all identifier
associations. The commands 'verbose' and 'quiet' turn on or off extra
diagnostics during expression analysis. A command starting with '>' or '>>'
redirects output to a file (appending in the latter case); the symbol is
followed by a file name (either delimited by whitespace or enclused in quotes)
and then the expression to be evaluated. Input redirection is similar, using
'<', but it should only be followed by a file name; if not found, the same
name with ".rx" appended will also be tried. Normally input redirection is
ignored if the same file was already read before; this is done so that a file
that buids forth on "basis.rx" can safely start with '<basis.rx' to ensure its
definitions are seen, without needlessly reloading it should it already have
been read. One can override this mechanism (useful if the file has changed) by
using '<<' instead of '<'. The command 'whattype' can either be followed by an
expression or by an identifier or operator followed by '?'. In the former case
the expression is only analyzed and its type printed; n the latter case the
overload table will be searched, and all occurrences of that item listed.

(b) Loose expressions: 'let', anonymous functions, casts, 'next'-expressions

These are the expression types that end with another expression that never
needs parentheses; they are themselves loosely bound, so the might require
parentheses if used in other context (like in an assignment). Let-expressions
introduce local definitions, starting with 'let', then a list of one or more
definitions then 'in' and a final expression in which those definitions are
valid, and which produces the value of the let-expression. Certain definitions
in the list may be separated by 'then', which behaves like 'in let', so that
the items defined before it are accessible afterwards. Between two of 'let',
'then, and 'in', several definitions may be separated by commas, in which case
they are handled in parallel (neither can refer to the identifiers defined by
the others). Each basic definition consists of an identifier pattern followed
by '=' and an expression (which never needs parentheses). Local definitions
are never overloaded, and any locally defined name hides all overloads of that
name. Nevertheless the special syntax of 'set' for function definitions (with
'=' after the parameter list) is also available with 'let'.

Anonymous functions consist of a pair of parentheses enclosing a parameter
list, followed by an optional (result) type, and then ':' and the function
body expression. A parameter list consists of zero or more pairs of a type
followed by an identifier pattern, separated by commas. Casts consist of a
type followed by ':' and an expression.

A next-expression consists of a quaternary level expression followed by 'next'
and an expression. The 'next' separator behaves like ';', except that it
returns the value of its left hand expression (which is still evaluated first)
instead of its right hand expression. When more than two expressions are
separated by 'next', the one before the first 'next' determines the value.

(c) Quaternary expressions: semicolon-separated sequences.

A sequence of expressions separated by semicolons is evaluated from left to
right, and the value of the last expression determines the value of the
sequence (the values of the other expressions are cast away, and often not
even assembled; this is true for the right hand expression of 'next' as well).
Because semicolon binds more stringly than 'next', when using a mixture of
both (without parentheses to override) the final value comes from the last
expression before the first 'next'. Tertiary expressions and more strongly
bound ones are considered to be quaternary expressions too, and this pattern
continues for the remaining levels.

(d) Tertiary expressions: assignments and Boolean expressions.

Assignments change the values bound to (non-overloaded instances of) local or
global identifiers (the most local binding hides any others). They consist of
an identifier name, then ':=' and a tertiary expression. The identifier must
have been introduced before (at least one binding must be found), and the
assignment must be compatible with its type, which cannot change by the
assignment (but the assigned value might be converted to match the type). An
alternative form of the assignment allows a binary operator symbol before ':='
as abbreviation, where an assignment like 'a % := 7' stands for 'a := a % 7'.
Another form of assignment involves a subscripted left hand side: an
identifier followed by '[', one or two expressions separated by ',', and
finally ']'. This modifies a list, vector or matrix by replacing one entry or
(in case of a matrix used with only one index expression) column by the value
of the right hand expression. The effect is that of the assignment of a new
value to the identifier, which differs from the old value only in the place
specified by the index or indices.

Boolean expressions involve the logical connectives 'and', 'or' and 'not'.
They can be understood as the most loosely bound forms of expressions, but are
actually translated into if-then-else expressions with Bollean values:
x and y -> if x then y else false fi,  x or y -> if x then true else y fi,
not x -> if x then false else true fi. This implies that the right hand side
of 'and ' and 'or' connectives is only evaluated if necessary. The connective
'or' is most loosly bound, 'and' binds stronger and 'not' stronger still, but
all of them bind more loosly then formulas, notably comparison operations.

(e) Secondary expressions: formulas.

These involve operators in the following order of increasing priority:
=,  !=,  <,  >,  <=,  >=;        +, -;      *, /, \, %, \%;     ^;        #.
Items separated by commas have the same priority, while among operators of the
same priority association is from left to right, except for '^' right to left.
When used in a unary way, an operator binds with the same priority and when
used as a binary operator: -x+y is (-x)+y, -a^b is -(a^b), and -a%p is -(a%p).

(f) Primary expressions: subscriptions, function applications, units

Subscriptions consist of a primary expression (usually an identfier) followed
by a comma-separated list of (index) expressions encloded in '[' and ']'.
Function applications are similar except that the list of (argument)
expressions is encloded in '(' and ')', and that it may be empty. Units are
expressions made of a single symbol: an identifier, integer number, true,
false, or string constant (enclosed in quotes and on a single line). These are
primary expressions, as are specialisations of overloaded names or operators,
formed by following the name or operator by '@' and a type (as in 'forget').

(g) Closed expressions: displays and groupings, conditionals, loops

These compound expressions include delimiters at both ends, so they never need
(additional) paretheses; a single parenthesized expression also forms a closed
expression. The different forms are as follows, where '*' is any expression

if * then * fi
if * then * else * fi
if * then * elif ... fi
while * do * od
for pattern in * do * od
for pattern @ ident in * do * od
for ident : * do * od
for ident : * from * do * od
for ident : * downto * do * od
begin * end
( * , * , ... )
[ * , ... ]
[ * , ... | * , ... | ... ]

(h) Argument lists, Identifier patterns

An identifier pattern can be a single identifier, or a parenthesized list or a
parenthesized list followed by ':' and an identifier (naming the whole
structure); in case of a parenthesized list the value of the expression after
'=' should have the corresponding tuple structure. The items in the
parenthesized list are again patterns, separated by commas, where patterns may
also be omitted if no name is needed for the corresponding component.

(i) Types

Types are either 'void' (the type of the empty tuple) or recursively
constructed using the basic types 'int', 'bool', 'string', 'vec', 'mat',
'ratvec', or atlas-specific types like 'InnerClass', using the list
constructor [*], the tuple constructor (*,*,...) (with at least two types:
around a single type parentheses just provide redundant grouping) and the
function constructor (*,*,...->*,*,...) (here parentheses around argument and
result type lists are implicitly assumed if there are more than one; there
could be none at all, which is equivalent to specifying 'void').
