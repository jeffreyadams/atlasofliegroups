{ determinant }
set det (mat M) = int:
  let (diag,,)=diagonalize(M),(n,m)=#M in
  if n!=m then error("Determinant of non-square matrix")
  elif #diag<n then 0 { there is at least one zero on the diagonal }
  else let p=1 in for d in diag do p*:=d od; p { otherwise multiply out }
  fi

{ compute Smith (almost) normal form in two ways }
set test (mat M) = (mat,mat):
( let model = null(#M), (diag,R,C) = diagonalize(M) in
  for v@i in diag do model[i,i]:=v od { diagonal(diag) may be too small }
; (model, R*M*C)
)

{ Euclid's algorithm, extended. Unrelated to determinants but we'll need lcm }

{ compute gcd, lcm, Bezout coefficients }
set Euclid (int a, int b) = (int,int,(int,int)):
let M = mat: [[ a,0 ],[b,b]]
in (
   while M[0,0]*M[0,1]!=0
   do M *:=[[1,-M[0,0]\M[0,1]],[0,1]]
   ; if M[0,0]!=0 then M *:=[[1,0],[-M[0,1]\M[0,0],1]] fi
   od
; if M[0,0]=0
  then (M[0,1],-M[1,0],((M[0,1]-M[1,1])\a,M[1,1]\b))
  else (M[0,0], M[1,1],((M[0,0]-M[1,0])\a,M[1,0]\b))
  fi
)

set gcd (int a,int b) = let (d,,)=Euclid(a,b) in d
set lcm (int a,int b) = let (,l,)=Euclid(a,b) in l
set Bezout (int a,int b) = let (,,B)=Euclid(a,b) in B

{ invert matrix, returning "numerator" matrix / minimal positive denominator }
set inv (mat M) = (mat,int):
let (diag,R,C) = diagonalize(M), l=1, (n,m)=#M
then ()=if n!=m then error("attempt to invert a non-square matrix")
        elif #diag<n then error("attempt to invert a singular matrix")
        fi
     ;  for v in diag do l:=lcm(l,v) od
in (C*diagonal(for v in diag do l\v od)*R,l)
