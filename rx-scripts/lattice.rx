<basic.rx
<matrix.rx { for 'minor' (this dependency might be eliminated) }

{ M is an nxk matrix, columns of M define a Z-module W }

set submodule_basis (mat M) = mat:
  let (B,cs) = adapted_basis(M) in n_rows(B) # for c@j in cs do c*B[j] od

{ a basis representing the quotient by sublattice spanned by columns;
  tests that this sublattice is a direct factor, and throws an error if not }
set quotient_module_basis (mat M) = mat:
( let (B,cs) = adapted_basis(M) then l=#cs in
  assert(cs=ones(l),"sublattice is not a direct factor")
; columns_with ((int j)bool: j>=l,B)
)

{ a basis representing the quotient by saturation of sublattice, so no test }
set saturation_quotient_module_basis (mat M) = mat:
  let (B,cs) = adapted_basis(M) then l=#cs
  in columns_with ((int j)bool: j>=l,B)

{ M is an n*k matrix whose columns span a rank k submodule W of V=Z^n
  A is an n*n matrix preserving W
  sub_matrix(M,W) is the k*k matrix giving the action of A on W,
  using columns of M as basis
}
set sub_matrix (mat A,mat M) = mat:
  let P = M#kernel(^M) then (Pinverse,d) = invert(P)
  then Q = minor(Pinverse*A*P,n_columns(M)) { extract top-left k*k block }
  in assert(=Q%d,"lattice not fixed"); Q\d

{ assuming M injective and Im(A*M)\subset Im(A), find unique C with A*M=M*C }
{ using decomposition M = L^{-1} * D * R^{-1} (B,L invertible, D diagonal)
  first find A' = L*A*L^{-1}, then A'' such that D*A'' = A'*D, which must
  exist, and finally compute C = R*A''*R^{-1}
}
set restrict_action (mat A, mat M) = mat:
  let (ds,L,R) = diagonalize(M), (l,r)=#M { also sizes of L,R; one has l>=r }
  then () = if #ds!=r then error("matrix has dependent columns") fi
  then A1 = L * A * inverse(L)
  then A1Dtr = l ^ for d@j in ds do d*A1[j] od { one has #A1Dtr=(r,l) }
  , A2tr= [vec]:[] { collects r vectors of size r } , zero=null(r)
  then () =
     for i: l { collect first r rows of A1, scaled; test remaining rows are 0 }
     do if i<r
        then
          if A1Dtr[i]%ds[i]=zero then  A2tr #:=  A1Dtr[i]\ds[i]
          else error("matrix does not fix lattice")
	  fi
        elif A1Dtr[i]!=zero then error("matrix does not fix image")
        fi
     od
  in R * (r^A2tr) * inverse(R)

set corestrict_action (mat A, mat M) = mat: ^restrict_action(^A,^M)

{ M is an nxk matrix whose columns span a submodule W of V=Z^n
  A is an nxn matrix preserving W
  quotient_matrix(M,W) is the matrix of M on V/W,
  using the basis from quotient_module_basis(M)
}
set quotient_matrix (mat M,mat A) = mat:
  let P= submodule_basis(M)#quotient_module_basis(M), ncM=n_columns(M)
  then (Pinverse,d) = invert(P)
  then Q = minor(Pinverse*A*P,n_columns(A)-ncM,ncM)
  in Q\d

{ M is an nxk matrix whose columns span a submodule W of V=Z^n
  Projection of v onto V/W parallel to W in basis from adapted_basis
  Basis of image space: projection of final vectors of adapted_basis
}
set projection_mod_image (mat M) = mat:
  let (B,cs) = adapted_basis(M) then d=#cs
  in rows_with( (int i): i>=d, inverse(B) ) { coordinates on final part basis }

{ original code:
  let sub = submodule_basis(M), quotient = saturation_quotient_module_basis(M)
  then P = mat: sub#quotient, dim_sum = n_columns(sub)
  in rows_with( (int i): i>=dim_sum, inverse(P) )
}

{ M is an nxk matrix whose columns span a submodule W of V=Z^n
  Projection to saturation of W, parallel to complement from |adapted_basis(M)|
  Basis of image space: initial vectors of |adapted_basis(M)|
}
set projection_to_image (mat M) = mat:
  let (B,cs) = adapted_basis(M) then d=#cs
  in rows_with( (int i): i<d, inverse(B) )

{ |solve_ratvec| finds a rational solution to linear equation A*x=v }
{ method:
  - write L*A*R = D using diagonalize, with L,R invertible matrices, D diagonal
    (only the d nonzero diagonal entries of D are actually recorded)
  - A*x = v is equivalent to L*A*x = L*v; call L*v the |target|
  - set x = R*y for new unknown y; A*x = v is equivalent to L*A*R*y = target
  - since L*A*R = D, it is necessary that |target| becomes zero after d entries
  - the first d entries of y must be those of |target| divided by entries of D
  - the remainder of y is unconstrained, take them to be 0
  - now x = R*y can be computed using only first d columns of R and target/D
}
set solve_ratvec (mat A, vec v) = ratvec:
  let (ds,L,R) = diagonalize(A) then d=#ds, target=L*v
  in begin
    for i:#target-d from d do assert(=target[i],"not in span") od
  ; columns_with((int j):j<d,R) * for i:d do target[i]/ds[i] od end

set in_lattice (mat M, ratvec v) = bool: { whether v in image lattice of M }
  let (ds,L,) = diagonalize(M) then d=#ds, target=L*v
  in all(#target, (int i): =if i<d then target[i]%ds[i] else target[i] fi )

{ as |solve_ratvec| but for integer solutions; now divisions must be exact }
set solve_vec (mat A, vec v) = vec: { find integer solution to A*x=v }
  let (ds,L,R) = diagonalize(A) then d=#ds
  then target =
    for c@i in L*v
    do if i<d
       then let (q,r)=c\%ds[i] in assert(=r,"not in lattice"); q
       else assert(=c,"not in span"); 0 { won't be used }
       fi
    od
  in columns_with((int j):j<d,R) * for i:d do target[i] od

{ alternative version: avoid error, but return success status in result }
set solve (mat A, vec v) = (vec,bool): { find integer solution to A*x=v }
  let (ds,L,R) = diagonalize(A) then d=#ds, success=true
  then target =
    for c@i in L*v
    do if i<d
       then let (q,r)=c\%ds[i] in if !=r then success:=false fi; q
       else if !=c then success:=false fi; 0
       fi
    od
  in ( columns_with((int j):j<d,R) * for i:d do target[i] od , success )
