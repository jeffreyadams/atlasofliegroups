<misc.rx
<kl.rx

{ a varable used in this file; set to true for more output from functions }
set hermitian_debug = false

set -(ParamPol P,ParamPol Q) = ParamPol: P+(-1)*Q

{ test equality of ParamPols }
set =(ParamPol P,ParamPol Q) = bool: #(P-Q)=0

{ order of operands in the next function avoids conflicting *@(int,ParamPol) }
set *(Param p,rat alpha) = let (x,lambda,nu)=%p in param(x,lambda,alpha*nu)

{set nu=0 in Param (x,lambda,nu) }
set make_no0 (Param p) = p*0
set make_nu0 (ParamPol P)= ParamPol:
  null_module(real_form(P)) + for w@p in P do (w,p*0) od

{ orientation_number_term(p,q) = s^{[\ell_0(p)-\ell_0(q)]/2}= 1 or s }
set orientation_number_term (Param p,Param q) = Split:
  let on_p=orientation_nr(p), on_q=orientation_nr(q) in
  if is_even(on_p-on_q)
  then s^((on_p-on_q)\2)
  else error("computing orientation number for odd difference of lengths")
  fi

{ c_form_std:
  write c-invariant form on standard module in terms of standardrepks,
  as a ParamPol
}
set c_form_std (Param p) = (ParamPol):
( if hermitian_debug then prints("computing c-form on standard module: ",p) fi
; full_deform(p)
)

{ c_form_irreducible(y) returns a ParamPol of standardrepks
  giving the c-invariant form on irreducible(y)
  formula used: when
    J(y)  =sum_x               (-1)^{ell(x)-ell(y)}P(x,y)(q=1)I(x)
  then
    J(y)_c=sum_x (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
  where
    P(x,y) is a cumulated KL polyomial
    (-1)^{ell(x)-ell(y)}P(x,y) is given by signedKL(y)[i] with indices[i]=x
       (note sign is taken care of already)
    on(x,y)=orientation number given by orientation_number_term()
    I(x)_c given as combination of standards x' with nu(x')=0 by c_form_std(x)
  algorithm: just compute the sum for J(y)_c, using signedKL and c_form_std
}


set c_form_irreducible_long (Param p) = (ParamPol,[(Param,Split,ParamPol)]):
( let (block,kl,polys,stops,indices,cumulation)=partial_block (p)
  then klpolys=signedKL(#block-1,kl,polys,stops,indices,cumulation)
  , P=null_module(real_form(p))
  , standards=[(Param,Split,ParamPol)]: []
  in
  for i:#indices downto 0 do
    let ev = at_s(klpolys[i]), q=block[indices[i]] in
    if ev!=0 { this saves considerable time }
    then
      let form_on_standard=c_form_std(q)
      , factor=ev*orientation_number_term(q,p)
      in P +:= factor*form_on_standard
      ; standards #:= (q,factor,form_on_standard)
    fi
  od
; (P,standards)
)

set c_form_irreducible (Param p)= ParamPol:
  let (rv,)=c_form_irreducible_long(p) in rv

set print_c_form_irreducible_long (Param p) = void:
  let (f,b)=c_form_irreducible_long(p) in
( for (q,coeff,Q) in b
  do prints("")
  ; prints("standard module: ",q)
  ; prints("coefficient: ",prettyPrint(coeff))
  ; prints("form on standard: ")
  ; prettyPrint(Q)
  od
; prints(""); prints("c-form on irreducible module:")
; prints(p, " at ",infinitesimal_character(p)); prettyPrint(f)
)

{ analyse }
{ print one terms with "mixed" coefficient (a+bs), i.e., both a,b\ne 0 }
set mixed (Split w)= bool: let (a,b)=%w in a*b!=0
set analyse (ParamPol P) = void:
begin prints("Mixed terms:")
; for w@p in P do if mixed(w) then
    prints("(",prettyPrint(w),")*",p,", ",infinitesimal_character(p))
  fi od
end


{ ---------------------------------------- }

{ commands for converting from c-form to hermitian-form}
{ compute (lambda+rho) restricted to torus T }

{ lambda\in X^*+rho =>
    one can define a parameter with this lambda, as param(x,lambda-rho,0)
  then
    infinitesimal_character(param(x,lambda-rho,0))=
    (1+theta)lambda/2=lambda restricted to T-tilde
  apply this with lambda-rho=0, returns (1+theta)rho/2     (on T-tilde)
  apply this with lambda-rho,   return  (1+theta)lambda/2  (on T-tilde)
  then the sum is (1+theta)(lambda+rho)/2 on T
}
set lambda_plus_rho_res_T(KGBElt x,ratvec lambda) = ratvec:
  let lpr=lambda+rho(real_form(x)) in (lpr+involution(x)*lpr)/2

{ mu(p) is the value of the lowest K-type of p, evaluated at x(p) }
{ formula: < (1+theta_x)(lambda+rho)/2 , torus_factor(x)+rho^\vee > }
set mu(Param p) = rat:
  lambda_plus_rho_res_T(x(p),lambda(p))*
  (torus_factor(x(p))+rhocheck(real_form(p)))

set convert_cform_hermitian (ParamPol P)= ParamPol:
  if #P=0 then P { since we cannot select a term for a null polynomial }
  else
    let a_mu = mu( for w@p in P do p od [0] ) { mu of the first term }
    in null_module(real_form(P)) +
      for w@p in P do (s^(rattoint(mu(p)-a_mu))*w,p) od
  fi

{ ParamPol giving the hermitian form on irreducible p }
set hermitian_form_irreducible(Param p) = ParamPol:
( if hermitian_debug
  then prints("Computing Hermitian form on irreducible: ",p)
  fi
; convert_cform_hermitian(c_form_irreducible(p))
)

{ nice output of hermitian_form_irreducible }
set print_hermitian_form_irreducible(Param p) = void:
  prettyPrint(hermitian_form_irreducible(p))

{ nice output of Hermitian forms on list of parameters }
set print_hermitian_form_irreducible([Param] P) = void:
  for p in P do
    prints("");prints("Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p)
  od

{ check the following property: let
  J(p)=\sum a_i I_i(nu)  (character formula)
  J(P)=\sum w_jI_j (formula for c-form or hermitian-form)
  Then test whether
   \sum a_i I_i[nu=0]=\sum_j w_j[s=1]I_j
}
{ set test_form (ParamPol P,Param p)=
  if P#1 = make_nu0(character_formula(p)) then
    prints("Passed") else prints("Failed")
  fi
}

{ assuming P is the ParamPol of the Hermitian
  form on an irreducible, is_unitary(P) tests
  if it is unitary: <=> every Split w=a+bs has a=0, or all have b=0 }

set is_unitary(ParamPol P)= bool:
( let OK=true, no_coef_1=true, no_coef_s=true, list= for w in P do w od
  then i=#list
  in
  while OK and (i-:=1)>=0
  do let (x,y)= %list[i]
     in if x=0 then { must have y!=0 } no_coef_s:=false; OK:= no_coef_1
        else no_coef_1:=false; OK:= no_coef_s and y=0
        fi
  od
; OK
)
{ body used to be:
  let coeffs =for (w,) in %P do w od
  then pos=for w in coeffs do let (x,)=%w in x od
  ,    neg=for w in coeffs do let (,y)=%w in y od
  in  pos=null(#pos) or neg=null(#neg)
}

{ compute Hermitian form on p, and report if it is unitary }

set is_unitary (Param p) = bool: is_unitary(hermitian_form_irreducible(p))

set test_spherical_unitary(RealForm G,[ratvec] nus)= void:
  for nu in nus do
    prints(nu,", ", is_unitary(spherical_principal_series(G,nu)))
  od

set test_line (Param p) = void:
( let (x,lambdaminusrho,nu) = %p
  then points=reducibility_points(p)
  ,   ipoints=integrality_points(root_datum(p),2*nu)
  in prints("testing line through ", p)
; prints("reducibility points: ",points)
; prints("integrality points (for 2*nu): ",ipoints)
; if #points=0
  then prints("entire line is irreducible and unitary"
       	     ,if is_final(p*0) then "" else " (nu=0 is not final)" fi)
  else
    let points=0#points in
    if not points[#points-1]=1/1 then points:=points#1/1 fi
  ; for i:#points-1 from 1 do
      let t=(points[i]+points[i-1])/2
      then q=param(x,lambdaminusrho,t*nu)
      then r=param(x,lambdaminusrho,points[i]*nu)
      in prints(t*nu,": ", is_unitary(q))
      ;  prints(points[i]*nu,": ", is_unitary(r))
    od
  fi
)
