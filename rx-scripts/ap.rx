{ap.rx}

<groups.rx
<hermitian.rx
<thetastable.rx
<K
<K_types

set inverse_theta_induce_standard(Param p, RealForm L)=
let x_G=x(p) then
x_L=inverse_embed_KGB(x_G,L) in
parameter(x_L,lambda(p)-rho_i(x_G)-theta_rhoS(x_G)+rho_i(x_L)+theta_rhoS(x_L),nu(p))

{check whether the (1+theta)lambda(p) is dominant}
set is_lambda_dominant(Param p)=bool:let rd=root_datum(p) then lam=lambda(p) in
prints("lambda+theta(lambda)=",lam+involution(x(p))*lam); is_dominant(rd,lam+involution(x(p))*lam)

{perform one step towards making (1+theta)*lambda(p) dominant through a C- root reflection} 
set move_towards_one_plus_theta_lambda_dominant (KGBElt x, ratvec lam, ratvec nu) = (KGBElt,ratvec,ratvec):
  let rd=root_datum(x) in let theta=involution(x) in
  let i=last(semisimple_rank(real_form(x)), (int i)bool: 
  status(i,x)=0 and (1+theta)*lam*simple_coroots(rd)[i]<0) in
  if i<0 then (x,lam,nu) else (cross(i,x),act((rd,[i]),lam),act((rd,[i]),nu)) fi

set make_one_plus_theta_lambda_dominant (KGBElt x, ratvec lam, ratvec nu) = (KGBElt,ratvec,ratvec): { repeat until stable }
let i=0 in let lim=2*semisimple_rank(real_form(x)) in
while not is_dominant(root_datum(x),(1+involution(x))*lam) and i<lim do 
let (z,l,n)=move_towards_one_plus_theta_lambda_dominant(x,lam,nu) in (x:=z; lam:=l; nu:=n; i+:=1) od;
prints("Now lambda= ",lam,"; (1+theta)lambda= ",(1+involution(x))*lam); 
if i=lim then prints("(1+theta)*Lambda can not be made dominant.", "i=",i) fi;(x,lam,nu)

set make_one_plus_theta_lambda_dominant(Param p) =
   parameter(make_one_plus_theta_lambda_dominant(x(p),lambda(p),nu(p)))

{find the classification Levi for a parameter; after making it lambda-dominant}
set make_classification_L(Param p)=
  let (x,lam_new,nu_new)=make_one_plus_theta_lambda_dominant(x(p),lambda(p),nu(p)) in
  L(x,lam_new) 

set theta_stable_data(Param p)=
if not is_lambda_dominant(p) then 
p:=make_one_plus_theta_lambda_dominant(p) fi;
p:=make_no_Cminus(p); prints("Final lambda=", lambda(p),"; (1+theta)lambda= ",(1+involution(x(p)))*lambda(p));
let p_L=inverse_theta_induce_standard(p,L(x(p),lambda(p)))
in (real_form(p_L),p_L)

set move_towards_no_Cminus (KGBElt x, ratvec lam, ratvec nu) = let rd=root_datum(x) in
  let i=last(semisimple_rank(real_form(x)), (int i)bool: =status(i,x)) in
  if i<0 then (x,lam,nu)  else (cross(i,x),act((rd,[i]),lam),act((rd,[i]),nu)) fi

set make_no_Cminus (KGBElt x, ratvec lam,ratvec nu) =  { repeat until stable }
  let y=x in while (y:=move_towards_no_Cminus(x))!=x do 
  let (,l,n)=move_towards_no_Cminus (x,lam,nu) in (x:=y;lam:=l;nu:=n) od; (x,lam,nu)

set make_no_Cminus (Param p) = let (x,lam,nu)=make_no_Cminus(x(p),lambda(p),nu(p)) in
   parameter (x,lam,nu)

set theta_stable_data_split(Param p)=
if not is_lambda_dominant(p) then
p:=make_one_plus_theta_lambda_dominant(p); 
prints("Now lambda=",lambda(p),"; (1+theta)lambda=",(1+involution(x(p)))*lambda(p)) fi; 
p:=make_no_Cminus(p); 
prints("Final lambda=",lambda(p),"; (1+theta)lambda=",(1+involution(x(p)))*lambda(p)); 
let p_L=inverse_theta_induce_standard(p,L(x(p),rho(real_form(p))))
in (real_form(p_L),p_L)