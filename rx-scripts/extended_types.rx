<basic.rx
<extended_misc.rx

{
  types of extended parameters:
  1C+,1C-,1i1,1i2f,1i2s,1ic,1r1f,1r1s,1r2,1rn
  2C+,2C-,2Ci,2Cr,2i11,2i12,2i22,2r22,2r21,2r11,2rn,2rc
  3C+,3C-,3Ci,3Cr,3i,3r,3rn,3ic
}

{ ext_length(rd,delta,j)=1,2,3 }
set ext_length (RootDatum rd,mat delta, int j) = int:
  let alpha=root(rd,j) then beta=delta*alpha in
  if alpha=beta then 1 elif coroot(rd,j)*beta=0 then 2 else 3 fi

{ E=extended parameter, ext_length(j,E) = ext_length(ic(E),delta(E),j) }
set ext_length(int j, extended_param(ic,delta,,,,,,,,)) = int:
  ext_length(ic,delta,j)

{ ext_length has many cases, split cases by length }
{ ext_type_1(delta,j,p)=1C+,1C-,1i1,1i2f,1i2s,1ic,1r1f,1r1s,1r2,1rn }
{ j=index of root in integral-simple roots (not all simple roots)}
set ext_type_1(mat delta,int j,Param p)=string:
  let type = status_text(j,p) in
  if type="i2" or type ="r1"
  then
    let q=Cayley(j,p) in
    if is_fixed(delta,q) then type+:="f" else type+:="s" fi
  fi; 1+type

{ext_type_2(delta,j,p)=2C+,2C-,2Ci,2Cr,2i11,2i12,2i22,2r22,2r21,2r11,2rn,2rc}
{ j=index of root in integral-simple roots (not all simple roots)}
set ext_type_2 (mat delta,int j,Param p) = string:
  let type=status_text(j,p), theta=involution(x(p)), 
  id=integrality_datum(p) 
  then alpha=root(id,j) then beta=delta*alpha
  {need to use is_complex(alpha,x) not is_complex(j,x)}
  in
  if is_complex(x(p))(alpha) then
    if theta*alpha=beta then "2Ci"
    elif theta*alpha=-beta then "2Cr"
    else 2+type
    fi
  elif is_imaginary(alpha,x(p)) then
    if status_text(j,p)="ic" then "2ic"
    elif status_text(j,p)="i2" then "2i22"
  {else 2i11 or2i12}
  else let k = lookup(beta,simple_roots(id)) in
      if status_text(k,Cayley(j,p))="i1" then "2i11" else "2i12" fi
    fi
  elif (status_text(j,p)="rn") then "2rn"
  elif (status_text(j,p)="r1") then "2r11"
  else let k = lookup(beta,simple_roots(id)) in
    if status_text(k,inv_Cayley(j,p))="r1" then "2r21" else "2r22" fi
  fi

{ ext_type_e(delta,j,p)=3C+3C-,3Ci,3Cr,3i,3r,3rn,3ic }
{ j=index of root in integral-simple roots (not all simple roots)}
set ext_type_3 (mat delta,int j,Param p) = string:
  let type=status_text(j,p), theta=involution(x(p)), 
  id=root_datum(p)
  then alpha=root(id,j) then beta=delta*alpha
  {need to use is_complex(alpha,x) not is_complex(j,x)}
  in
  if is_complex(alpha,x(p)) then
    if theta*alpha=beta then "3Ci"
    elif theta*alpha=-beta then "3Cr"
    else 3+type
    fi
  elif is_imaginary(alpha,x(p)) then
    if is_compact(alpha,x(p)) then "3ic" else "3i" fi
  elif status_text(j,p)="rn" then "3rn"
  else "3r"
  fi

{ ext_type(delta,j,p)=ext_type_i(delta,j,p) where i=ext_length(G,delta,j) }
{ j=index of root in integral-simple roots (not all simple roots)}
set ext_type (mat delta,int j,Param p) = string:
{  if is_fixed(delta,p) then let l=ext_length(root_datum(p),delta,j) in}
  if is_fixed(delta,p) then let l=ext_length(integrality_datum(p),delta,j) in
    if l=1 then ext_type_1(delta,j,p)
    elif l=2 then ext_type_2(delta,j,p)
    else ext_type_3(delta,j,p)
    fi
  else ""
  fi

{ E=extended parameter, ext_type(j,E)=ext_type(delta,j,parameter(E)) }
{ j=index of root in integral-simple roots (not all simple roots)}
set ext_type(int j,extended_param E) = string:
  ext_type(delta(E),j,parameter(E))

{ E=extended parameter, ext_types=[ext_type(j,E)] }
set ext_types(extended_param E) = [string]:
  for j:ss_rank(ic(E)) do ext_type(j,E) od
