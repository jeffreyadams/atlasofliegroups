<groups
<generate_groups

{G is a RealForm
pi0(G)=order of component group of G(R)
 H1(G)=order of Galois cohomology H^1(Gamma,G)}

set split_rank(RealForm G)=int:
let ((c,C,s),,,)=Cartan_info(most_split_Cartan(G)) in C+s

{square_classes(ic)=list of all square classes of inner class, labelled 0,1,...,n
square_classes(G)=list of all square classes of inner class of G}
set square_classes(InnerClass ic)=[[int]]:square_classes(Cartan_class(ic,0))
set square_classes(RealForm G)=[[int]]:square_classes(inner_class(G))

{assume you want all strong real forms, i.e. Cartan 0, this is just print output}
set print_strong_real(RealForm G)=void:print_strong_real(Cartan_class(G,0))

{real_forms(G): assume Cartan 0, list of real forms [RealForm]}
set real_forms(RealForm G)=[RealForm]:real_forms(Cartan_class(G,0))
set real_forms(InnerClass ic)=[RealForm]:real_forms(Cartan_class(ic,0))

{identify SO*(2m) via the information of square_classes(SO(2m,0))}
set SOstar(int n)=let G=SO(n,0) in  let sc=square_classes(G) in real_forms(G)[sc[1][0]]
set Spinstar(int n)=let G=Spin(n,0) in  let sc=square_classes(G) in real_forms(SO(n,0))[sc[1][0]]
set PSOstar(int n)=let G=PSO(n,0) in  let sc=square_classes(SO(n,0)) in real_forms(G)[sc[1][0]]

{match(v,k) returns true if k occurs in v, false otherwise}
set match([int] v,int k)=bool:
 let rv=false in 
 let i=0 in 
 while i<#v do 
  if (v[i]=k) then rv:=true; i:=#v fi;
  i+:=1
 od;rv

{find(vecs,k) returns the (smallest) int j such that k in occurs in vecs[j]
 returns -1 otherwise}
set find([[int]] vecs, int k)=int:
 let rv=-1 in 
 let i=0 in
 while i<#vecs do
  if match(vecs[i],k) then rv:=i;i:=#vecs fi;
  i+:=1
 od;rv

{associated to a real form \theta is an element of Z^\theta/(1+\theta)Z
if theta=\theta_x then x^2\in Z^\Gamma represents this class
form_number(G) is the number of the real form
the central invariant is the entry in square_classes(G) containing this number
for example inner class of Sp(4,R)
square_classes=([2],[1,0,0])
form_number(Sp(4,R))=2
central_invariant(Sp(4,R))=0
form_number(Sp(2,0))=0 form_number(Sp(1,1))=1
central_invariant(Sp(2,0))=central_invariant(Sp(1,1))=1}
set central_invariant(RealForm G)=int:find(square_classes(G),form_number(G))
set central_invariant(InnerClass ic, int k)=int:central_invariant(real_forms(ic)[k])
  
{
strong_real_forms_same_type(ic,k)
strong_real_forms_same_type(G)
returns a list [int] (with multiplicity)
of the real form numbers in given inner class with same x^2 as given real form
real form is given by (inner class, number) or (RealForm G)
if j occurs with multiplicity this means several strong real forms mapping to the given real form
for example if ic=inner_class(Spin(4,4)) then 
strong_real_forms_type(ic,0)=[4,0,0,0,0] 
meaning one split strong real form and 4 compact ones
}
set strong_real_forms_same_type(InnerClass ic, int k)=[int]:square_classes(ic)[central_invariant(ic,k)]
set strong_real_forms_same_type(RealForm G)=strong_real_forms_same_type(G,form_number(G))

{H^1(\Gamma,G)=H^1(\theta,G) is the number of strong real forms with given x^2\in Z}
set H1(RealForm G)=int:#strong_real_forms_same_type(G)

{calculate H1 for all simple groups of given rank bounds, both simply connected and adjoint
uses all_simple from generate_groups.rx}
set iterate_H1(int min_rank, int max_rank)=void:
 for rank:max_rank-min_rank+1 from min_rank do 
  for isogeny in ["sc","ad"] do 
   prints("-------------------------------------------------------------------------");
   if (isogeny ="sc") then 
     prints("Calculating H^1(Gamma,G) for simply connected simple groups of rank ", rank)
   elif( isogeny ="ad") then
     prints("Calculating H^1(Gamma,G) for adjoint simple groups of rank ", rank)
   fi;
   prints("");
   for g in all_simple(isogeny,rank) do prints(g,"   ",H1(g)) od 
  od
od

set pi0(RealForm G)=2^(components_rank(G))
set iterate_H1(int rank)=void:iterate_H1(rank,rank)
set iterate_H1()=void:iterate_H1(1,8)

