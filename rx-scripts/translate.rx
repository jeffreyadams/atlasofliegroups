{ the functions in this file have not been carefully checked }

<hermitian.rx

set translate_debug=false

{ translate Param p, at infinitesimal character gamma,
  to new infinitesimal character gamma_new
  assumes gamma,gamma_new are dominant, delta=gamma_new-gamma is integral
  replaces (x,lambda,nu) with (x,lambda+delta,nu+delta)
  if gamma,gamma_new are regular, p and T(p,gamma_new) will have
    identical block structure
  if gamma is regular and gamma_new is singular, block of T(p,gamma_new)
    will be a quotient of block at gamma
  if gamma or gamma_new is not dominant, no guarantees
}
set T(Param p, ratvec gamma_new)= Param:
  let (x,lambda_minus_rho,nu)=%p
  , delta=ratvec_as_vec(gamma_new-infinitesimal_character(p))
  in  param(x,lambda_minus_rho+delta,nu+delta)

{ translate a ParamPol by translating each term }
set T(ParamPol P, ratvec gamma_new)= ParamPol:
( let Q=null_module(real_form(P)) in
  for (w,q) in %P do Q +:= (w,T(q,gamma_new)) od
; Q
)

{ translate parameter p to simple root wall #k of the integral root system }
set Psi(Param p,int k)= Param:
  let rd=integrality_datum(p), gamma=infinitesimal_character(p)
  then coroot=coroot(rd,k)
  then c=rat_as_int(coroot*gamma) { integrality assures this is integer }
  then shift=c*fundamental_weight(rd,k) { this will be -delta in T }
  in
  if not is_integer(shift) then error("cannot project to this wall")
  else T(p,gamma-shift)
  fi

{translate ParamPol to simple root wall #k of the integral root system}
set Psi(ParamPol P,int k)= ParamPol:
( let Q=null_module(real_form(P)) in
  for (w,q) in %P do Q +:= (w,Psi(q,k)) od
; Q
)

{ translate p to intersection of set of simple root walls of integral system }
set Psi(Param p,[int] v)= Param:
( let rd=integrality_datum(p), gamma=infinitesimal_character(p)
  then shift = ratvec: null(rank(rd))
  in
  for k in v { select components in fundamental weight basis for these k }
  do shift +:= rat_as_int(coroot(rd,k)*gamma)*fundamental_weight(rd,k)
  od
; if not is_integer(shift) then error("cannot project to this subspace")
  else T(p,gamma-shift)
  fi
)

{ translate P to intersection of set of simple root walls of integral system }
set Psi(ParamPol P,[int] v)= ParamPol:
 let Q=null_module(real_form(P)) in for (w,q) in %P do Q +:= (w,Psi(q,v)) od; Q

{ the "pseudo-tau" invariant }
{ this is a subset of simple integral roots such that:
  1) one can translate to this wall (i.e., the requisite translation is in X^*)
  2) this translation is 0
  If G is simply connected this should be the usual tau_invariant
  Example: the trivial representation of SO(3), the unique simple root
  is in the pseudo-tau invariant, but you can't translate to the wall,
  since rho is not in the root lattice

  root k of the integral roots is in pseudo-tau(p) if
  <gamma,alpha_k^v>*fund_weight is integral, and
  Psi(p,k)=0 or its x(Psi(p,k)) gets changed by make_final
  (here Psi(p,k) is the translation of the standard module for p)
}

set root_in_pseudo_tau (Param p,int k)= bool:
  let rd=integrality_datum(p)
  then weight=
    (coroot(rd,k)*infinitesimal_character(p))*fundamental_weight(rd,k)
  in
  ( is_integer(weight) and is_zero(Psi(p,k))
    or not x(Psi(p,k))=x(make_final(Psi(p,k))[0]) )

{ set of integers, defining a subset of the simple integral roots }
set pseudo_tau (Param p)= [int]:
( let rd=integrality_datum(p), rv=[int]: [] in
  for i:ss_rank(rd) do if root_in_pseudo_tau(p,i) then rv #:= i fi od
; rv
)

{ set of integers, defining a subset of the simple integral roots }
set pseudo_tau_complement (Param p)= [int]:
( let rd=integrality_datum(p), rv= [int]: [] in
  for i:ss_rank(rd) do if not root_in_pseudo_tau(p,i) then rv #:= i fi od
; rv
)

{ push Param p to the most singular place where the irreducible is non-zero,
  i.e. to all of the root walls not in the pseudo_tau_invariant}
set make_maximally_singular (Param p)= Param: Psi(p,pseudo_tau_complement(p))

{ translate each term in a list of parameters to all the simple root walls
  not in its tau_invariant, and test if it is unitary.
  The even special unipotents of G should (all?) show up this way, varying
  over all blocks at rho
}
set test_even_unipotent (Param p)= void:
( let q=make_maximally_singular(p)
  then Q=hermitian_form_irreducible(q)
  then unitary=is_unitary(Q)
  in
  prints(""); prints("original parameter: ",p)
; prints("translated parameter: ",q,", ", infinitesimal_character(q))
; prints("translated irreducible is unitary: ",unitary)
; if translate_debug then pol_format(Q) fi
)

{ test_even_unipotent of a list of parameters }
set test_even_unipotent ([Param] params)= void:
  for p in params do  test_even_unipotent(p) od
