<basic.at

{ define a representation type that avoids implicit conversion to |ratvec|:
  store a list of rational coefficients, and a indeterminate name
}
set_type RatPoly = ([rat] coefficients, string indeterminate )

set strip ([rat] v) = [rat]: v[ : 1+last(#v,(int i)bool:v[i].!= ) ]

{ constructors }
set rat_poly ([rat] c, string X) = (strip(c),X)
set rat_poly ([rat] c) = (strip(c),"q") { constructor }
set rat_poly (rat c0, string X) = rat_poly([c0],X)
set rat_poly (rat c0) = rat_poly([c0])

set to_string (RatPoly(cs,X)) = string:
   if =#cs then "0"
   else let result="" in
      for c@k in cs
      do if c.!=
         then let (n,d)=%c in
            result +:= if n.< then "-" next n:=-n else "+" fi
         ;  result +:=
            if d>1 then c.to_string elif n>1 or k=0 then n.to_string else "" fi
           +if k>1 then X+"^"+k.to_string elif k=1 then X else "" fi
         fi
      od
   ; result
   fi

set prints (RatPoly P) = prints(P.to_string)

{ for convenience declare some constants, the ! makes changes to these illegal }
set !ratpol_0 = 0.rat_poly, !ratpol_1 = 1.rat_poly, !RatPoly2 = 2.rat_poly
set !ratpol_q = [0,1].rat_poly, !ratpol_q2 = [0,0,1].rat_poly

set + (RatPoly(a,X),RatPoly(b,)) = RatPoly:
   let na=#a, nb=#b then m=min(na,nb) in
   rat_poly(for i:m do a[i]+b[i] od ## if na>nb then a else b fi [m:], X)
set - (RatPoly(c,X)) = RatPoly: (for e in c do -e od,X)
set - (RatPoly P, RatPoly Q) = RatPoly: P + -Q

set convolve ([rat] a,[rat] b) = [rat]: { auxiliary for nonzero multiplication }
   let na=#a, nb=#b then c = for :na+nb-1 do rat:0 od in
   for x@i in a do for y@j in b do c[i+j]+:=x*y od od; c

set * (RatPoly(a,X),RatPoly(b,)) = RatPoly:
   if =#a or =#b then rat_poly(0,X) else rat_poly(convolve(a,b),X) fi

{ reduce polynomial by dropping trailing zeros; shouldn't really be needed }
set strip (RatPoly P) = RatPoly: rat_poly(P) { reconstruct }
set degree (RatPoly(c,)) = int: #c.strip-1 { degree, or -1 for the |RatPoly0| }

{ evaluate polynomial at integer }
set evaluate_at_1 (RatPoly(cs,)) = rat:
   let s=rat:0 in for c in cs do s+:=c od; s

{. Euclidean division: find (q,r) where a=q*b+r and deg(r)<deg(b) .}
set \% (RatPoly(a,X):A,RatPoly(b,):B) = (RatPoly,RatPoly):
   let l_a=#a, deg_b = degree(B) in assert(deg_b.>=,"Euclidean division by 0");
   if l_a<=deg_b then (ratpol_0,A)
   else let factor = / b~[0] { inverse of leading coefficeint of dividend } in
      for i: l_a-deg_b { quotient has $\deg P+1-\deg D$ terms }
      do let c=a~[i]*factor in a~[i]:=c { write coefficient of quotient }
      ;  for j:deg_b from 1 do a~[i+j] -:= c*b~[j] od
      od
   ;  (rat_poly(a[deg_b:],X) { quotient, was written in upper part}
      ,rat_poly(a[:deg_b],X) { remainder}
      )
   fi

set \ (RatPoly A, RatPoly B) = RatPoly: let (result,)= A\%B in result
set % (RatPoly A, RatPoly B) = RatPoly: let (,result)= A\%B in result

set ^ (RatPoly(p,X),int n) = RatPoly: { power of a rational polynomial }
   if n=0 then ratpol_1 elif =#p then ratpol_0
   else { no point in trying to do this by repeated squaring: is not faster }
      let f=p in while (n-:=1)>0 do f := convolve(f,p) od; rat_poly(f,X)
   fi
