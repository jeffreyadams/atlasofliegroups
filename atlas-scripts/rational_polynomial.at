<basic.at

{ define a representation type that avoids implicit conversion to |ratvec|:
  store a list of rational coefficients, and a indeterminate name
}
set_type RatPoly = ([rat] coefficients, string indeterminate )

set strip ([rat] v) = [rat]: v[ : 1+last(#v,(int i)bool:v[i].!= ) ]

{ constructors }
set rat_poly ([rat] c, string X) = (strip(c),X)
set rat_poly (rat c0, string X) = rat_poly([c0],X)
set rat_poly ([rat] l) = rat_poly(l,"q") { default to "q", unused in this file }
set rat_poly (rat c0) =  rat_poly([c0])  { default to "q", unused in this file }

set to_string (RatPoly(cs,X)) = string:
   if =#cs then "0"
   else let result="" in
      for c@k in cs
      do if c.!=
         then let (n,d)=%c in
            result +:= if n.< then "-" next n:=-n else "+" fi
         ;  result +:=
            if d>1 then c.to_string elif n>1 or k=0 then n.to_string else "" fi
           +if k>1 then X+"^"+k.to_string elif k=1 then X else "" fi
         fi
      od
   ; result
   fi

set prints (RatPoly P) = prints(P.to_string)

{ for convenience declare some constants, the ! makes changes to these illegal }
set !ratpol_0 = rat_poly(0,"q"), !ratpol_1 = rat_poly(1,"q")
set !ratpol_q = rat_poly([0,1],"q"), !ratpol_q2 = rat_poly([0,0,1],"q")

set  = (RatPoly(a,)) =  =#a
set != (RatPoly(a,)) = !=#a

set + (RatPoly(a,X),RatPoly(b,)) = RatPoly:
   let na=#a, nb=#b then m=min(na,nb) in
   rat_poly(for i:m do a[i]+b[i] od ## if na>nb then a else b fi [m:], X)
set - (RatPoly(c,X)) = RatPoly: (for e in c do -e od,X)
set - (RatPoly P, RatPoly Q) = RatPoly: P + -Q

set convolve ([rat] a,[rat] b) = [rat]: { auxiliary for nonzero multiplication }
   let na=#a, nb=#b then c = for :na+nb-1 do rat:0 od in
   for x@i in a do for y@j in b do c[i+j]+:=x*y od od; c

set * (RatPoly(a,X),RatPoly(b,)) = RatPoly:
   if =#a or =#b then rat_poly(0,X) else rat_poly(convolve(a,b),X) fi

{ reduce polynomial by dropping trailing zeros; shouldn't really be needed }
set strip (RatPoly P) = RatPoly: rat_poly(P) { reconstruct }
set degree (RatPoly(c,)) = int: #c.strip-1 { degree, or -1 for the |RatPoly0| }

{ evaluate polynomial at integer }
set evaluate_at_1 (RatPoly(cs,)) = rat:
   let s=rat:0 in for c in cs do s+:=c od; s

{. Euclidean division: find (q,r) where a=q*b+r and deg(r)<deg(b) .}
set \% (RatPoly(a,X):A,RatPoly(b,):B) = (RatPoly,RatPoly):
   let l_a=#a, deg_b = degree(B) in assert(deg_b.>=,"Euclidean division by 0");
   if l_a<=deg_b then (rat_poly(0,X),A)
   else let factor = / b~[0] { inverse of leading coefficient of dividend } in
      for i: l_a-deg_b { quotient has $\deg A+1-\deg B$ terms }
      do let c=a~[i]*factor in a~[i]:=c { write coefficient of quotient }
      ;  for j:deg_b from 1 do a~[i+j] -:= c*b~[j] od
      od
   ;  (rat_poly(a[deg_b:],X) { quotient, was written in upper part}
      ,rat_poly(a[:deg_b],X) { remainder}
      )
   fi

set \ (RatPoly A, RatPoly B) = RatPoly: let (result,)= A\%B in result
set % (RatPoly A, RatPoly B) = RatPoly: let (,result)= A\%B in result
{ find $D=\gcd(A,B)$ and $S,T$ such that $D=SA+TB$ }

set Bezout = (RatPoly,RatPoly->RatPoly,RatPoly,RatPoly):
   let sub ((RatPoly X, RatPoly SX, RatPoly TX)
           , RatPoly c
           , (RatPoly Y, RatPoly SY, RatPoly TY)) = (X-c*Y, SX-c*SY, TX-c*TY)
   in { Bezout = } (RatPoly(,X):A,RatPoly B) (RatPoly,RatPoly,RatPoly):
   let L=[RatPoly,RatPoly,RatPoly]:
       let X0=rat_poly(0,X),X1=rat_poly(1,X) in [(A,X1,X0), (B,X0,X1)]
   , (Q,R)=A\%B
   in
   while !=R
   do L#:=sub(L~[1],Q,L~[0])
   ; let (A,,)=L~[1], (B,,)=L~[0] in set (Q,R):= A\%B
   od; let ((d,):D,S,T)=L~[0] then c=rat_poly(/d~[0],X) in (D*c, S*c, T*c)

set ^ (RatPoly(p,X),int n) = RatPoly: { power of a rational polynomial }
   if n=0 then rat_poly(1,X) elif =#p then rat_poly(0,X)
   else { no point in trying to do this by repeated squaring: is not faster }
      let f=p in while (n-:=1)>0 do f := convolve(f,p) od; rat_poly(f,X)
   fi
