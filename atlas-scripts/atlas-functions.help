operators +, -, * : (int,int->int): usual integer arithmetic operations
operator - : (int->int): integral unary minus
operator ^ : (int,int->int): integer exponentiation (whenever result integral)
operators \ : (int,int->int): integer quotient (of Euclidean division)
operators % : (int,int->int): integer remainder (of Euclidean division)
operator \% : (int,int->int,int): division and remainder of Euclidean division
operators +, -, *, / : (rat,rat->rat): usual rational arithmetic operations
operators +, -, *, / : (rat,int->rat): more efficient in applicable cases
operator % : (rat,int->rat): remainder after removing greatest integer multiple
operator % : (rat,rat->rat): remainder after removing greatest integer multiple
operator - : (rat->rat): rational unary minus
operator / : (rat->rat): rational unary divide (in other words: inverse)
operator ^ : (rat,int->rat): rational exponentiation (whenever result defined)
operator % : (rat->int,int): pair of numerator and denominator
operators +, -: (vec,vec->vec): addition/subtraction of vectors of equal size
operator - : (vec->vec): vector unary minus
operator * : (vec,int->vec): scalar multiplication (note the operand order)
operator \ : (vec,int->vec): scalar division, rounding down
operator % : (vec,int->vec): remainder in scalar division
operator * : (vec,vec->int): scalar product
flex_add, flex_sub: (vec,vec->vec): variants of +,- adding/removing trailing 0's
convolve: (vec,vec->vec): convolution product of vectors, removing trailing 0's
operators +, -: (mat,mat->mat): matrix addition and subtraction
operator * : (mat,vec->vec): matrix-vector product
operator * : (mat,mat->mat): matrix-matrix product
operator * : (vec,mat->mat): vector-matrix product (vector is transposed)
operator ^ : (mat->mat): (unary use of ^) matrix transposition
operator ^ : (vec->mat): (unary use of ^) (transposed) vector as 1-line matrix
operator +, - : (mat,int->mat): addition/subtraction of multiple of identity
operator +, - : (int,mat->mat): addition/subtraction from multiple of identity
operator / : (vec,int->ratvec): vector division giving rational vector
operator % : (ratvec->vec,int): pair of numerator vector and denominator
operators +, - : (ratvec,ratvec->ratvec): additive rational vector arithmetic
operators *, /, % :  (ratvec,int->ratvec): scalar rational vector operations
operators *, / :  (ratvec,rat->ratvec): scalar rational vector operations
operator - : (ratvec->ratvec): unary minus of rational vectors
operator * : "(mat,ratvec->ratvec): left-multiplication my matrix of ratvec
operator * : "(ratvec,mat->ratvec): right-multiplication my matrix of ratvec

operators =, != : (int->bool): test for equality/inequality against 0
operators >=, > : (int->bool) : non-negative, positive (note op. on wrong side)
operators <=, < : (int->bool) : non-positive, negative (note op. on wrong side)
operators >, >=, <, <=, =, != : (int,int->bool): usual relational operators
operators =, != : (rat->bool): test for equality/inequality against 0/1
operators >=, > : (rat->bool) : non-negative, positive (note op. on wrong side)
operators <=, < : (rat->bool) : non-positive, negative (note op. on wrong side)
operators >, >=, <, <=, =, != : (rat,rat->bool): usual relational operators
operators =, != : (bool,bool->bool): Boolean equivalence, inequivalence (xor)
operators =, != : (string->bool): test for being (or not being) the empty string
operators >, >=, <, <=, =, != : (string,string->bool): relational operators
operators =, != : (vec->bool): test for being (or not being) a zero vector
operators >=, > : (vec->bool): test for all entries being non-negative/positive
operators =, != : (vec,vec->bool): vector equality and inequality
operators =, != : (ratvec->bool): test for being a (or not) zero rational vector
operators >=, > : (ratvec->bool): test for all entries non-negative/positive
operators =, != : (ratvec,ratvec->bool): rational vector equality, inequality
operators =, != : (mat->bool): test for being a (or not) zero matrix
operators =, != : (mat,mat->bool): matrix equality and inequality

operator # : (string->int) : length of string
operator # : (vec->int) : number of components of vector
operator # : (ratvec->int) : number of components of rational vector
operator # : (mat->int) : number of columns of matrix
operator # : ([T]->int) : number of components of row (T is any type)

operator # : (vec,int->vec) : append element to a vector
operator # : (int,vec->vec) : prepend element to a vector
operator # : ([T],T->[T]) : append element to a row (T is any type)
operator # : (T,[T]->[T]) : prepend element to a row (T is any type)

operator #: (int,[vec]->mat): combine columns of given fixed height into matrix
operator ^: (int,[vec]->mat): combine rows of given fixed length into matrix
stack_rows: ([vec]->mat) : combine ragged rows into matrix, zero-extend shorts

operator ## : (string,string->string): concatenation of two strings
operator ## : ([string]->string): concatenation of row of strings
operator ## : (vec,vec->vec) : concatenation of two vectors
operator ## : ([vec]->vec) : concatenation of row of vectors
operator ## : ([T],[T]->[T]) : concatenation of two rows (T is any type)
operator ## : ([[T]]->[T]) : concatenation of row of rows (T is any type)

error: (*,...->*) : print values and abort computation; report a runtime error

to_string:(*,...->string): string representation of arguments (concatenated)
print: (T->T): print value, followed by newline; return same value
prints: (*,...->): print values raw (no quotes or commas) followed by newline
ascii: (string->int): ASCII code of initial character, or -1 if string empty
ascii: (int->string): string of length 1 with given ASCII code (if safe value)

readline_completions: (string->[string]): list of completions of a prefix
  The result of this function depends on the atlas session and evolves during
  each session. Interpreting the argument as a prefix of an identifier, the
  result is the list of all identifiers currently in use, as well as keywords,
  whose name starts with that prefix. Being currently in use means either being
  defined as a (global) variable, or being defined at least once as a function.

{ in bitwise operations, an integer n represents a finite (if n>=0) or co-finite
  if (n<0) set of natural numbers, the positions (from 0 on the right) of their
  set bits (for n<0, these are the complement of those for -1-n, which is >=0 }

AND,OR,XOR: (int,int->int): bitwise AND|OR|XOR of the integers
AND_NOT: (int,int->int): bitwise AND NOT: AND_NOT(n,m) = AND(n,-1-m)
bitwise_subset: (int,int->bool): fast test whether AND_NOT(arguments)=0
nth_set_bit: (int,int->int): position of n-th bit 1 of k (from 0 at the right)
  Here n is the first argument, and k the second argument of nth_set_bit.
  If k>=0 then number N(k) of bits 1 of k is finite; for n>=N(k) returns -1.
  If k<0 and n>=0 this always returns a nonegative number (indeed at least n)
  If n<0 returns nth_set_bit(-1-k,-1-n), so searches among the bits 0 of k
bit_length: (int->int): for n>=0 return least k>=0 such that n<2^k
  If n<0 returns the well defined negative value -1-bit_length(-1-n)
to_bitset: (vec->int): bitset with bit i set iff i occurs in v as entry
  Negative vector entries are rejected, and result is always non-negative

floor: (rat->int): closest integer <= rational (round down, same as r\1)
ceil: (rat->int): closest integer >= rational (round up, same as -floor(-r))
frac: (rat->int): fractional part of rational (same as r%1 or as r-floor(r))

null: (int->vec): null vector of given length
null: (int,int->mat): null matrix with given number of rows and columns
id_mat: (int->mat): identity matrix of given size.
diagonal: (vec->mat): square diagonal matrix with given diagonal entries.
shape : (mat->int,int): dimensions (rows,columns) of a matrix
rows: (mat->[vec]): the matrix transformed into its list of rows
columns: (mat->[vec]): the list of columns (same result as coercion to [vec])
row: (mat,int->vec): row(M,i) is the row of the M at index i
column: (mat->[vec]): column(M,j) is the column M[j] of the M at index j

swiss_matrix_knife: (int,mat,int,int,int,int->mat): slice and dice a matrix
  This function selects a block from a matrix, and depending on the options in
  its first argument can apply a number of transformations on the fly. The
  basic call swiss_matrix_knife(0,A,i,k,j,l) returns the block A[i:k,j:l] (and
  is in fact used behind the scenes to implement that syntax). The first
  (integer) argument specifies 8 options (its value is taken modulo 2^8=256)
  as follows. Bits 0,1,2 modify row indexing: setting bit 0 reverses the rows
  before selecting, and bits 1,2 when set specify that i respectively k count
  from the end (they are subtracted from the number of rows before being
  used). Similarly bits 3,4,5 modify column indexing. Bit 6 when set specifies
  that the resulting block is transposed, and bit 7 when set indicates that
  all entries of the resulting matrix are negated (they are multiplied by -1).

gcd: (vec->int): the greatest common divisor of all entries of the vector
Bezout: (vec->int,mat): gcd of entries, and linear map sending v to (d,0,0,...)
  In addition to finding the gcd d like the previous function this also produces
  an invertible matrix (change of coordinates) that sends the argument vector v
  to d times the first canonical basis vector. That means the first row has a
  sequence of Bezout coefficients (for the gcd) and the other rows are sequences
  that similarly produce 0, so any combination of them can be added to the
  sequence of Bezout coefficients to produce another valid such sequence.
echelon: (mat->mat,mat,[int],int): column echelon form, with extra information
  This applies to the n*m matrix A column operations and possibly removal of
  null columns to obtain an n*k matrix M (with k<=m) and an unimodular matrix C
  that records the column operations performed; an increasing sequence s of k
  "pivot rows" and the a sign eps equal to the determinant of C are also
  recorded for convenience: the quadruple (M,C,s,eps) is returned. The column
  echelon form is a reverse one both horizontally and vertically: each column
  has a "pivot entry" which has a positive value, is the last nonzero entry of
  its column and the first nonzero entry of its row. The matrix C is the result
  of applying to an m*m matrix initialized as identity the same column
  operations that were a applied to A, except that column removal is replaced in
  C by moving the column to the right end; as a consequence A*C equals M
  extended by m-k zero columns (so the last m-k columns of C are a basis of the
  kernel of A). For each j with 0<=j<k one the entries M[s[j],j] is nonzero (the
  pivot entry) and M[i,j]=0 for i>s[j].
linear_solve: (mat,vec->(void|vec,int,mat)) Complete solution for x of A*x=b
  For a matrix A and vector (of same height as A) the affine space of rational
  solutions x to the equation A*x=b is sought. If none exist the first variant
  of the union type is returned, with tag empty_set, otherwise the space is
  returned in the form (v,n,M) where n is the minimal numerator required (so
  integer solutions exist only if n=1), v/n is a particular solution and the
  (linearly independent) columns of M span the kernel of A, so that all other
  solutions are obtained from v/n by adding a vector in that span.
diagonalize: (mat->vec,mat,mat): partial Smith reduction, without divisibility
  Applies row and column operations to the matrix to obtain diagonal form;
  returns the list of non-zero diagonal entries (all except the first are
  assured to be positive), and the pair of determinant 1 integral matrices
  that have been applied to left and right respectively.
adapted_basis: (mat->mat,vec): find basis whose integer multiples span image
  Returns for an n*m matrix M a pair (B,c) of an invertible n*n matrix B (so
  its columns form a basis of Z^n) and matching list c of k<=m positive
  integers, such that the multiples c_j*B_j of the first k columns of B
  span the image lattice of M (the lattice spanned by the columns of M).

kernel: (mat->mat): find matrix whose columns span kernel of the given matrix
eigen_lattice: (mat,int->mat): eigen-lattice of matrix (at integer eigenvalue)
  eigen_lattice(M,lambda) = kernel(M-lambda), where M is square matrix
row_saturate: (mat->mat): keep same kernel, but row-span saturated sublattice
  Interpreting rows of the matrix as linear forms, this transforms the system
  into an equivalent one, and whose Z-linear map is made to be surjective.
  In other words, the rows are made linearly independent, and the sublattice
  they generate saturated: if an integer multiple of v is in it, then so is v.

Smith: (mat->mat,vec): Smith normal form basis and invariant factors (no zeros).
  The result classifies precisely the sublattice spanned by the columns of M.
  The first component is an invertible matrix, whose initial columns, multiplied
  by the corresponding entries of the second component, span that sublattice.
  That second component is the list of the invariant factors of M, which are
  like the second component of adapted_basis(M), but with additional requirement
  that each entry divides the next; this may involve using a different basis.

invert: (mat->mat,int): invert(M)=inv,d such that M*inv=d*Id, with d minimal.
  The inverse matrix, represented as an integral numerator matrix inv, and a
  minimal positive common denominator d. Note: d does not mean determinant.
mod2_section (mat->mat): find section (left/right/inverse) of binary matrix
  The argument is reduced modulo 2 to a matrix A over Z/2Z; it returns a
  matrix B such that ABA=A and BAB=B; it will be an inverse/left inverse/right
  inverse of (over Z/2Z) whenever A is bijective/surjective/injective.

subspace_normal: (mat->mat,mat,mat,[int]) normalized modulo-2 basis
  Given a sequence of binary vectors, namely the reduction modulo 2 of the
  columns of the argument matrix, find a normalized basis for the subspace they
  span (a matrix in reduced column echelon form without zero columns), and also
  expressions for the basis vectors in terms of the given list, a basis for the
  relations between the vectors, and a list of pivot values (each list given as
  a matrix with the specified vectors as its columns). The argument is a list of
  n generators of size r whose components are interpreted modulo 2, the first
  output component is a reduced echelon basis, consisting of d binary vectors of
  size r where d is the dimension of the subspace, the next component has d
  binary vectors of size n, giving the combination of generators that produced
  this basis vector, the next component has n-d binary vectors of size n, each
  giving basis of the linear dependency relations among the generators, and the
  final component is an increasing sequence of non-negative d integers less than
  r giving the pivot (first nonzero) positions in each of the basis vectors.

Lie_type: (string->LieType): interpret string as Lie type.
  Factors are one of "ABCDEFGT" followed by a number; several factors can be
  concatenated in a string with optional punctuation. Must have total rank<=32
extend: (Lie_type,string,int->Lie_type): add a single (type,rank) pair to type
  In extend(lt,t,r), a factor (type,r) is added to the Lie type lt, where type
  is given by the first character of t (or is 'T' if t is the empty string).
simple_factors: (Lie_type->[string,int]): list of codes for the simple factors
  Each simple factor is identified by a one-letter string "A","B",...,"G" paired
  with the rank of a factor of that type; any central torus factor is ignored
rank: (Lie_type->int): rank, including both simple factors and any central torus
operator * : (LieType,LieType->LieType): concatenate Lie types
Lie_type: (RootDatum->LieType): Lie type of a root datum.

operators =, != : (LieType,LieType->bool) equality of Lie types (order matters)
operator % : (LieType->[string,int]) Expand into row of simple factors codes
  Each simple factor is described by a one-letter string and an integer rank,
  while factors ("T",1) are contributions to the central torus

Cartan_matrix: (LieType->mat): Cartan matrix of Lie type (square of size rank).
  A block form Cartan matrix, with zeros in rows and columns of torus factors
Cartan_matrix_type: (mat->LieType,[int]): type given by Cartan matrix.
  The input should be a Cartan matrix for a semisimple type (no zero rows or
  columns). The function returns the semisimple type, and the permutation of
  mapping the standard (Bourbaki) ordering of the diagram of that type to the
  positions of the (co)roots corresponding to then in matrix rows and columns.
is_Cartan_matrix: (mat->bool): whether calling Cartan_matrix_type is safe
  This function can be used to protect code that fails for non-Cartan matrices,
  calling Cartan_matrix_type directly, or indirectly by constructing root data

Smith_Cartan: (LieType->mat,vec): generators of weights modulo roots.
  Find a Smith basis for the weight lattice relative to the sublattice of
  roots, with corresponding invariant factors. It is almost equivalent to
  Smith(^Cartan_matrix(type)), except that (1) Smith_Cartan produces a
  separate diagonal block for each simple or torus factor, (2) for factors 'T'
  of the Lie type, Smith_Cartan produces a column with just '1' on the
  diagonal, but with corresponding "invariant factor" set equal to '0', and
  (3) for factors D_{2n} an equivalent basis is given, which has been tweaked
  so that the final two vectors are standard basis vectors.

filter_units: (mat,vec->mat,vec): discard entries '1' and their columns.
  The input is presumably produced by 'Smith_Cartan' or 'adapted_basis'; for
  all positions where the second (vector) component has '1', that entry and
  the corresponding column of the first matrix is discarded; what is left of
  the matrix and the vector is returned. If the vector has fewer entries than
  the matrix has columns (cf. adapted_basis), missing entries count as not 1.

ann_mod: (mat,int->mat): find maximal matrix with product divisible by d.
  The call ann_mod(M,d) finds a square matrix A whose columns have the same
  height as those of M and span a maximal sublattice subject to the condition
  that the scalar product of every column of A with every column of M is
  divisible by d (the matrix product ^A*M vanishes modulo d).

replace_gen: ((mat,vec),mat->mat): replace generators of weight lattice.
  The arguments are as for 'filter_units'. For every entry different from '1'
  in the vector argument, replace a column from the first matrix by a column
  from the second matrix. Both matrices must have the same column size; like
  for 'filter_units' the vector may be short, missing entries being not 1.

involution: (LieType,[int],string->mat): diagram involution for inner class.
  Return an involution matrix for simply connected times central torus datum,
  given by the Lie type and the permutation (second argument, which maps
  positions in the diagram to positions in the root list), the involution being
  described symbolically by the string. It is interpreted as the inner class
  string is in Fokko, where 'e' or 'c' mean compact (equal rank), 'u' means
  unequal rank (for types A_n with n>1, D_n and E_6), 's' means split, and
  'C' means Complex. The result is almost always a permutation matrix, but for
  the split type on (central) torus factors there is a diagonal entry -1
involution: (LieType,mat,string->mat): basic involution on given basis.
  This is like previous 'involution' for the same Lie type and inner class
  string, but the involution matrix is now expressed the given basis given by
  the columns of the matrix specified as second argument; this expression must
  be possible, so the sublattice spanned should be stable under the involution

root_datum: (mat,mat,bool->RootDatum): root datum from simple (co)root systems.
  In root_datum(roots,coroots), matrices roots and coroots must have the same
  dimensions (rank x semisimple rank); their columns give the desired systems
  of simple roots respectively simple coroots. The matrix of pairings of roots
  and coroots should be a valid Cartan matrix. A root datum with those systems
  of simple roots and simple coroots is returned. The final argument tells
  whether the coroots rather than the roots should be ordered by increasing
  level (in all cases corresponding roots ad coroots are at the same index).
root_datum: (LieType,mat,bool->RootDatum): root datum from type and sublattice.
  The columns of the matrix argument are interpreted as specifying the basis
  of a sublattice of the character lattice of the "simply connected" group G
  of the given Lie type (which is a direct product of a simply connected
  semisimple group G' and a central torus S), expressed in the basis of
  fundamental weights of G' and an arbitrary basis for characters of S). For
  this to be possible, it is required that the sublattice contain the root
  lattice of G'. The sublattice becomes the standard lattice X^* for the root
  datum, and is identified with Z^n using the given basis. The final argument
  has the same meaning as when constructing from simple (co)root matrices.
root_datum: (RootDatum,mat->RootDatum): root datum for sublattice in old one
  This is like root_datum@(LieType,mat), but starting from the specified root
  datum rd rather than from the simply connected one for the Lie type. The
  provided sublattice matrix must be square and full rank (invertible of the
  rational numbers) and the roots of rd must be in its integral column span.
root_datum: (InnerClass->RootDatum): root datum of inner class.
  Extract the root datum from the InnerClass value
dual_datum: (InnerClass->RootDatum): dual root datum of inner class.
  Extract the dual root datum from the InnerClass value

operators =, != : (RootDatum,RootDatum->bool) equality of Root data
  Tests identical simple_roots, simple_coroots matrices, and prefers_coroots
prefers_coroots: (RootDatum->bool): whether coroots were used for generation
  This recovers the attribute governing the order of roots and coroots, set
  during construction from argument or inheriting from an earlier root datum.
Cartan_matrix: (RootDatum->mat): Cartan matrix of root datum.
  This pairs roots and coroots, so it is square, of size the semisimple rank.
  By force of convention, rows correspond to roots and columns to coroots.
rank: (RootDatum->int) Rank of the weight lattice for this Lie type.
semisimple_rank: (RootDatum->int) Rank of the root lattice of  this Lie type.
nr_of_posroots: (RootDatum->int) Number of positive roots in the root datum.
two_rho: (RootDatum->vec): The sum of all positive roots in the root datum.
two_rho_check: (RootDatum->vec): The sum of all positive coroots in root datum.

simply_connected: (LieType,bool->RootDatum): "simply connected" datum for type.
  This gives the root datum for the "simply connected" group of the given type
  (the direct product of a simply connected G' with a central torus): one has
    simply_connected_datum(type,b) = root_datum(type,id_mat(rank),b)
  The final argument has the 'refers_coroots' meaning, as in root_datum versions
adjoint: (LieType,bool->RootDatum): "adjoint" root datum for given type.
  Here the sublattice for the semisimple factor is the root lattice, with
  simple roots as basis; for the central torus an arbitrary basis is used.
  Dual to simply_connected: adjoint(type,b) = dual(simply_connected(type,not b))
  The final argument has the 'refers_coroots' meaning, as in root_datum versions

root, coroot: (RootDatum,int->vec): root/cooroot with given index in root system
  Indexing is from -nr_of_posroots(rd) up to nr_of_posroots(rd)-1, with
  negative indices giving negative (co)roots, and non-negative indices giving
  positive (co)roots; simple (co)roots are consecutive from index 0 upwards.
root_index: (RootDatum,vec->int): Index of root with respect to posroots
coroot_index: (RootDatum,vec->int): Index of coroot with respect to poscoroots
  These functions return the index of the root/coroot in the root system rd, or
  return nr_of_posroots(rd) if the argument is not found among the (co)roots.
  The indexing is as in the root/coroot functions above, so if found, the
  index i returned has -nr_of_posroots(rd) <= i < nr_of_posroots(rd).
root_expression: (RootDatum,int->vec): Express root additively in simple roots
  So for v=root_expression(rd,i) one has root(rd,i)=sum_j=0^{r-1}v[j]root(rd,j)
  where r=semisimple_rank(rd). The root (index) can be negative or positive.
coroot_expression: (RootDatum,int->vec): Express coroot as sum of simple coroots
  So coroot_expression(rd,i) is the same as root_expression(dual(rd),i)
is_long_root: (RootDatum,int->bool): Whether a root is considered to be long
is_long_coroot: (RootDatum,int->bool): Whether a coroot is considered to be long
  Being long is defined to mean having a pairing strictly less than -1 with
  some (co)root other than its the dual of its own opposite. This gives usual
  "long" in types Bn,Cn,G2,F4, and always "short" short simply laced types.
root_involution : (RootDatum,int->vec): full system involution for reflection
  Renumbering the full root system from 0 for the most negative root, this gives
  the involution of those roots for the reflection for the given root/coroot
root_ladder_bottoms: (RootDatum,int->[int] Starting indices of root ladders
  For (rd,i) the gives those j for which root(rd,j)-root(rd,i) is not a root
coroot_ladder_bottoms: (RootDatum,int->[int] Starting indices of coroot ladders
  For (rd,i) the gives those j for which coroot(rd,j)-coroot(rd,i) is no coroot
fundamental_weight: (RootDatum,int->ratvec): fundamental weight number $i$
fundamental_coweight: (RootDatum,int->ratvec): fundamental coweight number $i$

simple_roots: (RootDatum->mat): matrix of simple roots in the root datum.
simple_coroots: (RootDatum->mat): matrix of simple coroots in the root datum.
posroots: (RootDatum->mat): matrix of positive roots in the root datum.
poscoroots: (RootDatum->mat): matrix of positive coroots in the root datum.
  Individual roots/coroots are columns of these matrices, which is somewhat
  unnatural in the case of coroots, but necessary to be able to do a for-loop
  over these matrices, which loops over its columns. The result is given as a
  matrix instead of as a list of vectors because this retains the information
  about the rank (number of rows of the matrix) even when there are 0 columns.
root_coradical: (RootDatum->mat): simple roots and coradical basis.
  With respect to simple_roots, add columns for coradical basis generators
coroot_radical: (RootDatum->mat): simple coroots and radical basis.
  With respect to simple_coroots, add columns for radical basis generators

dual: (RootDatum->RootDatum): dual of given root datum.
  This operation preserves the numbering of the roots, interchanging just what
  it calls roots and coroots. This implies that the ordering may differ from
  the one in which a root datum for the dual type would be constructed in
  isolation: notably the final root of |dual(rd)| may not be its highest one,
  even if the root datum is of semisimple type.
derived_info: (RootDatum->RootDatum,mat): information for the derived group
  The first result is the root datum for the derived group itself, the second
  result is a matrix mapping weights from the original to the derived datum.
  Although coordinates change, the Cartan matrix is unchanged in the result.
mod_central_torus_info: (RootDatum->RootDatum,mat): quotient by central torus
  The (semisimple) root datum obtained by quotienting by the central torus,
  and matrix embedding weights for the quotient datum into the original datum.
  Although coordinates change, the Cartan matrix is unchanged in the result.

integrality_datum: (RootDatum,ratvec->RootDatum): integral coroots subdatum
  Applied to (rd,gamma), forms the root datum whose coroots form the closed
  subsystem of the coroots of rd that take an integral value on gamma.
integrality_rank: (RootDatum,ratvec->int): semisimple rank of integrality datum
is_integrally_dominant: (RootDatum,ratvec->bool): dominance for integral coroots
  So integrally_dominant(rd,gamma) holds if and only if there are no positive
  coroots alpha_v for which alpha_v*gamma is a (strictly) negative integer
integrality_points: (RootDatum,ratvec->[rat]): fractions with integrality
  The call integrality_points(rd,lambda) returns the increasing list of
  positive fractions f<=1 so f*lambda has more integrality than generically:
  for some coroot alphav one has integral and nonzero value <alphav,f*lambda>.

Weyl_orbit: (RootDatum,vec->mat): Weyl group orbit of a weight
Weyl_orbit: (vec,RootDatum->mat): Weyl group orbit of a coweight
  In both functions the weights or coweights are the columns of the result;
  the order of these columns is not specified (though there is a system to it,
  for instance the orbit always starts with its dominant (co)weight).
Weyl_orbit_ws: (RootDatum,vec->[WeylElt]): Weyl group elements for weight orbit
Weyl_orbit_ws: (vec,RootDatum->[WeylElt]): Weyl group elements, coweight orbit
  These functions produce lists of Weyl group elements whose action on the
  initial (co)weight will produce its orbit, in the same order as |Weyl_orbit|

W_elt: (RootDatum,[int]->WeylElt): Make a WeylElt from a word in W-generators
  The root datum specifies the type of Weyl group, the vector gives the word in
  terms of simple reflections (indexed from 0) defining the Weyl group element
word: (WeylElt->[int]): chosen reduced Weyl word for a Weyl group element
root_datum: (WeylElt->rootDatum): Root datum underlying a Weyl group element
length: (WeylElt->int): Length in Weyl group of an element
operators =, != : (WeylElt->bool): test Weyl group element against identity
operators =, != : (WeylElt,WeylElt->bool): comparison of Weyl group elements
  The elements must be from equal or dual root data; if not, reports an error
operator * : (WeylElt,WeylElt->WeylElt): Compose Weyl group elements
operator / : (WeylElt->WeylElt): Inverse of Weyl group element
operator # : (WeylElt,int->WeylElt): multiply Weyl group element and generator
operator # : (int,WeylElt->WeylElt): multiply generator and Weyl group element
operator ## : (WeylElt,[int]->WeylElt): Compose Weyl group element and Weyl word
operator ## : ([int],WeylElt->WeylElt): Compose Weyl word and Weyl group element
operator * : (WeylElt,vec->WeylElt): left-act by Weyl group element on weight
operator * : (vec,WeylElt->WeylElt): right-act on coweight by Weyl group element
from_dominant: (RootDatum,vec->WeylElt,vec): write as W image of dominant weight
  Called for (rd,lambda), find in the orbit of lambda under the Weyl group W
  of rd the dominant weight v, and minimal w in W with lambda=w*v; return (w,v)
from_dominant: (vec,RootDatum->vec,WeylElt): write as dominant coweight * W-elt
  Called for (cowt,rd), find in the orbit of cowt under the Weyl group W of rd
  the dominant coweight v, and minimal w in W with cowt=v*w; return (v,w), Note
  that using form_dominant(dual(rd),cowt) instead would rather return (w^{-1},v)
root_permutation : (WeylElt w->vec): defined permutation of full root system
  Renumbering the full root system from 0 for the most negative root, this gives
  the permutation of those roots of the left action of the Weyl group element

quotient_basis: (LieType,[ratvec]->mat): sublattice given by kernel generators.
  Interpret the rational vectors as kernel generators for the given type, as
  in the Fokko program, and return the corresponding sublattice as a matrix
  whose column are its generators. More precisely, the rational vectors
  represent linear combinations of certain coweights in the dual basis to a
  basis of the weight lattice adapted to the root lattice; for those weights
  in the latter basis that already lie in the root lattice, the corresponding
  coweight is omitted, since there are no useful rational multiples of it
  anyway. Return a basis for the sublattice of X^* of weights on which all
  kernel generators have integer evaluation. If M is the matrix whose columns
  are the numerators of the kernel generators, brought to a common denominator
  d, this amounts to setting S=Smith_Cartan(type) and (C,)=filter_units(S),
  and then returning the value replace_gen(S,C*ann_mod(M,d)).
  This function is intended for use in constructing root data; see basic.at

classify_involution: (mat->int,int,int): determine type of lattice involution
  For any linear involution of Z^n, there is a basis consisting of certain
  vectors that are eigenvectors with eigenvalues 1 or -1 for the involution,
  and of pairs of vectors that are interchanged by the involution. The numbers
  of such vectors for each eigenvalue and of interchanged pairs determine the
  involution up to base change. This function, which requires its argument to
  be the matrix of an involution, returns these three numbers in the following
  order: eigenvectors for 1 (compact rank), pairs of interchanged vectors
  (Complex rank), eigenvectors for -1 (split rank).

inner_class: (RootDatum,mat->InnerClass): inner_class of G from involution
  This is the basic function for building a complex reductive group equipped
  with an involution from the root datum and that involution; the latter is
  given on the lattice basis of the root datum, and must describe an
  involutive automorphism theta of the root datum. If theta is not a based root
  datum involution, it is replaced by some w*theta that is, with w in W
twisted_involution (RootDatum,mat->WeylElt,InnerClass): extra info inner_class
  Build an inner class as the above function, by also return the Weyl element w
  (twisted involution) for which w*theta gives the distinguished involution
  (the element w is first component of result to remind us it acts on the left)

operators =, != : (InnerClass,InnerClass->bool): (non)identity of inner classes
  Equality holds only when both inner classes are built on identical root data,
  and have the same distinguished involution (based root datum automorphism)
distinguished_involution: (InnerClass->mat): involution of the inner class.
  Extract the distinguished involution of X^* that defines the inner class
dual: (InnerClass->InnerClass): dual inner class for dual complex group

nr_of_real_forms: (InnerClass->int): number of real forms in inner class
nr_of_dual_real_forms: (InnerClass->int): number of dual forms in inner class
nr_of_Cartan_classes: (InnerClass->int): total number of Cartans in inner class

block_sizes: (InnerClass->mat): matrix giving the block sizes.
  This is essentially the same as the output of 'blocksizes' in Fokko; the
  rows of the matrix correspond to real forms for the inner class, and the
  columns correspond to dual real forms for the inner class

form_names: (InnerClass->[string]): list of names of real forms.
  These are the same names used in Fokko, describing real Lie algebras
dual_form_names: (InnerClass->[string]): list of names of dual real forms.
  These are the names for the real forms of the dual InnerClass value

occurrence_matrix: (InnerClass->mat): real form-Cartan class incidence matrix
  For the given inner class, construct a matrix whose rows are parametrized by
  the real forms, and whose columns are parametrized by the Cartan classes,
  showing whether (1) or not (0) the Cartan class occurs for the real form
dual_occurrence_matrix: (InnerClass->mat): dual real form-Cartan class matrix
  This is like occurrence_matrix, but with rows representing dual real forms


real_form: (InnerClass,int->RealForm): select a real form from inner class.
  The result of form_names describes the valid range and names of real forms;
  this function actually constructs a real form from the list, selected by its
  position (starting from 0). The list is always the same for a given inner
  class (independent of other computations), unlike the list of Cartan classes
  for a real form as discussed below
inner_class: (RealForm->InnerClass): inner class containing the form
form_number: (RealForm->int): index of the real form in its inner class

quasisplit_form: (InnerClass->RealForm): quasisplit form for the inner class
  This is the last one in the list of real forms for the fundamental Cartan
  (number 0 in the list) of the inner class

components_rank: (RealForm->int): rank of the component group
  The group of connected components of the real Lie group defined by a real
  form is an elementary 2-group (Z/2Z vector space); this function gives its
  rank, so the number of connected components is 2^components_rank(rf)

nr_of_Cartan_classes: (RealForm->int): number of Cartan classes for real form

operators =, !=: (RealForm,RealForm->bool): (in)equality of real forms
  It means they belong to an identical inner class (not two inner classes
  created separately from identical arguments), and have same form number

KGB_size: (RealForm->int): size of the set K\G/B for this real form
base_grading_vector: (RealForm->ratvec): Offset implicit in torus_bits values
  The binary vectors torus_bits for elements of the KGB associated to a real
  form are relative to a special torus element t0, and this function produces
  a dominant rational coweight c for which \exp(\pi i c) equals this t0.
  The choice of t0 and of c are constant for each "square class" of real forms
  (which are grouped together in the output of print_strong_real for the
  fundamental Cartan), for which the squares of any of their strong
  involutions are the same torus element z: the choice of c is subject to
  \exp(2\pi i(c+rho_check))=z which reflects (t0)^2\exp(2\pi i rho_check)=z.
  Apart from z, the choice of c (or of t0) defines an implicit "base grading"
  of the simple roots at the distinguished involution of the inner class, by
  the parity of the (integer) pairing of c with the simple root. Here "odd"
  corresponds to grading 0, due to the mentioned rho_check: so c differs by
  rho_check from some "infinitesimal cocharacter" g chosen for the real form.
  A standard choice for c is determined by the base grading for the weak real
  form, whence the name of this function. However for real forms synthesized
  by the function real_form@(InnerClass,mat,ratvec), the arguments of that
  call may determine a different value of z, in which case a different choice
  for c is made to match it. The choice of c then depends on z only; in
  particular it will be the same for real forms synthesized using different
  strong involutions for the same real group, and such groups will test equal.

Cartan_order: (RealForm->mat): matrix describing ordering of Cartan classes
  The Cartan classes for a given real form form a partially ordered set; this
  function returns this partial ordering in the form of a square 0-1 matrix
KGB_Hasse: (RealForm->mat): Hasse diagram of Bruhat order on K\G/B
  The Bruhat order x<=y among K-orbits in G/B describes when x is contained in
  the (topological) closure of y. KGB_Hasse(G) is a matrix describing the Hasse
  diagram of this finite partial order: the set of pairs (x,z) for which the
  interval { y | x<=y<=z } contains exactly the two elements, namely x et z.
  The matrix is indexed by the numbers #x of the K\G/B elements x, and the
  entry at (#x,#z) is 1 when (x,z) is in the Hasse diagram, and 0 otherwise.

dual_real_form: (InnerClass,int->RealForm): select a dual real form
  This is like real_form, but selects a dual real form for the inner class
  (whose names are given by dual_form_names) by index. This is intended for
  functions that require both a real form and a dual real form for a given
  inner class; the compatibility between them is tested by a runtime check.
dual_quasisplit_form: (InnerClass->RealForm): quasisplit dual real form

Cartan_class: (InnerClass,int->CartanClass): Cartan class selected by number
  This selects a Cartan class by number in the list of all Cartan classes for
  this inner class. The numbering is fixed, and compatible with  the partial
  ordering on Cartan classes where more split ones are considered greater

Cartan_class: (RealForm,int->CartanClass): Cartan class selected by number
  This selects a Cartan class by number in the list of Cartan classes defined
  for this real form. The numbering is not the same as when selecting a Cartan
  class directly from an inner class, unless the real form is quasisplit.

most_split_Cartan: (RealForm->CartanClass): most split Cartan class for form
  The most split Cartan class of a given real form is the last one in the list
  of its Cartan classes, so
    set most_split_Cartan(RealForm rf)=Cartan_class(rf,count_Cartans(rf)-1)

involution: (CartanClass->mat): weight lattice involution for Cartan class
Cartan_info: (CartanClass->(int,int,int),vec,(int,int),(LieType,LieType,LieType)):
  Information about the Cartan class, essentially that given by the output of
  'cartan' in Fokko (except for the final partition corresponding to the real
  forms for this Cartan class, for which see fiber_partition).
  The first triple of integers gives in order the number of compact (U(1)),
  complex (GL(1,C)), and split (GL(1,R)) factors of the real torus defined by
  this Cartan class. Follows the canonical twisted involution for the Cartan
  class, a pair of integers giving the number of distinct twisted involutions
  defining this same Cartan class and their fiber size, and finally the types
  of the imaginary, real, and complex root subsystems (note the order here).

real_forms: (CartanClass->[RealForm]): list of real forms with given Cartan
  Returns a list of the real forms for which this Cartan class occurs
dual_real_forms: (CartanClass->[RealForm]): list Cartan's dual real forms
  Returns a list of the dual real forms for which this Cartan class occurs

square_classes: (CartanClass->[[int]]): partition real forms by square class
  This returns a list of lists of numbers that identify real forms in the
  inner class. All real forms whose representative strong involutions may
  square to the same value in the center are grouped together in a sublist
  (the number of sublists is a power of 2). Each number occurs only in a
  single sublist, but may be repeated, which indicates that there are multiple
  orbits of strong involutions (strong real forms) for the same real form.
  The value returned represents a part of the print_strong_real output.
fiber_partition: (CartanClass,RealForm->[int]): identifying part of fiber group
  This produces an increasing sequence of integers that characterizes the real
  form relative to the CartanClass. It describes a part of the adjoint fiber
  group associated to the Cartan class (an elementary 2-group of rank r equal
  to the number of compact factors of the real torus in the _adjoint_ group
  defined by the Cartan class), whose elements are represented by numbers 0 to
  2^r-1; as the real form traverses all those for which this Cartan class
  occurs, the results of the function form a partition of that set of numbers.

real_form: (InnerClass,mat,ratvec->RealForm): real form from strong real form
  Synthesize a real form defined by an involution and a torus factor. With
  arguments (ic,M,v), the matrix M should define an involution theta in the
  inner class. The rational vector v, after being made right M-fixed by right
  multiplication by (M+1)/2, defines a torus element \exp(\pi i v) whose
  square must be central, which means that v*alpha must be integral for all
  (simple) roots alpha. If this holds then theta and torus_factor v together
  define a strong involution representative. The function returns the strong
  real form rf identified by that strong involution. It may differ from
  real_form(ic,form_number(rf)), the standard version of this weak real form;
  the difference can be seen through the value of base_grading_vector(rf), and
  in the RealForm equality test (because of this distinction, one may consider
  the result to represent a strong real form). Real forms produced by this
  function are said to be synthesized (rather than selected). A subsequent
  call KGB_elt(rf,theta,v) should always produce a valid KGB element x. The
  grading of the imaginary roots alpha for theta defined by this x will be
  given by the parity of < v+\check\rho_i, \alpha >, where \check\rho_i is
  half the sum of the positive imaginary coroots for M (its presence in the
  formula ensures that v=0 is always valid, and grades all simple-imaginary
  roots as noncompact). This grading is the most tangible aspect of (theta,v),
  but only determines the weak real form, and may fail to identify a unique
  KGB element x; this function and the mentioned instance of KGB_elt are
  faithful beyond just reconstructing the correct grading.
central_fiber: (RealForm->[vec]): Set of torus bits not affecting any gradings
  These are binary vectors that can be added to |torus_bits| of KGB elements
  in the fundamental fiber to get another KGB element giving the same status
  (including compactness of imaginary roots) to every simple root; adding any
  of these values to torus bits defines an automorphism of the KGB structure
initial_torus_bits: (RealForm->vec) Torus bits for initial KGB element
  This test computes the torus bits of KGB(G,0) as used in the implementation to
  initialise the construction of the KGB structure for G. Contrary to computing
  torus_bits(KGB(G,0)), calling this function does not require the KGB set for
  G to be actually generated, so it should be fast even when that set is large.

KGB: (RealForm,int->KGBElt): select a KGB element x among those of a real form
  The call KGB(i,rf) selects the element in line i of the print_KGB(rf)
  output.
%: (KGBElt->RealForm,int): real form and number; inverse of KGB@(RealForm,int)
Cartan_class: (KGBElt->CartanClass): the Cartan class for the KGB element
involution: (KGBElt->mat): the involution of X^* associated to the KGB element
length: (KGBElt->int): length of the element within its KGB set
status: (int,KGBElt->int): status of root (by index) on KGB element, scale 0..4
  Encoding 0: Complex descent, 1: imaginary compact, 2: real,
  3: imaginary non-compact, 4: Complex ascent
cross: (int,KGBElt->KGBElt): cross action for (posrootnr,KGB element)
  Returns result of cross action by root reflection of the given KGB element
Cayley: (int,KGBElt->KGBElt): Cayley transform for (posrootnr,KGB element)
  Returns either the Cayley transform or an inverse Cayley transform of the
  KGB element through the given positive root, or returns that element itself
  when neither is defined. If defined, one can find which it is using status,
  and whether there is a second inverse Cayley transform can be found out by
  applying cross action to the result; it either returns the same result,
  which signifies a single-value inverse Cayley, or else the second value
twist: (KGBElt->KGBElt): twist of KGB element x, useful for Hermitian dual
  This is defined by conjugation of x by the distinguished involution delta
twist: (KGBElt,mat->KGBElt): twist of KGB element x by an external involution
  The result of conjugation of x by the given involution of the weight lattice
torus_factor: (KGBElt->ratvec): coweight for KGB element, twice that in print_X
  This is a \theta^t stable rational vector v with integral evaluations on
  all imaginary roots; interpreted modulo the image of 1+\theta^t acting
  on X_*, so in particular modulo (2\Z)^n. For an imaginary root \alpha
  the scalar product < v + \check\rho_i , \alpha > determines whether \alpha
  is compact (if even) or noncompact (if odd). Together with the inner class
  and the involution, this value completely characterizes the KGB element (and
  its real form), and it can be reconstructed using the KGB_elt function below.
torus_bits: (KGBElt->vec): torus part of KGB element as vector of 0,1 values
  A vector of size the rank that distinguishes between different KGB elements
  at the same involution, in the format used internally. From this the value
  torus_factor(x) is computed using base_grading_vector(rf)-torus_bits(x), for
  the real form rf of x, which value is then symmetrized for \theta^t.
KGB_elt: (RealForm,mat,ratvec): KGB element defined by rational coweight
  This function finds a KGB element x such that real_form(x), involution(x),
  and torus_factor(x) match the values (rf,M,v) given as arguments. The
  interpretation for the (involution) matrix M and rational (coweight) vector
  v are as for real_form@(InnerClass,mat,ratvec); moreover rf should be equal
  to the real form returned (for this inner class) by real_form(ic,M,v), and
  the difference v-base_grading_vector(rf) must be an integer vector. There is
  then at most one KGB element x for rf such that torus_factor(x) is congruent
  to v modulo the image of ^M+1 (i.e., M+1 applied on right), which x is then
  returned by this function (if no such x is found, an error is signaled).

operators =, != : (KGBElt,KGBElt): equality of elements of a same KGB set
  Equality of KGB elements implies equality of their real forms

block: (RealForm,RealForm->Block): construct traditional block as in Fokko
%: (Block->RealForm,RealForm): decompose block, inverse of 'block'
#: (Block->int): number of elements of block
element: (Block,int->KGBElt,KGBElt): KGB and dual KGB values for block element
index (Block,KGBElt,KGBElt->int): index in block, from KGB, dual KGB components
  This is the inverse of the map defined by element@(Block,int): given a
  compatible pair of a KGB element x and a dual KGB element y, it returns the
  index in the block of the corresponding element. For efficiency reasons the
  function requires the containing block to be supplied as first argument; if
  needed, block(real_form(x),dual_real_form(real_form(y))) computes the block
dual: (Block->Block): dual block, with real form and dual real form swapped
status: (int,Block,int->int): status at a block element of a simple reflection
  For s the index of a reflection, and i the index of an element of block b,
  status(s,b,i) gives according to the codes 0:C-, 1:ic, 2:r1, 3:r2,  4:C+,
  5: rn, 6:i1, 7:i2. Note that the descents s have status(b,i,s)<4

operators =, != : (Split->bool): test split integer against Split:(0,0)
operators =, != : (Split,Split->bool): equality/inequality of split integers
operator + : (Split,Split->Split): addition of split integers
operator - : (Split,Split->Split): subtraction of split integers
operator - : (Split->Split): negation of a split integer
operator * : (Split,Split->Split): multiplication of split integers
operator % : (Split,int,int): decomposition of split integer into components

K_type: (KGBElt,vec->KType): form a K-type from the pair (x,lambda-rho)
operator % : (KType->KGBElt,vec): recover (x,lambda-rho) from a KType
  The component lambda-rho represents a coset for the image of the lattice X^*
  by 1-involution(x), for which a preferred representative is chosen whenever
  a KType is constructed; so this is no perfect inverse of the K_type function
real_form: (KType->RealForm): recover the real form from a KType value
height: (KType->int): height of a K-type
operators =, != : (KType,KType): strict equality of KTypes
  Equality of KTypes implies equality of their real forms
equivalent: (KType,KType->bool): test equivalence of K-types
  Equivalence of $K$-types is generated by _complex_ simple reflections acting
  on x and lambda, and this allows to move any $K$-type to the fiber over any
  chosen involution for its Cartan class; within one fiber equivalence is the
  same as equality (bearing in mind that for the lambda component that means
  congruence modulo the image lattice of 1-involution(x)). The K-types tested
  need not be standard, but they must be K-types for same real form.
is_standard: (KType->bool): whether K-type defines a standard K-representation
  This is true whenever lambda is dominant relative to the imaginary roots
is_dominant: (KType->bool): whether K-type is dominant for full positive system
  This is true whenever (1+theta_x)lambda is dominant (for all simple roots)
is_zero: (KType->bool): whether K-type defines a zero K-representation
  True whenever lambda is singular on a compact (for x) simply-imaginary root
is_semifinal: (KType->bool): whether K-type has no real descents
  When false, the standard $K$ representation is combination of others
  on more compact Cartans by a Hecht-Schmid identity. So is_semifinal(p) is
  true provided no real coroots satisfy the parity condition.
is_final: (KType->bool): whether K-type has no singular descents at all
  This means that is_standard(p), not is_zero(p) and is_semifinal(p) hold,
  and the K-type has no singular (for (1+theta_x)lambda) complex descents.
  KTypes that satisfy |is_final(p)| are precisely the ones that can occur as
  monomials in a |KTypePol| value.
dominant: (KType->KType): ensure K-type has dominant (1+theta_x)lambda
  This gives an equivalent form of the K-type in which infinitesimal character
  has been made dominant (it may not be unique for this property within its
  equivalence class); calling this function requires is_standard to hold for the
  K-type, and an error will be reported if it is not.
to_canonical_fiber: (KType->KType): move to elected fiber for its Cartan class
  In every Cartan class of involutions one is singled out, and every K-type for
  this Cartan class can be moved into the fiber over this involution in a unique
  way; this function returns the K-type in that fiber obtained in this way.
normal: (KType->KType): bring K-type to a unique form under equivalence
  This form can be computed for all K-types, and only depends on its
  equivalence class; moreover if the class contains a K-type that satisfies
  is_final, then it is unique and it will be produced by this function.
theta_stable: (KType->KType): ensure K-type is moved to a theta-stable situation
  The name theta-stable refers to the parabolic subalgebra associated to the
  involution theta of the x component of the K-type: the subalgebra whose Levi
  factor has the real roots and whose nilpotent radical has the remaining
  positive roots is theta-stable, maning that theta permutes those remaining
  positive roots among each other. In terms of the K-type it means there are no
  complex descents, which is obtained by greedily performing any complex
  descents; multiple candidate results may exist, among which one is chosen.

null_K_module: (RealForm->KTypePol): empty sum of $K$-types for the real form
real_form: (KTypePol->RealForm): recover the real form from a KTypePol value
operators =, != : (KTypePol->bool): efficient test for formal sum being zero
operators =, != : (KTypePol,KTypePol->bool): test difference for being zero
operator # : (KTypePol->int): number of nonzero terms of the formal sum
operator +, - : (KTypePol,KType->KTypePol): add/subtract parameter to formal sum
operator + : (KTypePol,(Split,KType)->KTypePol): add parameter with coefficient
operator + : (KTypePol,[(Split,KType)]->KTypePol): add terms to formal sum
operators +, - : (KTypePol,KTypePol->KTypePol): addition/subtraction formal sums
operator * : (int,KTypePol->KTypePol): integer multiple of a formal sum
operator * : (Split,KTypePol->KTypePol): split integer multiple of a formal sum
first_term: (KTypePol->Split,KType): lowest term (by height) of nonzero K-module
last_term: (KTypePol->Split,KType): highest term (by height) of nonzero K-module
truncate_above_height: (KTypePol,int->KTypePol): drop terms with height>limit

KGP_sum: (KType->[int,KType]) signed subset of KGB associated to theta_stable(t)
  It is required that the argument KType t be semifinal, and it will be moved to
  an equivalent theta-stable position before doing the main work. The terms in
  the sum are K-types obtained from theta_stable(t) by operating by (real root)
  generators of the Levi factor of the corresponding theta-stable parabolic
  subalgebra (the x component moves to more compact Cartans, the lambda
  component gets projected or reflected), while a sign for the length change of
  the x component is prefixed to the K-type. These K-types may be non standard
  (even if the argument was standard) which is why the result is not transformed
  into a KTypePol value, as their terms are always standard, and even final.
K_type_formula: (KType,int->KTypePol): formula for K-types as irreducibles
  Express irreducible K representation as linear combination of standard
  representations, limiting (for efficiency) the height of resulting terms to be
  at most the second argument, unless that argument is negative. This is like
  the function of the same name, and should give the result of the latter
  restricted to K, but the implementations are entirely separate.
branch: (KTypePol,int->KTypePol): convert standard to irreducible, up to height
  In the first argument K-types are interpreted as standard K-representations,
  each of which is decomposed into irreducible factors; those factors (with
  their multiplicities) form a multi-set, from which terms whose height
  exceeds the limit (given as second argument) are truncated, so as to give a
  finite result. A KType argument can be converted to KTypePol implicitly.

param: (KGBElt,vec,ratvec->Param): form parameter from (x,lambda-rho,nu)
  From nu only the projection (1-involution(x))nu/2 is used, the complementary
  part of the infinitesimal character is taken from (1+involution(x))lambda/2
operator % : (Param->KGBElt,vec,ratvec): recover (x,lambda-rho,gamma) from param
  Here x and lambda-rho are as for K-types, and gamma is the infinitesimal
  character. The function param applied to the the result of % will reconstruct
  an identical parameter (so this is a left inverse of that function), but %
  will not always reconstruct the arguments used to construct a Param value,
  both because lambda-rho can be another representative of the same coset, and
  because gamma as returned includes the projection (1+involution(x))lambda/2
  These components are not invariant under equivalence of parameters, and are
  transformed in specific ways when a function like 'dominant' is applied to
  the parameter (the latter indeed serves to ensure that gamma is dominant).
real_form: (Param->RealForm): recover the real form from a Param value
height: (Param->int) W-invariant height measure standardrepn restricted to K
  This is the sum of absolute values of the scalar products of (1+theta)lambda
  and the positive coroots; it ignores the nu component of the parameter.
  This is the same function as used in branch to compare with the given limit.
K_type: (Param->KType): restriction to K (ignoring the nu-component)
param: (KType->Param): parameter for this K-type and with nu=0
operators =, != : (Param,Param): strict equality of parameters in the same block
  Equality of parameters implies equality of their real forms
equivalent: (Param,Param->bool): test equivalence of parameters
  Equivalence of parameters is generated by _complex or real_ simple reflections
  acting on the x, lambda and nu components, where the real simple reflections
  are by affine hyperplanes passing through rho, and are not applicable if the
  the infinitesimal character is singular for the real root (so that nu would be
  unchanged by the action). Every parameter satisfying is_standard has at least
  one equivalent parameter with dominant infinitesimal character
  (representative), and among such parameters equivalence amounts to
  reachability using singular complex cross actions. Test for this equivalence,
  reverting to a strict equality test if either parameter fails to be standard.
  The condition equivalent(p,q) should be the same as normal(p)=normal(q).
is_standard: (Param->bool): whether parameter defines a standard module
  This is true whenever gamma is dominant relative to the imaginary roots
is_dominant: (Param->bool): whether parameter is dominant for full system
  This is true whenever (1+theta_x)gamma is dominant (for all simple roots)
is_zero: (Param->bool): whether parameter defines a zero standard module
  True whenever gamma is singular on a compact (for x) simply-imaginary root
is_semifinal: (Param->bool): whether parameter has no singular real descents
  False whenever associated standard representation is combination of others
  on more compact Cartans by a Hecht-Schmid identity. So is_semifinal(p) is
  true provided no real coroots for which gamma is singular satisfy the parity
  condition. Note: one could still have is_zero(p); this needs a separate test.
is_final: (Param->bool): whether p parametrizes an irreducible representation
  This means that is_standard(p) and not is_zero(p) and is_semifinal(p) holds,
  as well as p=dominant(p)=normal(p). Parameters that satisfy |is_final(p)|
  are the ones that can occur as monomials in a |ParamPol| value.
dominant: (Param->Param): ensure parameter has dominant infinitesimal character
  This gives an equivalent form of the parameter in which the infinitesimal
  character has been made dominant (it may not be unique for this property)
normal: (Param->Param): bring parameter to a canonical form under equivalence
  This form has dominant infinitesimal character and no singular complex
  descents; there may be more than one such form, of which a preferred one is
  chosen (terms in a ParamPol are always normalized, and moreover have
  is_final(p) and not is_zero(p); in this case the form described is unique).
cross: (int,Param->Param): cross action for (Weyl group generator,parameter)
  This first argument indexes (starting at 0) a simple root for the subsystem
  for the given parameter p: integrality_datum(infinitesimal_character(p))
Cayley: (int,Param->Param): Cayley transform for (Weyl generator,parameter)
  The Weyl generator is an index into the simple roots of the _integral_ system
  for the parameter. If a Cayley transform in either direction is defined for
  the generator and the parameter, it will be applied, choosing one of the
  values in case of a two-valued transform; the other value, if any, can be
  obtained by applying the cross action for the same generator to the result.
  If no Cayley transform is defined at all, the parameter is returned unchanged.
cross: (vec,Param->Param): cross action for (root,parameter)
Cayley: (vec,Param->Param): Cayley transform for (root,parameter)
  These two functions should do the same as the three before, but taking the
  root in coordinates, and combining the Cayley/inverse Cayley into one
  function (whichever is defined is applied, or else the parameter returned).
  The implementation is quite independent however, so comparison is useful.
twist: (Param->Param): twist the parameter by the distinguished involution
twist: (Param,mat->Param): twist the parameter by the given external involution
orientation_nr: (Param->int): the orientation number
reducibility_points: (Param->[rat]): the 0<t<=1 with I(x,lambda,t\nu) reducible
operator * : (Param,rat->Param): scale component nu by given rational factor

print_block: (Param->): print translation family block for the given parameter
  The full common block is printed with "gamma-lambda" rather than "lambda-rho"
print_partial_block: (Param->): print partial translation family block
block: (Param->[Param],int): return block as list of parameters, and index
  The second component is the index into the first of the original parameter.
  Non-final parameters are omitted from the list, and if this includes the
  original parameter the second component will be negative.
partial_block: (Param->[Param]): return partial block as list of parameters
  This is the Bruhat interval of the block below the given parameter, sorted by
  length. Non-final parameters are omitted. If the original parameter is final,
  then it will be the last element of the list returned.
length: (Param->int): the length of a parameter within its block
block_Hasse: (Param->mat): Hasse diagram of Bruhat order of block of parameter
  Calling KGB_Hasse(p) ensures the full block containing the parameter p is
  generated, and returns a matrix describing the Hasse diagram of its Bruhat
  order: the set of pairs (x,z) for which the interval { y | x<=y<=z } contains
  exactly the two elements, namely x et z. The matrix is indexed by the numbers
  of the block elements as displayed in print_block(p).
KL_block: (Param->[Param],int,mat,[vec]): block for parameter, with its KL table
  This combines block with the computation of the its Kazhdan-Lusztig table.
  The two values of block are followed by two values in the format of raw_KL
  below: a matrix of indices into the following list of polynomials, coded as a
  list of coefficient vectors. (Contrary to raw_KL below no data about the
  length of block elements is exported, as length@Param can compute that.)
  In case the infinitesimal character of the given parameter is singular, the
  data computed for its common block is reduced to the elements that are final
  at that infinitesimal character, taking appropriate linear combinations of
  polynomials computed for the block. Since these combinations can have negative
  coefficients, some of the polynomials in the table may have these as well.
dual_KL_block: (Param->[Param],int,mat,[vec]): KL_block values for dual block
  This corresponds to KL_block, but computes the KL polynomials for the formally
  dual block, where change of length is reversed, the type of the simple roots
  dualized (interchanging for instance imaginary compact and real nonparity, or
  imaginary type 1 and real type 2). The first two components of the result are
  the same as for KL_block. The final two values give the KL polynomials for the
  dual block in the same format as for KL_block (since the list of parameters
  has decreasing length for the dual block, the matrix is lower triangular
  rather than upper). In case of a singular infinitesimal character, the dual
  KL polynomials at final block elements are selected unmodified (no linear
  combination) since that is appropriate for the dual block; thus the transpose
  of the matrix gives the matrix of Q-polynomials, which after conjugation with
  the diagonal matrix of length-parity signs gives the inverse of the matrix of
  ordinary Kazhdan-Lusztig polynomials, the ones returned by KL_block
partial_KL_block: (Param->[Param],mat,[vec]): partial KL_block
  This function relates to KL_block as partial_block relates to block. The first
  component of the result is the Bruhat interval as in partial_block, and the
  last two components have the same meansing as in KL_block; no index of the
  given parameter is returned (if present, it is always the last listed element).
W_graph: (Param->int,[[int],[int,int]]): W-graph for parameter block
  Generate block and decompose into W-cells; return the number of the parameter
  in the block, and the W graph in the format used for W_graph@Block below
W_cells: (Param->int,[[int],[[int],[int,int]]]): W-cells for parameter block
  Generate block and decompose into W-cells; return the number of the parameter
  in the block, and the cell data in the format used for W_cells@Block below
extended_block: (Param,mat->[Param],mat,mat,mat): extended block with graph data
  The arguments are a parameter p and an external distinguished involution delta
  (which should commute with the inner class distinguished involution). The
  block of p is constructed as in block@Param, and the (possibly empty) list of
  its parameters fixed by the action of delta returned as first component. The
  remaining three components are matrices indexed by (in this order) an index
  into the list of parameters and an index in the delta-folded Dynkin diagram
  (an extended generator), and containing for the first matrix a code for the
  type of the parameter for the generator, and for the other two matrices the
  indices of the neighbors for this generator: two for Cayley transforms (either
  the double-valued transform, or the single-valued transform with in addition
  the cross action); one for a complex cross action; none for cases like a
  compact imaginary generator. Every parameter in the extended block has an
  implicit choice of extended parameter attached, with respect to which choices
  certain neighbor relations may involve a sign flip, which is indicated in the
  corresponding matrix entry (link value): if the extended block has size n,
  then link values from 0 to n-1 indicate a neighbor with no flip, negative
  values from -1 to -n indicate a sign flip (for the index corresponding by
  subtraction from -1), and the value n indicates absence of a link.

null_module: (RealForm->ParamPol): empty sum of parameters for the real form
real_form: (ParamPol->RealForm): recover the real form from a ParamPol value
operator # : (ParamPol->int): number of nonzero terms of the formal sum
operators =, != : (ParamPol->bool): test virtual module for being zero
operators =, != : (ParamPol,ParamPol->bool): test virtual modules for equality
operator +, - : (ParamPol,Param->ParamPol): add/subtract parameter to formal sum
operator + : (ParamPol,(Split,Param)->ParamPol): add parameter with coefficient
operator + : (ParamPol,[(Split,Param)]->ParamPol): add terms to formal sum
operators +, - : (ParamPol,ParamPol->ParamPol): addition/subtraction formal sums
operator * : (int,ParamPol->ParamPol): integer multiple of a formal sum
operator * : (Split,ParamPol->ParamPol): split integer multiple of a formal sum
first_term: (ParamPol->Split,Param): lowest term (by height) of nonzero module
last_term: (ParamPol->Split,Param): highest term (by height) of nonzero module
truncate_above_height: (ParamPol,int->ParamPol): drop terms with height>limit
operator * : (ParamPol,rat->ParamPol): scale nu in each term, and renormalize
  After scaling the continuous part of the parameter in each term, some may no
  longer be dominant or final, and need to be rewritten in the same way as
  parameters are when incorporated into a ParamPol; this is the renormalization

deform: (Param->ParamPol): compute deformation terms when nu decreases
  The non-integral block for the parameter and its KL polynomials are
  computed, from which the deformation terms involving other members of the
  block are computed. They are returned as a formal sum of parameters with
  split integer coefficients, which are in fact integer multiples of (1-s).
twisted_deform: (Param->ParamPol): inner class twisted deformation terms
  This is like deform, but uses the twisted KL polynomials (for the inner class
  involution) instead. The argument parameter must be fixed under that twist.
  It must also be fully prepared for deformation, that is, have dominant
  infinitesimal character and be final; this is because interpretation of the
  result depends (by a sign) on the chosen default extension for the parameter,
  and preparations may cause a flip in that choice. If needed use scale_extended
  and finalize_extended to do these preparations while keeping track of flips.
block_deform: (Param,ParamPol,int->ParamPol,ParamPol): deform whole block
  Here the Param argument just serves to define its block, the ParamPol argument
  associates (Split) coefficients to the final elements of this block (and to
  other final parameters as well, but these terms will remain passive), and the
  int argument gives a height bound above which contributions will be ignored
  (which may speed up computation; a negative bound means nothing is ignored).
  The terms in the block are extracted, and |deform| is applied to each of them,
  from the top of the block downwards; once done the deformed parameter is
  marked as such and its coefficient will not change any more. The deformation
  terms from this parameter (which are of course multiplied by the coefficient
  of the term it came from) are added to the ones remaining to be processed
  (they are lower in the block). Once all terms are deformed, the
  post-deformation terms are added to form the first ParamPol of the output
  (these should be moved down to the next reducibility point towards nu=0 when
  full deformation is to be done), while the terms of the ParamPol argument that
  were not extracted for deformation are returned as the second argument.

full_deform: (Param->KTypePol): perform deformation all the way to nu=0
  This is like deform, but recursively deforms all new terms produced as long
  as they do not have nu=0. Having nu=0, the terms of the result can be and are
  represented as |KType|; they are made final, and gathered into a |KTypePol|.
twisted_full_deform: (Param->KTypePol): inner class twisted deformation to nu=0
  This is like full_deform, but uses the twisted KL polynomials (for the inner
  class involution) instead. The argument must be fixed under that twist.
  It must also be fully prepared for deformation, that is, have dominant
  infinitesimal character and be final; this is because interpretation of the
  result depends (by a sign) on the chosen default extension for the parameter,
  and preparations may cause a flip in that choice. If needed use scale_extended
  and finalize_extended to do these preparations while keeping track of flips.

KL_column: (Param->[int,Param,vec]): column of Kazhdan-Lusztig table
  Returns a list of nonzero Kazhdan-Lusztig polynomials P(x,y) with the given
  parameter as y, each as a triple (n,x,P(x,y)) where x is the parameter for
  the first index of the polynomial, P(x,y) the polynomial itself as a vector of
  coefficients (by increasing degree), and n is the number in its block of x.
KL_sum_at_s: (Param->ParamPol): signed sum of KL polynomials at s, fixed y
  Computes \sum_{x\leq y}(-1)^{l(y)-l(x)}P_{x,y}[q:=s].x where y is the block
  element of the parameter, and the sum is over other block elements x.
twisted_KL_sum_at_s: (Param->ParamPol): KL_sum_at_s, twisted KLV polynomials
  This does the same sum as KL_sum_at_s, but using twisted KLV polynomials
  (the twist is for the distinguished involution) instead of ordinary KLV
  polynomials. The actual value depends on sign choices for Hecke module
  generators (extended parameters) for each of the terms; these choices, which
  cannot be made explicit in terms of ordinary parameters only, affect the signs
  of the coefficients of these terms. However a consistent choice of a default
  extension is made internally for each parameter value, which make those signs
  well-defined. When modifications are made to parameters, like changing to an
  equivalent one with different infinitesimal character representative, or
  scaling their nu component, the change may "flip" the default extension in the
  sense that the corresponding change at the level of an extended parameter
  applied to an initial default extension may result in an extended parameter
  with opposite sign choice with respect to the default for the modified
  (ordinary) parameter; special functions are provided below to track such flips
twisted_KL_sum_at_s: (Param,mat->ParamPol): sum of delta-twisted KLV polynomials
  This version takes an explicit external involution matrix delta as second
  argument. The parameter should be delta-fixed. Unlike the previous two, this
  function does not tabulate results or look up previously computed ones.

scale_extended: (Param,mat,rat->Param,bool) scale nu, recording extended flips
  When interpreting parameters as representing a representation of the
  delta-extended group (where delta is the second argument, a distinguished
  involution commuting with the one defining the inner class), certain
  changes to parameters may flip the default choice of extended representation;
  this function takes care to record such a flip for the operation of scaling
  the continuous component nu by a rational factor. With arguments (p,delta,f)
  it is assumed that the parameter p is_final, and the factor f is positive.
  A new parameter is formed by scaling the component nu(p) by f, and it is made
  final, as in ParamPol:p*f; under the given assumptions this involves applying
  only complex reflections, so the result is a single parameter which is the
  first component of the result. The second component records whether this
  transformation at the level of extended parameter involves a flip with respect
  to the default extension, as described above under "twisted_KL_sum_at_s"
K_type_pol_extended: (Param,mat->K_type_pol): extended restrict to K
  The argument parameter must satisfy is_standard and be fixed under delta,
  the second argument (a distinguished involution commuting with the one
  defining the inner class). Like in scale_extended it is scaled and the
  result is then made final, taking into account flips with respect to the
  default extension; here the factor by which the nu component is scaled is
  zero, so that a K-type is obtained; this being the case the finalization
  process does not necessarily result in a single $K$-type, whence the result is
  represented as a KTypePol. Any flip associated to a $K$-type produced is
  recorded as a factor of (split integer unit) s in its coefficient.
finalize_extended: (Param,mat->ParamPol): conversion for extended parameters
  Like scale_extended, this function is about tracking flips in the default
  choice of extended representation, this time for the operation of expanding a
  parameter in terms of "final" parameters as happens when they enter into a
  ParamPol (their infinitesimal character is dominant and they have no singular
  descent simple reflections). When interpreting parameters as specifying a
  delta-extended representation using a per-parameter specific default choice of
  extension, the finalization process on extended parameters may involve flips
  with respect to the default choices for the terms of the finalization as an
  ordinary parameter; such flips are recorded as a factor of (split integer
  unit) s in the coefficient if the parameter in question.

raw_KL: (Block->mat,[vec],vec): Kazhdan-Lusztig data for block, raw form
  The call raw_KL(b) produces a matrix of numbers identifying polynomials, a
  list of those polynomials in the form of coefficient vectors, and a sequence
  'stops' of length boundaries that allow deducing the "lengths" of the integers
  used to index the matrix. The matrix is indexed by integers identifying block
  elements for the block, and the matrix entries are indices into the list of
  polynomials; in the final vector stops[l] is the first block element of length
  (at least) l. So if (M,L,len)=raw_KL(b), and v,w are integers identifying
  block elements, then the vector L[M[v,w]] gives the coefficients of the KL
  polynomial P_{v,w}. The length of (the block element number) v is the largest
  index l such that stops[l]<=v, and therefore one can find the length
  difference between v and w as the number of indices l with v<stops[l]<=w.

dual_KL: (Block->mat,[vec],vec): dual KL polynomials (Q_{x,y}) for block
  This is like raw_KL, but computes the polynomials Q instead of P. The
  indexing of the block is the same as for the polynomials P, so up to length
  signs, the matrix should be the inverse of the P matrix. The length stops
  are provided as final value, as in raw_KL; these are for the _same_ block.

raw_ext_KL: (Param,mat->mat,[vec],vec): extended Kazhdan-Lusztig data
  This function takes input similar to extended_block, namely a parameter and
  the matrix of a distinguished involution, which should commute with the
  distinguished involution defining the inner class, and produces raw output
  describing the extended Kazhdan-Lusztig polynomials associated to the block
  for the extended group, in a format similar to that used in raw_KL. So the
  matrix is indexed by block elements and its entries describe polynomials by an
  identification number, used as index into a list of polynomials that is the
  second component returned. In contrast to raw_KL, negative entries may occur
  in the matrix, which means that the polynomial found at its absolute value
  should by multiplied by -1 (the polynomial at index 0 is always the zero
  polynomial, so there is no need to negate it). The third component specifies
  at position l the block element for which the length function (which is
  monotonically increasing along the block), takes a value at least l for the
  first time.

W_graph: (Block->[[int],[int,int]]): data describing unoriented W-graph for block
  The data consists of a list with for each element x of the block a pair,
  consisting of its \tau-invariant (as list of 0-based simple root indices),
  and a list of outgoing edges, each one as a pair of a destination vertex y
  and the integer \mu(x,y)=\mu(y,x) that labels to this edge in the W-graph.
  This graph may be turned into an oriented graph by removing any edge from x
  to y where the tau-invariant of x is contained in the tau invariant of y; it
  is that oriented graph in terms of which W_cells are defined as equivalence
  classes for the relation of being linked by oriented paths in both directions.
W_cells: (Block->[[int],[[int],[int,int]]])): data describing W-cells for block
  This decomposes the W-graph into cells, and returns data describing each of
  those cells. It consists of a list with, for each cell, a pair consisting of
  a list of numbers identifying the elements of this cell by the numbers of
  the block elements they correspond to, and the restriction to this cell of the
  oriented graph obtained from the W-graph described there, in the same format
  (in the restriction vertices are renumbered form 0, so that it can be
  considered as a W-graph in its own right, without reference to the original).

walls: (RootDatum,ratvec->[int],int) Set of coroots defining walls of alcove
  The alcove is the one containing the given rational weight gamma, possibly on
  its boundary, and such that the half-line from gamma in any strictly dominant
  direction enters into the interior of the alcove (where all coroot evaluations
  are non integral). This latter condition makes the alcove unique, and means
  that among coroots with integral evaluation at gamma, only positive coroots
  are candidate to define a wall; indeed, an initial part of the list of coroot
  numbers returned as first component, of size given by the second component
  (the integrality rank), gives a simple basis for the integral system of gamma.
  The full list of root numbers index coroots whose evaluations non redundantly
  define the alcove, the integral part of these evaluations being the same as
  for gamma (using the integral part means the "sign" of the coroots is chosen
  such that they point into the alcove: their evaluation is integral on some
  face of the alcove, and increases towards the interior of the alcove). Within
  the initial set of integral coroot numbers, and within the remaining numbers,
  coroots are sorted by decreasing "label" with respect to alcove (which is an
  integer k such that within the alcove, the maximal fractional part of the
  evaluation is 1/k). This is a useful property for generating, modulo
  translations, the affine Weyl group orbit of the facet containing gamma
  ('affine_orbit_ws'), and ensures that in at leat one of the two sorted
  sublists the final element determines a coroot with label equal to 1.
walls_attitude: (RootDatum,[int]->WeylElt) classify alcove up to translation
  For any alcove there are alcoves in the W-orbit of the fundamental alcove that
  are equal to it up to a translation; this function determines a Weyl group
  element that witnesses this from the set of walls of the alcove, represented
  by a list of root indices as retuned by the 'walls' for an interior point of
  the alcove. The set of root indices must be that of the walls of some alcove,
  so in the W-orbit of the set of walls of the fundamental alcove (necessary
  conditions for this is the absence of acute angles, and a number of walls
  equal to the sum of the semisimple rank and the number of connected components
  of the Dynkin diagram). The list will contain both positive and negative
  roots, and the distinction between a root and its opposite is vital here. In
  general the Weyl group element is not unique; it would be unique if we were to
  limit translations by weights in the root lattice, but information for that
  classification of alcoves requires more information than just its wall set.
alcove_center: (Param->Param): Change gamma to a "central" point of its alcove
  The alcove is defined by the integral parts of the evaluations of gamma on
  all the positive coroots, as in the walls function. The "central" point is
  obtained by remaining on any (positive coroot) wall that gamma is already on,
  and for the remaining walls spread out the fractional parts of the coroot
  evaluations evenly, in the fashion of an isobarycenter. This adaptation
  should ensure the change is fixed under -p.x.involution in all cases.
alcove_root_vertex: (RootDatum,ratvec->vec) Nearby root lattice element
  For given rational weight gamma there is a unique vector v in the root lattice
  such that no coroot evaluation at v-gamma is more than 1 in absolute value, and
  if exactly 1 then +1 iff the coroot is positive. This v is the unique vertex
  in the root lattice of the alcove of 'walls'. This function returns that v.

basic_orbit_ws: (RootDatum,[int],int->[WeylElt]): subquotient of (pseudo-)Levis
affine_orbit_ws: (RootDatum,ratvec->[WeylElt]): W image of affine quotient
  Technical functions for generating modulo translation affine orbits of facets.
  The entries in the second argument of basic_orbit_ws are root numbers that
  interpreted as coroot numbers define the shape of some alcove (the condition
  actually required is that no pair of them has an acute angle), and the last
  argument gives the codimension of a facet: the number of initial coroots on
  the list that take an integral value on the facet (these two arguments could
  be taken from the value returned by a call of 'walls' above, and indeed in
  affine_orbit_ws the values returned from 'walls' for the given rational weight
  are used in their place). The sequence of root numbers describes an increasing
  chain of root systems, from the integral system to the full root system, the
  steps of which determine subquotients (sets of representatives of left cosets
  by a smaller in a larger subgroup) by pseudo-Levi subgroups of the Weyl group.
  In basic_orbit_ws the first such subquotient is computed (the other ones can
  be found by repeating the call with increasing final argument), while in
  affine_orbit_ws the full list of subquotients is computed and combined into a
  set of representatives of W/W_I, the quotient by the integral Weyl group. The
  latter produces, when applied to the original rational weight, its orbit under
  the affine Weyl group modulo its normal subgroup acting as root translations.
FPP_numers: (RootDatum,ratvec->[vec]): Affine Weyl orbit intersected with FPP
  The fundamental parallelepiped (FPP) is the part of the dominant cone where
  all simple coroots take values in the interval [0,1]. The hyperplanes where
  coroots take integral values chop up the FPP (and the whole space) into
  alcoves, each of which is the image by a unique affine Weyl group element of
  the fundamental alcove (the one in the FPP that has the origin as vertex), but
  facets can be shared between alcoves. Given a rational weight gamma in some
  facet of the fundamental alcove, this function finds all its distinct images
  under the affine Weyl group lying inside the FPP, and lists their numerators;
  this is to save space as the denominators are all equal to that of gamma.
FPP_w_shifts: (RootDatum,ratvec->[WeylElt,[vec]]): Affine Weyl elements for FPP
  This function has the same funcionality as FPP_numers, but presents the
  results differently, namely as a list of affine Weyl group elements (an
  ordinary Weyl group element followed by a shift in the root lattice), grouped
  by common Weyl group elements, each followed by a list of associated shifts.
  The Weyl group elements w are such that w*gamma is integrality dominant.

strong_components: ([[int]]->[[int]],[[int]]): Tarjan's graph algorithm
  The input describes a directed graph on the set #n={0,1,...,n-1}, where n is
  the length of the list. The graph defines by (reflexive and) transitive
  closure a pre-order on the set #n of vertices (an edge y->x meaning that x<y
  in the pre-order). This pre-order defines an equivalence relation (valid
  between x and y if both x<=y and y<=x hold) and an induced directed acyclic
  graph (and a partial order) on the quotient set for this equivalence relation
  (every edge of the original graph between elements of distinct equivalence
  classes giving an edge of the induced graph between those classes). This
  function computes these, returning the equivalence class and the induced
  graph. The graph is encoded by a list of lists, indexed by its vertices, where
  the list for vertex i describes the end points of all outgoing edges from i.
  The equivalence relation is given as a list of non empty lists, each
  describing the vertices of one equivalence classes, and the induced graph is
  given in the same format as the input graph (but on a smaller set of numbers).

partial_extended_KL_block: (Param,mat->[Param],mat,[vec]): extended KL data
  This function computes twisted KLV polynomials for part of a block, similarly
  to partial_KL_block, but including length-parity signs (so these are signed
  P-polynomials). The arguments (p,delta) are a parameter and a distinguished
  involution as for raw_ext_KL. The list of parameters returned are the final
  delta-fixed parameters of the block, which therefore give elements of the
  extended block without singular descents among the simple generators of the
  extended block. The list is also truncated by removing any elements that are
  beyond p from it, so if present, p is the last element on the list. The matrix
  of KL polynomials is condensed to a square matrix indexed by just the listed
  elements, as in partial_KL_block. Moreover, since the deformation algorithm
  can work with just the evaluations of the P polynomials at q=-1, these
  evaluations are computed (so that the result can be returned as a plain
  matrix, the second component) and the resulting number is negated for those
  entries for which the length difference for the block elements for its row and
  column is odd (here length is as length@Param, there is no separate length in
  extended blocks). The form of the result is meant to be directly usable in the
  deformation algorithm.

print_gradings: (CartanClass,RealForm->): print gradings defined by real form
  This more or less gives the output of the 'gradings' command in Fokko, for the
  selected real form. The type of the imaginary root system is printed, with the
  numbers of the roots that span this root subsystem as simple roots, in the
  Bourbaki ordering for its type. Then for each element in the list produced by
  fiber_part for the same arguments, the grading of the imaginary root system is
  given as a sequence of bits 0 (compact) or 1 (non-compact), to be interpreted
  on the simple roots in the given order, and extended to the whole imaginary
  root subsystem as a Z/2Z grading.

print_real_Weyl: (RealForm,CartanClass->)
print_strong_real: (CartanClass->)

print_block: (Block->):
print_blocku: (Block->):
print_blockd: (Block->):
print_blockstabilizer: (Block,CartanClass->):
print_KGB: (RealForm->):
print_KGB: (RealForm,[KGBElt]->): print only for the listed KGB elements
print_KGB_order: (RealForm->):
print_KGB_graph: (RealForm->):
print_X: (InnerClass->):
print_KL_basis: (Block->):
print_prim_KL: (Block->):
print_KL_list: (Block->):
print_W_cells: (Block->):
print_W_graph: (Block->):
  These commands give the output of the corresponding commands, present under
  that name in Fokko, for printing the information the name suggests
