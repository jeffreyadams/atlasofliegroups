<basic.at
<character_tables.at
<classical_W_classes_and_reps.at { for type abbreviation |BC_class|, |cycles| }
<character_table_C.at

{     type B     }

set conjugacy_class_SO(BC_class cycles) = WeylElt:
   let n=cycles.rank
   in W_elt(SO(n+n+1),class_word_BC(cycles.to_partition_pair))

{ for general type B root data, we need to look up and use the diagram order }
set conjugacy_class_B(RootDatum rd) = (BC_class->WeylElt):
   let map = test_simple_type("B",rd) then n=#map in
   (BC_class cycles) WeylElt:
(  let size = rank(cycles)
in assert(size=n,"Cycles sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word_BC(cycles.to_partition_pair) do map[s] od)
)

set class_table_B(int n) = WeylClassTable:
   let rd=SO(n+n+1), classes = [BC_class]: BC_classes(n)
in W_class_table( rd, for cycles in classes do conjugacy_class_SO(cycles) od
		, (WeylElt w)int:
		    cycle_class_size(cycle_code(w).as_signed_cycles)
		, (WeylElt w0) (WeylElt->bool): let code=cycle_code(w0) in
		    (WeylElt w)bool: cycle_code(w)=code
		)

set class_table_B(RootDatum rd) = WeylClassTable:
  let classes = [BC_class]: BC_classes(rd.semisimple_rank)
  , type_code(WeylElt w) = [int]: signed_cycle_type_code(classic_permutation(w))
  , class_rep = (BC_class->WeylElt): conjugacy_class_B(rd)
  in W_class_table( rd, for cycles in classes do class_rep(cycles) od
		  , (WeylElt w)int:
		      cycle_class_size(type_code(w).as_signed_cycles)
		  , (WeylElt w0) (WeylElt->bool): let code=type_code(w0) in
		      (WeylElt w)bool: type_code(w)=code
		  )

set character_table_B(int n) = CharacterTable:
   let class_list =  BC_classes(n)
   then classes = [WeylElt,classical_class,string]:
      for cycles in class_list
      do (conjugacy_class_SO(cycles), cycles.class_BC,cycles.cycles_string)
      od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in BC_irreps(n)
      do ( rep.irrep_BC, rep.irrep_string
         , for cycles in class_list do hyperoctahedral_character(rep,cycles) od
	 )
      od
   in character_table(class_table_B(n),classes,irreps)

set character_table_(RootDatum rd) = CharacterTable:
   let n=rd.semisimple_rank
   , class_rep = (BC_class->WeylElt): conjugacy_class_B(rd)
   then class_list =  BC_classes(n)
   then classes = [WeylElt,classical_class,string]:
      for cycles in class_list
      do (class_rep(cycles), cycles.class_BC,cycles.cycles_string)
      od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in BC_irreps(n)
      do ( rep.irrep_BC, rep.irrep_string
         , for cycles in class_list do hyperoctahedral_character(rep,cycles) od
	 )
      od
   in character_table(class_table_B(rd),classes,irreps)
