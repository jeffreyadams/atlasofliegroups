
{ KL stuff, including character formulas and composition series
  This implementation seeks to avoid using KL_block, and instead uses
  KL_sum_at_s, as this function stores earlier results
  Also (compared to old implementation) no regular/singular case distinction
}

<basic.at
<count.at {for char_counter}
{<time.at {for print_time_string}}
{
  Basic object: column of KL matrix (P-matrix), of polynomials evaluated as s,
  which by setting s=1 gives formula for irreducible as sum of standards

  main functions:

  character_formula(p): irreducible(p) as sum of standards
  composition_series(p): standard(p) as sum of irreducibles

  signed_KL_mat_at_1(p): signed P-matrix evaluated at 1 (integral matrix)
  KL_inverse_mat_at_1(p): Q-matrix evaluated at 1 (integral matrix)

  also
    print_character_formula,print_composition_series
}

{ ------------------------------------------------------------------- }

{set CF_flag = false}
set charTime = int:0

set character_formula (Param p) = ParamPol:
    let start = elapsed_ms()
    then answer = s_to_1(KL_sum_at_s(p))
    then () = charTime+:= elapsed_ms() - start
    then () = char_counter.use()
    {then () = if CF_flag then prints("CF(",p.x.number,",",p.lambda,",",
       p.nu,"), charTime = ",print_time_string(CharFormTime)) fi}
    in answer

{set character_formula (Param p) = ParamPol: s_to_1(KL_sum_at_s(p))}

set character_formula (ParamPol P) = ParamPol: map(character_formula@Param,P)

{for predicting whether to_ht or is_unitary is faster}
set low(Param p) = (int,int,int):
    let ic = p.inner_class, theta = p.x.involution, gamma = p.infinitesimal_character
    then LAM = (dominant(ic,(1+theta)*gamma)*ic.two_rho_check)\2 {this is
    height(p); size of lambda}
    then NU = (dominant(ic, (1-theta)*gamma) *ic.two_rho_check)\2 {size of nu}
    then R = (ic.two_rho * ic.two_rho_check)\2 {this is max height at rho}
    then () = if R.= then R:=1 fi
    in (LAM,NU,R)

{ trunc_factor is how much to DISLIKE trunctating character
    formula; increase to truncate LESS often}
set trunc_factor = rat: 2/1

set character_formula_to_height(Param p, int N) = ParamPol:
    let (,NU,) = low(p), ic = p.inner_class, start = elapsed_ms()
    {we're going to height N}
    {so should compare NU to N}
    then answer = if NU > trunc_factor*N 
       	     	  then s_to_1(KL_sum_at_s_to_height(p,N))
       		  else let (below,) = height_split(KL_sum_at_s(p),N)
       	    	       in s_to_1(below)
       		  fi
     then () = charTime+:= elapsed_ms() - start
     then () = char_counter.use()
     {then () = if CF_flag then prints("CFTH((",p.x.number,",",p.lambda,",",
       p.nu,"),",N,"), CTime = ",print_time_string(CharFormTime)) fi}
     in answer

set character_formula_to_height (ParamPol P, int N) = ParamPol:
    map(((Param->ParamPol): (Param p): character_formula_to_height(p, N)), P)
{ ------------------------------------------------------------------- }

{ composition series }

set composition_series(ParamPol P) = ParamPol:
  null_module(P)+
  while !=P { non null module }
  do let (coef,p):term=first_term(P) in P -:= coef*character_formula(p); term
  od

set composition_series (Param p) = ParamPol: composition_series(ParamPol: p)

set tabulate_at_1 ([Param] block, (Param->ParamPol) f) = mat:
  for y in block { y determines a column of the result }
  do let fy=f(y) in for x in block do fy[x].s_to_1 od
  od

set signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(partial_block(p), character_formula@Param)

set KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(partial_block(p), composition_series@Param)

{ versions that do the whole block rather than a partial block }
set full_signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),character_formula@Param)
set full_KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),composition_series@Param)


set print_formatted (ParamPol P) = void:
  for w@p in P do prints(split_factor_format(w),"*",p) od

set print_character_formula (Param p) = void:
  print_formatted(character_formula(p))

set print_composition_series(Param p) = void:
  print_formatted(composition_series(p))

set print_with_length (ParamPol P) = void:
  for c@p in P do prints(c.split_factor_format, "*"  , p, " ", p.length) od

{ print out high length terms as they become available }
set composition_series_verbose (ParamPol P) = ParamPol:
   let result=null_module(P), max=max(for p in monomials(P) do length(p) od)
in for L:max+1 ~ { reverse }
   do prints("Length: ", L)
   ;  let result_new=null_module(P)
   in for c@p in P
      do if length(p)=L then result_new +:=c*composition_series(p) fi
      od
   ;  result := result+result_new
   ;  prints("terms in result of length ", L, ":")
   ;  for c@p in result
      do if length(p)=L
         then prints(c.split_factor_format, "*",p, " ", p.length)
	 fi
      od
   od ; prints("result:"); print_with_length(result); result

{ simpler and faster: trace progress while computing |composition_series| }
set composition_series_trace (ParamPol P) = ParamPol:
  null_module(P)+
  while !=P { non null module }
  do let (coef,p):term=first_term(P)
  in P -:= coef*character_formula(p)
  ; prints(coef.int_part,"*",p," [",height(p),"]") { coefficients are integer }
  ; term
  od
