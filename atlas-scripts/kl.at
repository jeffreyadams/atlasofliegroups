<basic.at { for |s_to_1| and many others }
<count.at { for |char_counter| }
<parameters.at { for |dual_inner_class| }

{ KL stuff, including character formulas and composition series
  This implementation seeks to avoid using KL_block, and instead uses
  KL_sum_at_s, as this function stores earlier results
  Also (compared to old implementation) no regular/singular case distinction
}

{<time.at {for print_time_string}}
{
  Basic object: column of KL matrix (P-matrix), of polynomials evaluated as s,
  which by setting s=1 gives formula for irreducible as sum of standards

  main functions:

  character_formula(p): irreducible(p) as sum of standards
  composition_series(p): standard(p) as sum of irreducibles

  signed_KL_mat_at_1(p): signed P-matrix evaluated at 1 (integral matrix)
  KL_inverse_mat_at_1(p): Q-matrix evaluated at 1 (integral matrix)

  also
    print_character_formula,print_composition_series
}

{ ------------------------------------------------------------------- }

{set CF_flag = false}
set charTime = int:0

set character_formula (Param p) = ParamPol:
    let start = elapsed_ms()
    then answer = s_to_1(KL_sum_at_s(p))
    then () = charTime+:= elapsed_ms() - start
    then () = char_counter.use()
    {then () = if CF_flag then prints("CF(",p.x.number,",",p.lambda,",",
       p.nu,"), charTime = ",print_time_string(CharFormTime)) fi}
    in answer

{set character_formula (Param p) = ParamPol: s_to_1(KL_sum_at_s(p))}

set character_formula (ParamPol P) = ParamPol: map(character_formula@Param,P)

{for predicting whether to_ht or is_unitary is faster}
set low(Param p) = (int,int,int):
    let ic = p.inner_class, theta = p.x.involution, gamma = p.infinitesimal_character
    then LAM = (dominant(ic,(1+theta)*gamma)*ic.two_rho_check)\2 {this is
    height(p); size of lambda}
    then NU = (dominant(ic, (1-theta)*gamma) *ic.two_rho_check)\2 {size of nu}
    then GAM = (p.infinitesimal_character* ic.two_rho_check)\1 {this is max height at infl char}
    	 {is_unitary_to_ht(p,GAM) means unitary}
    in (LAM,NU,GAM)

{If NU (nu part) > LAM (lambda part) *nu_frac, then figure to_ht could work better}
set nu_frac = 1/1

{if target height < GAMMA*gamma_frac, then figure to_ht could be faster. So largest
reasonable target height is GAMMA*gamma_frac. INCREASE to use to_ht
more often}
{In E7_s, gamma_frac = 1/3 and test25 = params of infl char rho so low(p, ht(p)+25)
let to character_formula MUCH faster than character_formulas_to_ht: 178 secs vs 978 secs}
set gamma_frac = 1/4

{if target height < (GAM - LAM)*diff_frac, then figure
is_unitary_to_ht could be faster. So largest reasonable target height
is (GAM-LAM)*diff_frac. INCREASE to use to_ht more often}
set diff_frac = rat: 3/4

{if target height < (GAM - LAM)*diff_frac, then figure
is_unitary_to_ht could be faster. So largest reasonable target height
is (GAM-LAM)*diff_frac. INCREASE to use to_ht more often}
set diff_char_frac = rat: 1/10 {1/8 and 1/12 used a bit more memory and time in
    		     	       spherical E7_s}

{ strict_factor is how much to DISLIKE trunctating character
    formula; increase to truncate LESS often}
set strict_factor = rat: 2/1

{strict versions mean harder be false: they are used to prevent the
code from EVER using to_ht, they should be false RARELY. Otherwise the
caller of is_unitary_to_ht can make a local decision about whether to
use it.}


{whether to use to_height in computing to height N}
{true means large nu, so to_ht could be better}
set low_nu(Param p, int N) = bool:
    let (,NU,) = low(p)
    in NU > N*nu_frac

set strict_low_nu(Param p, int N) = bool:
    let (,NU,) = low(p)
    in strict_factor*NU > N*nu_frac

{true means GAM big compared to HT, so is_unitary could be better}
{If N>= GAM, then to_ht gives answer to unitarity.}
set low_gamma(Param p, int N) = bool:
    let (,,GAM) = low(p)
    in GAM*gamma_frac > N

set strict_low_gamma(Param p, int N) = bool:
    let (,,GAM) = low(p)
    in strict_factor*GAM*gamma_frac > N

set low_diff(Param p, int N) = bool:
    let (LAM, , GAM) = low(p)
    in (GAM - LAM)*diff_frac > N

set strict_low_diff(Param p, int N) = bool:
    let (LAM, , GAM) = low(p)
    in strict_factor*(GAM - LAM)*diff_frac > N

set low_diff_char(Param p, int N) = bool:
    let (LAM, , GAM) = low(p)
    in (GAM - LAM)*diff_char_frac > N

set prefer_gamma_flag = true

set prefer_diff_flag = false

{set low_test_flag = false

set low_test(Param p, int N) = bool:
    let q = all_parameters_gamma(p.real_form, p.infinitesimal_character)~[0]
    in height(q) - height(p) > N
}
{whether to turn off to_ht completely at difficult p}
set strict_low_flag = true

set strict_low(Param p, int N) = bool:
    if not strict_low_flag
    then return true
    fi;
    if prefer_gamma_flag
    then strict_low_gamma(p,N)
    elif prefer_diff_flag
    then strict_low_diff(p,N)
    else strict_low_nu(p,N)
    fi

set low(Param p, int N) = bool:
    if prefer_gamma_flag
    then low_gamma(p,N)
    elif prefer_diff_flag
    then low_diff(p,N)
    else low_nu(p,N)
    fi

set character_formula_to_height(Param p, int HT) = ParamPol:
    if HT.< then return s_to_1(KL_sum_at_s(p)) fi;
    let start = elapsed_ms()
    then answer = if low_diff_char(p,HT)
    	 	  then s_to_1(KL_sum_at_s_to_height(p,HT))
		  else let (below,) = height_split(KL_sum_at_s(p),HT)
       	    	       in s_to_1(below)
       		  fi
     then () = charTime+:= elapsed_ms() - start
     then () = char_counter.use()
     {then () = if CF_flag then prints("CFTH((",p.x.number,",",p.lambda,",",
       p.nu,"),",N,"), CTime = ",print_time_string(CharFormTime)) fi}
     in answer

set character_formula_to_height (ParamPol P, int HT) = ParamPol:
    map(((Param->ParamPol): (Param p): character_formula_to_height(p, HT)), P)
{ ------------------------------------------------------------------- }

{ composition series }

set composition_series(ParamPol P) = ParamPol:
  null_module(P)+
  while !=P { non null module }
  do let (coef,p):term=first_term(P) in P -:= coef*character_formula(p); term
  od

set composition_series (Param p) = ParamPol: composition_series(ParamPol: p)

set composition_series_to_ht(ParamPol P, int HT) = ParamPol:
  if HT.< then return composition_series(P) fi;
  let (PHT,) = height_split(P,HT)
  in null_module(P)+
  while !=PHT { non null module }
  do let (coef,p):term=first_term(PHT)
     in PHT -:= coef*character_formula_to_height(p,HT)
     ; term
  od

set composition_series_to_ht (Param p,int H) = ParamPol: composition_series_to_ht(ParamPol: p, H)

{---------------------------}
{same using dual}

set pos_part(Split s) = int:
    let (a,b) = %s in abs(a+b)

set endo_ic(Param p) = inner_class(integrality_datum(p),p.x.involution)

{one root from each non-real, non-imag pos pair (alpha, theta*alpha)}
{well-defined up to (1-theta)alpha}
set rho_C(RootDatum rd, mat theta) = vec:
    let zero = null(rd.rank)
    in sum(rd.rank, for alpha@j in rd.posroots
    		    do let k = root_index(rd,theta*alpha)
		        in if k > j {k=j is imag; k = -j-1 is real}
		       	   then alpha
		       	   else zero
			   fi
		    od)

{one root from each non-real, non-imag pos pair (alpha, -theta*alpha)}
{well-defined up to (1+theta)alpha}
set rho_minus_C(RootDatum rd, mat theta) = vec:
    let zero = null(rd.rank)
    in sum(rd.rank, for alpha@j in rd.posroots
    		    do let k = root_index(rd,theta*alpha)
		        in if -k-1 > j {k=j is imag; k = -j-1 is real}
		       	   then alpha
		       	   else zero
			   fi
		    od)

set rho_check_C(RootDatum rd, mat theta) = vec:
    let zero = null(rd.rank)
    in sum(rd.rank, for alpha@j in rd.posroots
    		    do let k = root_index(rd,theta*alpha)
		        in if k > j {k=j is imag; k = -j-1 is real}
		       	   then rd.poscoroots[j]
		       	   else zero
			   fi
		    od)

set rho_check_minus_C(RootDatum rd, mat theta) = vec:
    let zero = null(rd.rank)
    in sum(rd.rank, for alpha@j in rd.posroots
    		    do let k = root_index(rd,theta*alpha)
		        in if -k-1 > j {k=j is imag; k = -j-1 is real}
		       	   then rd.poscoroots[j]
		       	   else zero
			   fi
		    od)

set endo(Param p) = Param:
    let endoic = endo_ic(p), x = p.x, rd = p.root_datum
    then theta = x.involution
    then rho_shift =  rd.rho  - endoic.rho
    then lambda_shift =  rho_i(x)  - rho_i(endoic,theta) + rho_C(rd,theta) - rho_C(endoic,theta)
    then nu_shift = p.x.rho_r  - rho_r(endoic,theta) + rho_minus_C(rd,theta) - rho_minus_C(endoic,theta)
    then corho_shift = rho_check_minus_C(rd,theta) - rho_check_minus_C(endoic,theta)
    {then endgamma = p.infinitesimal_character+rho_shift_r}
    then endox = KGB_elt(endoic, x.involution, x.torus_factor - corho_shift)
    in parameter(endox, p.lambda + lambda_shift, p.nu + nu_shift)

{note torus_factor(x) = base_grading_vector + vec; vec is more or less torus_bits(x)}
set dualB(Param p) = Param:
    let rd = p.root_datum, dGi = dual_inner_class(p), gamma = p.infinitesimal_character, x = p.x
    then endoic = endo_ic(p), theta = x.involution
    then rho_shift =  rd.rho  - endoic.rho
    then lambda_shift =  rho_i(x)  - rho_i(endoic,theta) + rho_C(rd,theta) - rho_C(endoic,theta)
    then dgamma = base_grading_vector(p.real_form) + rho(dGi), theta = x.involution
    then dtheta = -(x.involution).^
    then dtf = gamma + rho_shift  - p.lambda - lambda_shift
    then dlambda = dgamma - torus_factor(x)
    then dx = KGB_elt(dGi,dtheta,dtf)
    in parameter(dx, dlambda, dgamma)

{this appears to work even if p is not final, although I'm not sure why}
{mult of irr q in std p <-> coeff of std pd in char of irr qd}
{low_diff_char(p,H) is a terrible way to decide whether to use this}
set composition_series_to_heightB(Param p, int H) = ParamPol:
    if H.< then return composition_series(p) fi;
    let start = elapsed_ms()
    then answer = if low_diff_char(p,H)
    	 	  then let Bp = partial_block(p), H0 = height(p)
    		       then BpH_js = for q@j in Bp do if q.height <= H
				     	     	      then [j]
				     		      else [] fi
						      od.##
    		       then BpH = for j in BpH_js do Bp[j] od, dp = dualB(p)
    		       then dBpH = for q in BpH do dualB(q)
    	      	       	    	   od {these qd are lower ht than pd}
    		       then dKLs = for dq in dBpH do KL_sum_at_s(dq) od
    		       in sum(p.real_form, for dQ@i in dKLs do pos_part(dQ[dp])*BpH[i] od)
    		  else let (below,) = height_split(composition_series(p),H)
       	 	       in s_to_1(below)
    		  fi
     then () = charTime+:= elapsed_ms() - start
     then () = char_counter.use()
     in answer
 
set composition_series_to_heightB(ParamPol P, int H) = ParamPol:
    map(((Param->ParamPol): (Param p): composition_series_to_heightB(p, H)), P)

{WARNING: HAVE NOT MADE THIS WORK FOR NEGATIVE H!}
{i,j entry is mult of irr i in (partial block) in standard j; so always i <= j, mat is upper triang}
{column j is comp series of std #j <-> coeffs of std dj in irrs di}
set composition_series_mat_to_heightB(Param p, int H) = mat:
    let Bp = partial_block(p) {block elts q of greater ht (closer to discrete series) than p;
    	     		      things that may occur}
    then BpH_js = for q@j in Bp do if q.height <= H then [j] else [] fi od.##
    then BpH = for j in BpH_js do Bp[j] od, pd = dualB(p)
    then dBpH = for q in BpH do {regroup(pd.real_form,}dualB(q){)} od {these qd are lower ht than pd}
    then dKLs = for dq in dBpH do KL_sum_at_s(dq) od
    then () = for dQi in dKLs do prints( dQi{for dqj in dBpH do pos_part(dQi[dqj]) od}) od {this is row i}
    then f(int i, int j) = pos_part(dKLs[i][dBpH[j]])
    in matrix((#dBpH,#dBpH),f)

set character_formula_to_heightB(Param p, int H) = ParamPol:
   if H.< then return character_formula(p) fi;
   let Bp = partial_block(p) {block elts q of greater ht (closer to discrete series) than p;
    	     		      things that may occur}
   then BpH_js = for q@j in Bp do if q.height <= H then [j] else [] fi od.##
   then BpH = for j in BpH_js do Bp[j] od, dp = dualB(p)
   then dBpH = for q in BpH do {regroup(dp.real_form,}dualB(q){)} od {these dq are lower ht than dp}
   then dKLs = for dq in dBpH do KL_sum_at_s(dq) od {qd plus earlier q'd}
   then f(int i, int j) = pos_part(dKLs[i][dBpH[j]])
   then M = matrix((#dBpH,#dBpH),f), ppol = 1*p
   then pvec = vec: for q in BpH do int_part(ppol[q]) od {e(#BpH, #BpH-1)}
   then ansvec = solve(M,pvec).requisition
   in sum(p.real_form, for q@j in BpH do ansvec[j]*q od)

set character_formula_to_heightB(ParamPol P, int H) = ParamPol:
    map(((Param->ParamPol): (Param p): character_formula_to_heightB(p, H)), P)

{-----------------------------}
set tabulate_at_1 ([Param] block, (Param->ParamPol) f) = mat:
  for y in block { y determines a column of the result }
  do let fy=f(y) in for x in block do fy[x].s_to_1 od
  od

set signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(partial_block(p), character_formula@Param)

set KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(partial_block(p), composition_series@Param)

{ versions that do the whole block rather than a partial block }
set full_signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),character_formula@Param)
set full_KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),composition_series@Param)


set print_formatted (ParamPol P) = void:
  for w@p in P do prints(split_factor_format(w),"*",p) od

set print_character_formula (Param p) = void:
  print_formatted(character_formula(p))

set print_composition_series(Param p) = void:
  print_formatted(composition_series(p))

set print_with_length (ParamPol P) = void:
  for c@p in P do prints(c.split_factor_format, "*"  , p, " ", p.length) od

{ print out high length terms as they become available }
set composition_series_verbose (ParamPol P) = ParamPol:
   let result=null_module(P), max=max(for p in monomials(P) do length(p) od)
in for L:max+1 ~ { reverse }
   do prints("Length: ", L)
   ;  let result_new=null_module(P)
   in for c@p in P
      do if length(p)=L then result_new +:=c*composition_series(p) fi
      od
   ;  result := result+result_new
   ;  prints("terms in result of length ", L, ":")
   ;  for c@p in result
      do if length(p)=L
         then prints(c.split_factor_format, "*",p, " ", p.length)
	 fi
      od
   od ; prints("result:"); print_with_length(result); result

{ simpler and faster: trace progress while computing |composition_series| }
set composition_series_trace (ParamPol P) = ParamPol:
  null_module(P)+
  while !=P { non null module }
  do let (coef,p):term=first_term(P)
  in P -:= coef*character_formula(p)
  ; prints(coef.int_part,"*",p," [",height(p),"]") { coefficients are integer }
  ; term
  od
