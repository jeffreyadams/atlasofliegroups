<basic.at { for |s_to_1| and many others }
<count.at { for |char_counter| }
<parameters.at { for |dual_inner_class| }
<hash.at {for hashed low function}
<polynomial.at {for eval}

{ KL stuff, including character formulas and composition series
  This implementation seeks to avoid using KL_block, and instead uses
  KL_sum_at_s, as this function stores earlier results
  Also (compared to old implementation) no regular/singular case distinction
}

{convention: "to_height" always computes with a to height algorithm. "to_ht" may
choose whether "to height" or "to infinity" algorithm is faster.}

{<time.at {for print_time_string}}
{
  Basic object: column of KL matrix (P-matrix), of polynomials evaluated as s,
  which by setting s=1 gives formula for irreducible as sum of standards

  main functions:

  character_formula(p): irreducible(p) as sum of standards
  composition_series(p): standard(p) as sum of irreducibles

  signed_KL_mat_at_1(p): signed P-matrix evaluated at 1 (integral matrix)
  KL_inverse_mat_at_1(p): Q-matrix evaluated at 1 (integral matrix)

  also
    print_character_formula,print_composition_series
}

{ ------------------------------------------------------------------- }
{seat_belt_on:=false}

{whether to use to_ht instead of truncating full_deform}
set to_ht_over_u_flag = true

{set CF_flag = false}
set charTime = int:0

set charTimeToHt = int:0

{ the next type is the same as |Maybe<KTypePol>|, but injector names differ }
set_type maybe_KTP = (void timed_out | KTypePol done)

set_type maybe_PP =  (void timed_out_PP | ParamPol done_PP)

set is_done(maybe_KTP P) = bool:
    case P
    | timed_out: false
    | done: true
    esac

set is_done(maybe_PP P) = bool:
    case P
    | timed_out_PP: false
    | done_PP: true
    esac

set character_formula (Param p) = ParamPol:
    let start = elapsed_ms()
    in s_to_1(KL_sum_at_s(p)) next charTime+:= elapsed_ms() - start;
       char_counter.use()
    {then () = if CF_flag then prints("CF(",p.x.number,",",p.lambda,",",
       p.nu,"), charTime = ",print_time_string(CharFormTime)) fi}

{set character_formula (Param p) = ParamPol: s_to_1(KL_sum_at_s(p))}

set character_formula (ParamPol P) = ParamPol: map(character_formula@Param,P)

{ Block of p, including zero parameters. Relevant because that's where
KL calculations need to happen }
set full_block(Param p) = [Param]:
    let tworho = two_rho(p.real_form)
    then q0 = parameter(p.x,p.lambda +tworho, p.nu+tworho)
    in for q in block_of(q0)
       do parameter(q.x,q.lambda-tworho, q.nu-tworho)
       od

{in is_unitary_to_ht(HT), KL calculations live in this subset of
full_block}
set full_block_to_ht(Param p, int HT) = [Param]:
    for q in full_block(p)
    do if height(q) <= HT
       then q
       else break
       fi
    od

{need to compute on loading; if it's repeated,
the second invocation will be too fast}
set KL_rate = rat:
    let start = elapsed_ms()
    then  (,m,,) = KL_block(E6_s.trivial) {size of E6_s block above trivial}
    in (elapsed_ms() - start)/m^2

{predicted time in milliseconds to compute KL in block of p}
set KL_predictor_full(Param p) = int: floor((#full_block(p))^2 * KL_rate) {next prints("we're in KL_pred_full at ",p)}
{maybe better? use number of extremal pairs in full block??
ROUGHLY: (x,y) so tau(x) not contained?? SO: how many pairs of [bool] order
rank have this. This is some function of rank?}

{this one is relevant to KL_sum_at_s_to_height, I think?}
{predicted time in milliseconds to compute KL to height HT in block of p}
set KL_predictor_up_to_ht(Param p, int HT) = int: floor((#full_block_to_ht(p,HT))^2 * KL_rate)
{next prints("we're in KL_pred_up at ",p)}

{relevant to KL_sum_at_s for p}
set KL_predictor(Param p) = int: floor((#partial_block(p))^2*KL_rate) {next prints("we're in KL_pred at ",p)}

set low_count= int:0
set low_time = int:0
{for predicting whether to_ht or is_unitary is faster}
set low(Param p) = (int,int,int):
    let start = elapsed_ms(), ic = p.inner_class, theta = p.x.involution, gamma = p.infinitesimal_character
    then LAM = (dominant(ic,(1+theta)*gamma)*ic.two_rho_check)\2 {this is
    height(p); size of lambda}
    then NU = (dominant(ic, (1-theta)*gamma) *ic.two_rho_check)\2 {size of nu}
    then GAM = (p.infinitesimal_character* ic.two_rho_check)\1 {this is max height at infl char}
    	 {is_unitary_to_ht(p,GAM) means unitary}
    in (LAM,NU,GAM) next low_count+:=1; low_time +:= elapsed_ms() - start

set GAM(Param p) = int: (p.infinitesimal_character*p.inner_class.two_rho_check)\1

{If NU (nu part) > LAM (lambda part) *nu_frac, then figure to_ht could work better}
set nu_frac = 1/1

{if target height < GAMMA*gamma_frac, then figure to_ht could be faster. So largest
reasonable target height is GAMMA*gamma_frac. INCREASE to use to_ht
more often}
{In E7_s, gamma_frac = 1/3 and test25 = params of infl char rho so low(p, ht(p)+25)
let to character_formula MUCH faster than character_formulas_to_ht: 178 secs vs 978 secs}
set gamma_frac = 1/4

{if target height < (GAM - LAM)*diff_frac, then figure
is_unitary_to_ht could be faster. So largest reasonable target height
is (GAM-LAM)*diff_frac. INCREASE to use to_ht more often}
set diff_frac = rat: 1/3 {1/4 better than 1/8 for E7_s spherical}

{if target height < GAM*diff_char_frac, then figure
{formerly (GAM - LAM)*diff_frac}
is_unitary_to_ht could be faster. So largest reasonable target height
is (GAM-LAM)*diff_frac. INCREASE to use to_ht more often}
set diff_char_frac = rat: 1/8 {1/8 and 1/12 used a bit more memory and time in
    		     	       spherical E7_s}
		{2/5/26: for Spin(6,6), .20 was faster than .15 or .25}
		{2/12/26: 1/3 was better than 1/5 or 1/2 for E7_s (20925,[ 1, 2, 2, 1, 1, 2, 2 ]/1)}
		{2/14/26: 1/4 better than 1/3 for E7_s[20000:20025]}
		{2/15/26: 1/8 much better than 1/4 20800-20810}
set diff_KGB_char_frac = rat: 9/10

{if LAM < lam_frac*GAM (big nu), don't try to_ht }
set lam_frac = rat: 1/6 {2/3}

{whether to use to_height in computing to height N}
{true means large nu/small ht, so is_unitary_to_ht could be better}
set low_nu(Param p, int HT) = bool:
    if HT < 0 then return  false fi;
    let (,NU,) = low(p)
    in NU > HT*nu_frac

{set strict_low_nu(Param p, int HT) = bool:
    if HT < 0 then return  false fi;
    let (,NU,) = low(p)
    in (strict_factor*NU > HT*nu_frac)}

{true means GAM big compared to HT, so is_unitary_to_ht could be better}
{If N>= GAM, then to_ht gives answer to unitarity.}
set low_gamma(Param p, int HT) = bool:
    if HT < 0 then return  false fi;
    {let (,,GAM) = low(p)
    in} (GAM(p)*gamma_frac) > HT

{Note HT must be in [LAM,GAM) True says it's near the bottom of that range: small HT.}
set low_diff(Param p, int HT) = bool:
    if (HT < 0) then return  false fi;
    let LAM = p.height, GAM = GAM(p) {(LAM, , GAM) = low(p)}
    in LAM < (1-diff_frac)*GAM and
       HT - LAM < diff_frac*GAM
    {(LAM < lam_frac*GAM) and} {(HT < diff_frac*GAM)}
    {(LAM < lam_frac*GAM) and ((GAM - LAM)*diff_frac) > HT {(HT-LAM)}}

set low_diff_char_time = int:0

{if true, allow KL_sum_at_s_to_height}
set low_diff_char(Param p, int HT) = bool: {false {ALWAYS use KL_sum_at_s}}
    if (HT < 0) then return  false fi;
    let start = elapsed_ms(){, ({LAM}, , GAM) = low(p)}
    then {ans = {(LAM < lam_frac*GAM) and} (((GAM - LAM)*diff_char_frac) > HT {HT - LAM)})}
    	 ans = p.x.number > diff_KGB_char_frac*KGB_size(p.real_form)
	       and (HT < diff_char_frac*GAM(p)) {forces LAM < diff_char_frac*GAM}
	       	   {(HT - height(p)) < diff_char_frac*GAM(p)}
    in ans next low_diff_char_time +:= (elapsed_ms() - start)

set low_KL_char(Param p, int HT) = bool:
    {prints("we're in low_KL_char at ",p);}
    p.x.number > diff_KGB_char_frac*KGB_size(p.real_form) and
    KL_predictor_up_to_ht(p,HT) < KL_predictor(p)

{Switching to HT -LAM 1/26 didn't work well; adding the small LAM condition is meant to alleviate??}

{bad experiences Jan 26 suggested this version}
set low_lam(Param p, int HT) = bool:
    if HT < 0 then return  false fi;
    {let (LAM, , GAM) = low(p)
    in}  (p.height < lam_frac*GAM(p))

set prefer_KL_flag = false

set prefer_diff_flag = true {true used to give true for parameter(E7_s,773,[0,1,1,1,1,1,0]/1,
    [-3,0,0,0,6,-6,0]/2) and HT 327, leading to a very slow is_unitary_to_ht}

set prefer_gamma_flag = false

set prefer_lam_flag = false

{whether to apply test to switcb from is_unitary_to_ht to is_unitary}
set low_flag = true

{whether to apply test to switcb from KL_sum_to_ht to KL_sum}
set low_char_flag = true

{if true, allow hermitian_form_irreducible_to_ht; if false, truncate hermitian_form_irreducible}
set low(Param p, int HT) = bool:
    if HT < 0 then return false
    elif not low_flag
    then return true
    elif prefer_diff_flag {default true 2/4/26}
    then {strict_}low_diff(p,HT)
    elif prefer_gamma_flag
    then {strict_}low_gamma(p,HT)
    elif prefer_lam_flag
    then low_lam(p,HT) and low_diff(p,HT)
    else {strict_}low_nu(p,HT)
    fi

{whether to consider replacing KL_sum_to_ht with KL_sum}
set low_char(Param p, int HT) = bool:
    if HT < 0 then return false
    elif not low_char_flag
    then return true
    elif prefer_diff_flag
    then low_diff_char(p,HT)
    {elif prefer_strict_KL_flag
    then strict_low_KL_char(p,HT)}
    elif prefer_KL_flag
    then low_KL_char(p,HT)
    else false{ALWAYS switch to KL_sum}
    fi

set to_ht (KTypePol P,int N) = KTypePol:
  if N<0 then return P fi;
  let (below,)=height_split(P,N) in below

set to_ht(maybe_KTP P,int N) = maybe_KTP:
    if N < 0 then return P fi;
    case P
    | timed_out: timed_out()
    | done(r): done(to_ht(r,N))
    esac

set to_ht_PP (int N) = (ParamPol->ParamPol): (ParamPol P):
  if N < 0 then P
  else let (below,)=height_split(P,N) in below
  fi

set to_ht (int N) = (KTypePol->KTypePol): (KTypePol P):
  if N < 0 then P
  else let (below,)=height_split(P,N) in below
  fi

set KL_sum_at_s(Param p) = ParamPol:
    let start = elapsed_ms()
    in KL_sum_at_s(p) next charTime +:= elapsed_ms() - start; char_counter.use()

set KL_sum_at_s_to_ht_new(int HT) = (Param p) ParamPol: {should check whether library knows KL_sum_at_s, use that}
    let start = elapsed_ms()
    in if HT < 0
       then KL_sum_at_s(p)
       else let mKLS = stored_KL_sum_at_s(p)
       	    in case mKLS
	       | timed_out_PP: if low_char(p,HT)
       	       	 	    then KL_sum_at_s_to_height(p,HT) 
       			    else let (below,) = height_split(KL_sum_at_s(p),HT), middle = elapsed_ms()
    	    		    	 in below
			    fi
	       | done_PP(KLS): let (below,) = height_split(KLS,HT)
    	       	 	    in below
	       esac
       fi next charTimeToHt +:= elapsed_ms() - start; char_counter_to_ht.use()

set KL_sum_at_s_to_ht(int HT) = (Param p) ParamPol: {should check whether library knows KL_sum_at_s, use that}
    let start = elapsed_ms()
    in if HT < 0
       then KL_sum_at_s(p)
       elif low_char(p,HT)
       then KL_sum_at_s_to_height(p,HT)
       else let (below,) = height_split(KL_sum_at_s(p),HT), middle = elapsed_ms()
    	    in below
       fi next charTimeToHt +:= elapsed_ms() - start; char_counter_to_ht.use()


set KL_sum_at_s_to_ht_inter(int HT) = (Param p,int time) maybe_PP:
    let start = elapsed_ms()
    in if  HT < 0
       then KL_sum_at_s(p).done_PP
       elif low_char(p,HT)
       then KL_sum_at_s_to_height(p,HT,time) next charTimeToHt +:= elapsed_ms() - start; char_counter_to_ht.use()
       else let (below,) = height_split(KL_sum_at_s(p),HT)
    	    in below.done_PP
       fi

set twisted_KL_sum_at_s(Param p) = ParamPol:
    let start = elapsed_ms()
    in twisted_KL_sum_at_s(p) next charTime +:= elapsed_ms() - start; char_counter.use()


set twisted_KL_sum_at_s_to_ht(int HT) = (Param p) ParamPol:
    if HT < 0 then return twisted_KL_sum_at_s(p)
    elif low_char(p,HT)
    then let start = elapsed_ms()
    	 then (below,) = height_split(twisted_KL_sum_at_s(p),HT)
    	 in below next charTimeToHt +:= elapsed_ms() - start; char_counter_to_ht.use()
    else let (below,) = height_split(twisted_KL_sum_at_s(p),HT)
    	 in below
    fi

set character_formula_to_ht(Param p, int HT) = ParamPol:
    s_to_1(KL_sum_at_s_to_ht(HT)(p))

set character_formula_to_ht (ParamPol P, int HT) = ParamPol:
    map(((Param->ParamPol): (Param p): character_formula_to_ht(p, HT)), P)

{ ------------------------------------------------------------------- }

{ composition series }

set composition_series_old(ParamPol P) = ParamPol:
  null_module(P)+
  while !=P { non null module }
  do let (coef,p):term=first_term(P) in P -:= coef*character_formula(p); term
  od

set composition_series_old (Param p) = ParamPol: composition_series_old(ParamPol: p)

set composition_series_to_height_old(ParamPol P, int HT) = ParamPol:
  if HT.< then return composition_series_old(P) fi;
  let (PHT,) = height_split(P,HT)
  in null_module(P)+
  while !=PHT { non null module }
  do let (coef,p):term=first_term(PHT)
     in PHT -:= coef*character_formula_to_ht(p,HT)
     ; term
  od

set composition_series_to_height_old (Param p,int HT) = ParamPol:
    composition_series_to_height_old(ParamPol: p, HT)

set composition_series(Param p) = ParamPol:
    let (B,m,M,polys) = dual_KL_block(p) {lower triangular; jth col is mult in stds of B[j]}
    in sum(p.real_form,for q@j in B[:m+1] do eval(polys[M[m,j]],1)*q od)

set composition_series(ParamPol P) = ParamPol:
    sum(P.real_form, for c@q in P do c*composition_series(q) od)

set composition_series_to_height(Param p, int HT) = ParamPol:
    if HT < 0 then return composition_series(p) fi;
    let (B,m,M,polys) = dual_KL_block(p) {lower triangular; jth col is mult in stds of B[j]}
    in sum(p.real_form, for q@j in B[:m+1] do if height(q) <= HT then eval(polys[M[m,j]],1)*q else 0*q fi od)

set composition_series_to_height (ParamPol P,int HT) = ParamPol:
    sum(P.real_form, for c@q in P do composition_series_to_height(q, HT) od)

set composition_series_to_ht(ParamPol P, int HT) = ParamPol:
  if HT.< then return composition_series(P) fi;
  P:=to_ht_PP(HT)(P);
  if #P = 0 then return P fi;
  let p0 = first_param(P)
  in if not low_char(p0,HT)
     then to_ht_PP(HT)(composition_series(P))
     else null_module(P) +
     	  while !=P { non null module }
  	  do let (coef,p):term=first_term(P)
     	  in P -:= coef*character_formula_to_ht(p,HT)
     	  ; term
  	  od
     fi
set composition_series_to_ht (Param p,int H) = ParamPol: composition_series_to_ht(ParamPol: p, H)

{---------------------------}
{same using dual}

set pos_part(Split s) = int:
    let (a,b) = %s in abs(a+b)

set endo_ic(Param p) = inner_class(integrality_datum(p),p.x.involution)

{one root from each non-real, non-imag pos pair (alpha, theta*alpha)}
{well-defined up to (1-theta)alpha}
set rho_C(RootDatum rd, mat theta) = vec:
    let zero = null(rd.rank)
    in sum(rd.rank, for alpha@j in rd.posroots
    		    do let k = root_index(rd,theta*alpha)
		        in if k > j {k=j is imag; k = -j-1 is real}
		       	   then alpha
		       	   else zero
			   fi
		    od)

{one root from each non-real, non-imag pos pair (alpha, -theta*alpha)}
{well-defined up to (1+theta)alpha}
set rho_minus_C(RootDatum rd, mat theta) = vec:
    let zero = null(rd.rank)
    in sum(rd.rank, for alpha@j in rd.posroots
    		    do let k = root_index(rd,theta*alpha)
		        in if -k-1 > j {k=j is imag; k = -j-1 is real}
		       	   then alpha
		       	   else zero
			   fi
		    od)

set rho_check_C(RootDatum rd, mat theta) = vec:
    let zero = null(rd.rank)
    in sum(rd.rank, for alpha@j in rd.posroots
    		    do let k = root_index(rd,theta*alpha)
		        in if k > j {k=j is imag; k = -j-1 is real}
		       	   then rd.poscoroots[j]
		       	   else zero
			   fi
		    od)

set rho_check_minus_C(RootDatum rd, mat theta) = vec:
    let zero = null(rd.rank)
    in sum(rd.rank, for alpha@j in rd.posroots
    		    do let k = root_index(rd,theta*alpha)
		        in if -k-1 > j {k=j is imag; k = -j-1 is real}
		       	   then rd.poscoroots[j]
		       	   else zero
			   fi
		    od)

set endo(Param p) = Param:
    let endoic = endo_ic(p), x = p.x, rd = p.root_datum
    then theta = x.involution
    then rho_shift =  rd.rho  - endoic.rho
    then lambda_shift =  rho_i(x)  - rho_i(endoic,theta) + rho_C(rd,theta) - rho_C(endoic,theta)
    then nu_shift = p.x.rho_r  - rho_r(endoic,theta) + rho_minus_C(rd,theta) - rho_minus_C(endoic,theta)
    then corho_shift = rho_check_minus_C(rd,theta) - rho_check_minus_C(endoic,theta)
    {then endgamma = p.infinitesimal_character+rho_shift_r}
    then endox = KGB_elt(endoic, x.involution, x.torus_factor - corho_shift)
    in parameter(endox, p.lambda + lambda_shift, p.nu + nu_shift)

{note torus_factor(x) = base_grading_vector + vec; vec is more or less torus_bits(x)}
set dualB(Param p) = Param:
    let rd = p.root_datum, dGi = dual_inner_class(p), gamma = p.infinitesimal_character, x = p.x
    then endoic = endo_ic(p), theta = x.involution
    then rho_shift =  rd.rho  - endoic.rho
    then lambda_shift =  rho_i(x)  - rho_i(endoic,theta) + rho_C(rd,theta) - rho_C(endoic,theta)
    then dgamma = base_grading_vector(p.real_form) + rho(dGi), theta = x.involution
    then dtheta = -(x.involution).^
    then dtf = gamma + rho_shift  - p.lambda - lambda_shift
    then dlambda = dgamma - torus_factor(x)
    then dx = KGB_elt(dGi,dtheta,dtf)
    in parameter(dx, dlambda, dgamma)

{this appears to work even if p is not final, although I'm not sure why}
{mult of irr q in std p <-> coeff of std pd in char of irr qd}
{low_diff_char(p,H) is a terrible way to decide whether to use this}
set composition_series_to_heightB(Param p, int H) = ParamPol:
    if H.< then return composition_series(p) fi;
    let start = elapsed_ms()
    then answer = if low_diff_char(p,H)
    	 	  then let Bp = partial_block(p), H0 = height(p)
    		       then BpH_js = for q@j in Bp do if q.height <= H
				     	     	      then [j]
				     		      else [] fi
						      od.##
    		       then BpH = for j in BpH_js do Bp[j] od, dp = dualB(p)
    		       then dBpH = for q in BpH do dualB(q)
    	      	       	    	   od {these qd are lower ht than pd}
    		       then dKLs = for dq in dBpH do KL_sum_at_s(dq) od
    		       in sum(p.real_form, for dQ@i in dKLs do pos_part(dQ[dp])*BpH[i] od)
    		  else let (below,) = height_split(composition_series(p),H)
       	 	       in s_to_1(below)
    		  fi
     then () = charTime+:= elapsed_ms() - start
     then () = char_counter.use()
     in answer
 
set composition_series_to_heightB(ParamPol P, int H) = ParamPol:
    map(((Param->ParamPol): (Param p): composition_series_to_heightB(p, H)), P)

{WARNING: HAVE NOT MADE THIS WORK FOR NEGATIVE H!}
{i,j entry is mult of irr i in (partial block) in standard j; so always i <= j, mat is upper triang}
{column j is comp series of std #j <-> coeffs of std dj in irrs di}
set composition_series_mat_to_heightB(Param p, int H) = mat:
    let Bp = partial_block(p) {block elts q of greater ht (closer to discrete series) than p;
    	     		      things that may occur}
    then BpH_js = for q@j in Bp do if q.height <= H then [j] else [] fi od.##
    then BpH = for j in BpH_js do Bp[j] od, pd = dualB(p)
    then dBpH = for q in BpH do {regroup(pd.real_form,}dualB(q){)} od {these qd are lower ht than pd}
    then dKLs = for dq in dBpH do KL_sum_at_s(dq) od
    then () = for dQi in dKLs do prints( dQi{for dqj in dBpH do pos_part(dQi[dqj]) od}) od {this is row i}
    then f(int i, int j) = pos_part(dKLs[i][dBpH[j]])
    in matrix((#dBpH,#dBpH),f)

set character_formula_to_heightB(Param p, int H) = ParamPol:
   if H.< then return character_formula(p) fi;
   let Bp = partial_block(p) {block elts q of greater ht (closer to discrete series) than p;
    	     		      things that may occur}
   then BpH_js = for q@j in Bp do if q.height <= H then [j] else [] fi od.##
   then BpH = for j in BpH_js do Bp[j] od, dp = dualB(p)
   then dBpH = for q in BpH do {regroup(dp.real_form,}dualB(q){)} od {these dq are lower ht than dp}
   then dKLs = for dq in dBpH do KL_sum_at_s(dq) od {qd plus earlier q'd}
   then f(int i, int j) = pos_part(dKLs[i][dBpH[j]])
   then M = matrix((#dBpH,#dBpH),f), ppol = 1*p
   then pvec = vec: for q in BpH do int_part(ppol[q]) od {e(#BpH, #BpH-1)}
   then ansvec = solve(M,pvec).requisition
   in sum(p.real_form, for q@j in BpH do ansvec[j]*q od)

set character_formula_to_heightB(ParamPol P, int H) = ParamPol:
    map(((Param->ParamPol): (Param p): character_formula_to_heightB(p, H)), P)

{-----------------------------}
set tabulate_at_1 ([Param] block, (Param->ParamPol) f) = mat:
  for y in block { y determines a column of the result }
  do let fy=f(y) in for x in block do fy[x].s_to_1 od
  od

set signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(partial_block(p), character_formula@Param)

set KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(partial_block(p), composition_series@Param)

{ versions that do the whole block rather than a partial block }
set full_signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),character_formula@Param)
set full_KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),composition_series@Param)


set print_formatted (ParamPol P) = void:
  for w@p in P do prints(split_factor_format(w),"*",p) od

set print_character_formula (Param p) = void:
  print_formatted(character_formula(p))

set print_composition_series(Param p) = void:
  print_formatted(composition_series(p))

set print_with_length (ParamPol P) = void:
  for c@p in P do prints(c.split_factor_format, "*"  , p, " ", p.length) od

{ print out high length terms as they become available }
set composition_series_verbose (ParamPol P) = ParamPol:
   let result=null_module(P), max=max(for p in monomials(P) do length(p) od)
in for L:max+1 ~ { reverse }
   do prints("Length: ", L)
   ;  let result_new=null_module(P)
   in for c@p in P
      do if length(p)=L then result_new +:=c*composition_series(p) fi
      od
   ;  result := result+result_new
   ;  prints("terms in result of length ", L, ":")
   ;  for c@p in result
      do if length(p)=L
         then prints(c.split_factor_format, "*",p, " ", p.length)
	 fi
      od
   od ; prints("result:"); print_with_length(result); result

{ simpler and faster: trace progress while computing |composition_series| }
set composition_series_trace (ParamPol P) = ParamPol:
  null_module(P)+
  while !=P { non null module }
  do let (coef,p):term=first_term(P)
  in P -:= coef*character_formula(p)
  ; prints(coef.int_part,"*",p," [",height(p),"]") { coefficients are integer }
  ; term
  od
