
{ KL stuff, including character formulas and composition series
  This implementation seeks to avoid using KL_block, and instead uses
  KL_sum_at_s, as this function stores earlier results
  Also (compared to old implementation) no regular/singular case distinction
}

<basic.at
<count.at {for char_counter}
{<time.at {for print_time_string}}
{
  Basic object: column of KL matrix (P-matrix), of polynomials evaluated as s,
  which by setting s=1 gives formula for irreducible as sum of standards

  main functions:

  character_formula(p): irreducible(p) as sum of standards
  composition_series(p): standard(p) as sum of irreducibles

  signed_KL_mat_at_1(p): signed P-matrix evaluated at 1 (integral matrix)
  KL_inverse_mat_at_1(p): Q-matrix evaluated at 1 (integral matrix)

  also
    print_character_formula,print_composition_series
}

{ ------------------------------------------------------------------- }

{set CF_flag = false}
set charTime = int:0

set character_formula (Param p) = ParamPol:
    let start = elapsed_ms()
    then answer = s_to_1(KL_sum_at_s(p))
    then () = charTime+:= elapsed_ms() - start
    then () = char_counter.use()
    {then () = if CF_flag then prints("CF(",p.x.number,",",p.lambda,",",
       p.nu,"), charTime = ",print_time_string(CharFormTime)) fi}
    in answer

{set character_formula (Param p) = ParamPol: s_to_1(KL_sum_at_s(p))}

set character_formula (ParamPol P) = ParamPol: map(character_formula@Param,P)

{for predicting whether to_ht or is_unitary is faster}
set low(Param p) = (int,int,int):
    let ic = p.inner_class, theta = p.x.involution, gamma = p.infinitesimal_character
    then LAM = (dominant(ic,(1+theta)*gamma)*ic.two_rho_check)\2 {this is
    height(p); size of lambda}
    then NU = (dominant(ic, (1-theta)*gamma) *ic.two_rho_check)\2 {size of nu}
    then GAM = (p.infinitesimal_character* ic.two_rho_check)\1 {this is max height at infl char}
    	 {is_unitary_to_ht(p,GAM) means unitary}
    in (LAM,NU,GAM)

{If NU (nu part) > LAM (lambda part) *low_frac, then figure to_ht could work better}
set low_frac = 1/1

{if target height < GAMMA*gamma_frac, then figure to_ht could be faster. So largest
reasonable target height is GAMMA*gamma_frac. INCREASE to use to_ht
more often}
{In E7_s, gamma_frac = 1/3 and test25 = params of infl char rho so low(p, ht(p)+25)
let to character_formula MUCH faster than character_formulas_to_ht: 178 secs vs 978 secs}
set gamma_frac = 1/4

{if target height < (GAM - LAM)*diff_frac, then figure is_unitary_to_ht could be faster. So largest
reasonable target height is (GAM-LAM)*diff_frac. INCREASE to use to_ht
more often}
set diff_frac = rat: 3/4

{if target height < (GAM - LAM)*diff_frac, then figure is_unitary_to_ht could be faster. So largest
reasonable target height is (GAM-LAM)*diff_frac. INCREASE to use to_ht
more often}
set diff_char_frac = rat: 1/8

{ trunc_factor is how much to DISLIKE trunctating character
    formula; increase to truncate LESS often}
set trunc_factor = rat: 2/1

{whether to use to_height in computing to height N}
{true means large nu, so to_ht could be better}
set low_nu(Param p, int N) = bool:
    let (,NU,) = low(p)
    in NU > N*low_frac

set low_gamma(Param p, int N) = bool:
    let (,,GAM) = low(p)
    in GAM*gamma_frac > N

set low_diff(Param p, int N) = bool:
    let (LAM, , GAM) = low(p)
    in (GAM - LAM)*diff_frac > N

set low_diff_char(Param p, int N) = bool:
    let (LAM, , GAM) = low(p)
    in (GAM - LAM)*diff_char_frac > N

set prefer_gamma_flag = true

set prefer_diff_flag = true

{set low_test_flag = false

set low_test(Param p, int N) = bool:
    let q = all_parameters_gamma(p.real_form, p.infinitesimal_character)~[0]
    in height(q) - height(p) > N
}

set low(Param p, int N) = bool:
    {if low_test_flag
    then low_test
    el}if prefer_diff_flag
    then low_diff(p,N)
    elif prefer_gamma_flag
    then low_gamma(p,N)
    else low_nu(p,N)
    fi

set character_formula_to_height(Param p, int N) = ParamPol:
    let start = elapsed_ms()
    then answer = if low_diff_char(p,N)
    	 	  then s_to_1(KL_sum_at_s_to_height(p,N))
		  else let (below,) = height_split(KL_sum_at_s(p),N)
       	    	       in s_to_1(below)
       		  fi
     then () = charTime+:= elapsed_ms() - start
     then () = char_counter.use()
     {then () = if CF_flag then prints("CFTH((",p.x.number,",",p.lambda,",",
       p.nu,"),",N,"), CTime = ",print_time_string(CharFormTime)) fi}
     in answer

set character_formula_to_height (ParamPol P, int N) = ParamPol:
    map(((Param->ParamPol): (Param p): character_formula_to_height(p, N)), P)
{ ------------------------------------------------------------------- }

{ composition series }

set composition_series(ParamPol P) = ParamPol:
  null_module(P)+
  while !=P { non null module }
  do let (coef,p):term=first_term(P) in P -:= coef*character_formula(p); term
  od

set composition_series (Param p) = ParamPol: composition_series(ParamPol: p)

set tabulate_at_1 ([Param] block, (Param->ParamPol) f) = mat:
  for y in block { y determines a column of the result }
  do let fy=f(y) in for x in block do fy[x].s_to_1 od
  od

set signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(partial_block(p), character_formula@Param)

set KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(partial_block(p), composition_series@Param)

{ versions that do the whole block rather than a partial block }
set full_signed_KL_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),character_formula@Param)
set full_KL_inverse_mat_at_1(Param p) = mat:
  tabulate_at_1(block_of(p),composition_series@Param)


set print_formatted (ParamPol P) = void:
  for w@p in P do prints(split_factor_format(w),"*",p) od

set print_character_formula (Param p) = void:
  print_formatted(character_formula(p))

set print_composition_series(Param p) = void:
  print_formatted(composition_series(p))

set print_with_length (ParamPol P) = void:
  for c@p in P do prints(c.split_factor_format, "*"  , p, " ", p.length) od

{ print out high length terms as they become available }
set composition_series_verbose (ParamPol P) = ParamPol:
   let result=null_module(P), max=max(for p in monomials(P) do length(p) od)
in for L:max+1 ~ { reverse }
   do prints("Length: ", L)
   ;  let result_new=null_module(P)
   in for c@p in P
      do if length(p)=L then result_new +:=c*composition_series(p) fi
      od
   ;  result := result+result_new
   ;  prints("terms in result of length ", L, ":")
   ;  for c@p in result
      do if length(p)=L
         then prints(c.split_factor_format, "*",p, " ", p.length)
	 fi
      od
   od ; prints("result:"); print_with_length(result); result

{ simpler and faster: trace progress while computing |composition_series| }
set composition_series_trace (ParamPol P) = ParamPol:
  null_module(P)+
  while !=P { non null module }
  do let (coef,p):term=first_term(P)
  in P -:= coef*character_formula(p)
  ; prints(coef.int_part,"*",p," [",height(p),"]") { coefficients are integer }
  ; term
  od
