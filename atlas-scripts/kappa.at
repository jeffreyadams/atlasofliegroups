set simple_reflections(RootDatum G)=[WeylElt]:
for alpha in G.simple_roots do root_reflection(G,alpha) od

{cross_sub_orbit[[WeylElt] list,KGBElt x) returns [(KGBElt,WeylElt)]
where each w is in the Weyl group of x.root_datum
sometimes you want: list is simple roots of a sub_root_system,
and the Weyl group elements returned to be for this root system}
set cross_sub_orbitx (RootDatum rd_sub, KGBElt x) = [KGBElt,WeylElt]:
cross_sub_orbit(simple_reflections(rd_sub),x)


set imaginary_root_system(KGBElt x)=RootDatum:
let (roots,coroots)=simple_imaginary_subsystem(x) in root_datum(roots,coroots,true)

{imaginary simple root: index of simple root in the imaginary subsystem of p.x}
{caution: what matters is the coroot in X^*(T^vee) since this gets evaluated
on exp(2\pi is)\in T^vee}
set kappa(Param p_G, ratvec s, int imaginary_simple_root_index)=int:
let G=p_G.root_datum then
x=p_G.x then
alpha=imaginary_root_system(x).simple_roots[imaginary_simple_root_index] then
alpha_check=coroot(G,alpha) in 
if is_compact_imaginary(alpha,x) then 1
else let
()=prints("alpha_check: ", alpha_check, " s", s) then
z=rat_as_int(alpha_check*s) in
(-1)^z fi

{dangerous bend:
 w: Weyl element of imaginary_root_system(x)
 but when acting by cross action it is viewed in G}
set kappa(Param p, ratvec s, WeylElt w)=int:
let ()=prints("p=", p, "  ",p.real_form, " s: ", s, new_line, "w: ", w, " ", w.root_datum) in 
let rd_i=root_datum(w) then
()=assert(rd_i=imaginary_root_system(p.x),"root system of w\ne imaginary roots of p.x") then
rec_fun f(Param p, ratvec s, WeylElt w)=int:
let ()=prints("in rec_fun, ", p, " ", s, " ", w, " ", w.matrix) in
if length(w)=0 then 1 
elif length(w)=1 then kappa(p,s,w.word[0]) else
let last=w.word~[0] {index of root in rd_i} then
()=prints("last: ", last) then
reflection_i=W_elt(rd_i,[last]) {in W(rd_i)} then
y=w*reflection_i  {in W(rd_i)}  then
alpha=rd_i.simple_roots[last] then
()=prints("alpha=",alpha) then
w_times_p=cross(alpha,p) {alpha is the vec of root of rd_i, viewed as root of G} in
kappa(p,s,last) * f(cross(last,p),s,y)  fi
  in prints("OK", p, " ", s, " ", w);f(p,s,w)

set kappa_packet_unnormalized(Param p,ratvec s)=ParamPol:
let rd_i=imaginary_root_system(p.x) then 
orbit=cross_sub_orbit(simple_imaginary_reflections(p.x),p.x)  in {list of pairs (w*x,w) where w is in G.W}
{but want them in W(rd_i)}
sum(p.real_form, for (x,w) in orbit do
  let w_i=W_elt(rd_i, w.matrix) in 
  kappa(p,s,w_i)*parameter(x,p.lambda,p.nu) od)

set generic_terms([Param] params)=[Param]:
for p in params do if =p.x.torus_factor then [p] else [] fi od.##

set generic_terms(ParamPol P)=[Param]: generic_terms(monomials(P))

set kappa_packet(Param p,ratvec s)=ParamPol:
let P=kappa_packet_unnormalized(p,s) then
gt=generic_terms(P) in
if =#gt then
 prints("no generic terms");P
else
 let p=generic_terms(P)[0] then
 coeff=P[p] in
 assert(is_int(coeff),"coefficient not an integer");
 sign(split_as_int(coeff))*P
fi

set coefficient(Param p_G,ratvec v)=rat:p_G.x.unnormalized_torus_factor*v