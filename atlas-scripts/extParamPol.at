{Double extended parameters}
{this file extParamPol.at includes what used to be extParamPolPlus.at}

{ExtParamPol: virtual character for doubly extended group
 two commuting distinguished involutions: (xi,delta)
 xi is usually (must be?) the distinguished involution in the inner class
 delta is the outer twist
}
 <bigMatrices.at
<ext_deform.at
{verbosity for recursive_deform function}
set recursive_deform_verbose=false

{
Two singly extended groups:
<xi,G>       (left)
<G,delta>    (right)
doubly extended group:
<xi,G,delta> (double)

ZParamPol:    ParamPol with Z coefficients
ZExtParamPol: (ZParamPol,ZParamPol,ZParamPol,delta)
ExtParamPol:  (xi,ParamPol,ParamPol,ParamPol,delta)


ZParamPol:    virtual character of G
ParamPol:     virtual character of <xi,G>
ZExtParamPol: virtual character of <G,delta>
ExtParamPol:  virtual characterof <xi,G,delta>
}

set_type [ ZParamPol = ParamPol]   {Z-coefficients}
set_type [ ZExtParamPol = (ZParamPol P_plus, ZParamPol P_minus, ZParamPol P_ind,mat delta)]       {each term has Z coeffs}
set_type [ ExtParamPol = (mat xi, ParamPol P_plus, ParamPol P_minus, ParamPol P_ind,mat delta)]  {each term has Z[s] coeffs}

set param_pol(ZParamPol P)=ParamPol:P
set ext_param_pol(ZExtParamPol (P,Q,R,delta))=ExtParamPol:(P.real_form.distinguished_involution,P,Q,R,delta)

{list of params occuring in three terms}
{param_pol(monmials(P)) = terms from P with all +1 coefficients, add these, and take monomials of the result}
set monomials(ZExtParamPol (P,Q,R,))=[Param]:
monomials(param_pol(monomials(P))+param_pol(monomials(Q))+param_pol(monomials(R)))

set monomials(ExtParamPol (,P,Q,R,))=[Param]:
monomials(param_pol(monomials(P))+param_pol(monomials(Q))+param_pol(monomials(R)))




set is_ZParamPol(ParamPol P)=bool:
all(for (c,) in %P do is_int(c) od)

{ExtParam E: has both xi=E.distinguished_involution and delta=E.delta
 Z_ext_param_pol(E) =  (P,Q,R,delta)   having to do with delta
                    =  (p,0,0,delta)   delta(p)=p, sign is +
                    or (0,p,0,delta)   delta(p)=p, sign is -
		    or (0,0,p,delta)   delta(p)\ne p
}
set Z_ext_param_pol (ExtParam E) = ZExtParamPol:
let delta=E.delta, p=parameter(E) then
N=null_module(real_form(p)) in
if not is_fixed(p,delta) then (N,N,N+p,delta)
 elif sign(E)=1 then (N+p,N,N,delta)
 else (N,N+p,N,delta)
fi

{p -> (p,N,N,delta)   delta(p)=p, plus_minus_0=1
      (N,p,N,delta)   delta(p)=p, plus_minus_0=-1
      (N,N,p,delta)   delta(p)\n p, plus_minus_0=0
}
set Z_ext_param_pol (Param p,int plus_minus_0)=ZExtParamPol:
let delta=p.real_form.distinguished_involution then
N=null_module(p) in
if is_fixed(p,delta) then
 if plus_minus_0=1 then (N+p,N,N,delta)
  elif plus_minus_0=-1 then (N,N+p,N,delta)
  else error("plus_minus_0=0, should be \pm 1")
 fi
else
 assert(not is_fixed(p,delta), "plus_minus_0=\pm 1, should be 0");
 (N,N,N+p,delta)
fi

set is_ZExtParamPol((ParamPol P, ParamPol Q, ParamPol R, mat delta))=bool:
 is_ZParamPol(P) and  is_ZParamPol(Q) and   is_ZParamPol(R)

{see Z_ext_param_pol in extParamPol.at}
{set extParamPol (ExtParam E) = ExtParamPol:
  let p=parameter(E)
  then xi=E.ic.distinguished_involution then
  delta=E.delta
  then N=null_module(real_form(p)) then F=N+p in
  if not is_fixed(p,xi) then (xi,N,N,F,delta)
  elif sign(E)=1 then (xi,F,N,N,delta)
  else (xi,N,F,N,delta)
  fi
}

{ type is in range {-1,0,1} here }
set extParamPol (Param p,int type,mat delta) = ExtParamPol:
  let N=null_module(real_form(p)) then
  xi=p.real_form.distinguished_involution in
  if type=1 then (xi,N+p,N,N,delta)
  elif type=minus_1 then (xi,N,N+p,N,delta)
  else (xi,N,N,N+p,delta)
  fi

set *(Split z,ExtParamPol(xi,P_plus,P_minus,P_ind,delta))= ExtParamPol:
  (xi,z*P_plus,s*P_minus,s*P_ind,delta)

set *(Split S,ZExtParamPol(P_plus,P_minus,P_ind,delta))=
  (P_plus.real_form.distinguished_involution,S*P_plus,S*P_minus,S*P_ind,delta)

set * (Split z,ExtParam E) =
z*Z_ext_param_pol(E)

set + (ExtParamPol(xi,P_plus_1,P_minus_1,P_ind_1,delta)
      ,ExtParamPol (Xi,P_plus_2,P_minus_2,P_ind_2,Delta)
      ) = ExtParamPol:
      assert(xi=Xi and delta=Delta,"involutions don't match");
     (xi,P_plus_1+P_plus_2,P_minus_1+P_minus_2,P_ind_1+P_ind_2,delta)

set - (ExtParamPol(xi,P_plus_1,P_minus_1,P_ind_1,delta)
      ,ExtParamPol (Xi,P_plus_2,P_minus_2,P_ind_2,Delta)
      ) = ExtParamPol:
      assert(xi=Xi and delta=Delta,"involutions don't match");
      (xi,P_plus_1-P_plus_2,P_minus_1-P_minus_2,P_ind_1-P_ind_2,delta)


set + (ExtParamPol P,[ExtParamPol] Q) = ExtParamPol:
  let rv=P in for R in Q do rv+:=R od;rv

set + (ExtParamPol P,(Split S,Param p,int type)) = ExtParamPol:
  P+S*extParamPol(p,type,P.delta)

set swap(ExtParamPol (xi,P,Q,R,delta))=ExtParamPol: (xi,Q,P,R,delta)
set s_to_1(ExtParamPol (xi,P,Q,R,delta))=ExtParamPol: (xi,P.s_to_1,Q.s_to_1,R.s_to_1,delta)

set display (ExtParamPol(,A,B,C,)) = void:
  prints("plus:",A,new_line,"minus:",B,new_line,"induced:",C)
set null_ext_module (RealForm G) = ExtParamPol: let N=null_module(G) in (G.distinguished_involution,N,N,N,G.distinguished_involution)

set find ([(int,int)] complete_indices,(int,int)pair) =int:
  first(#complete_indices,(int i)bool:complete_indices[i]=pair)

{ scale continuous part (|nu|) of extended parameter by rational factor |r| }
set * (ExtParam(ic,,,lambda,theta,,,,,):E,rat r) = ExtParam:
  E.gamma := ((1+theta)*(lambda+rho(ic))+(1-theta)*(E.nu*r))/2 ; E



{ implement ParamPol for extended parameters }

{useful shorthand}
set xi(Param p)=mat:distinguished_involution(p.inner_class)

set choose_type(Param p,mat delta)=int: if is_fixed(p,delta) then 1 else 0 fi
set is_valid_type(Param p, mat delta, int type)=bool:
 (is_fixed(p,delta) and abs(type)=1) or (not is_fixed(p,delta) and type=0) 


set twisted_coefficient_sum(mat xi,ParamPol P)=(Param->Split):(Param p):
if is_fixed(p,xi) then P[p] else s_to_1(P[p]+P[xi*p]) fi

set twisted_coefficient_sum(mat xi,mat delta,ParamPol P)=(Param->Split):(Param p):
if is_fixed(p,xi)
   then twisted_coefficient_sum(delta,P)(p)
elif is_fixed(p,delta)
   then twisted_coefficient_sum(delta,P)(p)
else {not fixed by xi or delta}
   s_to_1(P[p] + P[xi*p] + P[delta*p] + P[xi*delta*p])
fi

{support of a ParamPol P is the Params occuring: same as monomials(P)}

set support(ParamPol P)=[Param]: monomials(P)
set same_support(ParamPol P, ParamPol Q)=bool:
param_pol(support(P))=param_pol(support(Q))

set twisted_coefficient_sums_equal(mat xi, ParamPol P, ParamPol Q)=bool:
same_support(P,Q)=true and
all(for p in support(P) do
    twisted_coefficient_sum(xi,P)(p)= twisted_coefficient_sum(xi,Q)(p)
    od)

set twisted_coefficient_sums_equal(mat xi,mat delta, ParamPol P, ParamPol Q)=bool:
same_support(P,Q)=true and
all(for p in support(P) do
    twisted_coefficient_sum(xi,delta,P)(p)= twisted_coefficient_sum(xi,delta,Q)(p)
    od)

{
Equality of ExtParamPols: (xi,P,Q,R,delta) = (Xi,P',Q',R',Delta) if P=P', Q=Q'
also R=R' modulo:
(0,0,(a+bs)p + (c+ds)delta(p)) = (0,0,(a+b+c+d)p)
i.e. (1+delta)R|s=1 = (1+delta)R'|s=1
i.e. s_to_1(one_plus_delta(R,delta))=s_to_1(one_plus_delta(R',delta))
}
set =(ExtParamPol (xi,P,Q,R,delta),ExtParamPol (Xi,S,T,U,Delta))=bool:
xi=Xi and delta=Delta and
twisted_coefficient_sums_equal(xi,P,S) and
twisted_coefficient_sums_equal(xi,Q,T) and
twisted_coefficient_sums_equal(xi,delta,R,U)

set =(ZExtParamPol (P,Q,R,delta),ZExtParamPol (S,T,U,Delta))=bool:
delta=Delta and
P=S and Q=T and symmetrize(R,delta)=symmetrize(U,Delta)



set *(Split s,ExtParamPol(xi,P_plus,P_minus,P_ind,delta))= ExtParamPol:
  (xi,s*P_plus,s*P_minus,s*P_ind,delta)

set Z_ext_param_pol (Param p)=ZExtParamPol:
 if is_fixed(p,p.real_form.distinguished_involution)
  then Z_ext_param_pol(p,1)
 else
  Z_ext_param_pol(p,0)
 fi

{ param_pol(E) =  z*p having to do with xi
                 = p       xi(p)=p, sign is +
                 = sp      xi(p)=p, sign is -
                 = (1+s)p  xi(p)\ne p
}
set param_pol (ExtParam E) = ParamPol:
let xi=E.distinguished_involution,p=parameter(E) in
if not is_fixed(p,xi) then one_plus_twist(p,xi)
 elif sign(E)=1 then p
 else s*p
fi

set + (ExtParamPol(xi_1,P_plus_1,P_minus_1,P_ind_1,delta_1)
      ,ExtParamPol (xi_2,P_plus_2,P_minus_2,P_ind_2,delta_2)
      ) = ExtParamPol:
      assert(xi_1=xi_2 and delta_1=delta_2,"distinguished involutions don't match");
      (xi_1,P_plus_1+P_plus_2,P_minus_1+P_minus_2,P_ind_1+P_ind_2,delta_1)

set -(ExtParamPol(xi_1,P_plus_1,P_minus_1,P_ind_1,delta_1)
     ,ExtParamPol (xi_2,P_plus_2,P_minus_2,P_ind_2,delta_2)
     ) = ExtParamPol:
     assert(xi_1=xi_2 and delta_1=delta_2,"distinguished involutions don't match");
     (xi_1,P_plus_1-P_plus_2,P_minus_1-P_minus_2,P_ind_1-P_ind_2,delta_1)

set + (ExtParamPol P,[ExtParamPol] Q) = ExtParamPol:
  let rv=P in for R in Q do rv+:=R od;rv

set + (ExtParamPol P,(Split S,Param p,int type)) = ExtParamPol:
  P+S*Z_ext_param_pol(p,type)

{replace ExtParamPol (P_plus,P_minus,P_ind) with [(s_i,c_i,type_i)]}
set % (ExtParamPol(,P_plus,P_minus,P_ind,)) = [(Split,Param,int)]:
( for c@p in P_plus do (c,p,1) od
##for c@p in P_minus do (c,p,minus_1) od
##for c@p in P_ind do (c,p,0) od
)

set swap(ExtParamPol (xi,P,Q,R,delta))=ExtParamPol: (xi,Q,P,R,delta)
set s_to_1(ExtParamPol (xi,P,Q,R,delta))=ExtParamPol: (xi,P.s_to_1,Q.s_to_1,R.s_to_1,delta)

set pretty_print_with_spaces (ParamPol P, int spaces)= void:
if =#%P then prints(spaces*" " + "[empty]")
else
for w@p in P
 do prints(spaces*" " +"(",prettyPrint(w),")*",p)
od
fi

set show (ExtParamPol(xi,A,B,C,delta)) = void:
  prints("plus:");
  pretty_print_with_spaces(A,2);
  prints("minus:");
  pretty_print_with_spaces(B,2);
  prints("induced:");
  pretty_print_with_spaces(C,2)
set show (ZExtParamPol P)=void:show(ext_param_pol(P))

{set print_extended_character_formula_naive(Param p, mat delta)=show(extended_character_formula_naive(p,delta))
set print_extended_character_formula(Param p, mat delta)=show(extended_character_formula(p,delta))
}



set null_ext_module (RealForm G,mat delta) = ExtParamPol:
let N=null_module(G) then
xi=G.distinguished_involution in
(xi,N,N,N,delta)

set null_ext_module (RealForm G) = ExtParamPol:
null_ext_module(G,G.distinguished_involution)

set find ([(int,int)] complete_indices,(int,int)pair) =int:
  first(#complete_indices,(int i)bool:complete_indices[i]=pair)

{ scale continuous part (|nu|) of extended parameter by rational factor |r| }
set * (ExtParam(ic,,,lambda,theta,,,,,):E,rat r) = ExtParam:
  E.gamma := ((1+theta)*(lambda+rho(ic))+(1-theta)*(E.nu*r))/2 ; E

{restrict doubly extended ParamPol to <G,delta>}
set left_restrict(ExtParamPol E)=ZExtParamPol:
let (xi,P,Q,R,delta)=E in
(s_to_1(one_plus_twist(P,xi)),
s_to_1(one_plus_twist(Q,xi)),
s_to_1(one_plus_twist(R,xi)),delta)

{restrict doubly extended ParamPol to <xi,G>}
set right_restrict(ExtParamPol E)=ParamPol:
{let (xi,P,Q,R,delta)=E in one_plus_twist(P+Q+R,delta)}
let (xi,P,Q,R,delta)=E in symmetrize(P+s*Q+R,delta)

set right_restrict(ZExtParamPol E)=ParamPol:
right_restrict(ext_param_pol(E))

{E = ZExtParamPol <-> virtual character of G^delta
     restrict to the non-identity component
     E=(P,Q,R,delta)=(\sum a_i p_i, \sum b_i p_i, \sum c_j q_j,delta)
      <-> \sum a_i p_i_+ + \sum  b_i p_i_- + \sum c_j ind(q_k)
      maps to P-Q:
        p_i_\pm have opposite value on delta, and ind(q_k) vanishes on Gdelta
}
set twisted_character(ZExtParamPol (P,Q,R,))=ParamPol:P-Q

set change_nu (Param p, rat factor, int type) = ExtParamPol:
  let G=real_form(p)
  then delta=G.distinguished_involution
  , N=null_module(G), rv=null_ext_module(G)
  in
  if type=0
  then
     let q=normal(p*factor)
 {although p is not delta-fixed, it may be when nu is varied, this
  is always the case if factor=0
  then replace (N,N,q) with (q,q,N)}
  in if is_fixed(q,delta) then rv:=(delta,q,q,N,delta) else rv:=(delta,N,N,q,delta) fi
  else
     let P=finalize_extended(p*factor,delta)
  in for c@q in P
     do let (a,b)=%c in
        if type=1 then  rv+:=(delta,a*q,b*q,N,delta)  else rv+:=(delta,b*q,a*q,N,delta) fi
     od
  fi; rv

set convert_to_ext_param_pol(ParamPol P,mat delta)=ExtParamPol:
let xi=P.real_form.distinguished_involution then
plus=null_module(P.real_form) then
minus=null_module(P.real_form) then
ind=null_module(P.real_form) then
()=for c@p in P do
 if is_fixed(p,delta) then
  plus+:=int_part(c)*p;
  minus+:=s_part(c)*p
 else
  ind +:=c*p
 fi
od in
(xi,plus,minus,ind,delta)

{xi=distinguished involution of inner class, delta=twist}
set deform(Param p, mat delta, int type) = ExtParamPol:
(  let !N=assert(is_valid_type(p,delta,type),"type is not valid");null_module(p) in
{ if type=0 then we're getting sums of terms of the form
  (1-s)*(I(p,+)+I(p,-)); when passing to the Hermitian form this
  becomes (1-s)(1+s)I(p)_h=0, so can ignore these
  but for completeness sake leave them in. So we don't do:
  if type=0 then return null_ext_module(real_form(p));
  instead: return deform(p) [CHECK IF THIS IS CORRECT]
}
{if =type then convert_to_ext_param_pol(deform(p),delta)}
if false then convert_to_ext_param_pol(deform(p),delta)
else
  let (B,index)=singular_block(p)
  then (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta)
  then complete_indices=complete_indices(B,delta)
  then complete_index=find(complete_indices,(index,type))
  then nB=complete_index+1, length=length(p)
  {  then P_mat=
     top_left_square_block
      (calculate_big_P_signed_polynomials_at_minus_one(B,delta,index),nB) }
   then (,polys)=big_KL_P_signed_polynomials_at_minus_one(p,delta)
   then P_mat =
     top_left_square_block(polys,nB)
{garbled?:  then P_mat=
     top_left_square_block
      (calculate_big_P_signed_polynomials_at_minus_one(B,delta,index),nB)
  then polys=big_KL_P_signed_polynomials_at_minus_one(p,delta) then
  P_mat =
    top_left_square_block(P_mat(B,delta),nB)}
  then remainder=null(complete_index)#1 then
  solution=null(nB)
  , !opposite_parity=1-length%2 { opposite to that of |length(p)| }
  , !on_p =  orientation_nr(p)
  in for q_ind : nB
    ~do let (ordinary_index_q,)=complete_indices[q_ind]
        then q=B[ordinary_index_q], contrib=remainder[q_ind]*P_mat[q_ind]
     in remainder -:= contrib
     ;  if length(q)%2=opposite_parity then solution +:=contrib fi
     od
;  null_ext_module(real_form(p),delta)+
 for f@i in solution
 do let (ordinary_index_q,epsilon_q)=complete_indices[i]
    then onr=minus_1^half(on_p-orientation_nr(B[ordinary_index_q]))
    then term=(1-s)*onr*f*B[ordinary_index_q]
    in
    if epsilon_q=1 then (p.xi,term,N,N,delta)
    elif epsilon_q=minus_1 then (p.xi,N,term,N,delta)
    else (p.xi,N,N,term,delta)
    fi
  od
fi
)
set deform(Param p, mat delta) = ExtParamPol:deform(p,delta,choose_type(p,delta))

set recursive_deform (Param p, mat delta, int type_p) = ExtParamPol:
assert(is_valid_type(p,delta,type_p),"(p,delta,type_p) is not valid");
let G=assert(is_valid_type(p,delta,type_p),"(p,delta,type_p) is not valid");real_form(p)
then empty=null_ext_module(G,delta), N=null_module(G)
in if recursive_deform_verbose { choose verbose or non-verbose version of the function }
then
   rec_fun full_def (Split sc,Param p, int type) ExtParamPol:
      begin
	 prints("executing rec_fun with p=",p, " type=", type);
	 assert(is_standard(p)
	       ,"non standard parameter encountered in deformation");
	 let acc=empty in
	 prints("acc defined", "  sc=", sc, " p=", p, " type=", type)
      ;  let at_nu0=ExtParamPol: sc*change_nu(p,0,type) in
	 for factor in reducibility_points(p)
	~do let (pf,flipped) = { next deformation }
	       if is_fixed(p,delta)
	       then scale_extended(p,delta,factor)
	       else (p*factor,false)
	       fi
	    then def=deform(pf,delta,type)
	 in if flipped { flip signatures in this rare case }
	    then prints("flipped p=", p); def := s*def
	    fi
{        ; prints("adding deformation term: p=", pf, new_line,"adding:", def) }
	 ;  acc +:= def
	 od
      ;  for (k,q,type) in %acc do at_nu0 +:= full_def(sc*k,q,type) od
      ; prints("at_nu0 is now: ");display(at_nu0); at_nu0
      end
   else
      rec_fun full_def (Split sc,Param p, int type) ExtParamPol:
      begin
         assert(is_standard(p)
               ,"non standard parameter encountered in deformation");
         let acc=empty, at_nu0=ExtParamPol: sc*change_nu(p,0,type) in
         for factor in reducibility_points(p)
        ~do let (pf,flipped) =  { next deformation }
               if is_fixed(p,delta)
               then scale_extended(p,delta,factor)
               else (p*factor,false)
               fi
            then def = deform(pf,delta,type)
         in if flipped { flip signatures in this rare case }
            then prints("flipped p=",p); def := s*def
            fi
{        ; prints("adding deformation term: p=", pf, new_line,"adding:", def) }
         ; acc +:= def
         od
      ;  for (k,q,type_q) in %acc
         do { prints("full_def:",q); } at_nu0 +:= full_def(sc*k,q,type_q)
         od
      ;  at_nu0
      end
   fi  (Split:1,p,type_p)

set full_deform(Param p, mat delta, int type_p) =ExtParamPol: recursive_deform(p,delta,type_p)
set full_deform(Param p, mat delta) =ExtParamPol: recursive_deform(p,delta,choose_type(p,delta))
