<basic.at
<lattice.at { added functions, function in_lattice@(mat,mat) }
<parameters.at { for parameter(x,y,gamma), square, square_is_central }
<Weylgroup.at  { for make_dominant_using_roots }

{ canonical_g(x) returns a dominant regular element g such that e(g)=x^2
  This only depends on the real_form(x), in fact only on its square class
  the implementation depends on base_grading_vector(G) being dominant.
  An alternative that does not depend on that (recently ensured) circumstance:
  canonical_g(RealForm G)= ratvec: shift_g_regular(G,square(G))
}
set canonical_g (RealForm G) = ratvec: base_grading_vector(G)+rho_check(G)
set canonical_g (KGBElt x) = ratvec: canonical_g(real_form(x))
set canonical_g (Param p)  = ratvec: canonical_g(real_form(p))

{ some variants of Cayley transforms }

{ use vector-based cross/Cayley when possible, obviates inv_Cayley }
forget cross@(int,Param)
forget Cayley@(int,Param)
forget inv_Cayley@(int,Param)

set cross (int s,Param p) = Param:
  let alpha = simple_roots(
    integrality_datum(real_form(p),infinitesimal_character(p)))
  in cross(alpha[s],p)

set Cayley (int s,Param p) = Param:
  let alpha = simple_roots(
    integrality_datum(real_form(p),infinitesimal_character(p)))
  in Cayley(alpha[s],p)
set inv_Cayley = Cayley@(int,Param) { leave this defined for other scripts }

{ Cayley transform as a set (actually an array, but order doesn't matter) }
set Cayley_set (int j,Param p) = [Param]:
  let q=Cayley(j,p) in
  if status(j,p)%5=2 { r1 or i2 } then [q,cross(j,q)] else [q] fi

{ doubly iterated Cayley }
set Cayley_set (int j, int k, Param p) = [Param]:
  ## for q in Cayley_set(k,p) do Cayley_set(j,q) od

{ uniform syntax for single or iterated Cayley }
set Cayley_set ([int] kappa, Param p) = [Param]:
  if #kappa=1 then Cayley_set(kappa[0],p)
  elif #kappa=2 then Cayley_set(kappa[0],kappa[1],p)
  else error("iterated Cayley only defined for 1 or 2 steps")
  fi

{ action of delta on KGB for general distinguished delta
  if delta=distinguished_involution(real_form(x)) then twist(delta,x)=twist(x)
}
set twist (mat delta,KGBElt x) = KGBElt:
  KGB_elt(real_form(x),delta*involution(x)*delta,torus_factor(x)*delta)

set twist (mat delta,Param p)=
  let (x,lambda_rho,gamma) = %p
  in parameter(twist(delta,x),delta*(lambda_rho+rho(real_form(x))),delta*gamma)

set is_fixed (mat delta, Param p) = bool:
{ let ()=prints("is_fixed p:", p) in } p=twist(delta,p)

set is_fixed (ratvec gamma, mat delta, KGBElt x,KGBElt y) = bool:
  is_fixed(delta,parameter(x,y,gamma))

{ whether KGBElt (pair) is fixed by twist by matrix delta }
set is_fixed (mat delta, KGBElt x) = bool: x=twist(delta,x)
set is_fixed (mat delta, KGBElt x, KGBElt y) = bool:
  is_fixed(delta,x) and is_fixed(^delta,y)

{ Stuff related to KGB }
{ x_rep:(v,theta) represents KGB element x is by xi=e(v)\sigma_w\xi_0
  where e(v)=exp(2i\pi v) for v in X_*\otimes Q, and \theta = w\circ\theta_0
  in atlas: torus_factor(x)=2*v-rho_check(G) (NB: v is multiplied by 2)
  Jeff prefers to work with the "actual torus factor" v
}

: x_rep = (ratvec,mat) { represent x component by v (as above) and theta }

{ in_A@x_rep: test if e(v) is in A:=(H^{-theta})^0 (validity test)
  concretely: whether rational vector (1+theta)v lies in lattice (1+theta)X_*
}
set in_A (x_rep(v,theta)) = bool: let M=1+theta in in_lattice(M,M*v)

{ e(v_1)theta_1 is H-conjugate to e(v_2)theta_2
  implicit: e(v_i)theta_i=e(v_i)sigma_i*xi_0 (i=1,2) in same extended group
  for G
  test: theta_1=theta_2, e(v_1-v_2) is in A=(H^{\theta_1})^0
}
set is_equivalent (x_rep(v_1,theta_1),x_rep(v_2,theta_2)) = bool:
  theta_1=theta_2 and in_A(v_1-v_2,theta_1)

set square_is_central (InnerClass ic,x_rep(v,theta)) = bool:
  square_is_central(ic,theta,v) { use the function defined in parameters.at }


: ExtParam =
  ( InnerClass ic, mat delta
  , ratvec gamma, vec lambda_rho, mat theta
  , ratvec g, vec l, mat omega
  , vec tau, vec t
  )

set root_datum (ExtParam E) = RootDatum: root_datum(E.ic)
set rho        (ExtParam E) = ratvec: rho(E.root_datum)
set rho_check  (ExtParam E) = ratvec: rho_check(E.root_datum)

set dual_parameter (ExtParam
      (ic, delta, gamma, lambda, theta, g, l, omega, tau,t)) = ExtParam:
  (dual(ic),^delta,g,l,omega,gamma,lambda,theta,t,tau)

{ in PFTR: z=i^<tau,(delta_0-1)l>(-1)^<lambda,t>
  PFTR:delta_0 is ^delta here
}
set log_z (mat delta, vec lambda_rho, vec l, vec tau,vec t) = rat: { modulo 1 }
  (l*(delta-1)*tau/2+t*lambda_rho)/2 % 1
set log_zeta (mat delta, vec lambda, vec l,vec tau,vec t) = rat: { modulo 1 }
  (t*(delta-1)*lambda/2+l*tau)/2 % 1

set log_z (ExtParam E) = rat:
  log_z(E.delta,E.lambda_rho,E.l,E.tau,E.t)
set log_zeta (ExtParam E) = rat:
  log_zeta(E.delta,E.lambda_rho,E.l,E.tau,E.t)

{ compute x,y, the one-sided parameters of an extended parameter }

set x (ExtParam E) = KGBElt:
  KGB_elt(E.ic, E.theta, E.g-E.rho_check-E.l)

set y (ExtParam E) = KGBElt: { assumes integral |E.gamma| }
  KGB_elt(dual(E.ic),E.omega,E.gamma-E.lambda_rho-E.rho)

{ recover ordinary Param value from ExtParam; could be defined as
  set parameter (ExtParam E) = Param: parameter(x(E),y(E),E.gamma)

  actually this is better: use |(E.x,E.lambda,E.gamma)|
}
set parameter (ExtParam E) = Param: param(E.x,E.lambda_rho,E.gamma)

set integrality_datum (ExtParam E) = RootDatum:
  integrality_datum(E.ic,E.gamma)

{ assume gamma(E) is integrally dominant
  translate by sum of roots to make it dominant
  return (new extended parameter, sum of roots)
  see nonintegral.at
  *** should not need this any more, now that gamma is allowed to be
      integrally dominant
  However, since not all functions allow that, it is still needed
}
set translate_to_dominant (ExtParam
    (ic,delta,gamma,lambda_rho,theta,g,l,omega,tau,t):E) = (ExtParam,vec):
  let (new_gamma,shift) = make_dominant_using_roots(root_datum(E),gamma)
  in
   ((ic,delta, gamma+shift,lambda_rho+shift,theta, g,l,omega, tau,t) , shift)

{ for debugging:
  test that an extended parameter satisfies the defining conditions
}
set valid (
    ExtParam(ic,delta,gamma,lambda_rho,theta,g,l,omega,tau,t)) = bool:
begin let OK=false { pessimist: avoids having to set this in many branches } in
  if not square_is_central(ic,theta,(g-l-rho_check(ic)))
  then prints("xi^2 is not central")
  elif delta*gamma!=gamma then prints("gamma is not delta-fixed")
  elif g*delta!=g then prints("g is not ^delta-fixed")
  elif delta*theta!=theta*delta then prints("involution is not fixed by delta")
  elif omega!=-^theta then prints("Cartan involutions are not compatible")
  elif !=(g-l-rho_check(ic))*(1-theta)
  then prints("(1-^theta)g\ne (1-^theta)(l+rho^v)")
  elif !=(gamma-lambda_rho-rho(ic))*(1-omega)
  then prints("(1-^omega)gamma\ne (1-^omega)(lambda_rho+rho)")
  elif -l*(1-delta)!=t*(1+theta) then prints("(^delta-1)l\ne (1+^theta)t")
  elif -(1-delta)*lambda_rho!=(1-theta)*tau { recall that -theta=^omega }
  then prints("(delta-1)lambda_rho\ne (1+^omega)tau")
  else OK:=true
  fi
; OK
end

{ select delta-fixed elements from B }
set fixed (mat delta, [Param] B) = [Param]: { filter delta-fixed elements }
  ## for p in B do if is_fixed(delta,p) then [p] else [] fi od

{ select delta-fixed elements from block_of(p) }
set fixed_block_of (mat delta, Param p) = [Param]: fixed(delta,block_of(p))

set fixed_block (mat delta, Param p) = ([Param],int):
  let b=fixed(delta,block_of(p)) in (b,find(b,p))

set format (ExtParam E) = string:
  to_string ( "         x=", E.x
  , new_line, "     gamma=", E.gamma
  , new_line, "         g=", E.g
  , new_line
  , new_line, "lambda_rho=", E.lambda_rho
  , new_line, "       tau=", E.tau
  , new_line, "         l=", E.l
  , new_line, "         t=", E.t
  )

set short_format (ExtParam E) = string: to_string(
    "lambda_rho =",E.lambda_rho,", tau=", E.tau ,", l=", E.l, ", t=", E.t, ".")
set long_format (ExtParam E) = string: to_string(
"gamma=", E.gamma,", g=", E.g,", lambda_rho =",E.lambda_rho,", tau=", E.tau ,", l=", E.l, ", t=", E.t)

set display (ExtParam E) = void: prints(format(E))
set display_one_line (ExtParam E) = void: prints(short_format(E))
