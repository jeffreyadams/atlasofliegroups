<basic.at
<W_orbit.at { for |W_parabolic_iterator_with_action| }
<W_classes.at { for |character_value@(WeylCLassTable.[int],WeylElt)| }
<Weylgroup.at { for |order_W| }
<W_reps.at { for type |W_rep| }
<lattice.at { for |restrict_action| }

{ ------------ projection on isotypic subspace  ----------- }

{ scalar multiple of projection of representation space of |ops| on isotoypic
  subspace defined by character |chi| of an irreducible representation

  When |chi| is an irreducible character of $W$, and |tab| is the class table of
  $W$, the call |projector(tab,rep,chi)| for a $W$ representation given by |rep|
  computes a matrix describing a scalar multiple of the projection of the space
  $V$ on which |rep| acts to its isotypic subspace for |chi|, via the formula

		       $$ \sum_{w\in W}\chi(w)\rho(w), $$

  where $\rho(w)$ is the action in |rep| of |w|. The menioned scalar multiple
  is $|W|/\dim(\chi)$, as can be seen by taking $\rho$ to be the irredudible
  corresponding to $\chi$ itself, and computing the trace |W| of the above sum.

  If an irreducible character |chi| is not a constituent of the
  representation defined by |ops|, this gives the null matrix; then since
  the result depends linearly on |chi|, we can even use this when that
  character is reducible, but has a unique irreducible constituent in common
  with |ops|, giving (a multiple of) the projection for that isotypic subspace
}
set projector (WeylClassTable tab, W_rep(dim,ops), [int] chi) = mat:
   let rd=tab.root_datum
   then (get,incr) = Iterator<(WeylElt,mat)>: { to sum action over $W$ }
      W_parabolic_iterator_with_action(rd,all_simples(rd),dim,ops)
   , Q=null(dim,dim)
in while
      case get()
      | none: dont
      | some(w,action): do
        Q +:= character_value(tab,chi,w)*action; incr()
      esac
   od; Q

{ this used to be:
  for (w,action) in W_parabolic_with_action(rd,all_simples(rd),dim,ops)
  do Q+:=character_value(tab,w,chi)*action
  od; Q
}

{ restrict representation |pi| to isotypic subspace for |chi }
set restrict_representation_isotypic \
   (WeylClassTable Wct, W_rep pi, vec chi) = W_rep:
  let (basis,factors) = projector(Wct,pi,chi).adapted_basis
  { operators have integral matrices w.r.t. |basis|, so restriction is OK }
  then P=basis[:#factors] { saturated lattice basis of image of the projector }
  in (#P ,for T in pi.operators do restrict_action(T,P) od)

{ projector for a cell representation }
set projector (WeylClassTable Wct, WCell cell, vec chi) = mat:
  projector(Wct,cell_representation(Wct,cell),chi)

{ given a cell, compute the cell representation pi, find the smallest k so that
  <pi,sym^k(reflection)>!=0, then this inner product is 1, and the unique
  irreducible in common is special; use the character of sym^k(reflection)
  to compute the projection operator onto the special
}
set special_projector (WeylClassTable Wct, WCell cell) = mat:
  let cell_rep = cell_representation(Wct,cell)
  then char = Wct.sym_power_refl(smallest_degree(Wct,character(Wct,cell_rep)))
  in projector(Wct,cell_rep,char)

{ given a cell, compute the special_projector, and use this to construct
  the special representation itself
}
set special_representation_of_cell (WeylClassTable Wct, WCell cell) = W_rep:
  let cell_rep = cell_representation(Wct,cell)
  then char = Wct.sym_power_refl(smallest_degree(Wct,character(Wct,cell_rep)))
  in restrict_representation_isotypic(Wct,cell_rep,char)

{special_projectors for a list of cells}
set special_projectors (WeylClassTable Wct, [WCell] cells) = [mat]:
  for cell in cells do special_projector(Wct,cell) od

{test v, w same up to rational multiple}
set is_rational_multiple (vec v,vec w) = bool: rank(mat:[v,w])<2

{ given list of nonzero vectors return [[int]]
  where each [int] is the indices of the vectors
  which are the same up to multiple
  example: [[1,2],[2,3],[2,4]] -> [[0,2],[1]]}
set group_vectors_up_to_scalar ([vec] list) = [[int]]:
  let result=[[int]]: [], reps=[vec]: [] in
   for v@i in list
   do assert(@:v.!=,"Cell member projects to 0: "+i);
      let j=first(#reps,(int k)bool: is_rational_multiple(reps[k],v)) in
      if j.< then result #:= [i]; reps#:=v else result[j] #:= i fi
   od; result

{ given a cell, compute the projector onto the special representation
  Then cell vertices give the same primitive ideal iff they map to scalar
  multiples of the same vector in the special representation, i.e. the two
  corresponding columns of the matrix are the same up to rational multiple
}
set group_parameters_by_primitive_ideal (WCell cell,mat projector) = [[int]]:
  let grouping=group_vectors_up_to_scalar([vec]:projector{matrix columns})
  , parameters=cell.labels
  in for v in grouping do for w in v do parameters[w] od od

{ nice output of primitive ideal information for a cell }
set print_primitive_ideal_info ([WCell] cells,[mat] projectors) = void:
  let data=
     for cell@i in cells
     do let P=projectors[i] then g=group_parameters_by_primitive_ideal(cell,P)
     in [i.to_string,(#P).to_string,(#g).to_string,g.to_string]
     od
  in prints("Each line has 4 terms:",new_line
           ,"# of cell",new_line,"size of cell", new_line
           , "dimension of special representation of cell",new_line
           , "grouping of parameters in cell by primitive ideal");
     tabulate(data, "llll",2," ")

{ variant function of previous (distinguished by ignored final string argument),
  better suited to large cells
}
set print_primitive_ideal_info ([WCell] cells,[mat] projectors,string .) = void:
  for cell@i in cells
  do let P=projectors[i] then g=group_parameters_by_primitive_ideal(cell,P) in
    prints(new_line,"#",i,new_line, "size of cell: ", #P, new_line
          , "dimension of special: ", #g)
  ; for a in g do prints(a) od
  od
