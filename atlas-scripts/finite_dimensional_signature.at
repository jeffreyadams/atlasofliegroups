<K_types.at  {K_signature_irr}
<weyl_character_formula.at

{some functions related to Frobenius-Schur indicator,
real/quaternionic indicator, and sign of Hermitian form
on finite dimensional representation}

set verbose_fdsig=true

{assuming a rational is an integer, replace it with a string,
to allow output of integers up to 2^63-1}
set long_rat_as_integer_string(rat r)=
assert(denom(r)=1,"r is not an integer");to_string(r)[:2~] {cut off /1}

set is_self_dual(Param p)=bool:
let lambda=highest_weight_finite_dimensional(fd_only(p)) in
-act(w_long(root_datum(p)),lambda)=lambda

set Frobenius_Schur(Param p)=int:
if is_self_dual(fd_only(p)) then
let lambda=highest_weight_finite_dimensional(p) in
(-1)^(rat_as_int(2*lambda*rho_check(real_form(p)))) else 0 fi

set fs(Param p)=int:Frobenius_Schur(fd_only(p))

set is_self_conjugate(Param p)=bool:
let lambda=highest_weight_finite_dimensional(fd_only(p)) in
let G=real_form(p) in
-distinguished_involution(G)*act(w_long(G),lambda)=lambda

set real_quaternionic(Param p)=int:
if is_self_conjugate(fd_only(p)) then
let lambda=highest_weight_finite_dimensional(p) then
x_squared=square(x(p)) in (-1)^(rat_as_int(2*x_squared*lambda*fs(p))) else 0 fi

set rq(Param p)=int:real_quaternionic(fd_only(p))

{signature and index are, by default, (rat,rat) to allow up to 2^63-1
 signature_int and index_int give (int,int), but may lose information
 for output use signature_string and index_string which can output up to
 2^63-1 = 9223372036854775807
}

{.signature (p,q) of Hermitian form on a finite dimensional representation.}
set signature(Param p)=(rat,rat):
let G=real_form(fd_only(p)) then
height=rat_as_int(2*infinitesimal_character(p)*rho_check(G))  then
(pos,neg)=K_signature_irr(p,height) in
(  sum(for c@p in pos do split_as_int(c)*dimension_rat(K_type(p)) od),
sum(for c@p in neg do split_as_int(c)*dimension_rat(K_type(p)) od))

{.signature as a string.}
set signature_string(Param p)=string:
if not is_hermitian(fd_only(p)) then "*" else
let (pos,neg)=signature(p)  {type (rat,rat)}
in "(" + long_rat_as_integer_string(pos) + "," + long_rat_as_integer_string(neg) + ")" fi

{. index min(p,q) of Hermitian form on a finite dimensional representation.}
set index(Param p)=rat:let (pos,neg)=signature(p) in if pos<=neg then pos else neg fi

set index_string(Param p)=string:
if not is_hermitian(fd_only(p)) then "*" else long_rat_as_integer_string(index(p)) fi

set anisotropic_part(Param p)=rat: let (pos,neg)=signature(p) in abs(pos-neg)

set anisotropic_part_string(Param p)=
if not is_hermitian(fd_only(p)) then "*" else long_rat_as_integer_string(anisotropic_part(p)) fi

{report using direct computation of Hermitian form}
set fd_report(RealForm G, int k)=void:
if verbose_fdsig then
prints(new_line,"fund wt: highest weight in fundamental weight coordinates",
new_line,"lambda: highest weight in X^* coordinates",
new_line,"dim: dimension",
new_line,"FS: Frobenius-Schur indicator: 1:orthogonal, -1: symplectic, 0: not self-dual",
new_line,"RQ: Real-Quaternionic indicator: 1:real, -1: quaternionic, 0: not self-conjugate",
new_line,"signature:  signature (p,q) of Hermitian form (if Hermitian)",
new_line,"index: index min(p,q) of Hermitian form (if Hermitian)",
new_line,"aniso: dimension |p-q| of anisotropic part of Hermitian form (if Hermitian)",
new_line,"computing directly from the Hermitian form") fi;
let weights=box(k+1, ss_rank(G)) then  {all [a_1,...,a_rank] with 0\le a_i\le k}
M=ratvecs_as_ratmat(fundamental_weights(G)) in
for mu in weights do
 let lambda=M*mu in
  if is_integer(lambda) then
  let p=finite_dimensional(G,ratvec_as_vec(lambda))
in
prints("fund wt: ", mu, "  lambda:", lambda, " dim:", dimension(p), "   FS/RQ: ", fs(p), "/", rq(p), "  signature: ", signature_string(p), "  index: ", index_string(p), "  aniso: ", anisotropic_part_string(p)) fi od

{-------------------------------------------------------------------------}

{alternative (faster) computation of signature and index, in equal
rank case, using Weyl character formula,
evaluated at strong real form (equal rank case only)
}

set signature_wcf(Param p)=(rat,rat):
let G=real_form(p) then
v=(torus_factor(KGB(G,0))+rho_check(G))/2 then
(,diff)=wcf_strong_real(fd_only(p),v) then  {special version of wcf}
dim=dimension_rat(fd_only(p)) in
((dim+diff)/2, (dim-diff)/2)

set index_wcf(Param p)=rat:
let (pos,neg)=signature_wcf(p) in if pos<=neg then pos else neg fi

{.signature as a string.}
set signature_wcf_string(Param p)=string:
if not is_hermitian(fd_only(p)) then "*" else
let (pos,neg)=signature_wcf(p)  in
"(" + long_rat_as_integer_string(pos) + "," + long_rat_as_integer_string(neg) + ")"  fi

set index_wcf_string(Param p)=string:
if not is_hermitian(fd_only(p)) then "*" else long_rat_as_integer_string(index_wcf(p)) fi

set anisotropic_part_wcf(Param p)=rat: let (pos,neg)=signature_wcf(p) in abs(pos-neg)

set anisotropic_part_wcf_string(Param p)=
if not is_hermitian(fd_only(p)) then "*" else long_rat_as_integer_string(anisotropic_part_wcf(p)) fi


{report using computation of Hermitian form via the Weyl character formula}
{report using direct computation of Hermitian form}
set fd_report_wcf(RealForm G, int k)=void:
assert(is_equal_rank(G),"G is not equal rank");
if verbose_fdsig then
prints(new_line,"fund wt: highest weight in fundamental weight coordinates",
new_line,"lambda: highest weight in X^* coordinates",
new_line,"dim: dimension",
new_line,"FS: Frobenius-Schur indicator: 1:orthogonal, -1: symplectic, 0: not self-dual",
new_line,"RQ: Real-Quaternionic indicator: 1:real, -1: quaternionic, 0: not self-conjugate",
new_line,"signature:  signature (p,q) of Hermitian form (if Hermitian)",
new_line,"index: index min(p,q) of Hermitian form (if Hermitian)",
new_line,"aniso: dimension |p-q| of anisotropic part of Hermitian form (if Hermitian)",
new_line,"computing using the Weyl character formula") fi;
let weights=box(k+1, ss_rank(G)) then  {all [a_1,...,a_rank] with 0\le a_i\le k}
M=ratvecs_as_ratmat(fundamental_weights(G)) in
for mu in weights do
 let lambda=M*mu in
  if is_integer(lambda) then
  let p=finite_dimensional(G,ratvec_as_vec(lambda)) in
prints("fund wt: ", mu, "  lambda:", lambda, " dim:", long_rat_as_integer_string(dimension_rat(p)), "   FS/RQ: ", fs(p), "/", rq(p), "  signature: ", signature_wcf_string(p), "  index: ", index_wcf_string(p), "  aniso: ", anisotropic_part_wcf_string(p)) fi od

set wcf_report(RootDatum rd, ratvec v, int k)=void:
let weights=box(k+1, ss_rank(rd)) then  {all [a_1,...,a_rank] with 0\le a_i\le k}
M=ratvecs_as_ratmat(fundamental_weights(rd)) in
for mu in weights do
 let lambda=M*mu in
  if is_integer(lambda) then
  let p=finite_dimensional(split_form(rd),ratvec_as_vec(lambda)) in
  prints("fund wt: ", mu, "  lambda:", lambda, " dim:", dimension(p)
        ,"   self-dual: ",is_self_dual(p), " FS: ", fs(p)
        ,"   trace(x): ",wcf_strong_real(rd,lambda,v)) fi od

{detailed information about K-signature of finite dimensional
 also see print_K_types:print_K_signature_irr (defined for any p)}

set show_signature(Param p)=
let G=real_form(fd_only(p)) then
height=rat_as_int(2*infinitesimal_character(p)*rho_check(G))  then
(pos,neg)=K_signature_irr(p,height) then
(dim_pos,dim_neg)=(0,0) in
prints("positive part:");
for c@p in pos do
  let hw=highest_weights(p,KGB(G,0))[0] in
     dim_pos+:=split_as_int(c)*dimension(hw);prints("  ", split_as_int(c), " ", p, " ", hw, " ", dimension(hw), " ", split_as_int(c)*dimension(hw)) od;
prints("negative part:");
for c@p in neg do
  let hw=highest_weights(p,KGB(G,0))[0] in
     dim_neg+:=split_as_int(c)*dimension(hw);prints("  ", split_as_int(c), " ", p, " ", hw, " ", dimension(hw), " ", split_as_int(c)*dimension(hw)) od;
prints( "signature: (" + dim_pos +"," + dim_neg + ")");()

