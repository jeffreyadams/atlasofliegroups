<basic.at
<combinatorics.at

set size = sum@Partition

set hook_length (Partition P, int i, int j) =int:
  let arm = P[i]-j, leg = transpose(P)[j]-i in arm + leg -1

set dim_rep (Partition P) = int:
  let dim=fac(size(P)) in
  for i:#P do for j:P[i] do dim \:= hook_length(P,i,j) od od; dim

{ all weak compositions of numbers <=limit into n parts }
set rec_fun compositions_le (int limit, int n) = [[int]]:
  if =n then [[]] { one empty composition (0 parts) }
  else
    for last:limit+1
      for rest in compositions_le(limit-last,n-1) do rest#last od
    od
  fi

{ towards partition functions }


{ Given a set |S| of positive numbers and a maximum |m|, find all sums |s| of
  multisets on |S| such that |m-s| is also the sum of a multiset on |S|. This
  function could help to speed up (by precomputing the intermediate levels that
  can contribute to terms at level |m|) partition function calculations, in
  cases where the generating vectors have levels (represented in |S|) are wide
  apart. Not so for the Kostant partition function, since here the simple roots
  have level 1 so that all intermediate levels contribute to the result.
}
set inter_sums ([int] S, int m) = int{as bitset}:
(  assert(@:>=m and all(for s in S do >s od),"Positivity fails")
;  let multi_add (int a, int{as bitset} S, int m) = int{as bitset}:
   { close set |S| of integers under operation of adding |a|, up to limit |m| }
      let image = S, mult=[a].to_bitset, mask = full_bitset(m+1)
      in { repeatedly shift |image| of |S|, accumulating into |result| }
	 while !=(image:=AND(image*mult,mask)) do S:=OR(S,image) od
      ;  S

   , result=1 { interpreted as |[0].to_bitset| }
in for s in S do result:=multi_add(s,result,m) od
;  let rev = for r in result.set_bit_positions do m-r od.to_bitset
in AND(result,rev)
)

{ In what follows, |ParamPol| values are over an appropriate compact torus
  This makes them function as polynomials with exponents in $\Z^n$
}

set const_poly (int c, int n) = ParamPol:
  let G=compact_torus(n), zero=null(n)
  in null_module(G)+(Split:c,param(KGB(G,0),zero,zero))

set poly_multiple (ParamPol P, vec e) = ParamPol: { |P*X^e| }
   P.null_module + for c@p in P do let (x,l,nu)=%p in (c,param(x,l+e,nu)) od

set monomial (vec v) = Param: { $X^v$ }
   let n=#v then G=compact_torus(n),zero=null(n) in param(KGB(G,0),v,zero)

{ multiply |P| by the sum of the monomials for |exponents| }
set poly_multiple (ParamPol P, [vec] exponents) = ParamPol:
   P.null_module +
   for e in exponents do
      for c@p in P do let (x,l,nu)=%p in (c,param(x,l+e,nu)) od
   od.##

set_type power_series = [ParamPol] { level-sorted initial part of power series }

{ divide truncated power series |S| by |1-X^v|, with |v| of positive level |l| }
set divide (power_series S, vec v, int l) = power_series:
   for k:#S-l from l do S[k]+:=poly_multiple(S[k-l],v) od; S

{ same as the above, but only compute terms at levels |degs|, for efficiency }
set divide (power_series S, vec v, int l, int{as bitset} degs) = power_series:
   for k:#S-l from l
   do if is_member_bitset(k,degs)
      then S[k]+:=poly_multiple(S[k-l],v)
      fi
   od; S


{ simultaneously count nonnegative integer vector solutions |x| to |A*x=b| for
  all |b| with |f*b=level|, assuming that |f*A| is all positive and integer
}
set partition_count(mat A, ratvec f, int level) = ParamPol:
(  let fA=ratvec_as_vec(f*A), n=#f { |n=n_rows(A)| }
in assert(@:>fA,"Matrix not strictly positive for linear form")
;  let result = power_series: for i:level+1 do const_poly(#=i,n) od
in for col@j in A do result := divide(result,col,fA[j]) od; result~[0]
)

set partition_count_sparse(mat A, ratvec f, int level) = ParamPol:
(  let fA=ratvec_as_vec(f*A), n=#f { |n=n_rows(A)| }
   then degrees = inter_sums(fA,level)
in assert(@:>fA,"Matrix not strictly positive for linear form")
;  let result = power_series: for i:level+1 do const_poly(#=i,n) od
in for col@j in A do result := divide(result,col,fA[j],degrees) od; result~[0]
)

set Kostant_partition_function (RootDatum rd, vec v) = int:
   let f=rd.rho_check then (level,d)=%(f*v) in
   if d=1 and level>=0
   then partition_count(rd.posroots,f,level)[monomial(v)].split_as_int
   else 0
   fi
