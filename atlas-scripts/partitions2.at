<partitions.at

{generate partitions recursively}
{[a_1,...,a_n] ->
  [[a_1,...,a_n,1]] if a_{n-1}=a_n         if a_{n-1}=a_n
  [[a_1,...,a_n,1],[a_1,...,a_{n-1},a_n+1] otherwise
}
set add_one([int] P)=[[int]]:
if (#P>1 and P~[0]<P~[1]) or #P=1 then
[P#1,P~[0]+:=1;P] else [P#1] fi

{recursively compute partitions of n:
 [for each partition Q of n-1 do add_one(Q) od]
}
set par(int n)=
let rec_fun f(int n)=[[int]]:
  if n=0
     then [[int]]:[]
  elif n=1
     then [[int]]:[[1]]
  else
     for P in f(n-1) do add_one(P)  od.##
  fi in f(n)

{add single box to first column of P}
{brute force version}
set add_one_to_first_column(PaintedPartition P)=[PaintedPartition]:
for i:5 do if is_valid(P#[i]) then [P#[i]] else [] fi od.##

set add_one_to_last_row(PaintedPartition P)=[PaintedPartition]:
if #P=0
 then [ [[0]],[[1]],[[2]],[[3]],[[4]] ]
elif #P=1
 then
 for i:5 do let Q=[P[0]#i] in
   if is_valid(Q) then [Q] else [] fi od.##
elif #P~[0]<#P~[1]
 then
 for i:5 do let Q=P then ()=Q~[0]:=Q~[0]#i in if is_valid(Q) then [Q] else [] fi od.##
else
 []
fi

set painted_partitions(int n)=
let rec_fun f(int n)=[PaintedPartition]:
if n=0
 then [[]]
elif n=1 then
  [ [[0]],[[1]],[[2]],[[3]],[[4]] ]
else
 for P in f(n-1) do  add_one_to_first_column(P)##add_one_to_last_row(P) od.##
fi in f(n)

set left_valid_painted_partitions(int n,string label)=
for P in painted_partitions(n) do
 if is_valid_left(P,label) then [P] else [] fi od.##

set right_valid_painted_partitions(int n,string label)=
for P in painted_partitions(n) do
 if is_valid_right(P,label) then [P] else [] fi od.##

set painted_bipartitions(int left,int right, string label)=
let left=left_valid_painted_partitions(left,label) then
right=right_valid_painted_partitions(right,label) in
##for P in left do
 ##for Q in right do
  if is_valid(P,Q,label) then [(P,Q,label)] else [] fi od od

set painted_bipartitions(int n, string label)=
for i:n+1 do painted_bipartitions(i,n-i,label) od.##

