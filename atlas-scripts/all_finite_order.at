<basic.at
<groups.at
<sort.at
<synthetic.at
<affine.at
<W_orbit.at
<W_classes.at

{. The labels m_i on the Dynkin diagram representing the coefficient of the
   simple roots in the highest root. The label of the lowest root is 1 (not
   in the list of these labels). .}
{simple_root_labels@RootDatum is now defined in basic.at}

{ all nonnegative lists |L| of length |1+#limits| with |(limits#1)*L=0|, where
  each entry (except final one) does not exceed the corresponding |label| entry
}
set bounded_lists ([int] limits,[int] labels, int order) = [ [int] ]:
   for v in for n in limits do #(n+1) od.all_words
   do let extra=order-v*labels in
      if extra>=0
      do let w= v # extra in
	 if gcd(w)=1 do w fi
      fi.##
   od.##

set get_subsets_given_order(RootDatum rd, int order) = [ [int] ]:
   let labels=simple_root_labels(rd) in bounded_lists(labels,labels,order)

set get_subsets(RootDatum rd, int max_order) = [[ [int] ]]:
   let labels=simple_root_labels(rd)
in for order:max_order+1 do bounded_lists(labels,labels,order) od

set null(RootDatum rd)=([int],RootDatum,int):([],GL(1),0)

set get_raw_data(RootDatum rd,[[[int]]] S)=[[([int],RootDatum,int)]]:
   [null(rd)]#for order:#S-1 from 1 do
    let row=[([int],RootDatum,int)]:[] in
    for v_affine in S[order] do
       let v=co_usual_coordinates(rd,v_affine) in
       {v\in (X_*)_Q
        integrality_datum(rd,w): roots alpha such that h <w,alpha^v>\in Z (not what we want)
        integrality_datum(dual(rd),v): coroots alpha^v such that <v,alpha>\in Z (closer)
        dual(integrality_datum(dual(rd),v)): roots alpha such that <v,alpha>\in Z (what we want)}
       let rdi=dual(integrality_datum(dual(rd),v/order)) in
      row#:=(v_affine,rdi, dimension(rdi)) od ;row
   od

set mysort = ([([int],RootDatum,int)] -> [([int],RootDatum,int)]):
 sort_by(([int].,RootDatum.,int k) int:k)

set refine_raw_data([[([int],RootDatum,int)]] data)=[[([int],RootDatum,int)]]:for a in data do mysort(a) od

set get_data(RootDatum rd,[[[int]]] S)=[[([int],RootDatum,int)]]:refine_raw_data(get_raw_data(rd,S))

{main function}
set get_data(RootDatum rd,int n)=[[([int],RootDatum,int)]]:refine_raw_data(get_raw_data(rd,get_subsets(rd,n)))

set nice_classes(RootDatum rd, int n)=
 let data=get_data(rd,n) in
 for i:#data do
  let entries=data[i] then
  (v,rd,dim)=entries[0] in
   if #entries =1 then [(v,rd,dim)]
   else let (,,dim1)=entries[1] in if dim<dim1 then [(v,rd,dim)] else [] fi fi od

set info([[([int],RootDatum,int)]] data, int j)=void:
prints(new_line,"order=",j);
for (v,rdi,n) in data[j] do prints("Kac:", v, " ", Lie_type(rdi), " ", "  dim:",n) od

{don't include empty terms}
set info_reduced([[([int],RootDatum,int)]] data, int j)=void:
if #data[j]>0 then
prints(new_line,"order=",j);
for (v,rdi,n) in data[j] do prints("Kac:", v, " ", Lie_type(rdi), " ", "  dim:",n) od fi

set info([[([int],RootDatum,int)]] data, int j, int bound)=void:
prints(new_line,"order=",j);
for i:min(bound,#data[j]) do let (v,rdi,n)=data[j][i] in prints("Kac:", v, " ", Lie_type(rdi), " ", "  dim:",n) od

set cox(RootDatum rd,int n)=void:let v=rho(rd)/n then
rdi=integrality_datum(rd,v) in
prints(v, " ", Lie_type(rdi), " ", dimension(rdi))

set test([[([int],RootDatum,int)]] data, int n)=void:
let (,rd,)=data[0][0] in  cox(rd,n); info(data,n)
{
set find([[([int],RootDatum,int)]] data, int n)=void:
let (,rd,)=data[0][0] in
let labels=for i:rank(rd) do rat_as_int(highest_root(rd)*fundamental_coweights(rd)[i]) od in
for i:#data do for b in data[i] do let (v,rdi,k)=b in if k=n then prints(i, " ", v, " ", Lie_type(rdi), " ", v*labels, " ", k) fi od od

set find_short([[([int],RootDatum,int)]] data, int n)=void:
let (,rd,)=data[0][0] in
let labels=for i:rank(rd) do rat_as_int(highest_root(rd)*fundamental_coweights(rd)[i]) od in
for i:#data do for j: min(10,#(data[i]))  do let (v,rdi,k)=data[i][j] in if k=n then prints(i, " ", v, " ", Lie_type(rdi), " ", v*labels, " ", k) fi od od
}
set table([[([int],RootDatum,int)]] data)=void:
let n=#data in
prints("All conjugacy classes of E8 up to order", n);
prints("The elements of order m are parametrized by", new_line,
"their Kac diagrams",new_line,
"labels=[2,3,4,6,5,4,3,2;1] are the labels on the extended",new_line,
"Dynkin diagram (Bourbaki numbering)",new_line,
"    3",new_line,
"    |",new_line,
"2-4-6-5-4-3-2-1",new_line,
"Kac diagram: v=[a_1,...,a_8,a_0]",new_line,
"satisfying:",new_line,
"* the a_i are relatively prime",new_line,
"* v\dot labels=m",new_line,
new_line,
"The root system is the centralizer.",new_line,new_line,
"For example the Coxeter element is ",new_line,
"Kac:[1,1,1,1,1,1,1,1,1] Lie type 'T1.T1.T1.T1.T1.T1.T1.T1'   dim:0",new_line,
new_line,
"The elements of order 2 are:",new_line,
"order=2",new_line,
"Kac:[1,0,0,0,0,0,0,0,0] Lie type 'D8'   dim:56",new_line,
"Kac:[0,0,0,0,0,0,0,1,0] Lie type 'E7.A1'   dim:64",new_line);
prints("---------------------------------------------------");

for i:n-1 from 1 do info(data,i) od


set table([[([int],RootDatum,int)]] data,int bound)=void:
for i:#data-1 from 1 do info(data,i,bound) od

set table_reduced([[([int],RootDatum,int)]] data)=void:
for i:#data-1 from 1 do info_reduced(data,i) od

{. Given a positive integer m, (r+1)-tuples of integers a_i so that
   sum_i(a_i m_i)=m, with a_i's relatively prime. The last entry
   corresponds to the lowest root. These are essentially Kac diagrams. .}
set Kac_diags_given_order(RootDatum rd, int order)=[[int]]:
   let  labels = simple_root_labels(rd)
   then limits = for a in labels do floor(order/a) od
in bounded_lists(limits,labels,order)

set Kac_diags_up_to_order(RootDatum rd, int max_order)=[[[int]]]:
   let labels=simple_root_labels(rd)
in for order:max_order+1
   do bounded_lists(for a in labels do floor(order/a) od,labels,order)
   od


{. Given a Kac diagram, compute the corresponding element of the Lie algebra. .}
set Kac_x (RootDatum rd, vec v)=ratvec: let labels=simple_root_labels(rd)#1
   then r=semisimple_rank(rd),m=v*labels, fcw=fundamental_coweights(rd)
   then result=ratvec: for i:r do 0/1 od in
     for i:r do result+:=v[i]/m*fcw[i] od; result

{. Given a Kac diagram, compute the order of the corresponding element
   of G. .}
set order (RootDatum rd, vec v)=int: denom(Kac_x(rd,v))

{. List the Kac diagrams for the identity element of a complex group G
  (unique if G is simply connected). .}
set Kac_diags_of_identity (RootDatum rd)=[[int]]:
  let list=Kac_diags_given_order (rd,1) in
  for diag in list if order(rd,diag)=1 do diag fi od

{. List the elements in the fundamental domain for the affine Weyl Group
   that exponentiate to the identity element. .}
set identity_in_fund_domain (RootDatum rd)=[ratvec]:
  for diag in Kac_diags_of_identity (rd) do Kac_x(rd,diag) od

{. Given two ratvecs representing elements of T, decide whether they are
   conjugate in G. .}
set is_conjugate (ratvec v,ratvec w,RootDatum rd)=bool:
   let W=W(rd) in any(for x in W do is_integer(v*x-w) od)

set is_conjugate_Kac ([int] v,[int] w, RootDatum rd)=bool:
   let list=identity_in_fund_domain(rd) then
   Kac_x_w=Kac_x(rd,w) in
   any(for x in list
      do let (z,)=rd.affine_datum.affine_co_make_dominant(Kac_x(rd,v)+x) in z=Kac_x_w od)

{. crude listing. }
set Kac_classes_given_order_crude = Kac_diags_given_order@(RootDatum,int)

{. List all Kac elements of a given order, up to conjugacy of the
   corresponding group element. .}
set Kac_classes_given_order (RootDatum rd,int order)=[[int]]:
   if is_simply_connected(rd) then Kac_diags_given_order(rd,order)
   else let S = [[int]]: []
   in for w in Kac_diags_given_order(rd,order)
      do if none(for d in S do is_conjugate_Kac(d,w,rd) od) then S#:=w fi
      od
   ;  S
   fi

set zero_roots(RootDatum rd,[int] Kac)=[int]:
   ##for k@i in Kac do if k=0 then [i] else [] fi od

set complex_pseudo_Levi(RootDatum rd, [int] S)= RootDatum:
   if #S=0 then Levi_datum(rd,[int]:[]) else
   let roots=mat:for i in S do
     if i<semisimple_rank(rd) then simple_roots(rd)[i]
     else -highest_root(rd)
     fi od then
   coroots=mat:for i in S do
     if i<semisimple_rank(rd)
       then simple_coroots(rd)[i]
       else -coroot(rd,highest_root(rd))
     fi od
   in root_datum(roots,coroots,rd.prefers_coroots)
   fi

set centralizer_of_Kac (RootDatum rd, [int] Kac)=RootDatum:
   let roots=[int]:
   ##for k@i in Kac do if k=0 then [i] else [] fi od in
   complex_pseudo_Levi(rd,roots)