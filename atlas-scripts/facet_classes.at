<basic.at {for no_reps}
<sort.at
<combinatorics.at
<hash.at {for KTypePol_hash}
{<to_ht.at {for to_ht}}
<K_highest_weights {for LKTs}
set_type FacetVerts = [ratvec]
set_type FacetVertsIndex = vec { length k+1 for k-dimensional facet }
set_type LocalFacetVertsHash = vec {length k+5 for k-diml facet}
set_type FacetVertsKHash = vec {length d+2 for d-diml facet}
set_type
 [FacetStatusVertsIndex = (string status, FacetVertsIndex verts)
, VertexData = ([ratvec] list, (ratvec->int) lookup)
, FacetData = (VertexData v_data, [[FacetStatusVertsIndex]] facet_status_inds)
{ , FacetDataKchar = ( VertexData v_data
, [[FacetStatusVertsIndex]] facet_status_inds
, [[KTypePol]] Kchars
  )}
{ , FacetDataKNum =
  ( VertexData v_data
  , [[FacetStatusVertsIndex]] facet_status_inds
  , [vec] KNums
  )}
, FacetDataKHash =
  ( VertexData v_data
  , [[LocalFacetVertsHash]] facet_status_inds
  , [vec] KNums
  )
]

{ facets are indexed by pairs (d,j) of nonnegative integers; want
to label by single int...}

{levels[i] is number of terms at level 0,...,i-1}

{
{these two are repeated from facetious.at to avoid dependency}
set index_in_facet_list ([FacetStatusVertsIndex] L) = (vec->int):
    index_in(for (,v) in L do v od) { calls |index_in@[vec]| }

set index_in_facet_list([LocalFacetVertsHash] L) = (vec->int):
    let m = #L[0]-4 
    in index_in(for v in L do v[:m] od)
}

set to_ht (int N) = (ParamPol->ParamPol): (ParamPol P):
  if N < 0 then P
  else let (below,)=height_split(P,N) in below
  fi

{definition repeated from hermitian.at to avoid dependencies}
set to_ht(KTypePol P, int N) = KTypePol:
    let (below,) = height_split(P,N) in below

{removes repetitions and sorts a list of ints}
set no_reps = sort_u@([int])

set levels([[FacetStatusVertsIndex]] FD) = [int]:
    0 # for L in FD do #L od.cumulate_forward

set levels([[vec]] T) = [int]:
    0 # for L in T do #L od.cumulate_forward

{set levels([[LocalFacetVertsHash]] FD) = [int]:
    0 # for L in FD do #L od.cumulate_forward}

{set levels(FacetDataKchar FDK) = [int]:
    levels(FDK.facet_status_inds)}

{set levels(FacetDataKNum FDK) = [int]:
    levels(FDK.facet_status_inds)}

{set levels(FacetDataKHash FDK) = [int]:
    levels(FDK.facet_status_inds)}

{set size(FacetDataKchar FDK) = int:
    for x in FDK.facet_status_inds do #x od.sum}

{set size(FacetDataKNum FDK) = int:
    for x in FDK.facet_status_inds do #x od.sum}

{set size(FacetDataKHash FDK) = int:
    for x in FDK.facet_status_inds do #x od.sum}

set size([[FacetVertsKHash]] FDKH) = int:
    for x in FDKH do #x od.sum

{makes single list of facets}
set index_f ([[FacetStatusVertsIndex]] FD) = (int,int->int):
    let lvls = levels(FD) in (int d,int j) int: lvls[d]+j

set index_f ([[LocalFacetVertsHash]] FD) = (int,int->int):
    let lvls = levels(FD) in (int d,int j) int: lvls[d]+j

{set index_f (FacetDataKchar FDK) = (int,int->int):
    index_f(FDK.facet_status_inds)}

{set index_f (FacetDataKNum FDK) = (int,int->int):
    index_f(FDK.facet_status_inds)}

{set index_f (FacetDataKHash FDK) = (int,int->int):
    index_f(FDK.facet_status_inds)}

set index([[FacetStatusVertsIndex]] FD, int d, int j) = int:
    levels(FD)[d] + j

{makes single list of facets}
{set index(FacetDataKchar FDK, int d, int j) = int:
    levels(FDK)[d] + j}

{set index(FacetDataKNum FDK, int d, int j) = int:
    levels(FDK)[d] + j}

{set index(FacetDataKHash FDK, int d, int j) = int:
    levels(FDK)[d] + j}

{inverse of index}
set coords_f ([[FacetStatusVertsIndex]] FD) = (int->int,int):
    let lvls = levels(FD) in
    (int n) (int,int):
    let d = binary_search_first((int i)bool:lvls[i]>n,0,#lvls)-1
    in (d,n-lvls[d])

set coords_f ([[vec]] T) = (int->int,int):
    let lvls = levels(T) in
    (int n) (int,int):
    let d = binary_search_first((int i)bool:lvls[i]>n,0,#lvls)-1
    in (d,n-lvls[d])

{set coords_f (FacetDataKchar FDK) = (int->int,int):
    coords_f(FDK.facet_status_inds)}

{set coords_f (FacetDataKNum FDK) = (int->int,int):
    coords_f(FDK.facet_status_inds)}

{set coords_f (FacetDataKHash FDK) = (int->int,int):
    coords_f(FDK.facet_status_inds)}

set coords([[FacetStatusVertsIndex]] FD, int n) = (int,int):
    let d = last(for ell in levels(FD) do ell<=n od)
    then j = n- levels(FD)[d]
    in (d,j)

{inverse of index}
{set coords(FacetDataKchar FDK, int n) = (int,int):
    let d = last(for ell in levels(FDK) do ell<=n od)
    then j = n- levels(FDK)[d]
    in (d,j)}

{set coords(FacetDataKNum FDK, int n) = (int,int):
    let d = last(for ell in levels(FDK) do ell<=n od)
    then j = n- levels(FDK)[d]
    in (d,j)}

{set coords(FacetDataKHash FDK, int n) = (int,int):
    let d = last(for ell in levels(FDK) do ell<=n od)
    then j = n- levels(FDK)[d]
    in (d,j)}

set coords([[vec]] T, int n) = (int,int):
    let d = last(for ell in levels(T) do ell<=n od)
    then j = n- levels(T)[d]
    in (d,j)

{functions for looking up facets of given dimension as vertex index lists}
{
set lookups ([[FacetStatusVertsIndex]] FDinds) = [(vec->int)]:
    for L in FDinds do index_in_facet_list(L) od

set lookups ([[LocalFacetVertsHash]] FDinds) = [(vec->int)]:
    for L in FDinds do index_in_facet_list(L) od
}
set lookups ([[vec]] inds) = [(vec->int)]:
    for L@d in inds do index_in(for v in L do v[:d+1] od) od

set lookups ([[FacetStatusVertsIndex]] FDinds) = [(vec->int)]:
    for L@d in FDinds do index_in(for (,v) in L do v[:d+1] od) od
{
set lookups (FacetDataKchar FDK) = [(vec->int)]:
    lookups(FDK.facet_status_inds)
}

{set lookups (FacetDataKNum FDK) = [(vec->int)]:
    lookups(FDK.facet_status_inds)}

{set lookups (FacetDataKHash FDK) = [(vec->int)]:
    lookups(FDK.facet_status_inds)}

{generating relations for up graph: an arrow j0 --> j1 means
nonunitarity at j0 implies nonunitarity at j1}
{
set up_graph_gens(FacetDataKchar FDK) = [[int]]:
    let (,FDinds,Pols) = FDK
    then index   = (int,int->int): index_f(FDinds)
    , edge_gens = [[int]]: for :size(FDK) do [] od
    , lookups = [(vec->int)]:   lookups(FDK)
 in
    for d:#FDinds-1 from 1 { traverse facets having a vertex to spare }
    do let lookup = lookups[d-1] { looking up will be at previous level }
    in for Find@j1 in FDinds[d]
       do for e:d+1
	  do let j0 = lookup(delete(Find.verts,e)[:d])
	  in if j0.>=
	     then edge_gens[index(d-1,j0)] #:= index(d,j1)
	     { ; prints(index(d-1,j0),"  ",d," ",j1," ",j0, " "
		,edge_gens[index(d-1,j0)])}
	     ; if Pols[d][j1] = Pols[d-1][j0]
	       then edge_gens[index(d,j1)] #:= index(d-1,j0)
	       fi
	     fi
	   od
	od
     od;  edge_gens
}

{generating relations for up graph: an arrow j0 --> j1 means
nonunitarity at j0 implies nonunitarity at j1}
set up_graph_gens([[FacetVertsKHash]] FDKHash) = [[int]]:
    let index   = (int,int->int): index_f(FDKHash)
    , edge_gens = [[int]]: for :size(FDKHash) do [] od
    , lookups = [(vec->int)]:   lookups(FDKHash)
 in
    for d:#FDKHash-1 from 1 { traverse facets having a vertex to spare }
    do let lookup = lookups[d-1] { looking up will be at previous level }
    in for Find@j1 in FDKHash[d] {Find has d+3 entries; first d+1 corr
    to verts of d-diml facet}
       do for e:d+1
	  do let j0 = lookup(delete(Find,e)[:d])
	  in if j0.>=
	     then edge_gens[index(d-1,j0)] #:= index(d,j1)
	     ; if Find[d+1:d+3] = FDKHash[d-1][j0][d:d+2]
	       then edge_gens[index(d,j1)] #:= index(d-1,j0)
	       fi
	     fi
	   od
	od
     od;  edge_gens

{generating relations for up graph: an arrow j0 --> j1 means
nonunitarity at j0 implies nonunitarity at j1}
{NEED TO ENSURE #LKTs matches. Ask for coord}
{
set up_graph_gens(FacetDataKNum FDK) = [[int]]:
    let (,FDinds,Pols) = FDK
    then index   = (int,int->int): index_f(FDinds)
    , edge_gens = [[int]]: for :size(FDK) do [] od
    , lookups = [(vec->int)]:   lookups(FDK)
 in
    for d:#FDinds-1 from 1 { traverse facets having a vertex to spare }
    do let lookup = lookups[d-1] { looking up will be at previous level }
    in for Find@j1 in FDinds[d]
       do for e:d+1
	  do let j0 = lookup(delete(Find.verts,e)[:d])
	  in if j0.>=
	     then edge_gens[index(d-1,j0)] #:= index(d,j1)
	     ; if Pols[d][j1] = Pols[d-1][j0]
	       then edge_gens[index(d,j1)] #:= index(d-1,j0)
	       fi
	     fi
	   od
	od
     od;  edge_gens
}

{this function seems to take 98% of time in localGraph. Using
Kpol_hash slows it by factor of two, but even without hash it's the
main thing in localGraph. 9/25/23: now add a last coord checking
equality of #Langlands quotients}

{same, but only check equality of KChars to height |level|}
set up_graph_gens([[FacetVertsKHash]] FDK, KTypePol_hash Kpol_hash, int level) =
[[int]]:
if level < 0 then up_graph_gens(FDK)
else let indexFD   = (int,int->int): index_f(FDK)
    , edge_gens = [[int]]: for :size(FDK) do [] od
    , lookups = [(vec->int)]:   lookups(FDK)
 in
    for d:#FDK-1 from 1 { traverse facets having a vertex to spare }
    do let lookup = lookups[d-1] { looking up will be at previous level }
    in for Find@j1 in FDK[d]
     {Find has size d+3. First d+1 entries index verts of a d-diml
      facet. Next to last indexes K-char, last is #Langlands quotients}
       do for e:d+1
	  do let j0 = lookup(delete(Find,e)[:d])
	  in if j0.>=
	     then edge_gens[indexFD(d-1,j0)] #:= indexFD(d,j1)
	     	 ;if to_ht(Kpol_hash.index(FDK[d][j1][d+1]),level) =
	       	  to_ht(Kpol_hash.index(FDK[d-1][j0][d]),level)
		  and FDK[d][j1][d+2] = FDK[d-1][j0][d+1]
	       then edge_gens[indexFD(d,j1)] #:= indexFD(d-1,j0)
	       fi
	     fi
	   od
	od
     od;  edge_gens
fi

{ rather than using |strong_components| directly, we first try to determine the
  equivalence class of the undirected graph determined b bidirectional edges }

{ compute connected components of undirected graph, return class mapping }
set component_map (int size, [int,int] edges) = (int,(int->int)):
(  let equiv = #size { pointers to integers no larger than index itself }
   then path (int a) = [int]: a # while equiv[a]<a do a:=equiv[a] od
in for (a,b) in edges
   do let pa = path(a), pb=path(b) then sink=min(pa~[0],pb~[0])
   in for i in pa##pb do equiv[i]:=sink od
   od
;  let class_of=null(size), n_classes=0
in for v@i in equiv
   do if v=i then class_of[i]:=n_classes; n_classes+:=1
      else assert(v<i); class_of[i]:=class_of[v]
      fi
   od
;  (n_classes,(int i) int: class_of[i])
)

{ extract bidirectional edges from output of |up_graph_gens| }
set bi_edges ([[int]] graph_gens) = [int,int]:
   { since closure edges "go up", just collect the edges pointing down: }
   for targets@i in graph_gens
   do for t in targets do if t<i then [(t,i)] else [] fi od.##
   od.##

set to_quotient = ([[int]]->[[int]]): { transform graph data to quotient }
(  let !G = quasicompact_form
     (inner_class(root_datum(null(1,0),null(1,0)),id_mat(1)))
   then !x0=KGB(G,0), !zero=null(1), !null_type = null_K_module(G)
in ([[int]] graph_gens) [[int]]:
   let (quot_size,map) = component_map(#graph_gens,bi_edges(graph_gens))
   then new_edges = [KTypePol]: for :quot_size do null_type od
in for L@i in graph_gens
   do new_edges[map(i)] +:= for j in L do (1,K_type(x0,[map(j)])) od
   od
;  for pol in new_edges do for @t in pol do t.lambda_rho[0] od od
)

{ this is the type returned by the built-in strong_components,
describing a directed graph on #n. "classes" are for the equivalence
relation of having a directed path in each direction. "covers" are the
sets of covers in the partial order defined by the graph on classes.}
set_type GraphData = ([[int]] classes, [[int]] covers)

{ returns the class number to which n belongs, and its index in that class }
set find_class(GraphData gr_data, int n) = (int,int):
    let () = for C@m in gr_data.classes
    do
	let j = find(C,n)
	in if j >= 0 then return (m,j)
	   fi
    od
    in (-1,-1)

{finds only the class number. NOT FAST!}
set find_class_fast(GraphData gr_data, int n) = int:
    for C@m in gr_data.classes
    do if is_member_sorted(C)(n)
       then return m
       fi
    od; minus_1
{
set up_data(FacetDataKchar FDK) = GraphData:
    strong_components(up_graph_gens(FDK))
}
{set up_data(FacetDataKNum FDK) = GraphData:
    strong_components(up_graph_gens(FDK))}

{set up_data(FacetDataKHash FDK) = GraphData:
    strong_components(up_graph_gens(FDK))}

set up_data([[FacetVertsKHash]] FDKHash) = GraphData:
    strong_components(up_graph_gens(FDKHash))

{set up_data(FacetDataKHash FDK, KTypePol_hash Kpol_hash, int level) = GraphData:
    strong_components(up_graph_gens(FDK, Kpol_hash, level))}

set up_data([[FacetVertsKHash]] FDKH, KTypePol_hash Kpol_hash, int level) = GraphData:
    strong_components(up_graph_gens(FDKH, Kpol_hash, level))

{ for each equivalence class, sorted list of all classes above
it in the preorder. Is this really ALL classes above?
The no_reps also guarantees that the answers are sorted.}
set full_up_classes_old(GraphData (classes, covers)) = [vec]:
    let fullUpClassesBr = [[vec]]: for m:#classes do [[m]] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClassesBr[j] :=
		   (fullUpClassesBr[m]##fullUpClassesBr[j]).no_reps
		od
    	      od
    in for B in fullUpClassesBr do for v in B do v[0] od od

set full_up_classes(GraphData (classes, covers)) = [vec]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
		,id_mat(1)).quasicompact_form
    then x0 = KGB(G1,0)
    then upPols = [KTypePol]: for m:#classes
    			      do 1*K_type(x0,[m]) od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do upPols[j] := upPols[m]+upPols[j]
		od
    	      od
    in for P in upPols
       do for p in monomials(P)
       	  do lambda_rho(p)[0]
	  od
       od

{ for each equivalence class, sorted list of all classes above
it in the preorder. Is this really ALL classes above?
The no_reps also guarantees that the answers are sorted.}
set full_up_classes2(GraphData (classes, covers)) = [vec]:
    let fullUpClasses = [vec]: for m:#classes do [m] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClasses[j] :=
		   (fullUpClasses[m]##fullUpClasses[j]).no_reps
		od
    	      od
    in fullUpClasses

{ for each equivalence class, sorted list of all classes above it in
the preorder. Is this really ALL classes above?  The no_reps also
guarantees that the answers are sorted.}
{Moving no_reps to the end means that it's MUCH longer lists to apply
no_reps to; seems to be MUCH slower.}
set full_up_classes3(GraphData (classes, covers)) = [vec]:
    let fullUpClasses = [vec]: for m:#classes do [m] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClasses[j] :=
		   (fullUpClasses[m]##fullUpClasses[j])
		od
    	      od
    then () = prints(sum(for C in fullUpClasses do #C od))
    then () = for m:#fullUpClasses
    do
    fullUpClasses[m]:=fullUpClasses[m].no_reps
    od
    in fullUpClasses

{ for each equivalence class, sorted list all elements of all classes above
it in the preorder ; these are the elements where NU in the original
class implies NU here.}
set full_up(GraphData (classes, covers)) =[[int]]:
    for upClasses in full_up_classes((classes,covers))
    do (##for j in upClasses do classes[j] od).no_reps
    od

{ for each equivalence class, sorted list of all classes below
it in the preorder; these are the classes where U in the original
class implies U below. Is this really ALL classes below?
The no_reps also guarantees that the answers are sorted.}
set full_down_classes_old(GraphData (classes, covers)) = [vec]:
    let fullDownClassesBr = [[vec]]: for m:#classes do [[m]] od
    then () = for U@j in covers
    	      ~do
		for m in U
    	      	do fullDownClassesBr[m] :=
		   (fullDownClassesBr[m]##fullDownClassesBr[j]).no_reps
		od
    	      od
    in for B in fullDownClassesBr do for v in B do v[0] od od

{MUST do loop in reverse!}
set full_down_classes(GraphData (classes, covers)) = [vec]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
		,id_mat(1)).quasicompact_form
    then x0 = KGB(G1,0)
    then upPols = [KTypePol]: for m:#classes
    			      do 1*K_type(x0,[m]) od
    then () = for U@j in covers
    	      ~do
		for m in U
    	      	do upPols[m] := upPols[m]+upPols[j]
		od
    	      od
    in for P in upPols
       do for p in monomials(P)
       	  do lambda_rho(p)[0]
	  od
       od

{ for each equivalence class, sorted list all elements of all classes BELOW
it in the preorder. Direction of UNITARITY inheritance. }
set full_down(GraphData (classes, covers)) =[[int]]:
    for downClasses in full_down_classes((classes,covers))
    do (##for j in downClasses do classes[j] od).no_reps
    od

{entry j is class to which j belongs}
{
set class_list_linear(FacetDataKchar FDK, GraphData (classes,covers)) = vec:
  let v=null(size(FDK))
  then () = for C@m in classes
       do for j in C
       	  do v[j] := m od
       od
  in v
}

{set class_list_linear(FacetDataKNum FDK, GraphData (classes,covers)) = vec:
  let v=null(size(FDK))
  then () = for C@m in classes
       do for j in C
       	  do v[j] := m od
       od
  in v}

{set class_list_linear(FacetDataKHash FDK, GraphData (classes,covers)) = vec:
  let v=null(size(FDK))
  then () = for C@m in classes
       do for j in C
       	  do v[j] := m od
       od
  in v}

set class_list_linear([[FacetVertsKHash]] FDKH, GraphData (classes,covers)) = vec:
  let v=null(size(FDKH))
  then () = for C@m in classes
       do for j in C
       	  do v[j] := m od
       od
  in v

{
idea is in a session to say
  > FILENAME writeSC(GraphData)

(or >> to append to FILENAME).
Then in another session you can write
<< FILENAME
which will give you GraphData GD_saved = (eq_saved, covers_saved)
}
set writeSC(GraphData (eq,cov)) = void:
    prints("set eq_saved = [[int]]:");
    prints(eq); prints("set covers_saved =[[int]]:");
    prints(cov);
    prints("set GD_saved = GraphData: (eq_saved,covers_saved)")


{tells which class each facet belongs to}
{
set class_lists(FacetDataKchar FDK, GraphData (classes,covers)) =
[vec]:
	let CLL = class_list_linear(FDK, (classes,covers)),
	    Levels = levels(FDK)
	in  for d:#FDK.facet_status_inds
     	    do CLL[Levels[d]:Levels[d+1]]
     	    od
}

{set class_lists(FacetDataKNum FDK, GraphData (classes,covers)) =
[vec]:
	let CLL = class_list_linear(FDK, (classes,covers)),
	    Levels = levels(FDK)
	in  for d:#FDK.facet_status_inds
     	    do CLL[Levels[d]:Levels[d+1]]
     	    od}

{set class_lists(FacetDataKHash FDK, GraphData (classes,covers)) =
[vec]:
	let CLL = class_list_linear(FDK, (classes,covers)),
	    Levels = levels(FDK)
	in  for d:#FDK.facet_status_inds
     	    do CLL[Levels[d]:Levels[d+1]]
     	    od}

set class_lists([[FacetVertsKHash]] FDKH, GraphData (classes,covers)) =
[vec]:
	let CLL = class_list_linear(FDKH, (classes,covers)),
	    Levels = levels(FDKH)
	in  for d:#FDKH
     	    do CLL[Levels[d]:Levels[d+1]]
     	    od
{F4_s: 9789 facets in 1457 classes}
{Sp(6,R): 165 facets in 42 classes; 9 unitary, 33 not.}
{Sp(6,C): 165 facets in 91 classes; 10 unitary}

