{<facetious.at {for FacetDataKchar}}
< basic.at {for no_reps}

set_type FacetVerts = [ratvec]
set_type FacetVertsIndex = vec { length k+1 for k-dimensional facet }

set_type
[ FacetStatusVertsIndex = (string status, FacetVertsIndex verts)
, VertexData = ([ratvec] list, (ratvec->int) lookup)
, FacetData = (VertexData v_data, [[FacetStatusVertsIndex]] facet_status_inds)
, FacetDataKchar = (VertexData v_data, [[FacetStatusVertsIndex]]
facet_status_inds, [[KTypePol]] Kchars)
]

{ facets are indexed by pairs (d,j) of nonnegative integers; want
to label by single int...}

{levels[i] is number of terms at level 0,...,i-1}

{this is repeated from facetious.at to avoid dependency}
set index_in_facet_list ([FacetStatusVertsIndex] L) = (vec->int):
    index_in(for (,v) in L do v od) { calls |index_in@[vec]| }

{removes repetitions and sorts a list of ints}
set no_reps([int] v) = [int]:
    let V = [vec]: (for m in v do [m] od).no_reps
    in for v in V do v[0] od

set levels([[FacetStatusVertsIndex]] FD) = [int]:
    for k:#FD+1 do sum(for i:k do #FD[i] od) od

set levels(FacetDataKchar FDK) = [int]:
    levels(FDK.facet_status_inds)

set size(FacetDataKchar FDK) = int:
    let FDinds = FDK.facet_status_inds
    in sum(for d:#FDinds do #FDinds[d] od)

{makes single list of facets}
set index([[FacetStatusVertsIndex]] FD, int d, int j) = int:
    levels(FD)[d] + j

{makes single list of facets}
set index(FacetDataKchar FDK, int d, int j) = int:
    levels(FDK)[d] + j

{inverse of index}
set coords([[FacetStatusVertsIndex]] FD, int n) = (int,int):
    let d = last(for ell in levels(FD) do ell<=n od)
    then j = n- levels(FD)[d]
    in (d,j)

{inverse of index}
set coords(FacetDataKchar FDK, int n) = (int,int):
    let d = last(for ell in levels(FDK) do ell<=n od)
    then j = n- levels(FDK)[d]
    in (d,j)

{functions for looking up facets of given dimension as vertex index lists}
set lookups(FacetDataKchar FDK) = [(vec->int)]:
    let FDinds =  FDK.facet_status_inds
    in for L in FDinds do index_in_facet_list(L) od

{generating relations for up graph: an arrow j0 --> j1 means
nonunitarity at j0 implies nonunitarity at j1}
set up_graph_gens(FacetDataKchar FDK) = [[int]]:
    let (,FDinds,Pols) = FDK, lookups = lookups(FDK)
    	 , Levels = levels(FDK)
    then edge_gens = for n:size(FDK) do [int]:[] od
    then () = for d:#FDinds-1 from 1
    	 do for Find@j1 in FDinds[d]
	    do for e:d+1
	       do let v = delete(Find.verts,e)
	       	  then j0 = lookups[d-1](v)
		  in if j0>= 0
		     then edge_gens[Levels[d-1]+j0]##:=[Levels[d]+j1]
		     { ; prints(index(FDK, d-1,j0),"  ",d," ",j1," ",j0, " "
		       	,edge_gens[Levels[d-1]+j0]) }
		     ; if Pols[d][j1]= Pols[d-1][j0]
		       then edge_gens[Levels[d]+j1]##:=[Levels[d-1]+j0]
		       fi
		     fi
		od
             od
	  od
     in edge_gens

{ this is the type returned by the built-in strong_components,
describing a directed graph on #n. "classes" are for the equivalence
relation of having a direct path in each direction. "covers" are the
sets of covers in the partial order defined by the graph on classes.}
set_type GraphData = ([[int]] classes, [[int]] covers)

{ returns the class number to which n belongs, and its index in that class }
set find_class(GraphData gr_data, int n) = (int,int):
    let () = for C@m in gr_data.classes
    do
	let j = find(C,n)
	in if j >= 0 then return (m,j)
	   fi
    od
    in (-1,-1)

{finds only the class number. NOT FAST!}
set find_class_fast(GraphData gr_data, int n) = int:
    for C@m in gr_data.classes
    do if is_member_sorted(C)(n)
       then return m
       fi
    od; minus_1

set up_data(FacetDataKchar FDK) = GraphData:
    strong_components(up_graph_gens(FDK))

{ for each equivalence class, sorted list of all classes above
it in the preorder. Is this really ALL classes above?
The no_reps also guarantees that the answers are sorted.}
set full_up_classes_old(GraphData (classes, covers)) = [vec]:
    let fullUpClassesBr = [[vec]]: for m:#classes do [[m]] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClassesBr[j] :=
		   (fullUpClassesBr[m]##fullUpClassesBr[j]).no_reps
		od
    	      od
    in for B in fullUpClassesBr do for v in B do v[0] od od

set full_up_classes(GraphData (classes, covers)) = [vec]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
		,id_mat(1)).quasicompact_form
    then x0 = KGB(G1,0)
    then upPols = [KTypePol]: for m:#classes
    			      do 1*K_type(x0,[m]) od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do upPols[j] := upPols[m]+upPols[j]
		od
    	      od
    in for P in upPols
       do for p in monomials(P)
       	  do lambda_rho(p)[0]
	  od
       od

{ for each equivalence class, sorted list of all classes above
it in the preorder. Is this really ALL classes above?
The no_reps also guarantees that the answers are sorted.}
set full_up_classes2(GraphData (classes, covers)) = [vec]:
    let fullUpClasses = [vec]: for m:#classes do [m] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClasses[j] :=
		   (fullUpClasses[m]##fullUpClasses[j]).no_reps
		od
    	      od
    in fullUpClasses

{ for each equivalence class, sorted list of all classes above it in
the preorder. Is this really ALL classes above?  The no_reps also
guarantees that the answers are sorted.}
{Moving no_reps to the end means that it's MUCH longer lists to apply
no_reps to; seems to be MUCH slower.}
set full_up_classes3(GraphData (classes, covers)) = [vec]:
    let fullUpClasses = [vec]: for m:#classes do [m] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClasses[j] :=
		   (fullUpClasses[m]##fullUpClasses[j])
		od
    	      od
    then () = prints(sum(for C in fullUpClasses do #C od))
    then () = for m:#fullUpClasses
    do
    fullUpClasses[m]:=fullUpClasses[m].no_reps
    od
    in fullUpClasses

{ for each equivalence class, sorted list all elements of all classes above
it in the preorder ; these are the elements where NU in the original
class implies NU here.}
set full_up(GraphData (classes, covers)) =[[int]]:
    for upClasses in full_up_classes((classes,covers))
    do (##for j in upClasses do classes[j] od).no_reps
    od

{ for each equivalence class, sorted list of all classes below
it in the preorder; these are the classes where U in the original
class implies U below. Is this really ALL classes below?
The no_reps also guarantees that the answers are sorted.}
set full_down_classes_old(GraphData (classes, covers)) = [vec]:
    let fullDownClassesBr = [[vec]]: for m:#classes do [[m]] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullDownClassesBr[m] :=
		   (fullDownClassesBr[m]##fullDownClassesBr[j]).no_reps
		od
    	      od
    in for B in fullDownClassesBr do for v in B do v[0] od od

set full_down_classes(GraphData (classes, covers)) = [vec]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
		,id_mat(1)).quasicompact_form
    then x0 = KGB(G1,0)
    then upPols = [KTypePol]: for m:#classes
    			      do 1*K_type(x0,[m]) od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do upPols[m] := upPols[m]+upPols[j]
		od
    	      od
    in for P in upPols
       do for p in monomials(P)
       	  do lambda_rho(p)[0]
	  od
       od

{ for each equivalence class, sorted list all elements of all classes BELOW
it in the preorder. Direction of UNITARITY inheritance. }
set full_down(GraphData (classes, covers)) =[[int]]:
    for downClasses in full_down_classes((classes,covers))
    do (##for j in downClasses do classes[j] od).no_reps
    od

{entry j is class to which j belongs}
set class_list_linear(FacetDataKchar FDK, GraphData (classes,covers)) = vec:
  let v=null(size(FDK))
  then () = for C@m in classes
       do for j in C
       	  do v[j] := m od
       od
  in v

{tells which class each facet belongs to}
set class_lists(FacetDataKchar FDK, GraphData (classes,covers)) =
[vec]:
	let CLL = class_list_linear(FDK, (classes,covers)),
	    Levels = levels(FDK)
	in  for d:#FDK.facet_status_inds
     	    do CLL[Levels[d]:Levels[d+1]]
     	    od

{F4_s: 9789 facets in 1457 classes}
{Sp(6,R): 165 facets in 42 classes; 9 unitary, 33 not.}
{Sp(6,C): 165 facets in 91 classes; 10 unitary}
