<facetious.at {for FacetDataKchar}

{ facets are indexed by pairs (d,j) of nonnegative integers; want
to label by single int...}

{levels[i] is number of terms at level 0,...,i-1}
set levels(FacetDataKchar FDK) = [int]:
    let FDinds = FDK.facet_status_inds
    in for k:#FDinds do sum(for i:k do #FDinds[i] od) od

set size(FacetDataKchar FDK) = int:
    let FDinds = FDK.facet_status_inds
    in sum(for d:#FDinds do #FDinds[d] od)

{makes single list of facets}
set index(FacetDataKchar FDK, int d, int j) = int:
    levels(FDK)[d] + j

{inverse of index}
set coords(FacetDataKchar FDK, int n) = (int,int):
    let FDind = FDK.facet_status_inds 
    then d = last(for ell in levels(FDK) do ell<=n od)
    then j = n- levels(FDK)[d]
    in (d,j)

{functions for looking up facets of given dimension as vertex index lists}
set lookups(FacetDataKchar FDK) = [(vec->int)]:
    let FDinds =  FDK.facet_status_inds
    in for L in FDinds do index_in_facet_list(L) od

{generating relations for up graph: an arrow j0 --> j1 means
nonunitarity at j0 implies nonunitarity at j1}
set up_graph_gens(FacetDataKchar FDK) = [[int]]:
    let (,FDinds,Pols) = FDK, lookups = lookups(FDK)
    	 , Levels = levels(FDK)
    then edge_gens = for n:size(FDK) do [int]:[] od
    then () = for d:#FDinds-1 from 1
    	 do for Find@j1 in FDinds[d]
	    do for e:d+1
	       do let v = delete(Find.verts,e)
	       	  then j0 = lookups[d-1](v)
		  in if j0>= 0
		     then edge_gens[Levels[d-1]+j0]##:=[Levels[d]+j1]
		     { ; prints(index(FDK, d-1,j0),"  ",d," ",j1," ",j0, " "
		       	,edge_gens[Levels[d-1]+j0]) }
		     ; if Pols[d][j1]= Pols[d-1][j0]
		       then edge_gens[Levels[d]+j1]##:=[Levels[d-1]+j0]
		       fi
		     fi
		od
             od
	  od
     in edge_gens

set_type UpData = ([[int]] classes, [[int]] covers)

{ returns the class number to which n belongs, and its index in that class }
set find_class(UpData up_data, int n) = (int,int):
    let () = for C@m in up_data.classes
    do
	let j = find(C,n)
	in if j >= 0 then return (m,j)
	   fi
    od
    in (-1,-1)

{finds only the class number}
set find_class_fast(UpData up_data, int n) = int:
    for C@m in up_data.classes
    do if is_member_sorted(C)(n)
       then return m
       fi
    od; minus_1

set up_data(FacetDataKchar FDK) = UpData:
    strong_components(up_graph_gens(FDK))

{ for each equivalence class, sorted list all elements of all classes above
it in the preorder }
set full_up(UpData (classes, covers)) =[[int]]:
    let fullUp = [[int]]: for C in classes do C od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUp[j] := merge(fullUp[m],fullUp[j])
		od
    	      od
    in fullUp

{sorted list of all elements in all classes above #m}
set full_up(UpData (classes, covers), int m) = [int]:
    let fullUpm = [int]: classes[m], to_do = [int]: covers[m]
    then () = while #to_do> 0
    	      	    do for j in to_do
		       do to_do:= ##for j in to_do
		       	  	    do covers[j]
				    od;
		       	   fullUpm := merge(fullUpm,classes[j])
		       od
		    od
    in fullUpm

{ for each equivalence class, sorted list all elements of all classes BELOW
it in the preorder. Direction of UNITARITY inheritance. }
set full_down(UpData (classes, covers)) =[[int]]:
    let fullDown = [[int]]: for C in classes do C od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullDown[m] := merge(fullDown[j],fullDown[m])
		od
    	      od
    in fullDown

{sorted list of all elements in all classes below #m}
set full_down(UpData (classes, covers), int m) = [int]:
    let fullDownm = [int]: classes[m], to_do = [int]:
    for U@k in covers
    do if is_member(U)(m)
       then [k]
       else []
       fi
    od.##
    then () = while #to_do> 0
    	      	    do for j in to_do
		       do to_do:= for U@k in covers
		       	  	      do if is_disjoint(U,to_do)
				      	 then []
				     	 else [k]
				     	 fi
				      od.##
		       	   	      ; fullDownm := merge(fullDownm,classes[j])
		       od
		    od
    in fullDownm

{F4_s: 9789 facets in 1457 classes}
{Sp(6,R): 165 facets in 42 classes; 9 unitary, 33 not.}
{Sp(6,C): 165 facets in 91 classes; 10 unitary}

