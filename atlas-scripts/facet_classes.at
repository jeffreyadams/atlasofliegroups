<facetious.at {for FacetDataKchar}
< poset.at {for Poset commands}

{ facets are indexed by pairs (d,j) of nonnegative integers; want
to label by single int...}

{levels[i] is number of terms at level 0,...,i-1}
set levels(FacetDataKchar FDK) = [int]:
    let FDinds = FDK.facet_status_inds
    in for k:#FDinds do sum(for i:k do #FDinds[i] od) od

set size(FacetDataKchar FDK) = int:
    let FDinds = FDK.facet_status_inds
    in sum(for d:#FDinds do #FDinds[d] od)

{makes single list of facets}
set index(FacetDataKchar FDK, int d, int j) = int:
    levels(FDK)[d] + j

{inverse of index}
set coords(FacetDataKchar FDK, int n) = (int,int):
    let FDind = FDK.facet_status_inds 
    then d = last(for ell in levels(FDK) do ell<=n od)
    then j = n- levels(FDK)[d]
    in (d,j)

{functions for looking up facets of given dimension as vertex index lists}
set lookups(FacetDataKchar FDK) = [(vec->int)]:
    let FDinds =  FDK.facet_status_inds
    in for L in FDinds do index_in_facet_list(L) od

{generating relations for facet poset}
{NEED TO INCLUDE REVERSED RELATIONS}
set down_equiv_poset_gens(FacetDataKchar FDK) = Poset:
    let FDinds = FDK.facet_status_inds, Pols = FDK.Kchars
    then lookups = lookups(FDK)
    in
    for j:#FDinds[0] do [int]: [] od ##
    for n:size(FDK)-#FDinds[0] from #FDinds[0]
       do
       let (d,j) = coords(FDK, n)
       then Find = FDinds[d][j]
       	    in for e:d+1
       	       do
		let v = delete(Find.verts,e)
       	  	then j0 = lookups[d-1](v)
       	  	in if j0 >= 0 and Pols[d][j] = Pols[d-1][j0]
	    	   then [index(FDK,d-1,j0)]
       	     	   else []
	     	   fi
       	       od.##
       od

{includes the reversed relations}
set all_equiv_poset_gens(FacetDataKchar FDK) = Poset:
    let Pdown = down_equiv_poset_gens(FDK), FDinds = FDK.facet_status_inds,
    	L = levels(FDK)
    then
    () = for n:size(FDK)-#FDinds~[0]
       	 do
		let (d,j) = coords(FDK,n)
    		in Pdown[n]:= Pdown[n]##(for j:#FDinds[d+1]
	   		 	 do if find(Pdown[L[d+1]+j],n) >= 0
			    	    then [L[d+1]+j] else []
			    	    fi
			 	 od).##
    od##Pdown[L~[0]:]
    in Pdown

{jth entry is the equivalence class of j}
set equiv_poset(FacetDataKchar FDK) = Poset:
    closure(all_equiv_poset_gens(FDK))

{the distinct equivalence classes of facets}
set equiv_classes(FacetDataKchar FDK) = [[int]]:
    let PF = equiv_poset(FDK)
    in (for n:size(FDK)
       	do if PF[n][0] = n then [PF[n]] else []
	   fi
    	od).##

{F4_s: 9789 facets in 1457 classes}
{Sp(6,R): 165 facets in 42 classes; 9 unitary, 33 not.}
{Sp(6,C): 165 facets in 91 classes; 10 unitary}

{Now do unitary poset: equivalence classes above, PLUS containment of
vertex sets}

set down_unitary_poset_gens(FacetDataKchar FDK) = Poset:
    let downGen = all_equiv_poset_gens(FDK), FDinds = FDK.facet_status_inds
    then lookups = lookups(FDK)
    then () = for d:#FDinds-1 from 1
    	 do
    	     for Find@j in FDinds[d]
	     do
	     downGen[index(FDK,d,j)]:=
		downGen[index(FDK,d,j)] ## for e:d+1
		do
		    let v = delete(Find.verts,e)
		    then j0 = lookups[d-1](v)
		    in if j0 >= 0
		       then [index(FDK,d-1,j0)]
		       else []
		       fi
		od.## {.no_reps.sort}
	     od
	  od
     in downGen

set unitary_down_poset(FacetDataKchar FDK) = Poset:
    closure(down_unitary_poset_gens(FDK))


set up_nonunitary_poset_gens(FacetDataKchar FDK) = Poset:
    let upGen = all_equiv_poset_gens(FDK), FDinds = FDK.facet_status_inds
    then lookups = lookups(FDK)
    then () = for d:#FDinds-1 from 1
    	 do
    	     for Find@j in FDinds[d]
	     do
		for e:d+1
		do
		    let v = delete(Find.verts,e)
		    then j0 = lookups[d-1](v)
		    in if j0 >= 0
		       then upGen[index(FDK,d-1,j0)]##:=[index(FDK,d,j)]
		       	    {.no_reps.sort}
		       else []
		       fi
		od.##{.no_reps.sort}
	     od
	 od
    in upGen

set nonunitary_up_poset(FacetDataKchar FDK) = Poset:
    closure(up_nonunitary_poset_gens(FDK))
