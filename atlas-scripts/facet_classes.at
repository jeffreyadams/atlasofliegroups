{<facetious.at {for FacetDataKchar}}
<basic.at {for no_reps}
<sort.at
<combinatorics.at

set_type FacetVerts = [ratvec]
set_type FacetVertsIndex = vec { length k+1 for k-dimensional facet }

set_type
[ FacetStatusVertsIndex = (string status, FacetVertsIndex verts)
, VertexData = ([ratvec] list, (ratvec->int) lookup)
, FacetData = (VertexData v_data, [[FacetStatusVertsIndex]] facet_status_inds)
, FacetDataKchar =
  ( VertexData v_data
  , [[FacetStatusVertsIndex]] facet_status_inds
  , [[KTypePol]] Kchars
  )
]

{ facets are indexed by pairs (d,j) of nonnegative integers; want
to label by single int...}

{levels[i] is number of terms at level 0,...,i-1}

{this is repeated from facetious.at to avoid dependency}
set index_in_facet_list ([FacetStatusVertsIndex] L) = (vec->int):
    index_in(for (,v) in L do v od) { calls |index_in@[vec]| }

{removes repetitions and sorts a list of ints}
set no_reps = sort_u@([int])

set levels([[FacetStatusVertsIndex]] FD) = [int]:
    0 # for L in FD do #L od.cumulate_forward

set levels(FacetDataKchar FDK) = [int]:
    levels(FDK.facet_status_inds)

set size(FacetDataKchar FDK) = int:
    for x in FDK.facet_status_inds do #x od.sum

{makes single list of facets}
set index_f ([[FacetStatusVertsIndex]] FD) = (int,int->int):
    let lvls = levels(FD) in (int d,int j) int: lvls[d]+j

set index_f (FacetDataKchar FDK) = (int,int->int):
    index_f(FDK.facet_status_inds)

set index([[FacetStatusVertsIndex]] FD, int d, int j) = int:
    levels(FD)[d] + j

{makes single list of facets}
set index(FacetDataKchar FDK, int d, int j) = int:
    levels(FDK)[d] + j

{inverse of index}
set coords_f ([[FacetStatusVertsIndex]] FD) = (int->int,int):
    let lvls = levels(FD) in
    (int n) (int,int):
    let d = binary_search_first((int i)bool:lvls[i]>n,0,#lvls)-1
    in (d,n-lvls[d])

set coords_f (FacetDataKchar FDK) = (int->int,int):
    coords_f(FDK.facet_status_inds)

set coords([[FacetStatusVertsIndex]] FD, int n) = (int,int):
    let d = last(for ell in levels(FD) do ell<=n od)
    then j = n- levels(FD)[d]
    in (d,j)

{inverse of index}
set coords(FacetDataKchar FDK, int n) = (int,int):
    let d = last(for ell in levels(FDK) do ell<=n od)
    then j = n- levels(FDK)[d]
    in (d,j)

{functions for looking up facets of given dimension as vertex index lists}
set lookups (FacetDataKchar FDK) = [(vec->int)]:
    let FDinds =  FDK.facet_status_inds
    in for L in FDinds do index_in_facet_list(L) od

{generating relations for up graph: an arrow j0 --> j1 means
nonunitarity at j0 implies nonunitarity at j1}
set up_graph_gens(FacetDataKchar FDK) = [[int]]:
    let (,FDinds,Pols) = FDK
    then index   = (int,int->int): index_f(FDinds)
    , edge_gens = [[int]]: for :size(FDK) do [] od
    , lookups = [(vec->int)]:   lookups(FDK)
 in
    for d:#FDinds-1 from 1 { traverse facets having a vertex to spare }
    do let lookup = lookups[d-1] { looking up will be at previous level }
    in for Find@j1 in FDinds[d]
       do for e:d+1
	  do let j0 = lookup(delete(Find.verts,e))
	  in if j0.>=
	     then edge_gens[index(d-1,j0)] #:= index(d,j1)
	     { ; prints(index(FDK, d-1,j0),"  ",d," ",j1," ",j0, " "
		,edge_gens[Levels[d-1]+j0]) }
	     ; if Pols[d][j1] = Pols[d-1][j0]
	       then edge_gens[index(d,j1)] #:= index(d-1,j0)
	       fi
	     fi
	   od
	od
     od;  edge_gens

{ rather than using |strong_components| directly, we first try to determine the
  equivalence class of the undirected graph determined b bidirectional edges }

{ compute connected components of undirected graph, return class mapping }
set component_map (int size, [int,int] edges) = (int,(int->int)):
(  let equiv = #size { pointers to integers no larger than index itself }
   then path (int a) = [int]: a # while equiv[a]<a do a:=equiv[a] od
in for (a,b) in edges
   do let pa = path(a), pb=path(b) then sink=min(pa~[0],pb~[0])
   in for i in pa##pb do equiv[i]:=sink od
   od
;  let class_of=null(size), n_classes=0
in for v@i in equiv
   do if v=i then class_of[i]:=n_classes; n_classes+:=1
      else assert(v<i); class_of[i]:=class_of[v]
      fi
   od
;  (n_classes,(int i) int: class_of[i])
)

{ extract bidirectional edges from output of |up_graph_gens| }
set bi_edges ([[int]] graph_gens) = [int,int]:
   { since closure edges "go up", just collect the edges pointing down: }
   for targets@i in graph_gens
   do for t in targets do if t<i then [(t,i)] else [] fi od.##
   od.##

set to_quotient = ([[int]]->[[int]]): { transform graph data to quotient }
(  let !G = quasicompact_form
     (inner_class(root_datum(null(1,0),null(1,0)),id_mat(1)))
   then !x0=KGB(G,0), !zero=null(1), !null_type = null_K_module(G)
in ([[int]] graph_gens) [[int]]:
   let (quot_size,map) = component_map(#graph_gens,bi_edges(graph_gens))
   then new_edges = [KTypePol]: for :quot_size do null_type od
in for L@i in graph_gens
   do new_edges[map(i)] +:= for j in L do (1,K_type(x0,[map(j)])) od
   od
;  for pol in new_edges do for @t in pol do t.lambda_rho[0] od od
)

{ this is the type returned by the built-in strong_components,
describing a directed graph on #n. "classes" are for the equivalence
relation of having a direct path in each direction. "covers" are the
sets of covers in the partial order defined by the graph on classes.}
set_type GraphData = ([[int]] classes, [[int]] covers)

{ returns the class number to which n belongs, and its index in that class }
set find_class(GraphData gr_data, int n) = (int,int):
    let () = for C@m in gr_data.classes
    do
	let j = find(C,n)
	in if j >= 0 then return (m,j)
	   fi
    od
    in (-1,-1)

{finds only the class number. NOT FAST!}
set find_class_fast(GraphData gr_data, int n) = int:
    for C@m in gr_data.classes
    do if is_member_sorted(C)(n)
       then return m
       fi
    od; minus_1

set up_data(FacetDataKchar FDK) = GraphData:
    strong_components(up_graph_gens(FDK))

{ for each equivalence class, sorted list of all classes above
it in the preorder. Is this really ALL classes above?
The no_reps also guarantees that the answers are sorted.}
set full_up_classes_old(GraphData (classes, covers)) = [vec]:
    let fullUpClassesBr = [[vec]]: for m:#classes do [[m]] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClassesBr[j] :=
		   (fullUpClassesBr[m]##fullUpClassesBr[j]).no_reps
		od
    	      od
    in for B in fullUpClassesBr do for v in B do v[0] od od

set full_up_classes(GraphData (classes, covers)) = [vec]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
		,id_mat(1)).quasicompact_form
    then x0 = KGB(G1,0)
    then upPols = [KTypePol]: for m:#classes
    			      do 1*K_type(x0,[m]) od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do upPols[j] := upPols[m]+upPols[j]
		od
    	      od
    in for P in upPols
       do for p in monomials(P)
       	  do lambda_rho(p)[0]
	  od
       od

{ for each equivalence class, sorted list of all classes above
it in the preorder. Is this really ALL classes above?
The no_reps also guarantees that the answers are sorted.}
set full_up_classes2(GraphData (classes, covers)) = [vec]:
    let fullUpClasses = [vec]: for m:#classes do [m] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClasses[j] :=
		   (fullUpClasses[m]##fullUpClasses[j]).no_reps
		od
    	      od
    in fullUpClasses

{ for each equivalence class, sorted list of all classes above it in
the preorder. Is this really ALL classes above?  The no_reps also
guarantees that the answers are sorted.}
{Moving no_reps to the end means that it's MUCH longer lists to apply
no_reps to; seems to be MUCH slower.}
set full_up_classes3(GraphData (classes, covers)) = [vec]:
    let fullUpClasses = [vec]: for m:#classes do [m] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullUpClasses[j] :=
		   (fullUpClasses[m]##fullUpClasses[j])
		od
    	      od
    then () = prints(sum(for C in fullUpClasses do #C od))
    then () = for m:#fullUpClasses
    do
    fullUpClasses[m]:=fullUpClasses[m].no_reps
    od
    in fullUpClasses

{ for each equivalence class, sorted list all elements of all classes above
it in the preorder ; these are the elements where NU in the original
class implies NU here.}
set full_up(GraphData (classes, covers)) =[[int]]:
    for upClasses in full_up_classes((classes,covers))
    do (##for j in upClasses do classes[j] od).no_reps
    od

{ for each equivalence class, sorted list of all classes below
it in the preorder; these are the classes where U in the original
class implies U below. Is this really ALL classes below?
The no_reps also guarantees that the answers are sorted.}
set full_down_classes_old(GraphData (classes, covers)) = [vec]:
    let fullDownClassesBr = [[vec]]: for m:#classes do [[m]] od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do fullDownClassesBr[m] :=
		   (fullDownClassesBr[m]##fullDownClassesBr[j]).no_reps
		od
    	      od
    in for B in fullDownClassesBr do for v in B do v[0] od od

set full_down_classes(GraphData (classes, covers)) = [vec]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
		,id_mat(1)).quasicompact_form
    then x0 = KGB(G1,0)
    then upPols = [KTypePol]: for m:#classes
    			      do 1*K_type(x0,[m]) od
    then () = for U@j in covers
    	      do
		for m in U
    	      	do upPols[m] := upPols[m]+upPols[j]
		od
    	      od
    in for P in upPols
       do for p in monomials(P)
       	  do lambda_rho(p)[0]
	  od
       od

{ for each equivalence class, sorted list all elements of all classes BELOW
it in the preorder. Direction of UNITARITY inheritance. }
set full_down(GraphData (classes, covers)) =[[int]]:
    for downClasses in full_down_classes((classes,covers))
    do (##for j in downClasses do classes[j] od).no_reps
    od

{entry j is class to which j belongs}
set class_list_linear(FacetDataKchar FDK, GraphData (classes,covers)) = vec:
  let v=null(size(FDK))
  then () = for C@m in classes
       do for j in C
       	  do v[j] := m od
       od
  in v

{tells which class each facet belongs to}
set class_lists(FacetDataKchar FDK, GraphData (classes,covers)) =
[vec]:
	let CLL = class_list_linear(FDK, (classes,covers)),
	    Levels = levels(FDK)
	in  for d:#FDK.facet_status_inds
     	    do CLL[Levels[d]:Levels[d+1]]
     	    od

{F4_s: 9789 facets in 1457 classes}
{Sp(6,R): 165 facets in 42 classes; 9 unitary, 33 not.}
{Sp(6,C): 165 facets in 91 classes; 10 unitary}
