<basic.at
<combinatorics.at { for |partition_pairs|, |pairs_of_total_sum| }
<character_tables.at
<classical_W_classes_and_reps.at { for type abbreviation |BC_class|, |cycles| }



{     type C     }

set BC_classes(int n) = [BC_class]:
   for PQ in partition_pairs(n) do to_cycles(PQ) od

{ word representative in types B and C of conjugacy class for partition pair;
  the parts of P correspond to are cycles without flip, those of Q with flip }
set class_word_BC(Partition P,Partition Q) = [int]:
(  assert((P:=P.strip_to_partition).>, "P is not a partition")
;  assert((Q:=Q.strip_to_partition).>, "Q is not a partition")
;  let nP=sum(P), nQ=sum(Q)
   ,  Pbars = let sum=minus_1 in for p in P do sum+:=p od
   ,  Qbars = let sum=minus_1 in for q in Q do sum+:=q od
then  P_gens = complement(nP,Pbars) { for P part, do the same as in type A }
   ,  Q_gens = { each cycle from Q gets a sign flip when its end is sensed }
      for i:nQ
      do let pos=nP+i { position in [0,n) where we are }
      in if isnt_member(Qbars)(i) then [pos] { extend our cycle }
         else { tack on a sign flip at the final element of the cycle }
	    for j:nQ-i from pos do j od## for j:nQ-i-1 from pos do j ~od
	 fi
      od.##
in P_gens##Q_gens
)

{ for general type C root data, we need to look up and use the diagram order }
set conjugacy_class_C(RootDatum rd) = (BiPartition->WeylElt):
   let map = test_simple_type("C",rd) then n=#map in
   (BiPartition pair) WeylElt:
(  let size = rank(pair)
in assert(size=n,"Partition sizes sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word_BC(pair) do map[s] od)
)

{ in class table construction we perfer |BiPartition| over |Signed_cycles| }
set class_table_C(int n) = WeylClassTable:
   let rd=Sp(n+n), classes = [BiPartition]: partition_pairs(n)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do W_elt(rd,class_word_BC(pair)) od
		, (WeylElt w)int:
		    cycle_class_size(cycle_code(w).as_signed_cycles)
		, (WeylElt w) int: lookup(cycle_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

set class_table_C(RootDatum rd) = WeylClassTable:
   let classes = [BiPartition]: partition_pairs(rd.semisimple_rank)
   , type_code(WeylElt w) = vec: signed_cycle_type_code(classic_permutation(w))
   , class_rep = (BiPartition->WeylElt): conjugacy_class_C(rd)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do class_rep(pair) od
		, (WeylElt w)int:
		    cycle_class_size(type_code(w).as_signed_cycles)
		, (WeylElt w) int: lookup(type_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

set BC_irreps(int n) = [BC_irrep]:
   pairs_of_total_sum(n,(int k):partitions(k)~[:]) { list [k],..,ones(k) }

set character_table_C(int n) = CharacterTable:
   let class_list =  partition_pairs(n), rd=Sp(n+n)
   then cycles = for pair in class_list do pair.to_cycles od
   , class_rep(int i) = WeylElt: W_elt(rd,class_word_BC(class_list[i]))
   then classes = [WeylElt,classical_class,string]:
      for c@i in cycles do ( class_rep(i), c.class_BC, c.cycles_string) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in BC_irreps(n)
      do ( rep.irrep_BC, rep.irrep_string
         , for c in cycles do hyperoctahedral_character(rep,c) od
	 )
      od
   in character_table(class_table_C(n),classes,irreps)

set character_table_C(RootDatum rd) = CharacterTable:
   let n=rd.semisimple_rank
   then class_list =  partition_pairs(n)
   then cycles = for pair in class_list do pair.to_cycles od
   , class_rep(int i) = WeylElt: conjugacy_class_C(rd)(class_list[i])
   then classes = [WeylElt,classical_class,string]:
      for c@i in cycles do ( class_rep(i), c.class_BC, c.cycles_string) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in BC_irreps(n)
      do ( rep.irrep_BC, rep.irrep_string
         , for c in cycles do hyperoctahedral_character(rep,c) od
	 )
      od
   in character_table(class_table_C(rd),classes,irreps)
