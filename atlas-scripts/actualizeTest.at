{. I think the issue here is this (but the main problem is that I
don't understand the issue). Suppose w is a Weyl group element of
order 2 preserving a facet F in the FPP (or maybe -w preserves F??) with
vertices v[0],...,v[d], but acting nontrivially on the vertices, by a
permutation Perm (see the function thetaAct in facetious). In this
situation the actual unitary facet has vertices (v[i] + v[Perm(i))/2.

I would like to compute the set of all possible (v[i] + v[Perm(i)])/2
in advance, and use it instead of the FPP vertices in the unitarity
calculations.

A stupid thing to do would be to look at all (v+v')/2,
for v and v' any pair in the FPP vertices. Since this squares the
number of terms, it's impractical. The condition that the pairs make
a w-fixed 1-dimensional facet is closer to the right one. But maybe
it's (-w)-fixed??

Testing seems to indicate that new vertices are NOT produced in types
B, C, D_2n, G2, F4; that in type A, new vertices appear only in the equal
rank forms; that in D_odd, new vertices appear only in the equal
rank cases; that in E6, new vertices appear only in the equal rank cases.

I'm guessing that if -1 is in the folded Weyl group, then no new
vertices appear. This would reduce the issue to equal rank A, D_odd,
and E6, plus complex groups of types A, D_odd, and E6.

VERY crude guess at the needed new vertices: write tau = -w0, a root
datum automorphism. Take a pair (v, tau(v)) of distinct vertices of
the fundamental alcove, (These are the fundamental weights for
distinct simple roots exchanged by tau, divided by some highest coroot
coefficient.) Crude guess is

Waff applied to (v+tau(v))/2, intersect FPP.

But this is not yet correct (e.g. U(2,2)) .}

< facetious.at
set test(RealForm G) = void:
    prints(new_line, "testing G = ", G);
    let FD=facet_data_fold(G)
    then data= FD.v_data
    then vlist = data.list, finder = data.lookup
    then () = prints(new_line,"master vertex list for G:");
    for v in vlist do prints(v) od;
    prints(new_line,"unitary vertices not in master list:"); prints()
    in for x in KGB(G) do
    	 let FDx = actualize(x,G.rho,FD)
	 then vlistx = FDx.v_data.list
	 in
	 for v in vlistx do if finder(v) = -1 then prints(x,"  ",v) fi
	 od
       od
