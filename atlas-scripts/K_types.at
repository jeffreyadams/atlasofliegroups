<basic.at     { for *@(Param,rat) }
<hermitian.at { for hermitian_form_irreducible }
<K_highest_weights.at
<to_ht.at {for hermitian_form_irreducible_to_ht}
<FPP_faces_herm.at {for script branching}

set int_part (KTypePol P) = KTypePol:
   P.null_K_module + for c@t in P do (c.int_part,t) od
set s_part (KTypePol P) = KTypePol:
   P.null_K_module + for c@t in P do (c.s_part,t) od

{set branch_std = (KTypePol,int->KTypePol): branch@(KTypePol,int) { built-in }}
set branch_std (KTypePol P, int cut_off) = KTypePol:
    let start = elapsed_ms()
    then ans = if my_branch_flag
    	       then big_unitary_hash.branch(P,cut_off)
	       else branch(P,cut_off)
	       fi
    in if my_branch_flag
       then branch_script_time +:= elapsed_ms() - start
       else branch_builtin_time +:= elapsed_ms() - start
       fi;
       ans

set branch_std (KType mu, int cut_off) = KTypePol:
    branch_std(1*mu,cut_off)

set branch_std (ParamPol P, int bound) = KTypePol:
    let start = elapsed_ms()
    then ans = if my_branch_flag
    	       then big_unitary_hash.branch(K_type_pol(P),bound)
	       else branch(K_type_pol(P),bound)
	       fi
    in if my_branch_flag
       then branch_script_time +:= elapsed_ms() - start
       else branch_builtin_time +:= elapsed_ms() - start
       fi;
       ans

set branch_irr (Param p, int bound) = KTypePol:
   branch_std(K_type_pol(character_formula(p)),bound)

set branch_irr (ParamPol P,int bound) = KTypePol:
  branch_std(K_type_pol(character_formula(P)),bound)
 
{ multiplicity of K-type p_K in standard module p }
set mult_std (KType p_K,KTypePol P) = int:
  (branch_std(P,height(p_K))[p_K]).int_part

{ multiplicity of K-type p_K in irreducible module p }
set mult_irr (KType p_K,ParamPol P) = int:
  (branch_irr(P,height(p_K))[p_K]).int_part

set K_signature_irr (Param p,int bound) = (KTypePol,KTypePol):
  let HI = hermitian_form_irreducible(p)
  then start = elapsed_ms()
  then ans = if my_branch_flag
    	     then big_unitary_hash.branch(HI,bound)
	     else branch(HI,bound)
	     fi
  in if my_branch_flag
     then branch_script_time +:= elapsed_ms() - start
     else branch_builtin_time +:= elapsed_ms() - start
     fi;
     (int_part(ans),s_part(ans))

set K_signature_irrB (Param p,int bound) = (KTypePol,KTypePol):
  let HI = hermitian_form_irreducible_to_ht(p,bound)
  then start = elapsed_ms()
  then ans = if my_branch_flag
    	     then big_unitary_hash.branch(HI,bound)
	     else branch(HI,bound)
	     fi
  in if my_branch_flag
     then branch_script_time +:= elapsed_ms() - start
     else branch_builtin_time +:= elapsed_ms() - start
     fi;
     (int_part(ans),s_part(ans))

set signed_mult (KType p_K,Param p) = (int,int):
  let (P,Q)=K_signature_irr(p,height(p_K)) in (P[p_K].int_part,Q[p_K].int_part)

set signed_multB (KType p_K,Param p) = (int,int):
  let (P,Q)=K_signature_irrB(p,height(p_K)) in (P[p_K].int_part,Q[p_K].int_part)

{ this should be modified to print all LKTs }
set print_K_types (ParamPol P) = void:
  for c@p in P
  do let mu=highest_weight_one(LKT(p)) in
    prints(split_as_int(c), " ", fundamental_weight_coordinates (mu)
          , " ", dimension(mu), " ", length(mu))
  od

set print_K_types (ParamPol P, KGBElt x_K) = void:
  for c@p in P
  do let mu=highest_weight_one(LKT(p),x_K) in
    prints(split_as_int(c), " ", fundamental_weight_coordinates (mu)
          , " ", dimension(mu), " ", length(mu))
  od

{K_basis is the basis of a vector space, v is a vector in this basis
 return sum_i v[i]*K_types[i]
 need G only if #K_basis=0}
set expand ([int] v,[KType] K_basis, RealForm G) = KTypePol:
   null_K_module(G) + for c@i in v do c*K_basis[i] od

{ convenience function; gives error if K_basis=[] }
set expand ([int] v,[KType] K_basis) =KTypePol:
  expand(v,K_basis,K_basis[0].real_form)

{find KType in list of K_types}
set find ([KType] list,KType mu) = int: first(#list,(int i)bool:list[i]=mu)

{sort KTypes uniquely}
set sort_u ([KType] K_types) = [KType]:
  if =#K_types then []
  else
     for @t in K_types[0].null_K_module+for Kt in K_types do (1,Kt) od do t od
  fi
