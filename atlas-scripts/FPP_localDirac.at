<FPP_faces_herm
<simple_factors { for simple_factors }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]), no_reps}
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<unity.at { for is_unitary_test }
<bottom_layer.at {for bottom layer unitarity tests}
<springer_tables_reductive.at {for Springer_table }
<associated_variety_annihilator.at { for GK_dim, used in identifying unipotent reps }
<weak_packets.at {for unipotent_representations}
<derived_cover.at {for sc_descends}
<cohIndUnip.at {for is_FPP}
<up_mu.at {for up_mu_hash}
{ <lietypes.at { for simple_type }}
{ <parabolics.at {for parabolic_by_wt}}
<K_highest_weights.at {for all_lambda_differential_zero}
<lattice.at {for vec_solve}
{ <chopping_faces_fast.at {for chop_coroots(G, vertices)}}
<face_classes.at {for ordering on faces}
<hash.at {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<translate {for translate_param_by}
<time {for print_string}
{<powerTwo.at} {for fast raising to powers of two using make_power_function }
{This is meant to be functions for computing all unitary reps with
fixed LKT (x,lambda) and infl char in the FPP. Functions are meant to
use a Param_has Uhash containing a list of known unitary reps (like
Arthur's special unipotent ones) in order to avoid doing difficult
is_unitary calculations.

Throughout, the VertexData vd is meant to be the list of all vertices
in the FPP (that are fixed by the distinguished involution), and a
lookup function.

Attached to theta = x.involution and dlambda are

Perm = vec (size = number of vertices of FPP)
{mapAct = vec (size = number of vertices of FPP)}
Lvd = VertexData (vertex infinitesimal chars v in the FPP of Params
      		 (x, lambda v))

Here Perm is a partially defined permutation of order two of (indices
for) vd.list: it can happen that

- Perm[i] = i (fixed vertex v_i, so (x,lambda,v_i) is a Param of infl char
v_i); or

- Perm[j] = k != j, and Perm[k] = j, so (x,lambda, (v_j+v_k)/2) is a Param
  of infl char (v_j + v_k)/2; or

- Perm[ell] = -1, in which case v_ell has nothing to do with FPP Params
  at (x,lambda)

Say there are P fixed i and Q pairs (j,k). Then Lvd.list is the P+Q
vertices v_i and (v_j+v_k)/2, numbered in some way (probably not
reasonable).

{mapAct is a partially defined map from the indices for vd.list to the
indices for Lvd.list.

If Perm[i] = i, then mapAct[i] = index of v_i in Lvd.list

If Perm[j] = k != j, then mapAct[j] = mapAct[k] = mapAct[j] =
number of (v_j+v_k)/2 in Lvd.list

For other ell, mapAct[ell] = -1.}

Suppose (a_0,...,a_d) are the vertex numbers (indices in vd.list) of a d-diml face of the
FPP. Then this face meets FPP Params at (x,lambda) if and only if
(a_0,...,a_d) consists of p entries with Perm[a_i] = a_i and 2q
entries (a_j, a_k) exchanged by Perm (and no -1 entries). In this case
our face meets the FPP infl chars in a face of dimension p+q-1, with
vertices the fixed a_i and the various (a_j+a_k)/2.

The function localFD_Lvd(x, lambda, vd) computes (Lvd, Perm{, mapAct}).

Each d-dimensional (local) face at (x,lambda) is referred to by the
vec of its d+1 indices in Lvd.list. Appended to the end of this vec is
a single integer giving the location of the K_character of the local
face in a KTypePol_hash pol_hash.

There are four main functions, each taking either a long argument

(x, lambda, vd, LVD, Perm{, mapAct}, pol_hash, Uhash)

if you already have these in hand, or a short argument

(x, lambda, Uhash).

Functions each produce a list of all Params (x, lambda, nu_j), each
the barycenter of its local face, each having weakly dominant
infinitesimal character in the FPP (but possibly not final), and each
having all Langlands quotients unitary. These unitary reps are also
added to Uhash.

Here is a description of the four algorithms between these.

*******************
local_test_GEO_hash_dumb

This finds all vertices, then all edges, and computes the graph; then
removes all nonunitary vertices and edges.

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[D] faces; then makes a directed graph, and
eliminates all nonunitary faces.

The version def_dumb (invoked by def_flag = true, which is the
default) does unitarity tests using is_unitary_def_test.
*******************
local_test_GEO_hash
This finds all unitary-to-hts[0] vertices, then all unitary-to-hts[0]
edges.

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[D] faces; then makes a directed graph, and
eliminates all faces failing is-unitary-to-hts[D].

Now it has all faces of all dimensions passing is-unitary-to-hts[top
dim -1]. From these it makes a graph, and computes is_unitary.
*******************
local_test_GEO_hash2

Finds ALL vertices, then ALL edges; then makes a graph, and discards
all vertices and edges failing is_unitary_to_hts[0].

Rest is same as local_test_GEO_hash. This version seems faster because
use of the graph up to dimension 1 reduces the number of
is_unitary_to_hts[0] tests.
********************
local_test_GEO_hash_one_level

Assesses the "difficulty" of this case. If it's relatively easy,
reverts to local_test_GEO_hash2. Otherwise...

Finds ALL vertices, then ALL edges; then makes a graph, and discards
all vertices and edges failing is_unitary_to_hts[0, 1, ... ,
one_level].

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[one_level] faces; then makes a directed graph, and
eliminates all D+!-diml faces failing is-unitary-to-hts[one_level].

Now it has all faces of all dimensions passing
is-unitary-to-hts[one_level]. From these it makes a graph, and
computes is_unitary using is_unitary_test([one_level+1,...,last_level])
}

{given a sequence hts of hts to test, is_unitary_to_ht(p, hts~[0]) and
is_unitary_to_hts(p, hts) give the same result. If true, prefer using
the second. This seeks to eliminate easy cases by is_unitary_to_ht(p,
hts[0]) before trying the difficult is_unitary_to_ht(p,hts~[0])}
set prefer_to_hts = true

{. If "true," then calculations of unitary reps of a certain LKT
compute also the unitary deformations of these, with bigger
LKT's. This is unimportant for calculating say the spherical FPP
unitary dual, but very helpful with the FULL FPP unitary
dual. Therefore the functions FPP_unitary_hash... set this flag to
"true".}
set deform_flag = false

{. If "true," then some local FPP calculations revert to simpler (?)
   forms in "simple" cases.}
set revert_flag = true

{If "false", use the old version of one_level, in which vertex/edge calcs
are done immediately to ONE_HT}
set step_flag = true

{If "true", then hash_dumb uses real_dumb, which does less to_ht}
set real_flag = false

{If "true", then hash_dumb uses is_unitary_def_test, and hts are calculated with deform_hts}
set def_flag = false {true}

{if "false" use next_heights instead of short_hts, to avoid calculating
deform (KL calculations). So prefer false for rank \ge 7?}
set short_hts_flag = false

{For (x,lambda) such that to_ht rarely helps, this will be set to false}
set to_ht_flag = true

{prefer to use function is_unitary_test_big_simple_interrupt}
set test_interrupt_flag = true

set long_out_flag = false

{If true, use bottom_layer_interrupted}
set bl_interrupt_flag = false

{If true, use bottom_layer_stepped}
set bl_step_flag = false

{number of different shifts to try in bl_interrupt and bl_step}
set bl_step_count = 2

{how much to increase the shift at each step}
set bl_step_size = 5

{almost always it makes sense to preload the Arthur unipotent
reps. But not in a few test situations.}
set unip_flag = true

{if true, then more_bottom has already been applied where we are}
set more_after_flag = false

{if true, then min_bottom has already been applied where we are}
set min_after_flag = false

{if KGB number is below this times #KGB, use is_unitary rather than is_unitary_to_ht}
{set low_KGB_frac = rat: 1/2}

set difficulty(Param p) = rat:
    let rA = HTA(p)
    in if rA=0 then 0
       else rA/HT(p.real_form,p.infinitesimal_character)
       fi

{Integer between 0 and 100; integer part of 100*difficulty}
set approxDiff(Param p) = int:
    let q = difficulty(p)
    in (q.numer *100)\q.denom

{rational number, between 0 and 1 on FPP: how nu compares to rho in HT.
0 means tempered}
set difficultyA(Param p) = rat:
    let rA = HTA(p), G = p.real_form
    in rA/((G.rho)*(G.two_rho_check))

{Nonneg integer between 0 and 100; integer part of 100*difficultyA}
set approxDiffA(Param p) = int:
    let q = difficultyA(p)
    in (q.numer *100)\q.denom

{rational for increasing (stretcher > 1) or decreasing (stretcher < 1) the number of to_ht tests}
set stretcher = rat: 1/1

{meant to store bottom layer K-types}
set bl_KHash = make_KType_hash()

{ Block of p, including zero parameters. Relevant because that's where
KL calculations need to happen }
set full_block(Param p) = [Param]:
let G = p.real_form
in for q in block_of(translate_param_by(p, G.two_rho))
   do translate_param_by(q, -G.two_rho)
   od
{in is_unitary_to_ht(N), KL calculations live in this subset of
full_block}
set full_block_to_ht(Param p, int N) = [Param]:
    for q in full_block(p)
    do if height(q) <= N then [q] else [] fi od.##

set ht_saving(Param p, int N) = rat:
    #full_block_to_ht(p,N)/#full_block(p)

{ between 0 and 100. SMALL means is_unitary_to_ht is likely to be
faster than is_unitary.

If N \ge height(p), then full_block_to_ht(p) always includes p; so

0 < ht_saving(p,N) \le 1.

Therefore 0 \le approx_ht_saving(p,N) \le 100}
set approx_ht_saving(Param p, int N) = int:
    let rp = reducibility_points(p)
    then result = int:
    	 if #rp = 0 then 0
	 else let r = ht_saving(p*rp~[0],N)
    	      in (r.numer *100)\r.denom
	 fi
    in result

set pMAX = parameter(GL(1,R),0,[0]/1,[0]/1)
set pmax(KGBElt x, ratvec lambda, LocalVertexData Lvd) = Param:
    if pMAX.x = x and pMAX.lambda = lambda then return pMAX fi;
    let G = x.real_form
    then thetaMinus = x.involution - 1, BF = invariant_form(G)
    then max_loc = max_loc(for v in Lvd.list
    		  	   do G.two_rho_check*dominant(G, thetaMinus*v)
			   od)
    then () = pMAX :=parameter(x,lambda, Lvd.list[max_loc])
    in pMAX

set pmax(KGBElt x, ratvec lambda) = Param:
    let Lvd = Lvd(x,lambda)
    in pmax(x, lambda, Lvd)

{computes directed graph of local faces. Output GraphData is
[[int]],[[int]] giving equivalence classes and the graph. Next output
[vec]s are IUCL and classListByFace}
{9/25/23: have extra coord in FaceVertsKHash to record # Langlands quotients}
set localGraphK([[FaceVertsKHash]] LFvertsK) = (GraphData, [vec],[vec]):
    {let () = if face_verbose then prints("start to compute face graph K")
    	     fi}
    let start = elapsed_ms()
    then (eq,gr) = GraphData: up_data(LFvertsK)
    {then() = prints("number of graph equivalence classes = ",#eq)}
    then classListByFace = [vec]: class_lists(LFvertsK,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
    then time = elapsed_ms() - start
    { then () = if time_verbose
	      then prints("     ", print_time_string(time),
	           " for localGraphK calculation ") fi }
    in ((eq,gr), IUCL, classListByFace)

{here just require K-characters to match to level}
set localGraphK([[FaceVertsKHash]] FDKH, KTypePol_hash pol_hash, int level) =
    (GraphData, [vec],[vec]):
    let () = if face_verbose then prints(new_line,"start to compute face graph K to level ",
    	     		      	   			  level)
    	     fi
    then start = elapsed_ms()
    then (eq,gr) = GraphData: up_data(FDKH,pol_hash,level)
    {then () = for v in eq do prints(v) od}
    {then() = prints("number of graph equivalence classes to height = ",#eq)}
    then classListByFace = [vec]: class_lists(FDKH,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr)
    { then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   " for localGraphK calculation") fi}
	 in ((eq,gr), IUCL, classListByFace)

{classes have common value of red_count, so same K-character}
set localGraphRed([[FaceVertsIndex]] LF) = ([[int]], [vec]):
    let (eq,gr) = GraphData: K_graph_data(LF)
    then classListByFace = [vec]: class_lists(LF,(eq,gr))
    in (eq, classListByFace)

set look_up_vertices ([ratvec] vertices, [int] face)=[ratvec]:
   for n in face do vertices[n] od

set remove_closure ([vec] short,[vec] long) =[vec]:
  ##for v in short
    do if any(for w in long do sorted_is_subset(v,w) od)
       then [] else [v]
       fi
    od

set remove_closure ([[vec]] all, int k) =[[vec]]:
   for level@i in all do if i<k
	       then remove_closure (level,all[k])
	       else level
	       fi od

{returns the collection of unipotent points in list, as coords in list. If (x,lambda)
 has more than one LKT, only keep the unipotent irrs having ALL these LKTs.}
set local_unipotent_classes(KGBElt x, ratvec lambda, VertexData (list,lookup)) = vec:
(   let () = if face_verbose
    	     then prints("start local_unipotent_classes")
	     fi
    then G = x.real_form
    then st = G.dual.Springer_table
    in if not(is_split(G) and (x=x_open(G)) and (lambda = G.rho))
       then for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
      	      in if m0 >= 0 and #finalize(parameter(x,lambda,gamma)) = 1 and
	      	 GK_dim(parameter(x,lambda,gamma)) = dim(st.dual_map(O))/2
		 then [m0]
		 else []
		 fi
	   od.##
	else for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
     	       in if m0 >= 0
	       	  then [m0]
		  else []
		  fi
	   od.##
	fi
)

{inserts special unipotent reps in unitary_hash}
set unipotents_to_hash(RealForm G, Param_hash Uhash) = void:
    if unip_flag
    then for p in unipotent_representations(G) do Uhash.match(p) od
    else ()
    fi

{add only those unipotent reps of Gsc factoring to a quotient G, with M: X*(G1) -->
X*(G) the corr wt inclusion}
set unipotents_to_hash(RealForm G, RealForm Gsc, Param_hash Uhash, mat M) = void:
    if unip_flag
    then for psc in unipotent_representations(Gsc)
    	 do if solve(M,psc.lambda_minus_rho).any
       	    then for  p in sc_descends(psc, G, M)
	    	 do Uhash.match(p)
	    	 od
       	    fi
         od
    else ()
    fi

{assume Gsc --> G corrs to M: X*(G) --> X*(Gsc); assume Usc_hash is
reps of Gsc; put in U_hash those descending to G}
set descend_to_quotient(RealForm G, Param_hash Usc_hash, Param_hash U_hash, mat M) = void:
    for j:Usc_hash.size()
    do let psc = Usc_hash.index(j)
       in if solve(M, psc.lambda_minus_rho).any
       	  then for p in sc_descends(psc, G, M)
	       do U_hash.match(p)
	       od
	  fi
    od

{inserts special unipotent reps in [unitary_hash]; assumed to have one
 for each KGBElt}
set unipotents_to_hashes(RealForm G, [Param_hash] Uhashes) = void:
    if unip_flag
    then for p in unipotent_representations(G)
    	      do let (,xnum) = %p.x
	         in Uhashes[xnum].match(p)
	      od
    else ()
    fi

{whether to fill in statuses for known unitaries in local_testK_hash
and local_test_hash}
{separate flag KUKU_flag in FPP_faces_herm.at controls whether to use known_unitaries
or KU}
set KU_flag = true

{count how often nonunitary induction identifies nonunitary rep}
set NU_ind_counter = 0

{count how often unitary induction identifies unitary rep}
set U_ind_counter = 0

{whether to fill in statuses for known non-unitaries in local_testK_hash
and local_test_hash}
set KNU_flag = false

{whether to look at ind_cand_params to determine unitarity}
set ICPU_flag = false {true becomes very slow in rk 6}

{whether to look at ind_cand_params to determine nonunitarity}
set ICPNU_flag = false {true becomes very slow in rk 6}

{if true, functions in FPP_global pass through KGB backwards}
set tilde_flag = false

{set this to true to use wiggle tests in know_more mode in local_testK_hash_bottom_layer,
which handles the most cases}
set wiggle_flag0 = false

{set this to false to avoid wiggle tests in know_more mode later on}
set wiggle_flag = true

{if the testing in these functions is happening after
more_bottom_layer, then negative results should be recorded in
more_bad_hash.}

{test candidate classes with (new) tester; delete
 from LFVKH faces established to be nonunitary in this way. Output is new
 shorter list of candidate faces. Lvd is LOCAL LocalVertexData}
 {If tester is to_ht, then OK for all eq to be computed to_ht. Trickier for bottom_layer.}
 {Seems to require that equivalence classes be for ENTIRE K-char, not to height}
 {called lines 2183...}
set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KTypePol_hash pol_hash,
    (Param->bool) tester, int HT, Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes as known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				    then ()=newStatuses:= downdateUclassesB(newStatuses, gr, k, "T")
				    in newStatuses[k] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
    then QG = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_local_flag = bool: {whether Dirac_best could help here}
    	 if not Dirac_best_local_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then Q = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound_cap(mu,Dirac_best_steps) od
	      then bestbd = min(for (,,bs) in best_bounds
	      	   	    	do bs~[0]
				od)
	     then index = first(for v in Lvd.list
	     	  	  	do @bool: Q(v,v) > bestbd
				od)
	     in if index.>=
	     	then DiracBestBD:= bestbd; QG:=Q; true
		else false
		fi
	 fi
    then () = if fund_face_verbose
    	      then prints("     Examining ",NumClasses," classes in local_testK_hash; ",
	      count(for ans in newStatuses do ans[0] = "T" od)," are known unitary.")
	      fi
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash, ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and {removing ~ costs 5% in Spin(4,4)}
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		     then (d,j) = coords(FVKH,C[0])
	      	     then verts = vec: FVKH[d][j][:d+1]
		     then gamma = face_bary(Lvd,verts)
		     then pC = parameter(x, lambda, gamma)
	      	     then ps = monomials(finalize(pC))
		     then KCF = pol_hash.index(FVKH[d][j][d+red_shift+1])
		     then test_DB = (not temp_Dirac_best_local_flag) or (QG(gamma,gamma) <= DiracBestBD)
		     	  or DiracBestTest(pC,HT,KCF)
		     then () = if not test_DB
		       	       then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F");
			       	    newStatuses[k] := "F"
			       fi {not test_DB}
		     {then () = prints(new_line,"k = ",k,", ICPNU_flag = ",ICPNU_flag,", ICPU_flag = ",ICPU_flag)
		     then () = prints("before ICPNU, newStatuses = ",newStatuses)}
		     then () = if newStatuses[k] = "?" and ICPNU_flag {test for non-unitary}
		       	       then if any(for p in ps
		       	       	    	   do any(for pi in ind_cand_params(p)
				      	       	  do @bool:
						     let not_ans = not is_unitary_hash_big_SIMPLE(pi)
						     in if more_after_flag and not_ans
						     	then more_bad_hash.match(pi)
							fi;
							if min_after_flag and not_ans
							then bad_hash.match(pi)
							fi; not_ans
					       	  od)
				   	   od)
		       	     	     then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
				     	  NU_ind_counter+:=1;
			     	  	  newStatuses[k] := "F"
			     	    fi
		       		fi
		     {then () = prints("before ICPU, newStatuses = ",newStatuses)}
		     then () = if newStatuses[k] = "?" and ICPU_flag {test for unitary}
		       	       then if all(for p in ps
		       	       	    	   do #ind_cand_params(p) > 0
					      and all(for pi in ind_cand_params(p)
				      	       	       do @bool: let ans = is_unitary_hash_big_SIMPLE(pi)
						       	  	 in if more_after_flag and not ans
							     	    then more_bad_hash.match(pi)
							     	    fi;
								    if min_after_flag and not ans
							     	    then bad_hash.match(pi)
							     	    fi; ans
					       	       od)
				   	   od)
		       	     	     then newStatuses[k] := "T";
				     	  U_ind_counter+:=1
			     	    fi
		       		fi
		     {then () = prints("before NEWU, newStatuses = ",newStatuses)}
	             in if{NEWU} newStatuses[k] = "?"
		     	then if ps[0].nu.= or all(for p in ps do Uhash.lookup(p).>= or tester(p) od)
		     	     then newStatuses[k]:= "T"
		     	     else newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     	     	; newStatuses[k] := "F"
			     fi
		     	fi{NEWU}
		 fi {newStatuses[k] = "?"}
	      od
     {then () = prints("after first loop, newStatuses = ",newStatuses)}
     then () = if fund_face_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq
	       	    do if newStatuses[m][0] = "T"
     	     	       then {for k in C
		       	    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od}
			    for k in C
			    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od
		       fi {newStatuses[m][0] = "T"}
		    od
     {then () = if #FVKH = 3 then prints(FVKHnew[2]) fi}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KTypePol_hash pol_hash,
    (Param->bool) tester, int HT, Param_hash Uhash) = [[FaceVertsKHash]]:
    local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, pol_hash, tester, HT, Uhash,
    is_unitary_hash_big_SIMPLE@Param)

set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KTypePol_hash pol_hash,
    int ht, Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let tester = ((Param->bool): (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, ht))
     in local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, pol_hash, tester, ht,
     Uhash, fancy_tester)

set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KTypePol_hash pol_hash,
    int ht, Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let tester = ((Param->bool): (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, ht))
     in local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, pol_hash, tester, ht, Uhash,
     fancy_tester)

set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KTypePol_hash pol_hash,
    int ht, Param_hash Uhash) = [[FaceVertsKHash]]:
    let tester = ((Param->bool): (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, ht))
     in local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, pol_hash, tester, ht, Uhash)



{test candidate classes with (new) tester. Assume know_lower_flag is true,
 and use that to get rid of some candidates. Delete
 from LFVKH faces established to be nonunitary in this way. Output is new
 shorter list of candidate faces. Lvd is LOCAL VertexData}
set local_testK_hash_know_lower(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,  KTypePol_hash pol_hash,
    (Param->bool) tester, Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then QG = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_local_flag = bool: {whether Dirac_best could help here}
    	 if not Dirac_best_local_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then Q = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound_cap(mu,Dirac_best_steps) od
	      then bestbd = min(for (,,bs) in best_bounds
	      	   	    	do bs~[0]
				od)
	     then index = first(for v in Lvd.list
	     	  	  	do @bool: Q(v,v) > bestbd
				od)
	     in if index.>=
	     	then DiracBestBD:= bestbd; QG:=Q; true
		else false
		fi
	 fi
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
   { then () = if KNU_flag {and #FVKH = 2}
    	      then let knownNonUnitaries = known_non_unitaries(NUhash, x, lambda, Lvd, FVKH)
    	      	   then () = for list@d in knownNonUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "F"
	    	 		od
	      		     od
		   in ()
	       fi}
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash_know_lower, ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and {removing ~ costs 5% in Spin(4,4)}
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0])
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then gamma = face_bary(Lvd,verts)
		  then pC = parameter(x, lambda, gamma)
		  {then () = prints("d = ",d,", pC = ",pC)}
	      	  then ps = monomials(finalize(pC))
		  then KCF = pol_hash.index(FVKH[d][j][d+red_shift+1])
		  then test_DB = (not temp_Dirac_best_local_flag) or (QG(gamma,gamma) <= DiracBestBD)
		       	       	 or DiracBestTest(pC,KCF)
		  then () = if not test_DB
		       	    then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
			    elif not is_final(pC)
		      	    then if all(for q in ps do @bool: is_finished(q.x, q.lambda) and
			       	       	       	    	     (Uhash.lookup(q) >= 0) od)
			   	 then newStatuses[k] := "T"
			   	 elif any(for q in ps do @bool: is_finished(q.x,q.lambda) and
				    	 (Uhash.lookup(q) = -1) od)
			         then {prints("nonfinal, k = ",k, ", gr = ",gr);}
			   	      newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); "F"
			   	 fi
			     fi {not test_DB}
		   then () = if  newStatuses[k] = "?" and ICPNU_flag {test for non-unitary}
		       	    then if any(for p in ps
				    	do any(for pi in ind_cand_params(p)
			    	       	       do not is_unitary_hash_big_SIMPLE(pi)
				       	       od)
				    	od)
		       	          then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
				       NU_ind_counter+:=1;
			          {prints("know_lower ICP F: ",pC);}
			     	       newStatuses[k] := "F"
			         fi {any p}
		       	     fi {ICP_flag}
		   then () = if  newStatuses[k] = "?" and ICPU_flag {test for unitary}
		       	       then if all(for p in ps
		       	       	    	   do #ind_cand_params(p) > 0
					      and all(for pi in ind_cand_params(p)
				      	       	       do is_unitary_hash_big_SIMPLE(pi)
					       	       od)
				   	   od)
		       	     	     then U_ind_counter+:=1;
				     	  newStatuses[k] := "T"
			     	  {prints("know_lower ICP T: ",parameter(x,lambda,face_bary(Lvd,verts)));}
			     	    fi
		       		fi
	          in if newStatuses[k] = "?"
		     	and not is_final(pC) and all(for q in ps
		     	    		     	 do @bool: is_finished(q.x,q.lambda)
						    and Uhash.lookup(q).>=
					    	 od)
		     then newStatuses[k]:="T"
		     elif {know_lower_flag and} any(for q in ps
		     	    	   	    do @bool: is_finished(q.x,q.lambda)
					    and (Uhash.lookup(q) = -1)
					    od)
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     ; newStatuses[k] := "F"
		     fi;
		     if{NEWU} newStatuses[k] = "?"
		     	then if{all} all(for p in ps do Uhash.lookup(p).>= or tester(p) od)
			     {if p is unitary, tester(p) may record that fact in Uhash}
		     	     then newStatuses[k]:= "T"
		     	     else newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     	     ; newStatuses[k] := "F"
		     	     fi{all}
		     fi{NEWU}
	         fi
	      od
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq
	       	    do if newStatuses[m][0] = "T"
     	     	       then for k in C
			    do let (d,j) = coords(FVKH,k)
			       then verts = vec: FVKH[d][j][:d+1]
			       then pC = parameter(x, lambda, face_bary(Lvd, verts))
			       then ps = monomials(finalize(pC))
			       then () = for q in ps do Uhash.match({herm_center(}q{)}) od
			       in FVKHnew[d] #:= FVKH[d][j]
			    od
		       fi
		    od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_know_lower; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

set local_testK_hash_know_lower(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KTypePol_hash pol_hash,
    (Param->bool) tester, Param_hash Uhash) = [[FaceVertsKHash]]:
    local_testK_hash_know_lower(x, lambda, Lvd, FVKH, eq, gr, classListByFace, pol_hash,
    tester, Uhash, is_unitary_hash_big_SIMPLE@Param)

{Delete from LFVKH faces established to be nonunitary using
min_bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph. If U_flag = true, then test
for unitarity.}
set local_testK_hash_min_bottom_layer(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    KTypePol_hash pol_hash, Param_hash Uhash, (Param -> bool) fancy_tester) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq
    	, printInterval = int: 1, red_shift = if red_count_flag then 1 else 0 fi
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then QG = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_local_flag = bool: {whether Dirac_best could help here}
    	 if not Dirac_best_local_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then Q = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound_cap(mu,Dirac_best_steps) od
	      then bestbd = min(for (,,bs) in best_bounds
	      	   	    	do bs~[0]
				od)
	     then index = first(for v in Lvd.list
	     	  	  	do @bool: Q(v,v) > bestbd
				od)
	     in if index.>=
	     	then DiracBestBD:= bestbd; QG:=Q; true
		else false
		fi
	 fi
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
{next if possible label classes known to be nonunitary because they finalize or deform to nonunitary}
    then () = for k:NumClasses
    	     ~do if newStatuses[k] = "?"
		 then let C=eq[k] {should run backwards for update to be effective}
		      then (d,j) = coords(FVKH,C~[0]) {d is dimension of face. Tilde picks a largest-dimensional face in C.}
	      	      then verts = vec: FVKH[d][j][:d+1]
		      then gamma = face_bary(Lvd,verts)
		      then ratverts = [ratvec]: for m in verts do Lvd.list[m] od
		      {then sigma = sum(#lambda, ratverts)}
		      then pC = parameter(x, lambda, gamma) {sigma/(d+1))}
		      then KCF = pol_hash.index(FVKH[d][j][d+red_shift+1])
		      then pCdef = if not is_final(pC)
		      	   	   then monomials(finalize(pC))
		  		   elif wiggle_flag0 and d > 0
		  		   then {let () = char_counter.use()
				   	then startCF = elapsed_ms()}
				   	let CF = character_formula(finalize(pC))
					{then () = charTime +:= elapsed_ms() - startCF}
		       		   	in  monomials(composition_series((sum(x.real_form,
		       	   		    for j:d+1 {v in ratverts}
			   		    do wiggle(CF, face_bary(Lvd,verts[:j]##verts[j+1:]))
					    {(sigma - v)/d)}
			   		    od)))) {proper_facet_deformed(pCtop)}
		  	           else []
		  		   fi {not is_final pC}
{this function is invoked only on the 0/1 faces in bottom_layer. That's a relatively long list,
      with few wiggles; the cost of computing proper_facet_deformed(pC) seems not justified by
      the few edges eliminated}
		       then test_DB = (not temp_Dirac_best_local_flag) or (QG(gamma,gamma) <= DiracBestBD)
		       	    or DiracBestTest(pC,KCF) 
		   in if not test_DB
		      then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		      elif not is_final(pC)
		      then if all(for q in pCdef do @bool: is_finished(q.x, q.lambda) and
			       	       	       	    	     (Uhash.lookup(q) >= 0) od)
			   then newStatuses[k] := "T"
			   elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 (Uhash.lookup(q) = -1) od)
			   then {prints("nonfinal, k = ",k, ", gr = ",gr);}
			   newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); "F"
			   fi
		      else {now pC is final, and pCdef consists of wiggled Params with smaller x}
			  if any(for q in pCdef do @bool:  is_finished(q.x,q.lambda)
				       	       and (Uhash.lookup(q) = -1) od)
			  then {prints("final, k = ",k, ", gr = ",gr);}
			  newStatuses := updateNUclassesB(newStatuses, gr, k,"F");
			       newStatuses[k] := "F"
		           fi {any}
		      fi {not test_DB}
		fi {newStatuses[k]}
	      od {k:NumClasses}
    {then () = prints("no test newStatuses = ",newStatuses)}
    then () = if fund_face_verbose {and NumClasses > 100}
    then prints(); prints("start local_testK_hash_min_bottom_layer ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0]) {a lowest-diml face in C; least likely to be final}
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	  then ps = monomials(finalize(pC))
                  then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	      then true
			      elif not all(for p in ps
		     	  	     	   do @bool: if #ps = 1
					      	     then min_bottom_elim_factors(p,pC,pol_hash.index(FVKH[d][j][d+red_shift+1]))
						     else min_bottom_elim_factors(p,pC)
						     fi
					   od)
				then false
			      else true
			      fi
     		  in if not test
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     else newStatuses[k] := "T"
		     fi
		  fi {newStatuses[k] = "?"}
		  od {NumClasses}
     {then () = prints("tested newStatuses = ",newStatuses)}
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_min_bottom_layer; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

set local_testK_hash_min_bottom_layer(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    KTypePol_hash pol_hash, Param_hash Uhash) = [[FaceVertsKHash]]:
    local_testK_hash_min_bottom_layer(x, lambda, Lvd, FVKH, eq, gr, classListByFace,
    pol_hash, Uhash, is_unitary_hash_big_SIMPLE@Param)

{when the non-minimal parabolics are used at the end, how much above
height(p) to look at K-types.  A larger number finds more nonunitary,
takes longer}
set more_shift_level = int: 0

set more_shift(int n) = void:
    let () = more_flag:=true
    in more_shift_level:=n

{if true, then test for unitarity from beginning of bottom_layer}
{turns out to slow things down a bit: better to construct more
candidates, because they will lead to a graph with fewer components,
so fewer is_unitary tests. For E6_s, U_flag = false needs 833 tests;
U_flag = true needs 1001}
set U_flag = false

{Delete from LFVKH faces established to be nonunitary using
known_lower, bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph. If U_flag = true, then test
for unitarity. Should be applied only to OUTPUT of local_testK_hash_min_bottom_layer}
{AND Dirac_best??}
set local_testK_hash_bottom_layer_more(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
     [KGPElt] maxQs, [QKL_bottom_data] datas, KTypePol_hash pol_hash, Param_hash Uhash) =
    			    [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    {then () = assert(all(for (Q,) in datas do #(Q.S) < #lambda od),"Q=G occurs here")}
    then temp_Dirac_best_local_flag = bool: {whether Dirac_best could help here}
    	 if not Dirac_best_local_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then Q = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
	      	   	    	do bs~[0]
				od)
	     then index = first(for v in Lvd.list
	     	  	  	do @bool: Q(v,v) > bestbd
				od)
	     in if index.>=
	     	then true
		else false
		fi
	 fi
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash_bottom_layer ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		     then (d,j) = coords(FVKH,C[0])
		     {C[0] is a lowest-diml face in C; least likely to be final}
		     {C~[0] is highest-diml, so most likely to fail Dirac}
	      	     then verts = vec: FVKH[d][j][:d+1]
		     then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	     then ps = monomials(finalize(pC))
		     then KCF = pol_hash.index(FVKH[d][j][d+red_shift+1])
		     then test_DB = (not temp_Dirac_best_local_flag) or DiracBestTest(pC,KCF)
                     then test = if not test_DB
		     	       	 then false
				 elif all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	         then true
			      	 elif #ps = 1 {otherwise the K-char is wrong!}{)}
				 then bottom_elim_factors_more(ps[0], pC, datas,
				      pol_hash.index(FVKH[d][j][d+red_shift+1]))
			         else all(for p in ps
				       do @bool: bottom_elim_factors_more(p, pC, datas)
				       od)
			         fi
     		     in if not test
		     	then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     	else newStatuses[k] := "T"
		     	fi
		fi {newStatuses[k] = "?"}
		od {NumClasses}
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_bottom_layer_more; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

{Assume datass is built of bottom layer K-types up to Ds[0], enumerated in KHash.
Find first j from 1 where [Ds[j-1],Ds[j]) gives more bottom layer K-types; add those to KHash;
replace Ds by Ds[j:]. }
set add_datas(Param p, KGPElt Qmin, {KType_hash KHash,} [int] Ds) =
    ([QKL_bottom_data], [int]):
    let Es = [Ds~[0]], old_size = bl_KHash.size()
    then answer = [(KGPElt,[(KType,[KType])])]: []
    then () = if #Ds <= 1 then return (answer, Es) fi
    then () = for j:#Ds - 1 from 1
    	      do let datas = if Qs2_flag {[(KGPElt,[(KType,[KType])])]}
	     	      	     then for mu in LKTs(p)
			     	  do if Qs2B_flag
				     then bottom_factors(bottom_K_type_Qs2B(mu,Qmin,height(p),Ds[j]))
				     else for (Q,pL) in max_Qps(p)
				       	  do bottom_K_type_Qs2(mu,Q,height(p),Ds[j])
					  od
				     fi
				  od.##
			     else bottom_factors(bottom_K_type_Qs(p,Qmin,height(p), Ds[j]))
			     fi {Qs2_flag}
		 then new_datas = for (Q,list) in datas
		      		  do (Q, for (tau,local) in list
				     	 do let M = bl_KHash.size()
				     	    in if bl_KHash.match(tau) = M
					       then [(tau,local)]
					       else []
					       fi
				    	 od.##)
				  od
		 in if bl_KHash.size() > old_size {we found some new bottom layer K-types}
       	  	    then Es:= Ds[j:];
		    	 answer:=new_datas;
			 break
		    fi
	     od
    in (answer, Es)

set ktypes([QKL_bottom_data] datas) = [KType]:
    for (Q,list) in datas
    do for (tau,) in list
       do tau
       od
    od.##

set ktypes([[(KType,[KType])]] datas) = [KType]:
    for list in datas
    do for (tau,) in list
       do tau
       od
    od.##

{Delete from LFVKH faces established to be nonunitary using
known_lower, bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph. If U_flag = true, then test
for unitarity. Should be applied only to OUTPUT of local_testK_hash_min_bottom_layer}
{Just precompute FIRST datas; later as needed. Ds[0] is height for initial datas}
set local_testK_hash_bottom_layer_more_step(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KGPElt Qmin,
     [KGPElt] maxQs, [QKL_bottom_data] datas, [int] Ds{, KTypePol MU}, KTypePol_hash pol_hash,
     Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				    then ()=newStatuses:= downdateUclassesB(newStatuses, gr, k, "T")
				    in newStatuses[k] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
    then (datasNEW, DsNEW) = add_datas(parameter(x,lambda,0*lambda), Qmin, Ds)
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash_bottom_layer_more_step ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0]) {a lowest-diml face in C; least likely to be final}
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	  then ps = monomials(finalize(pC))
		  {then KHash = make_KType_hash()}
		  then () = for (,Klist) in datas
		       	    do for (tau,) in Klist
			       do bl_KHash.match(tau)
			       od
			    od
		  then testDs = Ds
                  then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	      then true
			      elif #ps = 1 {otherwise the K-char is wrong!}{)}
				then let still_here = bottom_elim_factors_more(ps[0], pC,
				     	       		  datas, pol_hash.index(FVKH[d][j][d+red_shift+1]))
				     then () = if still_here
				     	       then still_here := bottom_elim_factors_more(ps[0],pC,datasNEW,
					       	  	     pol_hash.index(FVKH[d][j][d+red_shift+1]))
					       fi
				     in still_here

{
					       while still_here and #Ds > 1
				      	      	do let old_size = bl_KHash.size()
					   	   then (datasNEW, DsNEW) = add_datas(pC, Qmin, {KHash,} testDs)
						   {then () = prints(new_line, "x = ",x.number,", lambda = ",lambda)
						   then () = prints("Ds = ",Ds,", datas = ",ktypes(datas),
						     	  ", datasNew = ",ktypes(datasNEW))}
					   	   then () = datas := datasNEW
						   in if bl_KHash.size() > old_size
						      then testDs:=DsNEW;
						      	   still_here := {test with new datas}
							   bottom_elim_factors_more(ps[0], pC, datas,
							   	pol_hash.index(FVKH[d][j][d+red_shift+1]));
				                   	   if not still_here then break fi
						      else break
						      fi
					        od
}
			       else let still_here = all(for p in ps
				       	      	    do bottom_elim_factors_more(p, pC, datas)
				       		    od)
				    then () = if still_here
				   	      then still_here := all(for p in ps
							     do @bool: bottom_elim_factors_more(p, pC, datas)
							     od)
					      fi
				   in still_here
{

				      	     do let old_size = bl_KHash.size()
					        then (datasNEW, DsNEW) = add_datas(pC, Qmin, {KHash,} testDs)
						{then () = prints(new_line, "x = ",x.number,", lambda = ",lambda)
						then () = prints("Ds = ",Ds,", datas = ",ktypes(datas),
						     	  ", datasNew = ",ktypes(datasNEW))}
						then () = datas := datasNEW
					   	in if bl_KHash.size() > old_size
						   then testDs:=DsNEW;
							still_here :=
							 all(for p in ps
							     do @bool: bottom_elim_factors_more(p, pC, datas)
							     od);
				                        if not still_here then break fi
						   else break
						   fi
					     od
}
			       fi
     		  in if not test
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     else newStatuses[k] := "T"
		     fi
		  fi {newStatuses[k] = "?"}
		  od {NumClasses}
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if #Ds > 1 and fund_face_verbose
     	       then prints("at x = ",x.number,", lambda = ",lambda,"# datas = ",#datas,", #Ds = ",#Ds)
	       fi
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_bottom_layer_more_step; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

set local_testK_hash_bottom_layer_more_step(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KGPElt Qmin,
     [KGPElt] maxQs, [QKL_bottom_data] datas, [int] Ds{, KTypePol MU}, KTypePol_hash pol_hash,
     Param_hash Uhash) = [[FaceVertsKHash]]:
     local_testK_hash_bottom_layer_more_step(x, lambda, Lvd, FVKH, eq, gr, classListByFace,
     Qmin, maxQs, datas, Ds, {MU,} pol_hash, Uhash, is_unitary_hash_big_SIMPLE@Param) 

set ParamsByDim = [[Param]]: for d:16 do [] od
set LFDKHByDim = [[FaceVertsKHash]]: for d:16 do [] od

{takes the unitary Param's listed in LFDKHByDim and computes the K-character
 number in pol_hash}
set KcharsByDim() = [[int]]:
    for j:16 do for v in LFDKHByDim [j] do v[j+1] od od

{lists all distinct K-characters (by number in pol_hash)}
set AllKchars() = [int]:
    KcharsByDim().##.sort_u

set NumKchars() = int:
    #AllKchars()

set more_verbose =false

{ Input is candidate faces, and graph info. Output is the tester-unitary ones.
 use and update a complete list Uhash of known tester-unitary faces.
 try to compute and systematically use partial order on faces}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    (Param->bool) tester, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, start = elapsed_ms(){,
       NUhash = big_unitary_hash.nuhash(x.real_form)}
    then newStatuses = for m:NumClasses do "?" od
    then start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose and NumClasses > 100
    	      then prints("start local_test, ",NumClasses,
	      " equiv classes of faces")
	      fi
    {then start_by_dim = vec: for list in LFVH do #list od}
    then () = if KU_flag
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, LFVH, fancy_tester)
	      	   {then () = prints(knownUnitaries)}
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				   then ()=newStatuses:= downdateUclassesB(newStatuses, gr, k, "T")
				   in newStatuses[k] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
    {then () = if KNU_flag {and #FVKH = 2}
    	      then let knownNonUnitaries = known_non_unitaries(NUhash, x, lambda, Lvd, LFVH)
    	      	   then () = for list@d in knownNonUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "F"
	    	 		od
	      		     od
		   in ()
	       fi}
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
    	 for m:NumClasses
    	 ~do if fund_face_verbose and NumClasses > 100 and
	      	 m%printInterval = 0
	    then prints("examining equivalence class #"
	      ,m, "; so far ",unitary_test_counter.use_count()
	      ," 'is_unitary' tests.")
	      ; printInterval := (3*printInterval)\2 + 1
	    fi;
	        let C=eq[m]
	      	then (d,j) = coords(LFVH,C[0])
	      	then verts = vec: LFVH[d][j][:d+1]
		then pC = parameter(x, lambda, face_bary(Lvd, verts))
		  {first_param makes trouble in UParams list!}
	      	then ps = monomials(finalize(pC))
	      	in if{NEWU} (U_flag and (d <= 1) and test_string = " using local_test_GEO_hash_bottom_layer")
		   {vertices and edges have already been tested if U_flag is true}
		   	    or newStatuses[m][0] = "T"
			    or all(for p in ps
		   	    	   do @bool: Uhash.lookup(p).>= or (let ans = tester(p)
				      	     			   in if not ans
								      then if more_after_flag
									   then more_bad_hash.match(p)
									   elif min_after_flag
									   then bad_hash.match(p)
									   fi
								       fi; ans)
				   od)
		   then downdateUclassesB(newStatuses, gr, m, "T"); newStatuses[m]:="T";
		   	for i in C
		   	do let (e,k) = coords(LFVH,i)
			   then moreverts = vec: LFVH[e][k][:e+1]
			   then () = unitary_by_dim[e]+:=1
			   then q = parameter(x,lambda, face_bary(Lvd,moreverts))
			   then () = for q1 in monomials(finalize(q))
			   	     do Uhash.match({herm_center(}q1{)});
				     if deform_flag
				     then for q1d in facet_deformed_new(q1)
				     	  do Uhash.match({herm_center(}q1d{)})
					  od
				     fi
				     od
			   then () = if long_out_flag
		      	   	     then let () = ParamsByDim[e] #:=q
				     {ParamsByDim[d] := ParamsByDim[d]#q}
			   	     	  then ()=LFDKHByDim[e]#:=LFVH[e][k]
					  {LFDKHByDim[d]#LFVH[d][j]}
				     	  in ()
			   	     fi
		       	   in q
		    	od {list of tester unitary Params}
		   else updateNUclassesB(newStatuses, gr, m);
		   	newStatuses[m] := "F";
			[]
		   fi{NEWU}
	  od.##
    then () = if test_verbose or test_slightly_verbose
    	      then prints("tester unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
		 		print_time_string(elapsed_ms() - start))
	      fi
    in  UParams

{don't want to specify tester}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    local_test_hash(x, lambda, Lvd, LFVH, eq, gr, classListByFace,
    if test_interrupt_flag
    then is_unitary_test_big_SIMPLE_interrupt@Param
    else is_unitary_hash_big_SIMPLE@Param
    fi, Uhash, fancy_tester)

{don't want to specify fancy_tester}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[LocalFaceVertsKHash]] LFVH,
    [[int]] eq, [[int]] gr, [vec] classListByFace, (Param->bool) tester, Param_hash Uhash) = [Param]:
    local_test_hash(x, lambda, Lvd, LFVH, eq, gr, classListByFace, tester, Uhash,
    if test_interrupt_flag {up_mu_flag}
    then is_unitary_test_big_SIMPLE_interrupt@Param
    else is_unitary_hash_big_SIMPLE@Param
    fi)

{don't want to specify either}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[LocalFaceVertsKHash]] LFVH,
    [[int]] eq, [[int]] gr, [vec] classListByFace, Param_hash Uhash) = [Param]:
    local_test_hash(x, lambda, Lvd, LFVH, eq, gr, classListByFace, Uhash,
    if test_interrupt_flag {up_mu_flag}
    then is_unitary_test_big_SIMPLE_interrupt@Param
    else is_unitary_hash_big_SIMPLE@Param
    fi)

{meant to hold params p with pL unitary and p not}
{set surprise_hash = make_Param_hash()
set surprise_flag = false}

{if true, uses bottom_more at last step instead of is_unitary}
set mix_flag = false

{ Input is candidate faces, and graph info. Output is the unitary ones.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use partial order on faces.
IF mix_flag, DON'T assume the input params are already bottom layer positive
for minimal parabolic; try
to use larger ones.}  {NOW NOT USED}
set local_test_hash_bottom(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    [KGPElt] maxQs, [QKL_bottom_data] datas, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, newStatuses = for j:#eq do "?" od
    then start_count = unitary_test_counter.use_count(), red_shift = if red_count_flag then 1 else 0 fi
    then () = for k:NumClasses
             ~do if newStatuses[k] = "?"
                 then let C=eq[k] {should run backwards for update to be effective?}
                      then (d,j) = coords(LFVH,C[0]) {search C to look for largest d?}
                      then verts = vec: LFVH[d][j][:d+1]
		      {then ratverts = [ratvec]: for m in verts do Lvd.list[m] od}
		      {then sigma = sum(#lambda, ratverts)}
                      then pC = parameter(x, lambda, face_bary(Lvd,verts)) {,sigma/(d+1))}
                      then pCdef = if is_final(pC)
                                   then if wiggle_flag and d > 0
					then {let () = char_counter.use()
				   	     then startCF = elapsed_ms()}
				   	     let CF = character_formula(pC)
					     {then () = charTime +:= elapsed_ms() - startCF}
					     in monomials(composition_series((sum(x.real_form,
					     for j:d+1 {v in ratverts}
					     do wiggle(CF, face_bary(Lvd,verts[:j]##verts[j+1:]))
					     {(sigma - v)/d)}
					     od))))
							  {proper_facet_deformed(pC)}
					 else []
					 fi
                                    else monomials(finalize(pC))
                                    fi {is_final(pC)}
                       in if not is_final(pC)
			  then if all(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
			       	       	       (Uhash.lookup(q) >= 0) od)
                               then newStatuses[k] := "T"
                               elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 	 (Uhash.lookup(q) = -1) od)
                               then newStatuses:= updateNUclassesB(newStatuses, gr, k); "F"
                               fi {all (for q}
                          else {now pC is final, and pCdef consists of wiggled Params with smaller x}
                               if any(for q in pCdef do @bool:  is_finished(q.x,q.lambda) and
				       	       (Uhash.lookup(q) = -1) od)
                               then newStatuses := updateNUclassesB(newStatuses, gr, k);
				    	 newStatuses[k] := "F"
                               fi
                          fi {not is_final(pC)}
                   fi {newStatuses[k]}
               od
    then () = if fund_face_verbose and NumClasses > 100
    	      then prints("start local_test, ",NumClasses,
	      " equiv classes of faces")
	      fi
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
    	 for m:NumClasses
    	~do if fund_face_verbose and NumClasses > 100 and
	      	 ((NumClasses-m-1)%printInterval = 0)
	    then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",unitary_test_counter.use_count()
	      ," 'is_unitary' tests.")
	      ; printInterval := (3*printInterval)\2 + 1
	    fi
	    ;
	    let elim_more = true, p = parameter(x,lambda,0*lambda)
	    then test = bool:
	        if newStatuses[m] = "F"
	    	then false
		elif newStatuses[m] = "T"
		then true
	    	else let C=eq[m]
	      	     then (d,j) = coords(LFVH,C[0])
	      	     then verts = vec: LFVH[d][j][:d+1]
		  {first_param makes trouble in UParams list!}
		     then p_start_time = elapsed_ms()
		     then () = p := parameter(x, lambda, face_bary(Lvd, verts))
		     then () = if more_verbose then prints("testing parameter ",p) fi
	      	     then ps = monomials(finalize(p))
		     then () = if more_flag or mix_flag
			       then elim_more:= if #ps = 1
				    		then bottom_elim_factors_more(ps[0], p, datas, pol_hash.index(LFVH[d][j][d+red_shift+1]))
		                    		else all(for p1 in ps
		   	       	    	       	     	 do Uhash.lookup(p1).>= or {this can produce "isn't LKT message"}
			       	       	    	      	 bottom_elim_factors_more(p1, p, datas)
					      	    	 od)
				     	   	 fi
			        fi
		      in if not elim_more
		      	 then false {we got rid of p by bottom layer}
			 else all(for p1 in ps
			      	  do @bool: let ans = is_unitary_def_test_big_SIMPLE(p1)
				     	    in if d <= 1 and more_after_flag and not ans
				     	       then more_bad_hash.match(p1)
					       fi;
					       if d<=1 and min_after_flag and not ans
				     	       then bad_hash.match(p1)
					       fi; ans
				  od)
		     	 fi
		  fi {newStatuses[m]}
	      then () = if more_verbose then prints("your final answer was ",test) fi
	      in if test
		 then for i in eq[m]
		      do let (d,j) = coords(LFVH,i)
			 then verts = vec: LFVH[d][j][:d+1]
			 then () = unitary_by_dim[d]+:=1
			 then q = parameter(x,lambda, face_bary(Lvd,verts))
			 then () = for q1 in monomials(finalize(q))
			   	   do Uhash.match({herm_center(}q1{)});
				      if deform_flag
				      then for q1d in facet_deformed_new(q1)
				     	   do Uhash.match({herm_center(}q1d{)})
					   od
				      fi
				   od
			  then () = if long_out_flag
		      	   	    then let () = ParamsByDim[d] #:= q
			   	     	 then ()=LFDKHByDim[d] #:= LFVH[d][j]
				     	 in ()
			   	    fi
			  in q
		       od
		  else [] 
		  fi{test}
	     od.## {list of unitary Params}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
    in  UParams

{ Input is candidate faces, and graph info. Output is the unitary ones.}
set local_test_wiggle_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr,
    [vec] classListByFace, Param_hash Uhash) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, newStatuses = for j:#eq do "?" od
    then () = for k:NumClasses
             ~do if newStatuses[k] = "?"
                 then let C=eq[k] {should run backwards for update to be effective?}
                      then (d,j) = coords(LFVH,C[0])
                      then verts = vec: LFVH[d][j][:d+1]
		      {then ratverts = [ratvec]: for m in verts do Lvd.list[m] od
		      then sigma = sum(#lambda, ratverts)}
                      then pC = parameter(x, lambda, face_bary(Lvd, verts)) {sigma/(d+1))}
                      then pCdef = if is_final(pC)
                                   then if wiggle_flag and d > 0
					then {let () = char_counter.use()
				   	     then startCF = elapsed_ms()}
				   	     let CF = character_formula(pC)
					     {then () = charTime +:= elapsed_ms() - startCF}
					     in monomials(composition_series((sum(x.real_form,
					     	for j:d+1{v in ratverts}
						do wiggle(CF, face_bary(Lvd,verts[:j]##verts[:j+1]))
						{(sigma - v)/d)}
						od))))
					else []
					fi
                                   else monomials(finalize(pC))
                                   fi {is_final}
                      in if not is_final(pC)
			 then if all(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
			       	       	       (Uhash.lookup(q) >= 0) od)
                              then newStatuses[k] := "T"
                              elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 	 (Uhash.lookup(q) = -1) od)
                              then newStatuses:= updateNUclassesB(newStatuses, gr, k); "F"
                              fi
                         else {now pC is final, and pCdef consists of wiggled Params}
                              if any(for q in pCdef do @bool: is_finished(q.x,q.lambda)
				       	       	    	     	    and (Uhash.lookup(q) = -1) od)
				 then newStatuses := updateNUclassesB(newStatuses, gr, k); newStatuses[k] := "F"
                                    fi
                               fi
                        fi
                   od
              {fi}
    then () = if fund_face_verbose and NumClasses > 100
              then prints("start local_test, ",NumClasses,
              " equiv classes of faces")
              fi
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
         for m:NumClasses
        ~do if fund_face_verbose and NumClasses > 100 and
                 ((NumClasses-m-1)%printInterval = 0)
            then prints("examining equivalence class #"
              ,NumClasses-m -1, "; so far ",unitary_test_counter.use_count()
              ," 'is_unitary' tests.")
              ; printInterval := (3*printInterval)\2 + 1
            fi
            ;
            let test = bool:
                if newStatuses[m][0] = "F"
                then false
		elif newStatuses[m][0] = "T"
		  then true
                else let C=eq[m]
                     then (d,j) = coords(LFVH,C[0])
                     then verts = vec: LFVH[d][j][:d+1]
                  {first_param makes trouble in UParams list!}
                     then p = parameter(x, lambda, face_bary(Lvd, verts))
                     then () = if more_verbose then prints("testing parameter ",p) fi
                     then ps = monomials(finalize(p))
                     in all(for p1 in ps do @bool: is_unitary_def_test_big_SIMPLE(p1) od)
		fi
             in if test
                then for i in eq[m]
                     do let (d,j) = coords(LFVH,i)
                        then verts = vec: LFVH[d][j][:d+1]
                        then () = unitary_by_dim[d]+:=1
                        then q = parameter(x,lambda, face_bary(Lvd,verts))
                        then () = for q1 in monomials(finalize(q))
                                  do Uhash.match({herm_center(}q1{)});
                                     if deform_flag
                                     then for q1d in facet_deformed_new(q1)
                                          do Uhash.match({herm_center(}q1d{)})
                                          od
                                     fi
                                  od
                         then () = if long_out_flag
                                  then let () = ParamsByDim[d] #:= q
                                       then ()=LFDKHByDim[d] #:= LFVH[d][j]
                                       in ()
                                  fi
                         in q
                      od
                  else [] 
                  fi
             od.## {list of unitary Params}
    in UParams

set one_true_counter = make_counter()
set one_false_counter = make_counter()
set hash_real_dumbCounter = make_counter()
set hash_dumbCounter = make_counter()
set hash_def_dumbCounter = make_counter()
set hash_bottom_layerCounter = make_counter()
set one_param_time = int: 0

{true more than 3/4 of time, so shouldn't do much to_height testing}
set one_param_test(Param p, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), Q = monomials(finalize(p)), G = p.real_form
    then () = if all(for q in Q do Uhash.lookup(q).>= od)
    	      then return [p]
	      fi
    then r = rank(Q[0].x.involution - 1), step = max(G.semisimple_rank\2,1)
    {then DEFHTS = [int]: next_heights(p, (r*stretcher)\2)}
    {then steps = max(rank(p.x.involution-1),1)}
    then test = all(for q in Q
       	      	    do @bool: {is_unitary_def_test_big_SIMPLE(q,steps)}
		       let ans = if test_interrupt_flag {up_mu_flag}
		       	       	 then is_unitary_test_big_SIMPLE_interrupt(q{, DEFHTS})
		       		 else let DEFHTS = [int]: next_heights(p, (r*stretcher)\2)
		            	      in is_unitary_test_big_SIMPLE(q, DEFHTS)
		      		 fi
			in if more_after_flag and not ans
			   then more_after_flag:=false; more_bad_hash.match(q)
			   fi;
			   if min_after_flag and not ans
			   then min_after_flag:= false; bad_hash.match(q)
			   fi; ans
	   	    od)
    in if test
       then one_true_counter.use();
	    one_param_time +:= elapsed_ms() - start;
	    [p]
       else one_false_counter.use();
 	    one_param_time +:= elapsed_ms() - start;
	    []
       fi

{only does min_bottom test}
set one_param_test_min_bottom(Param p, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), Q = monomials(finalize(p)), G = p.real_form
    then () = if all(for q in Q do Uhash.lookup(q).>= od)
    	      then return [p]
	      fi
    then elim_min = all(for q in Q do min_bottom_elim_factors(q,p) od)
    then () = if not elim_min
    	      then let () = one_false_counter.use()
	      	   then ()= one_param_time +:= elapsed_ms() - start
		   in return []
	      fi
    then r = rank(Q[0].x.involution - 1), step = max(G.semisimple_rank\2,1)
    {then DEFHTS = [int]: next_heights(p, (r*stretcher)\2)}
    {then steps = max(rank(Q[0].x.involution - 1),1)}
    then test = all(for q in Q
       	      	    do @bool: {is_unitary_def_test_big_SIMPLE(q, steps)}
		    if test_interrupt_flag {up_mu_flag}
		    then let ans = is_unitary_test_big_SIMPLE_interrupt(q{, DEFHTS})
		    	 in if not ans then bad_hash.match(q) fi; ans
		    else let DEFHTS = [int]: next_heights(p, (r*stretcher)\2)
		    	 then ans = is_unitary_test_big_SIMPLE(q, DEFHTS)
			 in if not ans then bad_hash.match(q) fi; ans
		    fi
	   	    od)
    in if test
       then one_true_counter.use();
	    one_param_time +:= elapsed_ms() - start;
	    [p]
       else one_false_counter.use();
	    one_param_time +:= elapsed_ms() - start;
	    []
       fi

{assume min_bottom already called?}
set one_param_test_bottom(Param p, [int] Ds, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), QG = monomials(finalize(p)),G = p.real_form
    { used to check here whether terms of QG already known? }
    then () = if all(for q in QG do Uhash.lookup(q).>= od)
    	      then return [p]
	      fi
    then () = hash_bottom_layerCounter.use()
    then still_here = true
    then Es = (if #Ds > 1 then Ds
    	      else height(p)#Ds
	      fi).sort_u
    then (Qmin,) = if small_test_flag
    	 	    then theta_stable_data_small(p)
		    else theta_stable_quasi_data(p)
		    fi
    {then MU = big_unitary_hash.branch(K_type_pol(p),Es~[0])} {branch_std(p,Es~[0])}
    then () = if #Es > 1
       	      then let () = if more_verbose then prints("start more with p = ",p, ", Es = ",Es) fi
	    	   then Ps = for q in QG do K_type_pol(character_formula(q)) od
		   in while still_here and #Es > 1
		      do let old_size = bl_KHash.size()
			 then (datasNEW, EsNEW) = add_datas(p, Qmin, {bl_KHash,} Es{, MU})
			 in if bl_KHash.size() > old_size
			    then Es:= EsNEW;
		   		 still_here := all(for q@i in QG
						   do @bool:
						      let ans = bottom_elim_factors_more(q, p, datasNEW, Ps[i])
						      in if not ans
						      	 then more_bad_hash.match(q)
							 fi; ans
						   od)
			     else break
			     fi
		       od
		fi {#Es > 1}
    then () = if more_verbose then prints("result of bottom_elim_more was ",still_here) fi
    then r = rank(p.x.involution-1), step = max(G.semisimple_rank\2,1)
    {then steps = max(r,1)}
    {then DEFHTS = [int]: next_heights(p, (r*stretcher)\2)}
    in if still_here
       then let () = if test_verbose then prints("one parameter unitary on bottom layer to height ",Es~[0]) fi
       then test = all( [(->bool)]:
		    	   for q in QG
			   do @bool: let ans = {is_unitary_def_test_big_SIMPLE(q,steps)}
			      if test_interrupt_flag {up_mu_flag}
		    	      then is_unitary_test_big_SIMPLE_interrupt(q{,DEFHTS})
		    	      else let DEFHTS = [int]: next_heights(p, (r*stretcher)\2)
			      	   in is_unitary_test_big_SIMPLE(q, DEFHTS)
		    	      fi
			      then () = if not ans and more_after_flag
		            {HERE USE DIRAC ON MORE K-types}
			      	      	then more_bad_hash.match(q); more_after_flag:=false
					fi
			      in ans
			   od)
	    then () = if more_verbose then prints("your final answer was ",test) fi
	    in if test
	       then {let () = for q in QG
		     	     do Uhash.match(q)
		     	     od}
	    	    let () = one_true_counter.use()
	    	    then () = one_param_time +:= elapsed_ms() - start
	    	    in [p]
	       else let () = one_false_counter.use() {if test is false}
	       	    then () = one_param_time +:= elapsed_ms() - start
		    in []
               fi
	else let () = one_false_counter.use() {if still_here is false}
	     then () = one_param_time +:= elapsed_ms() - start
	     in []
        fi

{don't assume min_bottom already called; should only be called if ht > 0?}
set one_param_test_all_bottom(Param p, [int] Ds, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), Q = monomials(finalize(p)),G = p.real_form
    {then () = prints("Ds = ",Ds)}
    then () = if all(for q in Q do Uhash.lookup(q).>= od)
    	      then return [p]
	      fi
    then () = hash_bottom_layerCounter.use()
    then elim_min = all(for q in Q do min_bottom_elim_factors(q,p) od)
    then () = if not elim_min
    	      then let () = one_false_counter.use()
	      	   then ()= one_param_time +:= elapsed_ms() - start
		   in return []
	      fi
{now min bottom failed to eliminate...}
    then elim_more = true
    then Es = (if #Ds > 1 then Ds
    	      else height(p)#Ds
	      fi).sort_u
    then () = if #Es > 1
       	      then let () = if more_verbose then prints("start more with p = ",p, ", Es = ",Es) fi
	    	   then Ps = for q in Q do K_type_pol(character_formula{_to_height}(q{, Es~[0]})) od
       	    	   then still_here = true
		   then () = {for D in Ds[:1]
		      	     do} still_here := all(for {D@j in Ds[1:]} j:#Es-1 from 1
					       	  do all(for q@i in Q
						      	 do @bool: bottom_elim_factors_more(q, p, Es[j-1],Es[j], Ps[i])
						   	 od)
					          od){;
				 if not still_here then break fi}
			      {od}
		   in elim_more:= still_here
		fi {#Es > 1}
    then () = if more_verbose then prints("result of elim_more was ",elim_more) fi
    {then steps = max(rank(p.x.involution-1),1), step = max(G.semisimple_rank\2,1)
    then test_heights = next_heights(p, steps)}
    in if elim_more
       then let () = if test_verbose then prints("one parameter unitary on bottom layer to height ",Es~[0]) fi
       	    then test = all( [(->bool)]:
		    	   for q in Q
			   do @bool: let ans = if test_interrupt_flag {up_mu_flag}
		    	      then is_unitary_test_big_SIMPLE_interrupt(q{,test_heights})
		    	      else let steps = max(rank(p.x.involution-1),1),
			      	       step = max(G.semisimple_rank\2,1)
    				       then test_heights = next_heights(p, steps)
				       in is_unitary_test_big_SIMPLE(q,test_heights)
		    	      fi
			      then () = if not ans
			      	      	then more_bad_hash.match(q)
					fi
			      in ans
		    	od)
	    then () = if more_verbose then prints("your final answer was ",test) fi
	    in if test
	       then let () = for q in Q
		     	     do Uhash.match(q)
		     	     od
	    	    then () = one_true_counter.use()
	    	    then () = one_param_time +:= elapsed_ms() - start
	    	    in [p]
	       else let () = one_false_counter.use() {if test is false}
	       	    then () = one_param_time +:= elapsed_ms() - start
		    in []
               fi
	else let () = one_false_counter.use() {if elim_more is false}
	     then () = one_param_time +:= elapsed_ms() - start
	     in []
        fi

{skips all unitary_to_ht tests in dims 2-top; just does at the end}
set quick_flag = true

{Assume we have local vertices and edges LF, herm and pos on LKTs.
Called when there are not enough heights; presumably small KGBElts??}
set local_test_GEO_hash_real_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
     [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) =
     [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G)
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if 1*parameter(x,lambda,lambda) = zero_pol then return [] fi
    then r = rank(x.involution - 1), NK = #KGB(x.real_form)
    then pmin = parameter(x,lambda,0*lambda)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	{[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then pmax = pmax(x,lambda,Lvd)
    {then maxDiffLoc = max_loc(for v in Lvd.list
    	 	       	       do G.two_rho_check*(dominant(G,thetaMinus*v))
			       od)
    then pmax = first_param(finalize(parameter(x, lambda, Lvd.list[maxDiffLoc]))),}
    then r = rank(x.involution - 1), rk = rank(x_open(G).involution - 1), step = max(G.semisimple_rank\2,1)
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    then tester = (Param->bool): (Param p) bool: {could have recorded bool above to
    	 	  		 	   	 omit is_unitary at end}
	 if test_interrupt_flag {up_mu_flag}
	 then is_unitary_test_big_SIMPLE_interrupt(p{,test_hts})
	 else let test_hts = [int]: next_heights(pmax, (r*stretcher)\2)
	      then too_high = first(for h in test_hts do h > FPP_max_ht od)
    	      then () = if too_high.>= then {prints(test_hts);} test_hts:=test_hts[:too_high] fi
	      in is_unitary_test_big_SIMPLE(p, test_hts)
	 fi
    {then () = if face_verbose then prints("test_ht = ",test_ht) fi}
    then () = test_string:= " using local_test_GEO_hash_real_dumb"
    then  () = hash_real_dumbCounter.use()
    then start_count = unitary_test_counter.use_count()
 {because of to_ht, CANNOT use KNU testing: NO THIS IS TEST}
    {then KNU_flag_hold = KNU_flag
    then ICPNU_flag_hold = ICPNU_flag
    then () = KNU_flag:=false
    then () = ICPNU_flag:=false}
    then startDBTcount = DBTcount
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
    {then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)}
    {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od,"; Dirac_best eliminated ",
			  DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
           {remove from LFDKH all faces failing is_unitary}
    then () = LFDKH := local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq, gr, CLBF, pol_hash,
    	 tester, Uhash, fancy_tester)
    then () = if test_verbose then prints("unitary face counts to dim 1: ",
    	      	 for list in LFDKH do #list od)
	      fi
    then () = if quick_flag
              then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                rank(x.involution - 1) + 1, pol_hash)
	           then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   in  LFDKH := {if know_lower_flag
                       	      	then} local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq,
				      gr, CLBF, pol_hash, tester, Uhash)
                       		{else local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF,
				      is_unitary_hash_big_SIMPLE@Param, Uhash)
                       		fi}
	      else let D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 then lowUs = sum(for d:D+1 do #LFDKH[d] od)
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
			      then test = {if know_lower_flag
                                     	  then} if any(for p in ps
                                                      do is_finished(p.x, p.lambda){p.x.# < known_to} and
						      	 	Uhash.lookup(p) = -1
                                                      od)
                                               then false
                                               elif all(for p in ps
                                                    	do Uhash.lookup(p).>=
                                                   	od)
                                               then true
                                               else all(for p in ps
					       	    	do tester(p)
							{is_unitary_test_big_SIMPLE(p,test_hts)}
					       		od)
                                               fi {any}
                                     	  {else all(for p in ps
                                                    do Uhash.lookup(p).>= or
                                                    is_unitary_hash_big_SIMPLE(p) od)
                                     	  fi{know_lower}}
		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
                          in if test
                             then [LFDKH[D+1][m]]
                             else []
                             fi
                          fi
                       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	 fi {if quick_flag}
    {then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:=ICPNU_flag_hold
    then () = ICPU_flag:=ICPU_flag_hold}
    then unitary_by_dim = for L in LFDKH do #L od
    {now have unitary faces of all dims}
     {then () = if test_verbose then prints("total number of tests = ",
                                  unitary_test_counter.use_count())
				  fi}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () =ParamsByDim[d]:=(ParamsByDim[d] next ParamsByDim[d]:=[])#p
			   {ParamsByDim[d] := ParamsByDim[d]#p}
			   	then ()=LFDKHByDim[d] :=(LFDKHByDim[d] next LFDKHByDim[d]:=[])#v
				{LFDKHByDim[d] := LFDKHByDim[d]#v}
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{for character_formula calculations on parameters of

    height/(G.rho * G.two_rho) \le CUTOFF,

it's assumed that character_to_height is faster. Setting CUTOFF = 2
means always character_formula_to_height, CUTOFF=0 means
character_formula except for height 0, and CUTOFF = -1 means always
character_formula. For F4_s, CUTOFF = 0 saves 10 seconds over -1 and 2}

{Get rid of this, use low??}
set CUTOFF =rat: 0/1

{Assume we have local vertices and edges LF, herm and pos on LKTs.
Called when there are not enough heights; presumably small KGBElts??}
set local_test_GEO_hash_else_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash,
    Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G)
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if 1*parameter(x,lambda,lambda) = zero_pol then return [] fi
    then r = rank(x.involution - 1), NK = #KGB(G)
    then pmin = parameter(x,lambda,0*lambda)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   {[height(pmin) + more_shift_level],} Uhash) 
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    {then test_hts = hts[:min(#hts,1{r})]  {??? who knows about r!}}
    then tester = (Param->bool): (Param p) bool:
    	 {is_unitary_test_big_SIMPLE(p,test_ht) {this settles unitarity absolutely}}
	 if test_interrupt_flag {up_mu_flag}
	 then is_unitary_test_big_SIMPLE_interrupt(p{,[hts[0]]})
	 else is_unitary_def_test_big_SIMPLE(p)
	 fi
    {then () = if test_verbose then prints("test_ht = ",test_ht) fi}
    then () = test_string:= " using local_test_GEO_hash_else_dumb"
    then  () = hash_dumbCounter.use()
    then start_count = unitary_test_counter.use_count(), startDBTcount = DBTcount
    {then temp_K_char_flag = height(pmin)/(G.rho * G.two_rho_check) <= CUTOFF}
     {defaults to true if ht=0, false otherwise}
    then pol_hash0 = make_KTypePol_hash() {to hold chars to height hts[0]}
    {if temp_K_char_flag
    	 	     then make_KTypePol_hash() {to hold chars to height hts[0]}
		     else pol_hash
		     fi}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,hts[0],pol_hash0, LF, eq,CLBF)
		      {if temp_K_char_flag
		      	 then localFD_KHash_01_graph(x,lambda,Lvd,hts[0],pol_hash0,
			      LF, eq,CLBF)
			 else localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
			 fi}
		  {elif temp_K_char_flag}
    	       	  else localFD_KHash_01(x, lambda, Lvd, hts[0], pol_hash0, LF)
		  {else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)}
		  fi {red_count_flag}
    {then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)}
    {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od,"; Dirac_best eliminated ",
			  DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    	 		       {if temp_K_char_flag
    	 		       then localGraphK(LFDKH)
    	 		       else localGraphK(LFDKH, pol_hash, hts[0]) {pol_hash0??}
			       fi {localGraphK(LFDKH)}}
           {remove from LFDKH all faces failing is_unitary to hts[0]}
	   {CAN'T use know_lower, because that uses DiracBest, without caring for height}
    then () =  LFDKH := local_testK_hash{_know_lower}(x,lambda,Lvd, LFDKH, eq, gr, CLBF, pol_hash0,
    (Param->bool): (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, hts[0]), hts[0], Uhash, fancy_tester)
    then () = if test_verbose then prints("unitary to ",hts[0]," face counts to dim 1: ",
    	      	 	      	   		   for list in LFDKH do #list od) fi
    then () = LFDKH:= if {temp_K_char_flag and} red_count_flag and #LFDKH[1] > 0
    	      	      then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
		      	   in  extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red,
			   CLBF_red)
    	      	      {elif temp_K_char_flag}
		      else extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
		      {else LFDKH}
		      fi
    {then () = prints("set LFDKH01 = ",LFDKH)}
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
              	   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, pol_hash, tester, height(pmin) + 100 ,Uhash)
		      {should make a version of local_testK_hash with inf HT}
                   in if test_verbose
		      then prints("unitary face counts to dim ", #LFDKH - 1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 {then lowUs = sum(for d:D+1 do #LFDKH[d] od)}
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
		              then test = if any(for p in ps
					       	 do is_finished(p.x, p.lambda) and
						      	 Uhash.lookup(p) = -1
						 od)
					  then false
					  elif all(for p in ps
					       	   do Uhash.lookup(p).>=
						   od)
					  then true
					  else all(for p in ps
					       	   do tester(p) od)
					  fi
		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
			       in if test
			       	  then [LFDKH[D+1][m]]
				  else []
				  fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	     fi {quick_flag}
    then unitary_by_dim = for L in LFDKH do #L od
    {now have unitary faces of all dims}
     {then () = if test_verbose then prints("total number of tests = ",
                                  unitary_test_counter.use_count())
				  fi}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{How many steps to use in is_unitary_def_test(p, steps) in def_dumb}
set def_steps = -1

{Assume we have local vertices and edges LF, herm and pos on LKTs and Dirac
	Use is_unitary_def_test(p, (G.rank + 1)\2}
set local_test_GEO_hash_def_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsIndex]] LF,
    KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then zero_pol = null_module(G), pmin = parameter(x,lambda, 0*lambda), NK = #KGB(G)
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution - 1)
    then () = to_ht_flag:=true
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then pmax = pmax(x,lambda, Lvd)
    {then maxDiffLoc = max_loc(for v in Lvd.list
    	 	             do G.two_rho_check*(dominant(G,thetaMinus*v))
		             od)
    then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])}
    then (LAMmax,NUmax,) = low(pmax)
    then () = if NUmax < LAMmax*low_frac {is_unitary_to_ht is never a good idea}
    	      then to_ht_flag:=false
	      fi
    then def_steps_temp = if def_steps = -1
    	 		  then ((r+G.rank)*stretcher)\5
			  else def_steps
			  fi
    then tester = (Param->bool): (Param p) bool:
     	 if test_interrupt_flag {up_mu_flag} and to_ht_flag
	 then is_unitary_test_big_SIMPLE_interrupt(p, def_steps_temp)
	 elif to_ht_flag
	 then is_unitary_def_test_big_SIMPLE(p,def_steps_temp)
	 else is_unitary_hash_big_SIMPLE(p)
	 fi
    then () = test_string:= " using local_test_GEO_hash_def_dumb"
    then  () = hash_def_dumbCounter.use()
    then start_count = unitary_test_counter.use_count(), startDBTcount = DBTcount
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
{    then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)}
    {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od,"; Dirac_best eliminated ",
			  DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    {then () = prints("LFDKH = ",LFDKH)}
    {then () = prints("eq = ",eq,", gr = ",gr)}
           {remove from LFDKH all faces failing is_unitary}
    then () = LFDKH := local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq, gr,
    	      	       				   CLBF, pol_hash, tester, Uhash, fancy_tester)
    then () = if test_verbose then prints("unitary face counts to dim 1: ", for list in LFDKH do #list od) fi
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
	      	   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, pol_hash, (Param->bool): (Param p):
		      is_unitary_def_test_big_SIMPLE(p,def_steps_temp)
		      ,height(pmin), Uhash)
                   in if test_verbose
		      then prints("unitary face counts to dim ", #LFDKH - 1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
    then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 {then lowUs = sum(for d:D+1 do #LFDKH[d] od)}
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {then ratverts = [ratvec]: for m in verts do Lvd.list[m] od}
			      {then sigma = sum(#lambda, ratverts)} {THIS IS WRONG BARYCENTER}
			      then pC = parameter(x, lambda, face_bary(Lvd, verts))
			      then ps = monomials(finalize(pC))
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      in if not is_final(pC)
				 then if any(for q in ps do @bool:  is_finished(q.x,q.lambda) and
				      	      	      (Uhash.lookup(q) = -1) od)
				      then []
				      else if all(for q in ps do @bool:  is_finished(q.x,q.lambda) and
					   	   	   (Uhash.lookup(q) >= 0) od)
				      	    then [LFDKH[D+1][m]]
				      	    else if all(for q in ps do @bool: tester(q) od)
					    	 then [LFDKH[D+1][m]]
					   	 else []
					   	 fi
				       	    fi {all(for q}
				      fi {any(for q}
				 else {now pC is final}
				      if wiggle_flag
				      then {let () = char_counter.use()
				   	   then startCF = elapsed_ms()}
				   	   let CF = character_formula(pC)
					   {then () = charTime +:= elapsed_ms() - startCF}
					   then pCdef =  monomials(composition_series((sum(x.real_form,
					   	      for j:#verts
						      do wiggle(CF, face_bary(Lvd, verts[:j]##verts[j+1:]))
						      od))))
							  {proper_facet_deformed(pC)}
				      	        in if any(for q in pCdef
						      	  do @bool: ( is_finished(q.x,q.lambda) and
							    (Uhash.lookup(q) = -1))
							  od)
						   then []
					      	   else if tester(pC)
					   	   	then [LFDKH[D+1][m]]
					   	   	else []
					     	   	fi
				      	      	   fi {any(for q}
				      else {not wiggle_flag}
					      if tester(pC)
					      then [LFDKH[D+1][m]]
					      else []
					      fi
				      fi {wiggle_flag}
				 fi {not is_final}
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	     fi {quick_flag}
    {now have unitary faces of all dims}
     then unitary_by_dim = for L in LFDKH do #L od
     then () = if test_verbose or test_slightly_verbose
    	       then prints("unitary faces by dim = ",
       	       	    	    unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   then () = to_ht_flag:= true
   in UParams

{assume LF is verts and edges, herm and pos on LKTs and Dirac?}
set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if real_flag
    then local_test_GEO_hash_real_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
    elif def_flag
    then local_test_GEO_hash_def_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
    else let shorts = if short_hts_flag
    	     	      then short_hts(parameter(x,lambda,Lvd.list[0]))
		      else next_heights(parameter(x,lambda, Lvd.list[0]), 1)
		      fi
    	 then hts = shorts[:min(1,#shorts)]
    	 in local_test_GEO_hash_else_dumb(x, lambda, {vd,} Lvd, LF, hts, pol_hash, Uhash,fancy_tester)
    fi

{if true, uses the (faster?) function localFD_1Dirac2_by_zero to compute local vertices and edges}
{seems SLOWER in F4, E7}
set by_zero_flag = true

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    let DiracBD = DiracBD(x,lambda), G=x.real_form
    then rhocheck = G.rho_check
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda,Lvd,Perm2)
	      fi
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    let DiracBD = DiracBD(x,lambda), G=x.real_form
    then rhocheck = G.rho_check
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	      fi
    {imposes Dirac, herm, pos on LKTs for vertices and edges}
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash,fancy_tester)

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    then (Lvd, Perm2) = localFD_Lvd2(x, lambda, FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO_dumb(KGBElt x, ratvec lambda) =
    [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form), pol_hash = make_KTypePol_hash(), G = x.real_form
    {then vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_dumb(x, lambda, pol_hash, Uhash, is_unitary_hash_big_SIMPLE@Param)

{USE THESE IN HASH AND HASH2!}
{lowest level (index in hts[]) to start testing}
set edge_offset = int: -1

{how much to increase level at each repetition}
set edge_skip = int: 1

{vertex set size number at which to revert to local_test_GEO_hash_dumb.
0 to 100 make sense: higher means revert MORE often}
set vert_diff_cutoff = int: 10

{when nu*2rho_check < (to_ht_frac)*(infl_char*2rho_check, don't use is_unitary_to_ht}
{If negative, always allow is_unitary_to_ht}
set to_ht_frac = 9/10

set hashCounter = make_counter()

{assume we've already got hts, #hts >= 1, imposed Dirac, and decided not to use _dumb
Assume LF is vertices and edges, already pos on LKTs and hermitian and Dirac}
set local_test_GEO_hash_no_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let () = hashCounter.use()
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = test_string:= " using local_test_GEO_hash"
    then () = if(face_verbose) then prints("hts = ",hts) fi
    then long_out_temp_flag = long_out_flag, r = rank(x.involution -1), start = elapsed_ms()
    then () = long_out_flag:=false {to allow using local_test_hash without recording Params}
    then edge_offset_temp = edge_offset, ht0 = height(parameter(x,lambda,0*lambda)),
    	 G = x.real_form
    then temp_K_char_flag = ht0/(G.rho * G.two_rho_check) <= CUTOFF
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    {then test_levels = for d:max(r+1,2) do (d*edge_skip*stretcher)\1 + edge_offset_temp od}
    {then test_hts = hts {for d:max(r+1,2) do hts[test_levels[d]] od} {need to increase #hts?}}
    then pol_hash0 = if temp_K_char_flag
    	 	     then make_KTypePol_hash() {to hold chars to height hts[0]}
		     else pol_hash
		     fi
    then startDBTcount = DBTcount
{for E8_s, K-chars to height test_hts[0] = 68 is 2.5 days. So do just hts[0]!}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq_red,CLBF_red) = localGraphRed(LF)
		      in if temp_K_char_flag
		      	 then localFD_KHash_01_graph(x,lambda,Lvd,hts[0],pol_hash0,
			      LF, eq_red,CLBF_red)
			 else localFD_KHash_01_graph(x,lambda,Lvd,pol_hash0,LF, eq_red,CLBF_red)
			 fi
		  elif temp_K_char_flag
    	       	  then localFD_KHash_01(x, lambda, Lvd, hts[0], pol_hash0, LF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
     {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od,"  Dirac_best eliminated ",
			  DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1, to hts[edge_offset]}
    then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
    	 		       then localGraphK(LFDKH)
    	 		       else localGraphK(LFDKH, pol_hash, hts[0])
			       fi
    {then () = prints("trial of eq at dim 1 is ",trial(x,lambda,Lvd,LFDKH, eq, hts[0]))}
 {because of to_ht, CANNOT use KNU testing}
    then KNU_flag_hold = KNU_flag
    then ICPNU_flag_hold = ICPNU_flag
    then () = KNU_flag:=false
    then () = ICPNU_flag:=false
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, pol_hash0,
    	      (Param->bool):(Param p): is_unitary_to_ht_big_SIMPLE(p, hts[0]), hts[0], Uhash)
    then () = if test_verbose then prints("unitary to ht ",hts[0],
                        " face counts to dim 1: ",for list in LFDKH do #list od) fi
    then () = LFDKH := if temp_K_char_flag and red_count_flag and #LFDKH[1] > 0
    	      	       then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
    	      	       	    in extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red, CLBF_red)
		       elif temp_K_char_flag
		       then extend_K_characters(x,lambda,Lvd,LFDKH,pol_hash)
		       else LFDKH
		       fi {now LFDKH is always FULL K-chars}
    then ((eq,gr),IUCL,CLBF) = {if temp_K_char_flag
    	 		       then localGraphK(LFDKH) {this automatically tests to test_hts[0]}
			       else} localGraphK(LFDKH, pol_hash, hts[0])
			       {this is TOLD to go to test_hts[0]}
			       {fi}
        {remove from LFDKH all faces failing is_unitary_to_ht(hts[0])}
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, pol_hash{0},
    	   (Param->bool):(Param p): is_unitary_to_ht_big_SIMPLE(p,hts[0]),
	   hts[0], Uhash)
    then () = if test_verbose then prints("unitary to ht ",hts[0],
                        " face counts to dim 1: ",for list in LFDKH
			do #list od) fi
     then Dlast = #hts -1
     then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,hts[Dlast])
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, pol_hash, (Param->bool): (Param p): 
		      is_unitary_to_hts_big_SIMPLE(p,hts[1:Dlast+1])
		      , hts[Dlast], Uhash)
                   in if test_verbose
		      then prints("unitary to ht ",hts[Dlast],
		      	      		" face counts to dim ",Dlast+1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
	      	   then () = if #hts < r
		   	     then hts ##:= for D:r-#hts do hts~[0] od
			     fi
    		   then () = while (D <= r - 1  ) and (#LFDKH = D + 1) and (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht hts[D] on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   LFDKH, D+1,D+2, pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,hts[D])
       	      	 {compute graph on faces to dim D+1}
		 then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, pol_hash, (Param->bool): (Param p):
		      is_unitary_to_ht_big_SIMPLE(p,hts[D])
		      ,hts[D], Uhash)
                 then () = if test_verbose
			   then prints("unitary to ht ",hts[D],
		      	      		" face counts to dim ",D+1,
				": ", for list in LFDKH do #list od)
			   fi
                 then ()= D:=D+1
                 in ()
     	     od{end of D while loop}
    in ()
    fi {quick_flag}
    {now have faces of all dims, to height hts[Dlast]}
    then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:=ICPNU_flag_hold
    then () = if hts[Dlast].<
    	      then return for list@d in LFDKH
		     	  do for v in list
			     do parameter(x,lambda, face_bary(Lvd, v[:d+1]))
			     od
		     	  od.##
	       fi {now hts[Dlast] > 0}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then () = if test_verbose then prints(sum(for list in LFDKH do #list od),
	      	      	   " unitary candidates in ",#eq," equivalence classes.") fi
    then () = long_out_flag := long_out_temp_flag
    then start = elapsed_ms(), pmin = parameter(x,lambda,0*lambda)
    {then () = for j:2 do prints(LFDKH[j]) od}
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash, fancy_tester)
    	 {possibly put some bottom layer stuff??}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    in UParams

set local_test_GEO_hash_no_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash_no_dumb(x, lambda, Lvd, LF, hts, pol_hash, Uhash,
    is_unitary_hash_big_SIMPLE@Param)

{Assume we have local vertices and edges LF, already herm, Dirac, pos on LKTs}
set local_test_GEO_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsIndex]] LF,
    KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if {EMPTY CASE} #LF[0] = 0 then return [] fi
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution - 1) {, NK = #KGB(G)}, step = max(G.semisimple_rank\2,1)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, Lvd,
	      	   	  	    LF, pol_hash, Uhash, fancy_tester) {use
				    real_dumb if real_flag, def_dumb if def_flag}
	      fi
    then edge_offset_temp = edge_offset
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    {then depth= max(r,2)}
    then depth= max(((r-1)*edge_skip*stretcher)\1 + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)
    in [Param]: let {maxDiffLoc = max_loc(for v in Lvd.list
    	       		    do G.two_rho_check*(dominant(G,thetaMinus*v))
		       		    od)
    	      	then pmax = first_param(finalize(parameter(x, lambda, Lvd.list[maxDiffLoc])))}
		     pmax = pmax(x, lambda, Lvd)
		then Shorthts = if short_hts_flag
		     	      	then short_hts(pmax)
		     	      	else next_heights(pmax,depth)
				fi
    	      	then () = if #Shorthts < depth and revert_flag
		     	  then return local_test_GEO_hash_else_dumb(x, lambda,
    	      	 	     Lvd, LF, Shorthts[:min(1,#Shorthts)], pol_hash, Uhash, fancy_tester)
	      		  fi
		then () = test_string:= " using local_test_GEO_hash"
    	        then hts = [int]:
		     let d0 = min(#Shorthts, depth)
		     in Shorthts[:d0] ## for j:depth-d0 do -1 od
    	      	in local_test_GEO_hash_no_dumb(x, lambda, {vd,} Lvd, LF, hts,
	      	 pol_hash, Uhash)

set local_test_GEO_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    {let () = adjust_global_top(x.inner_class)}
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO_hash(KGBElt x, ratvec lambda, VertexData vd, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO_hash(KGBElt x, ratvec lambda, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO(KGBElt x, ratvec lambda, (Param->bool) fancy_tester) =
    [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form), G = x.real_form, pol_hash = make_KTypePol_hash()
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash(x,lambda, pol_hash, Uhash, fancy_tester)

set local_test_GEO(KGBElt x, ratvec lambda) =
    [Param]:
    local_test_GEO(x, lambda, is_unitary_hash_big_SIMPLE@Param)

set hash2Counter = make_counter()

set up_shift = int: 0
{This version assumes edges and vertices already computed, with herm and pos on LKTs; called by one_level}
{Local data assumed to have red_count coords if red_count_flag = true}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) =
    [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = 1-x.involution, start = elapsed_ms()
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution -1), step = max(G.semisimple_rank\2,1)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash) 
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then edge_offset_temp = edge_offset
    then () = to_ht_flag:=true
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\3 {3 seems best for F4}
	      fi
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom {keeping this reduced #tests by 1/4}
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd,
	      	   	  	   LF, pol_hash, Uhash, fancy_tester) {use def_dumb if def_flag}
	      fi
    then depth= max(((r+1)*edge_skip*stretcher)\1 + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)
    {then maxDiffLoc = max_loc(for v in Lvd.list
    	 	             do G.two_rho_check*(dominant(G,thetaMinus*v))
		             od)
    then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])}
    then pmax = pmax(x, lambda, Lvd)
    then (LAMmax,NUmax,) = low(pmax)
    then () = if NUmax < LAMmax*low_frac {is_unitary_to_ht is never a good idea}
    	      then to_ht_flag:=false
	      fi
    then () = if revert_flag and not to_ht_flag
    	      then to_ht_flag:=true;
	      	   return local_test_GEO_hash_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
	      {use def_dumb if def_flag}
	      fi
    then gammamax = pmax.infinitesimal_character
    {then far_sph_flag = bool: dominant(G,thetaMinus*gammamax)*G.two_rho_check/2 < to_ht_frac*(gammamax*G.two_rho_check)}
    	      { left guaranteed <= right term on right. If close, then
	       params are close to spherical princ series, and to_ht is fast}
    then hts =[int]: if to_ht_flag
    	     	     then let Shorthts = if short_hts_flag {guaranteed to be size depth}
    	     	     	 	       	 then short_hts(pmax)
				         else next_heights(pmax,depth)
				    	 fi
    		     	  then () = if #Shorthts < depth and revert_flag
			       	    then return local_test_GEO_hash_else_dumb(x, lambda, Lvd, LF,
			       	    	 Shorthts[:min(#Shorthts,1)], pol_hash, Uhash, fancy_tester)
			       	    fi
    		          then d0 = min(#Shorthts, depth)
		     	  in Shorthts[:d0] ## for j:depth-d0 do -1 od
		      else for j:depth do height(pmax) od
		      fi
    then () = test_string:= " using local_test_GEO_hash2"
    then  () = hash2Counter.use()
    then test_hts = [int]: hts
    	 {let test_levels = for d:max(r+1,3) do (d*edge_skip*stretcher)\1 + edge_offset_temp od
      	      	  {last test_level is approx depth}
         in for d:max(r+1,3) do hts[test_levels[d]] od}
    then Dlast = #test_hts - 1
    then () = if (test_verbose) then prints("heights = ", hts, ", test heights = ",test_hts) fi
    {get K-type formulas for all vertices and edges}
    then temp_K_char_flag = height(parameter(x,lambda,0*lambda))/(G.rho * G.two_rho_check) <= CUTOFF
     {defaults to true if ht=0, false otherwise}
    then pol_hash0 = if temp_K_char_flag
    	 	     then make_KTypePol_hash() {to hold chars to height {test_}hts[0]}
		     else pol_hash
		     fi
    then startDBTcount = DBTcount
{for E8_s, K-chars to height test_hts[0] = 68 is 2.5 days. So maybe just hts[0]?}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in if temp_K_char_flag
		      	 then localFD_KHash_01_graph(x,lambda,Lvd,hts[0],pol_hash0,
			      LF, eq,CLBF)
			 else localFD_KHash_01_graph(x,lambda,Lvd,pol_hash0,LF, eq,CLBF)
			 fi {temp_K_char_flag}
		  elif temp_K_char_flag
    	       	  then localFD_KHash_01(x, lambda, Lvd, hts[0], pol_hash0, LF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash0, LF)
		  fi {red_count_flag}
    {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od, "; Dirac_best eliminated ",
			      DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1, to hts[edge_offset]}
    then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
    	 		       then localGraphK(LFDKH)
    	 		       else localGraphK(LFDKH, pol_hash0, {test_}hts[0]) {pol_hash0??}
			       fi
    {then () = prints("trial of eq at dim 1 is ",trial(x,lambda,Lvd,LFDKH, eq, hts[0]))}
 {because of to_ht, CANNOT use KNU testing}
    then KNU_flag_hold = KNU_flag
    then ICPNU_flag_hold = ICPNU_flag
    then () = KNU_flag:=false
    then () = ICPNU_flag:=false
    {then startDBTcount = DBTcount}
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, pol_hash0,
    	      (Param->bool):(Param p): is_unitary_to_ht_big_SIMPLE(p, {test_}hts[0])
			, {test_}hts[0], Uhash, fancy_tester)
    {then () = prints("LFDKH before extend = ",LFDKH)}
    then () = if test_verbose then prints("unitary to ht ",{test_}hts[0],
                        " face counts to dim 1: ",for list in LFDKH do #list od
			,"; Dirac_best eliminated ", DBTcount - startDBTcount) fi
    then () = LFDKH:= if temp_K_char_flag and red_count_flag and #LFDKH[1] > 0
    	      	      then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
		      	   in  extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red, CLBF_red)
    	      	      elif temp_K_char_flag
		      then extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
		      else LFDKH
		      fi
    {then () = prints("LFDKH after extend = ",LFDKH)}
    {then Dmid = max(r\4,1)} {changed from r\2, since test_levels[4] = 91 too slow for E8_s spherical}
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2, r+1, pol_hash)
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,test_hts[Dlast])
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, pol_hash, (Param->bool): (Param p):
		      is_unitary_to_hts_big_SIMPLE(p,test_hts[1:Dlast+1].sort_u)
		      , test_hts[Dlast], Uhash, fancy_tester)
		      	{test to the same height as not quick}
                   in if test_verbose
		      then prints("unitary to ht ",test_hts[Dlast],
		      	      		" face counts to dim ",r,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
     then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                          	   LFDKH, D+1,D+2,pol_hash)
	         {then () = if D=1 then prints(LFDKH[2]) fi}
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, {test_}hts[D])
       	      	 {compute graph on faces to dim D+1}
		 {then () = prints("trial of eq at dim ",D+1," is ",
		 trial(x,lambda,Lvd,LFDKH, eq, test_hts[D]))}
		 then () = LFDKH := local_testK_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, pol_hash,
		 (Param->bool):(Param p): is_unitary_to_ht_big_SIMPLE(p,test_hts[D])
					  , test_hts[D], Uhash, fancy_tester)
		 then () = if test_verbose
		     	   then prints("unitary to ht ",test_hts[D], " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
		 {then ()= Dmid:=D}
                 then ()= D:=D+1
		 in ()
     	     od
     in ()
     fi{quick_flag}
    {now have faces of all dims, to height test_hts[Dlast]}
    then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:= ICPNU_flag_hold
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    {then () = prints("last eq = ",eq)}
    {then sph_far_flag = dominant(G,thetaMinus*gammamax)*G.two_rho_check/2 < to_ht_frac*(gammamax*G.two_rho_check)}
    {term on left guaranteed <= right term on right. If close, then
    	       params are close to spherical princ series, and to_ht is fast}
    then () = if test_verbose
    	      then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
	           {if sph_far_flag
		   then} prints("using is_unitary_tester_big_SIMPLE_interrupt")
		   {else prints("testing to height ",hts[test_levels[Dmid+1]])
		   fi}
	      fi
    then mu_tester(Param p) = bool: is_unitary_test_big_SIMPLE_interrupt(p,[test_hts[Dlast]+1])
    then start=elapsed_ms() {already unitary to height hts[test_levels[Dlast]] = test_hts[max(r,2)]}
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		 if test_interrupt_flag {up_mu_flag} and to_ht_flag
		 then mu_tester(p)
		 else is_unitary_hash_big_SIMPLE(p)
		 fi, Uhash)
    {Maybe NEED TO PUT BOTTOM LAYER STUFF BACK}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
     then () = to_ht_flag := true
    in UParams

set local_test_GEO_hash2_end(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH,
    			KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    let G = x.real_form, r = rank(x.involution -1), thetaMinus = 1-x.involution
    then vertexDiff = #LFDKH[0]/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom {keeping this reduced #tests by 1/4}
    {then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd,
	      	   	  	   LF, pol_hash, Uhash, fancy_tester) {use def_dumb if def_flag}
	      fi}
    {then edge_offset_temp = edge_offset, step = max(G.semisimple_rank\2,1)}
    then () = to_ht_flag:=true
    {then () = if edge_offset = -1
    	      then edge_offset_temp := r\3 {3 seems best for F4}
	      fi}
    then depth= max(r+1,3)
    {max(((r+1)*edge_skip*stretcher)\1 + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)}
    {then maxDiffLoc = max_loc(for v in Lvd.list
    	 	             do G.two_rho_check*(dominant(G,thetaMinus*v))
		             od)
    then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])}
    then pmax = pmax(x, lambda, Lvd)
    then (LAMmax,NUmax,) = low(pmax)
    then () = if NUmax < LAMmax*low_frac {is_unitary_to_ht is never a good idea}
    	      then to_ht_flag:=false
	      fi
    then gammamax = pmax.infinitesimal_character
    then mu = K_type(x,pmax.lambda_minus_rho)
    then hts =[int]: if to_ht_flag
    	     	     then let Shorthts = if short_hts_flag {want hts guaranteed to be size depth}
    	     	     	 	       	 then short_hts(pmax)
					 {elif up_mu_flag
					 then up_mu_hash.up_heights(mu, depth+1+up_shift)[1:]}
					 else next_heights(pmax,depth)
				    fi
    		          then d0 = min(#Shorthts, depth)
		          in Shorthts[:d0] ## for j:depth-d0 do -1 od
		     else for j:depth do height(pmax) od
		     fi
    {then () = test_string:= " using local_test_GEO_hash2end"}
    {then  () = hash2Counter.use()}
    then test_hts = [int]: hts
    	 {if up_mu_flag
	 then hts
	 else let test_levels = for d:max(r+1,3) do (d*edge_skip*stretcher)\1 + edge_offset_temp od
      	      	  {last test_level is approx depth}
              in for d:max(r+1,3) do hts[test_levels[d]] od
	 fi}
    then Dlast = #test_hts - 1
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2, r+1, pol_hash)
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,test_hts[Dlast])
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, pol_hash, (Param->bool): (Param p):
		      is_unitary_to_hts_big_SIMPLE(p,test_hts[1:Dlast+1].sort_u)
		      , test_hts[Dlast], Uhash, fancy_tester)
		      	{test to the same height as not quick}
                   in if test_verbose
		      then prints("unitary to ht ",test_hts[Dlast],
		      	      		" face counts to dim ",r,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
     then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                          	   LFDKH, D+1,D+2,pol_hash)
	         {then () = if D=1 then prints(LFDKH[2]) fi}
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, hts[D])
       	      	 {compute graph on faces to dim D+1}
		 {then () = prints("trial of eq at dim ",D+1," is ",
		 trial(x,lambda,Lvd,LFDKH, eq, test_hts[D]))}
		 then () = LFDKH := local_testK_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, pol_hash,
		 (Param->bool):(Param p): is_unitary_to_ht_big_SIMPLE(p,test_hts[D])
					  , test_hts[D], Uhash, fancy_tester)
		 then () = if test_verbose
		     	   then prints("unitary to ht ",test_hts[D], " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
		 {then ()= Dmid:=D}
                 then ()= D:=D+1
		 in ()
     	     od
     in ()
     fi{quick_flag}
    {now have faces of all dims, to height test_hts[Dlast]}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then () = if test_verbose
    	      then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   prints("using is_unitary_tester_big_SIMPLE_interrupt")
	      fi
    then mu_tester(Param p) = bool: is_unitary_test_big_SIMPLE_interrupt(p,[test_hts[Dlast] + 1])
    then start=elapsed_ms() {already unitary to height hts[test_levels[Dlast]] = test_hts[max(r,2)]}
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		 if test_interrupt_flag {up_mu_flag}
		 then mu_tester(p)
		 else is_unitary_hash_big_SIMPLE(p)
		 fi, Uhash)
    {Maybe NEED TO PUT BOTTOM LAYER STUFF BACK}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    then () = to_ht_flag:=true
    in UParams

set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash2(x, lambda, Lvd, LF, pol_hash, Uhash, is_unitary_hash_big_SIMPLE@Param)

{Compute 0 and 1 faces, pass to previous}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2) {impose Dirac, pos on LKTs}
	     else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)


{Compute 0 and 1 faces, ensuring hermitian, pos on LKTs, pass to previous}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, VertexData vd, LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash{, [[FaceVertsIndex]] global_faces}) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
    	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO2(KGBElt x, ratvec lambda) = [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form) {make_Param_hash()}, pol_hash = make_KTypePol_hash(), G = x.real_form
    {then vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash2(x,lambda,{vd,} pol_hash, Uhash)



{difficulty at which to revert to local_test_GEO_hash on each vertex.
0 to 100 make sense: higher means revert MORE often}
set diff_cutoff = int: 90

{0 to 10000 make sense. Setting to zero means NEVER revert to hash, and
10000 means always default}
set prod_cutoff = int: 3000

{3 is best for F4_s spherical
4 or 5 best for E7_s spherical}
set one_level = int: -1

{after unitary to one_level are found, run unitary_test(p, heights
from one_level+1 to last_level) to speed elimination of nonunitary. Need
to have last_level \ge one_level}
set last_level = int: -1

set hash_one_levelCounter = make_counter()

{assume local faces to dim 1 are recorded in LF, already herm and pos on LKTs}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, {VertexData vd,}
    LocalVertexData Lvd, [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if 1*pmin = zero_pol then return [] fi
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then pmax = pmax(x,lambda,Lvd)
    then (LAM,NUmax,R) = low(pmax)
    then htFrac = LAM/R {height(parameter(x,lambda,0*lambda))/(G.rho * G.two_rho_check)}
    {then temp_K_char_flag = step_flag}
    {htFrac <= CUTOFF}  {defaults to true if ht=0, false otherwise}
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
	      {use def_dumb if def_flag}
	      fi
    then r = rank(thetaMinus)
    then ONE = if one_level = -1 then (r+2)\2
    	       else one_level
	       fi
    then LAST = if last_level = -1 then ONE+1
    	      else last_level
	      fi
    {if LAST = ONE, then final step should be _just_ is_unitary}
    { then () = prints("ONE = ",ONE,", LAST = ",LAST) }
    then edge_offset_temp = edge_offset, step = max(G.semisimple_rank\2,1)
    then () = to_ht_flag:=true
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    {then depth= max(r+2, 4)}
    {max(((r-1)*edge_skip*stretcher)\1 + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)}
    {then maxDiffLoc = max_loc(for v in Lvd.list
    	 	       	      do G.two_rho_check*(dominant(G,thetaMinus*v))
		       	      od)
    then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])}
    then () = if NUmax < LAM*low_frac {is_unitary_to_ht is never a good idea}
    	      then to_ht_flag:=false
	      fi
    then () = if revert_flag and not to_ht_flag
    	      then to_ht_flag:=true;
	      	   return local_test_GEO_hash_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
	      {use def_dumb if def_flag}
	      fi
    then Shorthts = if short_hts_flag
    	 	    then short_hts(pmax)
		    else next_heights(pmax,LAST+1)
		    fi
    then hts =[int]: let () = if #Shorthts < LAST+1 and revert_flag
    	      		       then return local_test_GEO_hash_else_dumb(x, lambda, Lvd, LF,
			       	    Shorthts[:min(1,#Shorthts)], pol_hash, Uhash, fancy_tester)
	      		       fi
		      then d0 = min({max(}LAST+1{,depth+1)},#Shorthts)
    		      in Shorthts[:d0] ## for j:LAST + 1 - d0 do -1 od
    {then () = prints({"depth = ",depth,} "#Shorthts = ",#Shorthts, ", LAST = ",LAST)}
    then pol_hash0 = if step_flag{temp_K_char_flag}
    	 	     then make_KTypePol_hash() {to hold chars to height hts[0]}
		     else pol_hash
		     fi

    then approxMaxDiff = approxDiff(pmax)
    {then () = prints("approxMaxDiff = ",approxMaxDiff)}
    {now have at least two vertices. If it's an easy case,
    	 revert to local_test_GEO_hash}
    then () = if revert_flag and {(approxMaxDiff*approxVertexDiff < prod_cutoff) and}
    	      	 (approxMaxDiff < diff_cutoff)
	      then return local_test_GEO_hash_no_dumb(x, lambda, Lvd,
	      	   	  LF, hts, pol_hash, Uhash)
    	      fi
    then () = test_string:= " using local_test_GEO_hash_one_level"
    then start_count = unitary_test_counter.use_count()
    then  () = hash_one_levelCounter.use()
    {then hts = next_heights(parameter(x,lambda,0*lambda), LAST+1)}
    then one_ht = hts[ONE], last_ht = hts[LAST]
   then () =  if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing level = ", ONE, ", final level = ",LAST, "; heights = ", hts, new_line)
	       fi
   then KNU_flag_hold = KNU_flag
   then ICPNU_flag_hold = ICPNU_flag
   then () = KNU_flag:=false
   then () = ICPNU_flag:=false
   then HT = height(pmin)
   then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts
		  then is_unitary_to_hts_big_SIMPLE(p, hts[:ONE+1])
	 	  else is_unitary_to_ht_big_SIMPLE(p, one_ht)
	 	  {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
	 	  fi
   then long_out_temp_flag = long_out_flag
   then () = long_out_flag:=false
   {then two_temp_flag = step_flag and ONE > 0 and temp_K_char_flag}
   {then pol_hash_low = if two_temp_flag
   		       then make_KTypePol_hash()
		       else pol_hash_one_ht
		       fi}
   then startDBTcount = DBTcount
   then LFDKH = [[FaceVertsKHash]]:
   	 if red_count_flag and #LF[1] > 0
    	 then let (eq,CLBF) = localGraphRed(LF)
	      in localFD_KHash_01_graph(x, lambda, Lvd, hts[0], pol_hash0,LF, eq,CLBF)
	      	 {if two_temp_flag
	         then localFD_KHash_01_graph(x, lambda, Lvd, hts[0], pol_hash0,LF, eq,CLBF)
		 else localFD_KHash_01_graph(x, lambda, Lvd, one_ht, pol_hash_one_ht, LF, eq, CLBF)
		 {else localFD_KHash_01_graph(x, lambda, Lvd, pol_hash0, LF, eq, CLBF)}
	         fi {two_temp_flag}}
	  {elif two_temp_flag}
    	  else localFD_KHash_01(x, lambda, Lvd, hts[0], pol_hash0, LF)
	  {else localFD_KHash_01(x, lambda, Lvd, one_ht, pol_hash_one_ht, LF)}
	  {else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)}
	  fi {red_count_flag}
    then tester0 = (Param->bool): (Param p) bool:
     	     	  is_unitary_to_ht_big_SIMPLE(p, hts[0])
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash0, hts[0])
    	 		       {if two_temp_flag
    	 		       then localGraphK(LFDKH, pol_hash0, hts[0])
    			       elif temp_K_char_flag
	     	  	       then localGraphK(LFDKH, pol_hash_one_ht, one_ht)
			       else localGraphK(LFDKH, pol_hash, one_ht)
			       fi}
             {then () = prints("at hts[0], #eq = ", #eq)}
    then () = LFDKH := local_testK_hash(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, pol_hash0, tester0, hts[0], Uhash, fancy_tester)
	     {now we've tested verts and edges to hts[0]}
    then () = if test_verbose then prints("unitary to ht ",hts[0],
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
	      fi
    then two_temp_flag = step_flag and ONE > 0
    then pol_hash_one_ht = if two_temp_flag
   			   then make_KTypePol_hash()
			   else pol_hash0
			   fi
    then () = if two_temp_flag
    	      then let () = LFDKH := extend_K_characters(x, lambda, Lvd, LFDKH, one_ht, pol_hash_one_ht)
    	      	   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    		   then tester1 = (Param->bool): (Param p) bool:
     	     	   	if prefer_to_hts then is_unitary_to_hts_big_SIMPLE(p, hts[1:ONE+1])
	 	 	else is_unitary_to_ht_big_SIMPLE(p,one_ht)
		 	fi
		   {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
    		   in LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq,
		       	gr, CLBF, pol_hash_one_ht, tester1, one_ht, Uhash, fancy_tester)
	      fi
	      {now we've tested verts and edges to one_ht}
    then () = if test_verbose then prints("unitary to ht ",one_ht,
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	   fi
{ Have faces to dim 1 unitary to one_ht. Seek to extend list to all higher dims }
     then tester2(Param p) = is_unitary_to_ht_big_SIMPLE(p, one_ht)
     then () = if quick_flag
    	       then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   	  		LFDKH, 2,r+1, pol_hash_one_ht)
			    		    {now top degree in LFDKH is D+1}
		    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		    in LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, pol_hash_one_ht,
		      	       			tester2, one_ht, Uhash, fancy_tester)
	      else let D = int:1
     	      	   then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht(one_ht) on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   	LFDKH, D+1,D+2, one_ht, pol_hash_one_ht)
		    {now top degree in LFDKH is D+1}
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
					  in if all(for p in ps
					     	    do Uhash.lookup(p).>= or
						       tester2(p) {is_unitary_to_ht_big_SIMPLE(p,one_ht)}
	{better to use to_ht because usually p _already_ unitary to one_ht}
						    od)
					     then [LFDKH[D+1][m]]
					     else []
					     fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
                 then () = if test_verbose and
		      	   ((D = r-1)  or
    	      	    	   (#LFDKH < D) or
		    	   (#(LFDKH~[0]) <= D+2))
			   then prints("unitary to ht ",one_ht,
		      	      		   " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	      od
	      in ()
	      fi{quick_flag}
    then long_out_temp_flag = long_out_flag
    then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:= ICPNU_flag_hold
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then () = if test_verbose then { prints("unitary to ht ",one_ht, " faces by dim = ",
       	       	   		      		      unitary_by_dim);}
		prints("number of tests so far = ",unitary_test_counter.use_count() - start_count)
	      fi
    then () = LFDKH := extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
    then start=elapsed_ms()
    then () = long_out_flag := long_out_temp_flag
    then mu = K_type(x, pmax.lambda_minus_rho) {LKTs(pmax)[0]}
    then mu_tester(Param p) = bool: is_unitary_test_big_SIMPLE_interrupt(p,[one_ht + 1])
    then UParams = [Param]:
         if one_ht >=  0
         then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	      then () = if test_verbose then prints(sum(for list in LFDKH do #list od),
	      	      	   " unitary candidates in ",#eq," equivalence classes.") fi
              in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool):(Param p):
		      		    if test_interrupt_flag {up_mu_flag}
				    then mu_tester(p)
				    elif prefer_to_hts
		      		    then is_unitary_test_big_SIMPLE(p,hts[ONE+1:])
				    else is_unitary_test_big_SIMPLE(p,hts[LAST])
		      		    fi, Uhash)
		       {NEED PERHAPS TO PUT BOTTOM LAYER BACK}
          else for list@d in LFDKH
               do for v in list
                  do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		     then () = for  p1 in monomials(finalize(p))
                      	       do Uhash.match({herm_center(}p1{)});
                             	  if deform_flag
			     	  then for q in facet_deformed_new(p1)
                             	       do Uhash.match({herm_center(}q{)})
				       od
			     	  fi
                             	  od
		     then () = if long_out_flag
		      	       then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	    then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				    in ()
			       fi
		     in p
                  od
                od.##
	 fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line)
	      fi
   then () = to_ht_flag:=true
   in UParams {local_test_GEO_hash_one_level}
   {fi}

set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash_one_level(x, lambda, Lvd, LF, pol_hash, Uhash,
    is_unitary_hash_big_SIMPLE@Param)

{JUST CALCULATE FIRST TWO LEVELS}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash{,
    [[FaceVertsIndex]] global_faces}) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    in local_test_GEO_hash_one_level(x, lambda, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      	   {computes edges and verts, imposing hermitian and Dirac}
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    in local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_one_level(KGBElt x, ratvec lambda) = [Param]:
    let G = x.real_form
    then Uhash = big_unitary_hash.uhash(x.real_form){make_Param_hash()}, pol_hash = make_KTypePol_hash()
    {, vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_one_level(x,lambda,{vd,} pol_hash, Uhash)

{to be called by bottom_layer after bottom layer arguments}
set local_test_GEO_hash_one_level_end(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH,
    			KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    let G = x.real_form, r = rank(x.involution -1), thetaMinus = 1-x.involution
    then ONE = if one_level = -1 then (r+2)\2
    	       else one_level
	       fi
    then LAST = if last_level = -1 then ONE+1
    	      else last_level
	      fi
    {if LAST = ONE, then final step should be _just_ is_unitary}
    { then () = prints("ONE = ",ONE,", LAST = ",LAST) }
    {then edge_offset_temp = edge_offset
    then () = to_ht_flag:=true
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi}
    then long_out_temp_flag = long_out_flag
    then () = long_out_flag:=false {to allow using local_test_hash without recording Params}
    {then depth= max(r+2,4)}
    {max(((r-1)*edge_skip*stretcher)\1 + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)}
    {then maxDiffLoc = max_loc(for v in LFDKH[0]{Lvd.list}
    	 	      	      do let gamma = Lvd.list[v[0]]
    	 	       	      	 in  G.two_rho_check*(dominant(G,thetaMinus*gamma))
		       	      od)
    then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc]), step = max(G.semisimple_rank\2,1)}
    then pmax = pmax(x, lambda, Lvd)
    then mu = K_type(x,pmax.lambda_minus_rho)
    then (LAMmax,NUmax,) = low(pmax)
    then () = if NUmax < LAMmax*low_frac {is_unitary_to_ht is never a good idea}
    	      then to_ht_flag:=false
	      fi
    then hts =[int]: if to_ht_flag
    	     	     then let Shorthts = if short_hts_flag {guaranteed to be size LAST+1}
    	     	     	 	       	 then short_hts(pmax)
					 {elif up_mu_flag
					 then up_mu_hash.up_heights(mu{LKTs(pmax)[0]}, depth + 1 + up_shift)[1:]}
		     	      	    	 else next_heights(pmax,LAST+1)
				    	 fi
    		     	   then d0 = min(#Shorthts, LAST+1)
		     	   in Shorthts[:d0] ## for j:LAST+ 1 - d0 do -1 od
		     else for j:LAST+1 do height(pmax) od
		     fi
    {then () = prints("depth = ",depth, ", #Shorthts = ",#Shorthts, ", LAST = ",LAST)}
    then one_ht = hts[ONE], last_ht = hts[LAST]
    then approxMaxDiff = approxDiff(pmax)
    then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts then is_unitary_to_hts_big_SIMPLE(p, hts[:ONE+1])
	 	  else is_unitary_to_ht_big_SIMPLE(p,one_ht)
	 	  {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
	 	  fi
    then start_count = unitary_test_counter.use_count()
{eliminate vert/edges not unitary to one_ht}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, one_ht)
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, pol_hash,
    	       	  				 tester1, one_ht, Uhash, fancy_tester)
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash, one_ht)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, pol_hash, (Param->bool): (Param p): tester1(p),
		      one_ht, Uhash, fancy_tester)
		      	{test to the same height as not quick}
                   in if test_verbose
		      then prints("unitary to ht ",one_ht,
		      	      		" face counts to dim ",r,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
     then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht(one_ht) on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := {if temp_K_char_flag
	      	     	  	   then localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   	LFDKH, D+1,D+2, one_ht, pol_hash_one_ht)
				   else} localFD_KHashbt_lookDownGEO(x,lambda,Lvd,
				   	LFDKH,D+1,D+2,pol_hash)
				   {fi}
		    {now top degree in LFDKH is D+1}
		 then ((eq,gr),IUCL,CLBF) = {if temp_K_char_flag
		      			    then localGraphK(LFDKH)
					    else} localGraphK(LFDKH,pol_hash,one_ht)
					    {fi}
       	      	 {compute graph on faces to dim D+1}
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
					  in if all(for p in ps
					     	    do Uhash.lookup(p).>= or
						       tester1(p)
						    od)
					     then [LFDKH[D+1][m]]
					     else []
					     fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
                 then () = if test_verbose and
		      	   ((D = r-1)  or
    	      	    	   (#LFDKH < D) or
		    	   (#(LFDKH~[0]) <= D+2))
			   then prints("unitary to ht ",one_ht,
		      	      		   " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	      od
	      in ()
	      fi{quick_flag}
    {now LFDKH is everything unitary to ht one_ht}
    {then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:= ICPNU_flag_hold}
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then () = if test_verbose then { prints("unitary to ht ",one_ht, " faces by dim = ",
       	       	   		      		      unitary_by_dim);}
		prints("number of tests so far = ",unitary_test_counter.use_count() - start_count)
	      fi
   { then () = LFDKH := if temp_K_char_flag and red_count_flag and #LFDKH[1] > 0
    	      	     then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
    	      	     	  in extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red, CLBF_red)
		      elif temp_K_char_flag
		      then extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
    	      	      else LFDKH
	      	      fi}
    then mu_tester(Param p) = bool: is_unitary_test_big_SIMPLE_interrupt(p,[hts~[0] + 1])
    then start=elapsed_ms()
    then () = long_out_flag := long_out_temp_flag
    then UParams = [Param]:
         if one_ht >=  0
         then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	      then () = if test_verbose then prints(sum(for list in LFDKH do #list od),
	      	      	   " unitary candidates in ",#eq," equivalence classes.") fi
              in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool):(Param p):
	      	 		    if test_interrupt_flag {up_mu_flag}
				    then mu_tester(p)
		      		    elif prefer_to_hts
		      		    then is_unitary_test_big_SIMPLE(p,hts[ONE+1:])
				    else is_unitary_test_big_SIMPLE(p,hts[LAST])
		      		    fi, Uhash)
		       {NEED PERHAPS TO PUT BOTTOM LAYER BACK}
          else for list@d in LFDKH
               do for v in list
                  do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		     then () = for  p1 in monomials(finalize(p))
                      	       do Uhash.match({herm_center(}p1{)});
                             	  if deform_flag
			     	  then for q in facet_deformed_new(p1)
                             	       do Uhash.match({herm_center(}q{)})
				       od
			     	  fi
                             	  od
		     then () = if long_out_flag
		      	       then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	    then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				    in ()
			       fi
		     in p
                  od
                od.##
	 fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line)
	      fi
   in UParams {local_test_GEO_hash_one_level_end}

{when LKT length is GREATER than bottom_length_frac*(max possible), DO
NOT use bottom_layer. Leaving this at 1 means always use bottom_layer,
to negative means never bottom layer.}
set bottom_length_frac = rat: 1{??}

{if true, use coh_ind_is_unitary in final tests; else is_unitary}
set coh_ind_tester_flag = true

set one_level_revert_flag = true {false}

{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
{this version assumes more_flag, sets more_shift_level to bl_step_count*bl_step_size}
set local_test_GEO_hash_bottom_layer_interrupt(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) =
    [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms(),
    	UTCstart = unitary_test_counter.use_count()
    then zero_pol = null_module(G)
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
    then () = if ht = 0 {fine K-type in quasisplit G}
    	      then if one_level_revert_flag
	      	   then return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    then htFrac = ht/FPP_max_ht
    then () = more_shift_level:= bl_step_count*bl_step_size
    {then temp_K_char_flag= htFrac <= CUTOFF {CUTOFF defaults to 0}}
    then r = rank(thetaMinus)
    then pmin = parameter(x, lambda, Lvd.list[LF[0][0][0]] )
    then (Q0, pminL0) =  if small_test_flag
    	 	      	 then theta_stable_data_small(pmin)
		   	 else theta_stable_quasi_data(pmin)
		   	 fi
    then L0 = Q0.Levi
    then () = if (x.involution - 1).= {is_abelian(L0)}
    	      then let () = Uhash.match({herm_center(}first_param(finalize(pmin{pmax}{)})))
	      	   in return [pmin]
	      fi
    then DG0 = if small_test_flag
    	       then minSmallBottomData.G_min_height(x,lambda)
	       else max(for mu in LKTs(pmin)
    	       	    	do minBottomData.G_min_height(mu)
		   	od)
	       fi
    then Ds = for j:bl_step_count+1 do let H = height(pmin) + j*bl_step_size
    	      	  		       in if H > FPP_max_ht then {prints("too big H = ",H,", x = ",x.number,
				       	  ", lambda = ",lambda);} break fi;
				          H
				    od
     	{these are the greatest heights at which we'll be looking at bottom layer K-types;
	 so we can compute K-chars just to this height} {NOT TRUE for good range arguments!}
     then () = if L0=G
    	      then if one_level_revert_flag
	      	   then return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test_min_bottom(pmin, Uhash)
	      fi
    then () = test_string:= " using local_test_GEO_hash_bottom_layer"
    then  () = hash_bottom_layerCounter.use()
    then () =  if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing heights = ", Ds, new_line)
	       fi
    then startDBTcount = DBTcount
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
    {then () = if test_verbose then prints(" face counts to dim 1: ",for list in LFDKH do
			     #list od, "; Dirac_best eliminated ",
			  DBTcount - startDBTcount)
		    	    fi}
{then LFDKH = [[FaceVertsKHash]]: localFD_KHash_01(x,lambda, Lvd, pol_hash, LF)}
   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   {remove all faces failing min_bottom_elim}
   then () = LFDKH := local_testK_hash_min_bottom_layer(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, pol_hash,  Uhash, fancy_tester)
   then () = if test_verbose then prints("unitary on min_bottom layer face counts to dim 1: ",
   	for list in LFDKH do #list od) fi
   then () = if #LFDKH[0] = 0 then return [] fi
   then () = if #LFDKH[0] = 1 {not clear whether Ds help here; already passed min_bottom}
   	     then return if more_flag then one_param_test_bottom(parameter(x,lambda,
	     	  	    	      Lvd.list[LFDKH[0][0][0]]), Ds, Uhash)
	     	  	 else one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]),Uhash)
			 fi
	     fi
   then start_datas = elapsed_ms(), newDs = [int]:[]
   then MU = big_unitary_hash.branch(K_type_pol(pmin), Ds~[0])
   {then MU = K_type_pol(character_formula(}
   then datass =  for j:{bl_step_count} #Ds - 1 from 1
   	       	  do let datas = if Qs2_flag
		     	       	 then for mu in LKTs(pmin)
				      do if Qs2B_flag
		     	       	      	 then bottom_factors(bottom_K_type_Qs2B(mu,Q0, Ds[j-1], Ds[j]))
					 else for Q in max_Qs(Q0)
					      do bottom_K_type_Qs2(mu,Q, Ds[j-1], Ds[j])
					      od
					 fi {Qs2B_flag}
				       od.##
		  		 else bottom_factors(bottom_K_type_Qs(pmin, Q0, Ds[j-1], Ds[j]{, MU}))
				 fi {Qs2_flag}
		     {then () = prints("j = ",j,", card(datas) = ", card(datas),", datas = ",datas, new_line)}
		     in if max_ht(datas) > height(pmin) {card(datas) > 0}
		     	then newDs #:= Ds[j];
			     [datas]
		     	else []
			fi
		   od.##.##  {??? second ## should be removed, list structure USED ???}
   {then () = if test_verbose then prints("#datass = ",#datass, ", cardinalities = ", for datas in datass do card(datas) od) fi}
   then  maxQs = max_Qs(Q0)
   {next remove from LFDKH all faces failing bottom_factors_elim_factors_more}
   then () = if time_verbose then prints("time for more datass/maxQs was ",
    	      	 print_time_string(elapsed_ms() - start_datas), " at lambda = ",lambda)
	      fi
   {then m = 0, last = 0}
   then () = if #newDs > 0
   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   	     	  then () = LFDKH := local_testK_hash_bottom_layer_more(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, maxQs, datass, pol_hash, Uhash)
   		  then () = if test_verbose then prints("unitary on bottom layer to ",newDs~[0],
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	    fi
   	          then () = if #LFDKH[0] = 0 then return [] fi
   		  then () = if #LFDKH[0] = 1 {already passed newDs, so test_bottom useless}
   	     	       	    then return one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), Uhash)
	     		    fi
		  in ()
	      fi
   then DiffList = for v in LFDKH[0]
    	 	      do G.two_rho_check*(dominant(G,thetaMinus*Lvd.list[v[0]]))
		      od
   then maxDiffLoc = max_loc(DiffList), minDiffLoc = min_loc(DiffList)
{ Have faces to dim 1 bottom layer unitary to DG0. Seek to extend list to all higher dims }
  then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
       	    	     		r + 1, pol_hash)
    then unitary_by_dim = vec: for L in LFDKH do #L od
    {then gammamax = Lvd.list[LFDKH[0][maxDiffLoc][0]]}
    {then sph_far_flag = dominant(G,thetaMinus*gammamax)*G.two_rho_check/2 < to_ht_frac*(gammamax*G.two_rho_check)}
    then steps = max(r-1,1)
    then start=elapsed_ms()
    {then test_heights = next_heights(pmin, steps)
    then j0 = if #newDs = 0
    	      then -1
	      else first(for m in test_heights do newDs~[0] < m od)
	      fi
    	 {so that we test above the height bottom layer has examined}
    then HT = if j0 = -1
    	      then test_heights~[0]
	      else test_heights[j0]
	      fi}
    {then () = prints("testing to ",HT)}
    then UParams = [Param]:
         let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	 {these have had know_lower, min_bottom, and bottom_elim
	 already applied; so just do is_unitary_test}
    	 then () = if test_verbose
    	      	   then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   	prints("number of tests so far = ",unitary_test_counter.use_count() - UTCstart);
		   	prints("testing with def level 1")
	           fi
    	 in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p) bool:
			       is_unitary_def_test_big_SIMPLE(p), Uhash)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      fi
   in UParams

set local_test_GEO_hash_bottom_layer_interrupt(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash_bottom_layer_interrupt(x, lambda, Lvd, LF, pol_hash, Uhash,
    is_unitary_hash_big_SIMPLE@Param)

{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
{this version tries various bl_step_count_shift_levels increasing by bl_step_size. Computes the branching stuff
only when the test is needed.}
set local_test_GEO_hash_bottom_layer_step(KGBElt x, ratvec lambda, {VertexData vd,}
    			LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH, KTypePol_hash pol_hash,
    			Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    {if {zero case} #LF[0] = 0 then return [] fi;}
    {if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;}
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms(),
    	UTCstart = unitary_test_counter.use_count()
    then zero_pol = null_module(G)
    then () = more_shift_level:= bl_step_count*bl_step_size
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    then htFrac = ht/FPP_max_ht
     then r = rank(thetaMinus)
    then pmin = parameter(x, lambda, Lvd.list[LFDKH[0][0][0]] )
    then (Q0, pminL0) = if small_test_flag
    	 	      	then theta_stable_data_small(pmin)
		   	else theta_stable_quasi_data(pmin)
		   	fi
    then L0 = Q0.Levi
    then DG0 = if small_test_flag
    	       then minSmallBottomData.G_min_height(x,lambda)
	       else max(for mu in LKTs(pmin)
    	       	    	do minBottomData.G_min_height(mu)
		   	od)
	       fi
    then Ds = for j:bl_step_count+1 do let H = ht + j*bl_step_size
    	      	  		       in if H > FPP_max_ht then {prints("too big H = ",H,", x = ",x.number,
				       	  ", lambda = ",lambda);} break fi;
				          H
				    od


   then start_datas = elapsed_ms(), newDs = [int]:[]
   then () = bl_KHash.clear() {= make_KType_hash()}
   then (trial, newDs) = add_datas(pmin, Q0, {KHash,} Ds{, MU})
   {then () = if time_verbose then prints("cardinalities = ",for datas in datass do card(datas) od) fi}
   then  maxQs = max_Qs(Q0)
   {next remove from LFDKH all faces failing bottom_factors_elim_factors_more}
   then () = if time_verbose then prints("time for more datass/maxQs was ",
    	      	 print_time_string(elapsed_ms() - start_datas), " at lambda = ",lambda)
	      fi
   then () = if #trial> 0 {we found a nontrivial bottom layer argument}
   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   	     	  then () = LFDKH := local_testK_hash_bottom_layer_more_step(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, Q0, maxQs, trial, newDs, {MU,} pol_hash, Uhash, fancy_tester)
   		  then () = if test_verbose then prints("unitary on bottom layer to ",newDs~[0],
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	    fi
   	          then () = if #LFDKH[0] = 0 then return [] fi
   		  then () = if #LFDKH[0] = 1 {already passed Ds, so bottom_test useless}
   	     	       	    then return one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), Uhash)
	     		    fi
		  in ()
	      fi
   then DiffList = for v in LFDKH[0]
    	 	      do G.two_rho_check*(dominant(G,thetaMinus*Lvd.list[v[0]]))
		      od
   then maxDiffLoc = max_loc(DiffList), minDiffLoc = min_loc(DiffList)
{ Have faces to dim 1 bottom layer unitary to DG0. Seek to extend list to all higher dims }
  then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
       	    	     		r + 1, pol_hash)
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then steps = max(r-1,1)
    then start=elapsed_ms()
    then UParams = [Param]:
         let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	 {these have had know_lower, min_bottom, and bottom_elim
	 already applied; so just do is_unitary_test}
    	 then () = if test_verbose
    	      	   then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   	prints("number of tests so far = ",unitary_test_counter.use_count() - UTCstart);
		   	prints("testing with def level 1")
	           fi
    	 in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p) bool:
			       is_unitary_def_test_big_SIMPLE(p), Uhash)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      fi
   in UParams

set local_test_GEO_hash_bottom_layer_step(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash_bottom_layer_step(x, lambda, Lvd, LFDKH, pol_hash, Uhash,
    			is_unitary_hash_big_SIMPLE@Param)

{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,}
    			LocalVertexData Lvd, [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    			Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    if bl_interrupt_flag
    then more_flag:=true;
    	 {more_shift_level:=bl_step_count*bl_step_size}
	 return local_test_GEO_hash_bottom_layer_interrupt(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash,
	 	fancy_tester)
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G)
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
        then pmin = parameter(x, lambda, Lvd.list[LF[0][0][0]] )
    then (Q0, pminL0) = if small_test_flag
    	 	      	then theta_stable_data_small(pmin)
		   	else theta_stable_quasi_data(pmin)
		   	fi
    then L0 = Q0.Levi
    then () = if L0=G {fine K-type in quasisplit G}
    	      then if one_level_revert_flag
	      	   then more_after_flag:= false; min_after_flag:=false;
		   	return local_test_GEO_hash_one_level(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
		   else more_after_flag:=false; min_after_flag:=false;
		   	return local_test_GEO_hash2(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
		   fi
	      fi
    then r = rank(thetaMinus)
    then () = if (x.involution - 1).=
    	      then let () = Uhash.match(first_param(finalize(pmin)))
	      	   in return [pmin]
	      fi
    then D = min(ht + more_shift_level, floor(G.rho* G.two_rho_check))
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test_all_bottom(pmin, [ht,D], Uhash)
	      fi
    {then () = prints("Got past one_param_test_all_bottom")}
    then LKDatas = if small_test_flag
    	 	   then minSmallBottomData.entry(x,lambda)
		   else for mu in LKTs(pmin)
			do minBottomData.entry(mu)
			od
		   fi
    then () = if max(for list in LKDatas do max(for (tau,) in list do height(tau) od) od) =
    	      	 height(pmin) and not more_flag
    	      {#LKDatas = #LKTs(pmin) and not more_flag}
   	      then if one_level_revert_flag
	      	   then return local_test_GEO_hash_one_level(x, lambda, Lvd, LF, pol_hash, Uhash,
		   	       fancy_tester)
		   else return local_test_GEO_hash2(x, lambda, Lvd, LF, pol_hash, Uhash,
		   	       fancy_tester)
		   fi
	      fi
    {then () = prints("Got past small LFDatas")}
    then () = test_string:= " using local_test_GEO_hash_bottom_layer"
    {then () = prints("Got here; SHOULD set blcounter")}
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then  () = hash_bottom_layerCounter.use()
    then () = if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing height = ", D, new_line)
	       fi
    then UTCstart = unitary_test_counter.use_count()
    then startDBTcount = DBTcount
    {next step computes K-characters, possibly using red_count to reduce the number of calcs}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
       {label each face (vertex/edge) with index
   	      	in pol_hash of its K-character}
   then () = bl_KHash.clear()
   then () = for list in LKDatas
   	     do for (tau,) in list
	     	do bl_KHash.match(tau)
		od
	     od
   then () = if #ktypes(LKDatas) > #LKTs(pmin)
   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    	     	      {next remove from LFDKH all faces failing min_bottom_factors_elim}
   	     	  then () = LFDKH:= local_testK_hash_min_bottom_layer(x,lambda, Lvd, LFDKH, eq,
		       	    	    gr, CLBF, pol_hash,  Uhash, fancy_tester)
   	    	 {then () = prints("min bot faces = ",for list in LFDKH do #list od)}
   	    	  in if test_verbose
		     then prints("unitary on min_bottom layer face counts to dim 1: ",
   	    	       	       		for list in LFDKH do #list od)
		  		{; prints(parameter(x,lambda,Lvd.list[LFDKH[0][0][0]]))}
		      fi
	     fi
   then () = min_after_flag := not more_flag
   then () = if #LFDKH[0] = 0
   	     then return []
	     fi
   then () = if #LFDKH[0] = 1
   	     then return if more_flag then one_param_test_bottom(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), [D], Uhash)
	     	  	 else one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]),Uhash)
			 fi
	     fi

    then () = if bl_step_flag {bl_step_count steps of size bl_step_size; defaults to 2 and 5}
    	      then more_flag:=true;
    	      	   {if more_shift_level = 0 then more_shift_level := maxht - ht fi;}
    	           return local_test_GEO_hash_bottom_layer_step(x, lambda, Lvd, LFDKH, pol_hash, Uhash,
		   	  fancy_tester)
	      fi
   then maxQps = max_Qps(pmin,pmin)
   then () = maxQps := for (Q,pL) in maxQps
    	 	   do if is_hermitian(pL)
		      then [(Q,pL)]
		      else []
		      fi
		   od.##
   then start_data = elapsed_ms()
   then () = if more_flag {want to use non-minimal theta-stable q} {??? USE Qs2 ???}
   	     then let datas = if Qs2_flag
	     	      	      then let ans = for mu in LKTs(pmin)
			      	       	     do if Qs2B_flag
					      	then bottom_factors(bottom_K_type_Qs2B(mu,Q0,height(pmin),D))
						else for (Q,pL) in maxQps
				       	      	      do let (,data) = bottom_K_type_Qs2(mu,Q,D)
						      	 in if #data > 1
						       	    then [(Q,data)]
						       	    else []
						       	    fi
					  	      od.##
						  fi
				       	      od.##
				   {then () = for (Q,) in ans do prints(Q, Q.S) od}
				   in if test_verbose
				      then prints("time to compute Qs2 data at (",x,",",lambda,") = ",
				      	   print_time_string(elapsed_ms() - start_data))
				      fi;
				      ans
			      else let ans = [QKL_bottom_data]:
				       bottom_factors(bottom_K_type_Qs(pmin, Q0, D))
				   then good_ans = for (Q,data) in ans
				   		   do if #data > 1
						      then [(Q,data)]
						      else []
						      fi
						   od.##
				   {then () = for (Q,) in ans do prints(Q, Q.S) od}
				   in if test_verbose
				      then prints("time to compute QKL data at (",x,",",lambda,") = ",
				      	    print_time_string(elapsed_ms() - start_data))
				      fi;
				      good_ans
			      fi
	     	  then () = if any(for (Q,list) in datas do @bool:
		       	       	   any(for (tau,) in list do @bool: height(tau) > height(pmin) od) od)
		       	    then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		  	    	 then  maxQs = max_Qs(Q0) {all MAXIMAL theta-stable containing Q0}
				 then () = LFDKH := local_testK_hash_bottom_layer_more(x,lambda, Lvd,
			    	      	   	 LFDKH, eq, gr, CLBF, maxQs, datas, pol_hash,  Uhash)
			    	  	 {bottom layer test on K-types in datas}
   		  	    	 then () = if test_verbose then prints("unitary on bottom layer to ",D,
		   	    	      	 	" face counts to dim 1: ",for list in LFDKH do #list od)
		    	    	           fi
   		  	    then () = if #LFDKH[0] = 0 then return [] fi
			    then () = more_after_flag:=true
		  	    then () = if #LFDKH[0] = 1 {already passed D}
   	     	       	    	      then return one_param_test(parameter(x,lambda,
			    	      	   Lvd.list[LFDKH[0][0][0]]),{ [D],} Uhash)
	     		    	      fi
		  	    in ()
			    fi
		    in ()
	      fi
	      {now have list of vertices and edges passing bottom layer test out to D}
   then () = more_after_flag := more_flag
   then () = min_after_flag := not more_flag
   in if one_level_revert_flag
      then local_test_GEO_hash_one_level_end(x, lambda, Lvd, LFDKH, pol_hash, Uhash, fancy_tester)
      else local_test_GEO_hash2_end(x, lambda, Lvd, LFDKH, pol_hash, Uhash, fancy_tester)
      fi

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, LocalVertexData Lvd,
[[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
local_test_GEO_hash_bottom_layer(x, lambda, Lvd, LF, pol_hash, Uhash,
is_unitary_hash_big_SIMPLE@Param)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2{, mapAct}{, global_faces}) {impose Dirac}
	      else localFD_1Dirac2(x, lambda, Lvd, Perm2{, mapAct})
	      fi
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    [[FaceVertsIndex]] global_faces) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2{, mapAct})
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2{, mapAct})
	      fi
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2{, mapAct})
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2{, mapAct})
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_bottom_layer(KGBElt x, ratvec lambda) = [Param]:
    let G = x.real_form
    then Uhash = big_unitary_hash.uhash(x.real_form){make_Param_hash()}, pol_hash = make_KTypePol_hash()
    {, vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_bottom_layer(x,lambda, {vd,} pol_hash, Uhash)

set spherical_general(RealForm G, (KGBElt, ratvec->[Param]) local) = [Param]:
    let start = elapsed_ms()
    then r = rank(x_open(G).involution - 1)
    then answer = local(x_open(G), G.rho)
    then () =  {if time_verbose
    	       then} prints("Total time ", print_time_string(elapsed_ms() -start)) {fi}
    then () = if long_out_flag
    	      then prints("unitary faces by dim = ", for j:r+1 do #LFDKHByDim[j] od,
    	      	   		   	     	   test_string)
	      fi
    then () = if long_out_flag
    	      then prints("number of distinct K-characters = ",NumKchars())
	      fi
    in answer

{this gives def_dumb if def_flag = true}
set spherical_dumb(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO_dumb@(KGBElt, ratvec))

set spherical_def_dumb(RealForm G) = [Param]:
    let () = def_flag:=true
    in spherical_general(G, local_test_GEO_dumb@(KGBElt, ratvec))

set spherical(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO@(KGBElt, ratvec))

set spherical2(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO2@(KGBElt, ratvec))

set spherical_one_level(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO_one_level@(KGBElt, ratvec))
