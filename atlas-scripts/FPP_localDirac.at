<FPP_faces_herm
<simple_factors { for simple_factors }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]), no_reps}
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<unity.at { for is_unitary_test }
<bottom_layer.at {for bottom layer unitarity tests}
<springer_tables_reductive.at { for Springer_table }
<associated_variety_annihilator.at { for GK_dim, used in identifying unipotent reps }
<weak_packets.at {for unipotent_representations}
<derived_cover.at {for sc_descends}
<cohIndUnip.at {for is_FPP}
{ <lietypes.at { for simple_type }}
{ <parabolics.at {for parabolic_by_wt}}
<K_highest_weights.at {for all_lambda_differential_zero}
<lattice.at {for vec_solve}
{ <chopping_faces_fast.at {for chop_coroots(G, vertices)}}
<face_classes.at {for ordering on faces}
<hash.at {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<translate {for translate_param_by}
<time {for print_string}
{<powerTwo.at} {for fast raising to powers of two using make_power_function }
{This is meant to be functions for computing all unitary reps with
fixed LKT (x,lambda) and infl char in the FPP. Functions are meant to
use a Param_has Uhash containing a list of known unitary reps (like
Arthur's special unipotent ones) in order to avoid doing difficult
is_unitary calculations.

Throughout, the VertexData vd is meant to be the list of all vertices
in the FPP (that are fixed by the distinguished involution), and a
lookup function.

Attached to theta = x.involution and dlambda are

Perm = vec (size = number of vertices of FPP)
{mapAct = vec (size = number of vertices of FPP)}
Lvd = VertexData (vertex infinitesimal chars v in the FPP of Params
      		 (x, lambda v))

Here Perm is a partially defined permutation of order two of (indices
for) vd.list: it can happen that

- Perm[i] = i (fixed vertex v_i, so (x,lambda,v_i) is a Param of infl char
v_i); or

- Perm[j] = k != j, and Perm[k] = j, so (x,lambda, (v_j+v_k)/2) is a Param
  of infl char (v_j + v_k)/2; or

- Perm[ell] = -1, in which case v_ell has nothing to do with FPP Params
  at (x,lambda)

Say there are P fixed i and Q pairs (j,k). Then Lvd.list is the P+Q
vertices v_i and (v_j+v_k)/2, numbered in some way (probably not
reasonable).

{mapAct is a partially defined map from the indices for vd.list to the
indices for Lvd.list.

If Perm[i] = i, then mapAct[i] = index of v_i in Lvd.list

If Perm[j] = k != j, then mapAct[j] = mapAct[k] = mapAct[j] =
number of (v_j+v_k)/2 in Lvd.list

For other ell, mapAct[ell] = -1.}

Suppose (a_0,...,a_d) are the vertex numbers (indices in vd.list) of a d-diml face of the
FPP. Then this face meets FPP Params at (x,lambda) if and only if
(a_0,...,a_d) consists of p entries with Perm[a_i] = a_i and 2q
entries (a_j, a_k) exchanged by Perm (and no -1 entries). In this case
our face meets the FPP infl chars in a face of dimension p+q-1, with
vertices the fixed a_i and the various (a_j+a_k)/2.

The function localFD_Lvd(x, lambda, vd) computes (Lvd, Perm{, mapAct}).

Each d-dimensional (local) face at (x,lambda) is referred to by the
vec of its d+1 indices in Lvd.list. Appended to the end of this vec is
a single integer giving the location of the K_character of the local
face in a KTypePol_hash pol_hash.

There are four main functions, each taking either a long argument

(x, lambda, vd, LVD, Perm{, mapAct}, pol_hash, Uhash)

if you already have these in hand, or a short argument

(x, lambda, Uhash).

Functions each produce a list of all Params (x, lambda, nu_j), each
the barycenter of its local face, each having weakly dominant
infinitesimal character in the FPP (but possibly not final), and each
having all Langlands quotients unitary. These unitary reps are also
added to Uhash.

Here is a description of the four algorithms between these.

*******************
local_test_GEO_hash_dumb

This finds all vertices, then all edges, and computes the graph; then
removes all nonunitary vertices and edges.

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[D] faces; then makes a directed graph, and
eliminates all nonunitary faces.

The version def_dumb (invoked by def_flag = true, which is the
default) does unitarity tests using is_unitary_def_test.
*******************
local_test_GEO_hash
This finds all unitary-to-hts[0] vertices, then all unitary-to-hts[0]
edges.

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[D] faces; then makes a directed graph, and
eliminates all faces failing is-unitary-to-hts[D].

Now it has all faces of all dimensions passing is-unitary-to-hts[top
dim -1]. From these it makes a graph, and computes is_unitary.
*******************
local_test_GEO_hash2

Finds ALL vertices, then ALL edges; then makes a graph, and discards
all vertices and edges failing is_unitary_to_hts[0].

Rest is same as local_test_GEO_hash. This version seems faster because
use of the graph up to dimension 1 reduces the number of
is_unitary_to_hts[0] tests.
********************
local_test_GEO_hash_one_level

Assesses the "difficulty" of this case. If it's relatively easy,
reverts to local_test_GEO_hash2. Otherwise...

Finds ALL vertices, then ALL edges; then makes a graph, and discards
all vertices and edges failing is_unitary_to_hts[0, 1, ... ,
one_level].

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[one_level] faces; then makes a directed graph, and
eliminates all D+!-diml faces failing is-unitary-to-hts[one_level].

Now it has all faces of all dimensions passing
is-unitary-to-hts[one_level]. From these it makes a graph, and
computes is_unitary using is_unitary_test([one_level+1,...,last_level])
}

{given a sequence hts of hts to test, is_unitary_to_ht(p, hts~[0]) and
is_unitary_to_hts(p, hts) give the same result. If true, prefer using
the second. This seeks to eliminate easy cases by is_unitary_to_ht(p,
hts[0]) before trying the difficult is_unitary_to_ht(p,hts~[0])}
set prefer_to_hts = true

{. If "true," then print number of invocations of a unitarity test .}
set test_verbose = true

{. If "true," then print a little info about invocations of a unitarity test .}
set test_slightly_verbose = true


{. If "true," then calculations of unitary reps of a certain LKT
compute also the unitary deformations of these, with bigger
LKT's. This is unimportant for calculating say the spherical FPP
unitary dual, but very helpful with the FULL FPP unitary
dual. Therefore the functions FPP_unitary_hash... set this flag to
"true".}
set deform_flag = false

{. If "true," then some local FPP calculations revert to simpler (?)
   forms in "simple" cases.}
set revert_flag = true

{If "false", use the old version of one_level, in which vertex/edge calcs
are done immediately to ONE_HT}
set step_flag = false

{If "true", then hash_dumb uses real_dumb, which does less to_ht}
set real_flag = false

{If "true", then hash_dumb uses is_unitary_def_test, and hts are calculated with deform_hts}
set def_flag = {false} true

{if "false" use next_heights instead of short_hts, to avoid calculating
deform (KL calculations). So prefer false for rank \ge 7?}
set short_hts_flag = false

set long_out_flag = false

{If true, use bottom_layer_interrupted}
set bl_interrupt_flag = false

{If true, use bottom_layer_stepped}
set bl_step_flag = false

{number of different shifts to try in bl_interrupt and bl_step}
set bl_step_count = 2

{how much to increase the shift at each step}
set bl_step_size = 5

{almost always it makes sense to preload the Arthur unipotent
reps. But not in a few test situations.}
set unip_flag = true

{if KGB number is below this times #KGB, use is_unitary rather than is_unitary_to_ht}
set low_KGB_frac = rat: 1/2


set difficulty(Param p) = rat:
    let rA = HTA(p)
    in if rA=0 then 0
       else rA/HT(p.real_form,p.infinitesimal_character)
       fi

{Integer between 0 and 100; integer part of 100*difficulty}
set approxDiff(Param p) = int:
    let q = difficulty(p)
    in (q.numer *100)\q.denom

{rational number, between 0 and 1 on FPP: how nu compares to rho in HT.
0 means tempered}
set difficultyA(Param p) = rat:
    let rA = HTA(p), G = p.real_form
    in rA/((G.rho)*(G.two_rho_check))

{Nonneg integer between 0 and 100; integer part of 100*difficultyA}
set approxDiffA(Param p) = int:
    let q = difficultyA(p)
    in (q.numer *100)\q.denom

{rational for increasing (stretcher > 1) or decreasing (stretcher < 1) the number of to_ht tests}
set stretcher = rat: 1/1

{ Block of p, including zero parameters. Relevant because that's where
KL calculations need to happen }
set full_block(Param p) = [Param]:
let G = p.real_form
in for q in block_of(translate_param_by(p, G.two_rho))
   do translate_param_by(q, -G.two_rho)
   od
{in is_unitary_to_ht(N), KL calculations live in this subset of
full_block}
set full_block_to_ht(Param p, int N) = [Param]:
    for q in full_block(p)
    do if height(q) <= N then [q] else [] fi od.##

set ht_saving(Param p, int N) = rat:
    #full_block_to_ht(p,N)/#full_block(p)

{ between 0 and 100. SMALL means is_unitary_to_ht is likely to be
faster than is_unitary.

If N \ge height(p), then full_block_to_ht(p) always includes p; so

0 < ht_saving(p,N) \le 1.

Therefore 0 \le approx_ht_saving(p,N) \le 100}
set approx_ht_saving(Param p, int N) = int:
    let rp = reducibility_points(p)
    then result = int:
    	 if #rp = 0 then 0
	 else let r = ht_saving(p*rp~[0],N)
    	      in (r.numer *100)\r.denom
	 fi
    in result

{computes directed graph of local faces. Output GraphData is
[[int]],[[int]] giving equivalence classes and the graph. Next output
[vec]s are IUCL and classListByFace}
{9/25/23: have extra coord in FaceVertsKHash to record # Langlands quotients}
set localGraphK([[FaceVertsKHash]] LFvertsK) = (GraphData, [vec],[vec]):
    {let () = if face_verbose then prints("start to compute face graph K")
    	     fi}
    let start = elapsed_ms()
    then (eq,gr) = GraphData: up_data(LFvertsK)
    {then() = prints("number of graph equivalence classes = ",#eq)}
    then classListByFace = [vec]: class_lists(LFvertsK,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
    then time = elapsed_ms() - start
    { then () = if time_verbose
	      then prints("     ", print_time_string(time),
	           " for localGraphK calculation ") fi }
    in ((eq,gr), IUCL, classListByFace)

set localGraphK([[FaceVertsKHash]] FDKH, KTypePol_hash pol_hash, int level) =
    (GraphData, [vec],[vec]):
    let () = if face_verbose then prints(new_line,"start to compute face graph K to level ",
    	     		      	   			  level)
    	     fi
    then start = elapsed_ms()
    then (eq,gr) = GraphData: up_data(FDKH,pol_hash,level)
    {then () = for v in eq do prints(v) od}
    {then() = prints("number of graph equivalence classes to height = ",#eq)}
    then classListByFace = [vec]: class_lists(FDKH,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr)
    { then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   " for localGraphK calculation") fi}
	 in ((eq,gr), IUCL, classListByFace)

{classes have common value of red_count, so same K-character}
set localGraphRed([[FaceVertsIndex]] LF) = ([[int]], [vec]):
    let (eq,gr) = GraphData: K_graph_data(LF)
    then classListByFace = [vec]: class_lists(LF,(eq,gr))
    in (eq, classListByFace)

set look_up_vertices ([ratvec] vertices, [int] face)=[ratvec]:
   for n in face do vertices[n] od

set remove_closure ([vec] short,[vec] long) =[vec]:
  ##for v in short
    do if any(for w in long do sorted_is_subset(v,w) od)
       then [] else [v]
       fi
    od

set remove_closure ([[vec]] all, int k) =[[vec]]:
   for level@i in all do if i<k
	       then remove_closure (level,all[k])
	       else level
	       fi od

{returns the collection of unipotent points in list, as coords in list. If (x,lambda)
 has more than one LKT, only keep the unipotent irrs having ALL these LKTs.}
set local_unipotent_classes(KGBElt x, ratvec lambda, VertexData (list,lookup)) = vec:
(   let () = if face_verbose
    	     then prints("start local_unipotent_classes")
	     fi
    then G = x.real_form
    then st = G.dual.Springer_table
    in if not(is_split(G) and (x=x_open(G)) and (lambda = G.rho))
       then for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
      	      in if m0 >= 0 and #finalize(parameter(x,lambda,gamma)) = 1 and
	      	 GK_dim(parameter(x,lambda,gamma)) = dim(st.dual_map(O))/2
		 then [m0]
		 else []
		 fi
	   od.##
	else for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
     	       in if m0 >= 0
	       	  then [m0]
		  else []
		  fi
	   od.##
	fi
)

{inserts special unipotent reps in unitary_hash}
set unipotents_to_hash(RealForm G, Param_hash Uhash) = void:
    if unip_flag
    then for p in unipotent_representations(G) do Uhash.match(p) od
    else ()
    fi

{add only those unipotent reps of Gsc factoring to a quotient G, with M: X*(G1) -->
X*(G) the corr wt inclusion}
set unipotents_to_hash(RealForm G, RealForm Gsc, Param_hash Uhash, mat M) = void:
    if unip_flag
    then for psc in unipotent_representations(Gsc)
    	 do if solve(M,psc.lambda_minus_rho).any
       	    then for  p in sc_descends(psc, G, M)
	    	 do Uhash.match(p)
	    	 od
       	    fi
         od
    else ()
    fi

{assume Gsc --> G corrs to M: X*(G) --> X*(Gsc); assume Usc_hash is
reps of Gsc; put in U_hash those descending to G}
set descend_to_quotient(RealForm G, Param_hash Usc_hash, Param_hash U_hash, mat M) = void:
    for j:Usc_hash.size()
    do let psc = Usc_hash.index(j)
       in if solve(M, psc.lambda_minus_rho).any
       	  then for p in sc_descends(psc, G, M)
	       do U_hash.match(p)
	       od
	  fi
    od

{inserts special unipotent reps in [unitary_hash]; assumed to have one
 for each KGBElt}
set unipotents_to_hashes(RealForm G, [Param_hash] Uhashes) = void:
    if unip_flag
    then for p in unipotent_representations(G)
    	      do let (,xnum) = %p.x
	         in Uhashes[xnum].match(p)
	      od
    else ()
    fi

{whether to fill in statuses for known unitaries in local_testK_hash
and local_test_hash}
set KU_flag = true

{count how often nonunitary induction identifies nonunitary rep}
set NU_ind_counter = 0

{count how often unitary induction identifies unitary rep}
set U_ind_counter = 0

{whether to fill in statuses for known non-unitaries in local_testK_hash
and local_test_hash}
set KNU_flag = false

{whether to look at ind_cand_params to determine unitarity}
set ICPU_flag = false {true becomes very slow in rk 6}

{whether to look at ind_cand_params to determine nonunitarity}
set ICPNU_flag = false {true becomes very slow in rk 6}

{if true, functions in FPP_global pass through KGB backwards}
set tilde_flag = false

{set this to true to use wiggle tests in know_more mode in local_testK_hash_bottom_layer,
which handles the most cases}
set wiggle_flag0 = false

{set this to false to avoid wiggle tests in know_more mode later on}
set wiggle_flag = true

{test candidate classes with (new) tester; delete
 from LFVKH faces established to be nonunitary in this way. Output is new
 shorter list of candidate faces. Lvd is LOCAL LocalVertexData}
 {If tester is to_ht, then OK to all eq to be computed to_ht. Trickier for bottom_layer.}
 {Seems to require that equivalence classes be for ENTIRE K-char, not to height}
 {called lines 2183...}
set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    (Param->bool) tester, Param_hash Uhash) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes as known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				    then ()=newStatuses:= downdateUclassesB(newStatuses, gr, k, "T")
				    in newStatuses[k] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
    {then () = if KNU_flag {and #FVKH = 2} 
    	      then let knownNonUnitaries = known_non_unitaries(NUhash, x, lambda, Lvd, FVKH)
    	      	   then () = for list@d in knownNonUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "F"
	    	 		od
	      		     od
		   in ()
	       fi}
    then () = if fund_face_verbose
    	      then prints("     Examining ",NumClasses," classes in local_testK_hash; ",
	      count(for ans in newStatuses do ans[0] = "T" od)," are known unitary.")
	      fi
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash, ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and {removing ~ costs 5% in Spin(4,4)}
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		     then (d,j) = coords(FVKH,C[0])
	      	     then verts = vec: FVKH[d][j][:d+1]
	      	     then ps = monomials(finalize(parameter(x, lambda
		    	  , face_bary(Lvd, verts))))
		     {then () = prints(new_line,"k = ",k,", ICPNU_flag = ",ICPNU_flag,", ICPU_flag = ",ICPU_flag)
		     then () = prints("before ICPNU, newStatuses = ",newStatuses)}
		     then () = if ICPNU_flag {test for non-unitary}
		       	       then if any(for p in ps
		       	       	    	   do any(for pi in ind_cand_params(p)
				      	       	  do not is_unitary_hash_big_SIMPLE(pi)
					       	  od)
				   	   od)
		       	     	     then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
				     	  NU_ind_counter+:=1;
				  {this appears to mark as nonunitary-under-tester anything equivalent to
				   a non-unitary-under-tester face}
			     	  {prints("Khash ICP F: ",parameter(x,lambda,face_bary(Lvd,verts)));}
			     	  	  newStatuses[k] := "F"
			     	    fi
		       		fi
		     {then () = prints("before ICPU, newStatuses = ",newStatuses)}
		     then () = if ICPU_flag {test for unitary}
		       	       then if all(for p in ps
		       	       	    	   do #ind_cand_params(p) > 0
					      and all(for pi in ind_cand_params(p)
				      	       	       do is_unitary_hash_big_SIMPLE(pi)
					       	       od)
				   	   od)
		       	     	     then newStatuses[k] := "T";
				     	  U_ind_counter+:=1{;
			     	  prints("Khash ICP T: ",parameter(x,lambda,face_bary(Lvd,verts)))}
			     	    fi
		       		fi
		     {then () = prints("before NEWU, newStatuses = ",newStatuses)}
	             in if{NEWU} newStatuses[k] = "?"
		     	then if ps[0].nu.= or all(for p in ps do Uhash.lookup(p).>= or tester(p) od)
		     	     then newStatuses[k]:= "T"
		     	     else newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     	     	; newStatuses[k] := "F"
			     fi
		     	fi{NEWU}
		 fi {newStatuses[k] = "?"}
	      od
     {then () = prints("after first loop, newStatuses = ",newStatuses)}
     then () = if fund_face_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq
	       	    do if newStatuses[m][0] = "T"
     	     	       then {for k in C
		       	    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od}
			    for k in C
			    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od
		       fi
		    od
     {then () = if #FVKH = 3 then prints(FVKHnew[2]) fi}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

{test candidate classes with (new) tester; delete
 from LFVKH faces established to be nonunitary in this way. Output is new
 shorter list of candidate faces. Lvd is LOCAL LocalVertexData}
{
set local_testK_hash_status(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHashStatus]] FVKHS, [[int]] eq, [[int]] gr, [vec] classListByFace,
    (Param->bool) tester, Param_hash Uhash) = [[LocalFaceVertsKHashStatus]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes as known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    {then () = if KU_flag {and #FVKH = 2}
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				    then ()=newStatuses:= downdateUclassesB(newStatuses, gr, k, "T")
				    in newStatuses[k] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
    {then () = if KNU_flag {and #FVKH = 2} 
    	      then let knownNonUnitaries = known_non_unitaries(NUhash, x, lambda, Lvd, FVKH)
    	      	   then () = for list@d in knownNonUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "F"
	    	 		od
	      		     od
		   in ()
	       fi}}
    then () = if fund_face_verbose
    	      then prints("     Examining ",NumClasses," classes in local_testK_hash_status; ",
	      count(for ans in newStatuses do ans[0] = "T" od)," are known unitary.")
	      fi
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash, ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and {removing ~ costs 5% in Spin(4,4)}
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		     then if any(for c in C
		     	     	 do let (d,j) = coords(FVKHS,c)
				    in FVKH[d+2] > 0)
				 od)
		     then (d,j) = coords(FVKH,C[0])
	      	     then verts = vec: FVKH[d][j][:d+1]
	      	     then ps = monomials(finalize(parameter(x, lambda
		    	  , face_bary(Lvd, verts))))
		     {then () = prints(new_line,"k = ",k,", ICPNU_flag = ",ICPNU_flag,", ICPU_flag = ",ICPU_flag)
		     then () = prints("before ICPNU, newStatuses = ",newStatuses)}
		     then () = if ICPNU_flag {test for non-unitary}
		       	       then if any(for p in ps
		       	       	    	   do any(for pi in ind_cand_params(p)
				      	       	  do not is_unitary_hash_big_SIMPLE(pi)
					       	  od)
				   	   od)
		       	     	     then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
				     	  NU_ind_counter+:=1;
			     	  {prints("Khash ICP F: ",parameter(x,lambda,face_bary(Lvd,verts)));}
			     	  	  newStatuses[k] := "F"
			     	    fi
		       		fi
		     {then () = prints("before ICPU, newStatuses = ",newStatuses)}
		     then () = if ICPU_flag {test for unitary}
		       	       then if all(for p in ps
		       	       	    	   do #ind_cand_params(p) > 0
					      and all(for pi in ind_cand_params(p)
				      	       	       do is_unitary_hash_big_SIMPLE(pi)
					       	       od)
				   	   od)
		       	     	     then newStatuses[k] := "T";
				     	  U_ind_counter+:=1{;
			     	  prints("Khash ICP T: ",parameter(x,lambda,face_bary(Lvd,verts)))}
			     	    fi
		       		fi
		     {then () = prints("before NEWU, newStatuses = ",newStatuses)}
	             in if{NEWU} newStatuses[k] = "?"
		     	then if all(for p in ps do Uhash.lookup(p).>= or tester(p) od)
		     	     then newStatuses[k]:= "T"
		     	     else newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     	     	; newStatuses[k] := "F"
			     fi
		     	fi{NEWU}
		 fi {newStatuses[k] = "?"}
	      od
     {then () = prints("after first loop, newStatuses = ",newStatuses)}
     then () = if fund_face_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq
	       	    do if newStatuses[m][0] = "T"
     	     	       then {for k in C
		       	    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od}
			    for k in C
			    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od
		       fi
		    od
     {then () = if #FVKH = 3 then prints(FVKHnew[2]) fi}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew
}

set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    int ht, Param_hash Uhash) = [[FaceVertsKHash]]:
    let tester = ((Param->bool): (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, ht))
     in local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, tester, Uhash)



{test candidate classes with (new) tester. Assume know_lower_flag is true,
 and use that to get rid of some candidates. Delete
 from LFVKH faces established to be nonunitary in this way. Output is new
 shorter list of candidate faces. Lvd is LOCAL VertexData}
set local_testK_hash_know_lower(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    (Param->bool) tester, Param_hash Uhash) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
   { then () = if KNU_flag {and #FVKH = 2}
    	      then let knownNonUnitaries = known_non_unitaries(NUhash, x, lambda, Lvd, FVKH)
    	      	   then () = for list@d in knownNonUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "F"
	    	 		od
	      		     od
		   in ()
	       fi}
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash_know_lower, ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and {removing ~ costs 5% in Spin(4,4)}
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0])
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
		  {then () = prints("d = ",d,", pC = ",pC)}
	      	  then ps = monomials(finalize(pC))
		  then () = if ICPNU_flag {test for non-unitary}
		       	    then if any(for p in ps
				    	do any(for pi in ind_cand_params(p)
			    	       	       do not is_unitary_hash_big_SIMPLE(pi)
				       	       od)
				    	od)
		       	          then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
				       NU_ind_counter+:=1;
			          {prints("know_lower ICP F: ",pC);}
			     	       newStatuses[k] := "F"
			         fi {any p}
		       	     fi {ICP_flag}
		     then () = if ICPU_flag {test for unitary}
		       	       then if all(for p in ps
		       	       	    	   do #ind_cand_params(p) > 0
					      and all(for pi in ind_cand_params(p)
				      	       	       do is_unitary_hash_big_SIMPLE(pi)
					       	       od)
				   	   od)
		       	     	     then U_ind_counter+:=1;
				     	  newStatuses[k] := "T"
			     	  {prints("know_lower ICP T: ",parameter(x,lambda,face_bary(Lvd,verts)));}
			     	    fi
		       		fi
	          in if newStatuses[k] = "?"
		     	and not is_final(pC) and all(for q in ps
		     	    		     	 do @bool: is_finished(q.x,q.lambda)
						    and Uhash.lookup(q).>=
					    	 od)
		     then newStatuses[k]:="T"
		     elif {know_lower_flag and} any(for q in ps
		     	    	   	    do @bool: is_finished(q.x,q.lambda)
					    and (Uhash.lookup(q) = -1)
					    od)
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     ; newStatuses[k] := "F"
		     fi;
		     if{NEWU} newStatuses[k] = "?"
		     	then if{all} all(for p in ps do Uhash.lookup(p).>= or tester(p) od)
			     {if p is unitary, tester(p) may record that fact in Uhash}
		     	     then newStatuses[k]:= "T"
		     	     else newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     	     ; newStatuses[k] := "F"
		     	     fi{all}
		     fi{NEWU}
	         fi
	      od
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq
	       	    do if newStatuses[m][0] = "T"
     	     	       then for k in C
			    do let (d,j) = coords(FVKH,k)
			       then verts = vec: FVKH[d][j][:d+1]
			       then pC = parameter(x, lambda, face_bary(Lvd, verts))
			       then ps = monomials(finalize(pC))
			       then () = for q in ps do Uhash.match({herm_center(}q{)}) od
			       in FVKHnew[d] #:= FVKH[d][j]
			    od
		       fi
		    od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_know_lower; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew


{Delete from LFVKH faces established to be nonunitary using
min_bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph. If U_flag = true, then test
for unitarity.}
set local_testK_hash_min_bottom_layer(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    KTypePol_hash pol_hash, Param_hash Uhash) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq
    	, printInterval = int: 1, red_shift = if red_count_flag then 1 else 0 fi
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
{next if possible label classes known to be nonunitary because they finalize or deform to nonunitary}
    then () = for k:NumClasses
    	     ~do if newStatuses[k] = "?"
		 then let C=eq[k] {should run backwards for update to be effective}
		      then (d,j) = coords(FVKH,C~[0]) {d is dimension of face. Tilde picks a largest-dimensional face in C.}
	      	      then verts = vec: FVKH[d][j][:d+1]
		      then ratverts = [ratvec]: for m in verts do Lvd.list[m] od
		      then sigma = sum(#lambda, ratverts)
		      then pC = parameter(x, lambda, sigma/(d+1))
		      then pCdef = if not is_final(pC)
		      	   	   then monomials(finalize(pC))
		  		   elif wiggle_flag0 and d > 0
		  		   then let () = char_counter.use()
				   	then startCF = elapsed_ms()
				   	then CF = character_formula(finalize(pC))
					then () = charTime +:= elapsed_ms() - startCF
		       		   	in  monomials(composition_series((sum(x.real_form,
		       	   		    for v in ratverts
			   		    do wiggle(CF, (sigma - v)/d)
			   		    od)))) {proper_facet_deformed(pCtop)}
		  	           else []
		  		   fi {not is_final pC}
{this function is invoked only on the 0/1 faces in bottom_layer. That's a relatively long list,
      with few wiggles; the cost of computing proper_facet_deformed(pC) seems not justified by
      the few edges eliminated}
		   in if not is_final(pC)
		      then if all(for q in pCdef do @bool: is_finished(q.x, q.lambda) and
			       	       	       	    	     (Uhash.lookup(q) >= 0) od)
			   then newStatuses[k] := "T"
			   elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 (Uhash.lookup(q) = -1) od)
			   then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); "F"
			   fi
		      else {now pC is final, and pCdef consists of wiggled Params with smaller x}
			  if any(for q in pCdef do @bool:  is_finished(q.x,q.lambda)
				       	       and (Uhash.lookup(q) = -1) od)
			  then newStatuses := updateNUclassesB(newStatuses, gr, k,"F");
			       newStatuses[k] := "F"
		           fi {any}
		      fi {not is_final(pC)}
		fi {newStatuses[k]}
	      od {k:NumClasses}
    then () = if fund_face_verbose {and NumClasses > 100}
    then prints(); prints("start local_testK_hash_min_bottom_layer ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0]) {a lowest-diml face in C; least likely to be final}
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	  then ps = monomials(finalize(pC))
                  then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	      then true
			      elif not all(for p in ps
		     	  	     	   do @bool: if #ps = 1
					      	     then min_bottom_elim_factors(p,pC,pol_hash.index(FVKH[d][j][d+red_shift+1]))
						     else min_bottom_elim_factors(p,pC)
						     fi
					   od)
				then false
			      else true
			      fi
     		  in if not test
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     else newStatuses[k] := "T"
		     fi
		  fi {newStatuses[k] = "?"}
		  od {NumClasses}
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_min_bottom_layer; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

{when the non-minimal parabolics are used at the end, how much above
height(p) to look at K-types.  A larger number finds more nonunitary,
takes longer}
set more_shift_level = int: 0

set more_shift(int n) = void:
    let () = more_flag:=true
    in more_shift_level:=n

{if true, then test for unitarity from beginning of bottom_layer}
{turns out to slow things down a bit: better to construct more
candidates, because they will lead to a graph with fewer components,
so fewer is_unitary tests. For E6_s, U_flag = false needs 833 tests;
U_flag = true needs 1001}
set U_flag = false

{meant to hold nonunitary Params not eliminated by more}
set more_bad_hash = make_Param_hash()

{Delete from LFVKH faces established to be nonunitary using
known_lower, bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph. If U_flag = true, then test
for unitarity. Should be applied only to OUTPUT of local_testK_hash_min_bottom_layer}
set local_testK_hash_bottom_layer_more(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
     [KGPElt] maxQs, [QKL_bottom_data] datas, KTypePol_hash pol_hash, Param_hash Uhash) =
    			    [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash_bottom_layer ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0]) {a lowest-diml face in C; least likely to be final}
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	  then ps = monomials(finalize(pC))
                  then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	      then true
			      elif not all(for p in ps
		     	  	     	   do @bool: if #ps = 1 then min_bottom_elim_factors(p,pC, pol_hash.index(FVKH[d][j][d+red_shift+1]))
					      	     else min_bottom_elim_factors(p,pC)
						     fi
					   od)
				then false
			      elif {(more_flag and} #ps = 1 {otherwise the K-char is wrong!}{)}
				then bottom_elim_factors_more(ps[0], maxQs, datas, pol_hash.index(FVKH[d][j][d+red_shift+1]))
			      else all(for p in ps
				       do @bool: bottom_elim_factors_more(p, maxQs, datas)
				       od)
			      fi
		  {then () = if test and U_flag {get definitive yes/no}
		       	    then let () = test:= all(for p in ps do is_unitary_def_test_big(p) od)
		       	    	 in if not test then more_bad_hash.match(pC) fi
		            fi}
     		  in if not test
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     else newStatuses[k] := "T"
		     fi
		  fi {newStatuses[k] = "?"}
		  od {NumClasses}
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_bottom_layer_more; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

{Delete from LFVKH faces established to be nonunitary using
known_lower, bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph. If U_flag = true, then test
for unitarity. Should be applied only to OUTPUT of local_testK_hash_min_bottom_layer}
{
set local_testK_hash_bottom_layer_more(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
     [KGPElt] maxQs, [QKL_bottom_data] datas, KTypePol_hash pol_hash, Param_hash Uhash) =
    			    [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash_bottom_layer ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0]) {a lowest-diml face in C; least likely to be final}
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	  then ps = monomials(finalize(pC))
                  then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	      then true
			      elif #ps = 1 {otherwise the K-char is wrong!}{)}
			      then bottom_elim_factors_more(ps[0], maxQs, datas , pol_hash.index(FVKH[d][j][d+red_shift+1]))
			      else all(for p in ps
				       do @bool: bottom_elim_factors_more(p, maxQs, datas)
				       od)
			      fi
     		  in if not test
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     else newStatuses[k] := "T"
		     fi
		  fi {newStatuses[k] = "?"}
		  od {NumClasses}
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_bottom_layer_more; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew
}
{append if possible a new nonempty datas to datass. Ds is the list of heights still to be tried.}
{REQUIRE #Ds>1. MU is a list of K-types on G appearing in the standard p}
set add_datas(Param p, KGPElt Qmin, [QKL_bottom_data] datass, [int] Ds, KTypePol MU) =
    ([QKL_bottom_data], [int]):
    let () = for j:#Ds - 1 from 1
    	      do let datas = bottom_factors(bottom_K_type_Qs(p,Qmin,Ds[j-1], Ds[j],MU))
		 in if card(datas) > 0
       	  	    then datass##:= datas;
	       	    	 Ds:=Ds[j:];
	       		 break
	  	    fi
	      od
    in (datass, Ds)

{Delete from LFVKH faces established to be nonunitary using
known_lower, bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph. If U_flag = true, then test
for unitarity. Should be applied only to OUTPUT of local_testK_hash_min_bottom_layer}
{Just precompute FIRST datas; later as needed. Ds[0] is height for initial datas}
set local_testK_hash_bottom_layer_more_step(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KGPElt Qmin,
     [KGPElt] maxQs, [QKL_bottom_data] datas, [int] Ds, KTypePol MU, KTypePol_hash pol_hash,
     Param_hash Uhash) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1{, NUhash = big_unitary_hash.nuhash(x.real_form)}
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash_bottom_layer_more_step ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0]) {a lowest-diml face in C; least likely to be final}
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	  then ps = monomials(finalize(pC))
                  then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	      then true
			      elif #ps = 1 {otherwise the K-char is wrong!}{)}
				then let still_here = bottom_elim_factors_more(ps[0],
				     	       		  maxQs, datas, pol_hash.index(FVKH[d][j][d+red_shift+1]))
				     then () = while still_here and #Ds > 1
				      	      	do let old_size = #datas
					   	   then (datasNEW, DsNEW) = add_datas(pC, Qmin, datas, Ds, MU)
						   then () = datas := datasNEW
						   in if #datas > old_size
						      then Ds:=DsNEW;
						      	   still_here := {test with new datas}
				bottom_elim_factors_more(ps[0], maxQs, [datas~[0]], pol_hash.index(FVKH[d][j][d+red_shift+1]));
				                   	   if not still_here then break fi
						      else break
						      fi
					        od
				      in still_here
			      else let still_here = all(for p in ps
				       	      	    do bottom_elim_factors_more(p, maxQs, datas)
				       		    od)
				   then () = while still_here and #Ds > 1
				      	     do let old_size = #datas
					        then (datasNEW, DsNEW) = add_datas(pC, Qmin, datas, Ds, MU)
						then () = datas := datasNEW
					   	in if #datas> old_size
						   then Ds:=DsNEW;
							still_here := bottom_elim_factors_more(ps[0], maxQs, [datas~[0]]);
				                             	     if not still_here then break fi
						   else break
						   fi
					     od
				   in still_here
			       fi
     		  in if not test
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     else newStatuses[k] := "T"
		     fi
		  fi {newStatuses[k] = "?"}
		  od {NumClasses}
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if #Ds > 1 and fund_face_verbose
     	       then prints("at x = ",x.number,", lambda = ",lambda,"# datas = ",#datas,", #Ds = ",#Ds)
	       fi
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_bottom_layer_more_step; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew



set ParamsByDim = [[Param]]: for d:16 do [] od
set LFDKHByDim = [[FaceVertsKHash]]: for d:16 do [] od

{takes the unitary Param's listed in LFDKHByDim and computes the K-character
 number in pol_hash}
set KcharsByDim() = [[int]]:
    for j:16 do for v in LFDKHByDim [j] do v[j+1] od od

{lists all distinct K-characters (by number in pol_hash)}
set AllKchars() = [int]:
    KcharsByDim().##.sort_u

set NumKchars() = int:
    #AllKchars()

{will be modified to name of local test being run}
set test_string = ""

set more_verbose =false

{ Input is candidate faces, and graph info. Output is the tester-unitary ones.
 use and update a complete list Uhash of known tester-unitary faces.
 try to compute and systematically use partial order on faces}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr,
    [vec] classListByFace, Param_hash Uhash, (Param->bool) tester) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, start = elapsed_ms(){,
       NUhash = big_unitary_hash.nuhash(x.real_form)}
    then newStatuses = for m:NumClasses do "?" od
    then start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose and NumClasses > 100
    	      then prints("start local_test, ",NumClasses,
	      " equiv classes of faces")
	      fi
    {then start_by_dim = vec: for list in LFVH do #list od}
    then () = if KU_flag
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, LFVH)
	      	   {then () = prints(knownUnitaries)}
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
    {then () = if KNU_flag {and #FVKH = 2}
    	      then let knownNonUnitaries = known_non_unitaries(NUhash, x, lambda, Lvd, LFVH)
    	      	   then () = for list@d in knownNonUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "F"
	    	 		od
	      		     od
		   in ()
	       fi}
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
    	 for m:NumClasses
    	 ~do if fund_face_verbose and NumClasses > 100 and
	      	 m%printInterval = 0
	    then prints("examining equivalence class #"
	      ,m, "; so far ",unitary_test_counter.use_count()
	      ," 'is_unitary' tests.")
	      ; printInterval := (3*printInterval)\2 + 1
	    fi;
	        let C=eq[m]
	      	then (d,j) = coords(LFVH,C[0])
	      	then verts = vec: LFVH[d][j][:d+1]
		then pC = parameter(x, lambda, face_bary(Lvd, verts))
		  {first_param makes trouble in UParams list!}
	      	then ps = monomials(finalize(pC))
	      	in if{NEWU} (U_flag and (d <= 1) and test_string = " using local_test_GEO_hash_bottom_layer")
		   {vertices and edges have already been tested if U_flag is true}
		   	    or newStatuses[m][0] = "T"
			    or all(for p in ps
		   	    	   do @bool: Uhash.lookup(p).>= or tester(p) od)
		   then downdateUclassesB(newStatuses, gr, m, "T"); newStatuses[m]:="T";
		   	for i in C
		   	do let (e,k) = coords(LFVH,i)
			   then moreverts = vec: LFVH[e][k][:e+1]
			   then () = unitary_by_dim[e]+:=1
			   then q = parameter(x,lambda, face_bary(Lvd,moreverts))
			   then () = for q1 in monomials(finalize(q))
			   	     do Uhash.match({herm_center(}q1{)});
				     if deform_flag
				     then for q1d in facet_deformed_new(q1)
				     	  do Uhash.match({herm_center(}q1d{)})
					  od
				     fi
				     od
			   then () = if long_out_flag
		      	   	     then let () = ParamsByDim[e] #:=q
				     {ParamsByDim[d] := ParamsByDim[d]#q}
			   	     	  then ()=LFDKHByDim[e]#:=LFVH[e][k]
					  {LFDKHByDim[d]#LFVH[d][j]}
				     	  in ()
			   	     fi
		       	   in q
		    	od {list of tester unitary Params}
		   else if more_flag
		   	then more_bad_hash.match(pC)
			fi;
		        updateNUclassesB(newStatuses, gr, m);
		   	newStatuses[m] := "F";
			[]
		   fi{NEWU}
	  od.##
    then () = if test_verbose or test_slightly_verbose
    	      then prints("tester unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
		 		print_time_string(elapsed_ms() - start))
	      fi
    in  UParams

set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr,
    			   [vec] classListByFace, Param_hash Uhash) = [Param]:
    local_test_hash(x, lambda, Lvd, LFVH, eq, gr, classListByFace, Uhash,
    		       is_unitary_def_test_big_SIMPLE@Param)

{meant to hold params p with pL unitary and p not}
{set surprise_hash = make_Param_hash()
set surprise_flag = false}

{if true, uses bottom_more at last step instead of is_unitary}
set mix_flag = false

{ Input is candidate faces, and graph info. Output is the unitary ones.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use partial order on faces.
IF mix_flag, DON'T assume the input params are already bottom layer positive
for minimal parabolic; try
to use larger ones.}  {NOW NOT USED}
set local_test_hash_bottom(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    [KGPElt] maxQs, [QKL_bottom_data] datas, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, newStatuses = for j:#eq do "?" od
    then start_count = unitary_test_counter.use_count(), red_shift = if red_count_flag then 1 else 0 fi
    then () = for k:NumClasses
             ~do if newStatuses[k] = "?"
                 then let C=eq[k] {should run backwards for update to be effective?}
                      then (d,j) = coords(LFVH,C[0]) {search C to look for largest d?}
                      then verts = vec: LFVH[d][j][:d+1]
		      then ratverts = [ratvec]: for m in verts do Lvd.list[m] od
		      then sigma = sum(#lambda, ratverts)
                      then pC = parameter(x, lambda, sigma/(d+1))
                      then pCdef = if is_final(pC)
                                   then if wiggle_flag and d > 0
					then let () = char_counter.use()
				   	     then startCF = elapsed_ms()
				   	     then CF = character_formula(pC)
					     then () = charTime +:= elapsed_ms() - startCF
					     in monomials(composition_series((sum(x.real_form, for v in ratverts
						      		       			   do wiggle(CF, (sigma - v)/d)
						      		       			   od))))
							  {proper_facet_deformed(pC)}
					 else []
					 fi
                                    else monomials(finalize(pC))
                                    fi {is_final(pC)}
                       in if not is_final(pC)
			  then if all(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
			       	       	       (Uhash.lookup(q) >= 0) od)
                               then newStatuses[k] := "T"
                               elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 	 (Uhash.lookup(q) = -1) od)
                               then newStatuses:= updateNUclassesB(newStatuses, gr, k); "F"
                               fi {all (for q}
                          else {now pC is final, and pCdef consists of wiggled Params with smaller x}
                               if any(for q in pCdef do @bool:  is_finished(q.x,q.lambda) and
				       	       (Uhash.lookup(q) = -1) od)
                               then newStatuses := updateNUclassesB(newStatuses, gr, k);
				    	 newStatuses[k] := "F"
                               fi
                          fi {not is_final(pC)}
                   fi {newStatuses[k]}
               od
    then () = if fund_face_verbose and NumClasses > 100
    	      then prints("start local_test, ",NumClasses,
	      " equiv classes of faces")
	      fi
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
    	 for m:NumClasses
    	~do if fund_face_verbose and NumClasses > 100 and
	      	 ((NumClasses-m-1)%printInterval = 0)
	    then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",unitary_test_counter.use_count()
	      ," 'is_unitary' tests.")
	      ; printInterval := (3*printInterval)\2 + 1
	    fi
	    ;
	    let elim_more = true, p = parameter(x,lambda,0*lambda)
	    then test = bool:
	        if newStatuses[m] = "F"
	    	then false
		elif newStatuses[m] = "T"
		then true
	    	else let C=eq[m]
	      	     then (d,j) = coords(LFVH,C[0])
	      	     then verts = vec: LFVH[d][j][:d+1]
		  {first_param makes trouble in UParams list!}
		     then p_start_time = elapsed_ms()
		     then () = p := parameter(x, lambda, face_bary(Lvd, verts))
		     then () = if more_verbose then prints("testing parameter ",p) fi
	      	     then ps = monomials(finalize(p))
		     then () = if more_flag or mix_flag
			       then elim_more:= if #ps = 1
				    		then bottom_elim_factors_more(ps[0], maxQs, datas, pol_hash.index(LFVH[d][j][d+red_shift+1]))
		                    		else all(for p1 in ps
		   	       	    	       	     	 do Uhash.lookup(p1).>= or {this can produce "isn't LKT message"}
			       	       	    	      	 bottom_elim_factors_more(p1, maxQs, datas)
					      	    	 od)
				     	   	 fi
			        fi
		      in if not elim_more
		      	 then false {we got rid of p by bottom layer}
			 else all(for p1 in ps do @bool: is_unitary_def_test_big_SIMPLE(p1) od)
		     	 fi
		  fi {newStatuses[m]}
	      then () = if more_verbose then prints("your final answer was ",test) fi
	      in if test
		 then for i in eq[m]
		      do let (d,j) = coords(LFVH,i)
			 then verts = vec: LFVH[d][j][:d+1]
			 then () = unitary_by_dim[d]+:=1
			 then q = parameter(x,lambda, face_bary(Lvd,verts))
			 then () = for q1 in monomials(finalize(q))
			   	   do Uhash.match({herm_center(}q1{)});
				      if deform_flag
				      then for q1d in facet_deformed_new(q1)
				     	   do Uhash.match({herm_center(}q1d{)})
					   od
				      fi
				   od
			  then () = if long_out_flag
		      	   	    then let () = ParamsByDim[d] #:= q
			   	     	 then ()=LFDKHByDim[d] #:= LFVH[d][j]
				     	 in ()
			   	    fi
			  in q
		       od
		  else let () = if (more_flag or mix_flag) and elim_more then more_bad_hash.match(p) fi
		      	       	    {in this case p passed elim_more but is not unitary}
		       in []
		  fi{test}
	     od.## {list of unitary Params}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
    in  UParams

{ Input is candidate faces, and graph info. Output is the unitary ones.}
set local_test_wiggle_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr,
    [vec] classListByFace, Param_hash Uhash) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, newStatuses = for j:#eq do "?" od
    then () = for k:NumClasses
             ~do if newStatuses[k] = "?"
                 then let C=eq[k] {should run backwards for update to be effective?}
                      then (d,j) = coords(LFVH,C[0])
                      then verts = vec: LFVH[d][j][:d+1]
		      then ratverts = [ratvec]: for m in verts do Lvd.list[m] od
		      then sigma = sum(#lambda, ratverts)
                      then pC = parameter(x, lambda, sigma/(d+1))
                      then pCdef = if is_final(pC)
                                   then if wiggle_flag and d > 0
					then let () = char_counter.use()
				   	     then startCF = elapsed_ms()
				   	     then CF = character_formula(pC)
					     then () = charTime +:= elapsed_ms() - startCF
					     in monomials(composition_series((sum(x.real_form, for v in ratverts
						      		       			   do wiggle(CF, (sigma - v)/d)
						      		       			   od))))
					else []
					fi
                                   else monomials(finalize(pC))
                                   fi {is_final}
                      in if not is_final(pC)
			 then if all(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
			       	       	       (Uhash.lookup(q) >= 0) od)
                              then newStatuses[k] := "T"
                              elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 	 (Uhash.lookup(q) = -1) od)
                              then newStatuses:= updateNUclassesB(newStatuses, gr, k); "F"
                              fi
                         else {now pC is final, and pCdef consists of wiggled Params}
                              if any(for q in pCdef do @bool: is_finished(q.x,q.lambda)
				       	       	    	     	    and (Uhash.lookup(q) = -1) od)
				 then newStatuses := updateNUclassesB(newStatuses, gr, k); newStatuses[k] := "F"
                                    fi
                               fi
                        fi
                   od
              {fi}
    then () = if fund_face_verbose and NumClasses > 100
              then prints("start local_test, ",NumClasses,
              " equiv classes of faces")
              fi
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
         for m:NumClasses
        ~do if fund_face_verbose and NumClasses > 100 and
                 ((NumClasses-m-1)%printInterval = 0)
            then prints("examining equivalence class #"
              ,NumClasses-m -1, "; so far ",unitary_test_counter.use_count()
              ," 'is_unitary' tests.")
              ; printInterval := (3*printInterval)\2 + 1
            fi
            ;
            let test = bool:
                if newStatuses[m][0] = "F"
                then false
		elif newStatuses[m][0] = "T"
		  then true
                else let C=eq[m]
                     then (d,j) = coords(LFVH,C[0])
                     then verts = vec: LFVH[d][j][:d+1]
                  {first_param makes trouble in UParams list!}
                     then p = parameter(x, lambda, face_bary(Lvd, verts))
                     then () = if more_verbose then prints("testing parameter ",p) fi
                     then ps = monomials(finalize(p))
                     in all(for p1 in ps do @bool: is_unitary_def_test_big_SIMPLE(p1) od)
		fi
             in if test
                then for i in eq[m]
                     do let (d,j) = coords(LFVH,i)
                        then verts = vec: LFVH[d][j][:d+1]
                        then () = unitary_by_dim[d]+:=1
                        then q = parameter(x,lambda, face_bary(Lvd,verts))
                        then () = for q1 in monomials(finalize(q))
                                  do Uhash.match({herm_center(}q1{)});
                                     if deform_flag
                                     then for q1d in facet_deformed_new(q1)
                                          do Uhash.match({herm_center(}q1d{)})
                                          od
                                     fi
                                  od
                         then () = if long_out_flag
                                  then let () = ParamsByDim[d] #:= q
                                       then ()=LFDKHByDim[d] #:= LFVH[d][j]
                                       in ()
                                  fi
                         in q
                      od
                  else [] 
                  fi
             od.## {list of unitary Params}
    in UParams

set one_true_counter = make_counter()
set one_false_counter = make_counter()
set hash_real_dumbCounter = make_counter()
set hash_dumbCounter = make_counter()
set hash_def_dumbCounter = make_counter()
set hash_bottom_layerCounter = make_counter()
set one_param_time = int: 0

set one_param_test(Param p, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), Q = monomials(finalize(p)), G = p.real_form
    then () = if not is_final(p)
    	      then if all(for q in Q do is_finished(q.x,q.lambda) and
	      	      	      (Uhash.lookup(q) >= 0) od)
	      	   then return [p]
		   else if any(for q in Q do is_finished(q.x,q.lambda) and
		   	   	   (Uhash.lookup(q) <0) od)
		   	then return []
			fi
		   fi
	      fi
    then r = rank(Q[0].x.involution - 1)
    then DEFHTS = [int]:
    	 if low(p, height(p)) {low(Q[0].x,Q[0].lambda)} {number(Q[0].x) < NK*low_KGB_frac}
	 then []
	 else {let (answer,) =} next_heights(Q[0], (r*stretcher)\2) {deform_hts(Q[0],(r*stretcher)\2)}
	 {in answer} {could record boolean, use it to replace _test by _to_hts}
	 fi
    then  () = hash_def_dumbCounter.use()
    then test = all(for q in Q do {Uhash.lookup(q).>= or}
		   	       is_unitary_test_big_SIMPLE(q, DEFHTS) od)
    in if test
       then let () = for q in Q
		     do Uhash.match(q)
		     od
	    then () = one_true_counter.use()
	    then () = one_param_time +:= elapsed_ms() - start
	    in [p]
       else let () = one_false_counter.use()
	    then () = one_param_time +:= elapsed_ms() - start
	    in []
       fi

{only does min_bottom test}
set one_param_test_min_bottom(Param p, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), QG = monomials(finalize(p)), G = p.real_form
    then () = if is_final(p)
    	      then if all(for q in QG do is_finished(q.x,q.lambda) and
	      	      	      (Uhash.lookup(q) >= 0) od)
	      	   then return [p]
		   else if any(for q in QG do is_finished(q.x,q.lambda) and
		   	   	   (Uhash.lookup(q) < 0) od)
		   	then return []
			fi
		   fi
	      fi
    then () = if height(p) > 0
    	      then let () = hash_bottom_layerCounter.use()
    	       	   then elim_min = all(for q in QG
    	      	    	do min_bottom_elim_factors(q)
		    	od)
    	 {then () = if one_param_verbose then then () = prints("result of elim_min was ",elim_min) fi}
    	       	  in if not elim_min {minimal bottom layer proved not a unitary Param}
       	       	     then one_false_counter.use();
	    	       	  one_param_time +:= elapsed_ms() - start;
		       	  return []
		     fi
	       else hash_def_dumbCounter.use()
	       fi
    {now min_bottom failed, or ht = 0}
    then r = rank(QG[0].x.involution - 1)
    then DEFHTS = [int]:
    	 if low(p, height(p))
	 then []
	 else  next_heights(QG[0], (r*stretcher)\2) {let (answer,) = deform_hts(QG[0],(r*stretcher)\2)}
	 {in answer} {could record boolean, use it to replace _test by _to_hts}
	 fi
    then test =  all( [(->bool)]:
	    	     for q in QG
		     do @bool: is_unitary_test_big_SIMPLE(q,DEFHTS) od)
    in if test
       then let () = for q in QG
		     do Uhash.match({herm_center(}q{)})
		     od
	    then () = one_true_counter.use()
	    then () = one_param_time +:= elapsed_ms() - start
	    in [p]
       else let () = one_false_counter.use()
	    then ()= one_param_time +:= elapsed_ms() - start
	    in []
       fi

{assume min_bottom already called?}
set one_param_test_bottom(Param p, [int] Ds, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), QG = monomials(finalize(p)),G = p.real_form
    then () = if is_final(p)
    	      then if all(for q in QG do is_finished(q.x,q.lambda) and
	      	      	      (Uhash.lookup(q) >= 0) od)
	      	   then return [p]
		   else if any(for q in QG do is_finished(q.x,q.lambda) and
		   	   	   (Uhash.lookup(q) < 0) od)
		   	then return []
			fi
		   fi
	      fi
    then () = hash_bottom_layerCounter.use()
    then elim_more = true
    then Es = if #Ds > 1 then Ds
    	      else height(p)#Ds
	      fi
    then () = if #Es > 1
       	      then let () = if more_verbose then prints("start more with p = ",p, ", Es = ",Es) fi
	    	   then Ps = for q in QG do K_type_pol(character_formula_to_height(q, Es~[0])) od
       	    	   then still_here = true
		   then () = {for D in Ds[:1]
		      	     do} still_here := all(for {D@j in Ds[1:]} j:#Es-1 from 1
					       	  do all(for q@i in QG
						      	 do @bool: bottom_elim_factors_more(q, Es[j-1],Es[j], Ps[i])
						   	 od)
					          od){;
				 if not still_here then break fi}
			      {od}
		   in elim_more:= still_here
		fi {#Es > 1}
    then () = if more_verbose then prints("result of elim_more was ",elim_more) fi
    then steps = max(rank(p.x.involution-1),1)
    {then test_heights = next_heights(p, steps)
    then (def_heights,) = deform_hts(QG[0],steps)
    then j0 = max(0,first(for m in test_heights do Ds~[0] < m od))}
		 {so that we test above the height bottom layer has examined}
    in if elim_more
       then let () = if test_verbose then prints("one parameter unitary on bottom layer to height ",Es~[0]) fi
       then test = all( [(->bool)]:
		    	   for q in QG
			   do @bool: {is_unitary_test_big_SIMPLE(q, test_heights[j0:])}
			      is_unitary_def_test_big_SIMPLE(q,steps)
			   od)
	    then () = if more_verbose then prints("your final answer was ",test) fi
	    in if test
	       then let () = for q in QG
		     	     do Uhash.match(q)
		     	     od
	    	    then () = one_true_counter.use()
	    	    then () = one_param_time +:= elapsed_ms() - start
	    	    in [p]
	       else let () = one_false_counter.use() {if test is false}
	       	    then () = one_param_time +:= elapsed_ms() - start
	     	    then () = more_bad_hash.match(p)
		    in []
               fi
	else let () = one_false_counter.use() {if elim_more is false}
	     then () = one_param_time +:= elapsed_ms() - start
	     in []
        fi


{don't assume min_bottom already called; should only be called if ht > 0?}
set one_param_test_all_bottom(Param p, [int] Ds, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), QG = monomials(finalize(p)),G = p.real_form
    then () = if is_final(p)
    	      then if all(for q in QG do is_finished(q.x,q.lambda) and
	      	      	      (Uhash.lookup(q) >= 0) od)
	      	   then return [p]
		   else if any(for q in QG do is_finished(q.x,q.lambda) and
		   	   	   (Uhash.lookup(q) < 0) od)
		   	then return []
			fi
		   fi
	      fi
    then () = hash_bottom_layerCounter.use()
    then elim_min = all(for q in QG
    	      	    	do min_bottom_elim_factors(q)
		    	od)
    	 {then () = if one_param_verbose then then () = prints("result of elim_min was ",elim_min) fi}
    then () = if not elim_min {minimal bottom layer proved not a unitary Param}
       	       	     then one_false_counter.use();
	    	       	  one_param_time +:= elapsed_ms() - start;
		       	  return []
	      fi
    then elim_more = true
    then Es = if #Ds > 1 then Ds
    	      else height(p)#Ds
	      fi
    then () = if #Es > 1
       	      then let () = if more_verbose then prints("start more with p = ",p, ", Es = ",Es) fi
	    	   then Ps = for q in QG do K_type_pol(character_formula_to_height(q, Es~[0])) od
       	    	   then still_here = true
		   then () = {for D in Ds[:1]
		      	     do} still_here := all(for {D@j in Ds[1:]} j:#Es-1 from 1
					       	  do all(for q@i in QG
						      	 do @bool: bottom_elim_factors_more(q, Es[j-1],Es[j], Ps[i])
						   	 od)
					          od){;
				 if not still_here then break fi}
			      {od}
		   in elim_more:= still_here
		fi {#Es > 1}
    then () = if more_verbose then prints("result of elim_more was ",elim_more) fi
    then steps = max(rank(p.x.involution-1),1)
    {then test_heights = next_heights(p, steps)
    then j0 = max(0,first(for m in test_heights do Ds~[0] < m od))}
		 {so that we test above the height bottom layer has examined}
    in if elim_more
       then let () = if test_verbose then prints("one parameter unitary on bottom layer to height ",Es~[0]) fi
       	    then test = all( [(->bool)]:
		    	   for q in QG
			   do @bool: {is_unitary_test_big_SIMPLE(q, test_heights[j0:])}
			      	     is_unitary_def_test_big_SIMPLE(q,steps)
		    	od)
	    then () = if more_verbose then prints("your final answer was ",test) fi
	    in if test
	       then let () = for q in QG
		     	     do Uhash.match(q)
		     	     od
	    	    then () = one_true_counter.use()
	    	    then () = one_param_time +:= elapsed_ms() - start
	    	    in [p]
	       else let () = one_false_counter.use() {if test is false}
	       	    then () = one_param_time +:= elapsed_ms() - start
	     	    then () = more_bad_hash.match(p)
		    in []
               fi
	else let () = one_false_counter.use() {if elim_more is false}
	     then () = one_param_time +:= elapsed_ms() - start
	     in []
        fi

{skips all unitary_to_ht tests in dims 2-top; just does at the end}
set quick_flag = true

{Assume we have local vertices and edges LF, herm and pos on LKTs.
Called when there are not enough heights; presumably small KGBElts??}
set local_test_GEO_hash_real_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
     [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G)
    then () = if 1*parameter(x,lambda,lambda) = zero_pol then return [] fi
    then r = rank(x.involution - 1), NK = #KGB(x.real_form)
    then pmin = parameter(x,lambda,0*lambda)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	{[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then maxDiffLoc = max_loc(for v in Lvd.list
    	 	       	       do G.two_rho_check*(dominant(G,thetaMinus*v))
			       od)
    then pmax = first_param(finalize(parameter(x, lambda, Lvd.list[maxDiffLoc]))),
    	 r = rank(x.involution - 1), rk = rank(x_open(G).involution - 1)
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    then test_hts = [int]:
    	 {if low(x,lambda) {number(pmax.x) < NK*low_KGB_frac} {defaults to 1/4 of #KGB; so most of time, use to_ht}
	 then []
	 else}  next_heights(pmax, (r*stretcher)\2) {let (answer,) = deform_hts(pmax,((rk+1)*stretcher)\2)}
	 	{!!this r\2 is a parameter to fiddle}
	      {in answer}
	 {fi}
   { then test_ht = if x.number < NK*low_KGB_frac
    	 	   then -1
		   else next_height(pmin)
		   fi}
    then too_high = first(for h in test_hts do h > FPP_max_ht od)
    then () = if too_high.>= then {prints(test_hts);} test_hts:=test_hts[:too_high] fi
    then tester = (Param->bool): (Param p) bool: {could have recorded bool above to
    	 	  		 	   	 omit is_unitary at end}
    	 is_unitary_test_big_SIMPLE(p,test_hts)
    {then () = if face_verbose then prints("test_ht = ",test_ht) fi}
    then () = test_string:= " using local_test_GEO_hash_real_dumb"
    then  () = hash_real_dumbCounter.use()
    then start_count = unitary_test_counter.use_count()
 {because of to_ht, CANNOT use KNU testing: NO THIS IS TEST}
    {then KNU_flag_hold = KNU_flag
    then ICPNU_flag_hold = ICPNU_flag
    then () = KNU_flag:=false
    then () = ICPNU_flag:=false}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
    {then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)}
    then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on faces to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
           {remove from LFDKH all faces failing is_unitary}
    then () = LFDKH := local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq, gr, CLBF, tester, Uhash)
    then () = if test_verbose then prints("unitary face counts to dim 1: ",
    	      	 for list in LFDKH do #list od)
	      fi
    then () = if quick_flag
              then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                rank(x.involution - 1) + 1, pol_hash)
	           then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   in  LFDKH := {if know_lower_flag
                       	      	then} local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq,
				      gr, CLBF, tester, Uhash)
                       		{else local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF,
				      is_unitary_hash_big_SIMPLE@Param, Uhash)
                       		fi}
	      else let D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 then lowUs = sum(for d:D+1 do #LFDKH[d] od)
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
			      then test = {if know_lower_flag
                                     	  then} if any(for p in ps
                                                      do is_finished(p.x, p.lambda){p.x.# < known_to} and
						      	 	Uhash.lookup(p) = -1
                                                      od)
                                               then false
                                               elif all(for p in ps
                                                    	do Uhash.lookup(p).>=
                                                   	od)
                                               then true
                                               else all(for p in ps
					       	    	do is_unitary_test_big_SIMPLE(p,test_hts)
					       		od)
                                               fi {any}
                                     	  {else all(for p in ps
                                                    do Uhash.lookup(p).>= or
                                                    is_unitary_hash_big_SIMPLE(p) od)
                                     	  fi{know_lower}}
		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
                          in if test
                             then [LFDKH[D+1][m]]
                             else []
                             fi
                          fi
                       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	 fi {if quick_flag}
    {then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:=ICPNU_flag_hold
    then () = ICPU_flag:=ICPU_flag_hold}
    then unitary_by_dim = for L in LFDKH do #L od
    {now have unitary faces of all dims}
     {then () = if test_verbose then prints("total number of tests = ",
                                  unitary_test_counter.use_count())
				  fi}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () =ParamsByDim[d]:=(ParamsByDim[d] next ParamsByDim[d]:=[])#p
			   {ParamsByDim[d] := ParamsByDim[d]#p}
			   	then ()=LFDKHByDim[d] :=(LFDKHByDim[d] next LFDKHByDim[d]:=[])#v
				{LFDKHByDim[d] := LFDKHByDim[d]#v}
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams


{Assume we have local vertices and edges LF, herm and pos on LKTs.
Called when there are not enough heights; presumably small KGBElts??}
set local_test_GEO_hash_else_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G)
    then () = if 1*parameter(x,lambda,lambda) = zero_pol then return [] fi
    then r = rank(x.involution - 1), NK = #KGB(G)
    then pmin = parameter(x,lambda,0*lambda)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   {[height(pmin) + more_shift_level],} Uhash) 
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    {then test_ht = {if low(pmin, height(pmin)) {low(x,lambda)}{x.number < NK*low_KGB_frac}  {this gives false whenever height(pmin) = 0}
    	 	   then} next_height(pmin)}
		   {else -1
		   fi}
   {then () = prints("in else_dumb, low(pmin,height(pmin)) = ", low(pmin, height(pmin)),
   	     	    ", next_height(pmin) = ", next_height(pmin),", test_ht = ",test_ht)}
    {then test_hts = hts[:min(#hts,1{r})]  {??? who knows about r!}}
    then tester = (Param->bool): (Param p) bool:
    	 {is_unitary_test_big_SIMPLE(p,test_ht) {this settles unitarity absolutely}}
	 is_unitary_def_test_big_SIMPLE(p)
    {then () = if test_verbose then prints("test_ht = ",test_ht) fi}
    then () = test_string:= " using local_test_GEO_hash_dumb"
    then  () = hash_dumbCounter.use()
    then start_count = unitary_test_counter.use_count()
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
{then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)}
    then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on faces to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
           {remove from LFDKH all faces failing is_unitary}
    then () =  LFDKH := local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq, gr, CLBF,(Param->bool):
    (Param p) bool: is_unitary_def_test_big_SIMPLE(p{,test_ht}), Uhash)
    then () = if test_verbose then prints("unitary face counts to dim 1: ",
    for list in LFDKH do #list od) fi
    {then () = prints("set LFDKH01 = ",LFDKH)}
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
              	   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		      is_unitary_def_test_big_SIMPLE(p{,test_ht})
		      ,Uhash)
                   in if test_verbose
		      then prints("unitary face counts to dim ", #LFDKH - 1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 {then lowUs = sum(for d:D+1 do #LFDKH[d] od)}
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
		              then test = if any(for p in ps
					       	 do is_finished(p.x, p.lambda) and
						      	 Uhash.lookup(p) = -1
						 od)
					  then false
					  elif all(for p in ps
					       	   do Uhash.lookup(p).>=
						   od)
					  then true
					  else all(for p in ps
					       	   do tester(p) od)
					  fi
		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
			       in if test
			       	  then [LFDKH[D+1][m]]
				  else []
				  fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	     fi {quick_flag}
    then unitary_by_dim = for L in LFDKH do #L od
    {now have unitary faces of all dims}
     {then () = if test_verbose then prints("total number of tests = ",
                                  unitary_test_counter.use_count())
				  fi}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{How many steps to use in is_unitary_def_test(p, steps) in def_dumb}
set def_steps = -1

{Assume we have local vertices and edges LF, herm and pos on LKTs and Dirac
	Use is_unitary_def_test(p, (G.rank + 1)\2}
set local_test_GEO_hash_def_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G), pmin = parameter(x,lambda, 0*lambda), NK = #KGB(G)
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution - 1)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then def_steps_temp = if def_steps = -1
    	 		  then ((r+G.rank)*stretcher)\5
			  else def_steps
			  fi
    then tester = (Param->bool): (Param p) bool:
     	 is_unitary_def_test_big_SIMPLE(p,def_steps_temp)
    then () = test_string:= " using local_test_GEO_hash_def_dumb"
    then  () = hash_def_dumbCounter.use()
    then start_count = unitary_test_counter.use_count()
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
{    then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)}
    then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on faces to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    {then () = prints("LFDKH = ",LFDKH)}
    {then () = prints("eq = ",eq,", gr = ",gr)}
           {remove from LFDKH all faces failing is_unitary}
    then () = LFDKH := local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq, gr,
    	      	       				   CLBF, tester, Uhash)
    then () = if test_verbose then prints("unitary face counts to dim 1: ",
    for list in LFDKH do #list od) fi
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
	      	   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		      is_unitary_def_test_big_SIMPLE(p,def_steps_temp)
		      ,Uhash)
                   in if test_verbose
		      then prints("unitary face counts to dim ", #LFDKH - 1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
    then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 {then lowUs = sum(for d:D+1 do #LFDKH[d] od)}
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      then ratverts = [ratvec]: for m in verts do Lvd.list[m] od
			      then sigma = sum(#lambda, ratverts) {THIS IS WRONG BARYCENTER}
			      then pC = parameter(x, lambda, face_bary(Lvd, verts))
			      then ps = monomials(finalize(pC))
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      in if not is_final(pC)
				 then if any(for q in ps do @bool:  is_finished(q.x,q.lambda) and
				      	      	      (Uhash.lookup(q) = -1) od)
				      then []
				      else if all(for q in ps do @bool:  is_finished(q.x,q.lambda) and
					   	   	   (Uhash.lookup(q) >= 0) od)
				      	    then [LFDKH[D+1][m]]
				      	    else if all(for q in ps do @bool: tester(q) od)
					    	 then [LFDKH[D+1][m]]
					   	 else []
					   	 fi
				       	    fi {all(for q}
				      fi {any(for q}
				 else {now pC is final}
				      if wiggle_flag
				      then let () = char_counter.use()
				   	   then startCF = elapsed_ms()
				   	   then CF = character_formula(pC)
					   then () = charTime +:= elapsed_ms() - startCF
					   then pCdef =  monomials(composition_series((sum(x.real_form,
					   	      for j:#verts
						      do wiggle(CF, face_bary(Lvd, verts[:j]##verts[j+1:]))
						      od))))
							  {proper_facet_deformed(pC)}
				      	        in if any(for q in pCdef
						      	  do @bool: ( is_finished(q.x,q.lambda) and
							    (Uhash.lookup(q) = -1))
							  od)
						   then []
					      	   else if tester(pC)
					   	   	then [LFDKH[D+1][m]]
					   	   	else []
					     	   	fi
				      	      	   fi {any(for q}
				      else {not wiggle_flag}
					      if tester(pC)
					      then [LFDKH[D+1][m]]
					      else []
					      fi
				      fi {wiggle_flag}
				 fi {not is_final}
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	     fi {quick_flag}
    {now have unitary faces of all dims}
     then unitary_by_dim = for L in LFDKH do #L od
     then () = if test_verbose or test_slightly_verbose
    	       then prints("unitary faces by dim = ",
       	       	    	    unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{assume LF is verts and edges, herm and pos on LKTs and Dirac?}
set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    if real_flag
    then local_test_GEO_hash_real_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
    elif def_flag
    then local_test_GEO_hash_def_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
    else let shorts = if short_hts_flag
    	     	      then short_hts(parameter(x,lambda,Lvd.list[0]))
		      else next_heights(parameter(x,lambda, Lvd.list[0]), 1)
		      fi
    	 then hts = shorts[:min(1,#shorts)]
    	 in local_test_GEO_hash_else_dumb(x, lambda, {vd,} Lvd, LF, hts, pol_hash, Uhash)
    fi

{if true, uses the (faster?) function localFD_1Dirac2_by_zero to compute local vertices and edges}
{seems SLOWER in F4, E7}
set by_zero_flag = true

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, {vec mapAct,} KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let DiracBD = DiracBD(x,lambda), G=x.real_form
    then rhocheck = G.rho_check
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda,Lvd,Perm2)
	      fi
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash{, [[FaceVertsIndex]] global_faces}) = [Param]:
    let DiracBD = DiracBD(x,lambda), G=x.real_form
    then rhocheck = G.rho_check
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	      fi
    {imposes Dirac, herm, pos on LKTs for vertices and edges}
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {Then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_dumb(KGBElt x, ratvec lambda) =
    [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form), pol_hash = make_KTypePol_hash(), G = x.real_form
    {then vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_dumb(x, lambda, {vd,} pol_hash, Uhash)

{for character_formula calculations on parameters of

    height/(G.rho * G.two_rho) \le CUTOFF,

it's assumed that character_to_height is faster. Setting CUTOFF = 2
means always character_formula_to_height, CUTOFF=0 means
character_formula except for height 0, and CUTOFF = -1 means always
character_formula. For F4_s, CUTOFF = 0 saves 10 seconds over -1 and 2}
set CUTOFF =rat: 0/1

{USE THESE IN HASH AND HASH2!}
{lowest level (index in hts[]) to start testing}
set edge_offset = int: -1

{how much to increase level at each repetition}
set edge_skip = int: 1

{vertex set size number at which to revert to local_test_GEO_hash_dumb.
0 to 100 make sense: higher means revert MORE often}
set vert_diff_cutoff = int: 10

{when nu*2rho_check < (to_ht_frac)*(infl_char*2rho_check, don't use is_unitary_to_ht}
{If negative, always allow is_unitary_to_ht}
set to_ht_frac = 9/10

set hashCounter = make_counter()

{assume we've already got hts, #hts >= 1, imposed Dirac, and decided not to use _dumb
Assume LF is vertices and edges, already pos on LKTs and hermitian and Dirac}
set local_test_GEO_hash_no_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let () = hashCounter.use()
    then () = test_string:= " using local_test_GEO_hash"
    then () = if(face_verbose) then prints("hts = ",hts) fi
    then long_out_temp_flag = long_out_flag, r = rank(x.involution -1), start = elapsed_ms()
    then () = long_out_flag:=false {to allow using local_test_hash without recording Params}
    then edge_offset_temp = edge_offset, ht0 = height(parameter(x,lambda,0*lambda)),
    	 G = x.real_form
    then temp_K_char_flag = ht0/(G.rho * G.two_rho_check) <= CUTOFF
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    then test_levels = for d:max(r+1,2) do (d*edge_skip*stretcher)\1 + edge_offset_temp od
    then test_hts = for d:max(r+1,2) do hts[test_levels[d]] od {need to increase #hts?}
    then pol_hash0 = if temp_K_char_flag
    	 	     then make_KTypePol_hash() {to hold chars to height hts[0]}
		     else pol_hash
		     fi
{for E8_s, K-chars to height test_hts[0] = 68 is 2.5 days. So do just hts[0]!}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq_red,CLBF_red) = localGraphRed(LF)
		      in if temp_K_char_flag
		      	 then localFD_KHash_01_graph(x,lambda,Lvd,test_hts[0],pol_hash0,
			      LF, eq_red,CLBF_red)
			 else localFD_KHash_01_graph(x,lambda,Lvd,pol_hash0,LF, eq_red,CLBF_red)
			 fi
		  elif temp_K_char_flag
    	       	  then localFD_KHash_01(x, lambda, Lvd, test_hts[0], pol_hash0, LF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
    {then LFDKH = if temp_K_char_flag
    	       	 then localFD_KHash_01(x, lambda, Lvd, hts[0], pol_hash0, LF)
		 else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		 fi}
    then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on faces to dim 1, to hts[edge_offset]}
    then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
    	 		       then localGraphK(LFDKH)
    	 		       else localGraphK(LFDKH, pol_hash, hts[0])
			       fi
    {then () = prints("trial of eq at dim 1 is ",trial(x,lambda,Lvd,LFDKH, eq, hts[0]))}
 {because of to_ht, CANNOT use KNU testing}
    then KNU_flag_hold = KNU_flag
    then ICPNU_flag_hold = ICPNU_flag
    then () = KNU_flag:=false
    then () = ICPNU_flag:=false
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF,
    	      (Param->bool):(Param p): is_unitary_to_ht_big_SIMPLE(p, hts[0]), Uhash)
    then () = if test_verbose then prints("unitary to ht ",hts[0],
                        " face counts to dim 1: ",for list in LFDKH do #list od) fi
    then () = LFDKH := if temp_K_char_flag and red_count_flag and #LFDKH[1] > 0
    	      	       then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
    	      	       	    in extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red, CLBF_red)
		       elif temp_K_char_flag
		       then extend_K_characters(x,lambda,Lvd,LFDKH,pol_hash)
		       else LFDKH
		       fi
    then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
    	 		       then localGraphK(LFDKH) {this automatically tests to test_hts[0]}
			       else localGraphK(LFDKH, pol_hash, test_hts[0])
			       {this is TOLD to go to test_hts[0]}
			       fi
        {remove from LFDKH all faces failing is_unitary_to_ht(test_hts[0])}
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF,
    	   (Param->bool):(Param p): is_unitary_to_hts_big_SIMPLE(p,hts[1:test_levels[0]+1].sort_u), Uhash)
    then () = if test_verbose then prints("unitary to ht ",test_hts[0],
                        " face counts to dim 1: ",for list in LFDKH
			do #list od) fi
     then () = if quick_flag
    	      then let Dlast =  max((r-1)\2,1) {r - 1}
	      	   then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,test_hts[Dlast])
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p): 
		      is_unitary_to_hts_big_SIMPLE(p,hts[test_levels[0]+1:test_levels[Dlast]+1].sort_u)
		      ,Uhash)
                   in if test_verbose
		      then prints("unitary to ht ",test_hts[Dlast],
		      	      		" face counts to dim ",Dlast+1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
    then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   LFDKH, D+1,D+2, pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,test_hts[D])
       	      	 {compute graph on faces to dim D+1}
		 then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		      is_unitary_to_hts_big_SIMPLE(p,hts[test_levels[D-1]:test_levels[D]+1].sort_u)
		      , Uhash)
                 then () = if test_verbose
			   then prints("unitary to ht ",test_hts[D],
		      	      		" face counts to dim ",D+1,
				": ", for list in LFDKH do #list od)
			   fi
                 then ()= D:=D+1
                 in ()
     	     od{end of D while loop}
    in ()
    fi {quick_flag}
    {now have faces of all dims, to height test_hts[Dlast] or test_hts[Dmid]}
    then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:=ICPNU_flag_hold
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then () = if test_verbose then prints(sum(for list in LFDKH do #list od),
	      	      	   " unitary candidates in ",#eq," equivalence classes.") fi
    then () = long_out_flag := long_out_temp_flag
    then start = elapsed_ms(), pmin = parameter(x,lambda,0*lambda)
    {then () = for j:2 do prints(LFDKH[j]) od}
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash) {possibly put some bottom layer stuff??}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    in UParams

{Assume we have local vertices and edges LF, already herm, Dirac, pos on LKTs}
set local_test_GEO_hash(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1
    then () = if {EMPTY CASE} #LF[0] = 0 then return [] fi
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution - 1) {, NK = #KGB(G)}
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd,
	      	   	  	    LF, pol_hash, Uhash) {use
				    real_dumb if real_flag, def_dumb if def_flag}
	      fi
    then edge_offset_temp = edge_offset
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    {then depth= max(r,2)}
    then depth= max(((r-1)*edge_skip*stretcher)\1 + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)
    in [Param]: let maxDiffLoc = max_loc(for v in Lvd.list
    	       		    do G.two_rho_check*(dominant(G,thetaMinus*v))
		       		    od)
    	      	then pmax = first_param(finalize(parameter(x, lambda, Lvd.list[maxDiffLoc])))
		then Shorthts = if short_hts_flag then short_hts(pmax)
		     	      	else {let (answer,) = deform_hts(pmax,depth)} next_heights(pmax,depth)
				     {in answer} {deform_hts took 10 secs in Spin(4,4) spherical}
				fi
    	      	then () = if #Shorthts < depth and revert_flag
		     	  then return local_test_GEO_hash_else_dumb(x, lambda, {vd,}
    	      	 	     	   	       Lvd, LF, Shorthts[:min(1,#Shorthts)],
					       pol_hash, Uhash)
	      		  fi
		then () = test_string:= " using local_test_GEO_hash"
    	        then hts = [int]:
		     let d0 = min(#Shorthts, depth)
		     in Shorthts[:d0] ## for j:depth-d0 do -1 od
    	      	in local_test_GEO_hash_no_dumb(x, lambda, {vd,} Lvd, LF, hts,
	      	 pol_hash, Uhash)

set local_test_GEO_hash(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    {let () = adjust_global_top(x.inner_class)}
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash(KGBElt x, ratvec lambda, VertexData vd, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash{,
    [[FaceVertsIndex]] global_faces}) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO(KGBElt x, ratvec lambda) =
    [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form) {make_Param_hash()}, G = x.real_form, pol_hash = make_KTypePol_hash()
    {then vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash(x,lambda, {vd,} pol_hash, Uhash)

set hash2Counter = make_counter()

{This version assumes edges and vertices already computed, with herm and pos on LKTs; called by one_level}
{Local data assumed to have red_count coords if red_count_flag = true}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd, [[FaceVertsIndex]] LF,
KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = 1-x.involution, start = elapsed_ms()
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution -1)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash) 
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then edge_offset_temp = edge_offset
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\3 {3 seems best for F4}
	      fi
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom {keeping this reduced #tests by 1/4}
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd,
	      	   	  	   LF, pol_hash, Uhash) {use def_dumb if def_flag}
	      fi
    then depth= max(((r+1)*edge_skip*stretcher)\1 + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)
    then maxDiffLoc = max_loc(for v in Lvd.list
    	 	             do G.two_rho_check*(dominant(G,thetaMinus*v))
		             od)
    then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])
    then gammamax = pmax.infinitesimal_character
    {then far_sph_flag = bool: dominant(G,thetaMinus*gammamax)*G.two_rho_check/2 < to_ht_frac*(gammamax*G.two_rho_check)}
    	      { left guaranteed <= right term on right. If close, then
	       params are close to spherical princ series, and to_ht is fast}
    then hts =[int]: let Shorthts = if short_hts_flag {guaranteed to be size depth}
    	     	     	 	    then short_hts(pmax)
		     	      	    else next_heights(pmax,depth)
				    fi
    		     then () = if #Shorthts < depth and revert_flag
			       then return local_test_GEO_hash_else_dumb(x, lambda, {vd,}
    	      	 	     	   	   Lvd, LF, Shorthts[:min(#Shorthts,1)], pol_hash, Uhash)
			       fi
    		     then d0 = min(#Shorthts, depth)
		     in Shorthts[:d0] ## for j:depth-d0 do -1 od
    then () = test_string:= " using local_test_GEO_hash2"
    then  () = hash2Counter.use()
    then test_levels = for d:max(r+1,3) do (d*edge_skip*stretcher)\1 + edge_offset_temp od
    {last test_level is approx depth}
    then test_hts = for d:max(r+1,3) do hts[test_levels[d]] od, Dlast = max(r,2)
    {test_hts[d] = hts[test_levels[d]}
    {test_levels and test_hts both size about r+2}
    {hts[:max(depth,4)}
    then () = if(test_verbose) then prints("heights = ", hts, " , test levels = ",
    	 test_levels, ", test heights = ",test_hts) fi
    {get K-type formulas for all vertices and edges}
    then temp_K_char_flag = height(parameter(x,lambda,0*lambda))/(G.rho * G.two_rho_check) <= CUTOFF
     {defaults to true if ht=0, false otherwise}
    {then temp_K_char_flag = false}
    then pol_hash0 = if temp_K_char_flag
    	 	     then make_KTypePol_hash() {to hold chars to height test_hts[0]}
		     else pol_hash
		     fi

{for E8_s, K-chars to height test_hts[0] = 68 is 2.5 days. So maybe just hts[0]?}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in if temp_K_char_flag
		      	 then localFD_KHash_01_graph(x,lambda,Lvd,test_hts[0],pol_hash0,
			      LF, eq,CLBF)
			 else localFD_KHash_01_graph(x,lambda,Lvd,pol_hash0,LF, eq,CLBF)
			 fi
		  elif temp_K_char_flag
    	       	  then localFD_KHash_01(x, lambda, Lvd, test_hts[0], pol_hash0, LF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
    {then LFDKH = if temp_K_char_flag
    	       	 then localFD_KHash_01(x, lambda, Lvd, test_hts[0], pol_hash0, LF)
		 else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		 fi}
    then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on faces to dim 1, to hts[edge_offset]}
    {then () = prints("temp_K_char_flag = ",temp_K_char_flag)}
    then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
    	 		       then localGraphK(LFDKH)
    	 		       else localGraphK(LFDKH, pol_hash, test_hts[0]) {pol_hash0??}
			       fi
    {then () = prints("trial of eq at dim 1 is ",trial(x,lambda,Lvd,LFDKH, eq, hts[0]))}
 {because of to_ht, CANNOT use KNU testing}
    then KNU_flag_hold = KNU_flag
    then ICPNU_flag_hold = ICPNU_flag
    then () = KNU_flag:=false
    then () = ICPNU_flag:=false
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, {comment out _big???}
    	      (Param->bool):(Param p): is_unitary_to_hts_big_SIMPLE(p, hts[:test_levels[0]+1].sort_u)
				       , Uhash)
    {then () = prints("LFDKH before extend = ",LFDKH)}
    then () = if test_verbose then prints("unitary to ht ",test_hts[0],
                        " face counts to dim 1: ",for list in LFDKH do #list od) fi
    then () = LFDKH:= if temp_K_char_flag and red_count_flag and #LFDKH[1] > 0
    	      	      then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
		      	   in  extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red, CLBF_red)
    	      	      elif temp_K_char_flag
		      then extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
		      else LFDKH
		      fi
    {then () = prints("LFDKH after extend = ",LFDKH)}
    {then Dmid = max(r\4,1)} {changed from r\2, since test_levels[4] = 91 too slow for E8_s spherical}
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2, r+1, pol_hash)
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,test_hts[Dlast])
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		      is_unitary_to_hts_big_SIMPLE(p,test_hts[1:Dlast+1].sort_u)
		      , Uhash)
		      	{test to the same height as not quick}
                   in if test_verbose
		      then prints("unitary to ht ",test_hts[Dlast],
		      	      		" face counts to dim ",r,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
     then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                          	   LFDKH, D+1,D+2,pol_hash)
	         {then () = if D=1 then prints(LFDKH[2]) fi}
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, {test_}hts[D])
       	      	 {compute graph on faces to dim D+1}
		 {then () = prints("trial of eq at dim ",D+1," is ",
		 trial(x,lambda,Lvd,LFDKH, eq, test_hts[D]))}
		 then () = LFDKH := local_testK_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF,
		 (Param->bool):(Param p): is_unitary_to_ht_big_SIMPLE(p,hts[test_levels[D]])
					  , Uhash)
		 then () = if test_verbose
		     	   then prints("unitary to ht ",test_hts[D], " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
		 {then ()= Dmid:=D}
                 then ()= D:=D+1
		 in ()
     	     od
     in ()
     fi{quick_flag}
    {now have faces of all dims, to height test_hts[Dlast]}
    then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:= ICPNU_flag_hold
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    {then () = prints("last eq = ",eq)}
    {then sph_far_flag = dominant(G,thetaMinus*gammamax)*G.two_rho_check/2 < to_ht_frac*(gammamax*G.two_rho_check)}
    {term on left guaranteed <= right term on right. If close, then
    	       params are close to spherical princ series, and to_ht is fast}
    then () = if test_verbose
    	      then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
	           {if sph_far_flag
		   then} prints("using is_unitary")
		   {else prints("testing to height ",hts[test_levels[Dmid+1]])
		   fi}
	      fi
    then start=elapsed_ms() {already unitary to height hts[test_levels[Dlast]] = test_hts[max(r,2)]}
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash, (Param->bool): (Param p):
    	 	 {is_unitary_test_big_SIMPLE(p,hts[test_levels[Dlast+1]])}
		 is_unitary_hash_big_SIMPLE(p))
    	 	 {if sph_far_flag
	       	 then is_unitary_hash_big_SIMPLE(p) {small nu compared to infl char, unitary_to_ht is slow}
	  	 else is_unitary_test{_big}(p,hts[test_levels[Dmid+1]])
		      {large nu compared to infl char, unitary_to_ht is fast}
	      	 fi)}
    {Maybe NEED TO PUT BOTTOM LAYER STUFF BACK}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    in UParams

{Compute 0 and 1 faces, pass to previous}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2) {impose Dirac, pos on LKTs}
	     else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

{Compute 0 and 1 faces, ensuring hermitian, pos on LKTs, pass to previous}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, VertexData vd, LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash{, [[FaceVertsIndex]] global_faces}) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
    	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO2(KGBElt x, ratvec lambda) = [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form) {make_Param_hash()}, pol_hash = make_KTypePol_hash(), G = x.real_form
    {then vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash2(x,lambda,{vd,} pol_hash, Uhash)



{difficulty at which to revert to local_test_GEO_hash on each vertex.
0 to 100 make sense: higher means revert MORE often}
set diff_cutoff = int: 90

{0 to 10000 make sense. Setting to zero means NEVER revert to hash, and
10000 means always default}
set prod_cutoff = int: 3000

{3 is best for F4_s spherical
4 or 5 best for E7_s spherical}
set one_level = int: -1

{after unitary to one_level are found, run unitary_test(p, heights
from one_level+1 to last_level) to speed elimination of nonunitary. Need
to have last_level \ge one_level}
set last_level = int: -1

set hash_one_levelCounter = make_counter()

{assume local faces to dim 1 are recorded in LF, already herm and pos on LKTs}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, {VertexData vd,}
    LocalVertexData Lvd, [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = if 1*pmin = zero_pol then return [] fi
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then htFrac = height(parameter(x,lambda,0*lambda))/(G.rho * G.two_rho_check)
    then temp_K_char_flag = htFrac <= CUTOFF  {defaults to true if ht=0, false otherwise}
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash) {use def_dumb if def_flag}
	      fi
    then r = rank(thetaMinus)
    then ONE = if one_level = -1 then (r+2)\2
    	       else one_level
	       fi
    then LAST = if last_level = -1 then ONE+1
    	      else last_level
	      fi
    {if LAST = ONE, then final step should be _just_ is_unitary}
    { then () = prints("ONE = ",ONE,", LAST = ",LAST) }
    then edge_offset_temp = edge_offset
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    then depth= max(((r-1)*edge_skip*stretcher)\1 + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)
    then maxDiffLoc = max_loc(for v in Lvd.list
    	 	       	      do G.two_rho_check*(dominant(G,thetaMinus*v))
		       	      od)
    then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])
    then Shorthts = if short_hts_flag
    	 	    then short_hts(pmax)
		    else next_heights(pmax,max(depth, LAST+1))
		    fi
    then hts =[int]: let () = if #Shorthts < max(max(r,2), LAST+1) and revert_flag
    	      		       then return local_test_GEO_hash_else_dumb(x, lambda, {vd,} Lvd, LF,
			       	    Shorthts[:min(1,#Shorthts)], pol_hash, Uhash)
	      		       fi
		      then d0 = min(max(LAST+1,depth+1),#Shorthts)
    		      in Shorthts[:d0] ## for j:max(LAST,depth) + 1 - d0 do -1 od
    {then () = prints("depth = ",depth, ", #Shorthts = ",#Shorthts, ", LAST = ",LAST)}
    then approxMaxDiff = approxDiff(pmax)
    {then () = prints("approxMaxDiff = ",approxMaxDiff)}
    {now have at least two vertices. If it's an easy case,
    	 revert to local_test_GEO_hash}
    then () = if revert_flag and {(approxMaxDiff*approxVertexDiff < prod_cutoff) and}
    	      	 (approxMaxDiff < diff_cutoff)  {and}
		 {(approxVertexDiff < vert_diff_cutoff)}
	      then return local_test_GEO_hash_no_dumb(x, lambda, {vd,} Lvd,
	      	   	  LF, hts, pol_hash, Uhash)
    	      fi
    then () = test_string:= " using local_test_GEO_hash_one_level"
    then start_count = unitary_test_counter.use_count()
    then  () = hash_one_levelCounter.use()
    {then hts = next_heights(parameter(x,lambda,0*lambda), LAST+1)}
    then one_ht = hts[ONE], last_ht = hts[LAST]
   then () =  if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing level = ", ONE, ", final level = ",LAST, "; heights = ", hts, new_line)
	       fi
   then pol_hash_one_ht = KTypePol_hash:
   	if temp_K_char_flag
	then make_KTypePol_hash() {to hold K_chars to height one_ht = hts[ONE]}
	else pol_hash
	fi
   then KNU_flag_hold = KNU_flag
   then ICPNU_flag_hold = ICPNU_flag
   then () = KNU_flag:=false
   then () = ICPNU_flag:=false
   then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts
		  then is_unitary_to_hts_big_SIMPLE(p, hts[:ONE+1])
	 	  else is_unitary_to_ht_big_SIMPLE(p, one_ht)
	 	  {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
	 	  fi
   then LFDKH = [[FaceVertsKHash]]:
   	if step_flag and ONE > 0{just calculate K-chars to hts[0], reduce the problem, then go to one_ht}
	then let pol_hash_low = if temp_K_char_flag
	     	 	      	then make_KTypePol_hash() {to hold K-chars to hts[0] only}
				else pol_hash
				fi
             {get K-type formulas for all vertices and edges}
             then LFDKH = if temp_K_char_flag
	     	  	  then if red_count_flag and #LF[1] > 0
    	       	 	       then let (eq,CLBF) = localGraphRed(LF)
		      	       	    in localFD_KHash_01_graph(x,lambda,Lvd,hts[0], pol_hash_low,LF, eq,CLBF)
			       else localFD_KHash_01(x, lambda, Lvd, hts[0], pol_hash_low, LF)
			       fi {red_count_flag}
			   else if red_count_flag and #LF[1] > 0
    	       	 	       then let (eq,CLBF) = localGraphRed(LF)
		      	       	    in localFD_KHash_01_graph(x,lambda,Lvd, pol_hash,LF, eq,CLBF)
			       else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
			       fi {red_count_flag}
		  	   fi {temp_K_char_flag}
	     {then () = prints("#Lvd = ", #Lvd.list, ", #LFDKH[0] = ",#LFDKH[0])}
	     then tester0 = (Param->bool): (Param p) bool:
     	     	  is_unitary_to_ht_big_SIMPLE(p, hts[0])
             then ((eq,gr),IUCL,CLBF) = {if temp_K_char_flag
	     	  		      	then localGraphK(LFDKH)
					else} localGraphK(LFDKH, pol_hash, hts[0])
					{fi}
             {then () = prints("at hts[0], #eq = ", #eq)}
	     then () = LFDKH := local_testK_hash(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, tester0, Uhash)
   	     then () = LFDKH := if temp_K_char_flag and red_count_flag and #LFDKH[1] > 0
	     	       	     	then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
    	      	       	    	     in extend_K_characters_graph(x, lambda, Lvd, LFDKH, one_ht,
			       	     	pol_hash, eq_red, CLBF_red)
		      		elif temp_K_char_flag
		       		then extend_K_characters(x, lambda, Lvd, LFDKH, one_ht, pol_hash)
	     	       		else LFDKH
		       		fi
	     then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
	     	  		      	then localGraphK(LFDKH)
					else localGraphK(LFDKH, pol_hash, one_ht)
					fi
	     { then () = prints("at one_ht, #eq = ", #eq) }
	     {then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts then is_unitary_to_hts_big_SIMPLE(p, hts[1:ONE+1])
	 	  else is_unitary_to_ht_big_SIMPLE(p,one_ht)
	 {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
	 	  fi}
	     in local_testK_hash(x,lambda,Lvd, LFDKH, eq,
		       	gr, CLBF, tester1, Uhash)
	else {get K-type formulas for all vertices and edges}
    	     let LFDKH = if temp_K_char_flag
	     	       	 then localFD_KHash_01(x, lambda, Lvd, one_ht, pol_hash_one_ht, LF)
			 else localFD_KHash_01(x,lambda, Lvd, pol_hash, LF)
			 fi
    	     {now have all local faces of dims 0 and 1.}
 	     {compute graph on faces to dim 1, to one_ht}
    	     then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts then is_unitary_to_hts_big_SIMPLE(p, hts[:ONE+1])
	 	  else is_unitary_to_ht_big_SIMPLE(p,one_ht)
	 	  {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
	 	  fi
    	     then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
	     	  		      	then localGraphK(LFDKH)
					else localGraphK(LFDKH, pol_hash, one_ht)
					fi
    	      {remove from LFDKH all faces failing is_unitary_to_ht{_big}(one_ht)}
	     {then () = prints("at one_ht, #eq = ", #eq)}
    	     in local_testK_hash(x,lambda,Lvd, LFDKH, eq,
		      gr, CLBF, tester1, Uhash)
	     fi
    then () = if test_verbose then prints("unitary to ht ",one_ht,
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	   fi
{ Have faces to dim 1 unitary to one_ht. Seek to extend list to all higher dims }
    then long_out_temp_flag = long_out_flag
    then () = if quick_flag
    	      then LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash{_one_ht})
	      else let D = int:1
    then () = long_out_flag:=false
    then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht(one_ht) on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := if temp_K_char_flag
	      	     	  	   then localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   	LFDKH, D+1,D+2, one_ht, pol_hash_one_ht)
				   else localFD_KHashbt_lookDownGEO(x,lambda,Lvd,
				   	LFDKH,D+1,D+2,pol_hash)
				   fi
		    {now top degree in LFDKH is D+1}
		 then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
		      			    then localGraphK(LFDKH)
					    else localGraphK(LFDKH,pol_hash,one_ht)
					    fi
       	      	 {compute graph on faces to dim D+1}
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
					  in if all(for p in ps
					     	    do Uhash.lookup(p).>= or
						       tester1(p) {is_unitary_to_ht_big_SIMPLE(p,one_ht)}
	{better to use to_ht because usually p _already_ unitary to one_ht}
						    od)
					     then [LFDKH[D+1][m]]
					     else []
					     fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
                 then () = if test_verbose and
		      	   ((D = r-1)  or
    	      	    	   (#LFDKH < D) or
		    	   (#(LFDKH~[0]) <= D+2))
			   then prints("unitary to ht ",one_ht,
		      	      		   " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	      od
	      in ()
	      fi{quick_flag}
    then () = KNU_flag:=KNU_flag_hold
    then () = ICPNU_flag:= ICPNU_flag_hold
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then () = if test_verbose then { prints("unitary to ht ",one_ht, " faces by dim = ",
       	       	   		      		      unitary_by_dim);}
		prints("number of tests so far = ",unitary_test_counter.use_count() - start_count)
	      fi
    then () = LFDKH := if temp_K_char_flag and red_count_flag and #LFDKH[1] > 0
    	      	     then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
    	      	     	  in extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red, CLBF_red)
		      elif temp_K_char_flag
		      then extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
    	      	      else LFDKH
	      	      fi
    then start=elapsed_ms()
    then () = long_out_flag := long_out_temp_flag
    then UParams = [Param]:
         if one_ht >=  0
         then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	      then () = if test_verbose then prints(sum(for list in LFDKH do #list od),
	      	      	   " unitary candidates in ",#eq," equivalence classes.") fi
              in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash, (Param->bool):(Param p):
		      		    if prefer_to_hts
		      		    then is_unitary_test_big_SIMPLE(p,hts[ONE+1:])
				    else is_unitary_test_big_SIMPLE(p,hts[LAST])
		      		    fi)
		       {NEED PERHAPS TO PUT BOTTOM LAYER BACK}
          else for list@d in LFDKH
               do for v in list
                  do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		     then () = for  p1 in monomials(finalize(p))
                      	       do Uhash.match({herm_center(}p1{)});
                             	  if deform_flag
			     	  then for q in facet_deformed_new(p1)
                             	       do Uhash.match({herm_center(}q{)})
				       od
			     	  fi
                             	  od
		     then () = if long_out_flag
		      	       then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	    then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				    in ()
			       fi
		     in p
                  od
                od.##
	 fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line)
	      fi
   in UParams
   {fi}

{JUST CALCULATE FIRST TWO LEVELS}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash{,
    [[FaceVertsIndex]] global_faces}) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    in local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      	   {computes edges and verts, imposing hermitian and Dirac}
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    in local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_one_level(KGBElt x, ratvec lambda) = [Param]:
    let G = x.real_form
    then Uhash = big_unitary_hash.uhash(x.real_form){make_Param_hash()}, pol_hash = make_KTypePol_hash()
    {, vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_one_level(x,lambda,{vd,} pol_hash, Uhash)

{when LKT length is GREATER than bottom_length_frac*(max possible), DO
NOT use bottom_layer. Leaving this at 1 means always use bottom_layer,
to negative means never bottom layer.}
set bottom_length_frac = rat: 1{??}

{if true, use coh_ind_is_unitary in final tests; else is_unitary}
set coh_ind_tester_flag = true

set one_level_revert_flag = false


{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
{this version assumes more_flag, sets more_shift_level to bl_step_count*bl_step_size}
set local_test_GEO_hash_bottom_layer_interrupt(KGBElt x, ratvec lambda, {VertexData vd,}
    			LocalVertexData Lvd, [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    			Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms(),
    	UTCstart = unitary_test_counter.use_count()
    then zero_pol = null_module(G)
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
    then () = if ht = 0 {fine K-type in quasisplit G}
    	      then if one_level_revert_flag
	      	   then return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    then htFrac = ht/FPP_max_ht
    then () = more_shift_level:= bl_step_count*bl_step_size
    {then temp_K_char_flag= htFrac <= CUTOFF {CUTOFF defaults to 0}}
    then r = rank(thetaMinus)
    then pmin = parameter(x, lambda, Lvd.list[LF[0][0][0]] )
    then (Q0, pminL0) =  if small_test_flag
    	 	      	 then theta_stable_data_small(pmin)
		   	 else theta_stable_quasi_data(pmin)
		   	 fi
    then L0 = Q0.Levi
    then () = if (x.involution - 1).= {is_abelian(L0)}
    	      then let () = Uhash.match({herm_center(}first_param(finalize(pmin{pmax}{)})))
	      	   in return [pmin]
	      fi
    then DG0 = if small_test_flag
    	       then minSmallBottomData.G_min_height(x,lambda)
	       else max(for mu in LKTs(pmin)
    	       	    	do minBottomData.G_min_height(mu)
		   	od)
	       fi
    then Ds = for j:bl_step_count+1 do let H = height(pmin) + j*bl_step_size
    	      	  		       in if H > FPP_max_ht then {prints("too big H = ",H,", x = ",x.number,
				       	  ", lambda = ",lambda);} break fi;
				          H
				    od
     	{these are the greatest heights at which we'll be looking at bottom layer K-types;
	 so we can compute K-chars just to this height} {NOT TRUE for good range arguments!}
     then () = if L0=G
    	      then if one_level_revert_flag
	      	   then return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test_min_bottom(pmin, Uhash)
	      fi
    then () = test_string:= " using local_test_GEO_hash_bottom_layer"
    then  () = hash_bottom_layerCounter.use()
    then () =  if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing heights = ", Ds, new_line)
	       fi
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
{then LFDKH = [[FaceVertsKHash]]: localFD_KHash_01(x,lambda, Lvd, pol_hash, LF)}
   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   {remove all faces failing min_bottom_elim}
   then () = LFDKH := local_testK_hash_min_bottom_layer(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, pol_hash,  Uhash)
   then () = if test_verbose then prints("unitary on min_bottom layer face counts to dim 1: ",
   	for list in LFDKH do #list od) fi
   then () = if #LFDKH[0] = 0 then return [] fi
   then () = if #LFDKH[0] = 1 {not clear whether Ds help here; already passed min_bottom}
   	     then return if more_flag then one_param_test_bottom(parameter(x,lambda,
	     	  	    	      Lvd.list[LFDKH[0][0][0]]), Ds, Uhash)
	     	  	 else one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]),Uhash)
			 fi
	     fi

   then start_datas = elapsed_ms(), newDs = [int]:[]
   then MU = branch_std(pmin, Ds~[0])
   then datass =  for j:{bl_step_count} #Ds - 1 from 1
   	       	  do let datas = bottom_factors(bottom_K_type_Qs(pmin, Q0, Ds[j-1], Ds[j], MU))
		     {then () = prints("j = ",j,", card(datas) = ", card(datas),", datas = ",datas, new_line)}
		     in if card(datas) > 0
		     	then newDs #:= Ds[j];
			     [datas]
		     	else []
			fi
		   od.##.##  {??? second ## should be removed, list structure USED ???}
{
(KGBElt,ratvec,LocalVertexData,[[vec]],[[int]],[[int]],[vec],[KGPElt],[[(KGPElt,[(KType,[KType])])]],KTypePol_hash,Param_hash) ACTUAL here
(KGBElt,ratvec,LocalVertexData,[[vec]],[[int]],[[int]],[vec],[KGPElt],[(KGPElt,[(KType,[KType])])],KTypePol_hash,Param_hash) DEFINED above
(KGBElt,ratvec,LocalVertexData,[[vec]],[[int]],[[int]],[vec],       [KGPElt],[(KGPElt,[(KType,[KType])])],[int],KTypePol,KTypePol_hash,Param_hash actual below
(KGBElt,ratvec,LocalVertexData,[[vec]],[[int]],[[int]],[vec],KGPElt,[KGPElt],[(KGPElt,[(KType,[KType])])],[int],KTypePol,KTypePol_hash,Param_hash) WITH _step
}
   {then () = if test_verbose then prints("#datass = ",#datass, ", cardinalities = ", for datas in datass do card(datas) od) fi}
   then  maxQs = max_Qs(Q0)
   {next remove from LFDKH all faces failing bottom_factors_elim_factors_more}
   then () = if time_verbose then prints("time for more datass/maxQs was ",
    	      	 print_time_string(elapsed_ms() - start_datas), " at lambda = ",lambda)
	      fi
   {then m = 0, last = 0}
   then () = if #newDs > 0
   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   	     	  then () = LFDKH := local_testK_hash_bottom_layer_more(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, maxQs, datass, pol_hash, Uhash)
   		  then () = if test_verbose then prints("unitary on bottom layer to ",newDs~[0],
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	    fi
   	          then () = if #LFDKH[0] = 0 then return [] fi
   		  then () = if #LFDKH[0] = 1 {already passed newDs, so test_bottom useless}
   	     	       	    then return one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), Uhash)
	     		    fi
		  in ()
	      fi
   then DiffList = for v in LFDKH[0]
    	 	      do G.two_rho_check*(dominant(G,thetaMinus*Lvd.list[v[0]]))
		      od
   then maxDiffLoc = max_loc(DiffList), minDiffLoc = min_loc(DiffList)
{ Have faces to dim 1 bottom layer unitary to DG0. Seek to extend list to all higher dims }
  then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
       	    	     		r + 1, pol_hash)
    then unitary_by_dim = vec: for L in LFDKH do #L od
    {then gammamax = Lvd.list[LFDKH[0][maxDiffLoc][0]]}
    {then sph_far_flag = dominant(G,thetaMinus*gammamax)*G.two_rho_check/2 < to_ht_frac*(gammamax*G.two_rho_check)}
    then steps = max(r-1,1)
    then start=elapsed_ms()
    then test_heights = next_heights(pmin, steps)
    then j0 = if #newDs = 0
    	      then -1
	      else first(for m in test_heights do newDs~[0] < m od)
	      fi
    	 {so that we test above the height bottom layer has examined}
    then HT = if j0 = -1
    	      then test_heights~[0]
	      else test_heights[j0]
	      fi
    {then () = prints("testing to ",HT)}
    then UParams = [Param]:
         let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	 {these have had know_lower, min_bottom, and bottom_elim
	 already applied; so just do is_unitary_test}
    	 then () = if test_verbose
    	      	   then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   	prints("number of tests so far = ",unitary_test_counter.use_count() - UTCstart);
		   	prints("testing with def level 1")
	           fi
    	 in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash, (Param->bool): (Param p) bool:
			       is_unitary_def_test_big_SIMPLE(p))
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      fi
   in UParams


{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
{this version tries various bl_step_count_shift_levels increasing by bl_step_size. Computes the branching stuff
only when the test is needed.}
set local_test_GEO_hash_bottom_layer_step(KGBElt x, ratvec lambda, {VertexData vd,}
    			LocalVertexData Lvd, [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    			Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms(),
    	UTCstart = unitary_test_counter.use_count()
    then zero_pol = null_module(G)
    then () = more_shift_level:= bl_step_count*bl_step_size
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
    then () = if ht = 0 {fine K-type in quasisplit G}
    	      then if one_level_revert_flag
	      	   then return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    then htFrac = ht/FPP_max_ht
    {then temp_K_char_flag= htFrac <= CUTOFF {CUTOFF defaults to 0}}
    then r = rank(thetaMinus)
    then pmin = parameter(x, lambda, Lvd.list[LF[0][0][0]] )
    then (Q0, pminL0) = if small_test_flag
    	 	      	then theta_stable_data_small(pmin)
		   	else theta_stable_quasi_data(pmin)
		   	fi
    then L0 = Q0.Levi
    then () = if (x.involution - 1).=
    	      then let () = Uhash.match(first_param(finalize(pmin)))
	      	   in return [pmin]
	      fi
    then DG0 = if small_test_flag
    	       then minSmallBottomData.G_min_height(x,lambda)
	       else max(for mu in LKTs(pmin)
    	       	    	do minBottomData.G_min_height(mu)
		   	od)
	       fi
    then Ds = for j:bl_step_count+1 do let H = ht + j*bl_step_size
    	      	  		       in if H > FPP_max_ht then {prints("too big H = ",H,", x = ",x.number,
				       	  ", lambda = ",lambda);} break fi;
				          H
				    od
     	{these are the greatest heights at which we'll be looking at bottom layer K-types;
	 so we can compute K-chars just to this height} {NOT TRUE for good range arguments!}
     then () = if L0=G
    	      then if one_level_revert_flag
	      	   then return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test_all_bottom(pmin, Ds, Uhash)
	      fi
    then () = test_string:= " using local_test_GEO_hash_bottom_layer"
    then  () = hash_bottom_layerCounter.use()
    then () =  if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing heights = ", Ds[1:], new_line)
	       fi
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
   {then LFDKH = [[FaceVertsKHash]]: localFD_KHash_01(x,lambda, Lvd, pol_hash, LF)}
   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   {remove all faces failing min_bottom_elim}
   then () = LFDKH := local_testK_hash_min_bottom_layer(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, pol_hash,  Uhash)
   then () = if test_verbose then prints("unitary on min_bottom layer face counts to dim 1: ",
   	for list in LFDKH do #list od) fi
   then () = if #LFDKH[0] = 0 then return [] fi
   then () = if #LFDKH[0] = 1 {already passed min, so value of Ds unclear}
   	     then return one_param_test_bottom(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), Ds, Uhash)
	     fi
   then start_datas = elapsed_ms(), newDs = [int]:[]
   then MU = branch_std(pmin, Ds~[0])
   then empty_datas = [QKL_bottom_data]: []
   then (trial, newDs) = add_datas(pmin, Q0, empty_datas, Ds, MU)
   {then () = if time_verbose then prints("cardinalities = ",for datas in datass do card(datas) od) fi}
   then  maxQs = max_Qs(Q0)
   {next remove from LFDKH all faces failing bottom_factors_elim_factors_more}
   then () = if time_verbose then prints("time for more datass/maxQs was ",
    	      	 print_time_string(elapsed_ms() - start_datas), " at lambda = ",lambda)
	      fi
   then () = if #trial> 0 {we found a nontrivial bottom layer argument}
   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   	     	  then () = LFDKH := local_testK_hash_bottom_layer_more_step(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, Q0, maxQs, trial, newDs, MU, pol_hash, Uhash)
   		  then () = if test_verbose then prints("unitary on bottom layer to ",newDs~[0],
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	    fi
   	          then () = if #LFDKH[0] = 0 then return [] fi
   		  then () = if #LFDKH[0] = 1 {already passed Ds, so bottom_test useless}
   	     	       	    then return one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), Uhash)
	     		    fi
		  in ()
	      fi
   then DiffList = for v in LFDKH[0]
    	 	      do G.two_rho_check*(dominant(G,thetaMinus*Lvd.list[v[0]]))
		      od
   then maxDiffLoc = max_loc(DiffList), minDiffLoc = min_loc(DiffList)
{ Have faces to dim 1 bottom layer unitary to DG0. Seek to extend list to all higher dims }
  then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
       	    	     		r + 1, pol_hash)
    then unitary_by_dim = vec: for L in LFDKH do #L od
    {then gammamax = Lvd.list[LFDKH[0][maxDiffLoc][0]]}
    {then sph_far_flag = dominant(G,thetaMinus*gammamax)*G.two_rho_check/2 < to_ht_frac*(gammamax*G.two_rho_check)}
    then steps = max(r-1,1)
    then start=elapsed_ms()
    then test_heights = next_heights(pmin, steps)
    then j0 = if #newDs = 0
    	      then -1
	      else first(for m in test_heights do newDs~[0] < m od)
	      fi
    	 {so that we test above the height bottom layer has examined}
    then HT = if j0 = -1
    	      then test_heights~[0]
	      else test_heights[j0]
	      fi
    {then () = prints("testing to ",HT)}
    then UParams = [Param]:
         let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	 {these have had know_lower, min_bottom, and bottom_elim
	 already applied; so just do is_unitary_test}
    	 then () = if test_verbose
    	      	   then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   	prints("number of tests so far = ",unitary_test_counter.use_count() - UTCstart);
		   	prints("testing with def level 1")
	           fi
    	 in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash, (Param->bool): (Param p) bool:
			       is_unitary_def_test_big_SIMPLE(p))
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      fi
   in UParams


{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,}
    			LocalVertexData Lvd, [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    			Param_hash Uhash) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    if bl_interrupt_flag
    then more_flag:=true;
    	 {more_shift_level:=bl_step_count*bl_step_size}
	 return local_test_GEO_hash_bottom_layer_interrupt(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms(),
    	UTCstart = unitary_test_counter.use_count()
    then zero_pol = null_module(G)
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
        then pmin = parameter(x, lambda, Lvd.list[LF[0][0][0]] )
    then (Q0, pminL0) = if small_test_flag
    	 	      	then theta_stable_data_small(pmin)
		   	else theta_stable_quasi_data(pmin)
		   	fi
    then L0 = Q0.Levi
    then () = if L0=G {fine K-type in quasisplit G}
    	      then if one_level_revert_flag
	      	   then return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    then htFrac = ht/FPP_max_ht
    then () = if bl_step_flag {bl_step_count steps of size bl_step_size; defaults to 2 and 5}
    	      then more_flag:=true;
    	      	   {if more_shift_level = 0 then more_shift_level := maxht - ht fi;}
    	           return local_test_GEO_hash_bottom_layer_step(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
	      fi
    {then temp_K_char_flag= htFrac <= CUTOFF {CUTOFF defaults to 0}}
    then r = rank(thetaMinus)
    then () = if (x.involution - 1).=
    	      then let () = Uhash.match(first_param(finalize(pmin)))
	      	   in return [pmin]
	      fi
    then D = min(ht + more_shift_level, FPP_max_ht)
    {then D0 = height(pmin) + more_shift_level
    then D = if D0>FPP_max_ht
    	     then prints("too high D0 = ",D0," at x = ",x.number,", lambda = ",lambda); FPP_max_ht
	     else D0
	     fi}
	{this is the greatest height at which we'll be looking at bottom layer K-types; during the first pass;
	 so we can compute K-chars just to this height} {NOT TRUE for good range arguments!}
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test_all_bottom(pmin, [ht,D], Uhash)
	      fi
    then () = test_string:= " using local_test_GEO_hash_bottom_layer"
    then  () = hash_bottom_layerCounter.use()
    then () =  if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing height = ", D, new_line)
	       fi
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
{then LFDKH = [[FaceVertsKHash]]: localFD_KHash_01(x,lambda, Lvd, pol_hash, LF)}
      {label each face (vertex/edge) with index
   	      	in pol_hash of its K-character}
   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    	{next remove from LFDKH all faces failing min_bottom_factors_elim}
   then () = LFDKH:= local_testK_hash_min_bottom_layer(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, pol_hash,  Uhash)
   then () = if test_verbose then prints("unitary on min_bottom layer face counts to dim 1: ",
   	for list in LFDKH do #list od){; prints(parameter(x,lambda,Lvd.list[LFDKH[0][0][0]]))} fi
   then () = if #LFDKH[0] = 0
   	     then return []
	     fi
   then () = if #LFDKH[0] = 1
   	     then return if more_flag then one_param_test_bottom(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), [D], Uhash)
	     	  	 else one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]),Uhash)
			 fi
	     fi
   then () = if more_flag {want to use non-minimal theta-stable q}
   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   	     	  then start_datas = elapsed_ms()
   		  then datas = [QKL_bottom_data]: bottom_factors(bottom_K_type_Qs(pmin, Q0, D))
		  then () = if test_verbose then prints("cardinality(datas) = ", card(datas)) fi
		  then  maxQs = max_Qs(Q0) {all MAXIMAL theta-stable containing Q0}
   		  then () = if time_verbose then prints("time for more datas/maxQs was ",
    	      	      	      print_time_string(elapsed_ms() - start_datas), " at lambda = ",lambda)
	      		    fi
   		  then () = LFDKH := local_testK_hash_bottom_layer_more(x,lambda, Lvd, LFDKH, eq,
		       	  gr, CLBF, maxQs, datas, pol_hash,  Uhash) {bottom layer test on K-types in datas}
   		  then () = if test_verbose then prints("unitary on bottom layer to ",D,
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	    fi
   		  then () = if #LFDKH[0] = 0 then return [] fi
		  then () = if #LFDKH[0] = 1 {already passed D}
   	     	       	    then return one_param_test{_bottom}(parameter(x,lambda,
			    Lvd.list[LFDKH[0][0][0]]),{ [D],} Uhash)
	     		    fi
		  in ()
	      fi
	      {now have list of vertices and edges passing bottom layer test out to D}
   then () = if test_verbose then prints("unitary on bottom layer to height ",D," face counts to dim 1: ",
   	for list in LFDKH do #list od) fi
   then DiffList = for v in LFDKH[0]
    	 	   do G.two_rho_check*(dominant(G,thetaMinus*Lvd.list[v[0]]))
		   od
  then maxDiffLoc = max_loc(DiffList), minDiffLoc = min_loc(DiffList)
  { Have faces to dim 1 bottom layer unitary to D. Seek to extend list to all higher dims }
  then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
       	    	     		r + 1, pol_hash)
    then unitary_by_dim = vec: for L in LFDKH do #L od
    {then gammamax = Lvd.list[LFDKH[0][maxDiffLoc][0]]}
    {then sph_far_flag = dominant(G,thetaMinus*gammamax)*G.two_rho_check/2 < to_ht_frac*(gammamax*G.two_rho_check)}
    then steps = max(r-1,1)
    then start=elapsed_ms()
    then test_heights = next_heights(pmin, steps)
    then j0 = first(for x in test_heights do D < x od)
    	 {so that we test above the height bottom layer has examined}
    then HT = if j0 = -1
    	      then -1
	      else test_heights[j0]
	      fi
    then UParams = [Param]:
         let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	 {these have had know_lower, min_bottom, and bottom_elim
	 already applied; so just do is_unitary_test}
    	 then () = if test_verbose
    	      	   then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   	prints("number of tests so far = ",unitary_test_counter.use_count() - UTCstart);
		   	prints("testing with def_test(1)")
	           fi
    	 in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash, (Param->bool): (Param p) bool:
			       {is_unitary_test_big_SIMPLE(p,HT))} is_unitary_def_test_big_SIMPLE(p))
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      fi
   in UParams

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2{, mapAct}{, global_faces}) {impose Dirac}
	      else localFD_1Dirac2(x, lambda, Lvd, Perm2{, mapAct})
	      fi
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    [[FaceVertsIndex]] global_faces) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2{, mapAct})
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2{, mapAct})
	      fi
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2{, mapAct})
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2{, mapAct})
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_bottom_layer(KGBElt x, ratvec lambda) = [Param]:
    let G = x.real_form
    then Uhash = big_unitary_hash.uhash(x.real_form){make_Param_hash()}, pol_hash = make_KTypePol_hash()
    {, vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_bottom_layer(x,lambda, {vd,} pol_hash, Uhash)

set spherical_general(RealForm G, (KGBElt, ratvec->[Param]) local) = [Param]:
    let start = elapsed_ms()
    then r = rank(x_open(G).involution - 1)
    then answer = local(x_open(G), G.rho)
    then () =  {if time_verbose
    	       then} prints("Total time ", print_time_string(elapsed_ms() -start)) {fi}
    then () = if long_out_flag
    	      then prints("unitary faces by dim = ", for j:r+1 do #LFDKHByDim[j] od,
    	      	   		   	     	   test_string)
	      fi
    then () = if long_out_flag
    	      then prints("number of distinct K-characters = ",NumKchars())
	      fi
    in answer

{this gives def_dumb if def_flag = true}
set spherical_dumb(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO_dumb@(KGBElt, ratvec))

set spherical_def_dumb(RealForm G) = [Param]:
    let () = def_flag:=true
    in spherical_general(G, local_test_GEO_dumb@(KGBElt, ratvec))

set spherical(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO@(KGBElt, ratvec))

set spherical2(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO2@(KGBElt, ratvec))

set spherical_one_level(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO_one_level@(KGBElt, ratvec))
