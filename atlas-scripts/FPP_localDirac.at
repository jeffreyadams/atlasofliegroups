<FPP_facetsDirac
<simple_factors { for simple_factors }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]), no_reps}
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<unity.at { for is_unitary_test }
<bottom_layer.at {for bottom layer unitarity tests}
<springer_tables_reductive.at { for Springer_table }
<associated_variety_annihilator.at { for GK_dim, used in identifying unipotent reps }
<weak_packets.at {for unipotent_representations}
<derived_cover.at {for sc_descends}
{ <lietypes.at { for simple_type }}
{ <parabolics.at {for parabolic_by_wt}}
<K_highest_weights.at {for all_lambda_differential_zero}
<lattice.at {for vec_solve}
{ <chopping_facets_fast.at {for chop_coroots(G, vertices)}}
<facet_classes.at {for ordering on facets}
<hash.at {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<cohom_reduction
<translate {for translate_param_by}
<time {for print_string}
{This is meant to be functions for computing all unitary reps with
fixed LKT (x,lambda) and infl char in the FPP. Functions are meant to
use a Param_has Uhash containing a list of known unitary reps (like
Arthur's special unipotent ones) in order to avoid doing difficult
is_unitary calculations.

Throughout, the VertexData vd is meant to be the list of all vertices
in the FPP (that are fixed by the distinguished involution), and a
lookup function.

Attached to theta = x.involution and dlambda are

Perm = vec (size = number of vertices of FPP)
mapAct = vec (size = number of vertices of FPP)
Lvd = VertexData (vertex infinitesimal chars v in the FPP of Params
      		 (x, lambda v))

Here Perm is a partially defined permutation of order two of (indices
for) vd.list: it can happen that

- Perm[i] = i (fixed vertex v_i, so (x,lambda,v_i) is a Param of infl char
v_i); or

- Perm[j] = k != j, and Perm[k] = j, so (x,lambda, (v_j+v_k)/2) is a Param
  of infl char (v_j + v_k)/2; or

- Perm[ell] = -1, in which case v_ell has nothing to do with FPP Params
  at (x,lambda)

Say there are P fixed i and Q pairs (j,k). Then Lvd.list is the P+Q
vertices v_i and (v_j+v_k)/2, numbered in some way (probably not
reasonable).

mapAct is a partially defined map from the indices for vd.list to the
indices for Lvd.list.

If Perm[i] = i, then mapAct[i] = index of v_i in Lvd.list

If Perm[j] = k != j, then mapAct[j] = mapAct[k] = mapAct[j] =
number of (v_j+v_k)/2 in Lvd.list

For other ell, mapAct[ell] = -1.

Suppose (a_0,...,a_d) are the vertex numbers (indices in vd.list) of a d-diml facet of the
FPP. Then this facet meets FPP Params at (x,lambda) if and only if
(a_0,...,a_d) consists of p entries with Perm[a_i] = a_i and 2q
entries (a_j, a_k) exchanged by Perm (and no -1 entries). In this case
our facet meets the FPP infl chars in a facet of dimension p+q-1, with
vertices the fixed a_i and the various (a_j+a_k)/2.

The function localFD_Lvd(x, lambda, vd) computes (Lvd, Perm, mapAct).

Each d-dimensional (local) facet at (x,lambda) is referred to by the
vec of its d+1 indices in Lvd.list. Appended to the end of this vec is
a single integer giving the location of the K_character of the local
facet in a KTypePol_hash pol_hash.

There are four main functions, each taking either a long argument

(x, lambda, vd, LVD, Perm, mapAct, pol_hash, Uhash)

if you already have these in hand, or a short argument

(x, lambda, Uhash).

Functions each produce a list of all Params (x, lambda, nu_j), each
the barycenter of its local facet, each having weakly dominant
infinitesimal character in the FPP (but possibly not final), and each
having all Langlands quotients unitary. These unitary reps are also
added to Uhash.

Here is a description of the four algorithms between these.

*******************
local_test_GEO_hash_dumb

This finds all vertices, then all edges, and computes the graph; then
removes all nonunitary vertices and edges.

For each facet dimension D+1 after that, it finds all D+1-diml facets
having unitary-to-hts[D] faces; then makes a directed graph, and
eliminates all nonunitary facets.

The version def_dumb (invoked by def_flag = true, which is the
default) does unitarity tests using is_unitary_def_test.
*******************
local_test_GEO_hash
This finds all unitary-to-hts[0] vertices, then all unitary-to-hts[0]
edges.

For each facet dimension D+1 after that, it finds all D+1-diml facets
having unitary-to-hts[D] faces; then makes a directed graph, and
eliminates all facets failing is-unitary-to-hts[D].

Now it has all facets of all dimensions passing is-unitary-to-hts[top
dim -1]. From these it makes a graph, and computes is_unitary.
*******************
local_test_GEO_hash2

Finds ALL vertices, then ALL edges; then makes a graph, and discards
all vertices and edges failing is_unitary_to_hts[0].

Rest is same as local_test_GEO_hash. This version seems faster because
use of the graph up to dimension 1 reduces the number of
is_unitary_to_hts[0] tests.
********************
local_test_GEO_hash_one_level

Assesses the "difficulty" of this case. If it's relatively easy,
reverts to local_test_GEO_hash2. Otherwise...

Finds ALL vertices, then ALL edges; then makes a graph, and discards
all vertices and edges failing is_unitary_to_hts[0, 1, ... ,
one_level].

For each facet dimension D+1 after that, it finds all D+1-diml facets
having unitary-to-hts[one_level] faces; then makes a directed graph, and
eliminates all D+!-diml facets failing is-unitary-to-hts[one_level].

Now it has all facets of all dimensions passing
is-unitary-to-hts[one_level]. From these it makes a graph, and
computes is_unitary using is_unitary_test([one_level+1,...,last_level])
}

{given a sequence hts of hts to test, is_unitary_to_ht(p, hts~[0]) and
is_unitary_to_hts(p, hts) give the same result. If true, prefer using
the second. This seeks to eliminate easy cases by is_unitary_to_ht(p,
hts[0]) before trying the difficult is_unitary_to_ht(p,hts~[0])}
set prefer_to_hts = true

{. If "true," then print number of invocations of a unitarity test .}
set test_verbose = true

{. If "true," then print a little info about invocations of a unitarity test .}
set test_slightly_verbose = true


{. If "true," then calculations of unitary reps of a certain LKT
compute also the unitary deformations of these, with bigger
LKT's. This is unimportant for calculating say the spherical FPP
unitary dual, but very helpful with the FULL FPP unitary
dual. Therefore the functions FPP_unitary_hash... set this flag to
"true".}
set deform_flag = false

{. If "true," then some local FPP calculations revert to simpler (?)
   forms in "simple" cases.}
set revert_flag = true

{If "false", use the old version of one_level, in which vertex/edge calcs
are done immediately to ONE_HT}
set step_flag = false

{If "true", then hash_dumb uses is_unitary}
set real_flag = true

{If "true", then hash_dumb uses is_unitary_def_test, and hts are calculated with deform_hts}
set def_flag = true

{if "false" use next_heights instead of short_hts, to avoid calculating
deform (KL calculations). So prefer false for rank \ge 7?}
set short_hts_flag = true

set long_out_flag = false

{almost always it makes sense to preload the Arthur unipotent
reps. But not in a few test situations.}
set load_unipotents_flag = true

{if KGB number is below this times #KGB, use is_unitary rather than is_unitary_to_ht}
set low_KGB_frac = rat: 1/4

set difficulty(Param p) = rat:
    let rA = HTA(p)
    in if rA=0 then 0
       else rA/HT(p.real_form,p.infinitesimal_character)
       fi

{Integer between 0 and 100; integer part of 100*difficulty}
set approxDiff(Param p) = int:
    let q = difficulty(p)
    in (q.numer *100)\q.denom

{rational number, between 0 and 1 on FPP: how nu compares to rho in HT.
0 means tempered}
set difficultyA(Param p) = rat:
    let rA = HTA(p), G = p.real_form
    in rA/((G.rho)*(G.two_rho_check))

{Nonneg integer between 0 and 100; integer part of 100*difficultyA}
set approxDiffA(Param p) = int:
    let q = difficultyA(p)
    in (q.numer *100)\q.denom

{ Block of p, including zero parameters. Relevant because that's where
KL calculations need to happen }
set full_block(Param p) = [Param]:
let G = p.real_form
in for q in block_of(translate_param_by(p, G.two_rho))
   do translate_param_by(q, -G.two_rho)
   od
{in is_unitary_to_ht(N), KL calculations live in this subset of
full_block}
set full_block_to_ht(Param p, int N) = [Param]:
    for q in full_block(p)
    do if height(q) <= N then [q] else [] fi od.##

set ht_saving(Param p, int N) = rat:
    #full_block_to_ht(p,N)/#full_block(p)

{ between 0 and 100. SMALL means is_unitary_to_ht is likely to be
faster than is_unitary.

If N \ge height(p), then full_block_to_ht(p) always includes p; so

0 < ht_saving(p,N) \le 1.

Therefore 0 \le approx_ht_saving(p,N) \le 100}
set approx_ht_saving(Param p, int N) = int:
    let rp = reducibility_points(p)
    then result = int:
    	 if #rp = 0 then 0
	 else let r = ht_saving(p*rp~[0],N)
    	      in (r.numer *100)\r.denom
	 fi
    in result

{computes directed graph of local facets. Output GraphData is
[[int]],[[int]] giving equivalence classes and the graph. Next output
[vec]s are IUCL and classListByFacet}
{9/25/23: have extra coord in FacetVertsKHash to record # Langlands quotients}
set localGraphK([[FacetVertsKHash]] LFvertsK) = (GraphData, [vec],[vec]):
    {let () = if facet_verbose then prints("start to compute facet graph K")
    	     fi}
    let start = elapsed_ms()
    then (eq,gr) = GraphData: up_data(LFvertsK)
    then classListByFacet = [vec]: class_lists(LFvertsK,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
    then time = elapsed_ms() - start
    { then () = if time_verbose
	      then prints("     ", print_time_string(time),
	           " for localGraphK calculation ") fi }
    in ((eq,gr), IUCL, classListByFacet)

set localGraphK([[FacetVertsKHash]] FDKH, KTypePol_hash pol_hash, int level) =
    (GraphData, [vec],[vec]):
    let () = if facet_verbose then prints(new_line,"start to compute facet graph K to level ",
    	     		      	   			  level)
    	     fi
    then start = elapsed_ms()
    then (eq,gr) = GraphData: up_data(FDKH,pol_hash,level)
    then classListByFacet = [vec]: class_lists(FDKH,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr)
    { then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   " for localGraphK calculation") fi}
	 in ((eq,gr), IUCL, classListByFacet)

set look_up_vertices ([ratvec] vertices, [int] facet)=[ratvec]:
   for n in facet do vertices[n] od

set remove_closure ([vec] short,[vec] long) =[vec]:
  ##for v in short
    do if any(for w in long do sorted_is_subset(v,w) od)
       then [] else [v]
       fi
    od

set remove_closure ([[vec]] all, int k) =[[vec]]:
   for level@i in all do if i<k
	       then remove_closure (level,all[k])
	       else level
	       fi od

{returns the collection of unipotent points in list, as coords in list. If (x,lambda)
 has more than one LKT, only keep the unipotent irrs having ALL these LKTs.}
set local_unipotent_classes(KGBElt x, ratvec lambda, VertexData (list,lookup)) = vec:
(   let () = if facet_verbose
    	     then prints("start local_unipotent_classes")
	     fi
    then G = x.real_form
    then st = G.dual.Springer_table
    in if not(is_split(G) and (x=x_open(G)) and (lambda = G.rho))
       then for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
      	      in if m0 >= 0 and #finalize(parameter(x,lambda,gamma)) = 1 and
	      	 GK_dim(parameter(x,lambda,gamma)) = dim(st.dual_map(O))/2
		 then [m0]
		 else []
		 fi
	   od.##
	else for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
     	       in if m0 >= 0
	       	  then [m0]
		  else []
		  fi
	   od.##
	fi
)

{inserts special unipotent reps in unitary_hash}
set unipotents_to_hash(RealForm G, Param_hash Uhash) = void:
    if load_unipotents_flag
    then for p in unipotent_representations(G) do Uhash.match(p) od
    else ()
    fi

{add only those unipotent reps of Gsc factoring to a quotient G, with M: X*(G1) -->
X*(G) the corr wt inclusion}
set unipotents_to_hash(RealForm G, RealForm Gsc, Param_hash Uhash, mat M) = void:
    for psc in unipotent_representations(Gsc)
    do if solve(M,psc.lambda_minus_rho).any
       then for  p in sc_descends(psc, G, M)
	    do Uhash.match(p)
	    od
       fi
    od

{assume Gsc --> G corrs to M: X*(G) --> X*(Gsc); assume Usc_hash is
reps of Gsc; put in U_hash those descending to G}
set descend_to_quotient(RealForm G, Param_hash Usc_hash, Param_hash U_hash, mat M) = void:
    for j:Usc_hash.size()
    do let psc = Usc_hash.index(j)
       in if solve(M, psc.lambda_minus_rho).any
       	  then for p in sc_descends(psc, G, M)
	       do U_hash.match(p)
	       od
	  fi
    od

{inserts special unipotent reps in [unitary_hash]; assumed to have one
 for each KGBElt}
set unipotents_to_hashes(RealForm G, [Param_hash] Uhashes) = void:
    if load_unipotents_flag
    then for p in unipotent_representations(G)
    	      do let (,xnum) = %p.x
	         in Uhashes[xnum].match(p)
	      od
    else ()
    fi

{. The next family of functions all need simple derived group. Always
|vd.list| should be ALL vertices in the FPP; Lvd.list will be all infl
chars in the FPP for a parameter (x,lambda,*), with x and lambda
fixed. The facet lists carried by [[FacetBary]] or [[FacetVertsIndex]]
may be pruned of reps not interesting for unitarity, but the indices
will always refer to a constant vlist.}

{whether to fill in statuses for known unitaries in local_testK_hash}
{this is useless, for reasons I don't understand; does NOT change # of
is_unitary tests performed (for ex in FPP_unitary_hash_one_level(SO(4,4)))}
set KU_flag = false

{test candidate classes with (new) tester; delete
 from LFVKH facets established to be nonunitary in this way. Output is new
 shorter list of candidate facets. vd is LOCAL VertexData}
set local_testK_hash(KGBElt x, ratvec lambda, VertexData vd,
    [[FacetVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFacet,
    (Param->bool) tester, Param_hash Uhash) = [[FacetVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq
    	, printInterval = int: 1
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Facet.
     Use function known_unitaries from FPP_facets
     Look up class in classListByFacet, and mark "T"}
    then start = elapsed_ms()
    then () = if KU_flag and #FVKH = 2
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, vd, FVKH)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFacet[d][j]] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
    then () = if fund_facet_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash ", NumClasses,
		   " equiv classes of facets to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_facet_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0])
	      	  then verts = vec: FVKH[d][j][:d+1]
	      	  then ps = monomials(finalize(parameter(x, lambda
		    	  , facet_bary(vd.list, verts))))
	          in if{NEWU} all(for p in ps do Uhash.lookup(p).>= or
					       tester(p) od)
		     then newStatuses[k]:= "T"
		     else newStatuses:= updateNUclassesB(newStatuses, gr, k)
		     ; newStatuses[k] := "F"
		     fi{NEWU}
	         fi
	      od
     {make new local facet list using only facets not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FacetVertsKHash]: [] od
          then () = for C@m in eq do if newStatuses[m][0] = "T"
     	     	     	      	then for k in C
			      	   do let (d,j) = coords(FVKH,k)
				      in FVKHnew[d] :=
				      (FVKHnew[d] next FVKHnew[d]:=[])
				      #FVKH[d][j]
				   od
			         fi
			      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash") fi
     in  FVKHnew

set local_testK_hash(KGBElt x, ratvec lambda, VertexData vd,
    [[FacetVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFacet,
    int ht, Param_hash Uhash) = [[FacetVertsKHash]]:
    let tester = ((Param->bool): (Param p) bool:
	      Uhash.lookup(p).>= or is_unitary_to_ht(p, ht))
     in local_testK_hash(x, lambda, vd, FVKH, eq, gr, classListByFacet, tester, Uhash)


{test candidate classes with (new) tester; delete
 from LFVKH facets established to be nonunitary in this way. Output is new
 shorter list of candidate facets. vd is LOCAL VertexData.
 Assume bottdata only has mu to height the level of the K-chars in pol_hash.}
set local_testK_hash_bottom_layer(KGBElt x, ratvec lambda, VertexData vd,
    [[FacetVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFacet,
    steady_bottom_data bott_data, int one_ht, KTypePol_hash pol_hash, Param_hash Uhash) =
    			    [[FacetVertsKHash]]: 
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq
    	, printInterval = int: 1
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Facet.
     Use function known_unitaries from FPP_facets
     Look up class in classListByFacet, and mark "T"}
    then start = elapsed_ms()
    then () = if KU_flag and #FVKH = 2
    	      then let knownUnitaries = known_unitaries(Uhash, x, lambda, vd, FVKH)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFacet[d][j]] := "T"
	    	 		od
	      		     od
		   in ()
	       fi
    {then LKdatas = for mu in LKTs(parameter(x,lambda)) do bott_data.entry(mu) od}
    {then HT = max(for LKdata in LKdatas
    	      	  do max(for pairs in LKdata
		     	 do max(for (tau,) in pairs
			    	do height(tau)
				od)
		         od)
		  od)}
    then () = if fund_facet_verbose and NumClasses > 100
    then prints(); prints("start local_testK_hash ", NumClasses,
		   " equiv classes of facets to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_facet_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then prints("examining undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests.")
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0])
	      	  then verts = vec: FVKH[d][j][:d+1]
	      	  then ps = monomials(finalize(parameter(x, lambda
		    	  , facet_bary(vd.list, verts))))
	          in if #ps = 1
		     then if Uhash.lookup(ps[0]).>= or
		     	     min_bottom_elim_factors(ps[0], bott_data,
			     		branch_std(pol_hash.index(FVKH[d][j][d+1]), one_ht))
		     	  then newStatuses[k]:= "T"
			  else newStatuses:= updateNUclassesB(newStatuses, gr, k)
			  ; newStatuses[k] := "F"
			  fi
		     else if{NEWU} all(for p in ps
		     	  	       do Uhash.lookup(p).>= or
					  min_bottom_elim_factors(p, bott_data)
				       od)
			  then newStatuses[k]:= "T"
			  else newStatuses:= updateNUclassesB(newStatuses, gr, k)
			  ; newStatuses[k] := "F"
			  fi{NEWU}
		     fi
	         fi
	      od
     {make new local facet list using only facets not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FacetVertsKHash]: [] od
          then () = for C@m in eq do if newStatuses[m][0] = "T"
     	     	     	      	then for k in C
			      	   do let (d,j) = coords(FVKH,k)
				      in FVKHnew[d] :=
				      (FVKHnew[d] next FVKHnew[d]:=[])
				      #FVKH[d][j]
				   od
			         fi
			      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_bottom_layer") fi
     in  FVKHnew



set ParamsByDim = [[Param]]: for d:16 do [] od
set LFDKHByDim = [[FacetVertsKHash]]: for d:16 do [] od

{takes the unitary Param's listed in LFDKHByDim and computes the K-character
 number in pol_hash}
set KcharsByDim() = [[int]]:
    for j:16 do for v in LFDKHByDim [j] do v[j+1] od od

{lists all distinct K-characters (by number in pol_hash)}
set AllKchars() = [int]:
    KcharsByDim().##.sort_u

set NumKchars() = int:
    #AllKchars()

{will be modified to name of local test being run}
set test_string = ""

{ Input is candidate facets, and graph info. Output is the tester-unitary ones. 
 use and update a complete list Uhash of known tester-unitary facets. 
 try to compute and systematically use partial order on facets}
set local_test_hash(KGBElt x, ratvec lambda, VertexData Lvd,
    [[LocalFacetVertsHash]] LFVH, [[int]] eq, [[int]] gr,
    [vec] classListByFacet, Param_hash Uhash, (Param->bool) tester) = [Param]:
    let NumClasses = #eq, printInterval = int: 1{, start = elapsed_ms()}
    { then listZero = [ratvec]: if #LFVH = 0
    	 	    	      then []
    			      else for w in LFVH[0] do Lvd.list[w[0]] od
			      fi
    then vdZero = to_vertex_data(listZero) }
    then () = if fund_facet_verbose and NumClasses > 100
    	      then prints("start local_test, ",NumClasses,
	      " equiv classes of facets")
	      fi
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
    	 for m:NumClasses
    	~do if fund_facet_verbose and NumClasses > 100 and
	      	 ((NumClasses-m-1)%printInterval = 0)
	    then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",unitary_test_counter.use_count()
	      ," 'is_unitary' tests.")
	      ; printInterval := (3*printInterval)\2 + 1
	    fi
	    ;   let C=eq[m]
	      	then (d,j) = coords(LFVH,C[0])
	      	then verts = vec: LFVH[d][j][:d+1]
		  {first_param makes trouble in UParams list!}
	      	  then ps = monomials(finalize(parameter(x, lambda
		    	  , facet_bary(Lvd.list, verts))))
	      	in if{NEWU} all(for p in ps
		   	    	do Uhash.lookup(p).>= or tester(p) od)
		   then for i in C
		   	do let (d,j) = coords(LFVH,i)
			   then verts = vec: LFVH[d][j][:d+1]
			   then () = unitary_by_dim[d]+:=1
			   then q = parameter(x,lambda, facet_bary(Lvd.list,verts))
			   then () = for q1 in monomials(finalize(q))
			   	     do Uhash.match(herm_center(q1));
				     if deform_flag
				     then for q1d in face_deformed_unitaries_new(q1)
				     	  do Uhash.match(q1d)
					  od
				     fi
				     od
			   then () = if long_out_flag
		      	   	     then let () = ParamsByDim[d]:=(ParamsByDim[d] next ParamsByDim[d]:=[])
				     	  #q
				     {ParamsByDim[d] := ParamsByDim[d]#q}
			   	     	  then ()=LFDKHByDim[d]:=(LFDKHByDim[d] next LFDKHByDim[d]:=[])
					  #LFVH[d][j]
					  {LFDKHByDim[d]#LFVH[d][j]}
				     	  in ()
			   	     fi
		       	   in q
		    	od {list of tester unitary Params}
		   else []
		   fi{NEWU}
	  od.##
    then () = if test_verbose or test_slightly_verbose
    	      then prints("tester unitary facets by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count())
	      fi
    in  UParams

{ Input is candidate facets, and graph info. Output is the unitary ones.}
set local_test_hash(KGBElt x, ratvec lambda, VertexData Lvd,
    [[LocalFacetVertsHash]] LFVH, [[int]] eq, [[int]] gr,
    [vec] classListByFacet, Param_hash Uhash) = [Param]:
    local_test_hash(x, lambda, Lvd, LFVH, eq, gr,
    classListByFacet, Uhash, is_unitary@Param)

set one_true_counter = make_counter()
set one_false_counter = make_counter()
set hash_real_dumbCounter = make_counter()
set hash_dumbCounter = make_counter()
set hash_def_dumbCounter = make_counter()
set hash_bottom_layerCounter = make_counter()

set one_param_test(Param p, Param_hash Uhash) = [Param]:
    let Q = monomials(finalize(p)), G = p.real_form
    then NK = #KGB(G), r = rank(Q[0].x.involution - 1)
    then DEFHTS = [int]:
    	 if number(Q[0].x) < NK*low_KGB_frac
	 then []
	 else let (answer,) = deform_hts(Q[0],r\2)
	 in answer {could record boolean, use it to replace _test by _to_hts}
	 fi
    then  () = hash_def_dumbCounter.use()
    then test = all(for q in Q do Uhash.lookup(q).>= or
		   	       is_unitary_test(q, DEFHTS) od)
    in if test
       then let () = for q in Q
		     do Uhash.match(herm_center(q))
		     od
	    then () = one_true_counter.use()
	    in [p]
       else let () = one_false_counter.use()
	    in []
       fi

set one_param_test(Param p, steady_bottom_data bott_data, Param_hash Uhash) = [Param]:
    let QG = monomials(finalize(p)),G = p.real_form
    then () = hash_bottom_layerCounter.use()
    then test = all(for q in QG
    	      	    do Uhash.lookup(q).>= or
    	      	       min_bottom_test_factors(q, bott_data)
		    od)
    in if test
       then let () = for q in QG
		     do Uhash.match(herm_center(q))
		     od
	    then () = one_true_counter.use()
	    in [p]
       else let () = one_false_counter.use()
	    in []
       fi

{Assume we have local vertices and edges LF, herm and pos on LKTs.
Called when there are not enough heights; presumably small KGBElts??}
set local_test_GEO_hash_real_dumb(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
     [[FacetVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = if #LF[0] = 0 then return [] fi
    then r = rank(x.involution - 1), NK = #KGB(x.real_form)
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
	      fi
    then maxDiffLoc = max_loc(for v in Lvd.list
    	 	       	       do G.two_rho_check*(dominant(G,thetaMinus*v))
			       od)
    then pmax = first_param(finalize(parameter(x, lambda, Lvd.list[maxDiffLoc]))),
    	 r = rank(x.involution - 1)
    then test_hts = [int]:
    	 if number(pmax.x) < NK*low_KGB_frac
	 then []
	 else let (answer,) = deform_hts(pmax,r\2)  {!!this r\2 is a parameter to fiddle}
	      in answer
	 fi
    then tester = (Param->bool): (Param p) bool: {could have recorded bool above to
    	 	  		 	   	 omit is_unitary at end}
    	 is_unitary_test(p,test_hts)
    {then () = if facet_verbose then prints("test_hts = ",test_hts) fi}
    then () = test_string:= " using local_test_GEO_hash_real_dumb"
    then  () = hash_real_dumbCounter.use()
    then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)
    {then () = prints("#Lvd = ", #Lvd.list, ", #LFDKH[0] = ",#LFDKH[0])}
    then () =  if test_verbose then prints("facet counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on facets to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
           {remove from LFDKH all facets failing is_unitary}
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, tester, Uhash)
    then () = if test_verbose then prints("unitary facet counts to dim 1: ",
    for list in LFDKH do #list od) fi
    then D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds facets of dim D+1; then does is_unitary on
    facets of dim D+1; then adds facets of dim D+2, etc. If there are less than
    D+2 possibly unitary facets of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on facets to dim D+1}
		 then lowUs = sum(for d:D+1 do #LFDKH[d] od)
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml facet #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  facet_bary(Lvd.list, verts))))
					  in if all(for p in ps
					     	    do Uhash.lookup(p).>= or
						    is_unitary_hash(p) od)
		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
					     then [LFDKH[D+1][m]]
					     else []
					     fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("facet counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
    then unitary_by_dim = for L in LFDKH do #L od
    {now have unitary facets of all dims}
     {then () = if test_verbose then prints("total number of tests = ",
                                  unitary_test_counter.use_count())
				  fi}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary facets by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count())
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, facet_bary(Lvd.list, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match(herm_center(p1));
                             if deform_flag
			     then for q in face_deformed_unitaries_new(p1)
                             	  do Uhash.match(q)
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () =ParamsByDim[d]:=(ParamsByDim[d] next ParamsByDim[d]:=[])#p
			   {ParamsByDim[d] := ParamsByDim[d]#p}
			   	then ()=LFDKHByDim[d] :=(LFDKHByDim[d] next LFDKHByDim[d]:=[])#v
				{LFDKHByDim[d] := LFDKHByDim[d]#v}
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams


{Assume we have local vertices and edges LF, herm and pos on LKTs.
Called when there are not enough heights; presumably small KGBElts??}
set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    [[FacetVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = if #LF[0] = 0 then return [] fi
    then r = rank(x.involution - 1), NK = #KGB(G)
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
	      fi
    then test_hts = hts[:min(#hts,1)]
    then tester = (Param->bool): (Param p) bool:
    	 is_unitary_test(p,test_hts)
    then () = if facet_verbose then prints("test_hts = ",test_hts) fi
    then () = test_string:= " using local_test_GEO_hash_dumb"
    then  () = hash_dumbCounter.use()
    then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)
    {then () = prints("#Lvd = ", #Lvd.list, ", #LFDKH[0] = ",#LFDKH[0])}
    then () =  if test_verbose then prints("facet counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on facets to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
           {remove from LFDKH all facets failing is_unitary}
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, tester, Uhash)
    then () = if test_verbose then prints("unitary facet counts to dim 1: ",
    for list in LFDKH do #list od) fi
    then D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds facets of dim D+1; then does is_unitary on
    facets of dim D+1; then adds facets of dim D+2, etc. If there are less than
    D+2 possibly unitary facets of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on facets to dim D+1}
		 then lowUs = sum(for d:D+1 do #LFDKH[d] od)
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml facet #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  facet_bary(Lvd.list, verts))))
					  in if all(for p in ps
					     	    do Uhash.lookup(p).>= or
						    is_unitary_hash(p) od)
		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
					     then [LFDKH[D+1][m]]
					     else []
					     fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("facet counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
    then unitary_by_dim = for L in LFDKH do #L od
    {now have unitary facets of all dims}
     {then () = if test_verbose then prints("total number of tests = ",
                                  unitary_test_counter.use_count())
				  fi}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary facets by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count())
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, facet_bary(Lvd.list, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match(herm_center(p1));
                             if deform_flag
			     then for q in face_deformed_unitaries_new(p1)
                             	  do Uhash.match(q)
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{How many steps to use in is_unitary_def_test(p, steps) in def_dumb}
set def_steps = -1

{Assume we have local vertices and edges LF, herm and pos on LKTs and Dirac
	Use is_unitary_def_test(p, (G.rank + 1)\2}
set local_test_GEO_hash_def_dumb(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    [[FacetVertsIndex]] LF, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = if #LF[0] = 0 then return [] fi
    then r = rank(x.involution - 1)
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
	      fi
    then def_steps_temp = if def_steps = -1
    	 		  then (r+G.rank)\2
			  else def_steps
			  fi
    then tester = (Param->bool): (Param p) bool:
    	 is_unitary_def_test(p,def_steps_temp) {(G.rank+1)\2)}
    then () = test_string:= " using local_test_GEO_hash_def_dumb"
    then  () = hash_def_dumbCounter.use()
    then LFDKH = localFD_KHash_01(x, lambda, Lvd, pol_hash,LF)
    {then () = prints("#Lvd = ", #Lvd.list, ", #LFDKH[0] = ",#LFDKH[0])}
    then () =  if test_verbose then prints("facet counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on facets to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
           {remove from LFDKH all facets failing is_unitary}
    { then () = prints("def_steps_temp = ", def_steps_temp) }
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, tester, Uhash)
    then () = if test_verbose then prints("unitary facet counts to dim 1: ",
    for list in LFDKH do #list od) fi
    then D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds facets of dim D+1; then does is_unitary on
    facets of dim D+1; then adds facets of dim D+2, etc. If there are less than
    D+2 possibly unitary facets of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on facets to dim D+1}
		 then lowUs = sum(for d:D+1 do #LFDKH[d] od)
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml facet #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  facet_bary(Lvd.list, verts))))
					  in if all(for p in ps
					     	    do Uhash.lookup(p).>= or
						    is_unitary_hash(p) od)
		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
					     then [LFDKH[D+1][m]]
					     else []
					     fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("facet counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
    {now have unitary facets of all dims}
     then unitary_by_dim = for L in LFDKH do #L od
     then () = if test_verbose or test_slightly_verbose
    	       then prints("unitary facets by dim = ",
       	       	    	    unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count())
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, facet_bary(Lvd.list, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match(herm_center(p1));
                             if deform_flag
			     then for q in face_deformed_unitaries_new(p1)
                             	  do Uhash.match(q)
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{assume LF is verts and edges, herm and pos on LKTs and Dirac?}
set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    [[FacetVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    if real_flag
    then local_test_GEO_hash_real_dumb(x, lambda, vd, Lvd, LF, pol_hash, Uhash)
    elif def_flag
    then local_test_GEO_hash_def_dumb(x, lambda, vd, Lvd, LF, pol_hash, Uhash)
    else let shorts = if short_hts_flag
    	     	      then short_hts(parameter(x,lambda,Lvd.list[0]))
		      else next_heights(parameter(x,lambda, Lvd.list[0]), 1)
		      fi
    	 then hts = shorts[:min(1,#shorts)]
    	 in local_test_GEO_hash_dumb(x, lambda, vd, Lvd, LF, hts, pol_hash, Uhash)
    fi

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let DiracBD = DiracBD(x,lambda), G=x.real_form
    then rhocheck = G.rho_check
    then LF = localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    in local_test_GEO_hash_dumb(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash, [[FacetVertsIndex]] global_facets) = [Param]:
    let DiracBD = DiracBD(x,lambda), G=x.real_form
    then rhocheck = G.rho_check
    then LF = [[FacetVertsIndex]]: localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct, global_facets)
    {imposes Dirac, herm, pos on LKTs for vertices and edges}
    in local_test_GEO_hash_dumb(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, VertexData vd,
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then ELs = edge_list_lookups(G)
    then () = adjust_global_top(G)
    then () = if #global_facets = 0 or #global_facets[0] != #vd.list
    then global_facets := low_FPP_facets(G)
	      fi
    then (Lvd, Perm2, mapAct) = localFD_Lvd2(x, lambda, vd, ELs)
    then LF = localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_dumb(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_dumb(KGBElt x, ratvec lambda) =
    [Param]:
    let Uhash = make_Param_hash(), pol_hash = make_KTypePol_hash(), G = x.real_form
    then vd = FPP_vertex_data(G)
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_dumb(x, lambda, vd, pol_hash, Uhash)

{for character_formula calculations on parameters of

    height/(G.rho * G.two_rho) \le CUTOFF,

it's assumed that character_to_height is faster. Setting CUTOFF = 2
means always character_formula_to_height, CUTOFF=0 means
character_formula except for height 0, and CUTOFF = -1 means always
character_formula. For F4_s, CUTOFF = 0 saves 10 seconds over -1 and 2}
set CUTOFF =rat: 0/1

{USE THESE IN HASH AND HASH2!}
{lowest level (index in hts[]) to start testing}
set edge_offset = int: -1

{how much to increase level at each repetition}
set edge_skip = int: 1

{vertex set size number at which to revert to local_test_GEO_hash_dumb.
0 to 100 make sense: higher means revert MORE often}
set vert_diff_cutoff = int: 10

set hashCounter = make_counter()

{assume we've already got hts, #hts >= 1, imposed Dirac, and decided not to use _dumb
Assume LF is vertices and edges, already pos on LKTs and hermitian and Dirac}
set local_test_GEO_hash_no_dumb(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    [[FacetVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    let () = hashCounter.use()
    then () = test_string:= " using local_test_GEO_hash"
    then () = if(facet_verbose) then prints("hts = ",hts) fi
    then long_out_temp_flag = long_out_flag, r = rank(x.involution -1), start = elapsed_ms()
    then () = long_out_flag:=false {to allow using local_test_hash without recording Params}
    {then () = prints("start no_dumb, hts = ",hts)}
    then edge_offset_temp = edge_offset, ht0 = height(parameter(x,lambda,0*lambda)),
    	 G = x.real_form
    then temp_K_char_flag = ht0/(G.rho * G.two_rho_check) > CUTOFF
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    then test_levels = for d:max(r,2) do d*edge_skip + edge_offset_temp od
    then test_hts = for d:max(r,2) do hts[test_levels[d]] od
    then pol_hash0 = if temp_K_char_flag
    	 	     then make_KTypePol_hash() {to hold formulas to ht test_hts[0]}
		     else pol_hash
		     fi
    {add K-chars to vertices and edges}
    then LFDKH = if temp_K_char_flag
    	       	 then localFD_KHash_01(x, lambda, Lvd, test_hts[0], pol_hash0, LF)
		 else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		 fi
    {then () = prints("#Lvd = ", #Lvd.list, ", #LFDKH[0] = ",#LFDKH[0])}
    then () =  if test_verbose then prints("facet counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on facets to dim 1, to hts[0]}
    then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
    	 		       then localGraphK(LFDKH, pol_hash, hts[0])
			       else localGraphK(LFDKH)
			       fi
        {remove from LFDKH all facets failing is_unitary_to_ht(test_hts[0])}
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF,
    	   (Param->bool):(Param p): {Uhash.lookup(p).>= or}
	   			is_unitary_to_hts(p,hts[:test_levels[0]+1]), Uhash)
    then () = if test_verbose then prints("unitary to ht ",test_hts[0],
                        " facet counts to dim 1: ",for list in LFDKH
			do #list od) fi
    then () = LFDKH := if temp_K_char_flag
    	      	       then LFDKH
		       else extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
		       fi
    then D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds facets of dim D+1; then does is_unitary_to_ht on
    facets of dim D+1; then adds facets of dim D+2, etc. If there are less than
    D+2 possibly unitary facets of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   LFDKH, D+1,D+2, pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,test_hts[D])
       	      	 {compute graph on facets to dim D+1}
		 then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		      {Uhash.lookup(p).>= or} is_unitary_to_ht(p,test_hts[D]), Uhash)
		      {is_unitary_to_hts(p,hts[:D+1]), Uhash)}

                 then () = if test_verbose
			   then prints("unitary to ht ",test_hts[D],
		      	      		" facet counts to dim ",D+1,
				": ", for list in LFDKH do #list od)
			   fi
                 then ()= D:=D+1
                 in ()
     	     od
    {now have facets of all dims, to height hts[?]}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then () = long_out_flag := long_out_temp_flag
    then UParams = local_test_hash(x,lambda,Lvd,LFDKH,eq,gr,CLBF,Uhash)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    in UParams


{Assume we have local vertices and edges LF, already herm, Dirac, pos on LKTs}
set local_test_GEO_hash(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    [[FacetVertsIndex]] LF, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    let (G,j0) = %x, thetaMinus = x.involution - 1
    then () = if {EMPTY CASE} #LF[0] = 0 then return [] fi
    then r = rank(x.involution - 1) {, NK = #KGB(G)}
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
	      fi
    then vertexDiff = #Lvd.list/#vd.list
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, vd, Lvd,
	      	   	  	    LF, pol_hash, Uhash) {use
				    real_dumb if real_flag, def_dumb if def_flag}
	      fi
    then edge_offset_temp = edge_offset
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    {then depth= max(r,2)}
    then depth= max((r-1)*edge_skip + edge_offset_temp + 1, edge_skip + edge_offset_temp + 1)
    in [Param]: let maxDiffLoc = max_loc(for v in Lvd.list
    	 	       		    do G.two_rho_check*(dominant(G,thetaMinus*v))
		       		    od)
    	      	then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])
		then Shorthts = if short_hts_flag then short_hts(pmax)
		     	      	else next_heights(pmax,depth)
				fi
    	      	then () = if #Shorthts < depth and revert_flag
		     	  then return local_test_GEO_hash_dumb(x, lambda, vd,
    	      	 	     	   	       Lvd, LF, Shorthts[:min(1,#Shorthts)],
					       pol_hash, Uhash)
	      		  fi
		then () = test_string:= " using local_test_GEO_hash"
    	        then hts = [int]:
		     let d0 = min(#Shorthts, depth)
		     in Shorthts[:d0] ## for j:depth-d0 do -1 od
    	      	in local_test_GEO_hash_no_dumb(x, lambda, vd, Lvd, LF, hts,
	      	 pol_hash, Uhash)

set local_test_GEO_hash(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let LF = localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct,global_facets)
    in local_test_GEO_hash(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    [[FacetVertsIndex]] global_facets) = [Param]:
    let LF = [[FacetVertsIndex]]: localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    in local_test_GEO_hash(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash(KGBElt x, ratvec lambda, VertexData vd,
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then ELs = edge_list_lookups(G)
    then () = adjust_global_top(G)
    then () = if #global_facets = 0 or #global_facets[0] != #vd.list
    then global_facets := low_FPP_facets(G)
	      fi
    then (Lvd, Perm2, mapAct) = localFD_Lvd2(x, lambda, vd, ELs)
    then LF = localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO(KGBElt x, ratvec lambda) =
    [Param]:
    let Uhash = make_Param_hash(), G = x.real_form, pol_hash = make_KTypePol_hash()
    then vd = FPP_vertex_data(G)
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash(x,lambda, vd, pol_hash, Uhash)

set hash2Counter = make_counter()

{This version assumes edges and vertices already computed, with herm and pos on LKTs; called by one_level}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, [[FacetVertsIndex]] LF,
KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms()
    then r = rank(x.involution -1){, NK = #KGB(G)}
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
	      fi
    then edge_offset_temp = edge_offset
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    then vertexDiff = #Lvd.list/#vd.list
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, vd, Lvd,
	      	   	  	   LF, pol_hash, Uhash) {use def_dumb if def_flag}
	      fi
    then depth= max((r-1)*edge_skip + edge_offset_temp + 1, edge_skip + edge_offset_temp + 1)
    then hts =[int]: let maxDiffLoc = max_loc(for v in Lvd.list
    	 	             do G.two_rho_check*(dominant(G,thetaMinus*v))
		             od)
    		     then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])
    		     then Shorthts = if short_hts_flag then short_hts(pmax)
		     	      	     else next_heights(pmax,depth)
				     fi
    		     then () = if #Shorthts < depth and revert_flag
			       then return local_test_GEO_hash_dumb(x, lambda, vd,
    	      	 	     	   	   Lvd, LF, Shorthts[:min(#Shorthts,1)], pol_hash, Uhash)
			       fi
    		     then d0 = min(#Shorthts, depth)
		     in Shorthts[:d0] ## for j:depth-d0 do -1 od
    then () = test_string:= " using local_test_GEO_hash2"
    then  () = hash2Counter.use()
    then test_levels = for d:max(r,2) do d*edge_skip + edge_offset_temp od
    then test_hts = for d:max(r,2) do hts[test_levels[d]] od
    then () = if(test_verbose) then prints("heights = ", hts, " , test levels = ",
    	 test_levels, ", test heights = ",test_hts) fi
    {get K-type formulas for all vertices and edges}
    {then () = print(LF)}
    then temp_K_char_flag = height(parameter(x,lambda,0*lambda))/(G.rho * G.two_rho_check) > CUTOFF
    then pol_hash0 = if temp_K_char_flag
    	 	     then pol_hash
		     else make_KTypePol_hash() {to hold chars to height hts[0]}
		     fi
    then LFDKH = if temp_K_char_flag
    	       	 then localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		 else localFD_KHash_01(x, lambda, Lvd, test_hts[0], pol_hash0, LF)
		 fi
    then () =  if test_verbose then prints("facet counts to dim 1: ",
                          for list in LFDKH do #list od) fi
        {compute graph on facets to dim 1, to hts[edge_offset]}
    then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
    	 		       then localGraphK(LFDKH, pol_hash, test_hts[0])
			       else localGraphK(LFDKH) {pol_hash ,test_hts[0])}
			       fi
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF,
    	   (Param->bool):(Param p): if prefer_to_hts
	   			    then {Uhash.lookup(p).>= or}
				    is_unitary_to_hts(p,hts[:test_levels[0]+1])
				    else {Uhash.lookup(p).>= or}
				    is_unitary_to_ht(p,test_hts[0])
				    fi, Uhash)
    then () = LFDKH:= if temp_K_char_flag
    	      	      then LFDKH
		      else extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
		      fi
    then () = if test_verbose then prints("unitary to ht ",hts[test_levels[0]],
                        " facet counts to dim 1: ",for list in LFDKH do #list od) fi
    then D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds facets of dim D+1; then does is_unitary_to_ht on
    facets of dim D+1; then adds facets of dim D+2, etc. If there are less than
    D+2 possibly unitary facets of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                          	   LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,test_hts[D])
       	      	 {compute graph on facets to dim D+1}
		 then () = LFDKH := local_testK_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF,
		      (Param->bool):(Param p): {Uhash.lookup(p).>= or}
		      			   is_unitary_to_ht(p, test_hts[D]), Uhash)
			  {is_unitary_to_hts(p, hts[test_levels[D-1]+1:test_levels[D]+1])}
                then () = if test_verbose {and
		      	   ((D = rank(x.involution-1)-1)  or
    	      	    	   (#LFDKH < D) or
		    	   (#(LFDKH~[0]) <= D+2))}
			   then prints("unitary to ht ",test_hts[D],
		      	      		" facet counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
    {now have facets of all dims, to height hts[?]}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then UParams = local_test_hash(x,lambda,Lvd,LFDKH,eq,gr,CLBF,Uhash)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    in UParams


{Compute 0 and 1 facets, pass to previous}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    {let LF = [[FacetVertsIndex]]: [for k:#Lvd.list do [k] od]}
    let LF = localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets) {impose Dirac, pos on LKTs}
    in local_test_GEO_hash2(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

{Compute 0 and 1 facets, ensuring hermitian, pos on LKTs, pass to previous}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash, [[FacetVertsIndex]] global_facets) = [Param]:
    let LF = [[FacetVertsIndex]]: localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct, global_facets)
    in local_test_GEO_hash2(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash2(KGBElt x, ratvec lambda, VertexData vd,
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then ELs = edge_list_lookups(G)
    then () = adjust_global_top(G)
    then () = if #global_facets = 0 or #global_facets[0] != #vd.list
    then global_facets := low_FPP_facets(G)
	      fi
    then (Lvd, Perm2, mapAct) = localFD_Lvd2(x, lambda, vd, ELs)
    then LF = localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash2(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO2(KGBElt x, ratvec lambda) = [Param]:
    let Uhash = make_Param_hash(), pol_hash = make_KTypePol_hash(), G = x.real_form
    then vd = FPP_vertex_data(G)
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash2(x,lambda,vd, pol_hash, Uhash)



{difficulty at which to revert to local_test_GEO_hash on each vertex.
0 to 100 make sense: higher means revert MORE often}
set diff_cutoff = int: 90

{0 to 10000 make sense. Setting to zero means NEVER revert to hash, and
10000 means always default}
set prod_cutoff = int: 3000

{3 is best for F4_s spherical
4 or 5 best for E7_s spherical}
set one_level = int: -1

{after unitary to one_level are found, run unitary_test(p, heights
from one_level+1 to last_level) to speed elimination of nonunitary. Need
to have last_level \ge one_level}
set last_level = int: -1

set hash_one_levelCounter = make_counter()

{assume local facets to dim 1 are recorded in LF, already herm and pos on LKTs}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, VertexData vd,
    VertexData Lvd, [[FacetVertsIndex]] LF, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
	      fi
    then htFrac = height(parameter(x,lambda,0*lambda))/(G.rho * G.two_rho_check)
    then temp_K_char_flag = htFrac > CUTOFF
    then vertexDiff = #Lvd.list/#vd.list
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then return local_test_GEO_hash_dumb(x, lambda, vd, Lvd, LF, pol_hash, Uhash) {use def_dumb if def_flag}
	      fi
    then r = rank(thetaMinus)
    then ONE = if one_level = -1 then (r+2)\2
    	       else one_level
	       fi
    then LAST = if last_level = -1 then ONE+1
    	      else last_level
	      fi
    {if LAST = ONE, then final step should be _just_ is_unitary}
    { then () = prints("ONE = ",ONE,", LAST = ",LAST) }
    then edge_offset_temp = edge_offset
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    then depth= max((r-1)*edge_skip + edge_offset_temp + 1, edge_skip + edge_offset_temp + 1)
    then maxDiffLoc = max_loc(for v in Lvd.list
    	 	       	      do G.two_rho_check*(dominant(G,thetaMinus*v))
		       	      od)
    then pmax = parameter(x, lambda, Lvd.list[maxDiffLoc])
    then Shorthts = if short_hts_flag
    	 	    then short_hts(pmax)
		    else next_heights(pmax,max(depth, LAST+1))
		    fi
    then depth= max((r-1)*edge_skip + edge_offset_temp + 1, edge_skip + edge_offset_temp + 1)
    then hts =[int]: let () = if #Shorthts < max(max(r,2), LAST+1) and revert_flag
    	      		       then return local_test_GEO_hash_dumb(x, lambda, vd, Lvd, LF,
			       	    Shorthts[:min(1,#Shorthts)], pol_hash, Uhash)
	      		       fi
		      then d0 = min(max(LAST+1,depth+1),#Shorthts)
    		      in Shorthts[:d0] ## for j:max(LAST,depth) + 1 - d0 do -1 od
    {then () = prints("depth = ",depth, ", #Shorthts = ",#Shorthts, ", LAST = ",LAST)}
    then approxMaxDiff = approxDiff(pmax)
    {then () = prints("approxMaxDiff = ",approxMaxDiff)}
    {now have at least two vertices. If it's an easy case,
    	 revert to local_test_GEO_hash}
    then () = if revert_flag and {(approxMaxDiff*approxVertexDiff < prod_cutoff) and}
    	      	 (approxMaxDiff < diff_cutoff)  {and}
		 {(approxVertexDiff < vert_diff_cutoff)}
	      then return local_test_GEO_hash_no_dumb(x, lambda, vd, Lvd,
	      	   	  LF, hts[:max(depth+1,2)], pol_hash, Uhash)
    	      fi
    then () = test_string:= " using local_test_GEO_hash_one_level"
    then  () = hash_one_levelCounter.use()
    {then hts = next_heights(parameter(x,lambda,0*lambda), LAST+1)}
    then one_ht = hts[ONE], last_ht = hts[LAST]
   then () =  if test_verbose then prints("facet counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing level = ", ONE, ", final level = ",LAST, "; heights = ", hts, new_line)
	       fi
   then pol_hash_one_ht = KTypePol_hash:
   	if temp_K_char_flag
	then pol_hash
	else make_KTypePol_hash() {to hold K_chars to height one_ht = hts[ONE]}
	fi
   then LFDKH = [[FacetVertsKHash]]:
   	if step_flag and ONE > 0{just calculate K-chars to hts[0], reduce the problem, then go to one_ht}
	then let pol_hash_low = if temp_K_char_flag
	     	 	      	then pol_hash
				else make_KTypePol_hash() {to hold K-chars to hts[0] only}
				fi
             {get K-type formulas for all vertices and edges}
             then LFDKH = if temp_K_char_flag
	     	  	  then localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
			  else localFD_KHash_01(x, lambda, Lvd, hts[0], pol_hash_low, LF)
			  fi
	     {then () = prints("#Lvd = ", #Lvd.list, ", #LFDKH[0] = ",#LFDKH[0])}
	     then tester0 = (Param->bool): (Param p) bool:
     	     	  is_unitary_to_ht(p, hts[0])
             then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
	     	  		      	then localGraphK(LFDKH, pol_hash, hts[0])
					else localGraphK(LFDKH)
					fi
             {then () = prints("at hts[0], #eq = ", #eq)}
	     then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq,
		      gr, CLBF, tester0, Uhash)
   	     then () = LFDKH := if temp_K_char_flag
	     	       	     	then LFDKH
				else extend_K_characters(x, lambda, Lvd, LFDKH, one_ht, pol_hash_one_ht)
				fi
	     then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	     { then () = prints("at one_ht, #eq = ", #eq) }
	     then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts then is_unitary_to_hts(p, hts[1:ONE+1])
	 	  else is_unitary_to_ht(p,one_ht)
	 {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
	 	  fi
	     in local_testK_hash(x,lambda,Lvd, LFDKH, eq,
		       	gr, CLBF, tester1, Uhash)
				{is_unitary_to_hts(p,hts[1:ONE+1]))}
				{is_unitary_to_ht(p,one_ht)}
	else {get K-type formulas for all vertices and edges}
    	     let LFDKH = if temp_K_char_flag
	     	       	 then localFD_KHash_01(x,lambda,Lvd,pol_hash, LF)
			 else localFD_KHash_01(x, lambda, Lvd, one_ht, pol_hash_one_ht, LF)
			 fi
    	     {now have all local facets of dims 0 and 1.}
 	     {compute graph on facets to dim 1, to one_ht}
    	     then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts then is_unitary_to_hts(p, hts[:ONE+1])
	 	  else is_unitary_to_ht(p,one_ht)
	 	  {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
	 	  fi
    	     then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
	     	  		      	then localGraphK(LFDKH, pol_hash, one_ht)
					else localGraphK(LFDKH)
					fi
    	      {remove from LFDKH all facets failing is_unitary_to_ht(one_ht)}
	     {then () = prints("at one_ht, #eq = ", #eq)}
    	     in local_testK_hash(x,lambda,Lvd, LFDKH, eq,
		      gr, CLBF, tester1, Uhash)
	     fi
    then () = if test_verbose then prints("unitary to ht ",one_ht,
		   	   " facet counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	   fi
{ Have facets to dim 1 unitary to one_ht. Seek to extend list to all higher dims }
    then D = int:1, long_out_temp_flag = long_out_flag
    then () = long_out_flag:=false
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds facets of dim D+1; then does is_unitary_to_ht(one_ht) on
    facets of dim D+1; then adds facets of dim D+2, etc. If there are less than
    D+2 possibly unitary facets of dim D, then none of dim D+1.}
    	      do let () = LFDKH := if temp_K_char_flag
	      	     	  	   then localFD_KHashbt_lookDownGEO(x,lambda,Lvd,
				   	LFDKH,D+1,D+2,pol_hash)
				   else localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   	LFDKH, D+1,D+2, one_ht, pol_hash_one_ht)
				   fi
		    {now top degree in LFDKH is D+1}
		 then ((eq,gr),IUCL,CLBF) = if temp_K_char_flag
		      			    then localGraphK(LFDKH,pol_hash,one_ht)
					    else localGraphK(LFDKH)
					    fi
       	      	 {compute graph on facets to dim D+1}
		 then lowUs = sum(for d:D+1 do #LFDKH[d] od)
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml facet #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  facet_bary(Lvd.list, verts))))
					  in if all(for p in ps
					     	    do Uhash.lookup(p).>= or
					{tester}is_unitary_to_ht(p,one_ht)
	{better to use to_ht because usually p _already_ unitary to one_ht}
						    od)
					     then [LFDKH[D+1][m]]
					     else []
					     fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
                 then () = if test_verbose and
		      	   ((D = rank(x.involution-1)-1)  or
    	      	    	   (#LFDKH < D) or
		    	   (#(LFDKH~[0]) <= D+2))
			   then prints("unitary to ht ",one_ht,
		      	      		   " facet counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	      od
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then () = if test_verbose then { prints("unitary to ht ",one_ht, " facets by dim = ",
       	       	   		      		      unitary_by_dim);}
		prints("number of tests so far = ",unitary_test_counter.use_count())
	      fi
    then () = LFDKH:= if temp_K_char_flag
    	      	      then LFDKH
		      else extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
		      fi
    then start=elapsed_ms()
    then () = long_out_flag := long_out_temp_flag
    then UParams = [Param]:
         if one_ht >=  0
         then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
              then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr,
                   CLBF, Uhash, (Param->bool):(Param p): if prefer_to_hts
		   	 			     	 then Uhash.lookup(p).>= or
							      is_unitary_test(p,hts[ONE+1:])
		   					 else Uhash.lookup(p).>= or
							      is_unitary_test(p,hts[LAST])
							 fi)
    	      {then time = elapsed_ms() - start
    	       then () = if time_verbose
	      	      	then prints("     ", print_time_string(time),
	      		     	    " for UParams calculation ", test_string, new_line) fi}
               in UParams
         else let UParams =
                  for list@d in LFDKH
                  do for v in list
                     do let p = parameter(x,lambda, facet_bary(Lvd.list, v[:d+1]))
		     	then () = for  p1 in monomials(finalize(p))
                      	     	  do Uhash.match(herm_center(p1));
                             	  if deform_flag
			     	  then for q in face_deformed_unitaries_new(p1)
                             	       do Uhash.match(q)
				       od
			     	  fi
                             	  od
			then () = if long_out_flag
		      	     	  then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	       then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				       in ()
			   	  fi
		     	in p
                     od
                  od.##
	      in UParams
	 fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      {then () = if test_verbose then prints("total number of tests = ",
                                        unitary_test_counter.use_count())}
	      fi
   in UParams
   {fi}

{JUST CALCULATE FIRST TWO LEVELS}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    {then LF = [[FacetVertsIndex]]: [for k:#Lvd.list do [k] od] {0-facets only}}
    then LF = localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets) {impose Dirac}
    in local_test_GEO_hash_one_level(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    [[FacetVertsIndex]] global_facets) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = [[FacetVertsIndex]]: localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    in local_test_GEO_hash_one_level(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, VertexData vd,
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then ELs = edge_list_lookups(G)
    then () = adjust_global_top(G)
    then () = if #global_facets = 0 or #global_facets[0] != #vd.list
    then global_facets := low_FPP_facets(G)
	      fi
    then (Lvd, Perm2, mapAct) = localFD_Lvd2(x, lambda, vd, ELs)
    then LF = localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_one_level(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_one_level(KGBElt x, ratvec lambda) = [Param]:
    let G = x.real_form
    then Uhash = make_Param_hash(), pol_hash = make_KTypePol_hash(), vd = FPP_vertex_data(G)
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_one_level(x,lambda,vd, pol_hash, Uhash)

{when LKT length is GREATER than bottom_length_frac*(max possible), DO
NOT use bottom_layer. Leaving this at 1 means always use bottom_layer,
to negative means never bottom layer.}
set bottom_length_frac = rat: 1{??}

{if true, use coh_ind_is_unitary in final tests; else is_unitary} 
set coh_ind_tester_flag = true
{how many levels of bottom layer K-types to use}
{this now has no effect; essentially hard coded in min_L_bottom_factors, in
argument of next_heights}
{set BL_steps = int:2}

{assume local facets to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht.}

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, VertexData vd,
    VertexData Lvd, [[FacetVertsIndex]] LF,  steady_bottom_data bott_data,
    	       KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms(),
    	ht = height(parameter(x,lambda,0*lambda))
    then () = if ht = 0 {fine K-type in quasisplit G}
    	      then return local_test_GEO_hash_one_level(x, lambda, vd, Lvd, LF,
	      	   	  				   pol_hash, Uhash)
	      fi
    then htFrac = ht/(G.rho * G.two_rho_check)
    then temp_K_char_flag= htFrac > CUTOFF
    then vertexDiff = #Lvd.list/#vd.list
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then r = rank(thetaMinus)
    then () = revert_flag:=false
    then maxDiffLoc = max_loc(for w in LF[0]
    	 	       	      do G.two_rho_check*(dominant(G,thetaMinus*Lvd.list[w[0]]))
		       	      od)
    then pmax = parameter(x, lambda, Lvd.list[LF[0][maxDiffLoc][0]])
    then (Q,pmaxL) = theta_stable_quasi_data(pmax)
    then L = Q.Levi
    then () = if is_abelian(L)
    	      then let () = Uhash.match(first_param(finalize(pmax)))
	      	   in return [pmax]
	      fi
    then () = if height(pmax) > bottom_length_frac* (G.two_rho * G.rho_check)
    	 then return local_test_GEO_hash_one_level(x, lambda, vd, Lvd, LF,
	      	   	  				   pol_hash, Uhash)
	 fi
    then startLKdatas = elapsed_ms()
    then LKdatas  = for mu in LKTs(pmax)
    	 	   do
		   bott_data.entry(mu)
		   od
    then () = if time_verbose then prints("time for LKdatas was ",
    	      	 print_time_string(elapsed_ms() - startLKdatas), " at lambda = ",lambda)
	      fi
    then NLKT = #LKdatas
    then () = if L = G or
	         sum(for i:NLKT
    	      	     do sum( for list in LKdatas[i] do #list od)
		     od)= NLKT
    	      then return local_test_GEO_hash_one_level(x, lambda, vd, Lvd, LF,
	      	   	  				   pol_hash, Uhash)
	      fi
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test(pmax, bott_data, Uhash)
	      fi
    then pmaxjs = factor_params(pmaxL)
    then qhts = max(for i:NLKT
    	      	    do max( for pairs in LKdatas[i]
    	      	       	    do max( for (tau,) in pairs do height(tau) od)
		       	    od)
		    od)
	{this is the greates height at which we'll be looking at bottom layer K-types; so we can
	compute K-chars just to this height}
    then () = test_string:= " using local_test_GEO_hash_bottom_layer"
    then  () = hash_bottom_layerCounter.use()
    then one_ht = qhts
    then () =  if test_verbose then prints("facet counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing height = ", qhts, new_line)
	       fi
   then pol_hash_one_ht = KTypePol_hash:
   	if temp_K_char_flag
	then pol_hash
	else make_KTypePol_hash() {to hold K_chars to height one_ht}
	fi
      {next add K-chars to height one_ht for vertices and edges}
   then LFDKH = [[FacetVertsKHash]]:
   	if temp_K_char_flag
	then localFD_KHash_01(x,lambda, Lvd, pol_hash, LF)
	else localFD_KHash_01(x, lambda, Lvd, one_ht, pol_hash_one_ht, LF)
	fi
   then ((eq,gr),IUCL,CLBF) =
   	if temp_K_char_flag
	then localGraphK(LFDKH, pol_hash, one_ht)
	else localGraphK(LFDKH)
	fi
   {then () = prints(((eq,gr), IUCL,CLBF))}
    	{next remove from LFDKH all facets failing min_bottom_factors_elim(one_ht)}
   then () = LFDKH := local_testK_hash_bottom_layer(x,lambda,Lvd, LFDKH, eq,
		      gr, CLBF, bott_data, one_ht, pol_hash_one_ht,  Uhash)
   then () = if test_verbose then prints("unitary on bottom layer to ",one_ht,
		   	   " facet counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	   fi
{ Have facets to dim 1 bottom layer unitary to one_ht. Seek to extend list to all higher dims }
    then D = int:1, long_out_temp_flag = long_out_flag
    then () = long_out_flag:=false
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds facets of dim D+1; then does is_unitary_to_ht(one_ht) on
    facets of dim D+1; then adds facets of dim D+2, etc. If there are less than
    D+2 possibly unitary facets of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2, one_ht, pol_hash_one_ht)
		    {now top degree in LFDKH is D+1}
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on facets to dim D+1}
		 then lowUs = sum(for d:D+1 do #LFDKH[d] od)
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml facet #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  facet_bary(Lvd.list, verts))))
			      in if #ps = 1
			      	 then if Uhash.lookup(ps[0]).>= or
                             	      	 min_bottom_elim_factors(ps[0], bott_data,
					 	pol_hash_one_ht.index(LFDKH[D+1][m][D+2]))
				      then [LFDKH[D+1][m]]
				      else []
				      fi
				 else if all(for p in ps
					     	    do Uhash.lookup(p).>= or
						       min_bottom_elim_factors(p, bott_data)
						    od)
				      then [LFDKH[D+1][m]]
				      else []
				      fi
			  	 fi
			   fi
		        od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
                 then () = if test_verbose and
		      	   ((D = rank(x.involution-1)-1)  or
    	      	    	   (#LFDKH < D) or
		    	   (#(LFDKH~[0]) <= D+2))
			   then prints("unitary on bottom layer to ",one_ht,
		      	      		   " facet counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	      od
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then () = if test_verbose then { prints("bottom layer unitary to ",one_ht, " facets by dim = ",
       	       	   		      		      unitary_by_dim);}
		prints("number of tests so far = ",unitary_test_counter.use_count())
	      fi
    then () = LFDKH:= if temp_K_char_flag
    	      	      then LFDKH
    	      	      else extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
		      fi
    then start=elapsed_ms()
    { then () = long_out_flag := long_out_temp_flag }
    then tester = (Param->bool): (Param p) bool:
	      if coh_ind_tester_flag
	      then coh_ind_is_unitary(p)
	      else is_unitary(p)
	      fi
    then UParams = [Param]:
         let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH) {next line: use tester}
         in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash, tester)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      fi
   in UParams

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, VertexData vd,
    VertexData Lvd, [[FacetVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let p = parameter(x, lambda, 0*lambda)
    then bott_data = make_steady_bottom_data()
    then () = for mu in LKTs(p)
    	      do bott_data.append(mu)
	      od
    in local_test_GEO_hash_bottom_layer(x, lambda, vd, Lvd, LF, bott_data,  pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    {then LF = [[FacetVertsIndex]]: [for k:#Lvd.list do [k] od] {0-facets only}}
    then LF = localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct, global_facets) {impose Dirac}
    in local_test_GEO_hash_bottom_layer(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    [[FacetVertsIndex]] global_facets) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = [[FacetVertsIndex]]: localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    in local_test_GEO_hash_bottom_layer(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, VertexData vd,
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then ELs = edge_list_lookups(G)
    then () = adjust_global_top(G)
    then () = if #global_facets = 0 or #global_facets[0] != #vd.list
    then global_facets := low_FPP_facets(G)
	      fi
    then (Lvd, Perm2, mapAct) = localFD_Lvd2(x, lambda, vd, ELs)
    then LF = localFD_1Dirac2(x,lambda, Lvd, Perm2, mapAct, global_facets)
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_one_level(x, lambda, vd, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_bottom_layer(KGBElt x, ratvec lambda) = [Param]:
    let G = x.real_form
    then Uhash = make_Param_hash(), pol_hash = make_KTypePol_hash(), vd = FPP_vertex_data(G)
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_bottom_layer(x,lambda,vd, pol_hash, Uhash)

{set local_facets(KGBElt x, ratvec lambda) = [[vec]]:
    let G = x.real_form
    then (Affd,,) = cofolded(G), vd = FPP_vertex_data(G)
    then (vd, Lvd, Perm, mapAct, LF) = localFD_000(x,lambda,vd)
    in localFD_bt(x,lambda,vd, Lvd, Perm, mapAct, LF,1,rank(x.involution-1)+2)}

{set spherical_facets(RealForm G) = local_facets(x_open(G), G.rho)}

set spherical_general(RealForm G, (KGBElt, ratvec->[Param]) local) = [Param]:
    let start = elapsed_ms()
    then r = rank(x_open(G).involution - 1)
    then answer = local(x_open(G), G.rho)
    then () =  {if time_verbose
    	       then} prints("Total time ", print_time_string(elapsed_ms() -start)) {fi}
    then () = if long_out_flag
    	      then prints("unitary facets by dim = ", for j:r+1 do #LFDKHByDim[j] od,
    	      	   		   	     	   test_string)
	      fi
    then () = if long_out_flag
    	      then prints("number of distinct K-characters = ",NumKchars())
	      fi
    in answer

{this gives def_dumb if def_flag = true}
set spherical_dumb(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO_dumb@(KGBElt, ratvec))

set spherical_def_dumb(RealForm G) = [Param]:
    let () = def_flag:=true
    in spherical_general(G, local_test_GEO_dumb@(KGBElt, ratvec))

set spherical(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO@(KGBElt, ratvec))

set spherical2(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO2@(KGBElt, ratvec))

set spherical_one_level(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO_one_level@(KGBElt, ratvec))
