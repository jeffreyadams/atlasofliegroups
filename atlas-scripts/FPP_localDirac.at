<FPP_faces_herm
<simple_factors { for simple_factors }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]), no_reps}
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<unity.at { for is_unitary_test }
<bottom_layer.at {for bottom layer unitarity tests}
<springer_tables_reductive.at {for Springer_table }
<associated_variety_annihilator.at { for GK_dim, used in identifying unipotent reps }
<weak_packets.at {for unipotent_representations}
<derived_cover.at {for sc_descends}
<cohIndUnip.at {for is_FPP}
<up_mu.at {for up_mu_hash}
{ <lietypes.at { for simple_type }}
{ <parabolics.at {for parabolic_by_wt}}
<K_highest_weights.at {for all_lambda_differential_zero}
<lattice.at {for vec_solve}
{ <chopping_faces_fast.at {for chop_coroots(G, vertices)}}
<face_classes.at {for ordering on faces}
<hash.at {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<translate {for translate_param_by}
<time {for print_string}
{<powerTwo.at} {for fast raising to powers of two using make_power_function }
{This is meant to be functions for computing all unitary reps with
fixed LKT (x,lambda) and infl char in the FPP. Functions are meant to
use a Param_has Uhash containing a list of known unitary reps (like
Arthur's special unipotent ones) in order to avoid doing difficult
is_unitary calculations.

Throughout, the VertexData vd is meant to be the list of all vertices
in the FPP (that are fixed by the distinguished involution), and a
lookup function.

Attached to theta = x.involution and dlambda are

Perm = vec (size = number of vertices of FPP)
{mapAct = vec (size = number of vertices of FPP)}
Lvd = VertexData (vertex infinitesimal chars v in the FPP of Params
      		 (x, lambda v))

Here Perm is a partially defined permutation of order two of (indices
for) vd.list: it can happen that

- Perm[i] = i (fixed vertex v_i, so (x,lambda,v_i) is a Param of infl char
v_i); or

- Perm[j] = k != j, and Perm[k] = j, so (x,lambda, (v_j+v_k)/2) is a Param
  of infl char (v_j + v_k)/2; or

- Perm[ell] = -1, in which case v_ell has nothing to do with FPP Params
  at (x,lambda)

Say there are P fixed i and Q pairs (j,k). Then Lvd.list is the P+Q
vertices v_i and (v_j+v_k)/2, numbered in some way (probably not
reasonable).

{mapAct is a partially defined map from the indices for vd.list to the
indices for Lvd.list.

If Perm[i] = i, then mapAct[i] = index of v_i in Lvd.list

If Perm[j] = k != j, then mapAct[j] = mapAct[k] = mapAct[j] =
number of (v_j+v_k)/2 in Lvd.list

For other ell, mapAct[ell] = -1.}

Suppose (a_0,...,a_d) are the vertex numbers (indices in vd.list) of a d-diml face of the
FPP. Then this face meets FPP Params at (x,lambda) if and only if
(a_0,...,a_d) consists of p entries with Perm[a_i] = a_i and 2q
entries (a_j, a_k) exchanged by Perm (and no -1 entries). In this case
our face meets the FPP infl chars in a face of dimension p+q-1, with
vertices the fixed a_i and the various (a_j+a_k)/2.

The function localFD_Lvd(x, lambda, vd) computes (Lvd, Perm{, mapAct}).

Each d-dimensional (local) face at (x,lambda) is referred to by the
vec of its d+1 indices in Lvd.list. Appended to the end of this vec is
a single integer giving the location of the K_character of the local
face in a KTypePol_hash pol_hash.

There are four main functions, each taking either a long argument

(x, lambda, vd, LVD, Perm{, mapAct}, pol_hash, Uhash)

if you already have these in hand, or a short argument

(x, lambda, Uhash).

Functions each produce a list of all Params (x, lambda, nu_j), each
the barycenter of its local face, each having weakly dominant
infinitesimal character in the FPP (but possibly not final), and each
having all Langlands quotients unitary. These unitary reps are also
added to Uhash.

Here is a description of the four algorithms between these.

*******************
local_test_GEO_hash_dumb

This finds all vertices, then all edges, and computes the graph; then
removes all nonunitary vertices and edges.

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[D] faces; then makes a directed graph, and
eliminates all nonunitary faces.

The version def_dumb (invoked by def_flag = true, which is the
default) does unitarity tests using is_unitary_def_test.
*******************
local_test_GEO_hash
This finds all unitary-to-hts[0] vertices, then all unitary-to-hts[0]
edges.

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[D] faces; then makes a directed graph, and
eliminates all faces failing is-unitary-to-hts[D].

Now it has all faces of all dimensions passing is-unitary-to-hts[top
dim -1]. From these it makes a graph, and computes is_unitary.
*******************
local_test_GEO_hash2

Finds ALL vertices, then ALL edges; then makes a graph, and discards
all vertices and edges failing is_unitary_to_hts[0].

Rest is same as local_test_GEO_hash. This version seems faster because
use of the graph up to dimension 1 reduces the number of
is_unitary_to_hts[0] tests.
********************
local_test_GEO_hash_one_level

Assesses the "difficulty" of this case. If it's relatively easy,
reverts to local_test_GEO_hash2. Otherwise...

Finds ALL vertices, then ALL edges; then makes a graph, and discards
all vertices and edges failing is_unitary_to_hts[0, 1, ... ,
one_level].

For each face dimension D+1 after that, it finds all D+1-diml faces
having unitary-to-hts[one_level] faces; then makes a directed graph, and
eliminates all D+!-diml faces failing is-unitary-to-hts[one_level].

Now it has all faces of all dimensions passing
is-unitary-to-hts[one_level]. From these it makes a graph, and
computes is_unitary using is_unitary_test([one_level+1,...,last_level])
}

{given a sequence hts of hts to test, is_unitary_to_ht(p, hts~[0]) and
is_unitary_to_hts(p, hts) give the same result. If true, prefer using
the second. This seeks to eliminate easy cases by is_unitary_to_ht(p,
hts[0]) before trying the difficult is_unitary_to_ht(p,hts~[0])}
set prefer_to_hts = true

{. If "true," then calculations of unitary reps of a certain LKT
compute also the unitary deformations of these, with bigger
LKT's. This is unimportant for calculating say the spherical FPP
unitary dual, but very helpful with the FULL FPP unitary
dual. Therefore the functions FPP_unitary_hash... set this flag to
"true".}
set deform_flag = false

{. If "true," then some local FPP calculations revert to simpler (?)
   forms in "simple" cases.}
set revert_flag = false {true}

{If "false", use the old version of one_level, in which vertex/edge calcs
are done immediately to ONE_HT}
set step_flag = false

{If "true", then hash_dumb uses real_dumb, which does less to_ht}
set real_flag = false

{If "true", then hash_dumb uses is_unitary_def_test, and hts are calculated with deform_hts}
set def_flag = false {true}

{if "false" use next_heights instead of short_hts, to avoid calculating
deform (KL calculations). So prefer false for rank \ge 7?}
set short_hts_flag = false

{For (x,lambda) such that to_ht rarely helps, this will be set to false}
{set to_ht_flag = true}

{whether to reverse each face list LFDKH[d] before is_unitary tests}
{maybe this effect is achieved by C~[0]?}
set one_two_reverse_flag = true

{prefer to use function is_unitary_test_big_simple_interrupt}
set test_interrupt_flag = true

set long_out_flag = false

{If true, use bottom_layer_interrupted}
set bl_interrupt_flag = false

{If true, use bottom_layer_stepped}
set bl_step_flag = false

{number of different shifts to try in bl_interrupt and bl_step}
set bl_step_count = 2

{how much to increase the shift at each step}
set bl_step_size = 5

{almost always it makes sense to preload the Arthur unipotent
reps. But not in a few test situations.}
set unip_flag = true

{if true, then more_bottom has already been applied where we are}
set more_after_flag = false

{if true, then min_bottom has already been applied where we are}
set min_after_flag = false

{lowest level (index in hts[]) to start testing}
{1 gives small improvement over 2 in E6; haven't tested bigger G}
set edge_offset = int: 2

{how much to increase index in hts[] for testing at various levels} 
{1 improves E6_s and E6_q time by almost 10% }
set edge_skip = int: 1

set difficulty(Param p) = rat:
    let rA = HTA(p)
    in if rA=0 then 0
       else rA/HT(p.real_form,p.infinitesimal_character)
       fi

{Integer between 0 and 100; integer part of 100*difficulty}
set approxDiff(Param p) = int:
    let q = difficulty(p)
    in (q.numer *100)\q.denom

{rational number, between 0 and 1 on FPP: how nu compares to rho in HT.
0 means tempered}
set difficultyA(Param p) = rat:
    let rA = HTA(p), G = p.real_form
    in rA/((G.rho)*(G.two_rho_check))

{Nonneg integer between 0 and 100; integer part of 100*difficultyA}
set approxDiffA(Param p) = int:
    let q = difficultyA(p)
    in (q.numer *100)\q.denom

{rational for increasing (stretcher > 1) or decreasing (stretcher < 1) the number of to_ht tests}
{set stretcher = rat: 1/1}

{meant to store bottom layer K-types}
set bl_KHash = make_KType_hash()

{ Block of p, including zero parameters. Relevant because that's where
KL calculations need to happen }
set full_block(Param p) = [Param]:
let G = p.real_form
in for q in block_of(translate_param_by(p, G.two_rho))
   do translate_param_by(q, -G.two_rho)
   od
{in is_unitary_to_ht(N), KL calculations live in this subset of
full_block}
set full_block_to_ht(Param p, int N) = [Param]:
    for q in full_block(p)
    do if height(q) <= N then [q] else [] fi od.##

set ht_saving(Param p, int N) = rat:
    #full_block_to_ht(p,N)/#full_block(p)

{ between 0 and 100. SMALL means is_unitary_to_ht is likely to be
faster than is_unitary.

If N \ge height(p), then full_block_to_ht(p) always includes p; so

0 < ht_saving(p,N) \le 1.

Therefore 0 \le approx_ht_saving(p,N) \le 100}
set approx_ht_saving(Param p, int N) = int:
    let rp = reducibility_points(p)
    then result = int:
    	 if #rp = 0 then 0
	 else let r = ht_saving(p*rp~[0],N)
    	      in (r.numer *100)\r.denom
	 fi
    in result

set pMAX = parameter(GL(1,R),0,[0]/1,[0]/1)
set pmax(KGBElt x, ratvec lambda, LocalVertexData Lvd) = Param:
    if pMAX.x = x and pMAX.lambda = lambda then return pMAX fi;
    let G = x.real_form
    {then thetaMinus = x.involution - 1}{, BF = invariant_form(G)}
    then tworc = G.two_rho_check
    then max_loc = max_loc(for v in Lvd.list
    		  	   do tworc*v
			   {G.two_rho_check*dominant(G, thetaMinus*v)}
			   od)
    then () = pMAX :=parameter(x,lambda, Lvd.list[max_loc])
    in pMAX

set pmax(KGBElt x, ratvec lambda) = Param:
    let Lvd = Lvd(x,lambda)
    in pmax(x, lambda, Lvd)

set pMIN = parameter(GL(1,R),0,[0]/1,[0]/1)
set pmin(KGBElt x, ratvec lambda, LocalVertexData Lvd) = Param:
    if pMIN.x = x and pMIN.lambda = lambda then return pMIN fi;
    let G = x.real_form
    {then thetaMinus = x.involution - 1}{, BF = invariant_form(G)}
    then tworc = G.two_rho_check
    then min_loc = min_loc(for v in Lvd.list
    		  	   do tworc*v
			   {G.two_rho_check*dominant(G, thetaMinus*v)}
			   od)
    then () = pMIN :=parameter(x,lambda, Lvd.list[min_loc])
    in pMIN

set pmin(KGBElt x, ratvec lambda) = Param:
    let Lvd = Lvd(x,lambda)
    in pmin(x, lambda, Lvd)


{computes directed graph of local faces. Output GraphData is
[[int]],[[int]] giving equivalence classes and the graph. Next output
[vec]s are IUCL and classListByFace}
{9/25/23: have extra coord in FaceVertsKHash to record # Langlands quotients}
set localGraphK([[FaceVertsKHash]] LFvertsK) = (GraphData, [vec],[vec]):
    {let () = if face_verbose then prints("start to compute face graph K")
    	     fi}
    let start = elapsed_ms()
    then (eq,gr) = GraphData: up_data(LFvertsK)
    {then() = prints("number of graph equivalence classes = ",#eq)}
    then classListByFace = [vec]: class_lists(LFvertsK,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
    then time = elapsed_ms() - start
    { then () = if time_verbose
	      then prints("     ", print_time_string(time),
	           " for localGraphK calculation ") fi }
    in ((eq,gr), IUCL, classListByFace)

{here just require K-characters to match to level}
set localGraphK([[FaceVertsKHash]] FDKH, KTypePol_hash pol_hash, int level) =
    (GraphData, [vec],[vec]):
    let () = if face_verbose then prints(new_line,"start to compute face graph K to level ",
    	     		      	   			  level)
    	     fi
    then start = elapsed_ms()
    then (eq,gr) = GraphData: up_data(FDKH,pol_hash,level)
    {then () = for v in eq do prints(v) od}
    {then() = prints("number of graph equivalence classes to height = ",#eq)}
    then classListByFace = [vec]: class_lists(FDKH,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr)
    { then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   " for localGraphK calculation") fi}
	 in ((eq,gr), IUCL, classListByFace)

{classes have common value of red_count, so same K-character}
set localGraphRed([[FaceVertsIndex]] LF) = ([[int]], [vec]):
    let (eq,gr) = GraphData: K_graph_data(LF)
    then classListByFace = [vec]: class_lists(LF,(eq,gr))
    in (eq, classListByFace)

{classes have common value of red_count, so same K-character}
set localGraphRedLong([[FaceVertsIndex]] LF) = (GraphData, [vec], [vec]):
    let (eq,gr) = GraphData: K_graph_data(LF)
    then classListByFace = [vec]: class_lists(LF,(eq,gr)), IUCL = full_down_classes(eq,gr)
    in ((eq,gr), IUCL, classListByFace)

{classes have common value of red_count, so same K-character}
set localGraphRedMed([[FaceVertsIndex]] LF) = (GraphData, [vec]):
    let (eq,gr) = GraphData: K_graph_data(LF)
    then classListByFace = [vec]: class_lists(LF,(eq,gr))
    in ((eq,gr), classListByFace)

set look_up_vertices ([ratvec] vertices, [int] face)=[ratvec]:
   for n in face do vertices[n] od

set remove_closure ([vec] short,[vec] long) =[vec]:
  ##for v in short
    do if any(for w in long do sorted_is_subset(v,w) od)
       then [] else [v]
       fi
    od

set remove_closure ([[vec]] all, int k) =[[vec]]:
   for level@i in all do if i<k
	       then remove_closure (level,all[k])
	       else level
	       fi od

{returns the collection of unipotent points in list, as coords in list. If (x,lambda)
 has more than one LKT, only keep the unipotent irrs having ALL these LKTs.}
set local_unipotent_classes(KGBElt x, ratvec lambda, VertexData (list,lookup)) = vec:
(   let () = if face_verbose
    	     then prints("start local_unipotent_classes")
	     fi
    then G = x.real_form
    then st = G.dual.Springer_table
    in if not(is_split(G) and (x=x_open(G)) and (lambda = G.rho))
       then for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
      	      in if m0 >= 0 and #finalize(parameter(x,lambda,gamma)) = 1 and
	      	 GK_dim(parameter(x,lambda,gamma)) = dim(st.dual_map(O))/2
		 then [m0]
		 else []
		 fi
	   od.##
	else for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
     	       in if m0 >= 0
	       	  then [m0]
		  else []
		  fi
	   od.##
	fi
)

{inserts special unipotent reps in unitary_hash}
set unipotents_to_hash(RealForm G, Param_hash Uhash) = void:
    if unip_flag
    then for p in unipotent_representations(G) do Uhash.match(p) od
    else ()
    fi

{add only those unipotent reps of Gsc factoring to a quotient G, with M: X*(G1) -->
X*(G) the corr wt inclusion}
set unipotents_to_hash(RealForm G, RealForm Gsc, Param_hash Uhash, mat M) = void:
    if unip_flag
    then for psc in unipotent_representations(Gsc)
    	 do if solve(M,psc.lambda_minus_rho).any
       	    then for  p in sc_descends(psc, G, M)
	    	 do Uhash.match(p)
	    	 od
       	    fi
         od
    else ()
    fi

{assume Gsc --> G corrs to M: X*(G) --> X*(Gsc); assume Usc_hash is
reps of Gsc; put in U_hash those descending to G}
set descend_to_quotient(RealForm G, Param_hash Usc_hash, Param_hash U_hash, mat M) = void:
    for j:Usc_hash.size()
    do let psc = Usc_hash.index(j)
       in if solve(M, psc.lambda_minus_rho).any
       	  then for p in sc_descends(psc, G, M)
	       do U_hash.match(p)
	       od
	  fi
    od

{inserts special unipotent reps in [unitary_hash]; assumed to have one
 for each KGBElt}
set unipotents_to_hashes(RealForm G, [Param_hash] Uhashes) = void:
    if unip_flag
    then for p in unipotent_representations(G)
    	      do let (,xnum) = %p.x
	         in Uhashes[xnum].match(p)
	      od
    else ()
    fi

{whether to fill in statuses for known unitaries in local_testK_hash
and local_test_hash}
{separate flag KUKU_flag in FPP_faces_herm.at controls whether to use known_unitaries
or KU}
set KU_flag = true

{whether to fill in statuses for known unitaries in local_testK_hash*
and local_test_hash}
{true costs about 2% in time for E6_q, but seems to make E7_s faster
by maybe 5%??}
set KNU_flag = true

{count how often nonunitary induction identifies nonunitary rep}
set NU_ind_counter = 0

{count how often unitary induction identifies unitary rep}
set U_ind_counter = 0

{whether to look at ind_cand_params to determine unitarity}
set ICPU_flag = false {true becomes very slow in rk 6}

{whether to look at ind_cand_params to determine nonunitarity}
set ICPNU_flag = false {true becomes very slow in rk 6}

{if true, functions in FPP_global pass through KGB backwards}
set tilde_flag = false

{set this to true to use wiggle tests in know_more mode in local_testK_hash_bottom_layer,
which handles the most cases}
set wiggle_flag0 = false

{if true, just do first LFDKH pass on red_count equiv classes: more is_unitary, but less character formula}
set dry_flag = false

{locations of unsettled points in a string of face statuses}
set q_nums([string] statuses) = [int]:
    for S@k in statuses
    do if S[0] = "?"
       then [k]
       else []
       fi
    od.##

{if the testing in these functions is happening after
more_bottom_layer, then negative results should be recorded in
more_bad_hash.}

{test candidate classes with (new) tester; delete
 from LFVKH faces established to be nonunitary in this way. Output is new
 shorter list of candidate faces. Lvd is LOCAL LocalVertexData}
 {If tester is to_ht, then OK for all eq to be computed to_ht. Trickier for bottom_layer.}
 {called lines 2183...}
set local_testK_hash_old(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, (Param->bool) tester,
    int HT, Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1
    {use Uhash to mark some classes as known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let () = KUKU_flag:=false
	      	   then knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				    then ()=newStatuses:= downdateUclassesB(newStatuses, gr, k, "T")
				    in newStatuses[k] := "T"
	    	 		od
	      		     od
		   in KUKU_flag:=true
	       fi
     then () = if KNU_flag
     	       then let knownNonUnitaries = known_non_unitaries(x, lambda, Lvd, FVKH, HT)
	       in for list@d in knownNonUnitaries
    	      	  do for j in list
	      	     do let k = classListByFace[d][j]
			in newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
			   newStatuses[k] := "F"
	    	     od {j in list}
	      	  od {list@d}
		fi
    {then () = if test_verbose then prints("eq = ",eq); prints("gr = ",gr) fi}
    {then () = if test_verbose then prints("ICPU_flag = ",ICPU_flag,", ICPNU_flag = ",ICPNU_flag) fi}
    then known_true_count = count(for ans in newStatuses do ans[0] = "T" od)
    then known_false_count = count(for ans in newStatuses do ans[0] = "F" od)
    then () = if test_verbose
    	      then prints("     Examining ",NumClasses," classes in local_testK_hash; ",
	      known_true_count," are known unitary, ", known_false_count, " known nonunitary.")
	      fi
      then () =  for k:NumClasses
    	        ~do {assert(#q_nums(newStatuses[k+1:]) = 0);}
		    if fund_face_verbose {and NumClasses > 100} and {removing ~ costs 5% in Spin(4,4)}
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then let unk = #q_nums(newStatuses[:k])
		   	in prints("test undet equiv class #"
	      	   ,k, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests; ",unk," classes still ? at ", print_time_string(elapsed_ms() - start))
	      	   ; printInterval := 2*printInterval
	      	   fi
	      	   ; if newStatuses[k] = "?"
	      	     then let C=eq[k]
		     	  then (d,j) = coords(FVKH,C[0]) {adding ~ here slows Spin(5,4) 8.95->9.35}
			       	       			  {also E6_s 63.5->64.6}
	      	     	  then verts = vec: FVKH[d][j][:d+1]
			  {then () = if wiggle_flag and nu_wiggle(x,lambda,verts,Lvd,HT)
				    then result = any(for q in qs do not is_unitary_to_ht_big_SIMPLE(q,}
		     	  then gamma = face_bary(Lvd,verts)
		     	  then pC = parameter(x, lambda, gamma)
	      	     	  then ps = monomials(pC)
		     {then () = prints(new_line,"k = ",k,", ICPNU_flag = ",ICPNU_flag,", ICPU_flag = ",ICPU_flag)
		     then () = prints("before ICPNU, newStatuses = ",newStatuses)}
		     {some test for known non-unitary??}
		     {then () = prints("before ICPU, newStatuses = ",newStatuses)}
		     	  then () = if ICPU_flag {test for unitary}
		       	       	    then if all(for p in ps
		       	       	    	    	do #ind_cand_params(p) > 0
					      	   and all(for pi in ind_cand_params(p)
				      	       	       	   do is_unitary_hash_big_SIMPLE(pi)
					       	       	   od)
				   	        od)
		       	     	     	 then newStatuses[k] := "T";
				     	  U_ind_counter+:=1{;
			     	  prints("Khash ICP T: ",parameter(x,lambda,face_bary(Lvd,verts)))}
			     	          fi {all for p}
		       		    fi {ICPU_flag}
		     {then () = prints("before NEWU, newStatuses = ",newStatuses)}
	             in if{NEWU} newStatuses[k] = "?"
		     	      then if ps[0].nu.= or all(for p in ps do Uhash.lookup(p).>= or
			     		    tester(p) od)
		     	     	   then newStatuses[k]:= "T"
		     	     	   else newStatuses:= updateNUclassesB(newStatuses, gr, k)
			     	{; prints("tested F at class ",k)}
		     	     	{; prints("number false = ",count(for S in newStatuses do S[0] = "F" od))}
				   	; newStatuses[k] := "F"
			     	    fi {ps[0].nu}
		     	 fi{NEWU}
		      fi {newStatuses[k] = "?"}
		    ; if let kopp = NumClasses - k - 1 in (kopp%8).= and kopp < 8*k
		      then let K = (NumClasses - k - 1)\8 {K runs from 0 more slowly}
		      	   {then () = assert(#q_nums(newStatuses[:K]) = 0)}
		      	   then () = if fund_face_verbose and (K%(max(printInterval\16,1))).=
	      	   	   	     then let unk = #q_nums(newStatuses[K:k])
		   		     	  in prints("test undet equiv class #",K,
					     "; so far ",unitary_test_counter.use_count(),
	      	   			     " 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
	      	   		     fi {fund_faca_verbose}
		      	   then () = if newStatuses[K][0] = "?" {NEWU}
	      	     	   	     then let C=eq[K]
		     	  	     then (d,j) = coords(FVKH,C[0]) {adding tilde increases time slightly}
	      	     	  	     then verts = vec: FVKH[d][j][:d+1]
		     	  	     then gamma = face_bary(Lvd,verts)
		     	  	     then pC = parameter(x, lambda, gamma)
	      	     	  	     then ps = monomials(finalize(pC))
		          {then () = prints(new_line,"K = ",K,", ICPNU_flag = ",ICPNU_flag,",
			  	ICPU_flag = ",ICPU_flag)
		     	   then () = prints("before ICPNU, newStatuses = ",newStatuses)}
		     	   	     then () = if newStatuses[K] = "?" and ICPU_flag {test for unitary}
		       	       	     then if all(for p in ps
		       	       	    	     	 do all(for pi in ind_cand_params(p)
				      	       	    	do is_unitary_hash_big_SIMPLE(pi)
					       	  	od)
				   	   	od)
		       	     	     	  then newStatuses:= downdateUclassesB(newStatuses, gr, K, "T");
				     	     	  U_ind_counter+:=1;
			     	  {prints("Khash ICP F: ",parameter(x,lambda,face_bary(Lvd,verts)));}
			     	  	  	 newStatuses[K] := "T"
			     	    	  fi {all for p in ps}
		       		               fi {ICPU_flag}
		     {then () = prints("before NEWU, newStatuses = ",newStatuses)}
	             in if{NEWU} newStatuses[K] = "?"
		     	then if ps[0].nu.= or all(for p in ps do Uhash.lookup(p).>= or
			     		    tester(p) od)
		     	     then downdateUclassesB(newStatuses, gr, K, "T");
			     	  newStatuses[K]:= "T"
		     	     else {newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
			     	{; prints("tested F at class ",k)}
		     	     	{; prints("number false = ",count(for S in newStatuses do S[0] = "F" od))}
				;} newStatuses[K] := "F"
			     fi {all for p in ps}
		     	fi{NEWU}
		 fi {newStatuses[K] = "?"}
		      	   in ()
		      fi {(kopp%8).=)}
	      od
     {then () = prints("after first loop, newStatuses = ",newStatuses)}
     then () = if test_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq
	       	    do if newStatuses[m][0] = "T"
     	     	       then {for k in C
		       	    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od}
			    for k in C
			    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od
		       fi {newStatuses[m][0] = "T"}
		    od
     {then () = if #FVKH = 3 then prints(FVKHnew[2]) fi}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

set old_local_testK_flag = false {old has pref_bottom = 8}
set pref_bottom = int: 64

{test candidate classes with (new) tester; delete
 from LFVKH faces established to be nonunitary in this way. Output is new
 shorter list of candidate faces. Lvd is LOCAL LocalVertexData}
 {If tester is to_ht, then OK for all eq to be computed to_ht. Trickier for bottom_layer.}
 {called lines 2183...}
 {every pref_bottom steps from bottom (vertices), do 1 from top (big faces)}
set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, (Param->bool) tester,
    int HT, Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    if old_local_testK_flag
    then return local_testK_hash_old(x, lambda, Lvd, FVKH, eq, gr, classListByFace, tester, HT,
    	 	Uhash, fancy_tester)
    fi;
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1
    {use Uhash to mark some classes as known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let () = KUKU_flag:=false
	      	   then knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				    then ()=newStatuses:= downdateUclassesB(newStatuses, gr, k, "T")
				    in newStatuses[k] := "T"
	    	 		od
	      		     od
		   in KUKU_flag:=true
	       fi
     then () = if KNU_flag
     	       then let knownNonUnitaries = known_non_unitaries(x, lambda, Lvd, FVKH, HT)
	       in for list@d in knownNonUnitaries
    	      	  do for j in list
	      	     do let k = classListByFace[d][j]
			in newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
			   newStatuses[k] := "F"
	    	     od {j in list}
	      	  od {list@d}
		fi
    {then () = if test_verbose then prints("eq = ",eq); prints("gr = ",gr) fi}
    {then () = if test_verbose then prints("ICPU_flag = ",ICPU_flag,", ICPNU_flag = ",ICPNU_flag) fi}
    then known_true_count = count(for ans in newStatuses do ans[0] = "T" od)
    then known_false_count = count(for ans in newStatuses do ans[0] = "F" od)
    then () = if test_verbose
    	      then prints("     Examining ",NumClasses," classes in local_testK_hash; ",
	      known_true_count," are known unitary, ", known_false_count, " known nonunitary.")
	      fi
      then () =  for k:NumClasses
    	        ~do {assert(#q_nums(newStatuses[k+1:]) = 0);}
		    {if fund_face_verbose {and NumClasses > 100} and {removing ~ costs 5% in Spin(4,4)}
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then let unk = #q_nums(newStatuses[:k])
		   	in prints("test undet equiv class #"
	      	   ,k, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests; ",unk," classes still ? at ", print_time_string(elapsed_ms() - start))
	      	   ; printInterval := 2*printInterval
	      	   fi
	      	   ;}if{NEWUk} newStatuses[k] = "?"
	      	     then let C=eq[k]
		     	  then (d,j) = coords(FVKH,C[0]) {adding ~ here slows Spin(5,4) 8.95->9.35}
			       	       			  {also E6_s 63.5->64.6}
	      	     	  then verts = vec: FVKH[d][j][:d+1]
			  {then () = if wiggle_flag and nu_wiggle(x,lambda,verts,Lvd,HT)
				    then result = any(for q in qs do not is_unitary_to_ht_big_SIMPLE(q,}
		     	  then gamma = face_bary(Lvd,verts)
		     	  then pC = parameter(x, lambda, gamma)
	      	     	  then ps = monomials(pC)
		     {then () = prints(new_line,"k = ",k,", ICPNU_flag = ",ICPNU_flag,", ICPU_flag = ",ICPU_flag)
		     then () = prints("before ICPNU, newStatuses = ",newStatuses)}
		     {some test for known non-unitary??}
		     {then () = prints("before ICPU, newStatuses = ",newStatuses)}
		     	  then () = if ICPU_flag {test for unitary}
		       	       	    then if all(for p in ps
		       	       	    	    	do #ind_cand_params(p) > 0
					      	   and all(for pi in ind_cand_params(p)
				      	       	       	   do is_unitary_hash_big_SIMPLE(pi)
					       	       	   od)
				   	        od)
		       	     	     	 then newStatuses[k] := "T";
				     	  U_ind_counter+:=1{;
			     	  prints("Khash ICP T: ",parameter(x,lambda,face_bary(Lvd,verts)))}
			     	          fi {all for p}
		       		    fi {ICPU_flag}
		     		    {then () = prints("before NEWU, newStatuses = ",newStatuses)}
	             	  then () = if{still NEWUk} newStatuses[k] = "?"
		     	       	    then if ps[0].nu.= or all(for p in ps do Uhash.lookup(p).>= or
			     		    tester(p) od)
		     	     	   	 then newStatuses[k]:= "T"
		     	     	   	 else newStatuses:= updateNUclassesB(newStatuses, gr, k)
			     	{; prints("tested F at class ",k)}
		     	     	{; prints("number false = ",count(for S in newStatuses do S[0] = "F" od))}
				   	; newStatuses[k] := "F"
			     	    	fi {ps[0].nu...}
		     	 	     fi{still NEWUk}
			   in ()
		      fi{NEWUk}
		    ; if let kopp = NumClasses - k - 1 in (kopp%pref_bottom).= and kopp < pref_bottom*k
		      then let K = (NumClasses - k - 1)\pref_bottom {K runs from 0}
		      	   {then () = assert(#q_nums(newStatuses[:K]) = 0)}
		      	   then () = if fund_face_verbose and (K%printInterval).=
	      	   	   	     then let unk = #q_nums(newStatuses[K:k])
		   		     	  in prints("test undet equiv class #",K, " and #",k,
					     "; so far ",unitary_test_counter.use_count(),
	      	   			     " 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
					     ; printInterval := 2*printInterval
	      	   		     fi {fund_face_verbose}
		      	   in if newStatuses[K][0] = "?" {NEWUK}
	      	     	   	     then let C=eq[K]
		     	  	     then (d,j) = coords(FVKH,C[0]) {adding tilde increases time slightly}
	      	     	  	     then verts = vec: FVKH[d][j][:d+1]
		     	  	     then gamma = face_bary(Lvd,verts)
		     	  	     then pC = parameter(x, lambda, gamma)
	      	     	  	     then ps = monomials(finalize(pC))
		          {then () = prints(new_line,"K = ",K,", ICPNU_flag = ",ICPNU_flag,",
			  	ICPU_flag = ",ICPU_flag)
		     	   then () = prints("before ICPNU, newStatuses = ",newStatuses)}
		     	   	     then () = if newStatuses[K] = "?" and ICPU_flag {test for unitary}
		       	       	     then if all(for p in ps
		       	       	    	     	 do all(for pi in ind_cand_params(p)
				      	       	    	do is_unitary_hash_big_SIMPLE(pi)
					       	  	od)
				   	   	od)
		       	     	     	  then newStatuses:= downdateUclassesB(newStatuses, gr, K, "T");
				     	     	  U_ind_counter+:=1;
			     	  {prints("Khash ICP F: ",parameter(x,lambda,face_bary(Lvd,verts)));}
			     	  	  	 newStatuses[K] := "T"
			     	    	  fi {all for p in ps}
		       		               fi {ICPU_flag}
		     {then () = prints("before NEWU, newStatuses = ",newStatuses)}
	             in if{still NEWUK} newStatuses[K] = "?"
		     	then if ps[0].nu.= or all(for p in ps do Uhash.lookup(p).>= or
			     		    tester(p) od)
		     	     then downdateUclassesB(newStatuses, gr, K, "T");
			     	  newStatuses[K]:= "T"
		     	     else {newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
			     	{; prints("tested F at class ",k)}
		     	     	{; prints("number false = ",count(for S in newStatuses do S[0] = "F" od))}
				;} newStatuses[K] := "F"
			     fi {all for p in ps}
		     	fi{still NEWUK}
		 fi {NEWUK}
	      fi {(kopp<k}
	      od
     {then () = prints("after first loop, newStatuses = ",newStatuses)}
     then () = if test_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq
	       	    do if newStatuses[m][0] = "T"
     	     	       then {for k in C
		       	    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od}
			    for k in C
			    do let (d,j) = coords(FVKH,k)
			       in FVKHnew[d] #:= FVKH[d][j]
			    od
		       fi {newStatuses[m][0] = "T"}
		    od
     {then () = if #FVKH = 3 then prints(FVKHnew[2]) fi}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew




set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, (Param->bool) tester,
    int HT, Param_hash Uhash) = [[FaceVertsKHash]]:
    local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, tester, HT, Uhash,
    is_unitary_hash_big_SIMPLE@Param)

set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, int ht,
    Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let tester = ((Param->bool): (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, ht))
     in local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, tester,
     ht, Uhash, fancy_tester)

set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, int ht,
    Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let tester = ((Param->bool): (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, ht))
     in local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, tester, ht, Uhash,
     fancy_tester)

set local_testK_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    int ht, Param_hash Uhash) = [[FaceVertsKHash]]:
    let tester = ((Param->bool): (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, ht))
     in local_testK_hash(x, lambda, Lvd, FVKH, eq, gr, classListByFace, tester, ht, Uhash)

{test candidate classes with (new) tester. Assume know_lower_flag is true,
 and use that to get rid of some candidates. Delete
 from LFVKH faces established to be nonunitary in this way. Output is new
 shorter list of candidate faces. Lvd is LOCAL VertexData}
{REQUIRE that tester is decisive: true means unitary}
set local_testK_hash_know_lower(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, (Param->bool) tester,
    Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    	, printInterval = int: 1, G = x.real_form
    {use Uhash to mark some classes as known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let () = KUKU_flag:=false {prevent using Lucas's slow test at this early stage}
	      	   then knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "T"
	    	 		od
	      		     od
		   in KUKU_flag:=true
	       fi
     then () = if KNU_flag
     	       then let knownNonUnitaries = known_non_unitaries(x, lambda, Lvd, FVKH)
	       in for list@d in knownNonUnitaries
    	      	  do for j in list
	      	     do let k = classListByFace[d][j]
			in newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
			   newStatuses[k] := "F"
	    	     od {j in list}
	      	  od {list@d}
		fi
    then known_true_count = count(for ans in newStatuses do ans[0] = "T" od)
    then known_false_count = count(for ans in newStatuses do ans[0] = "F" od)
    then () = if test_verbose {and NumClasses > 100}
    	      then prints(); prints("     Examining ",NumClasses," equiv classes of faces to dim ", #FVKH -1,
	      " in local_testK_hash_know_lower; ", known_true_count, " are known unitary, ",
	      known_false_count, " known nonunitary.")
	      ; prints()
	      fi
    then kup = int: 0
    then () = {if known_true_count < NumClasses/2
   	      then} for k:NumClasses
    	        ~do if fund_face_verbose and {NumClasses > 100 and} {removing ~ costs 5% in Spin(4,4)}
	      	   ((NumClasses - k - 1)%printInterval = 0)
	      	   then let unk = #q_nums(newStatuses[kup:k+1])
		   	in prints("test undet equiv class #"
	      	   ,k, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0])
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then gamma = face_bary(Lvd,verts)
		  then pC = parameter(x, lambda, gamma)
		  {then () = prints("d = ",d,", pC = ",pC)}
	      	  then ps = monomials(pC)
		  then () = if not is_final(pC)
		      	    then if all(for q in ps do @bool: is_finished(q.x, q.lambda) and
			       	       	       	    	     (Uhash.lookup(q) >= 0) od)
			   	 then newStatuses[k] := "T"
			   	 elif any(for q in ps do @bool: is_finished(q.x,q.lambda) and
				    	 (Uhash.lookup(q) = -1) od)
			         then {prints("nonfinal, k = ",k, ", gr = ",gr);}
			   	      newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); "F"
			   	 fi
			     fi {not is_final}
		   then () = if  newStatuses[k] = "?" and ICPNU_flag {test for non-unitary}
		       	    then if any(for p in ps
				    	do any(for pi in ind_cand_params(p)
			    	       	       do not is_unitary_hash_big_SIMPLE(pi)
				       	       od)
				    	od)
		       	          then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
				       NU_ind_counter+:=1;
			          {prints("know_lower ICP F: ",pC);}
			     	       newStatuses[k] := "F"
			         fi {any p}
		       	     fi {ICP_flag}
		   then () = if  newStatuses[k] = "?" and ICPU_flag {test for unitary}
		       	       then if all(for p in ps
		       	       	    	   do #ind_cand_params(p) > 0
					      and all(for pi in ind_cand_params(p)
				      	       	       do is_unitary_hash_big_SIMPLE(pi)
					       	       od)
				   	   od)
		       	     	     then U_ind_counter+:=1;
				     	  newStatuses[k] := "T"
			     	  {prints("know_lower ICP T: ",parameter(x,lambda,face_bary(Lvd,verts)));}
			     	    fi
		       		fi
	          in if newStatuses[k] = "?"
		     	and not is_final(pC) and all(for q in ps
		     	    		     	 do @bool: is_finished(q.x,q.lambda)
						    and Uhash.lookup(q).>=
					    	 od)
		     then newStatuses[k]:="T"
		     elif any(for q in ps
		     	      do @bool: is_finished(q.x,q.lambda)
					    and (Uhash.lookup(q) = -1)
			      od) or
			  any(for q in ps
			      do @bool: big_unitary_hash.nulookup(q).>=
			      od)
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     ; newStatuses[k] := "F"
		     fi;
		     if{NEWU} newStatuses[k] = "?"
		     	then if{all} all(for p in ps do Uhash.lookup(p).>= or tester(p) od)
			     {if p is unitary, tester(p) may record that fact in Uhash}
		     	     then newStatuses[k]:= "T"
		     	     else newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
		     	     ; newStatuses[k] := "F"
		     	     fi{all}
		     fi{NEWU}
	         fi {newStatuses[k] = "?"} {now go from zero up}
		 ; if let kopp = NumClasses - k - 1 in (kopp%8).= and kopp < 8*k
		      then let () = kup := (NumClasses - k - 1)\8 {kup runs from 0 more slowly}
		      	   {then () = assert(#q_nums(newStatuses[:kup]) = 0)}
		      	   then () = if fund_face_verbose and (kup%(max(printInterval\16,1))).=
	      	   	   	     then let unk = #q_nums(newStatuses[kup:k])
		   		     	  in prints("test undet equiv class #",kup,
					     "; so far ",unitary_test_counter.use_count(),
	      	   			     " 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
	      	   		     fi {fund_faca_verbose}
		      	   then () = if newStatuses[kup] = "?"
	      	     	   	     then let C=eq[kup]
		     	  	     then (d,j) = coords(FVKH,C[0])
	      	     	  	     then verts = vec: FVKH[d][j][:d+1]
		     	  	     then gamma = face_bary(Lvd,verts)
		     	  	     then pC = parameter(x, lambda, gamma)
	      	     	  	     then ps = monomials(finalize(pC))

		     	   	     then () = if ICPU_flag {test for unitary}
		       	       	     then if all(for p in ps
		       	       	    	     	 do all(for pi in ind_cand_params(p)
				      	       	    	do is_unitary_hash_big_SIMPLE(pi)
					       	  	od)
				   	   	od)
		       	     	     	  then newStatuses:= downdateUclassesB(newStatuses, gr, kup, "T");
				     	     	  U_ind_counter+:=1;
			     	  {prints("Khash ICP F: ",parameter(x,lambda,face_bary(Lvd,verts)));}
			     	  	  	 newStatuses[kup] := "T"
			     	    	  fi {all for p in ps}
		       		               fi {ICPU_flag}
			             then () =  if newStatuses[kup] = "?" and ICPNU_flag {test for non-unitary}
		       	    	     	     	then if any(for p in ps
				    		     	do any(for pi in ind_cand_params(p)
			    	       	       		       do not is_unitary_hash_big_SIMPLE(pi)
				       	       		       od)
				    			od)
		       	          	             then {newStatuses:= updateNUclassesB(newStatuses, gr, kup, "F");}
				       		     	  NU_ind_counter+:=1;
			          			  {prints("know_lower ICP F: ",pC);}
			     	       			  newStatuses[kup] := "F"
			         		     fi {any p}
		       	     			 fi {ICPNU_flag}
		     {then () = prints("before NEWU, newStatuses = ",newStatuses)}
	             in if{NEWU} newStatuses[kup] = "?"
		     	then if ps[0].nu.= or all(for p in ps do Uhash.lookup(p).>= or
			     		    tester(p) od)
		     	     then downdateUclassesB(newStatuses, gr, kup, "T");
			     	  newStatuses[kup]:= "T"
		     	     else {newStatuses:= updateNUclassesB(newStatuses, gr, k, "F")
			     	{; prints("tested F at class ",k)}
		     	     	{; prints("number false = ",count(for S in newStatuses do S[0] = "F" od))}
				;} newStatuses[kup] := "F"
			     fi
		     	fi{NEWU}
		 fi {newStatuses[kup] = "?"}
		      	   in ()
		      fi {(kopp%8).=)}
	      od
     then () = if test_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi

     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq
	       	    do if newStatuses[m][0] = "T"
     	     	       then for k in C
			    do let (d,j) = coords(FVKH,k)
			       then verts = vec: FVKH[d][j][:d+1]
			       then pC = parameter(x, lambda, face_bary(Lvd, verts))
			       then ps = monomials(pC)
			       then () = for q in ps do Uhash.match(q) od
			       in FVKHnew[d] #:= FVKH[d][j]
			    od
		       fi
		    od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_know_lower; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

{REQUIRE that tester is decisive: true means unitary}
set local_testK_hash_know_lower(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    (Param->bool) tester, Param_hash Uhash) = [[FaceVertsKHash]]:
    local_testK_hash_know_lower(x, lambda, Lvd, FVKH, eq, gr, classListByFace,
    tester, Uhash, is_unitary_hash_big_SIMPLE@Param)

{Delete from LFVKH faces established to be nonunitary using
min_bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  HT is
the largest HT of min_bottom_layer K-types, and FVKH classes
should refer to that HT.

If U_flag = true, then test
for unitarity.}
set local_testK_hash_min_bottom_layer(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, int HT,
    KTypePol_hash pol_hash, Param_hash Uhash, (Param -> bool) fancy_tester) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq
    then printInterval = int: {1} max(1,NumClasses\10), red_shift = if red_count_flag then 1 else 0 fi
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces_herm
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let () = KUKU_flag:=false
	      	   then knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do newStatuses[classListByFace[d][j]] := "T"
	    	 		od
	      		     od
		   in KUKU_flag:=true
	       fi
     then () = if KNU_flag
     	       then let knownNonUnitaries = known_non_unitaries(x, lambda, Lvd, FVKH, HT)
	       in for list@d in knownNonUnitaries
    	      	  do for j in list
	      	     do let k = classListByFace[d][j]
			in newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
			   newStatuses[k] := "F"
	    	     od {j in list}
	      	  od {list@d}
	        fi
{next if possible label classes known to be nonunitary because they finalize or deform to nonunitary}
    then () = for k:NumClasses
    	     ~do if newStatuses[k] = "?"
		 then let C=eq[k] {should run backwards for update to be effective}
		      then (d,j) = coords(FVKH,C~[0]) {d is dimension of face. Tilde picks a largest-dimensional face in C.}
	      	      then verts = vec: FVKH[d][j][:d+1]
		      then gamma = face_bary(Lvd,verts)
		      then ratverts = [ratvec]: for m in verts do Lvd.list[m] od
		      {then sigma = sum(#lambda, ratverts)}
		      then pC = parameter(x, lambda, gamma) {sigma/(d+1))}
		      then pCdef = if not is_final(pC)
		      	   	   then monomials(finalize(pC))
		  		   elif wiggle_flag0 and d > 0
		  		   then {let () = char_counter.use()
				   	then startCF = elapsed_ms()}
				   	let CF = character_formula(finalize(pC))
					{then () = charTime +:= elapsed_ms() - startCF}
		       		   	in  monomials(composition_series((sum(x.real_form,
		       	   		    for j:d+1 {v in ratverts}
			   		    do wiggle(CF, face_bary(Lvd,verts[:j]##verts[j+1:]))
					    {(sigma - v)/d)}
			   		    od)))) {proper_facet_deformed(pCtop)}
		  	           else []
		  		   fi {not is_final pC}
{this function is invoked only on the 0/1 faces in bottom_layer. That's a relatively long list,
      with few wiggles; the cost of computing proper_facet_deformed(pC) seems not justified by
      the few edges eliminated}
		   in if not is_final(pC)
		      then if all(for q in pCdef do @bool: is_finished(q.x, q.lambda) and
			       	       	       	    	     (Uhash.lookup(q) >= 0) od)
			   then newStatuses[k] := "T"
			   elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 (Uhash.lookup(q) = -1) od)
			   then {prints("nonfinal, k = ",k, ", gr = ",gr);}
			   newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); "F"
			   fi
		      else {now pC is final, and pCdef consists of wiggled Params with smaller x}
			  if any(for q in pCdef do @bool:  is_finished(q.x,q.lambda)
				       	       and (Uhash.lookup(q) = -1) od)
			  then {prints("final, k = ",k, ", gr = ",gr);}
			  newStatuses := updateNUclassesB(newStatuses, gr, k,"F");
			       newStatuses[k] := "F"
		           fi {any}
		      fi {not is_final}
		fi {newStatuses[k]}
	      od {k:NumClasses}
    {then () = prints("no test newStatuses = ",newStatuses)}
    then () = if fund_face_verbose {and NumClasses > 100}
    then prints(); prints("start local_testK_hash_min_bottom_layer ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then let unk = #q_nums(newStatuses[:k])
		   	in prints("test undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0]) {a lowest-diml face in C; least likely to be final}
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	  then ps = monomials(finalize(pC))
                  then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	      then true
			      elif not all(for p in ps
		     	  	     	   do @bool: if #ps = 1
					      	     then min_bottom_elim_factors(p,pC,pol_hash.index(FVKH[d][j][d+red_shift+1]))
						     else min_bottom_elim_factors(p,pC)
						     fi
					   od)
				then false
			      else true
			      fi
     		  in if not test
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     else newStatuses[k] := "T"
		     fi
		  fi {newStatuses[k] = "?"}
		  od {NumClasses}
     then () = if test_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi
         {make new local face list using only faces not already proven nonunitary}
    then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
    then () = for C@m in eq
    	      do if not newStatuses[m][0] = "F"
     	     	 then for k in C
		      do let (d,j) = coords(FVKH,k)
		      	 in FVKHnew[d] #:= FVKH[d][j]
		      od
		 fi
	       od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_min_bottom_layer; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

set local_testK_hash_min_bottom_layer(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, int HT,
    KTypePol_hash pol_hash, Param_hash Uhash) = [[FaceVertsKHash]]:
    local_testK_hash_min_bottom_layer(x, lambda, Lvd, FVKH, eq, gr, classListByFace, HT,
    pol_hash, Uhash, is_unitary_hash_big_SIMPLE@Param)

{when the non-minimal parabolics are used at the end, how much above
height(p) to look at K-types.  A larger number finds more nonunitary,
takes longer}
set more_shift_level = int: 0

set more_shift(int n) = void:
    let () = more_flag:=true
    in more_shift_level:=n

{if true, then test for unitarity from beginning of bottom_layer}
{turns out to slow things down a bit: better to construct more
candidates, because they will lead to a graph with fewer components,
so fewer is_unitary tests. For E6_s, U_flag = false needs 833 tests;
U_flag = true needs 1001}
set U_flag = false

{Delete from LFVKH faces established to be nonunitary using
known_lower, bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph.

   IS THAT TRUE?

If U_flag = true, then test
for unitarity. Should be applied only to OUTPUT of local_testK_hash_min_bottom_layer}
{AND Dirac_best; so no need to do Dirac_best again}
set local_testK_hash_bottom_layer_more(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace,
     {[KGPElt] maxQs,} [QKL_bottom_data] datas, KTypePol_hash pol_hash, Param_hash Uhash) =
    			    [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    then printInterval = int: {1}max(NumClasses\10, 1)
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose
    	      then prints(); prints("start local_testK_hash_bottom_layer_more ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose {and NumClasses > 100} and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then let unk = #q_nums(newStatuses[:k])
		   	in prints("test undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count()
	      	   ," 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
	      	   ; printInterval := 2*printInterval
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		     then (d,j) = coords(FVKH,C[0])
		     {C[0] is a lowest-diml face in C}
	      	     then verts = vec: FVKH[d][j][:d+1]
		     then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	     then ps = monomials(finalize(pC))
                     then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	         then true
			      	 elif #ps = 1 {otherwise the K-char is wrong!}{)}
				 then bottom_elim_factors_more(ps[0], pC, datas,
				      pol_hash.index(FVKH[d][j][d+red_shift+1]))
			         else all(for p in ps
				       do @bool: bottom_elim_factors_more(p, pC, datas)
				       od)
			         fi
     		     in if not test
		     	then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     	else newStatuses[k] := "T"
		     	fi
		fi {newStatuses[k] = "?"}
		od {NumClasses}
     {make new local face list using only faces not already proven nonunitary}
     then () = if test_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_bottom_layer_more; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

{Assume datass is built of bottom layer K-types up to Ds[0], enumerated in KHash.
Find first j from 1 where [Ds[j-1],Ds[j]) gives more bottom layer K-types; add those to KHash;
replace Ds by Ds[j:]. }
set add_datas(Param p, KGPElt Qmin, {KType_hash KHash,} [int] Ds) =
    ([QKL_bottom_data], [int]):
    let Es = [Ds~[0]], old_size = bl_KHash.size()
    then answer = [(KGPElt,[(KType,[KType])])]: []
    then () = if #Ds <= 1 then return (answer, Es) fi
    then () = for j:#Ds - 1 from 1
    	      do let datas = if Qs2_flag {[(KGPElt,[(KType,[KType])])]}
	     	      	     then for mu in LKTs(p)
			     	  do if Qs2B_flag
				     then bottom_factors(bottom_K_type_Qs2B(mu,Qmin,height(p),Ds[j]))
				     else for (Q,pL) in max_Qps(p)
				       	  do bottom_K_type_Qs2(mu,Q,height(p),Ds[j])
					  od
				     fi
				  od.##
			     else bottom_factors(bottom_K_type_Qs(p,Qmin,height(p), Ds[j]))
			     fi {Qs2_flag}
		 then new_datas = for (Q,list) in datas
		      		  do (Q, for (tau,local) in list
				     	 do let M = bl_KHash.size()
				     	    in if bl_KHash.match(tau) = M
					       then [(tau,local)]
					       else []
					       fi
				    	 od.##)
				  od
		 in if bl_KHash.size() > old_size {we found some new bottom layer K-types}
       	  	    then Es:= Ds[j:];
		    	 answer:=new_datas;
			 break
		    fi
	     od
    in (answer, Es)

set ktypes([QKL_bottom_data] datas) = [KType]:
    for (Q,list) in datas
    do for (tau,) in list
       do tau
       od
    od.##

set ktypes([[(KType,[KType])]] datas) = [KType]:
    for list in datas
    do for (tau,) in list
       do tau
       od
    od.##

{Delete from LFVKH faces established to be nonunitary using
known_lower, bottom layer, and deformation. Output is new shorter list
of candidate faces. Lvd is LOCAL VertexData.  Use of good range
induction requires using FULL K-chars to define graph. If U_flag = true, then test
for unitarity. Should be applied only to OUTPUT of local_testK_hash_min_bottom_layer}
{Just precompute FIRST datas; later as needed. Ds[0] is height for initial datas}
set local_testK_hash_bottom_layer_more_step(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KGPElt Qmin,
     {[KGPElt] maxQs,} [QKL_bottom_data] datas, [int] Ds{, KTypePol MU}, KTypePol_hash pol_hash,
     Param_hash Uhash, (Param->bool) fancy_tester) = [[FaceVertsKHash]]:
    let newStatuses = for j:#eq do "?" od,  NumClasses = #eq, red_shift = if red_count_flag then 1 else 0 fi
    then printInterval = int: {1}max(NumClasses\10, 1)
    {use Uhash to mark some classes at known? (those that hit a unitary Param)}
    {Find all Param's in Uhash with (x,lambda). For each, compute corresponding Face.
     Use function known_unitaries from FPP_faces
     Look up class in classListByFace, and mark "T"}
    then start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if KU_flag {and #FVKH = 2}
    	      then let () = KUKU_flag:=false
	      	   then knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, FVKH, fancy_tester)
	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				    then ()=newStatuses:= downdateUclassesB(newStatuses, gr, k, "T")
				    in newStatuses[k] := "T"
	    	 		od
	      		     od
		   in KUKU_flag:=true
	       fi
    then (datasNEW, DsNEW) = add_datas(parameter(x,lambda,0*lambda), Qmin, Ds)
    then () = if fund_face_verbose {and NumClasses > 100}
    then prints(); prints("start local_testK_hash_bottom_layer_more_step ", NumClasses,
		   " equiv classes of faces to dim ",#FVKH-1)
	      ; prints()
	      fi
	      ; for k:NumClasses
    	        ~do if fund_face_verbose and NumClasses > 100 and
	      	   ((NumClasses-k-1)%printInterval = 0)
	      	   then let unk = #q_nums(newStatuses[:k])
		   	in prints("test undet equiv class #"
	      	   ,NumClasses-k -1, "; so far ",unitary_test_counter.use_count() - start_count
	      	   ," 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
	      	   {; printInterval := 2*printInterval}
	      	   fi
	      ; if newStatuses[k] = "?"
	      	then let C=eq[k]
		  then (d,j) = coords(FVKH,C[0]) {a lowest-diml face in C; least likely to be final}
	      	  then verts = vec: FVKH[d][j][:d+1]
		  then pC = parameter(x, lambda, face_bary(Lvd, verts))
	      	  then ps = monomials(finalize(pC))
		  {then KHash = make_KType_hash()}
		  then () = for (,Klist) in datas
		       	    do for (tau,) in Klist
			       do bl_KHash.match(tau)
			       od
			    od
		  then testDs = Ds
                  then test = if all(for p in ps do @bool:Uhash.lookup(p).>= od)
		       	      then true
			      elif #ps = 1 {otherwise the K-char is wrong!}{)}
				then let still_here = bottom_elim_factors_more(ps[0], pC,
				     	       		  datas, pol_hash.index(FVKH[d][j][d+red_shift+1]))
				     then () = if still_here
				     	       then still_here := bottom_elim_factors_more(ps[0],pC,datasNEW,
					       	  	     pol_hash.index(FVKH[d][j][d+red_shift+1]))
					       fi
				     in still_here
			        else let still_here = all(for p in ps
				       	      	    do bottom_elim_factors_more(p, pC, datas)
				       		    od)
				     then () = if still_here
				   	      then still_here := all(for p in ps
							     do @bool: bottom_elim_factors_more(p, pC, datas)
							     od)
					      fi
				    in still_here
			         fi
     		  in if not test
		     then newStatuses:= updateNUclassesB(newStatuses, gr, k,"F"); newStatuses[k] := "F"
		     else newStatuses[k] := "T"
		     fi
		  fi {newStatuses[k] = "?"}
		  od {NumClasses}
     then () = if test_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary candidates.")
	       fi
     {make new local face list using only faces not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FaceVertsKHash]: [] od
          then () = for C@m in eq do if not newStatuses[m][0] = "F"
     	     	     	      	     then for k in C
			      	     	  do let (d,j) = coords(FVKH,k)
				      	     in FVKHnew[d] #:= FVKH[d][j]
				   	  od
			             fi
			      	  od
     then time = elapsed_ms() - start
     then () = if #Ds > 1 and fund_face_verbose
     	       then prints("at x = ",x.number,", lambda = ",lambda,"# datas = ",#datas,", #Ds = ",#Ds)
	       fi
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  	       " for local_testK_hash_bottom_layer_more_step; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  FVKHnew

set local_testK_hash_bottom_layer_more_step(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] FVKH, [[int]] eq, [[int]] gr, [vec] classListByFace, KGPElt Qmin,
     {[KGPElt] maxQs,} [QKL_bottom_data] datas, [int] Ds{, KTypePol MU}, KTypePol_hash pol_hash,
     Param_hash Uhash) = [[FaceVertsKHash]]:
     local_testK_hash_bottom_layer_more_step(x, lambda, Lvd, FVKH, eq, gr, classListByFace,
     Qmin, {maxQs,} datas, Ds, {MU,} pol_hash, Uhash, is_unitary_hash_big_SIMPLE@Param) 

set ParamsByDim = [[Param]]: for d:16 do [] od
set LFDKHByDim = [[FaceVertsKHash]]: for d:16 do [] od

{takes the unitary Param's listed in LFDKHByDim and computes the K-character
 number in pol_hash}
set KcharsByDim() = [[int]]:
    for j:16 do for v in LFDKHByDim [j] do v[j+1] od od

{lists all distinct K-characters (by number in pol_hash)}
set AllKchars() = [int]:
    KcharsByDim().##.sort_u

set NumKchars() = int:
    #AllKchars()

set more_verbose =false

{if true, hash_down runs through faces small to large, hoping for nonunitarity}
{set hash_down = true}

set final_verbose = false

{ Input is candidate faces, and graph info. Output is the tester-unitary ones.
 use and update a complete list Uhash of known tester-unitary faces.
 try to compute and systematically use partial order on faces}
set local_test_hash_old(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    (Param->bool) tester, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, start = elapsed_ms()
    then newStatuses = for m:NumClasses do "?" od
    then start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose and NumClasses > 100
    	      then prints("start local_test, ",NumClasses,
	      " equiv classes of faces")
	      fi
    {then start_by_dim = vec: for list in LFVH do #list od}
    then () = if KU_flag
    	      then let() = KUKU_flag:=false
	      	   then knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, LFVH, fancy_tester)
	      	   {then () = prints(knownUnitaries)}
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				   in newStatuses:= downdateUclassesB(newStatuses, gr, k, "T");
				      newStatuses[k] := "T"
	    	 		od
	      		     od
		   in KUKU_flag:=true
	       fi
     then () = if KNU_flag
     	       then let knownNonUnitaries = known_non_unitaries(x, lambda, Lvd, LFVH)
    	       in for list@d in knownNonUnitaries
    	      	  do for j in list
		     do let k = classListByFace[d][j]
			in newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
			   newStatuses[k] := "F"
	    	      od {j in list}
	      	   od {list@d}
		fi
    then known_true_count = 0, known_false_count = 0, unknown_ms = [int]:[]
    then () = for s@m in newStatuses
    	      do if s[0] = "T" then known_true_count +:= 1
	      	 elif s[0] = "F" then known_false_count +:=1
		 else unknown_ms #:=m
		 fi
	      od
    then () = if test_verbose
    	      then prints("     Examining ",NumClasses," classes in local_test_hash; ",
	      known_true_count," are known unitary, ", known_false_count, " known nonunitary.")
	      fi
    then () = if final_verbose and
    	      	 NumClasses - known_true_count - known_false_count > 0
    	      then prints("representatives of unknown classes:");
	      	   for m:NumClasses
	      	   do if newStatuses[m][0] = "?"
	              then let C = eq[m]
		      	   then (d,j) = coords(LFVH,C[0])
	      	      	   then verts = vec: LFVH[d][j][:d+1]
		      	   then gamma = face_bary(Lvd,verts)
		     	   then pC = parameter(x, lambda, gamma)
	      	      	   in prints("   ",pC, " for class of size ",#C)
		      fi {newStatuses = ?}
		   od
	      fi {final_verbose}
    then () = for m:NumClasses {work from small faces toward big}
    	     ~do if{NEWU} newStatuses[m][0] = "?"
	         then let C = eq[m]
		      then (d,j) = coords(LFVH,C[0])
	      	      then verts = vec: LFVH[d][j][:d+1]
			  {then () = if wiggle_flag and nu_wiggle(x,lambda,verts,Lvd,HT)
				    then result = any(for q in qs do not is_unitary_to_ht_big_SIMPLE(q,}
		     then gamma = face_bary(Lvd,verts)
		     then pC = parameter(x, lambda, gamma)
	      	     then ps = monomials(pC)
		     then () = if all(for p in ps
		   	    	   do @bool: Uhash.lookup(p).>= or (let ans = tester(p)
				      	     			   in if not ans
								      then if more_after_flag
									   then more_bad_hash.match(p)
									   elif min_after_flag
									   then bad_hash.match(p)
									   fi
								       fi; ans)
				   od)
		   	      then newStatuses[m]:="T"

		   else newStatuses:= updateNUclassesB(newStatuses, gr, m);
		   	newStatuses[m] := "F";
			[]
		   fi{NEWU};
	         if let mopp = NumClasses - m - 1 in mopp < m
	       	    then let M = NumClasses -m -1
	    	      	 then () = if fund_face_verbose and M%printInterval = 0
	    	      	      	   then let unk = #q_nums(newStatuses[M:m])
	    	      	   	   	in prints("testing equivalence class #",M, " and #",m,
	      		     	   "; so far ",unitary_test_counter.use_count() - start_count
	      		   	   ," 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
	      		   	   ; printInterval := (3*printInterval)\2 + 1
	    	       	    	   fi {fund_face_verbose}
	                  in if newStatuses[M][0] = "?" {NEWU}
		      	     then let C=eq[M]
		 	        then (d,j) = coords(LFVH,C[0]) {always easier to test FIRST term in equiv class?}
	     			then verts = vec: LFVH[d][j][:d+1]
	     			then pC = parameter(x, lambda, face_bary(Lvd, verts))
		  		     {first_param makes trouble in UParams list!}
	     			then ps = monomials(pC)
	     			in if all(for p in ps
		   	  	      	  do @bool: Uhash.lookup(p).>= or (let ans = tester(p)
			      	 	     	    		       	   in if not ans
				    					      then if more_after_flag
				      	 				      	   then more_bad_hash.match(p)
				      	 					   elif min_after_flag
				      	 					   then bad_hash.match(p)
				      	 					   fi {more_after}
				    					      fi{not ans}
				  					      ; ans)
					od) {all for p in ps}
			   	   then newStatuses := downdateUclassesB(newStatuses, gr, M,"T");
			   	     	 newStatuses[M] := "T"
		   		   else newStatuses[M] := "F"
				   fi {all for p in ps}
		            fi {NEWU} {list of unitary Params}
		fi {mopp < m}
		in ()
		fi
	  od {m:NumClasses}
     {while(known_true_count + known_false_count < NumClasses)
     do if known_true_count>known_false_count}
     then unitary_by_dim = vec: null(#LFVH)
     then UParams = [Param]:[]
     then () = for C@k in eq
     	       do if newStatuses[k][0] = "T"
	       	  then for i in C
		       do let (d,j) = coords(LFVH,i)
		          then moreverts = vec: LFVH[d][j][:d+1]
			  then () = unitary_by_dim[d]+:=1
			  then q = parameter(x,lambda, face_bary(Lvd,moreverts))
			  in UParams #:= q;
			     if long_out_flag
		      	     then ParamsByDim[d] #:=q;
			   	  LFDKHByDim[d]#:=LFVH[d][j]
			     fi;
			     for q1 in monomials(finalize(q))
			     do Uhash.match(q1);
				if deform_flag
				then for q1d in facet_deformed_new(q1)
				     do Uhash.match(q1d)
				     od
				fi {deform_flag}
			     od {q1 in monomials}
		       od {i in C}
		   fi {newStatuses[k]}
		od
     then () = if test_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary.")
	       fi
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",unitary_by_dim, test_string);
		   prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
		 	print_time_string(elapsed_ms() - start))
	      fi
    in  UParams

set old_local_test_flag = true
set pref_top = int: 4

{ Input is candidate faces, and graph info. Output is the tester-unitary ones.
 use and update a complete list Uhash of known tester-unitary faces.
 try to compute and systematically use partial order on faces}
{Work from top (big faces); after every pref_top of those, do one bottom}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    (Param->bool) tester, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if old_local_test_flag
    then return local_test_hash_old(x, lambda, Lvd, LFVH, eq, gr, classListByFace,
    	 tester, Uhash, fancy_tester)
    fi;
    let NumClasses = #eq, printInterval = int: 1, start = elapsed_ms()
    then newStatuses = for m:NumClasses do "?" od
    then start_count = unitary_test_counter.use_count()
    then () = if fund_face_verbose and NumClasses > 100
    	      then prints("start local_test, ",NumClasses,
	      " equiv classes of faces")
	      fi
    {then start_by_dim = vec: for list in LFVH do #list od}
    then () = if KU_flag
    	      then let() = KUKU_flag:=false
	      	   then knownUnitaries = known_unitaries(Uhash, x, lambda, Lvd, LFVH, fancy_tester)
	      	   {then () = prints(knownUnitaries)}
    	      	   then () = for list@d in knownUnitaries
    	      	   	     do for j in list
	      	 	     	do let k = classListByFace[d][j]
				   in newStatuses:= downdateUclassesB(newStatuses, gr, k, "T");
				      newStatuses[k] := "T"
	    	 		od
	      		     od
		   in KUKU_flag:=true
	       fi
     then () = if KNU_flag
     	       then let knownNonUnitaries = known_non_unitaries(x, lambda, Lvd, LFVH)
    	       in for list@d in knownNonUnitaries
    	      	  do for j in list
		     do let k = classListByFace[d][j]
			in newStatuses:= updateNUclassesB(newStatuses, gr, k, "F");
			   newStatuses[k] := "F"
	    	      od {j in list}
	      	   od {list@d}
		fi
    then known_true_count = 0, known_false_count = 0, unknown_ms = [int]:[]
    then () = for s@m in newStatuses
    	      do if s[0] = "T" then known_true_count +:= 1
	      	 elif s[0] = "F" then known_false_count +:=1
		 else unknown_ms #:=m
		 fi
	      od
    then () = if test_verbose
    	      then prints("     Examining ",NumClasses," classes in local_test_hash; ",
	      known_true_count," are known unitary, ", known_false_count, " known nonunitary.")
	      fi
    then () = if final_verbose and
    	      	 NumClasses - known_true_count - known_false_count > 0
    	      then prints("representatives of unknown classes:");
	      	   for m:NumClasses
	      	   do if newStatuses[m][0] = "?"
	              then let C = eq[m]
		      	   then (d,j) = coords(LFVH,C[0])
	      	      	   then verts = vec: LFVH[d][j][:d+1]
		      	   then gamma = face_bary(Lvd,verts)
		     	   then pC = parameter(x, lambda, gamma)
	      	      	   in prints("   ",pC, " for class of size ",#C)
		      fi {newStatuses = ?}
		   od
	      fi {final_verbose}
    then () = for m:NumClasses {work from big faces toward small}
    	      do if{NEWU} newStatuses[m][0] = "?"
	         then let C = eq[m]
		      then (d,j) = coords(LFVH,C[0])
	      	      then verts = vec: LFVH[d][j][:d+1]
			  {then () = if wiggle_flag and nu_wiggle(x,lambda,verts,Lvd,HT)
				    then result = any(for q in qs do not is_unitary_to_ht_big_SIMPLE(q,}
		     then gamma = face_bary(Lvd,verts)
		     then pC = parameter(x, lambda, gamma)
	      	     then ps = monomials(pC)
		     then () = if all(for p in ps
		   	    	   do @bool: Uhash.lookup(p).>= or (let ans = tester(p)
				      	     			   in if not ans
								      then if more_after_flag
									   then more_bad_hash.match(p)
									   elif min_after_flag
									   then bad_hash.match(p)
									   fi
								       fi; ans)
				   od)
		   	      	then newStatuses := downdateUclassesB(newStatuses, gr, m);
			      	     newStatuses[m]:="T"
		   	      	else newStatuses[m] := "F"
		   fi{NEWU};
	         if (m%pref_top).= and NumClasses - (m\pref_top) - 1 >  m
	       	    then let M = NumClasses -(m\pref_top) -1 {M runs from NumClasses - 1}
	    	      	 then () = if fund_face_verbose and (m\pref_top)%printInterval = 0
	    	      	      	   then let unk = #q_nums(newStatuses[m:M+1])
	    	      	   	   	in prints("testing equivalence classes #",m, " and #",M,
	      		     	   "; so far ",unitary_test_counter.use_count() - start_count
	      		   	   ," 'is_unitary' tests; ",unk," classes still ? at ",
					     print_time_string(elapsed_ms() - start))
	      		   	   ; printInterval := 2*printInterval
	    	       	    	   fi {fund_face_verbose}
	                  in if newStatuses[M][0] = "?" {NEWU}
		      	     then let C=eq[M]
		 	        then (d,j) = coords(LFVH,C[0]) {always easier to test FIRST term in equiv class?}
	     			then verts = vec: LFVH[d][j][:d+1]
	     			then pC = parameter(x, lambda, face_bary(Lvd, verts))
		  		     {first_param makes trouble in UParams list!}
	     			then ps = monomials(pC)
	     			in if all(for p in ps
		   	  	      	  do @bool: Uhash.lookup(p).>= or (let ans = tester(p)
			      	 	     	    		       	   in if not ans
				    					      then if more_after_flag
				      	 				      	   then more_bad_hash.match(p)
				      	 					   elif min_after_flag
				      	 					   then bad_hash.match(p)
				      	 					   fi {more_after}
				    					      fi{not ans}
				  					      ; ans)
					od) {all for p in ps}
			   	   then newStatuses[M] := "T"
		   		   else newStatuses := updateNUclassesB(newStatuses, gr, M,"F");
				   	newStatuses[M] := "F"
				   fi {all for p in ps}
		            fi {NEWU} {list of unitary Params}
		fi {mopp < m}
		in ()
		fi
	  od {m:NumClasses}
     {while(known_true_count + known_false_count < NumClasses)
     do if known_true_count>known_false_count}
     then unitary_by_dim = vec: null(#LFVH)
     then UParams = [Param]:[]
     then () = for C@k in eq
     	       do if newStatuses[k][0] = "T"
	       	  then for i in C
		       do let (d,j) = coords(LFVH,i)
		          then moreverts = vec: LFVH[d][j][:d+1]
			  then () = unitary_by_dim[d]+:=1
			  then q = parameter(x,lambda, face_bary(Lvd,moreverts))
			  in UParams #:= q;
			     if long_out_flag
		      	     then ParamsByDim[d] #:=q;
			   	  LFDKHByDim[d]#:=LFVH[d][j]
			     fi;
			     for q1 in monomials(finalize(q))
			     do Uhash.match(q1);
				if deform_flag
				then for q1d in facet_deformed_new(q1)
				     do Uhash.match(q1d)
				     od
				fi {deform_flag}
			     od {q1 in monomials}
		       od {i in C}
		   fi {newStatuses[k]}
		od
     then () = if test_verbose
    	       then prints("     Total of ", count(for ans in newStatuses do ans[0] = "T" od),
	      	   		 " classes are unitary.")
	       fi
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",unitary_by_dim, test_string);
		   prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
		 	print_time_string(elapsed_ms() - start))
	      fi
    in  UParams

{don't want to specify tester}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    local_test_hash(x, lambda, Lvd, LFVH, eq, gr, classListByFace,
    if test_interrupt_flag
    then is_unitary_test_big_SIMPLE_interrupt@Param
    else is_unitary_hash_big_SIMPLE@Param
    fi, Uhash, fancy_tester)

{don't want to specify fancy_tester}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[LocalFaceVertsKHash]] LFVH,
    [[int]] eq, [[int]] gr, [vec] classListByFace, (Param->bool) tester, Param_hash Uhash) = [Param]:
    local_test_hash(x, lambda, Lvd, LFVH, eq, gr, classListByFace, tester, Uhash,
    if test_interrupt_flag {up_mu_flag}
    then is_unitary_test_big_SIMPLE_interrupt@Param
    else is_unitary_hash_big_SIMPLE@Param
    fi)

{don't want to specify either}
set local_test_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[LocalFaceVertsKHash]] LFVH,
    [[int]] eq, [[int]] gr, [vec] classListByFace, Param_hash Uhash) = [Param]:
    local_test_hash(x, lambda, Lvd, LFVH, eq, gr, classListByFace, Uhash,
    if test_interrupt_flag {up_mu_flag}
    then is_unitary_test_big_SIMPLE_interrupt@Param
    else is_unitary_hash_big_SIMPLE@Param
    fi)


{if true, uses bottom_more at last step instead of is_unitary}
set mix_flag = false

{ Input is candidate faces, and graph info. Output is the unitary ones.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use partial order on faces.
IF mix_flag, DON'T assume the input params are already bottom layer positive
for minimal parabolic; try
to use larger ones.}  {NOW NOT USED}
set local_test_hash_bottom(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr, [vec] classListByFace,
    {[KGPElt] maxQs,} [QKL_bottom_data] datas, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, newStatuses = for j:#eq do "?" od
    then start_count = unitary_test_counter.use_count(), red_shift = if red_count_flag then 1 else 0 fi
    then () = for k:NumClasses
             ~do if newStatuses[k] = "?"
                 then let C=eq[k] {should run backwards for update to be effective?}
                      then (d,j) = coords(LFVH,C[0]) {search C to look for largest d?}
                      then verts = vec: LFVH[d][j][:d+1]
		      {then ratverts = [ratvec]: for m in verts do Lvd.list[m] od}
		      {then sigma = sum(#lambda, ratverts)}
                      then pC = parameter(x, lambda, face_bary(Lvd,verts)) {,sigma/(d+1))}
                      then pCdef = if is_final(pC)
                                   then if wiggle_flag and d > 0
					then {let () = char_counter.use()
				   	     then startCF = elapsed_ms()}
				   	     let CF = character_formula(pC)
					     {then () = charTime +:= elapsed_ms() - startCF}
					     in monomials(composition_series((sum(x.real_form,
					     for j:d+1 {v in ratverts}
					     do wiggle(CF, face_bary(Lvd,verts[:j]##verts[j+1:]))
					     {(sigma - v)/d)}
					     od))))
							  {proper_facet_deformed(pC)}
					 else []
					 fi
                                    else monomials(finalize(pC))
                                    fi {is_final(pC)}
                       in if not is_final(pC)
			  then if all(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
			       	       	       (Uhash.lookup(q) >= 0) od)
                               then newStatuses[k] := "T"
                               elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 	 (Uhash.lookup(q) = -1) od)
                               then newStatuses:= updateNUclassesB(newStatuses, gr, k); "F"
                               fi {all (for q}
                          else {now pC is final, and pCdef consists of wiggled Params with smaller x}
                               if any(for q in pCdef do @bool:  is_finished(q.x,q.lambda) and
				       	       (Uhash.lookup(q) = -1) od)
                               then newStatuses := updateNUclassesB(newStatuses, gr, k);
				    	 newStatuses[k] := "F"
                               fi
                          fi {not is_final(pC)}
                   fi {newStatuses[k]}
               od
    then () = if fund_face_verbose and NumClasses > 100
    	      then prints("start local_test, ",NumClasses,
	      " equiv classes of faces")
	      fi
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
    	 for m:NumClasses
    	~do if fund_face_verbose and NumClasses > 100 and
	      	 ((NumClasses-m-1)%printInterval = 0)
	    then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",unitary_test_counter.use_count() - start_count
	      ," 'is_unitary' tests.")
	      ; printInterval := (3*printInterval)\2 + 1
	    fi
	    ;
	    let elim_more = true, p = parameter(x,lambda,0*lambda)
	    then test = bool:
	        if newStatuses[m] = "F"
	    	then false
		elif newStatuses[m] = "T"
		then true
	    	else let C=eq[m]
	      	     then (d,j) = coords(LFVH,C[0])
	      	     then verts = vec: LFVH[d][j][:d+1]
		  {first_param makes trouble in UParams list!}
		     then p_start_time = elapsed_ms()
		     then () = p := parameter(x, lambda, face_bary(Lvd, verts))
		     then () = if more_verbose then prints("testing parameter ",p) fi
	      	     then ps = monomials(finalize(p))
		     then () = if more_flag or mix_flag
			       then elim_more:= if #ps = 1
				    		then bottom_elim_factors_more(ps[0], p, datas, pol_hash.index(LFVH[d][j][d+red_shift+1]))
		                    		else all(for p1 in ps
		   	       	    	       	     	 do Uhash.lookup(p1).>= or {this can produce "isn't LKT message"}
			       	       	    	      	 bottom_elim_factors_more(p1, p, datas)
					      	    	 od)
				     	   	 fi
			        fi
		      in if not elim_more
		      	 then false {we got rid of p by bottom layer}
			 else all(for p1 in ps
			      	  do @bool: let ans = is_unitary_def_test_big_SIMPLE(p1)
				     	    in if d <= 1 and more_after_flag and not ans
				     	       then more_bad_hash.match(p1)
					       fi;
					       if d<=1 and min_after_flag and not ans
				     	       then bad_hash.match(p1)
					       fi; ans
				  od)
		     	 fi
		  fi {newStatuses[m]}
	      then () = if more_verbose then prints("your final answer was ",test) fi
	      in if test
		 then for i in eq[m]
		      do let (d,j) = coords(LFVH,i)
			 then verts = vec: LFVH[d][j][:d+1]
			 then () = unitary_by_dim[d]+:=1
			 then q = parameter(x,lambda, face_bary(Lvd,verts))
			 then () = for q1 in monomials(finalize(q))
			   	   do Uhash.match({herm_center(}q1{)});
				      if deform_flag
				      then for q1d in facet_deformed_new(q1)
				     	   do Uhash.match({herm_center(}q1d{)})
					   od
				      fi
				   od
			  then () = if long_out_flag
		      	   	    then let () = ParamsByDim[d] #:= q
			   	     	 then ()=LFDKHByDim[d] #:= LFVH[d][j]
				     	 in ()
			   	    fi
			  in q
		       od
		  else [] 
		  fi{test}
	     od.## {list of unitary Params}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
    in  UParams

{ Input is candidate faces, and graph info. Output is the unitary ones.}
set local_test_wiggle_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH, [[int]] eq, [[int]] gr,
    [vec] classListByFace, Param_hash Uhash) = [Param]:
    let NumClasses = #eq, printInterval = int: 1, newStatuses = for j:#eq do "?" od
    then () = for k:NumClasses
             ~do if newStatuses[k] = "?"
                 then let C=eq[k] {should run backwards for update to be effective?}
                      then (d,j) = coords(LFVH,C[0])
                      then verts = vec: LFVH[d][j][:d+1]
		      {then ratverts = [ratvec]: for m in verts do Lvd.list[m] od
		      then sigma = sum(#lambda, ratverts)}
                      then pC = parameter(x, lambda, face_bary(Lvd, verts)) {sigma/(d+1))}
                      then pCdef = if is_final(pC)
                                   then if wiggle_flag and d > 0
					then {let () = char_counter.use()
				   	     then startCF = elapsed_ms()}
				   	     let CF = character_formula(pC)
					     {then () = charTime +:= elapsed_ms() - startCF}
					     in monomials(composition_series((sum(x.real_form,
					     	for j:d+1{v in ratverts}
						do wiggle(CF, face_bary(Lvd,verts[:j]##verts[:j+1]))
						{(sigma - v)/d)}
						od))))
					else []
					fi
                                   else monomials(finalize(pC))
                                   fi {is_final}
                      in if not is_final(pC)
			 then if all(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
			       	       	       (Uhash.lookup(q) >= 0) od)
                              then newStatuses[k] := "T"
                              elif any(for q in pCdef do @bool: is_finished(q.x,q.lambda) and
				    	 	 (Uhash.lookup(q) = -1) od)
                              then newStatuses:= updateNUclassesB(newStatuses, gr, k); "F"
                              fi
                         else {now pC is final, and pCdef consists of wiggled Params}
                              if any(for q in pCdef do @bool: is_finished(q.x,q.lambda)
				       	       	    	     	    and (Uhash.lookup(q) = -1) od)
				 then newStatuses := updateNUclassesB(newStatuses, gr, k); newStatuses[k] := "F"
                                    fi
                               fi
                        fi
                   od
              {fi}
    then () = if fund_face_verbose and NumClasses > 100
              then prints("start local_test, ",NumClasses,
              " equiv classes of faces")
              fi
    then unitary_by_dim = vec: null(#LFVH)
    then UParams = [Param]:
         for m:NumClasses
        ~do if fund_face_verbose and NumClasses > 100 and
                 ((NumClasses-m-1)%printInterval = 0)
            then prints("examining equivalence class #"
              ,NumClasses-m -1, "; so far ",unitary_test_counter.use_count()
              ," 'is_unitary' tests.")
              ; printInterval := (3*printInterval)\2 + 1
            fi
            ;
            let test = bool:
                if newStatuses[m][0] = "F"
                then false
		elif newStatuses[m][0] = "T"
		  then true
                else let C=eq[m]
                     then (d,j) = coords(LFVH,C[0])
                     then verts = vec: LFVH[d][j][:d+1]
                  {first_param makes trouble in UParams list!}
                     then p = parameter(x, lambda, face_bary(Lvd, verts))
                     then () = if more_verbose then prints("testing parameter ",p) fi
                     then ps = monomials(finalize(p))
                     in all(for p1 in ps do @bool: is_unitary_def_test_big_SIMPLE(p1) od)
		fi
             in if test
                then for i in eq[m]
                     do let (d,j) = coords(LFVH,i)
                        then verts = vec: LFVH[d][j][:d+1]
                        then () = unitary_by_dim[d]+:=1
                        then q = parameter(x,lambda, face_bary(Lvd,verts))
                        then () = for q1 in monomials(finalize(q))
                                  do Uhash.match({herm_center(}q1{)});
                                     if deform_flag
                                     then for q1d in facet_deformed_new(q1)
                                          do Uhash.match({herm_center(}q1d{)})
                                          od
                                     fi
                                  od
                         then () = if long_out_flag
                                  then let () = ParamsByDim[d] #:= q
                                       then ()=LFDKHByDim[d] #:= LFVH[d][j]
                                       in ()
                                  fi
                         in q
                      od
                  else [] 
                  fi
             od.## {list of unitary Params}
    in UParams

set one_true_counter = make_counter()
set one_false_counter = make_counter()
{set hash_real_dumbCounter = make_counter()
set hash_dumbCounter = make_counter()
set hash_def_dumbCounter = make_counter()
set hash_bottom_layerCounter = make_counter()}
set one_param_time = int: 0

{true more than 3/4 of time, so shouldn't do much to_height testing}
set one_param_test(Param p, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), Q = monomials(finalize(p)), G = p.real_form
    then () = if all(for q in Q do Uhash.lookup(q).>= od)
    	      then return [p]
	      elif any(for q in Q do big_unitary_hash.nulookup(q).>= od)
	      then return []
	      fi
    then r = rank(Q[0].x.involution - 1) {, step = max(G.semisimple_rank\2,1)}
    then test = all(for q in Q
       	      	    do @bool:
		       let ans = if test_interrupt_flag {up_mu_flag}
		       	       	 then is_unitary_test_big_SIMPLE_interrupt(q)
		       		 else {let DEFHTS = [int]: next_heights(p, r\2)
		            	      in is_unitary_test_big_SIMPLE(q, DEFHTS)}
				      is_unitary_hash_big_SIMPLE(q)
		      		 fi
			in if more_after_flag and not ans
			   then more_after_flag:=false; more_bad_hash.match(q)
			   fi;
			   if min_after_flag and not ans
			   then min_after_flag:= false; bad_hash.match(q)
			   fi; ans
	   	    od)
    in if test
       then one_true_counter.use();
	    one_param_time +:= elapsed_ms() - start;
	    [p]
       else one_false_counter.use();
 	    one_param_time +:= elapsed_ms() - start;
	    []
       fi

{only does min_bottom test}
set one_param_test_min_bottom(Param p, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), Q = monomials(finalize(p)), G = p.real_form
    then () = if all(for q in Q do Uhash.lookup(q).>= od)
    	      then return [p]
	      elif any(for q in Q do big_unitary_hash.nulookup(q).>= od)
	      then return []
	      fi
    then () = hash_bottom_layerCounter.use()
    then elim_min = all(for q in Q do min_bottom_elim_factors(q,p) od)
    then () = if not elim_min
    	      then let () = one_false_counter.use()
	      	   then ()= one_param_time +:= elapsed_ms() - start
		   in return []
	      fi
    then r = rank(Q[0].x.involution - 1)
    then test = all(for q in Q
       	      	    do @bool: 
		    if test_interrupt_flag {up_mu_flag}
		    then let ans = is_unitary_test_big_SIMPLE_interrupt(q)
		    	 in if not ans then bad_hash.match(q) fi; ans
		    else let DEFHTS = [int]: next_heights(p, r\2)
		    	 then ans = is_unitary_test_big_SIMPLE(q, DEFHTS)
			 in if not ans then bad_hash.match(q) fi; ans
		    fi
	   	    od)
    in if test
       then one_true_counter.use();
	    one_param_time +:= elapsed_ms() - start;
	    [p]
       else one_false_counter.use();
	    one_param_time +:= elapsed_ms() - start;
	    []
       fi

{assume min_bottom already called, so lookup failed}
set one_param_test_bottom(Param p, [int] Ds, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), QG = monomials(finalize(p)),G = p.real_form
    {Next statement, to check here whether terms of QG already known, sometimes omitted?}
    then () = if all(for q in QG do Uhash.lookup(q).>= od)
    	      then return [p]
	      elif any(for q in QG do big_unitary_hash.nulookup(q).>= od)
	      then return []
	      fi
    then () = hash_bottom_layerCounter.use()
    then still_here = true
    then Es = (if #Ds > 1 then Ds
    	      else height(p)#Ds
	      fi).sort_u
    then (Qmin,) = if small_test_flag
    	 	    then theta_stable_data_small(p)
		    else theta_stable_quasi_data(p)
		    fi
    {then MU = big_unitary_hash.branch(K_type_pol(p),Es~[0])} {branch_std(p,Es~[0])}
    then () = if #Es > 1
       	      then let () = if more_verbose then prints("start more with p = ",p, ", Es = ",Es) fi
	    	   then Ps = for q in QG do K_type_pol(character_formula(q)) od
		   in while still_here and #Es > 1
		      do let old_size = bl_KHash.size()
			 then (datasNEW, EsNEW) = add_datas(p, Qmin, {bl_KHash,} Es{, MU})
			 in if bl_KHash.size() > old_size
			    then Es:= EsNEW;
		   		 still_here := all(for q@i in QG
						   do @bool:
						      let ans = bottom_elim_factors_more(q, p, datasNEW, Ps[i])
						      in if not ans
						      	 then more_bad_hash.match(q)
							 fi; ans
						   od)
			     else break
			     fi
		       od
		fi {#Es > 1}
    then () = if more_verbose then prints("result of bottom_elim_more was ",still_here) fi
    then r = rank(p.x.involution-1) {, step = max(G.semisimple_rank\2,1)}
    in if still_here
       then let () = if test_verbose then prints("one parameter unitary on bottom layer to height ",Es~[0]) fi
       then test = all( [(->bool)]:
		    	   for q in QG
			   do @bool: let ans = 
			      if test_interrupt_flag {up_mu_flag}
		    	      then is_unitary_test_big_SIMPLE_interrupt(q)
		    	      else {let DEFHTS = [int]: next_heights(p, r\2)
			      	   in is_unitary_test_big_SIMPLE(q, DEFHTS)}
				   is_unitary_hash_big_SIMPLE(q)
		    	      fi
			      then () = if not ans and more_after_flag
		            {HERE USE DIRAC ON MORE K-types}
			      	      	then more_bad_hash.match(q); more_after_flag:=false
					fi
			      in ans
			   od)
	    then () = if more_verbose then prints("your final answer was ",test) fi
	    in if test
	       then 	    	    let () = one_true_counter.use()
	    	    then () = one_param_time +:= elapsed_ms() - start
	    	    in [p]
	       else let () = one_false_counter.use() {if test is false}
	       	    then () = one_param_time +:= elapsed_ms() - start
		    in []
               fi
	else let () = one_false_counter.use() {if still_here is false}
	     then () = one_param_time +:= elapsed_ms() - start
	     in []
        fi

{don't assume min_bottom already called; should only be called if ht > 0?}
set one_param_test_all_bottom(Param p, [int] Ds, Param_hash Uhash) = [Param]:
    let start = elapsed_ms(), Q = monomials(finalize(p)),G = p.real_form
    {then () = prints("Ds = ",Ds)}
    then () = if all(for q in Q do Uhash.lookup(q).>= od)
    	      then return [p]
	      elif any(for q in Q do big_unitary_hash.nulookup(q).>= od)
	      then return []
	      fi
    then () = hash_bottom_layerCounter.use()
    then elim_min = all(for q in Q do min_bottom_elim_factors(q,p) od)
    then () = if not elim_min
    	      then let () = one_false_counter.use()
	      	   then ()= one_param_time +:= elapsed_ms() - start
		   in return []
	      fi
{now min bottom failed to eliminate...}
    then elim_more = true
    then Es = (if #Ds > 1 then Ds
    	      else height(p)#Ds
	      fi).sort_u
    then () = if #Es > 1
       	      then let () = if more_verbose then prints("start more with p = ",p, ", Es = ",Es) fi
	    	   then Ps = for q in Q do K_type_pol(character_formula{_to_height}(q{, Es~[0]})) od
       	    	   then still_here = true
		   then () = {for D in Ds[:1]
		      	     do} still_here := all(for {D@j in Ds[1:]} j:#Es-1 from 1
					       	  do all(for q@i in Q
						      	 do @bool: bottom_elim_factors_more(q, p, Es[j-1],Es[j], Ps[i])
						   	 od)
					          od){;
				 if not still_here then break fi}
			      {od}
		   in elim_more:= still_here
		fi {#Es > 1}
    then () = if more_verbose then prints("result of elim_more was ",elim_more) fi
    in if elim_more
       then let () = if test_verbose then prints("one parameter unitary on bottom layer to height ",Es~[0]) fi
       	    then test = all( [(->bool)]:
		    	   for q in Q
			   do @bool: let ans = if test_interrupt_flag {up_mu_flag}
		    	      then is_unitary_test_big_SIMPLE_interrupt(q)
		    	      else let steps = max(rank(p.x.involution-1),1)
    				   then test_heights = next_heights(p, steps)
				   in is_unitary_test_big_SIMPLE(q,test_heights)
		    	      fi
			      then () = if not ans
			      	      	then more_bad_hash.match(q)
					fi
			      in ans
		    	od)
	    then () = if more_verbose then prints("your final answer was ",test) fi
	    in if test
	       then let () = for q in Q
		     	     do Uhash.match(q)
		     	     od
	    	    then () = one_true_counter.use()
	    	    then () = one_param_time +:= elapsed_ms() - start
	    	    in [p]
	       else let () = one_false_counter.use() {if test is false}
	       	    then () = one_param_time +:= elapsed_ms() - start
		    in []
               fi
	else let () = one_false_counter.use() {if elim_more is false}
	     then () = one_param_time +:= elapsed_ms() - start
	     in []
        fi

{skips all unitary_to_ht tests in dims 2-top; just does at the end}
set quick_flag = true

{Assume we have local vertices and edges LF, herm and pos on LKTs.
Called when there are not enough heights; presumably small KGBElts??}
set local_test_GEO_hash_real_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
     [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) =
     [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G)
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if 1*parameter(x,lambda,lambda) = zero_pol then return [] fi
    then r = rank(x.involution - 1), NK = #KGB(x.real_form)
    then pmin = parameter(x,lambda,0*lambda)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	{[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then pmax = pmax(x,lambda,Lvd)
    then r = rank(x.involution - 1), rk = rank(x_open(G).involution - 1), step = max(G.semisimple_rank\2,1)
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    then tester = (Param->bool): (Param p) bool: {could have recorded bool above to
    	 	  		 	   	 omit is_unitary at end}
	 if test_interrupt_flag {up_mu_flag}
	 then is_unitary_test_big_SIMPLE_interrupt(p{,test_hts})
	 else let test_hts = [int]: next_heights(pmax, r\2)
	      then too_high = first(for h in test_hts do h > FPP_max_ht od)
    	      then () = if too_high.>= then {prints(test_hts);} test_hts:=test_hts[:too_high] fi
	      in is_unitary_test_big_SIMPLE(p, test_hts)
	 fi
    {then () = if face_verbose then prints("test_ht = ",test_ht) fi}
    then () = test_string:= " using local_test_GEO_hash_real_dumb"
    then  () = hash_real_dumbCounter.use()
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then startDBTcount = DBTcount
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
        {compute graph on faces to dim 1, remove failing Dirac}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
           {remove from LFDKH all faces failing is_unitary}
    then () = LFDKH := local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq, gr, CLBF,
    	 tester, Uhash, fancy_tester)
{here should use DiracBest, not later}
    then () = if test_verbose then prints("unitary face counts to dim 1: ",
    	      	 for list in LFDKH do #list od)
	      fi
    then () = if quick_flag
              then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                rank(x.involution - 1) + 1, pol_hash)
	           then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   in  LFDKH := local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq,
				      gr, CLBF, tester, Uhash)
	      else let D = int:1
    then () = while (D <= rank(x.involution-1) - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 then lowUs = sum(for d:D+1 do #LFDKH[d] od)
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
			      then test = if any(for p in ps
                                                 do is_finished(p.x, p.lambda){p.x.# < known_to} and
						      	 	Uhash.lookup(p) = -1
                                                 od)
                                          then false
                                          elif all(for p in ps
                                                   do Uhash.lookup(p).>=
                                                   od)
                                          then true
                                          else all(for p in ps
					       	   do tester(p)
					       	   od)
                                          fi {any}
 		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
                          in if test
                             then [LFDKH[D+1][m]]
                             else []
                             fi
                          fi
                       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	 fi {if quick_flag}
    then unitary_by_dim = for L in LFDKH do #L od
    {now have unitary faces of all dims}
     {then () = if test_verbose then prints("total number of tests = ",
                                  unitary_test_counter.use_count())
				  fi}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () =ParamsByDim[d]:=(ParamsByDim[d] next ParamsByDim[d]:=[])#p
			   {ParamsByDim[d] := ParamsByDim[d]#p}
			   	then ()=LFDKHByDim[d] :=(LFDKHByDim[d] next LFDKHByDim[d]:=[])#v
				{LFDKHByDim[d] := LFDKHByDim[d]#v}
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{Assume we have local vertices and edges LF, herm and pos on LKTs.
Called when there are not enough heights; presumably small KGBElts??}
set local_test_GEO_hash_else_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash,
    Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G)
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if 1*parameter(x,lambda,lambda) = zero_pol then return [] fi
    then r = rank(x.involution - 1), NK = #KGB(G), edge_offset_temp = min(#hts-1, edge_offset)
    then pmin = parameter(x,lambda,0*lambda)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash) 
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    {then test_hts = hts[:min(#hts,1{r})]  {??? who knows about r!}}
    then tester = (Param->bool): (Param p) bool:
    	 {is_unitary_test_big_SIMPLE(p,test_ht) {this settles unitarity absolutely}}
	 if test_interrupt_flag {up_mu_flag}
	 then is_unitary_test_big_SIMPLE_interrupt(p)
	 else is_unitary_def_test_big_SIMPLE(p)
	 fi
    then () = test_string:= " using local_test_GEO_hash_else_dumb"
    then () = if test_verbose then prints("Chose",test_string) fi
    then  () = hash_dumbCounter.use()
    then start_count = unitary_test_counter.use_count(), startDBTcount = DBTcount
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd, hts[edge_offset_temp],pol_hash, LF, eq,CLBF)
    	       	 else localFD_KHash_01(x, lambda, Lvd, hts[edge_offset_temp], pol_hash, LF)
		  fi {red_count_flag}
    {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od,"; Dirac_best eliminated ",
			  DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
           {remove from LFDKH all faces failing is_unitary to hts[0]}
	   {CAN'T use know_lower, because that uses DiracBest, without caring for height}
    then () =  LFDKH := local_testK_hash{_know_lower}(x,lambda,Lvd, LFDKH, eq, gr, CLBF, (Param->bool):
    (Param p) bool: is_unitary_to_ht_big_SIMPLE(p, hts[edge_offset_temp]), hts[edge_offset_temp],
    		   	     	   				  Uhash, fancy_tester)
    then () = if test_verbose then prints("unitary to ",hts[edge_offset_temp]," face counts to dim 1: ",
    	      	 	      	   		   for list in LFDKH do #list od) fi
    then () = LFDKH:= if red_count_flag and #LFDKH[1] > 0
    	      	      then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
		      	   in  extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red,
			   CLBF_red)
		      else extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
		      fi {now LFDKH has complete K-chars for verts and edges}
    {then () = prints("set LFDKH01 = ",LFDKH)}
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
              	   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, tester, -1, Uhash)
                   in if test_verbose
		      then prints("unitary face counts to dim ", #LFDKH - 1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, tester, -1, Uhash) 
	      	   then D = int:1 {now all verts and edges are unitary}
    		   then () = while (D <= rank(x.involution-1) - 1  ) and
    	   	   	     	   (#LFDKH = D + 1) and {found D-faces}
		    		   (#(LFDKH~[0]) > D+1) {possibility of D+1 faces}
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    {Algorithm assumes ALL lower diml faces are unitary}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 {then lowUs = sum(for d:D+1 do #LFDKH[d] od)}
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
		              then test = if any(for p in ps
					       	 do is_finished(p.x, p.lambda) and
						      	 Uhash.lookup(p) = -1
						 od)
					  then false
					  elif all(for p in ps
					       	   do Uhash.lookup(p).>=
						   od)
					  then true
					  else all(for p in ps
					       	   do tester(p) od)
					  fi
		{ these are simplices of dim at least 2 with unitary faces,
		so expect TRUE usually; so is_unitary faster than tester?}
			       in if test
			       	  then [LFDKH[D+1][m]]
				  else []
				  fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	     fi {quick_flag}
    then unitary_by_dim = for L in LFDKH do #L od
    {now have unitary faces of all dims}
     {then () = if test_verbose then prints("total number of tests = ",
                                  unitary_test_counter.use_count())
				  fi}
    then () = if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",
       	       	    	   unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{How many steps to use in is_unitary_def_test(p, steps) in def_dumb}
set def_steps = -1

{Assume we have local vertices and edges LF, herm and pos on LKTs and Dirac
	Use is_unitary_def_test(p, (G.rank + 1)\2}
set local_test_GEO_hash_def_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsIndex]] LF,
    KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then zero_pol = null_module(G), pmin = parameter(x,lambda, 0*lambda), NK = #KGB(G)
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution - 1)
    {then () = to_ht_flag:=true}
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then pmax = pmax(x,lambda, Lvd)
    then (LAMmax,NUmax,GAMmax) = low(pmax)
    then def_steps_temp = if def_steps = -1
    	 		  then ((r+G.rank))\5
			  else def_steps
			  fi
    then tester = (Param->bool): (Param p) bool:
     	 if test_interrupt_flag {up_mu_flag} {and to_ht_flag}
	 then is_unitary_test_big_SIMPLE_interrupt(p)
	 {else is_unitary_def_test_big_SIMPLE(p,def_steps_temp)}
	 else is_unitary_hash_big_SIMPLE(p)
	 fi
    then () = test_string:= " using local_test_GEO_hash_def_dumb"
    then () = if test_verbose then prints("Chose",test_string) fi
    then () = hash_def_dumbCounter.use()
    then start_count = unitary_test_counter.use_count(), startDBTcount = DBTcount
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
    {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od,"; Dirac_best eliminated ",
			  DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    {then () = prints("LFDKH = ",LFDKH)}
    {then () = prints("eq = ",eq,", gr = ",gr)}
           {remove from LFDKH all faces failing is_unitary}
    then () = LFDKH := local_testK_hash_know_lower(x,lambda,Lvd, LFDKH, eq, gr,
    	      	       				   CLBF, tester, Uhash, fancy_tester)
    then () = if test_verbose then prints("unitary face counts to dim 1: ", for list in LFDKH do #list od) fi
    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
	      	   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		      is_unitary_def_test_big_SIMPLE(p,def_steps_temp), -1, Uhash)
                   in if test_verbose
		      then prints("unitary face counts to dim ", #LFDKH - 1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
    then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	LFDKH, D+1,D+2,pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 {then lowUs = sum(for d:D+1 do #LFDKH[d] od)}
			   { write statuses more simply: all unitary except
			     singleton classes of dim D+1 }
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {then ratverts = [ratvec]: for m in verts do Lvd.list[m] od}
			      {then sigma = sum(#lambda, ratverts)} {THIS IS WRONG BARYCENTER}
			      then pC = parameter(x, lambda, face_bary(Lvd, verts))
			      then ps = monomials(finalize(pC))
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      in if not is_final(pC)
				 then if any(for q in ps do @bool:  is_finished(q.x,q.lambda) and
				      	      	      (Uhash.lookup(q) = -1) od)
				      then []
				      else if all(for q in ps do @bool:  is_finished(q.x,q.lambda) and
					   	   	   (Uhash.lookup(q) >= 0) od)
				      	    then [LFDKH[D+1][m]]
				      	    else if all(for q in ps do @bool: tester(q) od)
					    	 then [LFDKH[D+1][m]]
					   	 else []
					   	 fi
				       	    fi {all(for q}
				      fi {any(for q}
				 else {now pC is final}
				      if wiggle_flag
				      then {let () = char_counter.use()
				   	   then startCF = elapsed_ms()}
				   	   let CF = character_formula(pC)
					   {then () = charTime +:= elapsed_ms() - startCF}
					   then pCdef =  monomials(composition_series((sum(x.real_form,
					   	      for j:#verts
						      do wiggle(CF, face_bary(Lvd, verts[:j]##verts[j+1:]))
						      od))))
							  {proper_facet_deformed(pC)}
				      	        in if any(for q in pCdef
						      	  do @bool: ( is_finished(q.x,q.lambda) and
							    (Uhash.lookup(q) = -1))
							  od)
						   then []
					      	   else if tester(pC)
					   	   	then [LFDKH[D+1][m]]
					   	   	else []
					     	   	fi
				      	      	   fi {any(for q}
				      else {not wiggle_flag}
					      if tester(pC)
					      then [LFDKH[D+1][m]]
					      else []
					      fi
				      fi {wiggle_flag}
				 fi {not is_final}
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
		 then () = if test_verbose then prints("face counts to dim ",
		     D+1,": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	     od
	     in ()
	     fi {quick_flag}
    {now have unitary faces of all dims}
     then unitary_by_dim = for L in LFDKH do #L od
     then () = if test_verbose or test_slightly_verbose
    	       then prints("unitary faces by dim = ",
       	       	    	    unitary_by_dim, test_string);
		 prints("number of tests = ",unitary_test_counter.use_count() - start_count)
	      fi
     then UParams = [Param]:
          for list@d in LFDKH
          do for v in list
             do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		then () = for  p1 in monomials(finalize(p))
                      	  do Uhash.match({herm_center(}p1{)});
                             if deform_flag
			     then for q in facet_deformed_new(p1)
                             	  do Uhash.match({herm_center(}q{)})
				  od
			      fi
                          od
		 then () = if long_out_flag
		      	   then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				in ()
			   fi
		 in p
              od
           od.##
   then time = elapsed_ms() - start
   then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
   in UParams

{assume LF is verts and edges, herm and pos on LKTs and Dirac?}
set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if real_flag
    then local_test_GEO_hash_real_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
    elif def_flag
    then local_test_GEO_hash_def_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
    else let shorts = if short_hts_flag
    	     	      then short_hts(parameter(x,lambda,Lvd.list[0]))
		      else next_heights(parameter(x,lambda, Lvd.list[0]), 1)
		      fi
    	 then hts = shorts[:min(1,#shorts)]
    	 in local_test_GEO_hash_else_dumb(x, lambda, {vd,} Lvd, LF, hts, pol_hash, Uhash,fancy_tester)
    fi

{if true, uses the (faster?) function localFD_1Dirac2_by_zero to compute local vertices and edges}
{seems SLOWER in F4, E7}
set by_zero_flag = true

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    let DiracBD = DiracBD(x,lambda), G=x.real_form
    then rhocheck = G.rho_check
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda,Lvd,Perm2)
	      fi
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    let DiracBD = DiracBD(x,lambda), G=x.real_form
    then rhocheck = G.rho_check
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	      fi
    {imposes Dirac, herm, pos on LKTs for vertices and edges}
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash,fancy_tester)

set local_test_GEO_hash_dumb(KGBElt x, ratvec lambda, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    then (Lvd, Perm2) = localFD_Lvd2(x, lambda, FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO_dumb(KGBElt x, ratvec lambda) =
    [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form), pol_hash = make_KTypePol_hash(), G = x.real_form
    {then vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_dumb(x, lambda, pol_hash, Uhash, is_unitary_hash_big_SIMPLE@Param)

{vertex set size number at which to revert to local_test_GEO_hash_dumb.
0 to 100 make sense: higher means revert MORE often}
set vert_diff_cutoff = int: 10

{set hashCounter = make_counter()}

{assume we've already got hts, #hts >= 1, imposed Dirac, and decided not to use _dumb
Assume LF is vertices and edges, already pos on LKTs and hermitian and Dirac}
set local_test_GEO_hash_no_dumb(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let () = hashCounter.use()
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = test_string:= " using local_test_GEO_hash"
    then () = if test_verbose then prints("Chose",test_string) fi
    then () = if(face_verbose) then prints("hts = ",hts) fi
    then long_out_temp_flag = long_out_flag, r = rank(x.involution -1), start = elapsed_ms()
    then () = long_out_flag:=false {to allow using local_test_hash without recording Params}
    then edge_offset_temp = edge_offset, ht0 = height(parameter(x,lambda,0*lambda)),
    	 G = x.real_form
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    {then test_levels = for d:max(r+1,2) do (d*edge_skip*stretcher)\1 + edge_offset_temp od}
    {then test_hts = hts {for d:max(r+1,2) do hts[test_levels[d]] od} {need to increase #hts?}}
    {then pol_hash0 = make_KTypePol_hash()} {to hold chars to height hts[edge_offset]}
    then startDBTcount = DBTcount
{for E8_s, K-chars to height test_hts[0] = 68 is 2.5 days. So do just hts[0]!}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq_red,CLBF_red) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,hts[edge_offset],pol_hash,
			      LF, eq_red,CLBF_red)
		 else localFD_KHash_01(x, lambda, Lvd, hts[edge_offset], pol_hash, LF)
		 fi {red_count_flag}
     {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od,"  Dirac_best eliminated ",
			  DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1, to hts[edge_offset]}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    {then () = prints("trial of eq at dim 1 is ",trial(x,lambda,Lvd,LFDKH, eq, hts[edge_offset]))}
    then ICPNU_flag_hold = ICPNU_flag
    then () = ICPNU_flag:=false
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, (Param->bool):(Param p):
    is_unitary_to_ht_big_SIMPLE(p, hts[edge_offset]), hts[edge_offset], Uhash)
	 {now have vert/edges unitary to hts[edge_offset]}
    then () = if test_verbose then prints("unitary to ht ",hts[edge_offset],
                        " face counts to dim 1: ",for list in LFDKH do #list od) fi
    then () = LFDKH := if red_count_flag and #LFDKH[1] > 0
    	      	       then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
    	      	       	    in extend_K_characters_graph(x, lambda, Lvd, LFDKH, pol_hash, eq_red, CLBF_red)
		       else extend_K_characters(x,lambda,Lvd,LFDKH,pol_hash)
		       fi {now LFDKH is always FULL K-chars}
     then Dlast = #hts -1
     then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, pol_hash)
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,hts[Dlast])
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF,
		   	(Param->bool): (Param p): is_unitary_to_hts_big_SIMPLE(p,hts[1:Dlast+1])
		      , hts[Dlast], Uhash)
                   in if test_verbose
		      then prints("unitary to ht ",hts[Dlast],
		      	      		" face counts to dim ",Dlast+1,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
	      	   then () = if #hts < r
		   	     then hts ##:= for D:r-#hts do hts~[0] od
			     fi
    		   then () = while (D <= r - 1  ) and (#LFDKH = D + 1) and (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht hts[D] on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   LFDKH, D+1,D+2, pol_hash)
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,hts[D+edge_offset])
       	      	 {compute graph on faces to dim D+1}
		 then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		      is_unitary_to_ht_big_SIMPLE(p,hts[D+edge_offset]), hts[D+edge_offset], Uhash)
                 then () = if test_verbose
			   then prints("unitary to ht ",hts[D+edge_offset],
		      	      		" face counts to dim ",D+1,
				": ", for list in LFDKH do #list od)
			   fi
                 then ()= D:=D+1
                 in ()
     	     od{end of D while loop}
    in ()
    fi {quick_flag}
    {now have faces of all dims, to height hts[Dlast]}
    then () = ICPNU_flag:=ICPNU_flag_hold
    then () = if hts[Dlast].<
    	      then return for list@d in LFDKH
		     	  do for v in list
			     do parameter(x,lambda, face_bary(Lvd, v[:d+1]))
			     od
		     	  od.##
	       fi {now hts[Dlast] > 0}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then () = if test_verbose then prints(sum(for list in LFDKH do #list od),
	      	      	   " unitary candidates in ",#eq," equivalence classes.") fi
    then () = long_out_flag := long_out_temp_flag
    then start = elapsed_ms(), pmin = parameter(x,lambda,0*lambda)
    {then () = for j:2 do prints(LFDKH[j]) od}
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, Uhash, fancy_tester)
    	 {possibly put some bottom layer stuff??}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    in UParams

set local_test_GEO_hash_no_dumb(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, [int] hts, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash_no_dumb(x, lambda, Lvd, LF, hts, pol_hash, Uhash,
    is_unitary_hash_big_SIMPLE@Param)

{Assume we have local vertices and edges LF, already herm, Dirac, pos on LKTs}
set local_test_GEO_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsIndex]] LF,
    KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let (G,j0) = %x, thetaMinus = x.involution - 1
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if {EMPTY CASE} #LF[0] = 0 then return [] fi
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution - 1) {, NK = #KGB(G)}, step = max(G.semisimple_rank\2,1)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then if test_verbose
	      	   then prints("few vertices; reverting to hash_dumb")
		   fi;
	     	   return local_test_GEO_hash_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
		   {use real_dumb if real_flag, def_dumb if def_flag}
	      fi
    then edge_offset_temp = edge_offset
    then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi
    {then depth= max(r,2)}
    then depth= max((r-1)*edge_skip + edge_offset_temp + 3, edge_skip + edge_offset_temp + 3)
    in [Param]: let {maxDiffLoc = max_loc(for v in Lvd.list
    	       		    do G.two_rho_check*(dominant(G,thetaMinus*v))
		       		    od)
    	      	then pmax = first_param(finalize(parameter(x, lambda, Lvd.list[maxDiffLoc])))}
		     pmax = pmax(x, lambda, Lvd)
		then Shorthts = if short_hts_flag
		     	      	then short_hts(pmax)
		     	      	else next_heights(pmax,depth)
				fi
    	      	then () = if #Shorthts < depth and revert_flag
		     	  then return local_test_GEO_hash_else_dumb(x, lambda,
    	      	 	     Lvd, LF, Shorthts[:min(1,#Shorthts)], pol_hash, Uhash, fancy_tester)
	      		  fi
		then () = test_string:= " using local_test_GEO_hash"
		then () = if test_verbose then prints("Chose",test_string) fi
    	        then hts = [int]:
		     let d0 = min(#Shorthts, depth)
		     in Shorthts[:d0] ## for j:depth-d0 do -1 od
    	      	in local_test_GEO_hash_no_dumb(x, lambda, {vd,} Lvd, LF, hts,
	      	 pol_hash, Uhash)

set local_test_GEO_hash(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    {let () = adjust_global_top(x.inner_class)}
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO_hash(KGBElt x, ratvec lambda, VertexData vd, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO_hash(KGBElt x, ratvec lambda, KTypePol_hash pol_hash, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash, fancy_tester)

set local_test_GEO(KGBElt x, ratvec lambda, (Param->bool) fancy_tester) =
    [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form), G = x.real_form, pol_hash = make_KTypePol_hash()
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash(x,lambda, pol_hash, Uhash, fancy_tester)

set local_test_GEO(KGBElt x, ratvec lambda) =
    [Param]:
    local_test_GEO(x, lambda, is_unitary_hash_big_SIMPLE@Param)

{set hash2Counter = make_counter()}

{fraction of r to use as multiple of edge_skip}
{set hash2_frac = 1/4}

set up_shift = int: 0

{This version assumes edges and vertices already computed, with herm and pos on LKTs; called by one_level}
{Local data assumed to have red_count coords if red_count_flag = true}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) =
    [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = 1-x.involution, start = elapsed_ms()
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if 1*pmin = zero_pol then return [] fi
    then r = rank(x.involution -1), step = max(G.semisimple_rank\2,1)
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash) 
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    {then edge_offset_temp = edge_offset}
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom {keeping this reduced #tests by 1/4}
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then if test_verbose
	      	   then prints("few vertices; reverting to hash_dumb")
		   fi;
		   return local_test_GEO_hash_dumb(x, lambda, {vd,} Lvd,
	      	   	  	   LF, pol_hash, Uhash, fancy_tester) {use def_dumb if def_flag}
	      fi
    then depth= max(r,2)*edge_skip + edge_offset
    then pmax = pmax(x, lambda, Lvd)
    then (LAMmax,NUmax,GAMmax) = low(pmax)
    then hts =[int]: let Shorthts = if short_hts_flag {guaranteed to be size depth}
    	     	     	 	    then short_hts(pmax)
				    else next_heights(pmax,depth)
				    fi
    		     then () = if #Shorthts < depth and revert_flag
			       then return local_test_GEO_hash_else_dumb(x, lambda, Lvd, LF,
			       	    	 Shorthts[:min(#Shorthts,1)], pol_hash, Uhash, fancy_tester)
			       fi
    		     then d0 = min(#Shorthts, depth)
		     in Shorthts[:d0] ## for j:depth-d0 do Shorthts~[0]+j+1 od
    then () = test_string:= " using local_test_GEO_hash2"
    then () = if test_verbose then prints("Chose",test_string) fi
    then  () = hash2Counter.use()
    then Dlast = #hts - 1, Dmid = #hts\2
    then () = if (test_verbose) then prints("heights = ", hts){, ", test heights = ",test_hts)} fi
    {get K-type formulas for all vertices and edges}
    then startDBTcount = DBTcount
{for E8_s, K-chars to height test_hts[0] = 68 is 2.5 days. So maybe just hts[0]?}
    then fakeLF = [[vec]]: [[],[]]
    then ((eqred,grred),IUCLred,CLBFred) = if red_count_flag and #LF > 1
    	 		       then localGraphRedLong(LF)
			       else localGraphRedLong(fakeLF)
			       fi
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then if dry_flag
		      then localFD_KHash_01_graph_dry(x,lambda,Lvd, pol_hash, LF, eqred,CLBFred)
		      else localFD_KHash_01_graph(x,lambda,Lvd, hts[edge_offset], pol_hash, LF, eqred,CLBFred)
		      fi
    	       	 else localFD_KHash_01(x, lambda, Lvd, hts[edge_offset], pol_hash, LF)
		 fi {red_count_flag}
    {then () =  if test_verbose then prints("face counts to dim 1: ",
                          for list in LFDKH do #list od, "; Dirac_best eliminated ",
			      DBTcount - startDBTcount) fi}
        {compute graph on faces to dim 1, to hts[edge_offset]}
    then ((eq,gr),IUCL,CLBF) = if dry_flag
    	      		       then ((eqred,grred),IUCLred,CLBFred)
			       else localGraphK(LFDKH, pol_hash, hts[edge_offset])
	      		       fi
    {then () = if test_verbose then prints("LFDKH[0] = ",LFDKH[0]); prints("LFDKH[1] = ",LFDKH[1]) fi}
    then () = if test_verbose
    	      then if dry_flag
	      	   then prints("using dry_flag, ",#eq," equiv classes of faces")
		   else prints("at height ",hts[edge_offset],", ",#eq," equiv classes of faces")
		   fi
	      fi
    {then () = prints("trial of eq at dim 1 is ",trial(x,lambda,Lvd,LFDKH, eq, hts[edge_offset]))}
 {because of to_ht, CANNOT use ICPNU testing ???}
    then ICPNU_flag_hold = ICPNU_flag
    then () = ICPNU_flag:=false
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, (Param->bool):(Param p):
    	      	    is_unitary_to_hts_big_SIMPLE(p, hts[:edge_offset+1]), hts[edge_offset], Uhash, fancy_tester)
    {then () = prints("LFDKH before extend = ",LFDKH)}
    then () = if test_verbose
    	      then prints("unitary to ht ", hts[edge_offset],
                        " face counts to dim 1: ",for list in LFDKH do #list od
			,"; Dirac_best eliminated ", DBTcount - startDBTcount)
	      fi
    then wiggle_flag_hold = wiggle_flag
    then () = wiggle_flag:=false
    then () = if quick_flag
    	      then let () = LFDKH:= extend_K_characters(x, lambda, Lvd, LFDKH, hts[Dmid], pol_hash)
		       	    {now pol_hash has K-chars to hts[Dmid]}
		   then () = if one_two_reverse_flag
    	      	   	     then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      		     fi
		   then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2, r+1,
	      	       	    	     hts[Dmid], pol_hash)
	           then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, hts[Dmid])
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd,
                      LFDKH, eq, gr, CLBF, (Param->bool): (Param p): is_unitary_to_hts_big_SIMPLE(p,hts[:Dmid+1])
		      	,hts[Dmid], Uhash, fancy_tester)  {test to the same height as not quick}
		   in if test_verbose
		      then prints("unitary to ht ",hts[Dmid],
		      	      		" face counts to dim ",r,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
     		   then () = while (D <= r - 1  ) and (#LFDKH = D + 1) and (#(LFDKH~[0]) > D+1)
    		   	{can't omit middle because LFDKH is truncated!}
    			{step D in while loop adds faces of dim D+1; then does is_unitary_to_ht on
    			 faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    			 D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      	 	     do  let HD = hts[D*edge_skip + edge_offset]
			     	 then () = LFDKH:= extend_K_characters(x, lambda, Lvd, LFDKH, HD, pol_hash)
		      		     	{now pol_hash has K-chars to HD}
		 		  then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, D+1,D+2,
				       	    HD, pol_hash)
	         			    {then () = if D=1 then prints(LFDKH[2]) fi}
				  then () = if one_two_reverse_flag
    	      			       	    then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      				    fi
		       	       	  then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, HD)
       	      	 		       {compute graph on faces to dim D+1}
		 		  then () = LFDKH := local_testK_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF,
		 		       	  (Param->bool):(Param p): is_unitary_to_hts_big_SIMPLE(p,
					  hts[:D*edge_skip + edge_offset+1] {HD})
					  , hts[D*edge_skip +edge_offset], Uhash, fancy_tester)
		 		  then () = if test_verbose
		     	   	  then prints("unitary to ht ",HD , " face counts to dim ",D+1,
				       ": ", for list in LFDKH do #list od) fi
                 		  then ()= D:=D+1
		 		  in ()
     	     		      od
     	     	    in ()
     	     fi{quick_flag}
    {now have faces of all dims, unitary to height hts[Dlast] or hts[Dmid]}
    then () = if one_two_reverse_flag
    	      then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      fi
    then () = LFDKH := extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
    then () = ICPNU_flag:= ICPNU_flag_hold
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    {then () = prints("last eq = ",eq)}
    {term on left guaranteed <= right term on right. If close, then
    	       params are close to spherical princ series, and to_ht is fast}
    then () = if test_verbose
    	      then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   prints("using is_unitary_tester_big_SIMPLE_interrupt")
	      fi
    then mu_tester(Param p) = bool: is_unitary_test_big_SIMPLE_interrupt(p, hts[min(Dlast,Dmid)+1:])
    then start=elapsed_ms() {already unitary to height hts[Dlast] = hts[max(r,2)]}
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		 if test_interrupt_flag {up_mu_flag}
		 then mu_tester(p)
		 else is_unitary_hash_big_SIMPLE(p)
		 fi, Uhash)
    {Maybe NEED TO PUT BOTTOM LAYER STUFF BACK}
    then () = wiggle_flag:=wiggle_flag_hold
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    in UParams

set local_test_GEO_hash2_end(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH,
    			KTypePol_hash pol_hash, int HK_known, Param_hash Uhash,
			(Param->bool) fancy_tester) = [Param]:
    let G = x.real_form, r = rank(x.involution -1), thetaMinus = 1-x.involution
    then vertexDiff = #LFDKH[0]/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom {keeping this reduced #tests by 1/4}
    then depth= max(r,2)*edge_skip + edge_offset
    then pmax = pmax(x, lambda, Lvd)
    then (LAMmax,NUmax,GAMmax) = low(pmax)
    {then () = to_ht_flag := if prefer_diff_flag
    	      		    then LAMmax < (GAMmax - LAMmax)*diff_frac
    			    elif prefer_gamma_flag
    	 	       	    then LAMmax < GAMmax*gamma_frac
		       	    else LAMmax*low_frac < NUmax
		       	    fi {false means is_unitary_to_ht is never a good idea}}
    {then gammamax = pmax.infinitesimal_character}
    {then mu = K_type(x,pmax.lambda_minus_rho)}
    then hts =[int]: let Shorthts = if short_hts_flag {want hts guaranteed to be size depth}
    	     	     	 	    then short_hts(pmax)
				    else next_heights(pmax,depth)
				    fi
    		     then d0 = min(#Shorthts, depth)
		     in Shorthts[:d0] ## for j:depth-d0 do Shorthts~[0] + j+1 od
    {then () = test_string:= " using local_test_GEO_hash2end"}
    {then  () = hash2Counter.use()}
    then D0 = edge_offset
    then ht0 = hts[edge_offset]
    then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts then is_unitary_to_hts_big_SIMPLE(p, hts[:D0+1])
	 	  else is_unitary_to_ht_big_SIMPLE(p,ht0)
	 	  fi
    then start_count = unitary_test_counter.use_count()
    {then () = prints("at (x,lambda) = (",x,",",lambda,"), pol_hash_min.list() is ",pol_hash_min.list())}
    then () = if ht0 > HK_known
    	      then {let () = prints("lambda = ",lambda,", one_ht = ",one_ht,", HK_known = ",HK_known)}
	      	   {let () = pol_hash_min.clear()
	      	   in} LFDKH := extend_K_characters(x,lambda,Lvd,LFDKH,ht0,pol_hash)
	      fi
    {then () = prints("after extend, pol_hash_min.list() is ",pol_hash_min.list())}
{eliminate vert/edges not unitary to ht0}
    then () = if one_two_reverse_flag
    	      then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      fi
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, ht0)
{because of to_ht, CANNOT use ICPNU testing??}
    then ICPNU_flag_hold = ICPNU_flag
    then () = ICPNU_flag:=false
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, tester1, ht0, Uhash, fancy_tester)
    then wiggle_flag_hold = wiggle_flag
    then () = wiggle_flag :=false
    then () = if test_verbose then prints("unitary to ht ", ht0,
                        " face counts to dim 1: ",for list in LFDKH do #list od)
			{,"; Dirac_best eliminated ", DBTcount - startDBTcount)} fi
    then Dlast = #hts - 1, Dmid = #hts\2
    then () = if quick_flag
    	      then let () = LFDKH := extend_K_characters(x, lambda, Lvd, LFDKH, hts[Dmid], pol_hash)
	      	   then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2, r+1, hts[Dmid], pol_hash)
		   then () = if one_two_reverse_flag
    	      	   	     then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      		     fi
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,hts[Dmid])
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		      is_unitary_to_hts_big_SIMPLE(p,hts[edge_offset+1:Dmid+1]), hts[Dmid], Uhash, fancy_tester)
                   in if test_verbose
		      then prints("unitary to ht ",hts[Dmid],
		      	      		" face counts to dim ",r,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
     then () = while (D <= r - 1  ) and (#LFDKH = D + 1) and (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let HD = hts[D*edge_skip + edge_offset]
	      	 then () = LFDKH:= extend_K_characters(x, lambda, Lvd, LFDKH, HD, pol_hash)
		 then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, D+1,D+2,
		      	   HD, pol_hash)
	         {then () = if D=1 then prints(LFDKH[2]) fi}
		 then () = if one_two_reverse_flag
    	      	      	   then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      		   fi
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, HD)
       	      	 {compute graph on faces to dim D+1}
		 {then () = prints("trial of eq at dim ",D+1," is ",
		 trial(x,lambda,Lvd,LFDKH, eq, hts[D+edge_offset]))}
		 then () = LFDKH := local_testK_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool):(Param p):
		 is_unitary_to_ht_big_SIMPLE(p,HD), HD, Uhash, fancy_tester)
		 then () = if test_verbose
		     	   then prints("unitary to ht ",HD, " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
		 {then ()= Dmid:=D}
                 then ()= D:=D+1
		 in ()
     	     od
     in ()
     fi{quick_flag}
    {now have faces of all dims, to height hts[Dmid] or hts[Dlast]}
    then () = if one_two_reverse_flag
    	      then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      fi
    then () = LFDKH := extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
    then () = ICPNU_flag:= ICPNU_flag_hold
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then () = if test_verbose
    	      then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   prints("using is_unitary_tester_big_SIMPLE_interrupt")
	      fi
    then mu_tester(Param p) = bool: is_unitary_test_big_SIMPLE_interrupt(p,hts[Dlast + 1:])
    then start=elapsed_ms() {already unitary to height hts[Dlast] = hts[max(r,2)]}
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		 if test_interrupt_flag {up_mu_flag}
		 then mu_tester(p)
		 else is_unitary_hash_big_SIMPLE(p)
		 fi, Uhash)
    {Maybe NEED TO PUT BOTTOM LAYER STUFF BACK}
    then () = wiggle_flag:=wiggle_flag_hold
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line) fi
    in UParams

set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash2(x, lambda, Lvd, LF, pol_hash, Uhash, is_unitary_hash_big_SIMPLE@Param)

{Compute 0 and 1 faces, pass to previous}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2) {impose Dirac, pos on LKTs}
	     else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)


{Compute 0 and 1 faces, ensuring hermitian, pos on LKTs, pass to previous}
set local_test_GEO_hash2(KGBElt x, ratvec lambda, VertexData vd, LocalVertexData Lvd, (vec,[(int,int)]) Perm2,
    vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash{, [[FaceVertsIndex]] global_faces}) = [Param]:
    let LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	     then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	     else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	     fi
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash2(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
    	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO2(KGBElt x, ratvec lambda) = [Param]:
    let Uhash = big_unitary_hash.uhash(x.real_form) {make_Param_hash()}, pol_hash = make_KTypePol_hash(), G = x.real_form
    {then vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash2(x,lambda,{vd,} pol_hash, Uhash)

{difficulty at which to revert to local_test_GEO_hash on each vertex.
0 to 100 make sense: higher means revert MORE often}
set diff_cutoff = int: 90

{0 to 10000 make sense. Setting to zero means NEVER revert to hash, and
10000 means always default}
set prod_cutoff = int: 3000

{for zeroth round on vertices/edges}
set zero_level = int: -1

{3 is best for F4_s spherical
4 or 5 best for E7_s spherical}
set one_level = int: -1

{after unitary to one_level are found, run unitary_test(p, heights
from one_level+1 to last_level) to speed elimination of nonunitary. Need
to have last_level \ge one_level}
set last_level = int: -1

{set hash_one_levelCounter = make_counter()}

{assume local faces to dim 1 are recorded in LF, already herm and pos on LKTs}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, {VertexData vd,}
    LocalVertexData Lvd, [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms()
    then () = if quick_flag then short_hts_flag:=false fi
    then zero_pol = null_module(G), pmin = parameter(x,lambda,0*lambda)
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then () = if 1*pmin = zero_pol then return [] fi
    then () = if {TINY CASE} #LF[0]=1
    	      then if mix_flag
	      	   then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF[0][0][0]]),
		   	       {[height(pmin) + more_shift_level],} Uhash)
		   else return one_param_test(parameter(x,lambda,Lvd.list[LF[0][0][0]]), Uhash)
		   fi
	      fi
    then pmax = pmax(x,lambda,Lvd)
    then (LAMmax,NUmax,GAMmax) = low(pmax)
    then vertexDiff = #Lvd.list/#FPP_vertices(G){vd.list}
    then approxVertexDiff = vertexDiff.numer*100\vertexDiff.denom
    then () = if approxVertexDiff < vert_diff_cutoff and revert_flag
    	      then if test_verbose
	      	   then prints("few vertices; reverting to hash_dumb")
		   fi;
	      	   return local_test_GEO_hash_dumb(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
	      	   	  {use def_dumb if def_flag}
	      fi
    then r = rank(thetaMinus)
    then ZERO = if step_flag
    	      	then if zero_level = -1
		     then 0
    	       	     else zero_level
		     fi
		else -1
	        fi

    then ONE = if one_level = -1 then edge_offset
    	       	  	    {max(edge_offset + edge_skip, (r+2)\2)}
    	       else one_level
	       fi
    {then LAST = if last_level = -1 then ONE+edge_skip
    	      else last_level
	      fi}
    {if LAST = ONE, then final step should be _just_ is_unitary}
    { then () = prints("ONE = ",ONE,", LAST = ",LAST) }
    {then} {edge_offset_temp = edge_offset,} {step = max(G.semisimple_rank\2,1)}
    { then () = if edge_offset = -1
    	      then edge_offset_temp := r\2 {3 seems best for F4}
	      fi}
     then Shorthts = if short_hts_flag
    	 	    then short_hts(pmax)
		    else next_heights(pmax,ONE+1)
		    fi
    then hts =[int]: let () = if #Shorthts < ONE+1 and revert_flag
    	      		       then return local_test_GEO_hash_else_dumb(x, lambda, Lvd, LF,
			       	    Shorthts[:min(1,#Shorthts)], pol_hash, Uhash, fancy_tester)
	      		       fi
		      then d0 = min(ONE+1,#Shorthts)
    		      in Shorthts[:d0] ## for j:ONE + 1 - d0 do Shorthts~[0]+j+1{-1} od
    {then () = prints({"depth = ",depth,} "#Shorthts = ",#Shorthts, ", LAST = ",LAST)}
    {then pol_hash0 = if step_flag
    	 	     then make_KTypePol_hash() {to hold chars to height hts[0]}
		     else pol_hash
		     fi}
    then approxMaxDiff = approxDiff(pmax)
    {then () = prints("approxMaxDiff = ",approxMaxDiff)}
    {now have at least two vertices. If it's an easy case,
    	 revert to local_test_GEO_hash}
    then () = if revert_flag and {(approxMaxDiff*approxVertexDiff < prod_cutoff) and}
    	      	 (approxMaxDiff < diff_cutoff)
	      then if test_verbose
		   then prints("approximate maximum difficulty = ", approxMaxDiff,"; reverting to hash_no_dumb")
		   fi;
		   return local_test_GEO_hash_no_dumb(x, lambda, Lvd,
	      	   	  LF, hts, pol_hash, Uhash)
    	      fi
    then () = test_string:= " using local_test_GEO_hash_one_level"
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then  () = hash_one_levelCounter.use()
    then zero_ht = if step_flag
    	 	   then hts[ZERO]
		   else 0
		   fi
    then one_ht = hts[ONE] {, last_ht = hts[LAST]}
    then () =  if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints(if step_flag
		  	 then "zero level = "+to_string(ZERO)+", "
			 else ""
			 fi, "testing level = ", ONE, {", final level = ",LAST,}
			 "; heights = ", hts, new_line)
	       fi
   then ICPNU_flag_hold = ICPNU_flag
   then () = ICPNU_flag:=false
   then HT = height(pmin)
   then long_out_temp_flag = long_out_flag
   then () = long_out_flag:=false
   then startDBTcount = DBTcount
   then LFDKH = if step_flag
   	      	then let ans = [[FaceVertsKHash]]:
   	   	     	 if red_count_flag and #LF[1] > 0
    	 	     	 then let (eq,CLBF) = localGraphRed(LF)
	      	     	      in localFD_KHash_01_graph(x, lambda, Lvd, zero_ht,
			      	 pol_hash,LF, eq,CLBF)
    	 	     	 else localFD_KHash_01(x, lambda, Lvd, zero_ht, pol_hash, LF)
	 	     	 fi {red_count_flag}
    	   	     then tester0 = if prefer_to_hts
    	 	     	       then (Param->bool): (Param p) bool:
     	     	   	       	    is_unitary_to_hts_big_SIMPLE(p, hts[:ZERO+1])
		   	       else (Param->bool): (Param p) bool:
     	     	   	       	    is_unitary_to_ht_big_SIMPLE(p, zero_ht)
		   	       fi {prefer_to_hts}
    	             then ((eq,gr),IUCL,CLBF) = localGraphK(ans, pol_hash, zero_ht)
              	     {then () = prints("at hts[edge_offset], #eq = ", #eq)}
    	      	     then () = ans := local_testK_hash(x,lambda, Lvd, ans, eq,
		      			gr, CLBF, tester0, zero_ht, Uhash, fancy_tester)
	     	     {now we've tested verts and edges to hts[ZERO]}
    		     then () = if test_verbose then prints("unitary to ht ",zero_ht,
		   	       	  " face counts to dim 1: ",for list in ans do #list od)
			       fi
		     in extend_K_characters(x, lambda, Lvd, ans, one_ht, pol_hash)
		 else if red_count_flag and #LF[1] > 0
    	 	      then let (eq,CLBF) = localGraphRed(LF)
	      	     	   in localFD_KHash_01_graph(x, lambda, Lvd, one_ht,
			      pol_hash,LF, eq,CLBF)
    	 	      else localFD_KHash_01(x, lambda, Lvd, one_ht, pol_hash, LF)
	 	      fi {red_count_flag}
	          fi {step_flag}
    then tester1 = (Param->bool): (Param p) bool:
     	     	   if prefer_to_hts then is_unitary_to_hts_big_SIMPLE(p, hts[ZERO+1:ONE+1])
	 	   else is_unitary_to_ht_big_SIMPLE(p,one_ht)
		   fi {to_ht is definitely 2% slower for F4 spherical,
		       10% slower for Sp(10) spherical}
    then () = if one_two_reverse_flag
    	      then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      fi
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, one_ht)
    then () = LFDKH := local_testK_hash(x,lambda, Lvd, LFDKH, eq,
		      			gr, CLBF, tester1, one_ht, Uhash, fancy_tester)
	      {now we've tested verts and edges to one_ht}
    then () = if test_verbose then prints("unitary to ht ",one_ht,
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	   fi
{ Have faces to dim 1 unitary to one_ht. Seek to extend list to all higher dims }
     then () = if quick_flag
    	       then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   	  		LFDKH, 2,r+1, pol_hash)
			    		    {now top degree in LFDKH is D+1}
		    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
		    in LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, tester1, one_ht,
		    Uhash, fancy_tester)
	      else let D = int:1
     	      	   then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht(one_ht) on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd,
                       	  	   	LFDKH, D+1,D+2, one_ht, pol_hash)
		    {now top degree in LFDKH is D+1}
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
       	      	 {compute graph on faces to dim D+1}
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(parameter(x, lambda,
					  face_bary(Lvd, verts))))
			      in if all(for p in ps
					do Uhash.lookup(p).>= or tester1(p)
	{is_unitary_to_ht_big_SIMPLE(p,one_ht)}
	{better to use to_ht because usually p _already_ unitary below one_ht}
					od)
				 then [LFDKH[D+1][m]]
					     else []
				 fi {all p in ps}
			  fi {#eq[j] > 1}
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
                 then () = if test_verbose and ((D = r-1)  or (#LFDKH < D) or
		      	      (#(LFDKH~[0]) <= D+2))
			   then prints("unitary to ht ",one_ht,
		      	      		   " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od)
			    fi {test_verbose}
                 then ()= D:=D+1
                 in ()
     	      od {while D <= r - 1}
	      in ()
	      fi{quick_flag}
    then long_out_temp_flag = long_out_flag
    then () = ICPNU_flag:= ICPNU_flag_hold
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then () = if test_verbose then { prints("unitary to ht ",one_ht, " faces by dim = ",
       	       	   		      		      unitary_by_dim);}
		prints("number of tests so far = ",unitary_test_counter.use_count() - start_count)
	      fi
    then () = if one_two_reverse_flag
    	      then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      fi
    then () = LFDKH := extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash)
    {anti_sort(x.real_form, Lvd, extend_K_characters(x, lambda, Lvd, LFDKH, pol_hash))} {this is worse in spherical E7_s}
    then start=elapsed_ms()
    then () = long_out_flag := long_out_temp_flag
    {then mu = K_type(x, pmax.lambda_minus_rho) {LKTs(pmax)[0]}}
    then mu_tester(Param p) = bool: is_unitary_test_big_SIMPLE_interrupt(p,hts[ONE+1:])
    {then () = if test_verbose then prints("one_ht = ",one_ht) fi}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then UParams = local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p):
		 if test_interrupt_flag {up_mu_flag}
		 then mu_tester(p)
		 else is_unitary_hash_big_SIMPLE(p)
		 fi, Uhash)
    {then UParams = [Param]:
         if one_ht >=  0
         then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	      then () = if test_verbose then prints(sum(for list in LFDKH do #list od),
	      	      	   " unitary candidates in ",#eq," equivalence classes.") fi
              in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool):(Param p):
		      		    if test_interrupt_flag {up_mu_flag}
				    then mu_tester(p)
				    elif prefer_to_hts
		      		    then is_unitary_test_big_SIMPLE(p,hts[ONE+1:])
				    else is_unitary_test_big_SIMPLE(p,hts[LAST])
		      		    fi, Uhash)
		       {NEED PERHAPS TO PUT BOTTOM LAYER BACK}
          else for list@d in LFDKH
               do for v in list
                  ~do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		     then () = for  p1 in monomials(finalize(p))
                      	       do Uhash.match({herm_center(}p1{)});
                             	  if deform_flag
			     	  then for q in facet_deformed_new(p1)
                             	       do Uhash.match({herm_center(}q{)})
				       od
			     	  fi
                             	  od
		     then () = if long_out_flag
		      	       then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	    then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				    in ()
			       fi
		     in p
                  od
                od.##
	 fi}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line)
	      fi
   in UParams {local_test_GEO_hash_one_level}
   {fi}

set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash_one_level(x, lambda, Lvd, LF, pol_hash, Uhash,
    is_unitary_hash_big_SIMPLE@Param)

{JUST CALCULATE FIRST TWO LEVELS}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash{,
    [[FaceVertsIndex]] global_faces}) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    in local_test_GEO_hash_one_level(x, lambda, Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, KTypePol_hash pol_hash,
    Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    {then () = adjust_global_top(G)}
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2)
	      	   {computes edges and verts, imposing hermitian and Dirac}
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2)
	      fi
    in local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_one_level(KGBElt x, ratvec lambda) = [Param]:
    let G = x.real_form
    then Uhash = big_unitary_hash.uhash(x.real_form){make_Param_hash()}, pol_hash = make_KTypePol_hash()
    {, vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_one_level(x,lambda,{vd,} pol_hash, Uhash)

{to be called by bottom_layer after bottom layer arguments. Hash has K-chars to height HK_known}
set local_test_GEO_hash_one_level_end(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH,
    			KTypePol_hash pol_hash, int HK_known, Param_hash Uhash,
			(Param->bool) fancy_tester) = [Param]:
    let G = x.real_form, r = rank(x.involution -1), thetaMinus = 1-x.involution
    then ONE = if one_level = -1 then edge_offset {+ max(1, (r+2)\2)*edge_skip}
    	       else one_level
	       fi
    {then LAST = if last_level = -1 then ONE + edge_skip
    	      else last_level
	      fi}
    then long_out_temp_flag = long_out_flag
    then () = long_out_flag:=false {to allow using local_test_hash without recording Params}
    then pmax = pmax(x, lambda, Lvd)
    then mu = K_type(x,pmax.lambda_minus_rho)
    then (LAMmax,NUmax,GAMmax) = low(pmax)
    then hts =[int]: let Shorthts = if short_hts_flag {guaranteed to be size ONE+1}
    	     	     	 	    then short_hts(pmax)
		     	      	    else next_heights(pmax,ONE+1)
				    fi
    		     then d0 = min(#Shorthts, ONE+1)
		     in Shorthts[:d0] ## for j:ONE+ 1 - d0 do Shorthts~[0]+j+1 od
    {then () = prints("depth = ",depth, ", #Shorthts = ",#Shorthts, ", ONE = ",ONE)}
    then one_ht = hts[ONE]
    then tester1 = (Param->bool): (Param p) bool:
     	     	  if prefer_to_hts then is_unitary_to_hts_big_SIMPLE(p, hts[:ONE+1])
	 	  else is_unitary_to_ht_big_SIMPLE(p,one_ht)
	 	  {to_ht is definitely 2% slower for F4 spherical, 10% slower for Sp(10) spherical}
	 	  fi
    then start_count = unitary_test_counter.use_count()
    {then () = prints("at (x,lambda) = (",x,",",lambda,"), pol_hash_min.list() is ",pol_hash_min.list())}
    then () = if one_ht > HK_known
    	      then {let () = prints("lambda = ",lambda,", one_ht = ",one_ht,", HK_known = ",HK_known)}
	      	   {let () = pol_hash_min.clear()
	      	   in} LFDKH := extend_K_characters(x,lambda,Lvd,LFDKH,one_ht,pol_hash)
	      fi
    {then () = prints("after extend, pol_hash_min.list() is ",pol_hash_min.list())}
    {to_ht invalidates ICPNU???}
    then ICPNU_flag_hold = ICPNU_flag
    then () = ICPNU_flag :=false
{eliminate vert/edges not unitary to one_ht}
    then () = if one_two_reverse_flag
    	      then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      fi
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, one_ht)
    then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, tester1, one_ht, Uhash, fancy_tester)
    then () = if test_verbose then prints("unitary to ht ", one_ht,
                        " face counts to dim 1: ",for list in LFDKH do #list od)
			{,"; Dirac_best eliminated ", DBTcount - startDBTcount)} fi

    then () = if quick_flag
    	      then let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
                                r + 1, one_ht, pol_hash)
	           then () = if one_two_reverse_flag
    	      	   	     then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      		     fi
		   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash, one_ht)
		   then () = LFDKH := local_testK_hash(x,lambda,Lvd, LFDKH, eq, gr, CLBF, (Param->bool):
		   (Param p): tester1(p),
		      one_ht, Uhash, fancy_tester)
		      	{test to the same height as not quick}
                   in if test_verbose
		      then prints("unitary to ht ",one_ht,
		      	      		" face counts to dim ",r,
				": ", for list in LFDKH do #list od)
		      fi
	      else let D = int:1
     then () = while (D <= r - 1  ) and
    	      	    (#LFDKH = D + 1) and
		    (#(LFDKH~[0]) > D+1)
    {can't omit middle because LFDKH is truncated!}
    {step D in while loop adds faces of dim D+1; then does is_unitary_to_ht(one_ht) on
    faces of dim D+1; then adds faces of dim D+2, etc. If there are less than
    D+2 possibly unitary faces of dim D, then none of dim D+1.}
    	      do let () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda,Lvd, LFDKH,D+1,D+2,one_ht, pol_hash)
		    {now top degree in LFDKH is D+1}
		 then () = if one_two_reverse_flag
    	      	      	   then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      		   fi
		 then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,pol_hash,one_ht)
		    	 {compute graph on faces to dim D+1}
		 then newDplus1 = [vec]: for j@m in CLBF[D+1]
		      {D+1-diml face #m belongs to class j}
		      do if #eq[j] > 1
		      	 then [LFDKH[D+1][m]]
		         else let verts = vec: LFDKH[D+1][m][:D+2]
			      {should insert Uhash.lookup(p).>=
			      Actually this has no effect in SO(4,4)}
			      then ps = monomials(finalize(
					  parameter(x, lambda,
					  face_bary(Lvd, verts))))
					  in if all(for p in ps
					     	    do Uhash.lookup(p).>= or
						       tester1(p)
						    od)
					     then [LFDKH[D+1][m]]
					     else []
					     fi
			  fi
		       od.##
		 then () = LFDKH := LFDKH[:D+1] # newDplus1
                 then () = if test_verbose and
		      	   ((D = r-1)  or
    	      	    	   (#LFDKH < D) or
		    	   (#(LFDKH~[0]) <= D+2))
			   then prints("unitary to ht ",one_ht,
		      	      		   " face counts to dim ",D+1,
				": ", for list in LFDKH do #list od) fi
                 then ()= D:=D+1
                 in ()
     	      od
	      in ()
	      fi{quick_flag}
    {now LFDKH is everything unitary to ht one_ht}
    then () = ICPNU_flag:= ICPNU_flag_hold
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then () = if test_verbose then { prints("unitary to ht ",one_ht, " faces by dim = ",
       	       	   		      		      unitary_by_dim);}
		prints("number of tests so far = ",unitary_test_counter.use_count() - start_count)
	      fi
    then mu_tester(Param p) = bool: is_unitary_test_big_SIMPLE_interrupt(p, hts[ONE+1:])
    then start=elapsed_ms()
    then () = long_out_flag := long_out_temp_flag
    {then () = if test_verbose then prints("one_ht = ",one_ht) fi}
    then UParams = [Param]:
         if one_ht >=  0
         then let () = LFDKH := extend_K_characters(x,lambda,Lvd,LFDKH,pol_hash)
	      then () = if one_two_reverse_flag
    	      	      	then LFDKH := for list in LFDKH do [vec]: for v in list ~do v od od
	      		fi
	      then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	      then () = if test_verbose then prints(sum(for list in LFDKH do #list od),
	      	      	   " unitary candidates in ",#eq," equivalence classes.") fi
              in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool):(Param p):
	      	 		    {if test_interrupt_flag {up_mu_flag} and prefer_to_hts
				    then is_unitary_test_big_SIMPLE_interrupt(p,[hts[ONE])
		      		    el}if test_interrupt_flag
				    then is_unitary_test_big_SIMPLE_interrupt(p,[hts[ONE]])
				    {elif prefer_to_hts
				    then is_unitary_test_big_SIMPLE(p,hts[ONE+1:])}
				    else is_unitary_hash_big_SIMPLE(p)
		      		    fi, Uhash)
          else for list@d in LFDKH
               do for v in list
                  do let p = parameter(x,lambda, face_bary(Lvd, v[:d+1]))
		     then () = for  p1 in monomials(finalize(p))
                      	       do Uhash.match({herm_center(}p1{)});
                             	  if deform_flag
			     	  then for q in facet_deformed_new(p1)
                             	       do Uhash.match({herm_center(}q{)})
				       od
			     	  fi
                             	  od
		     then () = if long_out_flag
		      	       then let () = ParamsByDim[d] := ParamsByDim[d]#p
			   	    then () = LFDKHByDim[d] := LFDKHByDim[d]#v
				    in ()
			       fi
		     in p
                  od
                od.##
	 fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line)
	      fi
   in UParams {local_test_GEO_hash_one_level_end}

{when LKT length is GREATER than bottom_length_frac*(max possible), DO
NOT use bottom_layer. Leaving this at 1 means always use bottom_layer,
to negative means never bottom layer.}
{set bottom_length_frac = rat: 1}{??}

{if true, use coh_ind_is_unitary in final tests; else is_unitary}
set coh_ind_tester_flag = true

set one_level_revert_flag = true {false}

{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
{this version assumes more_flag, sets more_shift_level to bl_step_count*bl_step_size}
set local_test_GEO_hash_bottom_layer_interrupt(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash, (Param->bool) fancy_tester) =
    [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms(),
    	UTCstart = unitary_test_counter.use_count()
    then zero_pol = null_module(G)
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
    then r = rank(thetaMinus)
    then pmin = parameter(x, lambda, Lvd.list[LF[0][0][0]] )
    then (Q0, pminL0) =  if small_test_flag
    	 	      	 then theta_stable_data_small(pmin)
		   	 else theta_stable_quasi_data(pmin)
		   	 fi
    then L0 = Q0.Levi
    then () = if L0=G {fine K-type in quasisplit G}
    	      then if one_level_revert_flag
	      	   then if test_verbose
		   	then prints("L0=G; reverting to one_level")
			fi;
			return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else if test_verbose
		   	then prints("L0=G; reverting to hash2")
			fi;
			return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    {then htFrac = ht/FPP_max_ht}
    then () = more_shift_level:= bl_step_count*bl_step_size
    then () = if (x.involution - 1).= {is_abelian(L0)}
    	      then let () = Uhash.match({herm_center(}first_param(finalize(pmin{pmax}{)})))
	      	   in return [pmin]
	      fi
    then DG0 = if small_test_flag
    	       then minSmallBottomData.G_min_height(x,lambda)
	       else max(for mu in LKTs(pmin)
    	       	    	do minBottomData.G_min_height(mu)
		   	od)
	       fi
    then Ds = for j:bl_step_count+1 do let H = height(pmin) + j*bl_step_size
    	      	  		       in if H > FPP_max_ht then {prints("too big H = ",H,", x = ",x.number,
				       	  ", lambda = ",lambda);} break fi;
				          H
				    od
     	{these are the greatest heights at which we'll be looking at bottom layer K-types;
	 so we can compute K-chars just to this height} {NOT TRUE for good range arguments!}
     then () = if L0=G
    	      then if one_level_revert_flag
	      	   then if test_verbose
		   	then prints("L0=G; reverting to one_level")
			fi;
			return local_test_GEO_hash_one_level(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   else if test_verbose
		   	then prints("L0=G; reverting to hash2")
			fi;
			return local_test_GEO_hash2(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)
		   fi
	      fi
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test_min_bottom(pmin, Uhash)
	      fi
    then () = test_string:= " using local_test_GEO_hash_bottom_layer"
    then () = if test_verbose then prints("Chose",test_string) fi
    then  () = hash_bottom_layerCounter.use()
    then () =  if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing heights = ", Ds, new_line)
	       fi
    then startDBTcount = DBTcount
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, pol_hash, LF)
		  fi {red_count_flag}
    {then () = if test_verbose then prints(" face counts to dim 1: ",for list in LFDKH do
			     #list od, "; Dirac_best eliminated ",
			  DBTcount - startDBTcount)
		    	    fi}
{then LFDKH = [[FaceVertsKHash]]: localFD_KHash_01(x,lambda, Lvd, pol_hash, LF)}
   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   {remove all faces failing min_bottom_elim}
   then () = LFDKH := local_testK_hash_min_bottom_layer(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, height(pmin), {placeholder!} pol_hash,  Uhash, fancy_tester)
   then () = if test_verbose then prints("unitary on min_bottom layer face counts to dim 1: ",
   	for list in LFDKH do #list od) fi
   then () = if #LFDKH[0] = 0 then return [] fi
   then () = if #LFDKH[0] = 1 {not clear whether Ds help here; already passed min_bottom}
   	     then return if more_flag then one_param_test_bottom(parameter(x,lambda,
	     	  	    	      Lvd.list[LFDKH[0][0][0]]), Ds, Uhash)
	     	  	 else one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]),Uhash)
			 fi
	     fi
   then start_datas = elapsed_ms(), newDs = [int]:[]
   then MU = big_unitary_hash.branch(K_type_pol(pmin), Ds~[0])
   {then MU = K_type_pol(character_formula(}
   then datass =  for j:{bl_step_count} #Ds - 1 from 1
   	       	  do let datas = if Qs2_flag
		     	       	 then for mu in LKTs(pmin)
				      do if Qs2B_flag
		     	       	      	 then bottom_factors(bottom_K_type_Qs2B(mu,Q0, Ds[j-1], Ds[j]))
					 else for Q in max_Qs(Q0)
					      do bottom_K_type_Qs2(mu,Q, Ds[j-1], Ds[j])
					      od
					 fi {Qs2B_flag}
				       od.##
		  		 else bottom_factors(bottom_K_type_Qs(pmin, Q0, Ds[j-1], Ds[j]{, MU}))
				 fi {Qs2_flag}
		     {then () = prints("j = ",j,", card(datas) = ", card(datas),", datas = ",datas, new_line)}
		     in if max_ht(datas) > height(pmin) {card(datas) > 0}
		     	then newDs #:= Ds[j];
			     [datas]
		     	else []
			fi
		   od.##.##  {??? second ## should be removed, list structure USED ???}
   {then () = if test_verbose then prints("#datass = ",#datass, ", cardinalities = ", for datas in datass do card(datas) od) fi}
   then  maxQs = max_Qs(Q0)
   {next remove from LFDKH all faces failing bottom_factors_elim_factors_more}
   then () = if time_verbose then prints("time for more datass/maxQs was ",
    	      	 print_time_string(elapsed_ms() - start_datas), " at lambda = ",lambda)
	      fi
   {then m = 0, last = 0}
   then () = if #newDs > 0
   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   	     	  then () = LFDKH := local_testK_hash_bottom_layer_more(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, {maxQs,} datass, pol_hash, Uhash)
   		  then () = if test_verbose then prints("unitary on bottom layer to ",newDs~[0],
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	    fi
   	          then () = if #LFDKH[0] = 0 then return [] fi
   		  then () = if #LFDKH[0] = 1 {already passed newDs, so test_bottom useless}
   	     	       	    then return one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), Uhash)
	     		    fi
		  in ()
	      elif test_verbose
	      then prints("no more_bottom K-types")
	      fi
   then () = if test_verbose
   	     then prints("unitary on more_bottom layer face counts to dim 1: ",
   	     	  		  for list in LFDKH do #list od)
	     fi
   then DiffList = for v in LFDKH[0]
    	 	      do G.two_rho_check*(dominant(G,thetaMinus*Lvd.list[v[0]]))
		      od
   then maxDiffLoc = max_loc(DiffList), minDiffLoc = min_loc(DiffList)
{ Have faces to dim 1 bottom layer unitary to DG0. Seek to extend list to all higher dims }
  then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
       	    	     		r + 1, pol_hash)
    then unitary_by_dim = vec: for L in LFDKH do #L od
    {then gammamax = Lvd.list[LFDKH[0][maxDiffLoc][0]]}
    then steps = max(r-1,1)
    then start=elapsed_ms()
    {then test_heights = next_heights(pmin, steps)
    then j0 = if #newDs = 0
    	      then -1
	      else first(for m in test_heights do newDs~[0] < m od)
	      fi
    	 {so that we test above the height bottom layer has examined}
    then HT = if j0 = -1
    	      then test_heights~[0]
	      else test_heights[j0]
	      fi}
    {then () = prints("testing to ",HT)}
    then UParams = [Param]:
         let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	 {these have had know_lower, min_bottom, and bottom_elim
	 already applied; so just do is_unitary_test}
    	 then () = if test_verbose
    	      	   then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   	prints("number of tests so far = ",unitary_test_counter.use_count() - UTCstart);
		   	prints("testing with def level 1")
	           fi
    	 in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p) bool:
			       is_unitary_def_test_big_SIMPLE(p), Uhash)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      fi
   in UParams

set local_test_GEO_hash_bottom_layer_interrupt(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash_bottom_layer_interrupt(x, lambda, Lvd, LF, pol_hash, Uhash,
    is_unitary_hash_big_SIMPLE@Param)

{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
{this version tries various bl_step_count_shift_levels increasing by bl_step_size. Computes the branching stuff
only when the test is needed.}
set local_test_GEO_hash_bottom_layer_step(KGBElt x, ratvec lambda, {VertexData vd,}
    			LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH, KTypePol_hash pol_hash,
    			Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    {if {zero case} #LF[0] = 0 then return [] fi;}
    {if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;}
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms(),
    	UTCstart = unitary_test_counter.use_count()
    then zero_pol = null_module(G)
    then () = more_shift_level:= bl_step_count*bl_step_size
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
    then FPP_max_ht = (G.rho * G.two_rho_check)\1
    {then htFrac = ht/FPP_max_ht}
     then r = rank(thetaMinus)
    then pmin = parameter(x, lambda, Lvd.list[LFDKH[0][0][0]] )
    then (Q0, pminL0) = if small_test_flag
    	 	      	then theta_stable_data_small(pmin)
		   	else theta_stable_quasi_data(pmin)
		   	fi
    then L0 = Q0.Levi
    then DG0 = if small_test_flag
    	       then minSmallBottomData.G_min_height(x,lambda)
	       else max(for mu in LKTs(pmin)
    	       	    	do minBottomData.G_min_height(mu)
		   	od)
	       fi
    then Ds = for j:bl_step_count+1 do let H = ht + j*bl_step_size
    	      	  		       in if H > FPP_max_ht then {prints("too big H = ",H,", x = ",x.number,
				       	  ", lambda = ",lambda);} break fi;
				          H
				    od


   then start_datas = elapsed_ms(), newDs = [int]:[]
   then () = bl_KHash.clear() {= make_KType_hash()}
   then (trial, newDs) = add_datas(pmin, Q0, {KHash,} Ds{, MU})
   {then () = if time_verbose then prints("cardinalities = ",for datas in datass do card(datas) od) fi}
   {then  maxQs = max_Qs(Q0)}
   {next remove from LFDKH all faces failing bottom_factors_elim_factors_more}
   then () = if time_verbose then prints("time for more datass was ",
    	      	 print_time_string(elapsed_ms() - start_datas), " at lambda = ",lambda)
	      fi
   then () = if #trial> 0 {we found a nontrivial bottom layer argument}
   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
   	     	  then () = LFDKH := local_testK_hash_bottom_layer_more_step(x,lambda, Lvd, LFDKH, eq,
		      gr, CLBF, Q0, {maxQs,} trial, newDs, {MU,} pol_hash, Uhash, fancy_tester)
   		  then () = if test_verbose then prints("unitary on bottom layer to ",newDs~[0],
		   	   " face counts to dim 1: ",for list in LFDKH do
			     #list od)
		    	    fi
   	          then () = if #LFDKH[0] = 0 then return [] fi
   		  then () = if #LFDKH[0] = 1 {already passed Ds, so bottom_test useless}
   	     	       	    then return one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]), Uhash)
	     		    fi
		  in ()
	      fi
   then DiffList = for v in LFDKH[0]
    	 	      do G.two_rho_check*(dominant(G,thetaMinus*Lvd.list[v[0]]))
		      od
   then maxDiffLoc = max_loc(DiffList), minDiffLoc = min_loc(DiffList)
{ Have faces to dim 1 bottom layer unitary to DG0. Seek to extend list to all higher dims }
  then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LFDKH, 2,
       	    	     		r + 1, pol_hash)
    then unitary_by_dim = vec: for L in LFDKH do #L od
    then steps = max(r-1,1)
    then start=elapsed_ms()
    then UParams = [Param]:
         let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
	 {these have had know_lower, min_bottom, and bottom_elim
	 already applied; so just do is_unitary_test}
    	 then () = if test_verbose
    	      	   then prints(for list in LFDKH do #list od, " = ",sum(for list in LFDKH do #list od),
	      	      	" unitary candidates in ",#eq," equivalence classes.");
		   	prints("number of tests so far = ",unitary_test_counter.use_count() - UTCstart);
		   	prints("testing with def level 1")
	           fi
    	 in local_test_hash(x, lambda, Lvd, LFDKH, eq, gr, CLBF, (Param->bool): (Param p) bool:
			       is_unitary_def_test_big_SIMPLE(p), Uhash)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      " for UParams calculation ", test_string, new_line){;}
	      fi
   in UParams

set local_test_GEO_hash_bottom_layer_step(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    local_test_GEO_hash_bottom_layer_step(x, lambda, Lvd, LFDKH, pol_hash, Uhash,
    			is_unitary_hash_big_SIMPLE@Param)

{assume local faces to dim 1 are recorded in LF, already herm and pos
on LKTs. This version uses min_bottom_elim instead of
unitary_to_ht. Because of incorporation of good range nonunitarity proofs in min_bottom_elim,
MUST use full K-chars to compute graphs.}
set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,}
    			LocalVertexData Lvd, [[FaceVertsIndex]] LF, KTypePol_hash pol_hash,
    			Param_hash Uhash, (Param->bool) fancy_tester) = [Param]:
    if {zero case} #LF[0] = 0 then return [] fi;
    if {tempered case} #LF[0] = 1 and ((1-x.involution)*(Lvd.list[LF[0][0][0]])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    if bl_interrupt_flag
    then more_flag:=true;
    	 {more_shift_level:=bl_step_count*bl_step_size}
	 return local_test_GEO_hash_bottom_layer_interrupt(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash,
	 	fancy_tester)
    fi;
    let G = x.real_form, thetaMinus = x.involution - 1, start = elapsed_ms()
    then zero_pol = null_module(G)
    then () = if 1*parameter(x,lambda,0*lambda) = zero_pol then return [] fi
    then ht = height(parameter(x,lambda,0*lambda))
        then pmin = parameter(x, lambda, Lvd.list[LF[0][0][0]] )
    then (Q0, pminL0) = if small_test_flag
    	 	      	then theta_stable_data_small(pmin)
		   	else theta_stable_quasi_data(pmin)
		   	fi
    then L0 = Q0.Levi
    then () = if L0=G {fine K-type in quasisplit G}
    	      then if one_level_revert_flag
	      	   then if test_verbose
		   	then prints("L0=G; reverting to one_level")
			fi;
			more_after_flag:= false; min_after_flag:=false;
		   	return local_test_GEO_hash_one_level(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
		   else if test_verbose
		   	then prints("no min_bottom layer; reverting to hash2")
			fi;
			more_after_flag:=false; min_after_flag:=false;
		   	return local_test_GEO_hash2(x, lambda, Lvd, LF, pol_hash, Uhash, fancy_tester)
		   fi
	      fi
    then r = rank(thetaMinus)
    then () = if (x.involution - 1).=
    	      then let () = Uhash.match(first_param(finalize(pmin)))
	      	   in return [pmin]
	      fi
    then () = if {TINY CASE} #LF[0]=1
    	      then return one_param_test_min_bottom(pmin, Uhash)
	      fi
    {then () = prints("Got past one_param_test_all_bottom")}
    then LKDatas = if small_test_flag
    	 	   then minSmallBottomData.entry(x,lambda)
		   else for mu in LKTs(pmin)
			do minBottomData.entry(mu)
			od
		   fi
    then () = bl_KHash.clear()
    then () = for list in LKDatas do for (tau,) in list do bl_KHash.match(tau) od od
    then min_ht_max = max((for tau in bl_KHash.list() do height(tau) od)#height(pmin))
    then () = if min_ht_max= height(pmin) and not more_flag
   	      then if one_level_revert_flag
	      	   then if test_verbose
		   	then prints("no min_bottom layer; reverting to one_level")
			fi;
			return local_test_GEO_hash_one_level(x, lambda, Lvd, LF, pol_hash, Uhash,
		   	       fancy_tester)
		   else if test_verbose
		   	then prints("no min_bottom layer; reverting to hash2")
			fi;
			return local_test_GEO_hash2(x, lambda, Lvd, LF, pol_hash, Uhash,
		   	       fancy_tester)
		   fi
	      fi
    then pmax = pmax(x,lambda,Lvd)
    then gamma = pmax.infinitesimal_character
    then ht_max = ht + min([more_shift_level, floor(gamma* G.two_rho_check) - ht,
    	 floor(min_ht_mult*(min_ht_max - ht))])
    {then () = prints("Got past small LFDatas")}
    {then pol_hash_min = make_KTypePol_hash()} {to hold K-chars for min bottom layer, to height min_ht_max}
    then () = test_string:= " using local_test_GEO_hash_bottom_layer"
    then () = if test_verbose then prints("Chose",test_string) fi
    {then () = prints("Got here; SHOULD set blcounter")}
    then () = more_after_flag:=false
    then () = min_after_flag:=false
    then  () = hash_bottom_layerCounter.use()
    then () = if test_verbose then prints("face counts to dim 1: ",
			  for list in LF do #list od);
		  prints("testing height = ", min_ht_max, new_line)
	       fi
    then UTCstart = unitary_test_counter.use_count()
    then startDBTcount = DBTcount
    {next step computes K-characters, possibly using red_count to reduce the number of calcs}
    then LFDKH = if red_count_flag and #LF[1] > 0
    	       	 then let (eq,CLBF) = localGraphRed(LF)
		      in localFD_KHash_01_graph(x,lambda,Lvd,pol_hash,LF, eq,CLBF)
		  else localFD_KHash_01(x, lambda, Lvd, min_ht_max, pol_hash, LF)
		  fi {red_count_flag}
       {label each face (vertex/edge) with index
   	      	in pol_hash of its K-character}
   then () = for list in LKDatas
   	     do for (tau,) in list
	     	do bl_KHash.match(tau)
		od
	     od
   then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    	{next remove from LFDKH all faces failing min_bottom_factors_elim}
   then () = LFDKH:= local_testK_hash_min_bottom_layer(x,lambda, Lvd, LFDKH, eq,
		       	    	    gr, CLBF, min_ht_max, pol_hash, Uhash, fancy_tester)
   	    	 {then () = prints("min bot faces = ",for list in LFDKH do #list od)}
   then () = if test_verbose
	     then prints("unitary on min_bottom layer face counts to dim 1: ",
   	    	       	       		for list in LFDKH do #list od)
	     fi
   then () = min_after_flag := not more_flag
   then () = if #LFDKH[0] = 0
   	     then return []
	     fi
   then () = if #LFDKH[0] = 1
   	     then return if more_flag then one_param_test_bottom(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]),
	     	  	    	      	   					     [ht_max], Uhash)
	     	  	 else one_param_test(parameter(x,lambda, Lvd.list[LFDKH[0][0][0]]),Uhash)
			 fi
	     fi
    then () = if bl_step_flag {bl_step_count steps of size bl_step_size; defaults to 2 and 5}
    	      then more_flag:=true;
    	      	   {if more_shift_level = 0 then more_shift_level := maxht - ht fi;}
    	           return local_test_GEO_hash_bottom_layer_step(x, lambda, Lvd, LFDKH, pol_hash, Uhash,
		   	  fancy_tester)
	      fi
   then maxQps = max_Qps(pmin,pmin)
   then () = maxQps := for (Q,pL) in maxQps
    	 	   do if is_hermitian(pL)
		      then [(Q,pL)]
		      else []
		      fi
		   od.##
   then start_data = elapsed_ms()
   then HK_known = min_ht_max
   then () = if more_flag {want to use non-minimal theta-stable q} {??? USE Qs2 ???}
   	     then let datas = if Qs2_flag
	     	      	      then let ans = for mu in LKTs(pmin)
			      	       	     do if Qs2B_flag
					      	then bottom_factors(bottom_K_type_Qs2B(mu,Q0,height(pmin),ht_max))
						else for (Q,pL) in maxQps
				       	      	      do let (,data) = bottom_K_type_Qs2(mu,Q,ht_max)
						      	 in if #data > 1
						       	    then [(Q,data)]
						       	    else []
						       	    fi
					  	      od.##
						  fi
				       	      od.##
				   {then () = for (Q,) in ans do prints(Q, Q.S) od}
				   in if test_verbose
				      then prints("time to compute Qs2 data at (",x,",",lambda,") = ",
				      	   print_time_string(elapsed_ms() - start_data))
				      fi;
				      ans
			      else let ans = [QKL_bottom_data]:
				       bottom_factors(bottom_K_type_Qs(pmin, Q0, ht_max))
				   then good_ans = for (Q,data) in ans
				   		   do if #data > 1
						      then [(Q,data)]
						      else []
						      fi
						   od.##
				   in if test_verbose
		   		      then prints("time to compute QKL data at (",x,",",lambda,") = ",
				      	    print_time_string(elapsed_ms() - start_data))
		   		      fi;{test_verbose}
		   		      good_ans
			      fi {Qs2_flag}
		  then () = datas := sort(datas, height(pmin), ht_max, bl_KHash)
		       {sort guarantees each term is nonempty}
		  then more_ht_max = if #datas = 0
		       		     then height(pmin)
				     else max(for(,list) in datas
		       		     	      do max( (for (tau,) in list do height(tau) od)#height(pmin)) od)
				     fi
		  {then () = prints("at line 3813, min_HT_max = ",min_ht_max," and more_HT_max = ",more_ht_max)}
		  then () = HK_known := max(HK_known, more_ht_max)
	     	  then () = if more_ht_max > min_ht_max
		       	    then LFDKH := if red_count_flag
    	      	       	    	       	  then let (eq_red,CLBF_red) = localGraphRed(LFDKH)
		       	    	     	       in extend_K_characters_graph(x, lambda, Lvd, LFDKH, more_ht_max,
					       	     	pol_hash, eq_red, CLBF_red)
		       	       	       	   else extend_K_characters(x, lambda, Lvd, LFDKH, more_ht_max,
						     pol_hash)
		       		       	   fi {now K-chars to height max(min_ht_max, more_ht_max)}
			     fi
		   then () = if more_ht_max > height(pmin)
		   	     then let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH, pol_hash, more_ht_max)
			     	  then () = LFDKH := local_testK_hash_bottom_layer_more(x,lambda, Lvd,
			    	      	   	 LFDKH, eq, gr, CLBF, {maxQs,} datas, pol_hash, Uhash)
			    	  	 {bottom layer test on K-types in datas}
   		  	       	  then () = if test_verbose then prints("unitary on more_bottom layer to ",
				       	       more_ht_max, " face counts to dim 1: ",for list in LFDKH do #list od)
		    	    	            fi
   		  	     	  then () = if #LFDKH[0] = 0 then return [] fi
			          then () = more_after_flag:=true
		  	          then () = if #LFDKH[0] = 1 {already passed D}
   	     	       	    	            then return one_param_test(parameter(x,lambda,
			    	      	   	   Lvd.list[LFDKH[0][0][0]]),Uhash)
	     		    	             fi
		  	          in ()
			     elif test_verbose
			     then prints("no more_bottom K-types")
			     fi {more_ht_max > height(pmin)}
		   then () = if test_verbose
   	     	       	     then prints("unitary on more_bottom layer face counts to dim 1: ",
   	     	  		  for list in LFDKH do #list od)
			     fi
		   in ()
	      fi {more_flag}
	      {now have list of vertices and edges passing bottom layer tests out to D}
   {want to pass HK_known}
   then () = more_after_flag := more_flag
   then () = min_after_flag := not more_flag
   in if one_level_revert_flag
      then local_test_GEO_hash_one_level_end(x, lambda, Lvd, LFDKH, pol_hash, HK_known, Uhash, fancy_tester)
      else local_test_GEO_hash2_end(x, lambda, Lvd, LFDKH, pol_hash, HK_known, Uhash, fancy_tester)
      fi

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, LocalVertexData Lvd,
[[FaceVertsIndex]] LF, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
local_test_GEO_hash_bottom_layer(x, lambda, Lvd, LF, pol_hash, Uhash,
is_unitary_hash_big_SIMPLE@Param)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2{, mapAct}{, global_faces}) {impose Dirac}
	      else localFD_1Dirac2(x, lambda, Lvd, Perm2{, mapAct})
	      fi
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,} LocalVertexData Lvd,
    (vec,[(int,int)]) Perm2, vec mapAct, KTypePol_hash pol_hash, Param_hash Uhash,
    [[FaceVertsIndex]] global_faces) = [Param]:
    let G = x.real_form, thetaMinus = x.involution - 1
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2{, mapAct})
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2{, mapAct})
	      fi
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_hash_bottom_layer(KGBElt x, ratvec lambda, {VertexData vd,}
    KTypePol_hash pol_hash, Param_hash Uhash) = [Param]:
    let G = x.real_form
    then FEL = LPm_table.flippable_edge_lookup(G)
    then (Lvd, Perm2{, mapAct}) = localFD_Lvd2(x, lambda, {vd,} FEL)
    then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
    	      then localFD_1Dirac2_by_zero(x,lambda, Lvd, Perm2{, mapAct})
	      else localFD_1Dirac2(x,lambda, Lvd, Perm2{, mapAct})
	      fi
    	{computes edges and verts, imposing hermitian and Dirac}
    in local_test_GEO_hash_bottom_layer(x, lambda, {vd,} Lvd, LF, pol_hash, Uhash)

set local_test_GEO_bottom_layer(KGBElt x, ratvec lambda) = [Param]:
    let G = x.real_form
    then Uhash = big_unitary_hash.uhash(x.real_form){make_Param_hash()}, pol_hash = make_KTypePol_hash()
    {, vd = FPP_vertex_data(G)}
    then () = unipotents_to_hash(x.real_form,Uhash)
    in local_test_GEO_hash_bottom_layer(x,lambda, {vd,} pol_hash, Uhash)

set spherical_general(RealForm G, (KGBElt, ratvec->[Param]) local) = [Param]:
    let start = elapsed_ms()
    then r = rank(x_open(G).involution - 1)
    then answer = local(x_open(G), G.rho)
    then () =  {if time_verbose
    	       then} prints("Total time ", print_time_string(elapsed_ms() -start)) {fi}
    then () = if long_out_flag
    	      then prints("unitary faces by dim = ", for j:r+1 do #LFDKHByDim[j] od,
    	      	   		   	     	   test_string)
	      fi
    then () = if long_out_flag
    	      then prints("number of distinct K-characters = ",NumKchars())
	      fi
    in answer

{this gives def_dumb if def_flag = true}
set spherical_dumb(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO_dumb@(KGBElt, ratvec))

set spherical_def_dumb(RealForm G) = [Param]:
    let () = def_flag:=true
    in spherical_general(G, local_test_GEO_dumb@(KGBElt, ratvec))

set spherical(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO@(KGBElt, ratvec))

set spherical2(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO2@(KGBElt, ratvec))

set spherical_one_level(RealForm G) = [Param]:
    spherical_general(G, local_test_GEO_one_level@(KGBElt, ratvec))
