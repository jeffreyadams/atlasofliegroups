<basic.at { for |infinitesimal character| }
<hash.at { for |make_xlambda_hash| }

{whether to use these functions}
set red_count_flag = false

set red_coroots(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then pos_co = G.poscoroots
    then theta = p.x.involution
    in for alphav@j in pos_co
       do let gammaj = gamma*alphav
       	  in if is_integer(gammaj) and gammaj.>
       	     then if alphav*theta = -alphav and Cayley((G.posroots)[j],p) != p
   	     	  then [alphav] {parity real root}
	       	  else []
	       	  fi
	     elif ((theta*(gamma.numer))*alphav).<
	     then [alphav] {complex}
	     else []
	     fi
       od.##

set red_count_time =int:0

{whether to use the old version, which does not store root system data}
set red_count_old_flag = true

{real parity: gamma+ lambda + rho_real EVEN on alphavee}
set red_count_old(Param p) = int:
    let start = elapsed_ms(), G = p.real_form, x = p.x
    then gamma = p.infinitesimal_character
    then lambdainttw = (2*p.lambda).numer + sum(x.real_posroots)
    then theta = p.x.involution
    then ans = count( for alphav in G.poscoroots
       	       	      do let (gammajn,gammajd) = %(gamma*alphav)
       	      	      	 in gammajd=1 and
	      	 	    gammajn.!= and
       	  	 	    if alphav*theta = -alphav
			    then (2*gammajn + lambdainttw*alphav)%4 = 2
	  	 	    else gammajn.> and
				 ((theta*(gamma.numer))*alphav).<
		 	    fi
	      	     od)
    then () = red_count_time +:= elapsed_ms() - start
    in ans

set red_count_old(Param p, int HT) = int:
    if HT = -1 then return red_count_old(p) fi;
    let start = elapsed_ms(), G = p.real_form, x = p.x, lambda = p.lambda
    then up = (HT-height(p)) {how much we're allowed to increase ht}
    then gamma = p.infinitesimal_character
    then lambdainttw = (2*p.lambda).numer + sum(x.real_posroots)
    then theta = p.x.involution
    then ans = count( for alphav@j in G.poscoroots
       	       	      do let (gammajn,gammajd) = %(gamma*alphav)
       	      	      	 in gammajd=1 and
	      	 	    gammajn.!= and
       	  	 	    if alphav*theta = -alphav
			    then (2*gammajn + lambdainttw*alphav)%4 = 2
			    	 and dominant(G,(1+reflection(G,j)*theta)*gamma)*G.two_rho_check <=2*HT
	  	 	    else let (tgammajn,) = %((theta*gamma)*alphav)
				 in tgammajn.< and dominant(G, (1+reflection(G,j)*theta*reflection(G,j))*
				 gamma) * G.two_rho_check <= 2*HT
		 	    fi
	      	     od)
    then () = red_count_time +:= elapsed_ms() - start
    in ans

{label integral non-parity real as 1}
set test_nonpar(Param p) = vec:
    let G = p.real_form
    then theta = p.x.involution
    then gamma = p.infinitesimal_character
    in for alphav@j in G.poscoroots
       do let (gammajn,gammajd) = %(gamma*alphav)
       	  in if gammajd>1 or alphav*theta != -alphav
	     then [] {just leaves integral real}
	     elif Cayley(G.posroots[j],p) = p
	     then [1]
	     else [0]
	     fi
       od.##

set lambda_test_nonpar(Param p) = vec:
    let G = p.real_form, x = p.x
    then theta = x.involution
    then gamma = p.infinitesimal_character
    then lambdatw = p.lambda +rho_r(x) +gamma
    in for alphav@j in G.poscoroots
       do let (gammajn,gammajd) = %(gamma*alphav)
       	  in if gammajd>1 or alphav*theta != -alphav
	     then [] {just leaves integral real}
	     else let testj = (lambdatw*alphav).numer%2
	     	  in if testj = 0
	     	     then [1]
	    	     else [0]
	     	     fi
	     fi
       od.##

set red_count_xl_hash = make_xlambda_hash()

{same size as preceding hash}
set red_counters_list = [[(ratvec -> int)]]: []

{one function for each real root and each pair alpha < -theta*alpha of pos complex roots;
attaches to infl char gamma the smallest HT of Cayley(alpha)(p(x,lambda,gamma)), or cross.}
set red_counters(KGBElt x, ratvec lambda) = [(ratvec -> int)]:
    let N = red_count_xl_hash.size()
    then n = red_count_xl_hash.match(x,lambda)
    in if n < N
       then red_counters_list[n]
       else let theta = x.involution, G = x.real_form
       	    then lambdainttw = (2*lambda).numer + sum(x.real_posroots)
	    then answers = [(ratvec -> int)]: [], keep = true
	    then () = for alphav@j in G.poscoroots
	       	      do let answer = (ratvec -> int): (ratvec gamma):
	       	    	     let (gammajn,gammajd) = %(gamma*alphav)
	       	    	     in if (alphav*theta + alphav).=
			     	then if gammajd != 1 or gammajn.=
				     then -1
		     	   	     elif (2*gammajn + lambdainttw*alphav)%4 = 2
		       	   	     then rat_as_int(dominant(G,(1+reflection(G,j)*theta)*gamma)*G.rho_check)
				     else -1
				     fi
	    	       	   	elif alphav*theta*(G.rho) > 0
				then keep:=false; -1
				else if gammajd = 1 and (let (tgammajn,) = %((theta*gamma)*alphav)
				     	     {now alpha cplx, theta(alpha) < 0}
			      	     	       in tgammajn.<)
		       	   	     then rat_as_int(dominant(G,(1+reflection(G,j)*theta*reflection(G,j))*
							gamma) * G.rho_check)
		       	             else -1
				     fi
		     	   	fi
		     	 then () = if keep then answers#:= answer fi
		     	 in keep:=true
		       od
	    in red_counters_list #:= answers;
	       assert(#red_counters_list = red_count_xl_hash.size());
	       answers
         fi


set red_count(Param p) = int:
    if red_count_old_flag then return red_count_old(p) fi;
    let start = elapsed_ms(), G = p.real_form, x = p.x
    then gamma = p.infinitesimal_character
    then ans = count(for f in red_counters(p.x,p.lambda) do f(gamma).>= od)
    then () = red_count_time +:= elapsed_ms() - start
    in ans

set red_count(Param p, int HT) = int:
    if red_count_old_flag then return red_count_old(p,HT) fi;
    let start = elapsed_ms(), G = p.real_form, x = p.x
    then gamma = p.infinitesimal_character
    then ans = count(for f in red_counters(p.x,p.lambda) do let H = f(gamma) in H.>= and
    	 H <= HT od)
    then () = red_count_time +:= elapsed_ms() - start
    in ans