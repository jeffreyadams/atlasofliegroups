< basic {for infinitesimal character}

{counts integral roots perhaps contributing to reducibility of Param p
(more or less assumed to be weakly normal}
set red_roots_old(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then id = integrality_datum(G,gamma)
    then pos_int = id.posroots, pos_int_co = id.poscoroots
    then theta = p.x.involution
    in for alpha@j in pos_int
       do if gamma*pos_int_co[j] = 0
       	  then []
       	  elif theta*alpha = -alpha
	  then if Cayley(alpha,p) != p then [alpha]
	       else []
	       fi
	  elif (theta*gamma)*pos_int_co[j] < 0
	  then [alpha]
	  else []
	  fi
	  od.##

set red_coroots(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then pos_co = G.poscoroots
    then theta = p.x.involution
    in for alphav@j in pos_co
       do let gammaj = gamma*alphav
       	  in if (not is_integer(gammaj)) or gammaj = 0
       	  then []
       	  elif alphav*theta = -alphav
	  then if Cayley((G.posroots)[j],p) != p then [alphav]
	       else []
	       fi
	  elif (theta*gamma)*alphav < 0
	  then [alphav]
	  else []
	  fi
	  od.##

set red_count_old(Param p) = int: #red_roots_old(p)

set red_count_time =int:0

set red_count(Param p) = int:
    let start = elapsed_ms(), G = p.real_form
    then pos_co = G.poscoroots, gamma = p.infinitesimal_character
    then theta = p.x.involution
    then ans = count( for alphav@j in pos_co
       	      do let gammaj = gamma*alphav
       	      in is_integer(gammaj) and
	      	 (gammaj.numer).> and
       	  	 if alphav*theta = -alphav
	  	 then Cayley((G.posroots)[j],p) != p
	  	 else (theta*gamma)*alphav < 0
		 fi
	      od)
    then () = red_count_time +:= elapsed_ms() - start
    in ans
