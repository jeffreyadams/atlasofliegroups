< basic {for infinitesimal character}

{whether to use these functions}
set red_count_flag = false

{counts integral roots perhaps contributing to reducibility of Param p
(more or less assumed to be weakly normal TRY TO DROP THAT for blob}
set red_roots_oldest(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then id = integrality_datum(G,gamma)
    then pos_int = id.posroots, pos_int_co = id.poscoroots
    then theta = p.x.involution
    in for alpha@j in pos_int
       do let m = gamma*pos_int_co[j]\1
       	  in if gamma*pos_int_co[j] = 0
       	     then []
       	     elif theta*alpha = -alpha
	     then if Cayley(alpha,p) != p then [alpha]
	       	  else []
	       	  fi
	     elif ((theta*gamma)*pos_int_co[j])*m < 0
	     then [alpha]
	     else []
	     fi
      od.##

set red_coroots_old(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then pos_co = G.poscoroots
    then theta = p.x.involution
    in for alphav@j in pos_co
       do let gammaj = gamma*alphav
       	  in if (not is_integer(gammaj)) or gammaj = 0
       	  then []
       	  elif alphav*theta = -alphav
	  then if Cayley((G.posroots)[j],p) != p then [alphav]
	       else []
	       fi
	  elif ((theta*gamma)*alphav)*gammaj < 0
	  then [alphav]
	  else []
	  fi
	  od.##

set red_coroots(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then pos_co = G.poscoroots
    then theta = p.x.involution
    in for alphav@j in pos_co
       do let gammaj = gamma*alphav
       	  in if is_integer(gammaj) and gammaj.>
       	     then if alphav*theta = -alphav and Cayley((G.posroots)[j],p) != p
   	     	  then [alphav]
	       	  else []
	       	  fi
	     elif ((theta*(gamma.numer))*alphav).<
	     then [alphav]
	     else []
	     fi
       od.##

set red_count_oldest(Param p) = int: #red_roots_oldest(p)

set red_count_time =int:0

set red_count_old(Param p) = int:
    let start = elapsed_ms(), G = p.real_form
    then pos_co = G.poscoroots, gamma = p.infinitesimal_character
    then theta = p.x.involution
    then ans = count( for alphav@j in pos_co
       	      do let gammaj = gamma*alphav
       	      in is_integer(gammaj) and
	      	 (gammaj.numer).!= and
       	  	 if alphav*theta = -alphav
	  	 then Cayley((G.posroots)[j],p) != p
	  	 else ((theta*gamma)*alphav)*gammaj < 0
		 fi
	      od)
    then () = red_count_time +:= elapsed_ms() - start
    in ans

set red_count_Cayley(Param p) = int:
    let start = elapsed_ms(), G = p.real_form
    then gamma = p.infinitesimal_character
    then theta = p.x.involution
    then ans = count( for alphav@j in  G.poscoroots
       	       	      do let (gammajn,gammajd) = %(gamma*alphav)
       	      	      	 in gammajd=1 and
	      	 	    gammajn.!= and
       	  	 	    if alphav*theta = -alphav
	  	 	    then Cayley((G.posroots)[j],p) != p
	  	 	    else gammajn.> and
				 ((theta*(gamma.numer))*alphav).<
		 	    fi
	      	     od)
    then () = red_count_time +:= elapsed_ms() - start
    in ans

{real parity: gamma+ lambda + rho_real EVEN on alphavee}
set red_count(Param p) = int:
    let start = elapsed_ms(), G = p.real_form, x = p.x
    then gamma = p.infinitesimal_character
    then lambdainttw = (2*p.lambda).numer + sum(x.real_posroots)
    then theta = p.x.involution
    then ans = count( for alphav in G.poscoroots
       	       	      do let (gammajn,gammajd) = %(gamma*alphav)
       	      	      	 in gammajd=1 and
	      	 	    gammajn.!= and
       	  	 	    if alphav*theta = -alphav
			    then (2*gammajn + lambdainttw*alphav)%4 = 2
	  	 	    else gammajn.> and
				 ((theta*(gamma.numer))*alphav).<
		 	    fi
	      	     od)
    then () = red_count_time +:= elapsed_ms() - start
    in ans



{label integral non-parity real as 1}
set test_nonpar(Param p) = vec:
    let G = p.real_form
    then theta = p.x.involution
    then gamma = p.infinitesimal_character
    in for alphav@j in G.poscoroots
       do let (gammajn,gammajd) = %(gamma*alphav)
       	  in if gammajd>1 or alphav*theta != -alphav
	     then [] {just leaves integral real}
	     elif Cayley(G.posroots[j],p) = p
	     then [1]
	     else [0]
	     fi
       od.##

set lambda_test_nonpar(Param p) = vec:
    let G = p.real_form, x = p.x
    then theta = x.involution
    then gamma = p.infinitesimal_character
    then lambdatw = p.lambda +rho_r(x) +gamma
    in for alphav@j in G.poscoroots
       do let (gammajn,gammajd) = %(gamma*alphav)
       	  in if gammajd>1 or alphav*theta != -alphav
	     then [] {just leaves integral real}
	     else let testj = (lambdatw*alphav).numer%2
	     	  in if testj = 0
	     	     then [1]
	    	     else [0]
	     	     fi
	     fi
       od.##
