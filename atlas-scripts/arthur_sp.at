{testing conjectures about obtaining Arthur packets by cohomological induction
from unipotent on L.derived, in case G=Sp(2n,R), L=U(1)^{n-m}x Sp(2m,R)}

{implement:
compute all Langlands members of unipotent packets on L_der
next: input central character and one of these p_der  -> p on L
AAM: compute honest Arthur packet for L defined by p
also: compute all strong real forms of L
get "strong" Arthur packet on union of these strong real forms
induce all of these up to G: conjecturally this is an Arthur packet for G
Note: not really all: L=TxSp(2m,R) only use split strong real forms: ignore TxSp(p,q)
since these are not Levis in Sp(2n,R)
claim: the Langlands member of this ostensible Arthur packet is induced from the Langlands member on L
assuming this: it is enough to check that
strong packet on L containing p_L_Langlands -> p_G_Langlands -> Arthur packet(p_G_Langlands) (using AAM again)
check these two sets are equal}

<twisted_endoscopy_D.at
<strong_real_forms.at

set arthur_sp_verbose=false

{moved pr_long to misc.at}

set show([[Param]] packets)=void:
for S@i in packets do 
 prints("i=",i);pr_long(S) od;prints("")



{run over all weak packets, return the Langlands members: those of minimal height}
set unipotent_langlands_parameters(RealForm G)=[Param]:
let wp=weak_packets(G) in
 ##for packet in wp do min_height(parameters(packet)) od

{shift in infinitesimal character for U(1)^{n-m}xSp(2m) in Sp(2n)}
set rho_shift_0(int n,int m)=for i:n-m do n-i od
set rho_shift(int n,int m)=rho_shift_0(n,m)##null(m)

set rho_shift_0(Param p_L,RealForm G)=rho_shift_0(rank(G),rank(p_L.root_datum))
set rho_shift(Param p_L,RealForm G)=rho_shift(rank(G),rank(p_L.root_datum))

{given n,m: G=Sp(2n,R), L=U(1)^{n-m}x Sp(2m,R), compute all Langlands unipotents of L_der}
{computes all weak packets for L_der, then keeps the parameters of minimal height (these
are the Langlands member of the honest packets}
set init(int n, int m)=(RealForm, RealForm, [Param]):
prints("constructing Levi U(1)^",n-m,"*Sp(",2*m,",R) in Sp(",2*n,",R) and Langlands unipotent parameters for L_der");
prints("Cohomological induction shifts the infinitesimal character by ",rho_shift(n,m));
let G=Sp(2*n,R) then
L_der=Sp(2*m,R) then 
L=compact_torus(n-m) * L_der then
unipotents=unipotent_langlands_parameters(L_der) in
(G,L,unipotents)

{returns (G,[(L_der,[params for G induced from L])])}
set init_all(int n)=([(RealForm,[Param])],RealForm):
let G=Sp(2*n,R) in
(for m:n-1 from 1 do
 let (,L_der,params)=init(n,m)  in (L_der,params) od,G)

set quasisplit_unitary_group(int n)=RealForm:  if is_even(n)  then U(n\2,n\2) else U(n\2+1,n\2) fi
set antidiagonal(int n)=mat:for i:n do e(n,n-1-i) od

{for Sp(2n,R) only}
set endoscopic_data(RealForm G)=(mat,RealForm,mat):  {(M,GL(2n+1,R),delta): matrix M for twisted endoscopic transfer Sp(2n,R)-> GL(2n+1,R), with nice coordinates}
let n=rank(G) in
if G=Sp(2*n,R) then
  let GL=GL(2*n+1,R) then
  delta=GL.distinguished_involution then
  (rd_0,M_0,)=complex_endoscopic_group(GL,delta)  then {rd_0=Sp(2n) with the negative coordinates}
  {skip the next two steps:
  rd=root_datum(-rd_0.simple_roots,-rd_0.simple_coroots) then   {clumsy way to get nicer coordinates}
  G=split_form(rd) then {Sp(2n,R) with usual coordinates, just gives G}
  }
  M=-M_0 {M*simple_coroots(G) = first n columns of GL.simple_coroots}
  in (M,GL,delta)
elif quasisplit_form(G)=quasisplit_unitary_group(n) then
  let GL=GL(n,C) then
  delta=GL.distinguished_involution then
  (rd_0,M_0,)=complex_endoscopic_group(GL,delta)  in
  (M_0,GL,delta)
else
  prints("only implemented for Sp(2n,R) and U(p,q)");
  (null(0,0),GL(1,R), null(0,0))
fi

{
set endoscopic_data(RealForm G)=
}

{Arthur packet for G=Sp(2n,R) or U(p,q)}
set Arthur_packet_character(Param p)=ParamPol:
let (M,GL,delta)=endoscopic_data(p.real_form) in
let ecf=extended_character_formula(Finalize(lift_std(p,M,GL)),delta) in
let P=twisted_character(ecf) in
let Pw=twisted_character_whittaker(P,delta) in
composition_series(inverse_lift_std(Pw,p.real_form,M,p.infinitesimal_character))

{Gives the A-packet as a set of Params in the case of a classical group of type A, B and C}
set Arthur_packet(Param p)=[Param]:
monomials(Arthur_packet_character(p))


{central shift, intended only for U(p,q)}
set shift(Param p, int k)=Param:
parameter(p.x,p.lambda + k*ones(rank(p.real_form)), p.nu)

{include central shift for U(p,q)}
set Arthur_packet_character(Param p, int shift)=ParamPol:
Arthur_packet_character(shift(p,shift))

set Arthur_packet(Param p,int shift)=[Param]:monomials(Arthur_packet_character(p,shift))

{p should be a langlands member of an Arthur packet on the quasisplit form}
set Arthur_packet_character_strong(Param p)=[ParamPol]:
let char_qs=Arthur_packet_character(p) in
for G in strong_real_forms(p.real_form) do inner_lift(char_qs,G) od

set Arthur_packet_strong(Param p)=[Param]:
for P in Arthur_packet_character_strong(p) do monomials(P) od.##

{------------ inducing Arthur packets from U(p,q) to Sp(2n,R)-----------}

{this is intended for U(p,q), allowing central shift
 given parameter p_L should be for a quasisplit unitary group}
set Arthur_packet_character_strong(Param p_L, int shift)=[ParamPol]:
Arthur_packet_character_strong(shift(p_L,shift))

set Arthur_packet_strong(Param p_L,int shift)=[Param]:
Arthur_packet_strong(shift(p_L,shift))

{compute the strong Arthur packet of p_L (on strong real forms of U(p,q)) and induce it to G
p_L should be on quasisplit unitary group of rank n, G=Sp(2n,R)}
set induce_Arthur_packet_strong(Param p_L,RealForm G)=[Param]:
let strong_packet=for p in Arthur_packet_strong(p_L) do
 let ind=theta_induce_irreducible(p,G) then
 ()=if #ind>1 then prints("Warning: induced is reducible:  p=", p) fi in
 monomials(ind) od.##
in strong_packet

{same as previous but allow shift}
set induce_Arthur_packet_strong(Param p_L,int shift,RealForm G)=[Param]:
induce_Arthur_packet_strong(shift(p_L,shift),G)

{compute all unipotent langlands parameters for strong real forms of unitary group
 compute resulting Arthur packets on L, induce up to G
 L should be quasisplit unitary group of rank n, G=Sp(2n,R)}
set induce_all_Arthur_packets_strong(RealForm L, int shift,RealForm G)=[[Param]]:
for p_L in unipotent_langlands_parameters(L) do induce_Arthur_packet_strong(p_L,shift,G) od

{-----------inducing unipotent packets from U(p,q) x Sp(2m,R) to Sp(2n,R)-----}

{now allow L=U(p,q)xSp(2m,R)}

{given KGB elements for G,H -> KGB element for GxH}
set join(KGBElt x,KGBElt y)=
let G=x.real_form*y.real_form in 
let t_x=torus_factor(x), t_y=torus_factor(y), theta_x=x.involution, theta_y=y.involution in
KGB_elt(KGB_elt_gen(inner_class(G),block_matrix(theta_x,theta_y),t_x##t_y))

{given parameters p_L,p_M -> parameter for LxM}
set join(Param p_L,Param p_M)=
parameter(join(p_L.x,p_M.x), p_L.lambda##p_M.lambda,p_L.nu##p_M.nu)

{given parameters p_L for U(p,q), p_M for Sp(2m,R), shift on U(p,q) factor -> parameter for U(p,q)xSp(2m,R)}
set join(Param p_L,int shift,Param p_M)=
join(shift(p_L,shift),p_M)

{given p_L for quasisplit unitary group, shift on this term, p_M on Sp(2m,R)
 assuming p_L, p_M are langlands members of Arthur packets
 -> parameter for LxM -> Arthur packet for LxM
 also repeat this on all strong real forms of L (but only the split form of M)}
set Arthur_packet_strong(Param p_L, int shift,Param p_M)=[Param]:
for p in Arthur_packet_strong(shift(p_L,shift)) do
for q in Arthur_packet(p_M) do 
 join(p,q) od od.##

{given p_L for quasisplit unitary group, shift on L, p_M for Sp(2m,R)
 assuming p_L, p_M are langlands members of Arthur packets
 compute strong Arthur packet on (strong real forms of L)xM and induce to G}
set induce_Arthur_packet_strong(Param p_L, int shift, Param p_M,RealForm G)=[Param]:
let strong_packet=for p in Arthur_packet_strong(p_L,shift,p_M) do
 let ind=theta_induce_irreducible(p,G) then
 ()=if #ind>1 then prints("Warning: induced is reducible:  p=", p) fi in
 monomials(ind) od.##
in strong_packet

{Langlands members of all unipotent packets for LxM, shifted on L}
set unipotent_langlands_parameters(RealForm L,int shift,RealForm M)=
for p_L in unipotent_langlands_parameters(L) do
 for p_M in unipotent_langlands_parameters(M) do
  join(shift(p_L,shift),p_M) od od.##

{run over all weak unipotent packets for strong real forms of L (=quasisplit unitary group), with shift,
 and all weak unipotent packets of M=Sp(2m,R) ->
 keep just the Langlands members (of minimal height) 
 for each of these parameters of LxM compute the unipotent (+shift on L) Arthur packet on LxM, 
 induce up to G=Sp(2n,R)}
set induce_all_Arthur_packets_strong(RealForm L,int shift,RealForm M,RealForm G)=[[Param]]:
for p_L in unipotent_langlands_parameters(L) do
for p_M in unipotent_langlands_parameters(M) do 
induce_Arthur_packet_strong(p_L,shift,p_M,G) od od.##



{-------------------------compact torus x Sp(2m,R) in Sp(2n,R)-----------------}


{L=compact torus * L_der
 extended parameter from L_der to L with given character on compact torus
 requires: L.simple_roots = (rows of zeros) followed by (simple roots of L_der)}

set extend(vec central_char, Param p_L_der)=Param:
let L=compact_torus(#central_char) * p_L_der.real_form then
lambda=central_char##(p_L_der.lambda) then
nu= null(#central_char) ##(p_L_der.nu) in
parameter(KGB(L,p_L_der.x.number),lambda,nu)

{Arthur packet character for L=T*L_der=(compact torus)*Sp(2m,R)
requirement:  p_der.real_form=Sp(2m,R) with usual coordinates
returns ParamPol: (fixed character on T)\otimes(Arthur virtual character on Sp(2m,R))}
set Arthur_packet_character(vec central_char,Param p_der)=ParamPol:
let character_der=Arthur_packet_character(p_der) then
G=compact_torus(#central_char)*p_der.real_form in
sum(G,for (c,p) in %character_der do c*extend(central_char,p) od)

{Arthur packet character for T*Sp(2m,R) T=compact torus
requirement:  p_der.real_form=Sp(2m,R) with usual coordinates
returns: Arthur packet (fixed character of T)\otimes (Arthur packet of Sp(2m,R)}
set Arthur_packet(vec central_char,Param p_der)=[Param]:
monomials(Arthur_packet_character(central_char,p_der))

{Arthur packet character for strong real forms of T*Sp(2m,R)
requirement:  p_der.real_form=Sp(2m,R) with usual coordinates
returns: [ParamPol]:  each ParamPol is an Arthur stable character for a strong real form of T*Sp(2m,R)
note: T contributes 2^dim(T) strong real forms with x^2=1}
set Arthur_packet_character_strong(vec central_char,Param p_der)=[ParamPol]:
let a_packet=Arthur_packet_character(central_char,p_der) then
srf=strong_real_forms(a_packet.real_form) in
for H in srf do transfer(a_packet,H) od


{Arthur packet character for strong real forms of T*Sp(2m,R)
requirement:  p_der.real_form=Sp(2m,R) with usual coordinates
same as previous, but replace each ParamPol with its monomials}
set Arthur_packet_strong(vec central_char,Param p_der)=[[Param]]:
for P in Arthur_packet_character_strong(central_char,p_der) do monomials(P) od



{Given L=U(1)^{n-m}*Sp(2m,R)\subset G=Sp(2n,R)
 fixed character of U(1), p_der on Sp(2m,R)
 assuming: p_der is the Langlands term of a unipotent packet on L_der,
 construct
   the unipotent packet on L_der -> (fixed character of T)*(this packet on L_der)
                                 -> (move this packet to all strong real forms of L)
				 -> cohomologically induce these to G}
set induce_Arthur_packet_strong(vec central_char, Param p_der,RealForm G)=[Param]:
let strong_packet_L=##Arthur_packet_strong(central_char,p_der) then
strong_packet_L_split_only=for p in strong_packet_L do if is_quasisplit(p.real_form) then [p] else [] fi od.## then
strong_packet=for p  in strong_packet_L_split_only do monomials(theta_induce_irreducible(p,G)) od.##
in if arthur_sp_verbose then
prints("infinitesimal character on G: ", central_char##infinitesimal_character(p_der) + rho_shift(p_der,G));
pr_long(strong_packet) fi;
strong_packet

{test if [Param] params is an Arthur packet: Arthur_packet(p_min) =?= params
 where p_min is of minimal height in params}
set is_Arthur_packet_long([Param] params)=([Param],[Param],bool):
let min=min_height(params)  then
a_packet=Arthur_packet(min[0]) in (params,a_packet,param_pol(params)=param_pol(a_packet))

set is_Arthur_packet([Param] params)=bool:
let (,,test)=is_Arthur_packet_long(params) in test

set show_long([[Param]] packets)=void:
for S@i in packets do 
 prints("i=",i);pr_long(S);prints(is_Arthur_packet(S));prints("-------------") od

set test([[Param]] packets)=bool:
let rv=
 for S@i in packets do let result=is_Arthur_packet(S) in prints(i, " ", result);result od
in prints(all(rv));all(rv)

set is_decreasing([int] v)=bool:
all(for i:#v-1 do v[i]>=v[i+1] od)

{infinitesimal character p_der=[b_1,...,b_m]
do all shifts so the *infinitesimal character* on G is
[a_1,...,a_{n-m},b_1,...,b_m] with
0<= a_i <= b_1
ALSO a_1\ge a_2...\ge a_{n-m}
the last condition is:  v-rho_shift_0 is (weakly) decreasing}
{Note: these vectors have some minus signs in the first coordinates, but 
after adding rho_shift_0 the entries are all >=0 and weakly decreasing}
set all_shifts(Param p_der,RealForm G)=
let rho_shift_0=rho_shift_0(p_der,G) then 
b_max=ceil(max(infinitesimal_character(p_der))) then 
box=box(b_max+1,rank(G)-rank(p_der.real_form)) then
{()=prints("box: ", box) then
()=prints("rho_shift_0: ", rho_shift_0) then}
shifts_0=for v in box do {prints("v, ", v, "  ", v-rho_shift_0);}if is_decreasing(v{-rho_shift_0}) then [v-rho_shift_0] else [] fi od.## in
shifts_0

set induce_Arthur_packets_strong_all(Param p_der,RealForm G)=(Param,[(vec,[int],ratvec,Param,[Param])]):
let ()=prints("L_der=",p_der.real_form," p_der=", p_der) in
let rho_shift=rho_shift(rank(G),rank(p_der.real_form)) then
shifts_0=all_shifts(p_der,G) then
()=if arthur_sp_verbose then prints("all shifts: ", shifts_0) fi in
(p_der,for v in shifts_0 do
 let infchar=v##infinitesimal_character(p_der)+rho_shift in
 (v, rho_shift_0(p_der,G),infchar,p_der,induce_Arthur_packet_strong(v,p_der,G)) od)

set show((Param p_der,[(vec,[int],ratvec,Param,[Param])] data))=void:
for (v,rho_shift,infchar,p,params) in data do
prints("rho_shift: ", rho_shift, " shift (v): ", v,"  total shift: ", v+rho_shift,new_line,
"inf.char. on L_der: ", infinitesimal_character(p),"  inf.char. on G: ", infchar);
prints("L_der=", p.real_form);
pr_long(params);
prints("-----------------------") od

set show_long((Param p_der,[(vec,[int],ratvec,Param,[Param])] data))=void:
for (v,rho_shift,infchar,p,params) in data do
prints("rho_shift: ", rho_shift, " shift (v): ", v,"  total shift: ", v+rho_shift,new_line,
"inf.char. on L_der: ", infinitesimal_character(p),"  inf.char. on G: ", infchar);
prints("L_der=", p.real_form);
pr_long(params);
prints("Arthur packet: ", is_Arthur_packet(params));
prints("-----------------------") od

set induce_Arthur_packets_strong_all([Param] reps,RealForm G)=
for p in reps do induce_Arthur_packets_strong_all(p,G) od

{call previous using output of init_all}
set induce_Arthur_packets_strong_all([(RealForm,[Param])] data,RealForm G)=
induce_Arthur_packets_strong_all(for (,params) in data do params od.##,G)

set show([(Param,[(vec,[int],ratvec,Param,[Param])])] data)=void:
for d@i in data do show(d);prints("==============================") od

set show_long([(Param,[(vec,[int],ratvec,Param,[Param])])] data)=void:
for d@i in data do show_long(d);prints("==============================") od

{------------------------------ inducing one-dimensional from U(p,q) to Sp(2n,R) -----}

set arthur_packet_trivial_upq_strong(int n)=[Param]:
for G in strong_real_forms(U(n,0)) do G.trivial od

set arthur_packet_trivial_upq_strong(int n,int shift)=[Param]:
for G in strong_real_forms(U(n,0)) do
 let p=G.trivial in parameter(p.x, p.lambda + shift*ones(n), p.nu) od

set induce_arthur_packet_trivial_upq_strong(int n)=
for p in arthur_packet_trivial_upq_strong(n) do
 let ind=theta_induce_irreducible(p,Sp(2*n,R))  in
  let ()=if #ind>1 then prints("warning:  induced is reducible, p=", p) fi in
  monomials(ind) od.##

set induce_arthur_packet_trivial_upq_strong(int n, int shift)=
for p in arthur_packet_trivial_upq_strong(n,shift) do
 let ind=theta_induce_irreducible(p,Sp(2*n,R))  in
  let ()=if #ind>1 then prints("warning:  induced is reducible, p=", p) fi in
  monomials(ind) od.##

set ind_upq(int n)=induce_arthur_packet_trivial_upq_strong(n)
set ind_upq(int n, int shift)=induce_arthur_packet_trivial_upq_strong(n,shift)

{-----------------------------inducing from 1 dimensional on U(p,q) x Sp(2m,R) -----------}


set Arthur_packets(RealForm G)=
let wp=weak_packets(G) then
(chars,)=
remove_duplicates(for packet in wp do 
 let min=min_height(parameters(packet)) in
  for p in min do Arthur_packet_character(p) od od.##) in chars

set Arthur_phi([Param] params)=L_homomorphism:
let min=min_height(params)[0] in phi(min)

set Arthur_phi(ParamPol P)=L_homomorphism:
Arthur_phi(monomials(P))

set Arthur_phis(RealForm G)=[L_homomorphism]:
for params in Arthur_packets(G) do Arthur_phi(params) od

set Arthur_packet(L_homomorphism phi_arthur)=Arthur_packet(L_packet(phi_arthur)[0][0])
{set Arthur_packet(L_homomorphism phi_arthur)=Arthur_packet(L_packet(phi_arthur)[0])}
