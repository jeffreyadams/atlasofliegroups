<basic.at
<combinatorics.at { for |Partition| }
<W_classes.at { for |WeylClassTable| }
<class_tables.at { for |class_table_E8| }
<character_tables.at

<e8_gap.at { load the information from GAP: |e8_gap_table|, |e8_gap_profile| }

set GAP_positions_E8 (WeylClassTable Wct) = [int]: { |Wct| classes to Magma }
   let GAP_ranked = [int]: { column indices of |e6_profile| ranked |lex_leq| }
      ranking(rlex_leq@(vec,vec))([vec]:e8_gap_profile)
   then profiles_sorted = for r in GAP_ranked do e8_gap_profile[r] od
   , lookup = binary_lookup(rlex_leq@(vec,vec))
   in for w@i in Wct.class_representatives
      do let prof = vec:
         [ order(w), Wct.class_size(i)
	 , Wct.sign[i], Wct.reflection[i], Wct.reflection[Wct.class_power(i,3)]
	 ]
      in GAP_ranked[lookup(prof,profiles_sorted).requisition]
      od

set GAP_reorder_E8 (WeylClassTable Wct) = [int]: { map GAP to |Wct| numbers }
   let Wct_prof = [vec]: { 112 vectors of size 5 }
      for j:Wct.n_classes
      do [ Wct.class_representatives[j].order
	 , Wct.class_sizes[j]
	 , Wct.sign[j]
	 , Wct.reflection[j]
	 , Wct.reflection[Wct.class_power(j,3)]
	 ]
      od
   then rank_of_GAP_elts = [int]: { for x in e8_gap_profile its |lex_leq| rank }
      ranking([vec]:e8_gap_profile).inverse
   , Wct_ranked = ranking(Wct_prof)
   in for r@pos in rank_of_GAP_elts
      do let class_nr = Wct_ranked[r]
         in assert(e8_gap_profile[pos]=Wct_prof[class_nr])
      ; class_nr
      od

{ atlas character table for W(E8)
  for history of its construction see character_table_E8.txt in Dropbox }

set to_special_E8 = (int i) int:
   case i
{1x}    in   0{sp}, 1{sp}
{28x}   , 71, 72
{35x}   , 4{sp}, 5{sp}
{70y}   , 52
{50x}   , 14, 15
{84x}   , 71, 72
{168y}  , 52
{175x}  , 42, 43
{210x}  , 14{sp},15{sp}
{420y}  , 52
{300x}  , 28, 29
{350x}  , 42, 43
{525x}  , 21{sp}, 22{sp}
{567x}  , 23{sp}, 24{sp}
{1134y} , 52
{700xx} , 96, 97
{700x}  , 28{sp}, 29{sp}
{1400y} , 52
{840x}  , 63, 64
{1680y} , 52
{972x}  , 53, 54
{1050x} , 42, 43
{2100y} , 38{sp}
{1344x} , 92, 93
{2688y} , 52
{1400x} , 42{sp}, 43{sp}
{1575x} , 42, 43
{3150y} , 52
{2100x} , 96, 97
{4200y} , 52
{2240x} , 50{sp}, 51{sp}
{4480y} , 52{sp}
{2268x} , 53{sp}, 54{sp}
{4536y} , 52
{2835x} , 56{sp}, 57{sp}
{5670y} , 52
{3200x} , 110, 111
{4096x} , 104, 62{sp}
{4200x} , 63{sp}, 64{sp}
{6075x} , 65{sp}, 66{sp}
{8z}    , 67{sp}, 68{sp}
{56z}   , 92, 93
{112z}  , 71{sp}, 72{sp}
{160z}  , 14, 15
{448w}  , 52
{400z}  , 28, 29
{448z}  , 92, 93
{560z}  , 80{sp}, 81{sp}
{1344w} , 52
{840z}  , 50, 51
{1008z} , 92, 93
{2016w} , 52
{1296z} , 53, 54
{1400zz}, 50, 51
{1400z} , 92{sp}, 93{sp}
{2400z} , 110, 111
{2800z} , 96{sp}, 97{sp}
{5600w} , 52
{3240z} , 99{sp}, 100{sp}
{3360z} , 63, 64
{7168w} , 52
{4096z} , 104{sp}, 62
{4200z} , 106{sp}, 107{sp}
{4536z} , 108{sp}, 109{sp}
{5600z} , 110{sp}, 111{sp}
   else error("Wrong E8 irrep number")
   esac

set character_table_E8 (WeylClassTable Wct) = CharacterTable:
   let G_pos = GAP_positions_E8(Wct)
   then class_names = [string]:
      for w@i in Wct.class_representatives
      do to_string(class_signature_E8(w).compressed_string
		  ," (GAP:",e8_gap_classes[G_pos[i]],")")
      od
   , chars = for line in e8_gap_table do for p in G_pos do line[p] od od
   then named_chars = [[int],string]:
      let limit = Wct.root_datum.nr_of_posroots+1 in
      for chi@i in chars
      do let degree =
	 first(limit,(int k) bool: Wct.inner(chi,Wct.sym_power_refl(k))>0)
      in ( chi
	 , case i%67
	   in if i=0 then "trivial" else  "reflection" fi
	   , if i=1 then "sign" else "sign*reflection" fi
	   else to_string("irrep(dim:",chi[0],",deg:",degree,")")
	   esac
	 )
      od
   in character_table(Wct,class_names,named_chars,to_special_E8@int)

set character_table_E8 = (RootDatum->CharacterTable):
((RootDatum rd) CharacterTable: character_table_E8(class_table_E8(rd))
, standard_datum_E8
).memo_1_rd

set character_table_E8() = CharacterTable:
   character_table_E8(standard_datum_E8)
