<basic.at
<combinatorics { for |Partition| }
<W_classes.at { for |WeylClassTable| }
<class_tables.at { for |test_simple_type| }
<e8_gap.at { load the information from GAP }
<character_tables.at

{atlas character table for W(E8)}
{see character_table_E8.txt}

set character_table_E8(RootDatum rd) = CharacterTable:
   let Wct = class_table_E8(rd)
   then reordering = GAP_reorder_E8(Wct)
   then E8_name(vec chi) = string:
      let psi = null(#chi)
      then degree = { first reorder |chi| for |Wct| into |psi| }
	 for j@i in reordering do psi[j]:=chi[i] od { apply inverse reordering }
      ;  first(Wct.root_datum.nr_of_posroots+1
	      ,(int k) bool: Wct.inner(psi,Wct.sym_power_refl(k)).>
	      )
      in to_string("irrep(dim:",psi[0],",deg:",degree,")")

   then classes = [WeylElt,classical_class,string]:
      let reps = Wct.class_representatives
      in for j in reordering
	 do (reps[j],null_class()
	    ,to_string(class_signature_E8(reps[j]).compressed_string
		      ," (GAP:",e8_gap_classes[j],")")
	    )
	 od
   ,  irreps = [classical_irrep,string,[int]]:
      for line@i in e8_gap_table
      do (null_irrep(),E8_name(line),line)
      od
   in character_table(Wct,classes,irreps)

{ voluntarily override previous definition to memoize for |standard_datum_E8| }
set character_table_E8 = (RootDatum->CharacterTable):
   let ct= trivial_character_table { place holder value }
in (RootDatum rd) CharacterTable:
   if rd != standard_datum_E8 then character_table_E8(rd) { no recursion! }
   elif =ct.root_datum.rank { whether this is the first time we are called }
   then ct:=character_table_E8(rd) { compute and store the first time }
   else ct { any next time just return the previously computed value }
   fi


set character_table_E8() = CharacterTable:
   character_table_E8(standard_datum_E8)
