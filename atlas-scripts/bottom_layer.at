< induction.at {for theta_stable_quasi_data}
< unity.at {for deform_support}
< hermitian.at {for to_ht}
<K_types.at {for branch_std}
<time.at {for print_time_string}
<cohom_reductionND {for factor_params, factor_K_types}
{trying to get at bottom layer K-types. Use D for bound on height, d
for bound on number of terms. The "min" refers to the theta-stable
parabolic built by theta_stable_quasi_data. Parabolics _containing_
that one should certainly be supported; there's a chance also of
getting useful information from parabolics _not_ containing it.}
{"pairs" is }

{K_signature_irrB appears to be much slower than hermitian_form_irr_to_ht, so I'll
try to replace it.}
set min_bottom_verbose = false

set deform_support(Param p, int D) = KTypePol:
    to_ht(deform_support(p), D)

set two_rho_u_check(KGPElt Q) = vec:
    two_rho_check(Q.real_form) - two_rho_check(Q.Levi)

{Each (muG,muL) in output list is a Q-bottom layer K-type for p with (Q,pL) =
theta_stable_quasi_data(p). D is the largest height to which to compute
K-types. For now assume K connected.}
set min_bottom(Param p, int D) = [(KType,KType)]:
    let (Q,pL) = theta_stable_quasi_data(p), {x = p.x, lambda = p.lambda}
    	G = p.real_form
    then L = Q.Levi
    then xcL = KGB(L,0)
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0], LKTL = LKTs(pL)[0]
    then TRUCH = two_rho_u_check(Q)
    then bottom = TRUCH*(highest_weight(LKTG, xcG).mu)
    then too_many_mus = monomials(branch_std(p,D))
    { monomials(deform_support(p,D)) }
    then mus = for mu in too_many_mus
       	       do if {height(mu) > height(LKTG) and}
	       	      TRUCH*(highest_weight(mu, xcG).mu) = bottom
	       	  then [mu]
	  	  else []
	  	  fi
	  	od.##
    then shift = highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu
    in  for mu in mus
    	do (mu, K_types(K_highest_weight_from_K0_weight(xcL,
       	       	       highest_weight(mu,xcG).mu - shift))[0])
	od

{PROBLEM: muL of height DL + M can give K-type of height D+m, with m \ne M}
{each (tau,tauL) in output list is a bottom layer
K-type and the corr L\cap K-type. ASSUME K CONNECTED
Lists include LKT pairs, so always nonempty.}

set min_L_bottom(Param p, int D) = [(KType,KType)]:
    let (Q,pL) = theta_stable_quasi_data(p), {x = p.x, lambda = p.lambda,}
    	G = p.real_form
    then L = Q.Levi
    then xcL = KGB(L,0)
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0],
    	 LKTL = LKTs(pL)[0]
    then shift = K0_param(LKTG, xcG).lambda_minus_rho - K0_param(LKTL,xcL).lambda_minus_rho
    	 {highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu}
    then DL = D-height(p) + height(pL)
    then too_many_tauLs = monomials(branch_std(pL,DL)) {reps of L\cap K}
    then K0 = K_0(xcG), LK0 = K_0(xcL)
    then tauLs =  for tauL in too_many_tauLs
       	      	  do let weight = K0_param(tauL,xcL).lambda_minus_rho + shift
		  in if {height(tauL) > 0 and}
		       	   is_dominant(K0,weight)
       	  	    then [(weight,tauL)]
	  	    else []
	  	    fi
		 od.##
    in for (weight,tauL) in tauLs
       do (K_types(K_highest_weight_from_K0_weight(xcG, weight))[0] ,tauL) od

{Each (tau,tauLj) in output is a bottom layer K-type tau for mu, and the
corresponding Lj\cap K-type tauLj; one list for each Lj. Guaranteed to include LKT pairs, so nonempty}
{
set min_L_bottom_factors(KType mu, int level) = [[(KType, KType)]]:
    let p = parameter(mu)
    then (Q,pL) = theta_stable_quasi_data(p), G = p.real_form
    then muL = LKT(pL)
    then muLjs = factor_K_types(muL), L = Q.Levi
    then Ljs = for muLj in muLjs do muLj.real_form od
     {restriction to each simple factor of L}
    {then Ljs = simple_factors(L) doesn't match real forms of muLjs}
    then DLjs = for muLj in muLjs do next_heights(muLj, level) od
    then too_many_tauLjs = [[KType]]:
    	 for muLj@j in muLjs
	 do monomials(branch(muLj, DLjs[j]~[0]))
	 od
    then xcL = KGB(L,0)
    then xcLjs = for Lj in Ljs
    	       	 do KGB(Lj, 0)
		 od
    then xcGs = for xcLj in xcLjs do embed_KGB(xcLj,G) od
    then shifts = for xcLj@j in xcLjs {Connects Lj\cap K-types to bottom layer K-types}
    	 	  do K0_param(mu, xcGs[j]).lambda_minus_rho -
		     K0_param(muLjs[j],xcL).lambda_minus_rho
{highest_weight(mu,xcGs[j]).mu - highest_weight(muLjs[j], xcLj).mu}
		  od
    in for listj@j in too_many_tauLjs
       do let K0 = K_0(xcGs[j])
       	  in for tauLj in listj
       	     do let taujwt = K0_param(tauLj, xcLjs[j]).lambda_minus_rho + shifts[j]
{highest_weight(tauLj, xcLjs[j]).mu + shifts[j]}
	     in if {height(tauLj) > 0 and} is_dominant(K0, taujwt)
  	             then [(K_types(K_highest_weight_from_K0_weight(xcGs[j], taujwt))[0], tauLj)]
	  	     else []
	  	     fi
	       od.##
	  od
}

set min_L_bottom_factors(KType mu, int level) = [[(KType, KType)]]:
    let p = parameter(mu)
    then (Q,pL) = theta_stable_quasi_data(p), G = p.real_form
    then muL = LKT(pL)
    then muLjs = factor_K_types(muL), L = Q.Levi
    then Ljs = for muLj in muLjs do muLj.real_form od
     {restriction to each simple factor of L}
    {then Ljs = simple_factors(L) doesn't match real forms of muLjs}
    then DLjs = for muLj@j in muLjs do next_heights(muLj, (semisimple_rank(Ljs[j]) + 1)\2) od
    then too_many_tauLjs = [[KType]]:
    	 for muLj@j in muLjs
	 do monomials(branch(muLj, DLjs[j]~[0]))
	 od
    then xcL = KGB(L,0)
    then xcLjs = for Lj in Ljs
    	       	 do KGB(Lj, 0)
		 od
    then xcGs = for xcLj in xcLjs do embed_KGB(xcLj,G) od
    then shifts = for xcLj@j in xcLjs {Connects Lj\cap K-types to bottom layer K-types}
    	 	  do K0_param(mu, xcGs[j]).lambda_minus_rho -
		     K0_param(muLjs[j],xcLjs[j]).lambda_minus_rho
{highest_weight(mu,xcGs[j]).mu - highest_weight(muLjs[j], xcLj).mu}
		  od
    in for listj@j in too_many_tauLjs
       do let K0 = K_0(xcGs[j])
       	  in for tauLj in listj
       	     do let taujwt = K0_param(tauLj, xcLjs[j]).lambda_minus_rho + shifts[j]
{highest_weight(tauLj, xcLjs[j]).mu + shifts[j]}
	     in if {height(tauLj) > 0 and} is_dominant(K0, taujwt)
  	             then [(K_types(K_highest_weight_from_K0_weight(xcGs[j], taujwt))[0], tauLj)]
	  	     else []
	  	     fi
	       od.##
	  od


{table of bottom layer data indexed by KType}
set_type
[steady_bottom_data =
( ( -> int) size
  , ( -> ) clear
  , ( -> int) BL_depth
  , (int -> ) adjust_BL_depth
  , (KType->[[(KType,KType)]]) entry
  , (KType->) append
  , (int -> KType) K_type_index
  , (int -> [[(KType,KType)]]) data_index
  , ( -> int) bottom_branch_time
  )
]

set make_steady_bottom_data () = steady_bottom_data:
(  let K_type_hash = make_KType_hash()
   then bottom_data = [[[(KType,KType)]]] : []
   then steps = int:2
   then branch_time = int: 0
   then clear() = void:
       let () = K_type_hash.clear()
       then () = bottom_data:=[]
       then  () = branch_time := 0
       in ()
   in 
   ( ( -> int): { size } @int: K_type_hash.size()
   , ( -> ): {clear} clear
   , ( -> int): {BL_depth} @int: steps
   , (int -> ): {adjust_BL_depth} (int b): steps:= b
   , (KType -> [[(KType,KType)]]): {entry} (KType mu)
     [[(KType,KType)]]:
     begin
	let M = K_type_hash.size()
	then m = K_type_hash.match(mu)
	then () = if m = M
	     	  then let start = elapsed_ms()
		       then () = bottom_data := (bottom_data next bottom_data:= [])
		       	       	 	     #min_L_bottom_factors(mu, steps)
		       in branch_time +:= elapsed_ms() - start
		  fi
	then () = assert(#bottom_data =
	     	K_type_hash.size(),"steady_bottom_data damaged")
	in bottom_data[m]
     end
   , (KType->): {append } (KType mu):
     begin
	let M = K_type_hash.size()
	then m = K_type_hash.match(mu)
	then () = if m = M
	     	  then let start = elapsed_ms()
	     	       then () = bottom_data := (bottom_data next bottom_data:= [])
		       	       	 	     #min_L_bottom_factors(mu, steps)
		       in branch_time +:= elapsed_ms() - start
		  fi
        then () = assert(#bottom_data =
	     	K_type_hash.size(),"steady_bottom_data damaged")
	in ()
     end
   , (int -> KType): {K_type_index} (int j): K_type_hash.index(j)
   , (int -> [[(KType,KType)]]): {data_index} (int j) [[(KType,KType)]]: bottom_data[j]
   , ( -> int): {bottom_branch_time} @int: branch_time
  )
)

{false guarantees not unitary, but true does not guarantee unitary. pairs is (tau, tauL):
a bottom layer K-type and the corresponding L\cap K-type}
set min_bottom_elim(Param p, [(KType,KType)] pairs) = bool:
    let start = elapsed_ms(), (,pL) = theta_stable_quasi_data(p)
    in if  #pairs = 1  then true
       else let DL = max(for (,tauL) in pairs do height(tauL) od),
       	    posLK_time = int:0, multK_time = int:0
       	    then (posL,) = K_signature_irrB(first_param(finalize(pL)),DL)
	    	 {positive part of the signature on L}
	    then () = if min_bottom_verbose
	    	      then let () = posLK_time := elapsed_ms()
		      	   in prints("LK_sig used ",
    	    	      	      print_time_string(posLK_time - start))
		      fi
	    then DG = max(for(tau,) in pairs do height(tau) od)
	    then multG = branch_irr(p,DG)
	    	 {all K-mults to height of largest tau}
	    then () = if min_bottom_verbose
	    	      then let () = multK_time := elapsed_ms()
		      	   in prints("multK used ",
    	    	      	      print_time_string(multK_time - posLK_time))
		      fi
		      {create a list of FUNCTIONS returning a bool. Functions
		      are only evaluated until false }
	    then (posL,) = K_signature_irrB(first_param(finalize(pL)),DL)
	    then answer =  all( for (tau,tauL) in pairs[1:]
       	       	    do @bool: int_part(posL[tauL]) >= int_part(multG[tau])
		       {let (posL,) = K_signature_irrB(first_param(finalize(pL)),DL)}
		    od)
		    {or @bool:int_part...}
    	    then () = if min_bottom_verbose
	       	      then prints("min_bottom_elim used ",
    	    	      	   print_time_string(elapsed_ms() - start))
	       	      fi
            in answer
	fi

{false guarantees not unitary, but true does not guarantee unitary}
{Here P is the K-character of p, at least to heights of pairs}
set min_bottom_elim(Param p, [(KType,KType)] pairs, KTypePol P) = bool:
    let start = elapsed_ms(), (,pL) = theta_stable_quasi_data(p)
    in if #pairs = 1 then true
       else let DL = max(for (,muL) in pairs do height(muL) od){,
       	    posLK_time = int:0, multK_time = int:0}
       	    then (posL,) = K_signature_irrB(first_param(finalize(pL)),DL)
	    	 {positive part of the signature on L}
	    { then () = if min_bottom_verbose
	    	      then let () = posLK_time := elapsed_ms()
		      	   in prints("LK_sig used ",
    	    	      	      print_time_string(posLK_time - start))
		      fi}
	    then DG = max(for(mu,) in pairs do height(mu) od)
	    then multG = P {all K-mults to height of largest mu}
	    { then () = if min_bottom_verbose
	    	      then let () = multK_time := elapsed_ms()
		      	   in prints("multK used ",
    	    	      	      print_time_string(multK_time - posLK_time))
		      fi}
	    in all( for (mu,muL) in pairs[1:]
       	       	    do @:int_part(posL[muL]) >= int_part(multG[mu])
		    od )
    	    {then () = if min_bottom_verbose
	       	      then prints("min_bottom_elim used ",
    	    	      	   print_time_string(elapsed_ms() - start))
	       	      fi
            in answer}
	fi


set min_bottom_test(Param p,[(KType,KType)] pairs) = bool:
    if not min_bottom_elim(p, pairs)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test(Param p,[(KType,KType)] pairs, KTypePol P) = bool:
    if not min_bottom_elim(p, pairs, P)
    then return false
    else is_unitary(p)
    fi

set min_bottom_elim(Param p, int D) = bool:
    let start = elapsed_ms()
    then pairs = min_L_bottom(p,D), minLb_time = int:0, posLK_time = int:0,
    	 multK_time = int:0
    then () = if min_bottom_verbose
    	      then let () = minLb_time := elapsed_ms()
    	      	   in  prints(new_line,"min_L_bottom used ",
    	    	       print_time_string(minLb_time - start))
	      fi
    in min_bottom_elim(p, pairs)

set min_bottom_test(Param p, int D) = bool:
    if not min_bottom_elim(p, D)
    then return false
    else is_unitary(p)
    fi

{false guarantees not unitary, but true does not guarantee unitary}
{LKdata[j] is [(tauj,tauLj)]: tauLj is an Lj\cap K-type inducing to a bottom layer tauj of p.}
set min_bottom_elim_factors(Param p, [[(KType,KType)]] LKdata) = bool:
    let start = elapsed_ms(), answers = for k:#LKdata do false od,
    	(,pL) = theta_stable_quasi_data(p)
    then (mu,) = LKdata[0][0]
    then LKTloc = first(for muprime@m in LKTs(p) do muprime=mu od)
    in if LKTloc <0
       then prints("mu isn't a LKT of p"); true
       elif sum(for pairs in LKdata do #pairs od) = #LKdata
       	    then true
       else let pLjs = factor_params(pL)
       	    then DLs = for pairs@j in LKdata
	       	       do max(for (,tauLj) in pairs
		       	      do height(tauLj)
		      	      od)
	       	       od
      	    then muL = LKTs(pL)[LKTloc]
       	    then muLjs = factor_K_types(muL) {need to line up each muLjs[j] with ONE LKT of pLjs[j]}
       	    then baseLjs = [KType]:
       	    	 for pairs@j in LKdata
	    	 do let (,baseLj) = pairs[0]
	       	    in baseLj
	    	 od
	    then x0js = for muLj@j in muLjs
	    	 	    do muLj.real_form.KGB[0]
			    od
       	    then shiftjs  = for pLj@j in pLjs {for shifting an LKj type to one attached to muLj}
	    	      	    do  let cands = for phiLjk in LKTs(pLj)
			       	   	   do  K0_param(muLjs[j]).lambda_minus_rho -
			       	   	       K0_param(phiLjk).lambda_minus_rho
					   od
				then Lj = pLj.real_form, Lmuj = muLjs[j].real_form
				then coroots = Lj.simple_coroots, zeroj = null(Lj.semisimple_rank)
		      	        then wts = for cand in cands
				     	   do let try = K_highest_weight_from_K0_weight(x0js[j], cand).mu
			   			     {this lifts cand on K0 to X^*}
					      {then () = prints("try = ",try)
					      in (1+x0js[j].involution)*try/2}
					      in try
					   od
				{ then () = prints(new_line,"Lj = ",pLj.real_form, ", coroot = ",Lj.simple_coroots[0])
				then () = prints("pLj = ",pLj)
				then () = prints("cands = ",cands[0],", wts = ",wts[0])}
				then loc = first(for wt@k in wts
				     	   	 do wt*coroots = zeroj
						 {(wt.numer)*coroots = zeroj and wt.denom = 1}
						 {is_one_dimensional(
				     parameter(x_open(pLj.real_form), pLj.real_form.rho + wt, pLj.real_form.rho))}
				     		 od)
				in assert(loc >= 0,"this muLj doesn't match any LKT of pLj"); wts[loc].numer
			   {ratvec_as_vec(param(muLjs[j]).d_lambda - pLj.d_lambda)}
		      	   od
       	    then qLjs = for pLj@j in pLjs
		      	do let qLj = parameter(baseLjs[j].real_form, (pLj.x).number, pLj.lambda +
		      				    shiftjs[j], pLj.nu)
			   { then () = prints(new_line, "shift = ",shiftjs[j], ", Lj coroots = ",
			   	qLj.real_form.simple_coroots)
			   then () = prints("qLj = ",qLj)}
		           then () = assert(any(for psiLj in LKTs(qLj) do psiLj = baseLjs[j] od),
			   	     		   "qLj fails to have baseLj as a LKT")
			   then () = assert(is_hermitian(qLj),"qLj fails to be hermitian")
			   then () = assert(is_final(qLj),"qLj fails to be final")
			   in qLj
		   	od
            then DG = max(for pairs in LKdata
       	    	     do max(for (tauj,) in pairs
			    do height(tauj)
			    od)
		     od)
       	    then multG = branch_irr(p,DG)
       in all( [(->bool)]: {list of functions, one for each factor Lj}
	       for pairs@j in LKdata
	       do {prints("qLjs[j] = ",qLjs[j]);}
	       let (posLj,negLj) = K_signature_irrB(qLjs[j], DLs[j])
	       	  then () = if posLj[baseLjs[j]] = 0
		       	    then posLj := negLj
			    fi
		  in @:all( [(->bool)]:
			    for(tauj, tauLj) in pairs[1:]
			    do {prints(posLj[tauLj]," ",multG[tauj]);}
			    @bool: int_part(posLj[tauLj]) >= int_part(multG[tauj])
			    od )
	       od )
       fi

set min_bottom_elim_factors(Param p, steady_bottom_data bott_data) = bool:
    all( for mu in LKTs(p)
    	 do min_bottom_elim_factors(p, bott_data.entry(mu))
	 od
       )

{false guarantees not unitary, but true does not guarantee unitary}
{Here P is branch_std(K-character of p to heights of pairs}
{LKdata refers to ONE LKT of p}
set min_bottom_elim_factors(Param p, [[(KType,KType)]] LKdata, KTypePol P) = bool:
    let start = elapsed_ms(), answers = for k:#LKdata do false od,
    	(,pL) = theta_stable_quasi_data(p)
    then (mu,) = LKdata[0][0]
    then LKTloc = first(for muprime@m in LKTs(p) do muprime=mu od)
    in if LKTloc <0
       then prints("mu isn't a LKT of p"); true
       elif sum(for pairs in LKdata do #pairs od) = #LKdata
       	    then true
       else let pLjs = factor_params(pL)
       	    then DLs = for pairs@j in LKdata
	       	       do max(for (,tauLj) in pairs
		       	      do height(tauLj)
		      	      od)
	       	       od
      	    then muL = LKTs(pL)[LKTloc]
       	    then muLjs = factor_K_types(muL) {need to line up each muLjs[j] with ONE LKT of pLjs[j]}
       	    then baseLjs = [KType]:
       	    	 for pairs@j in LKdata
	    	 do let (,baseLj) = pairs[0]
	       	    in baseLj
	    	 od
       	    then shiftjs  = for pLj@j in pLjs {for shifting an LKj type to one attached to muLj}
	    	      	    do  let cands = for phiLjk in LKTs(pLj)
			       	   	   do  K0_param(muLjs[j]).lambda_minus_rho -
			       	   	       K0_param(phiLjk).lambda_minus_rho
					   od
				then Lj = pLj.real_form, Lmuj = muLjs[j].real_form
				then coroots = Lj.simple_coroots, zeroj = null(Lj.semisimple_rank)
		      	        then wts = for cand in cands
				     	   do K_highest_weight_from_K0_weight(
					       	    Lmuj.KGB[0], cand).mu
			   			     {this lifts cand on K0 to X^*}
					   od
				then loc = first(for wt@k in wts
				     	   	 do wt*coroots = zeroj
						 {is_one_dimensional(
				     parameter(x_open(pLj.real_form), pLj.real_form.rho + wt, pLj.real_form.rho))}
				     		 od)
				in assert(loc >= 0,"this muLj doesn't match any LKT of pLj"); wts[loc]
			   {ratvec_as_vec(param(muLjs[j]).d_lambda - pLj.d_lambda)}
			   {loc may not be the right one to shift by}
		      	   od
       	    then qLjs = for pLj@j in pLjs
		      	do let qLj = parameter(baseLjs[j].real_form, (pLj.x).number, pLj.lambda +
		      				    shiftjs[j], pLj.nu)
		           then () = assert(any(for psiLj in LKTs(qLj) do psiLj = baseLjs[j] od),
			   	     		   "qLj fails to have baseLj as a LKT")
			   in qLj
		   	od
            in all( [(->bool)]: {list of functions, one for each factor Lj}
       	    	for pairs@j in LKdata
       	    	do if #pairs = 1 then @: true
		   else {let (,tauj0) = pairs[0]}
		   	let qLj = qLjs[j]
		   	{qLj is now a Param for the same real form as tauj}
			then (posLj,negLj) = K_signature_irrB(qLjs[j], DLs[j])
	       	  	then () = if posLj[baseLjs[j]] = 0
		       	     	  then posLj := negLj
			    	  fi
	    	      	{positive part of the signature on Lj}
	           	in @:all( [(->bool)]:
	       	  	     for (tauj,tauLj) in pairs[1:]
       	       	    	     do @bool: int_part(posLj[tauLj]) >= int_part(P[tauj])
		             od )
		    fi
	        od )
	fi

set min_bottom_elim_factors(Param p, steady_bottom_data bott_data, KTypePol P) = bool:
    all( for mu in LKTs(p)
    	 do min_bottom_elim_factors(p, bott_data.entry(mu), P)
	 od
       )
set min_bottom_test_factors(Param p, [[(KType,KType)]] LKdata) = bool:
    if not min_bottom_elim_factors(p, LKdata)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test_factors(Param p,[[(KType,KType)]] LKdata, KTypePol P) = bool:
    if not min_bottom_elim_factors(p, LKdata, P)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test_factors(Param p, steady_bottom_data bott_data) = bool:
    if not min_bottom_elim_factors(p, bott_data)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test_factors(Param p, steady_bottom_data bott_data, KTypePol P) = bool:
    if not min_bottom_elim_factors(p, bott_data, P)
    then return false
    else is_unitary(p)
    fi

set min_bottom_elim_factors(Param p, int level) = bool:
    let start = elapsed_ms()
    then LKdatas = for mu in LKTs(p) do min_L_bottom_factors(mu,level) od
    	 , minLb_time = int:0, posLK_time = int:0, multK_time = int:0
    then () = if min_bottom_verbose
    	      then let () = minLb_time := elapsed_ms()
    	      	   in  prints(new_line,"min_L_bottom used ",
    	    	       print_time_string(minLb_time - start))
	      fi
    in all( [(->bool)]: for LKdata in LKdatas do @bool: min_bottom_elim_factors(
       	    	   p, LKdata)
       	    od)

set min_bottom_test_factors(Param p, int level) = bool:
    if not min_bottom_elim_factors(p, level)
    then return false
    else is_unitary(p)
    fi
