< induction.at {for theta_stable_quasi_data}
< unity.at {for deform_support}
< hermitian.at {for to_ht}
<K_types.at {for branch_std}
<time.at {for print_time_string}
<cohom_reductionND {for factor_params, factor_K_types}
<derived_cover.at
<K.at {for projection_to_K_matrix}
<FPP_faces_herm.at {for is_unitary_hash_big}
<count.at {for char_counter}

{ <sub_cells.at {for is_complex}}
{trying to get at bottom layer K-types. Use D for bound on height, d
for bound on number of terms. The "min" refers to the theta-stable
parabolic built by theta_stable_quasi_data. Parabolics _containing_
that one should certainly be supported; there's a chance also of
getting useful information from parabolics _not_ containing that.}
{"pairs" is...}

{INVESTIGATE parabolic_LKT function in K_highest_weights.at}
{See Ktest.at}
{K_signature_irrB is hermitian_form_irr_to_ht; K_signature_irr is hermitian_form_irr truncated.
Haven't figured out which is faster when.}
set bottom_verbose = false

set deform_support(Param p, int D) = KTypePol:
    to_ht(deform_support(p), D)

set two_rho_u_check(KGPElt Q) = vec:
    two_rho_check(Q.real_form) - two_rho_check(Q.Levi)

{The result of cohomological induction on the level of K}
set theta_induce_K(KTypePol QL, RealForm G) = KTypePol:
K_type_pol(sum(G, for c@pL in QL do c*theta_induce_standard(param(pL),G) od))

set theta_induce_signature(Param pL, RealForm G) = KTypePol:
    theta_induce_K(hermitian_form_irreducible(pL),G)

{meant to be applied to quasisplit simple L}
{set next_heights(RealForm L) = int:
    let N = if not is_quasisplit(L) then 0
    	    elif is_abelian(L) then 0
    	    else max(for p in all_parameters_gamma(L, null(L.rank))
    	     	     do next_heights(p, (semisimple_rank(L) + 3)\2)
	     	     od.##)
    	    fi
     in N {if not is_simple(L)
     	then (N+1)\2
	else N
	fi}}

{meant to be applied to quasisplit simple L}
set next_heights = (RealForm -> int):
    let ichash = make_InnerClass_hash()
    then nhs = [int]: []
    in (RealForm -> int): (RealForm L) int:
       if not is_quasisplit(L)
       then 0
       elif is_abelian(L)
       then 0
       else let I = ichash.size()
       	    then i = ichash.match(L)
	    then ()= if i = I {haven't yet seen L}
		     then nhs#:=max(for p in all_parameters_gamma(L, null(L.rank))
    	     	      	       	    do next_heights(p, (semisimple_rank(L) + 3)\2)
	     	     	       	    od.##)
    	    	     fi
	    in nhs[i]
       fi

set_type LK_data = [(KType,[KType])] {for each bottom layer tau, list [dertauLj] of corr derLKj-types}
set_type QK_bottom_data = (KGPElt Q, [KType] list) {intent is that list consists of K-types tau that are Q-bottom layer}
set_type QKL_bottom_data = (KGPElt Q, [(KType,[KType])] LKdata) {for each bottom layer tau, list [dertauLj] of corr derLKj-types}
{allow NON-height 0 K-type entries}
set_type
[RF_sig_tables =
( ( -> int) real_form_size
  , ( -> ) clear
  , ( -> vec) K_type_size {number of LKTs for each real form}
  , ( -> vec) K_type_pol_size
  , ( -> vec) Param_size
  , ((KType, int) -> KTypePol) branch_entry {branch std to height}
{  , ((KType, int) ->) branch_append {branch std to height, don't report}}
  , (Param -> KTypePol) sig_entry {signature}
{  , ((Param,int) ->) append}
  , (int -> RealForm) real_form_index
  , (int, int -> int) branch_height {largest ht to which K type j on real form i has been branched}
{  , (int, int -> int) sig_height {largest ht to which param j on real form i has had sig computed}}
  , ( -> int) bottom_branch_time
  , ( -> int) bottom_sig_time
)
]

set make_RF_sig_tables () = RF_sig_tables:
(  let real_form_hash = make_RealForm_hash()
   then deltas = [mat]: [] {distinguished involution for each form}
   then param_hashes = [Param_hash] : [] {one for each real form}
   then K_type_hashes = [KType_hash] : [] {one for each real form; list of LKTs of params}
   then K_type_pol_hashes = [KTypePol_hash] : []  {one for each real form}
   then branches = [vec] : [] {one vec for each real form, of size #K types;
   		   	      ith entry is index of branching KTypePol for KType #i}
   then sigs = [vec]: [] {one vec for each real form, of size #params;
   	       	      	  jth entry is index of signature KTypePol for Param #j}
   then branch_heights = [vec]: [] {one list for each real form; jth entry is vec with ith entry the height
   		       	 	   to which branch(param i) is known}
   {then sig_heights = [vec]: [] {one list for each real form; jth entry is vec with ith entry the height
   		       	 	   to which sig(param i) is known}}
   then bottom_branch_time = int: 0
   then bottom_sig_time = int: 0
   then clear() = void:
       let () = real_form_hash.clear()
       then () = deltas:=[]
       then () = param_hashes:=[]
       then () = K_type_hashes:=[]
       then () = K_type_pol_hashes := []
       then () = branches := []
       then () = sigs := []
       then () = branch_heights := []
       {then () = sig_heights := []}
       then () = bottom_branch_time := 0
       then () = bottom_sig_time := 0
       in ()
   then add_real_form(RealForm S) = int:
   	let RFNUM = real_form_hash.size()
	then rfnum = real_form_hash.match(S)
	then () =  if rfnum = RFNUM {haven't seen this real form before}
	     	   then deltas #:= S.distinguished_involution;
		   	param_hashes #:= make_Param_hash();
		        K_type_hashes #:= make_KType_hash();
		        K_type_pol_hashes #:= make_KTypePol_hash();
		        branches #:= null(0);
		        sigs #:= null(0);
		        branch_heights #:= null(0)
			{sig_heights #:= null(0)}
		   fi
	 in rfnum
   then add_K_type(KType mu) = (int, int): {real form index, K type index}
   	let rfnum = add_real_form(mu.real_form)
	then KTYPENUM = K_type_hashes[rfnum].size()
	then ktypenum = K_type_hashes[rfnum].match(mu)
	then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	     	  then let pol = 1*mu
	     	       then m = K_type_pol_hashes[rfnum].match(pol)
		       then () = branches[rfnum] #:= m
		       then () = branch_heights[rfnum] #:= height(mu)
		       then () = assert(real_form_hash.size() = #K_type_pol_hashes,"RF_sig_table damaged")
        	       then () = assert(real_form_hash.size() = #K_type_hashes,"RF_sig_table damaged")
		       then () = assert(real_form_hash.size() = #param_hashes,"RF_sig_table damaged")
		       then () = assert(#sigs[rfnum] = param_hashes[rfnum].size(), "RF_sig_table damaged")
		       then () = assert(#branches[rfnum] = K_type_hashes[rfnum].size(), "RF_sig_table damaged")
		       in ()
		  fi
	in (rfnum, ktypenum)
   then add_K_type(KType mu, int D) = (int, int, int): {this time add to height; D should be >= height(mu)}
   	let rfnum = add_real_form(mu.real_form)
	then KTYPENUM = K_type_hashes[rfnum].size()
	then ktypenum = K_type_hashes[rfnum].match(mu)
	then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	     	  then let start_branch = elapsed_ms()
		       then pol = branch_std(mu,D)
	     	       then m = K_type_pol_hashes[rfnum].match(pol)
		       then () = bottom_branch_time +:= elapsed_ms() - start_branch
		       then () = branches[rfnum] #:= m
		       then () = branch_heights[rfnum] #:= D
		       then () = assert(real_form_hash.size() = #K_type_pol_hashes,"RF_sig_table damaged")
        	       then () = assert(real_form_hash.size() = #K_type_hashes,"RF_sig_table damaged")
		       then () = assert(real_form_hash.size() = #param_hashes,"RF_sig_table damaged")
		       then () = assert(#sigs[rfnum] = param_hashes[rfnum].size(), "RF_sig_table damaged")
		       then () = assert(#branches[rfnum] = K_type_hashes[rfnum].size(), "RF_sig_table damaged")
		       in ()
		   else {we've seen mu before}
		       if branch_heights[rfnum][ktypenum] < D
		       then let tempbranchhts = branch_heights[rfnum]
		       	    then tempbranches = branches[rfnum]
		       	    then start_branch = elapsed_ms()
		       	    then pol = branch_std(mu, D)
		       	    then () = bottom_branch_time +:= elapsed_ms() - start_branch
		       	    then m = K_type_pol_hashes[rfnum].match(pol)
		       	    then () = tempbranches[ktypenum]:=m
		       	    then () = tempbranchhts[ktypenum] :=  D
		       	    then () = branch_heights[rfnum] := tempbranchhts
			    then () = branches[rfnum] := tempbranches
		       	    in()
		        fi
		    fi
	in (rfnum, ktypenum, branches[rfnum][ktypenum])
   then add_param(Param p) = (int, int,int):
   	let  rfnum = add_real_form(p.real_form)
	then PNUM = param_hashes[rfnum].size()
	then pnum = param_hashes[rfnum].match(p)
	then () = if pnum = PNUM {haven't computed with p before}
	     	  then let sig = hermitian_form_irreducible(p)
		       then sig_ind = K_type_pol_hashes[rfnum].match(sig)
		       then () = sigs[rfnum] := if #sigs[rfnum] = 0 then [sig_ind]
		     	      	      	     else (sigs[rfnum] next sigs[rfnum] := [])# sig_ind
				      	     fi
		       then () = assert(real_form_hash.size() = #K_type_pol_hashes,"RF_sig_table damaged")
		       then () = assert(real_form_hash.size() = #param_hashes,"RF_sig_table damaged")
		       then () = assert(real_form_hash.size() = #branch_heights,"RF_sig_table damaged")
		       then () = assert(#sigs[rfnum] = param_hashes[rfnum].size(), "RF_sig_table damaged")
		       in ()
		  fi
	 in (rfnum,pnum,sigs[rfnum][pnum])
    in
   ( ( -> int): { real_form_size } @int: real_form_hash.size()
   , ( -> ): {clear} clear
   , ( -> vec): {K_type_size} @vec: for hash in K_type_hashes do hash.size() od
   , ( -> vec): {K_type_pol_size} @vec: for hash in K_type_pol_hashes do hash.size() od
   , ( -> vec): {Param_size} @vec: for hash in param_hashes do hash.size() od
   , ((KType,int) -> KTypePol): {branch_entry} (KType mu, int D) KTypePol:
     begin
     	let (rf, ktypenum,m) = add_K_type(mu,D)
	in to_ht(K_type_pol_hashes[rf].index(m), D)
     end
   , (Param -> KTypePol): {sig_entry} (Param p) KTypePol:
     begin
	let (rf,pnum,sig_ind) = add_param(p)
	in K_type_pol_hashes[rf].index(sig_ind)
     end
    , (int -> RealForm): {real_form_index} (int j): real_form_hash.index(j)
   , ((int, int) -> int): {branch_height} (int rf, int ktypenum): branch_heights[rf][ktypenum]
{   , ((int, int) -> int): {sig_height} (int rf, int pnum): sig_heights[rf][pnum]}
   , ( -> int): {bottom_branch_time} @int: bottom_branch_time
   , ( -> int): {bottom_sig_time} @int: bottom_sig_time
  )
)

{whether to use RF_sig_tables in bottom layer computation}
set RF_code = true

set rf_sig_tables = make_RF_sig_tables()

set nKeTime = int: 0
{pick the distinguished one making mu+2\rho_c dominant}
set natural_KGB_elt(KType mu) = KGBElt:
  let start = elapsed_ms(), (,x, hwt) = highest_weight(mu)
  then rd=root_datum(x), theta = x.involution
  then (w,hwt_1) = from_dominant
      (rd,(1+theta)*hwt/2) { make |hwt| zero on the split part of |h| }
  then x_1=cross(x,w)
{ Note: tworho_K (x) (above) is in (\h^*)^theta,
  while rho_K(x) is in \t^*, need the former
}
  then hwt_2=hwt_1+tworho_K (x_1)
  then () = nKeTime+:= elapsed_ms() - start
  in cross(x_1,chamber(rd,hwt_2))

{If Q = LU is a parabolic represented by KGPElt (S,x), then S is the set of simple roots of L; so
the derived simple factors derLj of L have simple roots Sj partitioning S. Answer is [Sj]}
set simple_factor_root_partition(KGPElt Q) = [[int]]:
    let L = Q.Levi, G = Q.real_form
    in for Lj in simple_factors(L)
       do for alpha in Lj.simple_roots do root_index(G,alpha) od
       od

set mbfTime = int: 0 {time spent in min_bottom_factors}
{4 seconds in this for Sp(6,R) out of 10 seconds total}
set min_bottom_factors_old(KType mu) = ([[(KType, KType)]], [int]):
    let p = parameter(mu), start = elapsed_ms()
    then (Q,pL) = theta_stable_quasi_data(p), G = p.real_form, ProjK = projection_to_K_matrix(mu.inner_class)
    then SFRP = simple_factor_root_partition(Q)
    then muL = LKT(pL), L = Q.Levi
    then dermuLs = derived_factor_K_types2(muL) {each dermuLj is on a simple derived derLj}
    then derLs = derived_simple_factors(L)
    then DLjs = for derLj in derLs do next_heights(derLj) od
    {then xcG = {embed_KGB(xcL,G)} natural_KGB_elt(mu){this is needed to make shifts for L equal to shifts for G}
    then xcL = {KGB(L,0)} {natural_KGB_elt(muL)} inverse_embed_KGB(xcG,L)}
    then xcL = natural_KGB_elt(muL){ KGB(L,0)}
    then xcG = embed_KGB(xcL,G)
    then derxcLs = derived_factor_KGBs2(xcL)
    then muwt=K0_param(mu,xcG).lambda_minus_rho {size is rank(K)}
    then K0 = K_0(xcG)
    then dertauLs = [[KType]]: {jth list on derived simple factor derLj}
    	 for dermuLj@j in dermuLs
	 do if RF_code {should use bottom_data}
	    then monomials(rf_sig_tables.branch_entry(dermuLj,DLjs[j]))
	    else monomials(branch(dermuLj, DLjs[j]))
	    fi
	 od
    then dertauLjshifts =
    	 for listj@j in dertauLs {list of derLj types}
    	 do let dermuLwtj = K0_param(listj[0], derxcLs[j]).lambda_minus_rho
	    in for dertauLj in listj
	       do K0_param(dertauLj,derxcLs[j]).lambda_minus_rho - dermuLwtj {this is a wt for K on derLj}
	       od
	 od
    then tauwts = for shiftlist@j in dertauLjshifts
    	 	   do let Sj = SFRP[j]
		      in for dertauLjshift in shiftlist
    	 	      	 do muwt + ratvec_as_vec(sum(K0.rank, for xi@k in fundamental_coweights(derLs[j])
			      	       	       		      do ProjK*((dertauLjshift*xi)*G.simple_roots[Sj[k]])
							      od))
{problem in preceding formula for U(3,3), p = parameter(G,140,[3,1,1,-1,-1,-3]/2,[2,0,0,-2,1,-1]/2).
The shifts on G are wrt parabolic defined by lambda, NOT the parabolic for x. Need to shift by something
related to various xc?? Or compute K-types using xc related to mu?}
		      od
		   od
{then () = mbfTime +:= elapsed_ms() - start}{Sp(6): .84 secs to here}
    then LKdata = for listj@j in dertauLs
       	 	  do let taulist = tauwts[j]
		     in [(KType, KType)]: {meant to be list of pairs (tau, dertauLj) with
	     	      	       tau bottom layer for G, dertauLj corr LjK-type}
			for taujwt@m in taulist
			do if is_dominant(K0, taujwt)
  	             	   then [(K_type(K_highest_weight_from_K0_weight(xcG, taujwt)),
		   	    	 listj[m])]
	  	   	   else []
	  	    	   fi
	     		od.##
		   od
     {then () = mbfTime +:= elapsed_ms() - start}
     then helpful_js = for j:#LKdata
     	  	       do if #LKdata[j] > 1
		       	  then [j]
			  else []
			  fi
		       od.##
      then () = mbfTime +:= elapsed_ms() - start {Sp(6): 4.1 secs to here}
      in (for j in helpful_js do LKdata[j] od, helpful_js)
{
{table of bottom layer data indexed by KType}
set_type
[min_bottom_data_old =
( ( -> int) size
  , ( -> ) clear
  , (KType->([[(KType,KType)]], [int])) helpful_entry {subset of entry where list has more than one elt (so
    						      might detect nonunitarity), and the corr numbers of derLj
						      (among the derived simple factors of L}
  , (KType->int) G_min_height {largest height of a G K-type in helpful_entry; at least height(mu)}
  , (KType->vec) L_min_heights {largest heights of derLj\cap K-types in helpful_entry}
  , (int -> KType) K_type_index
  , (int -> ([[(KType,KType)]],[int])) data_index
{  , ( -> int) min_bottom_factors_time}
  )
]

set make_min_bottom_data_old () = min_bottom_data_old:
(  let K_type_hash = make_KType_hash()
   then bottom_data = [([[(KType, KType)]], [int])]:[] {one helpful_entry for each K-type}
   then heights = vec: [] {one for each K-type}
   then Lheights = [vec]: [] {one for each K-type; size is size of helpful_entry}
   {then min_bottom_factors_time = int: 0}
   then clear() = void:
       let () = K_type_hash.clear()
       then () = bottom_data:=[]
       then  () = heights := []
       then () = Lheights :=[]
       in ()
   then enter(KType mu) = int:
       let M = K_type_hash.size()
       then m = K_type_hash.match(mu)
       then () = if m = M
	     	 then let start = elapsed_ms()
		      then mbf = min_bottom_factors_old(mu)
		      then () = bottom_data #:= mbf
		      then (lists,) = mbf
		      then () = heights#:= if #lists = 0 then height(mu)
		      	      		   else max(for list in lists
					   	    do max(for (tau,) in list
						       	   do height(tau)
							   od)
						    od)
					    fi
		      then () = Lheights#:= if #lists = 0 then vec:[]
		      	      		    else for list in lists
					    	 do max(for (,tauLj) in list
						    	do height(tauLj)
							od)
						 od
					     fi
		      in () {bottom_factors_time +:= elapsed_ms() - start}
		 fi
        then () = assert(#bottom_data = K_type_hash.size(),"min_bottom_data_old damaged")
	then () = assert(#heights = #bottom_data,"min_bottom_data_old damaged")
	then () = assert(#Lheights = #bottom_data,"min_bottom_data_old damaged")
	in m
   in
   ( ( -> int): { size } @int: K_type_hash.size()
   , ( -> ): {clear} clear
   , (KType->([[(KType,KType)]], [int])): {helpful_entry} (KType mu) ([[(KType,KType)]], [int]):
     begin
	let m = enter(mu)
	in bottom_data[m]
     end
   , (KType->int): {G_min_height} (KType mu) int:
     begin
	let m = enter(mu)
	in heights[m]
     end
   , (KType->vec): {L_min_heights} (KType mu) vec:
     begin
	let m = enter(mu)
	in Lheights[m]
     end
   , (int -> KType): {K_type_index} (int j): K_type_hash.index(j)
   , (int -> ([[(KType,KType)]],[int])): {data_index} (int j) ([[(KType,KType)]],[int]): bottom_data[j]
  )
)

{use this constant one instead of carrying around bott_data}
set minBottomDataOld = make_min_bottom_data_old()
}

{this time the results are a list of (Qmin,[tau, [dertauLj]).}
set min_bottom_factors(KType mu) = QKL_bottom_data:
    let p = parameter(mu), start = elapsed_ms()
    then (Q,pL) = theta_stable_quasi_data(p), G = p.real_form, ProjK = projection_to_K_matrix(mu.inner_class)
    then SFRP = simple_factor_root_partition(Q)
    then muL = LKT(pL), L = Q.Levi
    then dermuLs = derived_factor_K_types2(muL) {each dermuLj is on a simple derived derLj}
    then derLs = derived_simple_factors(L)
    then derProjKinvs = for derL in derLs do right_inverse(projection_to_K_matrix(derL)) od
    then DLjs = for derLj in derLs do next_heights(derLj) od
    then xcL = {KGB(L,0)} natural_KGB_elt(muL) {inverse_embed_KGB(xcG,L)}
    then xcG = embed_KGB(xcL,G) {natural_KGB_elt(mu)} {this is needed to make shifts for L equal to shifts for G}
    then derxcLs = derived_factor_KGBs2(xcL)
    then muwt=K0_param(mu,xcG).lambda_minus_rho {size is rank(K)}
    then K0 = K_0(xcG)
    then dertauLs = [[KType]]: {jth list on derived simple factor derLj}
    	 for dermuLj@j in dermuLs
	 do if RF_code {should use bottom_data}
	    then monomials(rf_sig_tables.branch_entry(dermuLj,DLjs[j]))
	    else monomials(branch(dermuLj, DLjs[j]))
	    fi
	 od
    then dertauLjshifts = {size = rank of derLj cap K}
    	 for listj@j in dertauLs {list of derLj types}
    	 do let dermuLwtj = K0_param(listj[0], derxcLs[j]).lambda_minus_rho
	    in for dertauLj in listj
	       do K0_param(dertauLj,derxcLs[j]).lambda_minus_rho - dermuLwtj {this is a wt for K on derLj}
	       od
	 od
    then taushifts = for shiftlist@j in dertauLjshifts {for jth simple factor of L, this is a list of the (ratvec)
    	 	     	 	     		       contributions to shift on G from the various dertauLj}
    	 	 do let Sj = SFRP[j]
		    in for dertauLjshift in shiftlist
    	 	       do ProjK*(sum(G.rank, for xi@k in fundamental_coweights(derLs[j])
			      	       	       		    do ((derProjKinvs[j]*dertauLjshift)*xi)*(G.simple_roots[Sj[k]])
							    od))
		       od
		  od
    then B = box(for list in dertauLs do #list od) {going to look at all tensor products over j of dertauLj}
    then tauwts = for b in B
    	 	  do ratvec_as_vec(sum(rank(K0), for m@j in b do taushifts[j][b[j]] od) + muwt)
		  od
    {then () = for k:#tauwts do prints(tauwts[k]) od}
    then LKData = for tauwt@k in tauwts
       	 	  do if is_dominant(K0,tauwt)
		     then [(K_type(K_highest_weight_from_K0_weight(xcG, tauwt)), for m@j in B[k] do dertauLs[j][m] od)]
		     else []
		     fi
		  od.##
    then () = mbfTime +:= elapsed_ms() - start
    in (Q,LKData) 

{table of bottom layer data indexed by KType}
set_type
[min_bottom_data =
( ( -> int) size
  , ( -> ) clear
  , (KType->LK_data) entry
  , (KType->int) G_min_height {largest height of a G K-type in entry; at least height(mu)}
  , (KType->vec) L_min_heights {bounds (not nec achieved) of derLj\cap K-types in entry}
{  , (KType->KGBElt) natural_KGB} {result of natural_KGB_elt(mu)}
  , (int -> KType) K_type_index
  , (int -> LK_data) data_index
  )
]

set make_min_bottom_data () = min_bottom_data:
(  let K_type_hash = make_KType_hash()
   then bottom_data = [LK_data]:[] {one entry for each K-type}
   then heights = vec: [] {one for each K-type}
   then Lheights = [vec]: [] {one for each K-type; size #simple factors of L}
   {then natural_KGBs = [KGBElt]: []} {one for each K-type; value of natural_KGB_elt}
   then clear() = void:
       let () = K_type_hash.clear()
       then () = bottom_data:=[]
       then  () = heights := []
       then () = Lheights :=[]
       {then () = natural_KGBs := []}
       in ()
   then enter(KType mu) = int:
       let M = K_type_hash.size()
       then m = K_type_hash.match(mu)
       then () = if m = M
	     	 then let start = elapsed_ms()
		      {then xcG = natural_KGB_elt(mu)}
		      then (,mbf) = min_bottom_factors(mu{,xcG})
		      then () = bottom_data#:= mbf
		      then () = heights#:= max(for (tau,) in mbf
					       do height(tau)
					       od)
		      then (,list) = mbf[0]
		      in Lheights#:= for dertauL in list
				     	     do next_heights(dertauL.real_form)
				     	     od
		      {in natural_KGBs#:= xcG}
		 fi
        then () = assert(#bottom_data = K_type_hash.size(),"min_bottom_data damaged")
	then () = assert(#heights = #bottom_data,"min_bottom_data damaged")
	then () = assert(#Lheights = #bottom_data,"min_bottom_data damaged")
	{then () = assert(#natural_KGBs = #bottom_data,"min_bottom_data damaged")}
	in m
   in
   ( ( -> int): { size } @int: K_type_hash.size()
   , ( -> ): {clear} clear
   , (KType->LK_data): {entry} (KType mu) LK_data:
     begin
	let m = enter(mu)
	in bottom_data[m]
     end
   , (KType->int): {G_min_height} (KType mu) int:
     begin
	let m = enter(mu)
	in heights[m]
     end
   , (KType->vec): {L_min_heights} (KType mu) vec:
     begin
	let m = enter(mu)
	in Lheights[m]
     end
{   , (KType->KGBElt): {natural_KGB} (KType mu) KGBElt:
     begin
	let m = enter(mu)
	in natural_KGBs[m]
     end}
   , (int -> KType): {K_type_index} (int j): K_type_hash.index(j)
   , (int -> LK_data): {data_index} (int j): bottom_data[j]
  )
)

{use this constant one instead of carrying around bott_data}
set minBottomData = make_min_bottom_data()


set basis_lambda_differential_0(mat theta) = mat: {columns are weights lambda with (1+theta)lambda = 0,
    				   	    	  mod (1-theta)X^*}
    let E = eigen_lattice(theta, -1)
    then(A,v) = adapted_basis(in_lattice_basis(E,1-theta))
    in E*columns_with((int j):v[j] = 2,A)

set all_even_lambda_differential_0(RootDatum rd, mat theta) = [vec]:
    let basis = basis_lambda_differential_0(theta), (RSC,) = {real simple coroots}
    	      	simple_system_from_positive(real_poscoroots(rd,theta), real_posroots(rd,theta))
    in for v in all_0_1_vecs(n_columns(basis))
       do let C = basis*v
       	  in if all(for ac in RSC do is_even(ac*C) od)
	     then [C]
	     else []
	     fi
	od.##

{permutation of the simple roots defined by delta}
set delta_on_simple(InnerClass ic) = [int]:
    let r = ic.semisimple_rank, SR = ic.simple_roots, delta = ic.distinguished_involution
    in for i:r do first(for j:r do SR[i] = delta*SR[j] od) od

{these are the maximal proper theta-stable parabolics containing Q}
set max_Qs(KGPElt Q) = [KGPElt]:
    let S= Q.S, x = Q.x, L = Q.Levi
    then xL = inverse_embed_KGB(x,L), G = x.real_form
    then Sc = complement(G.semisimple_rank,S), DOS = delta_on_simple(G),
    	 delta = G.distinguished_involution
    then fixc = for a in Sc
    	      	do if DOS[a] = a
		   then [a]
		   else []
		   fi
		od.##
    then pairsc = for a in Sc
    	 	  do if DOS[a] > a
		     then [[a,DOS[a]]]
		     else []
		     fi
		  od.##
    in [KGPElt]: for a in fixc do (complement(G.semisimple_rank, [a]),x) od##
	 	 for v in pairsc do (complement(G.semisimple_rank,v), x) od

{these are all maximal proper theta-stable Levis}
set max_Ls(RealForm G) = [RealForm]:
    let rfhash = make_RealForm_hash()
    then () = for x in thetaStable(G)
    	      do let Bx = KGPElt: ([],x)
	      	 in for Q in max_Qs(Bx)
	    	    do rfhash.match(Q.Levi)
		    od
	      od
     in for j:rfhash.size()
     	do rfhash.index(j)
	od

{these are the maximal proper theta-stable parabolics from which p is naturally cohom induced,
       with inducing reps}
set max_Qps(Param p, [KGPElt] maxQs) = [(KGPElt,Param)]:
    let (Q0,pL0) = theta_stable_quasi_data(p)
    in for Q in maxQs
       do (Q,first_param(theta_induce_standard(pL0,Q.Levi)))
       od

set max_Qps(Param p) = [(KGPElt,Param)]:
    let (Q0,pL0) = theta_stable_quasi_data(p)
    then maxQs = max_Qs(Q0)
    in for Q in maxQs
       do (Q,first_param(theta_induce_standard(pL0,Q.Levi)))
       od


{returns is_good, is_weakly_good, is_weakly_fair for each maximal Q from which p is coh ind}
set max_goodness(Param p, [(KGPElt,Param)] maxQps) = [(bool, bool, bool)]:
    let G = p.real_form
    in for (Q,pL) in maxQps
       do let L = pL.real_form
       	  then gamma = pL.infinitesimal_character + G.rho - L.rho
       	  then gamma0 = gamma - sum(G.rank, for xi@j in L.fundamental_weights
    	 	  	  	       do (simple_coroots(L)[j]*gamma)*xi od)
       	  in (is_dominant(G,gamma) and is_regular(G,gamma), is_dominant(G,gamma), is_dominant(G,gamma0))
       od

set max_goodness(Param p) = [(bool, bool, bool)]:
    let maxQps = max_Qps(p)
    in max_goodness(p, maxQps)

{this time counter INCLUDES the time in bottom_factor, which is separately counted by bfTime. Correct
at printing in FPP_globalDirac.at}
set befmoreTime = int:0 {time spent with non-minimal parabolics}
set mbefTime = int: 0 {time spent in min_bottom_elim_factors}

{whether to use _more versions of bottom layer tests for unitarity}
set more_flag = false

{meant to hold nonunitary reps identified first by more}
set more_good_hash = make_Param_hash()

{set coh_ind_is_unitary(Param p) = bool:
    let {mu = LKTs(p)[0],} G = p.real_form
    then (Q,pL) = theta_stable_quasi_data(p)
    then gamma = pL.infinitesimal_character + G.rho - pL.real_form.rho
    then () = if not (is_dominant(G,gamma))
    	      then return is_unitary_hash(p)
	      fi {now induction is at least weakly good}
    then derpLjs = derived_factor_params2(pL) {one for each derived simple factor derLj}
    then test = all(for derpLj in derpLjs do is_unitary_hash(derpLj) od)
    then () = if all(for j in Q.S do gamma*G.simple_coroots[j] > 0 od) {is_good(pL,G)}
    	      then return test
	      fi
    then () = if test
    	      then return true
	      fi
    in is_unitary_hash(p)}

set min_bottom_elim_factors(Param p, {[KGPElt] maxQs,} KTypePol P) = bool:
    let start = elapsed_ms(), (,pL) = theta_stable_quasi_data(p), G = p.real_form
    {then () = if is_unitary_hash(pL) then return true fi} {seems to slow things down}
     then () = if more_flag {do good range stuff}
     	       then let maxQps = max_Qps(p{,maxQs})
     	       	    then three_bools = max_goodness(p, maxQps), R = more_good_hash.size()
     	  	    then good = first(for (g,,) in three_bools do g od)
		    {then () = prints("good = ",good)}
     	  	    then () = if good>=0
    	       	    	      then let (,pL) =  maxQps[good]
	      	    	      	   then () = if bottom_verbose then prints("p = ",p," is a good one!") fi
				   then derpLs = derived_factor_params2(pL)
				   then answer = all(for derpL in derpLs
				   	       	     do @bool: is_unitary_hash_big_SIMPLE(derpL)
						     od)
                    	 	   {then () = attest_is_unitary(p,answer)}
		    	 	   then () = befmoreTime +:= elapsed_ms() - start
                    	      	   in return answer
	      	     	      fi {now there is nothing good}
     	  	    then wk_good = first(for (,wg,) in three_bools do wg od)
		    {then () = prints("wk_good = ",wk_good)}
     	  	    in if wk_good >= 0 {form on p is induced from form on L}
    	     	       then let (,pwk) = maxQps[wk_good]
		       	    then derpLwks = derived_factor_params2(pwk)
			    then answer = if all(for derpLwk in derpLwks
				   	       	 do @bool: is_unitary_hash_big_SIMPLE(derpLwk)
						 od)
					  then true
					  else let HG = theta_induce_signature(pwk,G)
		  	    		       in is_pure(HG)
					  fi
		  	     then () = befmoreTime +:= elapsed_ms() - start
			     in return answer
	     	       fi
    	        fi
    then derpLjs = derived_factor_params2(pL)
    then () = mbefTime +:= elapsed_ms()-start
    then answers = [(->bool)]: {one function for each LKT mu of p}
    	 for mu in LKTs(p)
    	 do let LKData = minBottomData.entry(mu) {[tau,[dertauLj]]}, pmu = param(mu)
	    then DG = minBottomData.G_min_height(mu), (,pLmu) = theta_stable_quasi_data(pmu)
	    then DLs = minBottomData.L_min_heights(mu), muL = LKT(pLmu)
	    then () = start:= elapsed_ms()
    	    then derxLjs = for derpLj in derpLjs do derpLj.x od
            then derLjs = for derpLj in derpLjs do derpLj.real_form od
 	    then dermuLjs = derived_factor_K_types2(muL)
	    then  multG = branch_std(P,DG)
	    {then () = prints(multG)}
	    then Lbranches = for derpLj@j in derpLjs
	    	       	 do let sigLj =
		            	if big_unitary_hash.uhash(derLjs[j]).lookup(derpLj).>=
				then let startCF = elapsed_ms()
				     then Q = character_formula(derpLj)
				     then () = charTime +:= elapsed_ms() - startCF
				     then () = char_counter.use()
				     in K_type_pol(Q)
				elif RF_code
	    	      		then rf_sig_tables.sig_entry(derpLj)
				else hermitian_form_irreducible(derpLj){, DLs[j])}
		        	fi
	              	     in if int_part(sigLj[dermuLjs[j]]) = 0
		       	        then branch_std(s*sigLj, DLs[j])
				else branch_std(sigLj,DLs[j])
				fi
			 od
	    {then () = for Lsig in Lsigs do prints(Lsig) od}
	    then () = mbefTime +:= elapsed_ms()-start
	    in @: all( [(->bool)]:
	       	       for (tau,list) in LKData[1:] {one function for each min_bottom K-type tau}
 		       do let coeff = Split: 1 {this will be the bottom layer signature at tau}
			  then () = for tauLj@j in list
			       	    do {if Lsigs[j][tauLj] = 0
			     	       then prints(j," ",tauLj," ",Lsigs[j]," ",Lsigs[j])
			     	       fi;}
			     	       coeff*:= Lbranches[j][tauLj]
			  	    od
		    	   in @bool: int_part(coeff) >= int_part(multG[tau])
	       	        od)
        od
	then answer = all(answers)
	{then () = if not answer then attest_is_unitary(p,answer) fi}
	{then () = mbefTime +:= elapsed_ms()-start}
        in answer

set min_bottom_elim_factors(Param p{, [KGPElt] maxQs}) = bool:
    let startCF = elapsed_ms()
    then Q = character_formula(p)
    then () = charTime +:= elapsed_ms() - startCF
    then () = char_counter.use()
    in min_bottom_elim_factors(p, K_type_pol(Q))

set min_bottom_test_factors(Param p) = bool:
    if not min_bottom_elim_factors(p)
    then false
    else is_unitary_hash_big(p)
    fi

set min_bottom_test_factors(Param p, KTypePol P) = bool:
    if not min_bottom_elim_factors(p, P)
    then return false
    else is_unitary_hash_big(p)
    fi

set bfTime = int: 0

{K-types tau on G need to be descended to each derLj.}
{Each term in answer is (tau,list of corr dertauj's).}
set bottom_factors(KType mu, QK_bottom_data (Q,taus)) = QKL_bottom_data: {(KGPElt,[(KType, [KType])])}
    let p = parameter(mu), {Dshift = D - height(mu),} start = elapsed_ms()
    then (Q0,pL0) = theta_stable_quasi_data(p), G = p.real_form, L = Q.Levi
    then L0 = Q0.Levi, muL0 = LKT(pL0)
    then xcL0 = natural_KGB_elt(muL0){KGB(L0,0)}{inverse_embed_KGB(xcG, L0)} {x_min(Q0)}
    then xcG = embed_KGB(xcL0,G)
    then pL = first_param(theta_induce_standard(pL0,L)), SFRP = simple_factor_root_partition(Q)
    then muL = LKT(pL)
    then dermuLs = derived_factor_K_types2(muL) {each dermuLj is on a simple derived derLj}
    {then DLjs = for dermuLj in dermuLs do height(dermuLj) + Dshift
    od}
    then xcL = embed_KGB(xcL0,L)
    then derLsInfo = derived_simple_factors_info(L) {DERIVED simple factors}
    then derxjs = derived_factor_KGBs2(xcL)
    {then K0 = K_0(xcG), ProjK = projection_to_K_matrix(mu.inner_class)}
    then muwt = {highest_weight(mu,xcG).mu} K0_param(mu,xcG).lambda_minus_rho,
    	      	muLwt = K0_param(muL,xcL).lambda_minus_rho
    then tau_shifts = for tau in taus do {highest_weight(tau,xcG).mu} K0_param(tau,xcG).lambda_minus_rho - muwt od
    then tauLs = for shift in tau_shifts do K_type(K_highest_weight_from_K0_weight(xcL,muLwt+shift)) od
    then () = bfTime+:= elapsed_ms() - start
    in (Q, for tau@k in taus
       	   do (tau, derived_factor_K_types2(tauLs[k]))
       	   od)

set bottom_factors(KType mu, [QK_bottom_data] data) = [QKL_bottom_data]: {[(KGPElt,[(KType, [KType])])]}
    for (Q,taus) in data do bottom_factors(mu, (Q,taus)) od

{false guarantees not unitary, but true does not guarantee unitary}
{LKdata[j] is [(tauj,tauLj)]: tauLj are thes Lj\cap K-types inducing to a bottom layer tauj of p.}
set bottom_elim_factors(Param p, KType mu, QKL_bottom_data (Q,LKdata)) = bool:
    let start = elapsed_ms(), {answers = for k:#LKdata do false od,}
    	(,pL0) = theta_stable_quasi_data(p), L = Q.Levi, pmu = param(mu)
    then () = if K_type_pol(p)[mu] = 0
       	      then return if bottom_verbose then prints("mu isn't a LKT of p") fi; true
       	      fi
    {then () = if sum(for pairs in Q.LKdata do #pairs od) = #Q.LKdata
    	      then return true
	      fi}
    then pL = first_param(theta_induce_standard(pL0,L)), (,pmuL0) = theta_stable_quasi_data(pmu)
    then pmuL = first_param(theta_induce_standard(pmuL0,L))
    {then () = if is_unitary_hash(pL) then return true fi}{seems to slow things}
    then derpLjs = derived_factor_params2(pL){one for each derived simple factor derLj}, muL = LKT(pmuL)
    then dermuLjs = derived_factor_K_types2(muL)
    {then badjs = {#(#derpLjs)}
    	       	 for derpLj@j in derpLjs
    	       	 do if is_unitary_hash(derpLj)
		    then []
		    else [j]
		    fi
		 od.##
    then () = if #badjs = 0 then return true fi
    then badderpLjs = for j in badjs do derpLjs[j] od}
    then derxLjs = for {bad} derpLj in {bad} derpLjs do derpLj.x od
    then {bad} derLjs = for derpLj in derpLjs do derpLj.real_form od
    {we wish these dermuLjs were LKTs of derpLj; need to twist derpLj to make this true.}
    {then baddermuLjs = for j in badjs
    	 	       do dermuLjs[j]
		       od}
      {check badderpLj has baddermuLj as a LKT}
    then () = for {bad}derpLj@j in {bad}derpLjs
      	      	do {assert(not K_type_pol(badderpLj)[baddermuLjs[k]].=,"oops, we needed a twist")}
		   if K_type_pol({bad}derpLj)[{bad}dermuLjs[j]].=
		   then let twistj = all_even_lambda_differential_0({bad}derLjs[j].dual, - {bad}derxLjs[j].involution.^)
		   	then () = if bottom_verbose then prints("twisting derpLj needed at p = ",p, ", j = ",j) fi
		   	then twistxLs = let Genx = KGB_elt_gen({bad}derxLjs[j])
				      	in for t@i in twistj
			   	      	   do let () = Genx.torus_factor +:= t
					      {need to force real form}
			      	      	      in KGB({bad}derpLj.real_form, KGB_elt(Genx).number) 
			   	      	   od
		    	then twistderpLjs = for yLj in twistxLs
		    	 	      	do parameter(yLj, {bad}derpLj.lambda, {bad}derpLj.nu)
				    	od
		    	then m = first(for derqLj in twistderpLjs
		    	     	       do K_type_pol(derqLj)[{bad}dermuLjs[j]] != 0
				       od)
		    	then () = if m < 0
		     	       	  then prints("x twisting failed at p = ",p,", j = ",j)
			       	  else {bad}derpLjs[j] := twistderpLjs[m]
			       	  fi
		    	in ()
		    fi
		od
       then DG = max(for (tau,) in LKdata
		     do height(tau)
		     od)
       then DLs = for j:#derpLjs
       	    	  do max(for (,list) in LKdata
		     	 do height(list[j])
			 od)
		  od
       then multG = branch_irr(p,DG)
       then branchLjs = for derpLj@j in derpLjs
	       	      	do let sigLj =
	       	   	       if RF_code
		   	       then rf_sig_tables.sig_entry(derpLj){, DLs[k])}
		   	       else hermitian_form_irreducible(derpLj)
		   	       fi
			   then () = if int_part(sigLj[dermuLjs[j]]) = 0
		       	   	     then sigLj := s*sigLj
			 	     fi
	       		   in branch_std(sigLj, DLs[j])
			od
        then result = all( [(->bool)]: {list of functions, one for each bottom layer K-type tau}
			for(tau,list) in LKdata
			do {prints(posLj[tauLj]," ",multG[tauj]);}
			   let coeff = Split: 1 {this will be the bottom layer signature at tau}
			   then () = for tauLj@j in list
			       	    do {if Lsigs[j][tauLj] = 0
			     	       then prints(j," ",tauLj," ",Lsigs[j]," ",Lsigs[j])
			     	       fi;}
			     	       coeff*:= branchLjs[j][tauLj]
			  	    od
			   in @bool: int_part(coeff) >= int_part(multG[tau])
			od )
        {then () = if not result then attest_is_unitary(p,result) fi}
	then () = {mbefTime} befmoreTime +:= elapsed_ms()-start
	in result

{false guarantees not unitary, but true does not guarantee unitary}
{An entry of LKdata is [(tau,[dertauLj])]: dertauLj are the derLj\cap K-types
attached to a bottom layer inducing to a bottom layer tau of p.}
set bottom_elim_factors(Param p, KType mu, int D, KGPElt Q, [(KType,[KType])] LKdata) = bool:
    let start = elapsed_ms(), {answers = for k:#LKdata do false od,}
    	(,pL0) = theta_stable_quasi_data(p), L = Q.Levi
    then () = if K_type_pol(p)[mu] = 0
       	      then return if bottom_verbose then prints("mu isn't a LKT of p") fi; true
       	      fi
    then pL = first_param(theta_induce_standard(pL0,L))
    then muL = LKT(pL)
    {then () = if is_unitary_hash(pL) then return true fi}{seems to slow things}
    then derpLjs = derived_factor_params2(pL) {one for each derived simple factor derLj}
    {then badjs = {#(#derpLjs)}
    	       	 for derpLj@j in derpLjs
    	       	 do if is_unitary_hash(derpLj)
		    then []
		    else [j]
		    fi
		 od.##
    then () = if #badjs = 0 then return true fi
    then badderpLjs = for j in badjs do derpLjs[j] od}
    then derxLjs = for derpLj in derpLjs do derpLj.x od
    then derLjs = for derpLj in derpLjs do derpLj.real_form od
    {we wish these dermuLjs were LKTs of derpLj; need to twist derpLj to make this true.}
    then dermuLjs = derived_factor_K_types2(muL)
    then DLs = for j:#derLjs
       	       do max(for (tau, list) in LKdata {one for each j}
       	    	      do height(list[j])
		      od)
	       od
    then multG = branch_irr(p,D)
    then branchLjs = for derpLj@j in derpLjs
	       	     do let sigLj =
	       	   	    if RF_code
		   	    then rf_sig_tables.sig_entry(derpLj){, DLs[k])}
		   	    else hermitian_form_irreducible(derpLj)
		   	    fi
			then () = if int_part(sigLj[dermuLjs[j]]) = 0
		       	   	  then sigLj := s*sigLj
			 	  fi
	       		in branch_std(sigLj, DLs[j])
		     od
     then result = all( [(->bool)]: {list of functions, one for each bottom layer K-type tau}
			for(tau,list) in LKdata
			do {prints(posLj[tauLj]," ",multG[tauj]);}
			   let coeff = Split: 1 {this will be the bottom layer signature at tau}
			   then () = for tauLj@j in list
			       	    do {if Lsigs[j][tauLj] = 0
			     	       then prints(j," ",tauLj," ",Lsigs[j]," ",Lsigs[j])
			     	       fi;}
			     	       coeff*:= branchLjs[j][tauLj]
			  	    od
			   in @bool: int_part(coeff) >= int_part(multG[tau])
			od )
        {then () = if not result then attest_is_unitary(p,result) fi}
	then () = {mbefTime} befmoreTime +:= elapsed_ms()-start
	in result

set bottom_elim_factors(Param p, KType mu, (KGPElt Q, [(KType,[KType])] LKdata), KTypePol P) = bool:
    let start = elapsed_ms(), {answers = for k:#LKdata do false od,}
    	(,pL0) = theta_stable_quasi_data(p), L = Q.Levi
    then () = if K_type_pol(p)[mu] = 0
       	      then return if bottom_verbose then prints("mu isn't a LKT of p") fi; true
       	      fi
    then pL = first_param(theta_induce_standard(pL0,L))
    {then pmu = parameter(mu)}
    then muLs = LKTs(pL)
    then muL = muLs[first(for muL in muLs do mu = LKT(first_param(theta_induce_standard(parameter(muL),p.real_form))) od)]
    {then () = if is_unitary_hash(pL) then return true fi}{seems to slow things}
    then derpLjs = derived_factor_params2(pL) {one for each derived simple factor derLj}
{    then badjs = {#(#derpLjs)}
    	       	 for derpLj@j in derpLjs
    	       	 do if is_unitary_hash(derpLj)
		    then []
		    else [j]
		    fi
		 od.##
    then () = if #badjs = 0 then return true fi
    then badderpLjs = for j in badjs do derpLjs[j] od}
    then derxLjs = for derpLj in derpLjs do derpLj.x od
    then derLjs = for derpLj in derpLjs do derpLj.real_form od
    {we wish these dermuLjs were LKTs of derpLj; hope we don't need to twist derpLj to make this true.}
    then dermuLjs = derived_factor_K_types2(muL)
    then DLs = for j:#derpLjs
       	       do max(for (, list) in LKdata {one for each j}
       	    	      do height(list[j])
		      od)
	       od
    then D = max(for (tau,) in LKdata do height(tau) od)
    then Pmult = branch_std(P, D)
    then branchLjs = for derpLj@j in derpLjs
	       	     do let sigLj =
	       	   	    if RF_code
		   	    then rf_sig_tables.sig_entry(derpLj){, DLs[k])}
		   	    else hermitian_form_irreducible(derpLj)
		   	    fi
			then () = if int_part(sigLj[dermuLjs[j]]) = 0
		       	   	  then sigLj := s*sigLj
			 	  fi
	       		in branch_std(sigLj, DLs[j])
		     od
       then result = all( [(->bool)]: {list of functions, one for each bottom layer K-type tau}
			for(tau,list) in LKdata
			do {prints(posLj[tauLj]," ",multG[tauj]);}
			   let coeff = Split: 1 {this will be the bottom layer signature at tau}
			   then () = for tauLj@j in list
			       	    do {if Lsigs[j][tauLj] = 0
			     	       then prints(j," ",tauLj," ",Lsigs[j]," ",Lsigs[j])
			     	       fi;}
			     	       coeff*:= branchLjs[j][tauLj]
			  	    od
			   in @bool: int_part(coeff) >= int_part(Pmult[tau])
			od )
        {then () = if not result then attest_is_unitary(p,result) fi}
	then () = {mbefTime} befmoreTime +:= elapsed_ms()-start
	in result

{permutation of the simple roots defined by delta}
set delta_on_simple(InnerClass ic) = [int]:
    let r = ic.semisimple_rank, SR = ic.simple_roots, delta = ic.distinguished_involution
    in for i:r do first(for j:r do SR[i] = delta*SR[j] od) od

{For the tempered irr corr to mu, lists K-types to height D which are
bottom layer for some proper parabolic; the smallest such parabolic is
defined by the simple coroots in S. S always contains the coroots S0
vanishing on p.d_lambda.} {useless case is #bottom_K_types = 1}
set bottom_K_types(KType mu, int D) = [(KType,[int])]:
    let q = param(mu), Proj = projection_to_K_matrix(mu.real_form), start = elapsed_ms()
    then (Q0,) = theta_stable_quasi_data(q), G = mu.real_form, ProjInv = right_inverse(Proj)
    then L0 = Q0.Levi, (S0,) = Q0, Krk = #ProjInv
    then S0c = complement(G.semisimple_rank,S0), DOS = delta_on_simple(G),
    	 delta = G.distinguished_involution
    then fixc = for a in S0c {type [int]}
    	      	do if DOS[a] = a
		   then [a]
		   else []
		   fi
		od.##
    then pairsc = for a in S0c {type [[int]]}
    	 	  do if DOS[a] > a
		     then [[a,DOS[a]]]
		     else []
		     fi
		  od.##
    then fixc_cowts = mat:
    	 if #fixc = 0
	 then null(rank(G),0)
    	 else for a in fixc
    	      do G.fundamental_coweights[a].numer*ProjInv
	      od
	 fi
    then pairsc_cowts = mat:
    	 if #pairsc = 0
	 then null(rank(G),0)
    	 else for pair in pairsc
    	      do sum(G.rank, for a in pair do G.fundamental_coweights[a].numer od)*ProjInv
              od
	 fi
    then xcL0 = KGB(L0,0)
    then xcG0 = embed_KGB(xcL0, G)
    then too_many_taus = monomials(branch_irr(q,D))
    then hwt0 = K0_param(mu,xcG0).lambda_minus_rho{highest_weight(too_many_taus[0],xcG0).mu}
    then too_many_shifts = for tau in too_many_taus
    	 	       	 do {highest_weight(tau,xcG0).mu}
			    K0_param(tau, xcG0).lambda_minus_rho - hwt0
			 od
    then too_many_Ss = [[int]]:
    	 for shift in too_many_shifts
	 do S0## (for col@i in fixc_cowts
		  do if (shift*col).= then [] else [fixc[i]] fi
		  od.##)
	      ## (for col@j in pairsc_cowts
		  do if (shift*col).= then [] else pairsc[j] fi
		  od.##)
         od  {these are the coroots needed to make a parabolic
		       	    for which corr tau is bottom layer}
    then () = bfTime:=elapsed_ms() - start
    in for tau@k in too_many_taus
       do if #too_many_Ss[k]= G.semisimple_rank then []
	  else [(tau, too_many_Ss[k].sort)]
	  fi
       od.##

{For the K-type mu, lists the K-types tau in height range (D_low,D) which

a) occur in standard(mu)
b) are not mu
c) are bottom layer for (smallest possible) theta-stable parabolic Q;

list is indexed by Q.}
set bottom_K_type_Qs(KType mu, int D_low, int D) = [QK_bottom_data] {[KGPElt, [KType]]}:
    let q = param(mu), Proj = projection_to_K_matrix(mu.real_form), start = elapsed_ms()
    then (Q0,) = theta_stable_quasi_data(q), G = mu.real_form, ProjInv = right_inverse(Proj)
    then L0 = Q0.Levi, (S0,) = Q0, Krk = #ProjInv
    then S0c = complement(G.semisimple_rank,S0), DOS = delta_on_simple(G),
    	 delta = G.distinguished_involution
    then fixc = for a in S0c {type [int]}
    	      	do if DOS[a] = a
		   then [a]
		   else []
		   fi
		od.##
    then pairsc = for a in S0c {type [[int]]}
    	 	  do if DOS[a] > a
		     then [[a,DOS[a]]]
		     else []
		     fi
		  od.##
    then fixc_cowts = mat:
    	 if #fixc = 0
	 then null(rank(G),0)
    	 else for a in fixc
    	      do (G.fundamental_coweights[a].numer)*ProjInv
	      od
	 fi
    then pairsc_cowts = mat:
    	 if #pairsc = 0
	 then null(rank(G),0)
    	 else for pair in pairsc
    	      do sum(G.rank, for a in pair do G.fundamental_coweights[a].numer od)*ProjInv
              od
	 fi
    then xcL0 = KGB(L0,0)
    then xcG0 = embed_KGB(xcL0, G)
    then br_std_qD = branch_std(q,D)
    then too_many_taus = monomials(br_std_qD - to_ht(br_std_qD,D_low))[1:] {OK since mu is always term 0?}
    {then () = if #too_many_taus > 1 then too_many_taus:=too_many_taus[1:]{omit mu}}
    then hwt0 = K0_param(mu,xcG0).lambda_minus_rho
    then too_many_shifts = for tau in too_many_taus
    	 	       	 do K0_param(tau,xcG0).lambda_minus_rho - hwt0
			 od {what to add to highest weight of mu to get to tau}
    then too_many_Ss = [[int]]:
    	 for shift in too_many_shifts
	 do (S0## (for col@i in fixc_cowts
		  do if (shift*col).= then [] else [fixc[i]] fi
		  od.##)
	      ## (for col@j in pairsc_cowts
		  do if (shift*col).= then [] else pairsc[j] fi
		  od.##)).sort_u
         od  {these are the coroots needed to make a parabolic
		       	    for which tau is bottom layer}
    then candSs = too_many_Ss.sort_u
    then proper_candSs = if #candSs = 0
    	 	       	 then candSs
    	 	       	 else candSs[:#candSs-1] {omit G}
			 fi
    then () = bfTime:=elapsed_ms() - start
    in for S in proper_candSs
       do let list = for tau@j in too_many_taus
       	      	     do if too_many_Ss[j] = S
	     	     	then [tau]
	     		else []
	     		fi
	 	     od.## {this is all tau's attached to S}
	   {then shifts = for }
	   in ((S, xcG0),list)
       od


{For the K-type mu, lists the K-types tau to height D which

a) occur in standard(mu)
b) are not mu
c) are bottom layer for (smallest possible) theta-stable parabolic Q;

list is indexed by Q.}

set bottom_K_type_Qs(KType mu, int D) = [QK_bottom_data] {[KGPElt, [KType]]}:
    let q = param(mu), Proj = projection_to_K_matrix(mu.real_form), start = elapsed_ms()
    then (Q0,) = theta_stable_quasi_data(q), G = mu.real_form, ProjInv = right_inverse(Proj)
    then L0 = Q0.Levi, (S0,) = Q0, Krk = #ProjInv
    then S0c = complement(G.semisimple_rank,S0), DOS = delta_on_simple(G),
    	 delta = G.distinguished_involution
    then fixc = for a in S0c {type [int]}
    	      	do if DOS[a] = a
		   then [a]
		   else []
		   fi
		od.##
    then pairsc = for a in S0c {type [[int]]}
    	 	  do if DOS[a] > a
		     then [[a,DOS[a]]]
		     else []
		     fi
		  od.##
    then fixc_cowts = mat:
    	 if #fixc = 0
	 then null(rank(G),0)
    	 else for a in fixc
    	      do (G.fundamental_coweights[a].numer)*ProjInv
	      od
	 fi
    then pairsc_cowts = mat:
    	 if #pairsc = 0
	 then null(rank(G),0)
    	 else for pair in pairsc
    	      do sum(G.rank, for a in pair do G.fundamental_coweights[a].numer od)*ProjInv
              od
	 fi
    then xcL0 = KGB(L0,0)
    then xcG0 = embed_KGB(xcL0, G)
    then too_many_taus = monomials(branch_std(q,D))[1:] {OK since mu is always term 0?}
    {then () = if #too_many_taus > 1 then too_many_taus:=too_many_taus[1:]{omit mu}}
    then hwt0 = K0_param(mu,xcG0).lambda_minus_rho
    then too_many_shifts = for tau in too_many_taus
    	 	       	 do K0_param(tau,xcG0).lambda_minus_rho - hwt0
			 od {what to add to highest weight of mu to get to tau}
    then too_many_Ss = [[int]]:
    	 for shift in too_many_shifts
	 do (S0## (for col@i in fixc_cowts
		  do if (shift*col).= then [] else [fixc[i]] fi
		  od.##)
	      ## (for col@j in pairsc_cowts
		  do if (shift*col).= then [] else pairsc[j] fi
		  od.##)).sort_u
         od  {these are the coroots needed to make a parabolic
		       	    for which tau is bottom layer}
    then candSs = too_many_Ss.sort_u
    then proper_candSs = if #candSs = 0
    	 	       	 then candSs
    	 	       	 else candSs[:#candSs-1] {omit G}
			 fi
    then () = bfTime:=elapsed_ms() - start
    in for S in proper_candSs
       do let list = for tau@j in too_many_taus
       	      	     do if too_many_Ss[j] = S
	     	     	then [tau]
	     		else []
	     		fi
	 	     od.## {this is all tau's attached to S}
	   {then shifts = for }
	   in ((S, xcG0),list)
       od

set card([QK_bottom_data] data) = int:
    sum(for (,list) in data do #list od)

set card([(KType, [(KGPElt,[(KType,[KType])])])] datass) = int:
    sum(for (,datas) in datass do sum(for(,list) in datas do #list od) od)


{For the irreducible p, lists the K-types to height D which are bottom layer for some proper parabolic;
the smallest such parabolic is defined by the simple coroots in S. S always contains the coroots S0
vanishing on p.d_lambda.}
set bottom_K_types(Param p, int D) = [(KType,[int])]:
    let q = first_param(finalize(p)), start = elapsed_ms()
    then (Q0,) = theta_stable_quasi_data(q), {x = p.x, lambda = p.lambda}
    	G = p.real_form
    then L0 = Q0.Levi, (S0,) = Q0, Proj = projection_to_K_matrix(G)
    then ProjInv = right_inverse(Proj)
    then S0c = complement(G.semisimple_rank,S0), DOS = delta_on_simple(G),
    	 delta = G.distinguished_involution, Krk = #ProjInv
    then fixc = for a in S0c {type [int]}
    	      	do if DOS[a] = a
		   then [a]
		   else []
		   fi
		od.##
    then pairsc = for a in S0c {type [[int]]}
    	 	  do if DOS[a] > a
		     then [[a,DOS[a]]]
		     else []
		     fi
		  od.##
    then fixc_cowts = mat:
    	 if #fixc = 0
	 then null(rank(Proj),0)
    	 else for a in fixc
    	      do (G.fundamental_coweights[a].numer)*ProjInv
	      od
	 fi
    then pairsc_cowts = mat:
    	 if #pairsc = 0
	 then null(rank(Proj),0)
    	 else for pair in pairsc
    	      do sum(G.rank, for a in pair do G.fundamental_coweights[a].numer od)*ProjInv
              od
	 fi
    then xcL0 = KGB(L0,0)
    then xcG0 = embed_KGB(xcL0, G)
    then too_many_taus = monomials(branch_irr(q,D))
    then hwt0 = {highest_weight(too_many_taus[0],xcG0).mu}K0_param(too_many_taus[0],xcG0).lambda_minus_rho
    then too_many_shifts = for tau in too_many_taus
    	 	       	 do {highest_weight(tau,xcG0).mu}
			    K0_param(tau,xcG0).lambda_minus_rho- hwt0
			 od
    then too_many_Ss = [[int]]:
    	 for shift in too_many_shifts
	 do (S0## (for col@i in fixc_cowts
		  do if (shift*col).= then [] else [fixc[i]] fi
		  od.##)
	      ## (for col@j in pairsc_cowts
		  do if (shift*col).= then [] else pairsc[j] fi
		  od.##)).sort
         od  {these are the coroots needed to make a parabolic
		       	    for which corr tau is bottom layer}
    then () = bfTime:=elapsed_ms() - start
    in for tau@k in too_many_taus
       do if #too_many_Ss[k]= G.semisimple_rank then []
	  else [(tau, too_many_Ss[k])]
	  fi
       od.##

{returns is_good, is_weakly_good, is_weakly_fair}
set goodness(Param p, KGPElt Q) = (bool, bool, bool):
    let (P0,pL0) = theta_stable_quasi_data(p), L = Q.Levi, G = p.real_form
    then pL = first_param(theta_induce_standard(pL0,L))
    then gamma = pL.infinitesimal_character + G.rho - pL.real_form.rho
    then gamma0 = gamma - sum(G.rank, for xi@j in L.fundamental_weights
    	 	  	  	      do (simple_coroots(L)[j]*gamma)*xi
				      od)
    in (is_dominant(G,gamma) and is_regular(G,gamma), is_dominant(G,gamma), is_dominant(G,gamma0))

{D is meant to be max(height(tau) for tau in BKT. nQs are the parabolics where bottom layer might help.}
{nQs is meant to be new_Qs(), P the K-character of p}
{need to be sure nQs does not include a Borel}
set bottom_elim_factors_more(Param p, [KGPElt] maxQs, [KType, [QKL_bottom_data]] datas, KTypePol P)= bool:
    let start =  elapsed_ms(), G=p.real_form
     then maxQps = max_Qps(p,maxQs)
     then three_bools = max_goodness(p, maxQps), R = more_good_hash.size()
     then good = first(for (g,,) in three_bools do g od)
     then () = if good>=0
    	       then let (,pL) =  maxQps[good]
	      	    then () = if bottom_verbose then prints("p = ",p," is a good one!") fi
                    then answer = is_unitary_hash_big(pL)
                    {then () = attest_is_unitary(p,answer)}
		    then () = befmoreTime +:= elapsed_ms() - start
                    in return answer
	      	fi
     then wk_good = first(for (,wg,) in three_bools do wg = true od)
     then () = if wk_good >= 0 {form on p is induced from form on L}
    	       then let (,pL) = maxQps[wk_good]
	       	    then HG = theta_induce_signature(pL,G){, Ip = theta_induce_irreducible(pL,G)}
		    then G_pure = is_pure(HG)
		    in  befmoreTime +:= elapsed_ms() - start;
                        {attest_is_unitary(p, G_pure);}
			return G_pure
	        fi
     then () = befmoreTime +:= elapsed_ms() - start
     then () = if not all(for (mu, data) in datas
			 do @bool: all(for (Q,list) in data
				       do  @bool: bottom_elim_factors(p, mu, (Q, list), P)
			      	       od)
		         od) {this seems to be quite rare??}
	       then let MG = more_good_hash.size()
		    then mg = more_good_hash.match(p)
		    then () = if bottom_verbose and mg=MG
			      then prints("at p = ",p,", more helped!")
			      fi
                    {then () = attest_is_unitary(p,false)}
		    then () = befmoreTime +:= elapsed_ms() - start
		    in return false
	       fi
     then () = if bottom_verbose then prints("sorry, don't know") fi
     in true

set bottom_elim_factors_more(Param p, [KGPElt] maxQs, [KType, [QKL_bottom_data]] mudatas)= bool:
    let h = height(p)
    then D = max(for (mu, datas) in mudatas
    	    	do max(for (Q,LKdata) in datas
		       do max(for (tau,) in LKdata do height(tau) od#h)
		       od#h)
		od#h)
    then startCF = elapsed_ms()
    then Q = character_formula_to_height(p,D)
    then () = charTime +:= elapsed_ms() - startCF
    {then () = prints("in befm, use ",elapsed_ms() - startCF)}
    then () = char_counter.use()
    then P = K_type_pol(Q)
    in  bottom_elim_factors_more(p, maxQs, mudatas, P)

{D is meant to be max(height(tau) for tau in BKT. nQs are the parabolics where bottom layer might help.}
{nQs is meant to be new_Qs(), P the K-character of p}
{need to be sure nQs does not include a Borel}
set bottom_elim_factors_more(Param p, int D, KTypePol P)= bool:
    let start =  elapsed_ms(), G=p.real_form, (Q0,pL0) = theta_stable_quasi_data(p)
    then maxQs = max_Qs(Q0), R = more_good_hash.size()
    then maxQps = max_Qps(p,maxQs)
    then three_bools = max_goodness(p, maxQps)
     then good = first(for (g,,) in three_bools do g od)
     then () = if good>=0
    	       then let (,pL) =  maxQps[good]
	      	    then () = if bottom_verbose then prints("p = ",p," is a good one!") fi
                    then answer = is_unitary_hash_big(pL)
                    {then () = attest_is_unitary(p,answer)}
		    then () = befmoreTime +:= elapsed_ms() - start
                    in return answer
	      	fi
     then wk_good = first(for (,wg,) in three_bools do wg = true od)
     then () = if wk_good >= 0 {form on p is induced from form on L}
    	       then let (,pL) = maxQps[wk_good]
	       	    then HG = theta_induce_signature(pL,G){, Ip = theta_induce_irreducible(pL,G)}
		    then G_pure = is_pure(HG)
		    in  befmoreTime +:= elapsed_ms() - start;
                        {attest_is_unitary(p, G_pure);}
			return G_pure
	        fi
     then () = befmoreTime +:= elapsed_ms() - start
     then () = if not all(for mu in LKTs(p)
			 do @bool: all(for (Q,list) in bottom_K_type_Qs(mu,D)
				       do  @bool: bottom_elim_factors(p, mu, bottom_factors(mu, (Q, list)), P)
			      	       od)
		         od) {this seems to be quite rare??}
	       then let MG = more_good_hash.size()
		    then mg = more_good_hash.match(p)
		    then () = if bottom_verbose and mg=MG
			      then prints("at p = ",p,", more helped!")
			      fi
                    {then () = attest_is_unitary(p,false)}
		    then () = befmoreTime +:= elapsed_ms() - start
		    in return false
	       fi
     then () = if bottom_verbose then prints("sorry, don't know") fi
     in true

set bottom_elim_factors_more(Param p, int D) = bool:
    let startCF = elapsed_ms()
    then Q = character_formula_to_height(p,D)
    then () = charTime +:= elapsed_ms() - startCF
    then () = char_counter.use()
    then P = K_type_pol(Q)
    in  bottom_elim_factors_more(p, D, P)


{D is meant to be max(height(tau) for tau in BKT. nQs are the parabolics where bottom layer might help.}
{nQs is meant to be new_Qs(), P the K-character of p}
{need to be sure nQs does not include a Borel}
set bottom_test_factors_more(Param p, [KGPElt] maxQs, [KType, [QKL_bottom_data]] datas, KTypePol P)= bool:
    if not more_flag
    then is_unitary_hash_big(p) {min_bottom_test_factors(p,P)}
    else
     let start =  elapsed_ms(), G=p.real_form
     then maxQps = max_Qps(p, maxQs), R = more_good_hash.size()
     then three_bools = max_goodness(p, maxQps)
     then good = first(for (g,,) in three_bools do g od)
     then () = if good>=0
    	       then let (,pL) =  maxQps[good]
	      	    then () = if bottom_verbose then prints("p = ",p," is a good one!") fi
                    then answer = is_unitary_hash_big(pL)
                    {then () = attest_is_unitary(p,answer)}
		    then () = befmoreTime +:= elapsed_ms() - start
                    in return answer
	      	fi
     then wk_good = first(for (,wg,) in three_bools do wg = true od)
     then () = if wk_good >= 0 {form on p is induced from form on L}
    	       then let (,pL) = maxQps[wk_good]
	       	    then HG = theta_induce_signature(pL,G){, Ip = theta_induce_irreducible(pL,G)}
		    then G_pure = is_pure(HG)
		    in  befmoreTime +:= elapsed_ms() - start;
                        {attest_is_unitary(p, G_pure);}
			return G_pure
	        fi
     then () = befmoreTime +:= elapsed_ms() - start
     then () = if not all(for (mu, data) in datas
			 do @bool: all(for (Q,list) in data
				       do  @bool: bottom_elim_factors(p, mu, (Q, list), P)
			      	       od)
		         od) {this seems to be quite rare??}
	       then let MG = more_good_hash.size()
		    then mg = more_good_hash.match(p)
		    then () = if bottom_verbose and mg=MG
			      then prints("at p = ",p,", more helped!")
			      fi
                    {then () = attest_is_unitary(p,false)}
		    then () = befmoreTime +:= elapsed_ms() - start
		    in return false
	       fi
     then () = if bottom_verbose then prints("sorry, doing is_unitary") fi
     in is_unitary_hash_big(p)
    fi

{P is K-character at least to appropriate height, NOT branch!. Assume already eliminated using minimal P0}
set bottom_test_factors_more(Param p, int D, KTypePol P) = bool:
    if not more_flag
    then is_unitary_hash_big(p) {min_bottom_test_factors(p,P)}
    else
    let start = elapsed_ms(), G = p.real_form
    then three_bools = max_goodness(p), maxQps = max_Qps(p)
    then good = first(for (g,,) in three_bools do g od)
    then () = if good>=0
    	      then let (,pL) =  maxQps[good]
	      	   then () = if bottom_verbose then prints("p = ",p," is a good one!") fi
		   then answer = is_unitary_hash_big(pL)
		   {then () = attest_is_unitary(p,answer)}
		   in return answer
	      fi
    then wk_good = first(for (,wg,) in three_bools do wg = true od)
    then () = if wk_good >= 0
    	      then let (,pL) = maxQps[wk_good]
	       	   then HG = theta_induce_signature(pL,G){, Ip = theta_induce_irreducible(pL,G)}
		   then G_pure = is_pure(HG)
		   in befmoreTime +:= elapsed_ms() - start;
		      {attest_is_unitary(p,G_pure);}
		      return G_pure
	      fi

    then () = befmoreTime+:= elapsed_ms() - start
    then () = if not all(for mu in LKTs(p)
			 do @bool: all(for (Q,list) in bottom_K_type_Qs(mu,D)
			    	       do @bool: bottom_elim_factors(p, mu, bottom_factors(mu,(Q,list)), P)
				       od)
		         od)
	       then let MG = more_good_hash.size()
		    then mg = more_good_hash.match(p)
		    then () = if bottom_verbose and mg=MG
			      then prints("at p = ",p,", more helped!")
			      fi
		    {then () = attest_is_unitary(p,false)}
		    then () = befmoreTime +:= elapsed_ms() - start
		    in return false
	       fi
     {now either bottom layer has succeeded, or it can't help}
     then () = if bottom_verbose then prints("sorry, doing is_unitary") fi
     in is_unitary_hash_big(p)
     fi

set bottom_test_factors_more(Param p, int D) = bool:
    if not more_flag
    then is_unitary_hash_big(p) {min_bottom_test_factors(p)}
    else let startCF = elapsed_ms()
    	 then Q = character_formula(p)
    	 then () = charTime +:= elapsed_ms() - startCF
    	 then () = char_counter.use()
    	 then P = K_type_pol(Q)
    	 {let P = K_type_pol(character_formula(p))}
    	 in bottom_test_factors_more(p, D, P)
    fi

