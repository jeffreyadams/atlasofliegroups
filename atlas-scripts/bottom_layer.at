< induction.at {for theta_stable_quasi_data}
< unity.at {for deform_support}
< hermitian.at {for to_ht}
<K_types.at {for branch_std}
<time.at {for print_time_string}
<cohom_reductionND {for factor_params, factor_K_types}
<derived_cover.at
<K.at {for projection_to_K_matrix}
{ <sub_cells.at {for is_complex}}
{trying to get at bottom layer K-types. Use D for bound on height, d
for bound on number of terms. The "min" refers to the theta-stable
parabolic built by theta_stable_quasi_data. Parabolics _containing_
that one should certainly be supported; there's a chance also of
getting useful information from parabolics _not_ containing it.}
{"pairs" is...}

{K_signature_irrB is hermitian_form_irr_to_ht; K_signature_irr is hermitian_form_irr truncated.
Haven't figured out which is faster when.}
set min_bottom_verbose = false

set deform_support(Param p, int D) = KTypePol:
    to_ht(deform_support(p), D)

set two_rho_u_check(KGPElt Q) = vec:
    two_rho_check(Q.real_form) - two_rho_check(Q.Levi)

{Each (muG,muL) in output list is a Q-bottom layer K-type for p with (Q,pL) =
theta_stable_quasi_data(p). D is the largest height to which to compute
K-types. For now assume K connected.}

set min_bottom(Param p, int D) = [(KType,KType)]:
    let (Q,pL) = theta_stable_quasi_data(p), {x = p.x, lambda = p.lambda}
    	G = p.real_form
    then L = Q.Levi
    then xcL = KGB(L,0)
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0], LKTL = LKTs(pL)[0]
    then TRUCH = two_rho_u_check(Q)
    then bottom = TRUCH*(highest_weight(LKTG, xcG).mu)
    then too_many_mus = monomials(branch_std(p,D))
    { monomials(deform_support(p,D)) }
    then mus = for mu in too_many_mus
       	       do if {height(mu) > height(LKTG) and}
	       	      TRUCH*(highest_weight(mu, xcG).mu) = bottom
	       	  then [mu]
	  	  else []
	  	  fi
	  	od.##
    then shift = highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu
    in  for mu in mus
    	do (mu, K_types(K_highest_weight_from_K0_weight(xcL,
       	       	       highest_weight(mu,xcG).mu - shift))[0])
	od

{each (tau,tauL) in output list is a bottom layer
K-type and the corr L\cap K-type. ASSUME K CONNECTED
Lists include LKT pairs, so always nonempty.}

set min_L_bottom(Param p, int D) = [(KType,KType)]:
    let (Q,pL) = theta_stable_quasi_data(p), {x = p.x, lambda = p.lambda,}
    	G = p.real_form
    then L = Q.Levi
    then xcL = KGB(L,0)
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0],
    	 LKTL = LKTs(pL)[0]
    then shift = K0_param(LKTG, xcG).lambda_minus_rho - K0_param(LKTL,xcL).lambda_minus_rho
    	 {highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu}
    then DL = D-height(p) + height(pL)
    then too_many_tauLs = monomials(branch_std(pL,DL)) {reps of L\cap K}
    then K0 = K_0(xcG), LK0 = K_0(xcL)
    then tauLs =  for tauL in too_many_tauLs
       	      	  do let weight = K0_param(tauL,xcL).lambda_minus_rho + shift
		  in if {height(tauL) > 0 and}
		       	   is_dominant(K0,weight)
       	  	    then [(weight,tauL)]
	  	    else []
	  	    fi
		 od.##
    in for (weight,tauL) in tauLs
       do (K_types(K_highest_weight_from_K0_weight(xcG, weight))[0] ,tauL) od

{meant to be applied to quasisplit simple L}
set next_heights(RealForm L) = int:
    let N = if not is_quasisplit(L) then 0
    	    elif is_abelian(L) then 0
    	    else max(for p in all_parameters_gamma(L, null(L.rank))
    	     	     do next_heights(p, (semisimple_rank(L) + 3)\2)
	     	     od.##)
    	    fi
     in N {if not is_simple(L)
     	then (N+1)\2
	else N
	fi}

set_type
[QRF_sig_tables =
( ( -> int) real_form_size
  , ( -> ) clear
  , ( -> vec) K_type_size {number of (fine) K-types for each real form}
  , ( -> vec) K_type_pol_size
  , ( -> vec) Param_size
  , (KType -> KTypePol) branch_entry {branch std to height}
  , (KType ->) branch_append {branch std to height, don't report}
  , (Param -> (KTypePol,KTypePol)) entry
  , (Param ->) append
  , (int -> RealForm) real_form_index
  , (int -> int) real_form_height
  , ((int,int) -> KTypePol) branch_index
  , ((int,int) -> (KTypePol,KTypePol)) sig_pol_index
  , ((int,int) -> vec) sig_vec_index
  , ( -> int) bottom_branch_time
  , ( -> int) bottom_sig_time
  )
]

set make_QRF_sig_tables () = QRF_sig_tables:
(  let real_form_hash = make_RealForm_hash()
   then param_hashes = [Param_hash] : [] {one for each real form}
   then K_type_hashes = [KType_hash] : [] {one for each real form; list of fine K-types}
   then K_type_pol_hashes = [KTypePol_hash] : []  {one for each real form}
   then branches = [vec] : [] {one vec for each real form; ith entry is index of branching KTypePol for KType #i}
   then sigs = [[vec]]: [] {one [vec] for each real form, one vec for each Param}
   then heights = vec: [] {jth entry is height to compute for jth real form}
   then bottom_branch_time = int: 0
   then bottom_sig_time = int: 0
   then clear() = void:
       let () = real_form_hash.clear()
       then () = param_hashes:=[]
       then () = K_type_hashes:=[]
       then () = K_type_pol_hashes := []
       then () = branches := []
       then () = sigs := []
       then () = heights := []
       then () = bottom_branch_time := 0
       then () = bottom_sig_time := 0
       in ()
   in 
   ( ( -> int): { real_form_size } @int: real_form_hash.size()
   , ( -> ): {clear} clear
   , ( -> vec): {K_type_size} @vec: for hash in K_type_hashes do hash.size() od
   , ( -> vec): {K_type_pol_size} @vec: for hash in K_type_pol_hashes do hash.size() od
   , ( -> vec): {Param_size} @vec: for hash in param_hashes do hash.size() od
   , (KType -> KTypePol): {branch_entry} (KType mu) KTypePol:
     begin
     	let RF = real_form_hash.size()
	then rf = real_form_hash.match(mu.real_form)
	then () = if rf = RF {haven't seen this quasisplit form before}
	     	  then param_hashes := (param_hashes next param_hashes:= []) #make_Param_hash();
		       K_type_hashes := (K_type_hashes next K_type_hashes:= []) #make_KType_hash();
		       K_type_pol_hashes := (K_type_pol_hashes next K_type_pol_hashes:= [])
		       	       	 	     #make_KTypePol_hash();
		       heights := (heights next heights := [])#next_heights(mu.real_form);
		       sigs := (sigs next sigs := []) # [];
		       branches #:= null(0)
		  fi
	then KTYPENUM = K_type_hashes[rf].size()
	then ktypenum = K_type_hashes[rf].match(mu)
	then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	     	  then let start_branch = elapsed_ms()
	     	       then pol = branch_std(mu,heights[rf])
		       then () = bottom_branch_time +:= elapsed_ms() - start_branch
	     	       then m = K_type_pol_hashes[rf].match(pol)
		       in branches[rf] #:= m
		  fi
	then () = assert(real_form_hash.size() = #K_type_pol_hashes,"QRF_sig_table damaged")
        then () = assert(real_form_hash.size() = #K_type_hashes,"QRF_sig_table damaged")
	then () = assert(real_form_hash.size() = #param_hashes,"QRF_sig_table damaged")
	then () = assert(#sigs[rf] = param_hashes[rf].size(), "QRF_sig_table damaged")
	then () = assert(#branches[rf] = K_type_hashes[rf].size(), "QRF_sig_table damaged")
	in K_type_pol_hashes[rf].index(branches[rf][ktypenum])
     end
   , (KType ->): {branch_append} (KType mu):
     begin
     	let RF = real_form_hash.size()
	then rf = real_form_hash.match(mu.real_form)
	then () = if rf = RF
	     	  then param_hashes := (param_hashes next param_hashes:= []) #make_Param_hash();
		       K_type_hashes := (K_type_hashes next K_type_hashes:= []) #make_KType_hash();
		       K_type_pol_hashes := (K_type_pol_hashes next K_type_pol_hashes:= [])
		       	       	 	     #make_KTypePol_hash();
		       heights := (heights next heights := [])#next_heights(mu.real_form);
		       sigs := (sigs next sigs := [])# [];
		       branches #:= null(0)
		  fi
	then KTYPENUM = K_type_hashes[rf].size()
	then ktypenum = K_type_hashes[rf].match(mu)
	then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	     	  then let start_branch = elapsed_ms()
	     	       then pol = branch_std(mu,heights[rf])
		       then () = bottom_branch_time +:= elapsed_ms() - start_branch
	     	       then m = K_type_pol_hashes[rf].match(pol)
		       in branches[rf] #:= m
		  fi
	then () = assert(real_form_hash.size() = #K_type_pol_hashes,"QRF_sig_table damaged")
        then () = assert(real_form_hash.size() = #K_type_hashes,"QRF_sig_table damaged")
	then () = assert(real_form_hash.size() = #param_hashes,"QRF_sig_table damaged")
	then () = assert(real_form_hash.size() = #heights,"QRF_sig_table damaged")
	then () = assert(#sigs[rf] = param_hashes[rf].size(), "QRF_sig_table damaged")
	then () = assert(#branches[rf] = K_type_hashes[rf].size(), "QRF_sig_table damaged")
	in ()
     end
   , (Param -> (KTypePol,KTypePol)): {entry} (Param p)
     (KTypePol,KTypePol):
     begin
	let RF = real_form_hash.size()
	then rf = real_form_hash.match(p.real_form)
	then () = if rf = RF
	     	  then param_hashes := (param_hashes next param_hashes:= []) #make_Param_hash();
		       K_type_pol_hashes := (K_type_pol_hashes next K_type_pol_hashes:= [])
		       	       	 	     #make_KTypePol_hash();
		       heights := (heights next heights := [])#next_heights(p.real_form);
		       sigs := (sigs next sigs := []) # []
		  fi
	then PNUM = param_hashes[rf].size()
	then pnum = param_hashes[rf].match(p)
	then () = if pnum = PNUM {haven't computed with p before}
	     	  then let start_sig = elapsed_ms()
	     	       then (pos,neg) = K_signature_irrB(p,heights[rf])
		       then () = bottom_sig_time +:= elapsed_ms() - start_sig
	     	       then (p,q) = (K_type_pol_hashes[rf].match(pos), K_type_pol_hashes[rf].match(neg))
		       in sigs[rf] := if #sigs[rf] = 0 then [[p,q]]
		     	      	 else (sigs[rf] next sigs[rf] := [])
		       		    # [p,q]
				      fi
		  fi
	then () = assert(real_form_hash.size() = #K_type_pol_hashes,"QRF_sig_table damaged")
	then () = assert(real_form_hash.size() = #param_hashes,"QRF_sig_table damaged")
	then () = assert(real_form_hash.size() = #heights,"QRF_sig_table damaged")
	then () = assert(#sigs[rf] = param_hashes[rf].size(), "QRF_sig_table damaged")
	in (K_type_pol_hashes[rf].index(sigs[rf][pnum][0]), K_type_pol_hashes[rf].index(sigs[rf][pnum][1]))
     end
   , (Param -> ): {append} (Param p):
     begin
 	let RF = real_form_hash.size()
	then rf = real_form_hash.match(p.real_form)
	then () = if rf = RF
	     	  then param_hashes := (param_hashes next param_hashes:= []) #make_Param_hash();
		       K_type_pol_hashes := (K_type_pol_hashes next K_type_pol_hashes:= [])
		       	       	 	     #make_KTypePol_hash();
		       heights := (heights next heights:=[])#next_heights(p.real_form);
		       sigs := (sigs next sigs := [])#[]
		  fi
	then PNUM = param_hashes[rf].size()
	then pnum = param_hashes[rf].match(p)
	then () = if pnum = PNUM {haven't computed with p before}
	     	  then let start_sig = elapsed_ms()
	     	       then (pos,neg) = K_signature_irrB(p,heights[rf])
		       then () = bottom_sig_time +:= elapsed_ms() - start_sig
		       then (p,q) = (K_type_pol_hashes[rf].match(pos), K_type_pol_hashes[rf].match(neg))
		       in sigs[rf] := if #sigs[rf] = 0 then [[p,q]]
		     	      	      else (sigs[rf] next sigs[rf] := [])# [p,q]
				      fi
		  fi
	then () = assert(real_form_hash.size() = #K_type_pol_hashes,"QRF_sig_table damaged")
	then () = assert(real_form_hash.size() = #param_hashes,"QRF_sig_table damaged")
	then () = assert(real_form_hash.size() = #heights,"QRF_sig_table damaged")
	then () = assert(#sigs[rf] = param_hashes[rf].size(), "QRF_sig_table damaged")
	in ()
     end
   , (int -> RealForm): {real_form_index} (int j): real_form_hash.index(j)
   , (int -> int): {real_form_height} (int j): heights[j]
   , ((int,int) -> KTypePol): {branch_index} (int rf, int ktypenum) KTypePol:
     K_type_pol_hashes[rf].index(branches[rf][ktypenum])
   , ((int,int) -> (KTypePol,KTypePol)): {sig_pol_index} (int rf, int pnum) (KTypePol,KTypePol):
     (K_type_pol_hashes[rf].index(sigs[rf][pnum][0]), K_type_pol_hashes[rf].index(sigs[rf][pnum][1]))
   , ((int,int) -> vec): {sig_vec_index} (int rf, int pnum) vec:
     sigs[rf][pnum]
   , ( -> int): {bottom_branch_time} @int: bottom_branch_time
   , ( -> int): {bottom_sig_time} @int: bottom_sig_time
  )
)

{whether to use QR_sig_tables in bottom layer computation}
set QR_code = true

set qrf_sig_tables = make_QRF_sig_tables()

set min_L_bottom_factors(KType mu) = [[(KType, KType)]]:
    let p = parameter(mu)
    then (Q,pL) = theta_stable_quasi_data(p), G = p.real_form
    then muL = LKT(pL), L = Q.Levi
    then muLs = factor_K_types(muL) {each muLj is on a simple mod center Lj}
    then dermuLs = derived_factor_K_types(muL) {each dermuLj is on a simple derived derLj}
    then Ls = for muL in muLs do muL.real_form od {these are the Lj}
    then derLMs = for (Lj,derLj,Mj) in derived_simple_factors_info(L) do (derLj,Mj) od {DERIVED simple factors}

    then derMs = for (,Mj) in derLMs do Mj od
    then derLs = for (derLj,) in derLMs do derLj od {DERIVED simple factors}
    then xcderLMs = for (derLj,Mj) in derLMs
    	       	 do (KGB(derLj, 0),Mj)
		 od
    then xcLs = for (xcderLj,Mj)@j in xcderLMs {KGBElts for Lj, lifted from #zero on derLj}
    	      	 do embed_KGB(xcderLj,Ls[j],Mj) {PROBABLY these are all #0 on Lj???}
		 od
    then xcGs = for xcLj@j in xcLs do embed_KGB(xcLj,G) od
    then dertauLs = [[KType]]: {jth list on derived simple factor derLj}
    	 for dermuLj@j in dermuLs
	 do if QR_code
	    then monomials(qrf_sig_tables.branch_entry(dermuLj))
	    else monomials(branch(dermuLj, max(next_heights(dermuLs[j], (semisimple_rank(derLs[j]) + 1)\2))))
	    fi
	 od
    in for listj@j in dertauLs
       do let K0 = K_0(xcGs[j])
       	  then muwtj = K0_param(mu,xcGs[j]).lambda_minus_rho {size is rank(K)}
	  then dermuLj = dermuLs[j], (xcLj,) = xcderLMs[j], derLj = derLs[j], Lj = Ls[j]
	  then dermuLjwt = K0_param(dermuLj).lambda_minus_rho
	  then () = if Lj.Cartan_matrix != derLj.Cartan_matrix
		     	  then prints("WARNING: CM mismatch at Lj = ",Lj)
			  fi

       	  in [(KType, KType)]: {meant to be list of pairs (tau, dertauLj) with tau bottom layer for G,
	       	       			 dertauLj corr LjK-type}
	     for dertauLj in listj
       	     do  let dertauLjwt = K0_param(dertauLj).lambda_minus_rho {this is a wt for K on derLj}
	     	 then taujwt = muwtj + ratvec_as_vec(sum(K0.rank, for xi@k in fundamental_coweights(derLj)
		     		      				  do projection_to_K_matrix(mu.inner_class)*
								    ((dertauLjwt - dermuLjwt)*xi*Lj.simple_roots[k])
								  od))
	     	 in if is_dominant(K0, taujwt)
  	            then [(K_types(K_highest_weight_from_K0_weight(xcGs[j], taujwt))[0],
		   	  dertauLj)]
	  	    else []
	  	    fi
	     od.##
	od
 
{table of bottom layer data indexed by KType}
set_type
[steady_bottom_data =
( ( -> int) size
  , ( -> ) clear
  , (KType->[[(KType,KType)]]) entry
  , (KType->) append
  , (int -> KType) K_type_index
  , (int -> [[(KType,KType)]]) data_index
  , ( -> int) min_L_bottom_factors_time
  )
]

set make_steady_bottom_data () = steady_bottom_data:
(  let K_type_hash = make_KType_hash()
   then bottom_data = [[[(KType,KType)]]] : []
   then bottom_factors_time = int: 0
   then clear() = void:
       let () = K_type_hash.clear()
       then () = bottom_data:=[]
       then  () = bottom_factors_time := 0
       in ()
   in 
   ( ( -> int): { size } @int: K_type_hash.size()
   , ( -> ): {clear} clear
   , (KType -> [[(KType,KType)]]): {entry} (KType mu)
     [[(KType,KType)]]:
     begin
	let M = K_type_hash.size()
	then m = K_type_hash.match(mu)
	then () = if m = M
	     	  then let start = elapsed_ms()
		       then () = bottom_data := (bottom_data next bottom_data:= [])
		       	       	 	     #min_L_bottom_factors(mu)
		       in bottom_factors_time +:= elapsed_ms() - start
		  fi
	then () = assert(#bottom_data =
	     	K_type_hash.size(),"steady_bottom_data damaged")
	in bottom_data[m]
     end
   , (KType->): {append } (KType mu):
     begin
	let M = K_type_hash.size()
	then m = K_type_hash.match(mu)
	then () = if m = M
	     	  then let start = elapsed_ms()
	     	       then () = bottom_data := (bottom_data next bottom_data:= [])
		       	       	 	     #min_L_bottom_factors(mu)
		       in bottom_factors_time +:= elapsed_ms() - start
		  fi
        then () = assert(#bottom_data =
	     	K_type_hash.size(),"steady_bottom_data damaged")
	in ()
     end
   , (int -> KType): {K_type_index} (int j): K_type_hash.index(j)
   , (int -> [[(KType,KType)]]): {data_index} (int j) [[(KType,KType)]]: bottom_data[j]
   , ( -> int): {bottom_min_L_bottom_time} @int: bottom_factors_time
  )
)


set basis_lambda_differential_0(mat theta) = mat: {columns are weights lambda with (1+theta)lambda = 0,
    				   	    	  mod (1-theta)X^*}
    let E = eigen_lattice(theta, -1)
    then(A,v) = adapted_basis(in_lattice_basis(E,1-theta))
    in E*columns_with((int j):v[j] = 2,A)

set all_even_lambda_differential_0(RootDatum rd, mat theta) = [vec]:
    let basis = basis_lambda_differential_0(theta), (RSC,) = {real simple coroots}
    	      	simple_system_from_positive(real_poscoroots(rd,theta), real_posroots(rd,theta))
    in for v in all_0_1_vecs(n_columns(basis))
       do let C = basis*v
       	  in if all(for ac in RSC do is_even(ac*C) od)
	     then [C]
	     else []
	     fi
	od.##
set mbefTime = int: 0
{just checks whether it's cohom ind from unitary; doesn't check good range.
So could be wrong in either direction}
set coh_ind_is_unitary(Param p) = bool:
    let {mu = LKTs(p)[0],} G = p.real_form
    then (Q,pL) = theta_stable_quasi_data(p)
    then gamma = pL.infinitesimal_character + G.rho - pL.real_form.rho
    then () = if not (is_dominant(G,gamma))
    	      then return is_unitary_hash(p)
	      fi
    then derpLjs = derived_factor_params(pL) {one for each derived simple factor derLj}
    then test = all(for derpLj in derpLjs do is_unitary_hash(derpLj) od)
    then () = if all(for j in Q.S do gamma*G.simple_coroots[j] > 0 od) {is_good(pL,G)}
    	      then return test
	      fi
    then () = if test
    	      then return true
	      fi
    in is_unitary_hash(p)

{false guarantees not unitary, but true does not guarantee unitary}
{LKdata[j] is [(tauj,tauLj)]: tauLj is an Lj\cap K-type inducing to a bottom layer tauj of p.}
set min_bottom_elim_factors(Param p, [[(KType,KType)]] LKdata) = bool:
    let start = elapsed_ms(), {answers = for k:#LKdata do false od,}
    	(,pL) = theta_stable_quasi_data(p)
    then (mu,) = LKdata[0][0]
    then () = if K_type_pol(p)[mu] = 0
       	      then return prints("mu isn't a LKT of p"); true
       	      fi
    then () = if sum(for pairs in LKdata do #pairs od) = #LKdata
    	      then return true
	      fi
    then derpLjs = derived_factor_params(pL) {one for each derived simple factor derLj}
    then derxLjs = for derpLj in derpLjs do derpLj.x od
    then derLjs = for derpLj in derpLjs do derpLj.real_form od
    {we wish these dermuLjs were LKTs of derpLj; may need to twist pLj to make this true??}
    then dermuLjs = for pairs in LKdata do let (,dermuLj) = pairs[0] in dermuLj od
      {check derpLj has dermuLj as a LKT}
    then () = for derpLj@j in derpLjs
      	      	do if K_type_pol(derpLj)[dermuLjs[j]] = 0
		   then let twistj = all_even_lambda_differential_0(derLjs[j].dual, - derxLjs[j].involution.^)
		   	{then () = prints("twisting derpLj needed at p = ",p, ", j = ",j)}
		   	then twistxLj = let Genx = KGB_elt_gen(derxLjs[j])
				      	in for t@i in twistj
			   	      	   do let () = Genx.torus_factor +:= t
			      	      	      in KGB_elt(Genx)
			   	      	   od
		    	then twistpLj = for yLj in twistxLj
		    	 	      	do parameter(yLj, derpLj.lambda, derpLj.nu)
				    	od
		    	then m = first(for derqLj in twistpLj
		    	     	       do K_type_pol(derqLj)[dermuLjs[j]] != 0
				       od)
		    	then () = if m < 0
		     	       	  then prints("x twisting failed at p = ",p,", j = ",j)
			       	  else derpLjs[j] := twistpLj[m]
			       	  fi
		    	in ()
		    fi
		od
       { then () = for derpLj@j in derpLjs
       	       	 do assert(K_type_pol(derpLj)[dermuLjs[j]] != 0, "derpLj does not have LKT dermuLj")
		 od }
       then DG = max(for pairs in LKdata
       	    	     do max(for (tauj,) in pairs
			    do height(tauj)
			    od)
		     od)
       then multG = branch_irr(p,DG)
       then result = all( [(->bool)]: {list of functions, one for each factor Lj}
	       for pairs@j in LKdata
	       do 
	       let (posLj, negLj) = if QR_code
	    	      	    	    then qrf_sig_tables.entry(derpLjs[j])
			   	    else K_signature_irrB(derpLjs[j],max(
				    	 for (,tauLj) in LKdata[j]
		       	  		 do height(tauLj)
		      	   		 od)){DLs[j])}
				    fi
	       then () = if posLj[dermuLjs[j]] = 0
		       	 then posLj := negLj
			 fi
	       in @:all( [(->bool)]:
			for(tauj, tauLj) in pairs[1:]
			do {prints(posLj[tauLj]," ",multG[tauj]);}
			@bool: int_part(posLj[tauLj]) >= int_part(multG[tauj])
			od )
	       od )
	then () = mbefTime +:= elapsed_ms()-start
	in result

set min_bottom_elim_factors(Param p, steady_bottom_data bott_data) = bool:
    all( for mu in LKTs(p)
    	 do min_bottom_elim_factors(p, bott_data.entry(mu))
	 od
       )

{false guarantees not unitary, but true does not guarantee unitary}
{Here P is branch_std(K-character of p to heights of pairs}
{LKdata refers to ONE LKT of p}
set min_bottom_elim_factors(Param p, [[(KType,KType)]] LKdata, KTypePol P) = bool:
    let start = elapsed_ms(), {answers = for k:#LKdata do false od,}
    	(,pL) = theta_stable_quasi_data(p)
    then (mu,) = LKdata[0][0]
    then () = if K_type_pol(p)[mu] = 0
       	      then return prints("mu isn't a LKT of p"); true
       	      fi
    then () = if sum(for pairs in LKdata do #pairs od) = #LKdata
    	      then return true
	      fi
    then derpLjs = derived_factor_params(pL) {one for each derived simple factor derLj}
    then derxLjs = for derpLj in derpLjs do derpLj.x od
    then derLjs = for derpLj in derpLjs do derpLj.real_form od
    {we wish these dermuLjs were LKTs of derpLj; need to twist derpLj to make this true.}
    then dermuLjs = for pairs in LKdata do let (,muLj) = pairs[0] in muLj od
      {check derpLj has dermuLj as a LKT}
    then () = for derpLj@j in derpLjs
      	      	do if K_type_pol(derpLj)[dermuLjs[j]] = 0
		   then let twistj = all_even_lambda_differential_0(derLjs[j].dual, - derxLjs[j].involution.^)
		   	{then () = prints("twisting derpLj needed at p = ",p, ", j = ",j)}
		   	then twistxLj = let Genx = KGB_elt_gen(derxLjs[j])
				      	in for t@i in twistj
			   	      	   do let () = Genx.torus_factor +:= t
			      	      	      in KGB_elt(Genx)
			   	      	   od
		    	then twistpLj = for yLj in twistxLj
		    	 	      	do parameter(yLj, derpLj.lambda, derpLj.nu)
				    	od
		    	then m = first(for derqLj in twistpLj
		    	     	       do K_type_pol(derqLj)[dermuLjs[j]] != 0
				       od)
		    	then () = if m < 0
		     	       	  then prints("x twisting failed at p = ",p,", j = ",j)
			       	  else derpLjs[j] := twistpLj[m]
			       	  fi
		    	in ()
		    fi
		od
      { then () = for derpLj@j in derpLjs
      	      	do assert(K_type_pol(derpLj)[dermuLjs[j]] != 0, "derpLj does not have LKT dermuLj")
		od }
     { then DG = max(for pairs in LKdata
       	    	     do max(for (tauj,) in pairs
			    do height(tauj)
			    od)
		     od)}
     then result = all( [(->bool)]: {list of functions, one for each factor Lj}
	       for pairs@j in LKdata
	       do 
	       let (posLj, negLj) = if QR_code
	    	      	    	    then qrf_sig_tables.entry(derpLjs[j])
			   	    else K_signature_irrB(derpLjs[j],max(
				    	 for (,tauLj) in LKdata[j]
		       	  		 do height(tauLj)
		      	   		 od))
				    fi
	       then () = if posLj[dermuLjs[j]] = 0
		       	 then posLj := negLj
			 fi
	       in @:all( [(->bool)]:
			for(tauj, tauLj) in pairs[1:]
			do {prints(posLj[tauLj]," ",multG[tauj]);}
			@bool: int_part(posLj[tauLj]) >= int_part(P[tauj])
			od )
	       od )
     then () = mbefTime +:= elapsed_ms() - start
     in result


set min_bottom_elim_factors(Param p, steady_bottom_data bott_data, KTypePol P) = bool:
    all( for mu in LKTs(p)
    	 do min_bottom_elim_factors(p, bott_data.entry(mu), P)
	 od
       )
set min_bottom_test_factors(Param p, [[(KType,KType)]] LKdata) = bool:
    if not min_bottom_elim_factors(p, LKdata)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test_factors(Param p,[[(KType,KType)]] LKdata, KTypePol P) = bool:
    if not min_bottom_elim_factors(p, LKdata, P)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test_factors(Param p, steady_bottom_data bott_data) = bool:
    if not min_bottom_elim_factors(p, bott_data)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test_factors(Param p, steady_bottom_data bott_data, KTypePol P) = bool:
    if not min_bottom_elim_factors(p, bott_data, P)
    then return false
    else is_unitary(p)
    fi

set min_bottom_elim_factors(Param p) = bool:
    let start = elapsed_ms()
    then LKdatas = for mu in LKTs(p) do min_L_bottom_factors(mu) od
    	 , minLb_time = int:0, posLK_time = int:0, multK_time = int:0
    then () = if min_bottom_verbose
    	      then let () = minLb_time := elapsed_ms()
    	      	   in  prints(new_line,"min_L_bottom used ",
    	    	       print_time_string(minLb_time - start))
	      fi
    in all( [(->bool)]: for LKdata in LKdatas do @bool: min_bottom_elim_factors(
       	    	   p, LKdata)
       	    od)

set min_bottom_test_factors(Param p) = bool:
    if not min_bottom_elim_factors(p)
    then return false
    else is_unitary(p)
    fi
{permutation of the simple roots defined by delta}
set delta_on_simple(InnerClass ic) = [int]:
    let r = ic.semisimple_rank, SR = ic.simple_roots, delta = ic.distinguished_involution
    in for i:r do first(for j:r do SR[i] = delta*SR[j] od) od

{all theta-stable parabolics containing a given one}
set larger_Ps(KGPElt Q) = [KGPElt]:
    let (S,x) = Q, L = Q.Levi
    then xL = inverse_embed_KGB(x,L), G = x.real_form
    then Sc = complement(G.semisimple_rank,S), DOS = delta_on_simple(G),
    	 delta = G.distinguished_involution
    then fixc = for a in Sc
    	      	do if DOS[a] = a
		   then [a]
		   else []
		   fi
		od.##
    then pairsc = for a in Sc
    	 	  do if DOS[a] > a
		     then [[a,DOS[a]]]
		     else []
		     fi
		  od.##
    then PSfixc = power_set(#fixc), PSpairsc = power_set(#pairsc)
    then Snew = S
    in for A in PSfixc
       do for B in PSpairsc
       	  do (S## for i in A
	     	 do fixc[i]
		 od
	      ## for j in B
	      	 do pairsc[j]
		 od.## , x)
	  od
       od.##

{for each pair (MN,pM), p is cohomologically induced from pM. First
pair is theta_stable_quasi_data(p), last is (G,p).}
set larger_Qps(Param p) = [(KGPElt,Param)]:
    let (Q,pL) = theta_stable_quasi_data(p)
    then LPs = larger_Ps(Q)
    in for P in LPs
       do let M = P.Levi
       	  in (P, first_param(theta_induce_standard(pL,M)))
       od

{Let (Q0,pL0) = theta_stable_quasi_data(p) and assume Q containing Q0
is theta-stable.  Each (tau,tauL) in output list is a Q-bottom layer
K-type for p. D is the largest height to which to compute K-types.
List includes LKT pairs, so always nonempty.  Assume K connected.}
set bottom(Param p, int D, KGPElt Q) = [(KType,KType)]:
    let (Q0,pL0) = theta_stable_quasi_data(p),
    	G = p.real_form, L = Q.Levi
    then L0 = Q0.Levi, pL = first_param(theta_induce_standard(pL0,L))
    then xcL = KGB(L,0)
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0], LKTL = LKTs(pL)[0]
    then TRUCH = two_rho_u_check(Q)
    then bottom = TRUCH*(highest_weight(LKTG, xcG).mu)
    then too_many_taus = monomials(branch_std(p,D))
    then taus = for tau in too_many_taus
       	       do if TRUCH*(highest_weight(tau, xcG).mu) = bottom
	       	  then [tau]
	  	  else []
	  	  fi
	  	od.##
    then shift = highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu
    in  for tau in taus
    	do (tau, K_types(K_highest_weight_from_K0_weight(xcL,
       	       	       highest_weight(tau,xcG).mu - shift))[0])
	od

{Let (Q0,pL0) = theta_stable_quasi_data(p) and assume Q containing Q0
is theta-stable.  Each (tau,tauL) in output list is a Q-bottom layer
K-type for p. D is the largest height to which to compute K-types.
List includes LKT pairs, so always nonempty.  Assume K connected.}
set L_bottom(Param p, int D, KGPElt Q) = [(KType,KType)]:
    let (Q0,pL0) = theta_stable_quasi_data(p), G = p.real_form,
    	L = Q.Levi
    then L0 = Q0.Levi, pL = first_param(theta_induce_standard(pL0,L))
    then xcL = KGB(L,0)
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0], LKTL = LKTs(pL)[0]
    then shift = K0_param(LKTG, xcG).lambda_minus_rho - K0_param(LKTL,xcL).lambda_minus_rho
    	 {highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu}
    then DL = D-height(p) + height(pL)
    then too_many_tauLs = monomials(branch_std(pL,DL)) {reps of L\cap K}
    then K0 = K_0(xcG), LK0 = K_0(xcL)
    then tauLs =  for tauL in too_many_tauLs
       	      	  do let weight = K0_param(tauL,xcL).lambda_minus_rho + shift
		  in if is_dominant(K0,weight)
       	  	     then [(weight,tauL)]
	  	     else []
	  	     fi
		  od.##
    in for (weight,tauL) in tauLs
       do (K_types(K_highest_weight_from_K0_weight(xcG, weight))[0] ,tauL) od

{false guarantees not unitary, but true does not guarantee unitary.
Assume p is cohom ind from pL; pairs is (tau, tauL):
a bottom layer K-type and the corresponding L\cap K-type}
set bottom_elim(Param p, Param pL, [(KType,KType)] pairs) = bool:
    let start = elapsed_ms()
    in if  #pairs = #LKTs(p)  then true
       else let DL = max(for (,tauL) in pairs do height(tauL) od),
       	    posLK_time = int:0, multK_time = int:0
       	    then (posL,negL) = K_signature_irrB(first_param(finalize(pL)),DL)
	    	 {positive part of the signature on L}
	    then () = if min_bottom_verbose
	    	      then let () = posLK_time := elapsed_ms()
		      	   in prints("LK_sig used ",
    	    	      	      print_time_string(posLK_time - start))
		      fi
	    then DG = max(for(tau,) in pairs do height(tau) od)
	    then multG = branch_irr(p,DG)
	    	 {all K-mults to height of largest tau}
	    then () = if min_bottom_verbose
	    	      then let () = multK_time := elapsed_ms()
		      	   in prints("multK used ",
    	    	      	      print_time_string(multK_time - posLK_time))
		      fi
		      {create a list of FUNCTIONS returning a bool. Functions
		      are only evaluated until false }
	    then () = if let (, muL) = pairs[0] in posL[muL] = 0
		      then posL := negL
		      fi
	    then answer =  all( for (tau,tauL) in pairs[1:]
       	       	    do @bool: int_part(posL[tauL]) >= int_part(multG[tau])
		    od)
		    {or @bool:int_part...}
    	    then () = if min_bottom_verbose
	       	      then prints("min_bottom_elim used ",
    	    	      	   print_time_string(elapsed_ms() - start))
	       	      fi
            in answer
	fi

{false guarantees not unitary, but true does not guarantee unitary}
{Here P is the K-character of p, at least to heights of pairs}
set bottom_elim(Param p, Param pL, [(KType,KType)] pairs, KTypePol P) = bool:
    let start = elapsed_ms()
    in if #pairs = #LKTs(p) then true
       else let DL = max(for (,tauL) in pairs do height(tauL) od){,
       	    posLK_time = int:0, multK_time = int:0}
	    then (posL, negL) = K_signature_irrB(first_param(finalize(pL)),DL)
       	    {then (posL,) = K_signature_irrB(first_param(finalize(pL)),DL)}
	    then () = if let (,muL) = pairs[0] in posL[muL] = 0
		      then posL := negL
		      fi
	    	 {positive part of the signature on L}
	    then DG = max(for(tau,) in pairs do height(tau) od)
	    then multG = P {all K-mults to height of largest mu}
	    in all( for (tau,tauL) in pairs[1:]
       	       	    do @:int_part(posL[tauL]) >= int_part(multG[tau])
		    od )
	fi

set bottom_test(Param p, Param pL, [(KType,KType)] pairs) = bool:
    if not bottom_elim(p, pL, pairs)
    then return false
    else is_unitary(p)
    fi

set bottom_test(Param p, Param pL, [(KType,KType)] pairs, KTypePol P) = bool:
    if not bottom_elim(p, pL, pairs, P)
    then return false
    else is_unitary(p)
    fi

set bottom_elim(Param p, int D, KGPElt Q) = bool:
    let start = elapsed_ms(), (Q0,pL0) = theta_stable_quasi_data(p)
    then pL = first_param(theta_induce_standard(pL0,Q.Levi))
    then pairs = L_bottom(p,D,Q), minLb_time = int:0, posLK_time = int:0,
    	 multK_time = int:0
    then () = if min_bottom_verbose
    	      then let () = minLb_time := elapsed_ms()
    	      	   in  prints(new_line,"min_L_bottom used ",
    	    	       print_time_string(minLb_time - start))
	      fi
    in bottom_elim(p, pL, pairs)

set bottom_test(Param p, int D, KGPElt Q) = bool:
    if not bottom_elim(p, D, Q)
    then return false
    else is_unitary(p)
    fi
