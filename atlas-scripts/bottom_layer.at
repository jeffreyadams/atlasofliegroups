< induction.at {for theta_stable_quasi_data}
< unity.at {for deform_support}
< hermitian.at {for to_ht}
<K_types.at {for branch_std}
<time.at {for print_time_string}
<cohom_reductionND {for factor_params}
{trying to get at bottom layer K-types. Use D for bound on height, d
for bound on number of terms. The "min" refers to the theta-stable
parabolic built by theta_stable_quasi_data. Parabolics _containing_
that one should certainly be supported; there's a chance also of
getting useful information from parabolics _not_ containing it.}

set min_bottom_verbose = false

set deform_support(Param p, int D) = KTypePol:
    to_ht(deform_support(p), D)

set two_rho_u_check(KGPElt Q) = vec:
    two_rho_check(Q.real_form) - two_rho_check(Q.Levi)

{Each (muG,muL) in output list is a Q-bottom layer K-type for p with (Q,pL) =
theta_stable_quasi_data(p). D is the largest height to which to compute
K-types. For now assume K connected.}
set min_bottom(Param p, int D) = [(KType,KType)]:
    let (Q,pL) = theta_stable_quasi_data(p), {x = p.x, lambda = p.lambda}
    	G = p.real_form
    then L = Q.Levi
    then xcL = KGB(L,0)
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0], LKTL = LKTs(pL)[0]
    then TRUCH = two_rho_u_check(Q)
    then bottom = TRUCH*(highest_weight(LKTG, xcG).mu)
    then too_many_mus = monomials(branch_std(p,D))
    { monomials(deform_support(p,D)) }
    then mus = for mu in too_many_mus
       	       do if height(mu) > height(LKTG) and
	       	      TRUCH*(highest_weight(mu, xcG).mu) = bottom
	       	  then [mu]
	  	  else []
	  	  fi
	  	od.##
    then shift = highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu
    in  for mu in mus
    	do (mu, K_types(K_highest_weight_from_K0_weight(xcL,
       	       	       highest_weight(mu,xcG).mu - shift))[0])
	od

{PROBLEM: muL of height DL + M can give K-type of height D+m, with m \ne M}
{each muL in output list is an L\cap K-type inducing to a bottom layer
K-type. ASSUME K CONNECTED}

set min_L_bottom(Param p, int D) = [(KType,KType)]:
    let (Q,pL) = theta_stable_quasi_data(p), {x = p.x, lambda = p.lambda,}
    	G = p.real_form
    then L = Q.Levi
    then xcL = KGB(L,0)
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0],
    	 LKTL = LKTs(pL)[0]
    then shift = highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu
    then DL = D-height(p) + height(pL)
    then too_many_muLs = monomials(branch_std(pL,DL))
    then K0 = K_0(xcG), LK0 = K_0(xcL)
    then muLs =  for muL in too_many_muLs
       	      	 do if height(muL) > 0 and
		       is_dominant(K0,shift + highest_weight(muL,xcL).mu)
       	  	    then [muL]
	  	    else []
	  	    fi
		 od.##
    in for muL in muLs do (K_types(K_highest_weight_from_K0_weight(xcG,
       	       	       highest_weight(muL, xcL).mu + shift))[0] ,muL) od

set min_L_bottom_factors(Param p, int level) = [Param,[(KType, KType)]]:
    let (Q,pL) = theta_stable_quasi_data(p), {x = p.x, lambda = p.lambda,}
    	G = p.real_form
    then pjs = factor_params(pL), L = Q.Levi
     {restriction to each simple factor of L}
    then Ljs = simple_factors(L)
    then DLjs = for pj in pjs do next_heights(pj, level) od
    then too_many_mujs = [[KType]]:
    	 for pj@j in pjs
	 do monomials(branch_std(pj, DLjs[j][level -1]))
	 od
    then xcL = KGB(L,0)
    then xcLjs = for pj in pjs
    	       	 do KGB(pj.real_form,0) {KGB(Lj, 0)}
		 od
    then xcG = embed_KGB(xcL, G), LKTG = LKTs(p)[0],
    	 LKTL = LKTs(pL)[0]
    then shift = highest_weight(LKTG,xcG).mu - highest_weight(LKTL,xcL).mu
    then K0 = K_0(xcG), LK0 = K_0(xcL)
    then taujs =  for listj@j in too_many_mujs {list of vecs, K0 weights}
    	      	  do for muLj in listj
       	      	     do let tauj = highest_weight(muLj, xcLjs[j]).mu + shift
		     	in if height(muLj) > 0 and
			   is_dominant(K0, tauj)
		        {is_dominant(K0,shift + highest_weight(muLj,xcLjs[j]).mu)}
       	  	        then [(tauj,muLj)]
	  	        else []
	  	        fi
		     od.##
		  od
    in for listj@j in taujs
       do (pjs[j],
       	  for (tauj,muLj) in listj
       	  do (K_types(K_highest_weight_from_K0_weight(xcG, tauj))[0],muLj)
	  od)
       od

{false guarantees not unitary, but true does not guarantee unitary}
set min_bottom_elim(Param p, [(KType,KType)] pairs) = bool:
    let start = elapsed_ms(), (,pL) = theta_stable_quasi_data(p)
    in if #pairs = 0 then true
       else let DL = max(for (,muL) in pairs do height(muL) od),
       	    posLK_time = int:0, multK_time = int:0
       	    then (posL,) = K_signature_irr(first_param(finalize(pL)),DL)
	    	 {positive part of the signature on L}
	    then () = if min_bottom_verbose
	    	      then let () = posLK_time := elapsed_ms()
		      	   in prints("LK_sig used ",
    	    	      	      print_time_string(posLK_time - start))
		      fi
	    then DG = max(for(mu,) in pairs do height(mu) od)
	    then multG = branch_irr(p,DG)
	    	 {all K-mults to height of largest mu}
	    then () = if min_bottom_verbose
	    	      then let () = multK_time := elapsed_ms()
		      	   in prints("multK used ",
    	    	      	      print_time_string(multK_time - posLK_time))
		      fi
	    then answer =  all( for (mu,muL) in pairs
       	       	    do int_part(posL[muL]) >= int_part(multG[mu])
		    od )
    	    then () = if min_bottom_verbose
	       	      then prints("min_bottom_elim used ",
    	    	      	   print_time_string(elapsed_ms() - start))
	       	      fi
            in answer
	fi


{false guarantees not unitary, but true does not guarantee unitary}
{Here P is the K-character of p, at least to heights of pairs}
set min_bottom_elim(Param p, [(KType,KType)] pairs, KTypePol P) = bool:
    let start = elapsed_ms(), (,pL) = theta_stable_quasi_data(p)
    in if #pairs = 0 then true
       else let DL = max(for (,muL) in pairs do height(muL) od),
       	    posLK_time = int:0, multK_time = int:0
       	    then (posL,) = K_signature_irr(first_param(finalize(pL)),DL)
	    	 {positive part of the signature on L}
	    then () = if min_bottom_verbose
	    	      then let () = posLK_time := elapsed_ms()
		      	   in prints("LK_sig used ",
    	    	      	      print_time_string(posLK_time - start))
		      fi
	    then DG = max(for(mu,) in pairs do height(mu) od)
	    then multG = P
	    then () = if min_bottom_verbose
	    	      then let () = multK_time := elapsed_ms()
		      	   in prints("multK used ",
    	    	      	      print_time_string(multK_time - posLK_time))
		      fi
	    	 {all K-mults to height of largest mu}

	    then answer =  all( for (mu,muL) in pairs
       	       	    do int_part(posL[muL]) >= int_part(multG[mu])
		    od )
    	    then () = if min_bottom_verbose
	       	      then prints("min_bottom_elim used ",
    	    	      	   print_time_string(elapsed_ms() - start))
	       	      fi
            in answer
	fi


set min_bottom_test(Param p,[(KType,KType)] pairs) = bool:
    if not min_bottom_elim(p, pairs)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test(Param p,[(KType,KType)] pairs, KTypePol P) = bool:
    if not min_bottom_elim(p, pairs, P)
    then return false
    else is_unitary(p)
    fi

set min_bottom_elim(Param p, int D) = bool:
    let start = elapsed_ms()
    then pairs = min_L_bottom(p,D), minLb_time = int:0, posLK_time = int:0,
    	 multK_time = int:0
    then () = if min_bottom_verbose
    	      then let () = minLb_time := elapsed_ms()
    	      	   in  prints(new_line,"min_L_bottom used ",
    	    	       print_time_string(minLb_time - start))
	      fi
    in min_bottom_elim(p, pairs)

set min_bottom_test(Param p, int D) = bool:
    if not min_bottom_elim(p, D)
    then return false
    else is_unitary(p)
    fi

{false guarantees not unitary, but true does not guarantee unitary}
set min_bottom_elim_factors(Param p, [Param,[(KType,KType)]] pjpairss) = bool:
    let start = elapsed_ms(), answers = for k:#pjpairss do false od
    then () = if #pjpairss = 0 then return true
       	      else for (pj, pairsj)@j in pjpairss
       	      	   do let DLj = max(for (,muLj) in pairsj do height(muLj) od#height(pj))
       	      	      then (posLj,) = K_signature_irr(first_param(finalize(pj)),DLj)
	    	      	   {positive part of the signature on Lj}
	    	      then DGj = max(for(muj,) in pairsj do height(muj) od #height(p))
	    	      then multGj = branch_irr(p,DGj)
	    	      	   {all K-mults to height of largest muj}
	    	      then () = answers[j] :=  all( for (muj,muLj) in pairsj
       	       	    	    	 do int_part(posLj[muLj]) >= int_part(multGj[muj])
		    		 od )
		      in ()
	     	   od
	      fi
     in all(answers)

{false guarantees not unitary, but true does not guarantee unitary}
{Here P is the K-character of p, at least to heights of pairs}
set min_bottom_elim_factors(Param p, [Param,[(KType,KType)]] pjpairss, KTypePol P) = bool:
    let start = elapsed_ms(), answers = for k:#pjpairss do false od
    then () = if #pjpairss = 0 then return true
       	      else for (pj, pairsj)@j in pjpairss
       	      	   do let DLj = max(for (,muLj) in pairsj do height(muLj) od# height(pj))
       	      	      then (posLj,) = K_signature_irr(first_param(finalize(pj)),DLj)
	    	      	   {positive part of the signature on Lj}
	    	      then DGj = max(for(muj,) in pairsj do height(muj) od#height(p))
	    	      then () = answers[j] :=  all( for (muj,muLj) in pairsj
       	       	    	    	 do int_part(posLj[muLj]) >= int_part(P[muj])
		    		 od )
		      in ()
	     	   od
	      fi
     in all(answers)

set min_bottom_test_factors(Param p, [Param,[(KType,KType)]] pjpairss) = bool:
    if not min_bottom_elim_factors(p, pjpairss)
    then return false
    else is_unitary(p)
    fi

set min_bottom_test_factors(Param p,[Param, [(KType,KType)]] pjpairss, KTypePol P) = bool:
    if not min_bottom_elim_factors(p, pjpairss, P)
    then return false
    else is_unitary(p)
    fi

set min_bottom_elim_factors(Param p, int level) = bool:
    let start = elapsed_ms()
    then pjpairss = min_L_bottom_factors(p,level), minLb_time = int:0, posLK_time = int:0,
    	 multK_time = int:0
    then () = if min_bottom_verbose
    	      then let () = minLb_time := elapsed_ms()
    	      	   in  prints(new_line,"min_L_bottom used ",
    	    	       print_time_string(minLb_time - start))
	      fi
    in min_bottom_elim_factors(p, pjpairss)

set min_bottom_test_factors(Param p, int level) = bool:
    if not min_bottom_elim_factors(p, level)
    then return false
    else is_unitary(p)
    fi
