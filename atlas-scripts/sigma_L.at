<isomorphism_W.at
{sigma_L=sigma_Lusztig
actually there are two, differing by sgn: sigma_L_1 and sigma_L_2
sigma_L is sigma_L_1, see commented section below

 O=orbit, x\in Cent(SL(2))
 sigma_L(x,1): irreducible representation of W
  attached by Lusztig to the pair (x,1)
  strictly speaking O is special,
  and x is an element of A(O)=Cent(SL(2))/Cent()^0
  a computation of sigma_L(x,1) is given conjecturally by Vogan
   this algorithm takes x\in Cent() to W^
   need to assume: this map only depends on the image of x in A(O)
  assuming this, this file implements that algorithm
   using the values of x computed by component_datum(orbit)
}

{O is an even nilpotent orbit, x in Cent(SL(2)),
 -> L=L_x = pseudo-Levi Cent(x)
 -> O_L = orbit in L_x
 -> O_L_v=d(O_L) = orbit in (L_x)^vee
 -> sigma_L_v=Springer(O_L_v) \in hat(W_L_v)
 -> truncated induction of sigma_L_v in hat(W_v)
 -> sigma in hat(W) via W\simeq W_v
 from W_L to W: this (conjecturally) is sigma_L(x,1)
 where sigma_L: M(A-bar(O)) -> W^, M(*) is Lusztig's
 set of pairs  (x,\xi)   Orbit O -> A(O) -> M(A(O))={(x,xi)| x in A(O), xi irreducible representation of Cent_A(O)(x)}
 (x=1,xi=1) -> Springer(O)  giving all special representations of W
}

set sigma_L_verbose=true

{even orbit O, RootDatum M, vec H_M,ratvec v
 O is an orbit for RootDatum G
 (M,H_M,v) will be from component_representative_plus(O)
 L=Cent_G(\exp(2\pi iv)) is a pseudo-Levi
 M is a pseudo-Levi
 M\subset L\subset G
 O intersects M in a single distinguished orbit O_M
  this is the orbit with H_M
 O_L = L.O_M, has H_L=dominant(H_M,L)
 then sigma_L=Springer(O_L)\otimes sign 
  [note: \otimes sgn is wrong for the exceptional orbits in E7/E8]
 sigma_L is an irreducible representation of L^\vee
 sigma=truncated_induction(\sigma_L) = irreducible representation of W(G^\vee)
 except in G2/F4: W(G^vee)\simeq W(G) is the identity map on characters
 in fact, same is true in G2, but not F4
}

{
Compute A-bar:  A(O)/ all conj. classes x st sigma_L(x,1)=sigma_L(1,1)
}
{
There are two Springer maps differing by tensoring with sign,
similarly Lusztig and sigma_L

Springer_1(0)=sgn
Springer_2(0)=trivial
Carter's tables (and all others?) are of Springer_1

How to compute Lusztig_i(O,x,xi)
These are given (for exceptional groups) starting on page 96
 of Orange (Lusztig's book), these are the families,
 once you know Lusztig_i(O,1,1):
DEFINE:
Lusztig_i(O,1,1)=Springer_i(O)
Desideratum:
the map (O,x,xi) -> W-hat given by the families
 in Lusztig, page 95+, is Lusztig_1 (not Lusztig_2)
 Note: Lusztig_i(O,1,1) is unambiguous
 but the map in Orange is Lusztig_1, not Lusztig_2
 for example in G_2, subregular, given in the book:
  Lusztig_1(O,1,ref) = phi''(1,3)
  Lusztig_1(O,g_3,1) = phi'(1,3)
 and this implies
  Lusztig_2(O,1,ref) = phi'(1,3)
  Lusztig_2(O,g_3,1) = phi''(1,3)

Example: F4, orange pg 96:

{4_2,2_1,2_3} = {phi(4,1),phi''(2,4),phi'(2,4)}    a=1
{4_5,2_4,2_2} = {phi(4,13),phi''(2,16),phi'(2,16)} a=13
the phi's are given by Carter page 413

Carter pg 428:
Springer_1(A1s)=phi(4,13)
Springer_1(F4(a1))=phi(4,1)
=>
Lusztig_1(A1s,1,1)=phi(4,13)
Lusztig_1(F4(a1),1,1)=phi(4,1)

also (from Orange, page 97):
A=A-bar=Z2
Lusztig_1(A1s,g_2,1)=phi''(2,16)
Lusztig_1(A1s,1,xi)=phi'(2,16)
Lusztig_1(F4(a1),g_2,1)=phi''(2,4)
Lusztig_1(F4(a1),1,xi)=phi'(2,4)

The conjecture is about Lusztig_2, so let's tabulate that:
Lusztig_2(A1s,1,1)=phi(4,13)*sgn=phi(4,1)
Lusztig_2(F4(a1),1,1)=phi(4,1)*sgn=phi(4,13)
Lusztig_2(A1s,g_2,1)=phi''(2,4) {caution: the primes switch} 
Lusztig_2(A1s,1,xi)=phi'(2,4)
Lusztig_2(F4(a1),g_2,1)=phi''(2,16)
Lusztig_2(F4(a1),1,xi)=phi'(2,16)

sigma_L_2(O,x,1) is defined

Conjecture:
sigma_L_2(O,x,1)=Lusztig_2(O,x,1)

by the definition of sigma_L_2 this is:

t-ind(Springer_2(O_L))=Lusztig_2(O,x,1)

special case: x=1, this says:

Springer_2(O)=Lusztig_2(O,1,1) (correct)

key example:
orbit=0, x=1 or anything
x=1: Springer_2(0)=trivial of W_L=W
Lusztig_2(0,1,1)=trivial
x=anything:
Springer_2(0)=trivial of W_L -> truncated induce -> trivial of W

BUT

Springer_1(0):
 x=anything
 sigma_L_1(0,1,1)=t-ind Springer_1(O_L)=t-ind sgn_{W_L} is NOT sgn_{W_G}

So nothing like the conjecture can hold for sigma_L_1
}

{NOTE: sigma_L_even and all others compute sigma_L_2: sigma_L_2(0-orbit,1)=trivial}
set sigma_L_even(SpringerTable st,ComplexNilpotent orbit,RootDatum M,vec H_M,ratvec v)=int:  {modify v by center of M^0}
assert(is_even(orbit),"orbit is not even");
let ()=prints(new_line,"Computing sigma_L_even: ",new_line, "G=", st.root_datum,new_line,"M=", M, new_line, "H_M=",H_M,new_line,"v=", v) in
if v.is_integer then  {L=G, don't need induction}
 let ()=prints("v is integer, no induction") in
 let char=st.ct.tensor_sign(st.ct.characters[st.springer(orbit)]) in
 st.ct.character_index(char)
else  {need induction; compute L, sigma_L, truncated_induce}
 let ()=prints("need induction: ") in
 let rd=orbit.root_datum then
 ()=if sigma_L_verbose then prints(("v=",v) ) fi then
 L=centralizer(rd,v) then
 ()=if sigma_L_verbose then prints(("L=",L, new_line, "G=", rd) ) fi then
 {O_M=ComplexNilpotent:(M,(),H_M) -> saturation -> O_L
  O_L has the same H=H_M, but made L-dominant}
 H_L=dominant(H_M,L) then
 ()=if sigma_L_verbose then prints(("L=", L) ) fi then
 ()=if sigma_L_verbose then prints(("H_L=", H_L) ) fi then
 O_L=ComplexNilpotent:(L,(),H_L) then
 ()=if sigma_L_verbose then prints(("O_L:", O_L.H, " ", O_L.diagram) ) fi then
 roots_L=for alpha in L.simple_roots do find(rd.roots,alpha) od then
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
 sigma_L=
 if O_L=L.zero_orbit then
  L.character_table.trivial {Springer(O_L)*sign}
 elif O_L=L.principal_orbit then
  L.character_table.sign {Springer(O_L)*sign}
 else  {need to compute L.springer_table}
  let ()=if sigma_L_verbose then prints(("computing st_L:") ) fi then
  st_L=L.springer_table then
  ()=if sigma_L_verbose then prints(("done") ) fi then
  L_index=st_L.springer(O_L) then
  ()=if sigma_L_verbose then prints(("O_L", O_L, " ", O_L.diagram) ) fi then
  ()=if sigma_L_verbose then prints(("L_index: ", L_index) ) fi then
  sigma_L_0=st_L.characters[L_index] then
  sigma_L=st_L.ct.tensor_sign(sigma_L_0)  then
roo  ()=if sigma_L_verbose then prints("sigma_L: ", sigma_L, new_line, "index=", st_L.ct.character_index(sigma_L)) fi in
  sigma_L
 fi  {end if O_L=L.zero_orbit} then
  (ignore_degree,char_indices)=
     prints("truncated induce: ", "G=",rd,new_line,"roots_L: ", roots_L, " ", sigma_L);

  truncate_induce_character(rd,st.ct,roots_L,sigma_L) then
  char=st.ct.characters[char_indices[0]] then
  ()=if sigma_L_verbose then prints("character of L: ", char_indices[0], new_line, char) fi in
  st.ct.character_index(char)
fi

{orbit -> list of pairs (L,[v_1,...,v_n]) L is a pseudo-Levi}
set pseudo_Levi_pairs(ComplexNilpotent orbit)=[(RootDatum,[ratvec])]:
let (,,pairs)=orbit.component_datum in pairs

{representatives of conjugacy classes in A(O)
 each ratvec v gives an element exp(2\pi iv) which is G-conjugate
 to an element of Cent(O)
}
set component_representatives(ComplexNilpotent orbit)=
let (,,pairs)=orbit.component_datum in
 ##for (L,ratvecs) in pairs do
    for v in ratvecs do (L,v)
    od
   od

set component_representatives_plus(ComplexNilpotent orbit)=[(RootDatum,vec,ratvec)]:
let (,,triples)=orbit.component_datum_plus in
 ##for (M,v,ratvecs) in triples do
    for w in ratvecs do (M,v,w) od
   od

{run over all ratvecs from component_representatives(orbit)}
set sigma_L_even(SpringerTable st,ComplexNilpotent orbit)=[int]:
prints("sigma_L_even for: ", orbit, " st:",st.root_datum);
for (M,H_M,v) in component_representatives_plus(orbit) do
 let ()=prints(new_line,"computing sigma_L for M=", M, new_line,"H_M=",H_M,new_line, "v=", v) in
 sigma_L_even(st,orbit,M,H_M,v) od

set sigma_L_even(ComplexNilpotent orbit)=sigma_L_even(orbit.root_datum.springer_table,orbit)

set show_sigma_L_even(SpringerTable st,ComplexNilpotent orbit)=
tabulate(["M","v","L","H_M","j","deg_j","char_j"]#
for (M,H_M,v) in component_representatives_plus(orbit) do
 let ()=prints("doing M:", M) in
  let j=sigma_L_even(st,orbit,M,H_M,v) in
   [M.nice_format, v.compact_ratvec,centralizer(st.root_datum,v).nice_format,H_M.compact_ratvec,j.to_string,st.ct.degrees[j].to_string,st.ct.characters[j].to_string]
 od
)

set show_sigma_L_even(SpringerTable st,[ComplexNilpotent] orbits)=
tabulate(["orbit","M","v","L","j","dim_j","deg_j","name","tensor_sign name","char_j"]#
##for orbit in orbits do
 let ()=if sigma_L_verbose then prints("doing orbit: ", orbit.diagram) fi in
 for (M,H_M,v) in component_representatives_plus(orbit) do
  let ()= if sigma_L_verbose then prints("doing M:", M) fi  in
   let ()=prints("doing v: ", v) in
   let j=sigma_L_even(st,orbit,M,H_M,v) in
    [orbit.diagram.to_string,
    M.nice_format,
    v.compact_ratvec,
    centralizer(st.root_datum,v).nice_format,
    j.to_string,
    st.ct.dimension(j).to_string,
    st.ct.degrees[j].to_string,
    st.ct.irreducible_label(j),
    st.ct.irreducible_label(st.ct.character_index(st.ct.tensor_sign(st.ct.characters[j]))),
    st.ct.characters[j].to_string]
   od
 od
)

set show_sigma_L_even(SpringerTable st)=void:
show_sigma_L_even(st,st.ct.root_datum.even_orbits)


{-------------------------------------------------------------------}


{sigma_L for general orbit, comes down to sigma_L for an even orbit
 for the integrality subgroup
 O -> rd_int (integrality_datum: roots integral on O.H/2)
   -> O_int even orbit for rd_int
   -> sigma_L(O_int) by previous construction \in W(rd_int)
   -> truncated induction_{rd_int}^rd sigma_L(O_int)
}

{NB: be careful about the character/Springer tables of rd_int versus those for rd
in the code: ct/st always means for rd, ct_int/st_int is for rd_int}

set sigma_L(RootDatum rd,CharacterTable ct,SpringerTable st_int,ComplexNilpotent O)=
let ()=prints(new_line,"-------------",new_line,"Orbit: ", O, " ", O.diagram) then
()=prints("ct: ", ct.root_datum) then
()=prints("st_int: ", st_int.root_datum) then
{O_int=integral_descent(O)   {an orbit for a subgroup of G NOT TRUE} then}
O_int=ComplexNilpotent:(centralizer_coweight(O.root_datum,O.H/2),(),O.H) then
()=prints("O_int: ", O_int, " ", O_int.diagram, " ", O_int.diagram_normalized) then
()=prints("O_int roots: ", O_int.root_datum.simple_roots) then
()=prints("rd: ", rd) then
()=prints("rd roots: ", rd.roots) then
sigma_int=sigma_L_even(st_int,O_int) then
()=prints("sigma_int: ", sigma_int) then
roots_int=for alpha in O_int.root_datum.simple_roots do find(rd.roots,alpha) od then
()=prints("roots_int: ", roots_int) then
rv= ##for i in sigma_int do
 let (,sigma)=truncate_induce_character(rd,ct,roots_int,st_int.ct.characters[i]) in
 prints("i: ", i, " sigma: ", sigma);sigma od in
rv

{need ct for G, st_int for subgroup}
set sigma_L(ComplexNilpotent O)=
if O.is_even then sigma_L_even(O)
else
let ct=O.root_datum.character_table then
rd_int=integrality_datum(O) then
st_int=rd_int.springer_table in
sigma_L(O.root_datum,ct,st_int,O)
fi

set show_sigma_L(RootDatum rd,CharacterTable ct,SpringerTable st_int,ComplexNilpotent O)=
{let O_int=integral_descent(O)   {an orbit for a subgroup of G NOT TRUE} then}
let O_int=ComplexNilpotent:(centralizer_coweight(O.root_datum,O.H/2),(),O.H) then
data_int={sigma_L_even(st_int,O_int) then}
          { set show_sigma_L_even(SpringerTable st,ComplexNilpotent orbit)=}
          { tabulate(["L","v","M","H_M","j","deg_j","char_j"]#}
 for (M,H_M,v) in component_representatives_plus(O_int) do
   let j=sigma_L_even(st_int,O_int,M,H_M,v) in (M,H_M,v,j) 
 od
then
roots_int=for alpha in O_int.root_datum.simple_roots do find(rd.roots,alpha) od in
tabulate(
 for i:#data_int do
  let (M,H_M,v,j)=data_int[i] then
  (,sigma)=truncate_induce_character(rd,ct,roots_int,st_int.ct.characters[i]) in
  [i.to_string,
   O_int.root_datum.nice_format,
   M.nice_format,
   H_M.compact_ratvec,
   v.compact_ratvec,
   j.to_string,
   sigma.to_string,
   ct.degrees[j].to_string,
   ct.characters[j].to_string]
 od)

set show_sigma_L(RootDatum rd,CharacterTable ct,[ComplexNilpotent] orbits)=
tabulate(
["O","i","rd_int","M","H_M","v","L","sigma_int","sigma","dim","deg","sgn","deg_sgn","char"]#
##for O in orbits do
 {let O_int=integral_descent(O)   {an orbit for a subgroup of G NOT TRUE} then}
 let O_int=ComplexNilpotent:(centralizer_coweight(O.root_datum,O.H/2),(),O.H) then
 rd_int=O_int.root_datum then
 st_int=O_int.root_datum.springer_table then
 data_int=
  for (M,H_M,v) in component_representatives_plus(O_int) do
    let sigma_int=sigma_L_even(st_int,O_int,M,H_M,v) in (M,H_M,v,sigma_int) 
  od
 then
 roots_int=for alpha in rd_int.simple_roots do find(rd.roots,alpha) od in
  for i:#data_int do
   let (M,H_M,v,sigma_int)=data_int[i] then
   (,sigma_array)=truncate_induce_character(rd,ct,roots_int,st_int.ct.characters[sigma_int]) then
   sigma=assert(#sigma_array=1,"array wrong length");sigma_array[0] then
   tensor_sgn_index=ct.tensor_sign_index(sigma) in
   [O.diagram.to_string,
    i.to_string,
    rd_int.nice_format,
    M.nice_format,
    H_M.compact_ratvec,
    v.compact_ratvec,
    centralizer(rd_int,v).nice_format,
    sigma_int.to_string,
    sigma.to_string,
    ct.dimension(sigma).to_string,
    ct.degrees[sigma].to_string,
    tensor_sgn_index.to_string,
    ct.degrees[tensor_sgn_index].to_string,
    ct.characters[sigma].to_string]
  od od)

set show_sigma_L(RootDatum rd,CharacterTable ct,ComplexNilpotent orbit)=show_sigma_L(rd,ct,[orbit])

set show_sigma_L(CharacterTable ct)=void:
show_sigma_L(ct.root_datum,ct,ct.root_datum.orbits)

set show_sigma_L(RootDatum rd)=void:
show_sigma_L(rd.character_table)

{{need ct for G, st_int for subgroup}
set show_sigma_L(ComplexNilpotent O)=
let ct=O.root_datum.character_table then
rd_int=integrality_datum(O) then
st_int=rd_int.springer_table in
show_sigma_L(O.root_datum,ct,st_int,O)
}


