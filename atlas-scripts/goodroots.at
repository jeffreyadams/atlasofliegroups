<<induction.at {for theta_stable_quasi_data}
<<K.at {for K_0}
<<hermitian.at {for is_hermitian}
<<Vogan-dual.at {for dual@Param}

{Before introducing L1, first command failed for  G=GL(2,R),
limit of discrete series

p = final parameter(x=0,lambda=[1,1]/2,nu=[0,0]/1)

}

{.long element for the good Weyl group. Hope that the condition to be
Hermitian and positive on LKTs is w0_good_matrix(p) * p.nu = -p.nu.
Calculation mostly takes place in the Levi of a theta-stable
parabolic; at the end chw is change of variable to get back to
(G,x,lambda).}
{ really this only depends on the pair (x,lambda), but as far as I
know there isn't a type (KGBElt,ratvec) like that??? }
set w0_good_matrix(Param p) = ratmat:
    let (w,) = from_dlambda_dom(p)
    then chw = w.matrix, chwinv = w.inverse.matrix,
    	(Q,pL) = theta_stable_quasi_data(p)
    then L = Q.Levi, pL0 = pL*0, x0=pL.x
    {infinitesimal character of pL0 vanishes on all roots of L}
    {difficulty with this L is that x0 need not be x_open(L), so
    pL0.dual need not be in the fundamental fiber.}
    then q0d = pL0.dual
    {need to find something in block_of(q0d) that DOES live on fund fiber}
    then L0d = q0d.real_form, q1d = last_param(character_formula(q0d))
    then K0d = K_0(q1d.x),
    	 deltad = L0d.distinguished_involution
    { then () = assert(2^components_rank(L0d) >= #LKTs(p),
	 "#LKTs doesn't match comps of L0d") |}
    then w0d = w0(K0d).matrix, B = injection_from_K_matrix(q1d.x)
      {B maps X_*(K0d) into X_*(L0d), ^B maps X^*(L0d) onto X*(K0d)}
    then C = right_inverse(^B)
      {C maps X^*(K0d) into X^(L0d), ^C maps X_*(L0d) onto X_*(K0d)}
    in chw * (B*^w0d*^C*((1+^deltad)/2) + (1-^deltad)/2)*chwinv
    {middle part (being conj by chw)  MIGHT need to be conjugated to make it
    act on the -1 eig of theta for pL. More or less this is conj by
    the Weyl element for L carrying theta(x0) to distinguished
    involution for L. But problem doesn't arise in lots of tests.}

set is_pos_on_LKTs(Param p) = bool:
    let () = if not is_hermitian(p) then
    	 prints("oops, parameter is not hermitian"); return false fi
    then nu = p.nu, wpos = w0_good_matrix(p)
    in wpos*nu = -nu
