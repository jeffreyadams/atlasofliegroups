<<induction.at {for theta_stable_quasi_data}
<<K.at {for K_0}
<<hermitian.at {for is_hermitian}
<<Vogan-dual.at {for dual@Param}
<<translate.at {for translate_param_by}
<<kl.at {for composition_series}
<K_highest_weights.at {for all_parameters_x_gamma}

{.long element for the good Weyl group. Hope that the condition to be
Hermitian and positive on LKTs is w0_good_matrix(p) * p.nu = -p.nu.
Calculation mostly takes place in the Levi of a theta-stable
parabolic; at the end chw is change of variable to get back to
(G,x,lambda).}
{ really this only depends on the pair (x,lambda), but as far as I
know there isn't a type (KGBElt,ratvec) like that??? }
set w0_good_matrix(Param p) = ratmat:
    let (w,) = from_dlambda_dom(p)
    then chw = w.matrix, chwinv = w.inverse.matrix,
    	(Q,pL) = theta_stable_quasi_data(p)
    then L = Q.Levi, pL0 = pL*0, x0=pL.x
    {infinitesimal character of pL0 vanishes on all roots of L}
    {difficulty with this L is that x0 need not be x_open(L), so
    pL0.dual need not be in the fundamental fiber.}
    then q0d = pL0.dual
    {need to find something in block_of(q0d) that DOES live on fund fiber}
    then L0d = q0d.real_form, q1d = last_param(character_formula(q0d))
    then K0d = K_0(q1d.x),
    	 deltad = L0d.distinguished_involution {=qld.x.involution}
    { then () = assert(2^components_rank(L0d) >= #LKTs(p),
	 "#LKTs doesn't match comps of L0d") |}
    then w0d = w0(K0d).matrix, B = injection_from_K_matrix(q1d.x)
      {B maps X_*(K0d) into X_*(L0d), ^B maps X^*(L0d) onto X*(K0d)}
    then C = right_inverse(^B)
      {C maps X^*(K0d) into X^(L0d), ^C maps X_*(L0d) onto X_*(K0d)}
    in chw * (B*^w0d*^C*((1+^deltad)/2) + (1-^deltad)/2)*chwinv
    {middle part (being conj by chw)  MIGHT need to be conjugated to make it
    act on the -1 eig of theta for pL. More or less this is conj by
    the Weyl element for L carrying theta(x0) to distinguished
    involution for L. But problem doesn't arise in lots of tests.}

set long_elt(RootDatum R) = mat:
    let R_remaining = R
    then M = id_mat(R.rank)
    then r = #R_remaining.poscoroots
    then () = while r > 0 do
    	 M *:= reflection(R_remaining, r -1);
	 R_remaining :=
    	 	     centralizer([R_remaining.poscoroots[r-1]],R_remaining);
         r:=#R_remaining.poscoroots
	 od
    in M

{this version takes also a distinguished involution MinusTheta of R,
    assumed to be of order 2, and a vec d in X* (defined mod
    (1+MinusTheta)X*) defining a character of H^theta; and computes a
    representative of the long element of the good reduced root system.}
set w0_good_long_elt(RootDatum R, mat MinusTheta, vec d) = mat:
    ( let roots_remaining = #R.nr_of_posroots, M=id_mat(R.rank)
      then old_size = #roots_remaining+1
    in while #roots_remaining<old_size
    	 do old_size :=#roots_remaining
    	 ; for i in roots_remaining
	 ~do let alpha_vee = coroot(R,i)
	 in if alpha_vee*MinusTheta != alpha_vee
	    then let S = reflection(R,i) in 
    	    M *:= (S * MinusTheta)^2
	    ; roots_remaining:=
	    for j in roots_remaining
	    do if =(alpha_vee + alpha_vee*MinusTheta)*root(R,j)
	       then [j] else [] fi
	    od.##
	    ; break
	 elif is_even(alpha_vee*d) {want essentially nonparity real roots}
	 then M *:= reflection(R,i)
	 ; roots_remaining:=
	    for j in roots_remaining
	    do if is_orthogonal(R,i,j) then [j] else [] fi
	    od.##
	    ; break
	 fi
	 od
    od
    ; M
    )

{Version of w0_good_matrix using w0_good_long_elt. The iterations over
all positive coroots make it rather slow compared to w0_good_matrix: }

set w0_good_matrix2(Param p) = mat:
    let (w,) = from_dlambda_dom(p)
    then chw = w.matrix, chwinv = w.inverse.matrix
    ,	(Q,pL) = theta_stable_quasi_data(p)
    then L = Q.Levi, pL0 = pL*0, x0=pL.x
    {infinitesimal character of pL0 vanishes on all roots of L}
    {difficulty with this L is that x0 need not be x_open(L).}
    then xL = L.x_open
    ,pLup = translate_param_by(pL0
    , ratvec_as_vec(2*rho(L))) {change from pL to pL0}
    then p0up = Param: 
    let val = Param: p { dummy value; |val| will be assigned to below} in
    for p in all_parameters_x_gamma(x_open(L),pLup.infinitesimal_character)
    do if composition_series(p)[pLup] != 0 then val:=p; break fi
    od
    ; val { value to initialise |p0up| }
    then p0 = translate_param_by(p0up,-ratvec_as_vec(2*rho(L)))*0
    {now p0 is attached to x_open(L)}
    then Ltest = ratvec_as_vec(p0.lambda - L.rho)
    then wzero = w0_good_long_elt(L, -xL.involution, Ltest)
    in chw*(wzero)*chwinv


set is_pos_on_LKTs(Param p) = bool:
    let () = if not is_hermitian(p) then
    	 { prints("oops, parameter is not hermitian");} return false fi
    then () = if #LKTs(p) = 1 then return true fi
    then nu = p.nu, wpos = w0_good_matrix(p)
    in wpos*nu = -nu

{Version using w0_good_matrix2}
set is_pos_on_LKTs2(Param p) = bool:
    let () = if not is_hermitian(p) then
    	 {prints("oops, parameter is not hermitian");} return false fi
    then () = if #LKTs(p) = 1 then return true fi
    then nu = p.nu, wpos = w0_good_matrix2(p)
    in wpos*nu = -nu

