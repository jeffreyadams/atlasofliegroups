<basic.at
<sort.at { for inv_standardisation }
<Weylgroup.at { for make_dominant }

{also see parabolics.at}

{
  see "K_types in atlas", in dropbox, ultimately on atlas web site

  Fix a subset S of the simple roots, defining the complex standard
  parabolic P_S (see parabolic.at) of type S. We define a set KGP(S) (a
  quotient of KGB) such that (roughly) KGP(S) <-> K\G/P_S

  More precisely for any x\in KGB and p(\xi)=x then
  KGP(S) is canonically in bijection with K_\xi\G/P_S, i.e.
  K_\xi conjugacy classes of parabolics of type S.

  K orbits on G/P_S, equivalently K-conjugacy classes of parabolics of type S
  Given a RealForm and a subset S of the simple roots
  S -> partial order on KGB, generated by ascents not in S
    -> equivalence relation generated by this
  KGB/equivalence <-> K\G/P_S
  Define KGP to be KGB modulo this equivalence

  Data: ([int],KGBElt)=(S,x) where S lists the indices of a subset of the
  simple roots of root_datum(x)
  Equivalence: (S,x)=(S',y) if these correspond to the same K orbit on G/P_S,
  which means:
   real_form(x)=real_form(y), S=S'  (i.e. same complex parabolic), and
   x=y in the equivalence defined by S
  In particular, given (S,x), taking x itself for the strong real form,
  (S,x) goes to K_x-conjugacy class of the standard parabolic P_S

  Given (S,x),
  write [x_1,...,x_n] for the S-equivalence class of x\subset KGB

  The last element x_n is maximal, and is uniquely determined
  This orbit of K on G/P_S is closed <=>x_1 is closed in KGB
}

{ data type for a K-orbit on G/P_S, equivalently a K-conjugacy class of
  parabolics of type S
  ([int] S,KGBElt x)
  S lists indices of a subset of the simple roots
  (S,x)=(S,y) if x is S-equivalent to y, see below
  Associated to (S,x) is a canonical K-conjugacy class of parabolics of type S
  More precisely, for each \xi, a K_\xi-conjugacy class of parabolics of type S
}
: KGPElt    = ([int], KGBElt)
: Parabolic = ([int], KGBElt)  {synonym}

{ some auxiliary routines needed for defining equivalence of data }
set sort_by((KGBElt -> int) f)= ([KGBElt] v) [KGBElt]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od
set sort = ([KGBElt] -> [KGBElt]): sort_by((KGBElt x) int: #x)

set min ([KGBElt] list)=sort(list)[0]
set max ([KGBElt] list)=sort(list)~[0]

set S (KGPElt(S,)) = [int]: S
set root_datum (KGPElt(,x)) = RootDatum: root_datum(x)
set real_form  (KGPElt(,x)) = RealForm:  real_form(x)

{ complement of subset of simple roots in rank n }
set complement(int n,[int] S) = [int]:
  list((int i)bool: none(for m in S do i=m od),n)

{ add i to list if (and only if) it is new }
set add_new(int i,[int] list) = [int]:
  if find(list,i)=-1 then list#i else list fi

{elements above x one step in the partial order given by ascents in S}
set up_neighbors([int] S,KGBElt x)=[int]:
let result=[int]:[] in
for i in S do
 let t=status(i,x) in
  if t=3 then result#:= #Cayley(i,x)
  elif t=4 then result#:= #cross(i,x) fi od;sort_u(result)

{elements below x one step in the partial order}
set down_neighbors([int] S,KGBElt x)=[int]:
  let result=[int]:[] in
  for i in S
  do let t=status(i,x) in
    if t=2
    then let y=Cayley(i,x) in result#:= #y; result #:= #cross(i,y)
    elif t=0 then result# := #cross(i,x)
    fi
  od; sort_u(result)

set is_maximal_in_partial_order ([int] S,KGBElt x)=bool: #up_neighbors(S,x)=0

{ maximal elements in the partial order }
set maximal_in_partial_order(RealForm G,[int] S)=[KGBElt]:
  let result=[int]:[] in
  for x in KGB(G)
  do if is_maximal_in_partial_order(S,x) then result #:= #x fi od;
  for i in sort(result) do KGB(G,i) od

{ (unique) maximal element in equivalence class of x }
set maximal([int] S,KGBElt x)=KGBElt:
  let rec_fun f([int] S,KGBElt x)=KGBElt:
    if is_maximal_in_partial_order(S,x) then x
    else f(S,KGB(real_form(x),up_neighbors(S,x)[0]))
    fi
  in f(S,x)

set canonical_representative(KGPElt y)=(S(y),maximal(y))
set x(KGPElt y)=KGBElt:maximal(y)

{equivalence class of KGB element in partial order defined by S}
set equivalence_class_of(KGPElt(S,x):y)=[KGBElt]:
  let x_max=maximal(S,x)
  then G=real_form(x_max),result=[#x_max], to_do=[#x_max]
  in
  while #to_do>0
  do let y=KGB(G,to_do[0]) then new=down_neighbors(S,y) in
    for i in new do result:=add_new(i,result);to_do:=add_new(i,to_do) od
  ; to_do:=delete(to_do,0)
  od;
  for i in sort(result) do KGB(G,i) od


{ a minimal element from equivalence class (unlike x_max, it is not unique) }
set x_min (KGPElt P) = min(equivalence_class_of(P))

{set of KGP elements (P,S), S=[KGBElt] is an equivalence class
KGP(G,P) is in bijection with K\G/P}
set KGP(RealForm G,[int] P)=[KGPElt]:
for x in maximal_in_partial_order(G,P) do (P,x) od

{ sometimes it is convenient to just keep the numbers, although this loses the
  information of what G is }
set KGP_numbers (RealForm G,[int] S) =[int]: for (,x) in KGP(G,S) do #x od



{test y in K\G/P_S is closed: <=> length(first element)=0}
set is_closed(KGPElt y)=bool:let eq=equivalence_class_of(y) in length(min(eq))=0

set KGP_elt([int] P,KGBElt x)=KGPElt:(P,x)

{parabolic determined by lambda q(lambda)=l(lambda)+u(lambda)}
set KGP_elt(ratvec lambda,KGBElt x)=KGPElt:
let rd=root_datum(x) then
{()=prints("lambda=",lambda) then}
P=[int]:[]  then
(lambda_dom,w)=make_dominant(rd,lambda) then
{()=prints("w=",w) then}
y=cross(inverse(w),x) in
for a@i in simple_roots(rd) do if a*lambda_dom=0 then P#:=i fi od;
KGP_elt(P,y)

set parabolic([int] P,KGBElt x)=Parabolic:KGP_elt(P,x)  {simple roots P}
set parabolic(ratvec lambda,KGBElt x)=Parabolic:KGP_elt(lambda,x) {lambda in \h^*}

{test y in K\G/P_S is open: <=> last element of y is last element of KGB}
set is_open(KGPElt y)=bool:let eq=equivalence_class_of(y) then
G=real_form(y) in  maximal(y)=KGB(G,KGB_size(G)-1)

{(S,x)=(T,y) if these give the same K-orbit of parabolics}
set =(KGPElt (S,x),KGPElt (T,y))=bool: real_form(x)=real_form(y) and S=T and maximal(S,x)=maximal(S,y)





