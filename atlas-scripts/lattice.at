<basic.at
<matrix.at { for |ech_up@(mat,[int])| }

{ General linear algebra over $\Z$. In so far as saturation of lattices is
  done, this actually relates to vector spaces over $\Q$, but all computations
  are done with integers only, distinguishing this script from Gaussian-elim.at
}

{ Compute what appears to be called the Hermite form of an integral matrix.

  |M| is an $n\times k$ matrix, so columns of |M| span a $\Z$-submodule
  $ W=image(M)$ of $\Z^n$; get canonical generators for this submodule
}
set image_lattice (mat A) = mat:
   let (M,,pivots,)=echelon(A) then c=#M
in for i@j in pivots
   do let col=M[j] then pivot=col[i]
   in for l: c-1-j from j+1 do M[l]-:=col*(M[i,l]\pivot) od
   od; M

{ whether |image_lattice(M)| is a saturated lattice (direct factor of $\Z^n$) }
set is_saturated (mat M) = bool:
   let (M,,pivots,)=echelon(M)
in set (M,):=ech_up(M,pivots); product(M.main_diagonal)=1

{ The function |adapted_direct_sum| finds the dimenion |k| of the image of |M|,
  and a $\Z$-inverible matrix |R| whose first |c| columns span the saturation of
  the image, while remaining ones span a chosen complement of that saturation.

  Apart from the initial call of |echelon| to standardise the image and compute
  the list of |pivot| positions, this function is very similar to |ech_up| in
  matrix.at, but the inverse of the recording matrix is needed here, and since
  replacing columns is easier than replacing rows, we maintain the matrix in
  inverse transposed form so that we can still maintina it by column operations.

  We avoid using |adapted_basis| and |diagonalize|, which may suffer severe
  coefficient growth for not too small matrices; we do however use |echelon|
  and |Bezout| that might have similar effects. It is to be used in situations
  where only the (saturated) image subspace as a whole, and possibly a choice of
  a complementary subspace, are needed, not a special basis for the image.
}
set adapted_direct_sum (mat M) = (int,mat):
   let (M0,,pivot,)=echelon(M) then (k,l)=shape(M:=^M0) { forget and reuse |M| }
   then R=id_mat(l) { record transpose inverse of column operations applied }
in { now do coordinate change to make |M| upper triangular }
   for i:k { loop over columns of M while it is being modified in the loop }
   do let piv_i=pivot[i]+1 { only consider few rows now: |i:piv_i| }
   in if i<pivot[i] { avoid doing any work when our range is a single row }
      then
         let (d,C)=Bezout(vector(piv_i-i,(int j):M[i,i+j]))
         then new_M_cols=M[i:piv_i] * C, new_R_cols = R[i:piv_i] * ^C.inverse
         { updated rows are now spliced into place in |M| and |R|: }
      in for j:piv_i-i do M[i+j]:=new_M_cols[j]; R[i+j]:=new_R_cols[j] od
      fi
   od; assert(R*^M=M0); (k,R)

set image_subspace (mat M) = mat: { generators for $\Q$-span of image of |M| }
   let (c,R)=adapted_direct_sum(M) in R[:c]

set image_complement_basis (mat M) = mat:
   let (c,R)=adapted_direct_sum(M) in R[c:]

set saturation = image_subspace@mat { intersection of $\Z^n$ with $\Q$-span }

{ a basis representing the quotient by sublattice spanned by columns of |M|;
  tests that this sublattice is a direct factor, and throws an error if not }
set free_quotient_lattice_basis (mat M) = mat:
( let (E,,,)=echelon(M) in { pre-compute echelon }
  assert(E.is_saturated,"sublattice is not a direct factor")
; image_complement_basis(E)
)

{ a basis representing the quotient by saturation of sublattice, so no test }
set saturation_quotient_basis = image_complement_basis@mat


{ |M| is an $n\times k$ matrix; its columns span a submodule $W$ of $\Z^n$.
  Compute $n\times n$ matrix of projection onto the saturation (or $\Q$-span)
  of $W$, parallel to its complement from |adapted_sirect_sum(M)|.
}
set projector_to_image (mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in R[ : , :c] * R.inverse[ :c, : ]


{ complementary projector, to chosen complement to |image_subspace(M)| }
set projector_mod_image (mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in R[ : ,c: ] * R.inverse[c: , : ]

{ |M| is an $n\times k$ matrix; its columns span a submodule $W$ of $\Z^n$.
  A complement to |image_subspace(M)| is chosen by |adapted_direct_sum(M)|, and
  |decompose(M,w)=(u,v)| with |u| in |image_subspace(M)| and |v| in complement.
}
set decompose (mat M, vec v)= (vec,vec):
   let (c,R)=adapted_direct_sum(M) then R1=R.inverse
in (R[:,:c] * (R.inverse[:c,:] * v), R[:,c:] * (R.inverse[c:,:] * v) )

set decompose (mat M, ratvec w) = (ratvec,ratvec):
   let (v,d)=%w then (v1,v2)=decompose(M,v) in (v1/d,v2/d)


{ assuming M injective and Im(M) is A-stable, return unique B with A*M=M*B,
  which is action of A restricted to that sublattice $\Z^m$, embedded via M
}
set restrict_action (mat A, mat M) = mat: { shapes A: n by n, M: n by m }
   case solve(M,A*M) | some(B): B
   | else error("Image lattice M is not fixed by A")
   esac

{ assuming M full row rank and ker(M) is A-stable, find unique B with M*A=B*M }
set corestrict_action (mat M,mat A) = mat:  { shapes M: m by n, A: n by n }
   case solve(^M,^(M*A)) | some(tB): ^tB
   | else error("Kernel of M is not fixed by A")
   esac

{ |M| is an $n\times k$ matrix; its columns span a subspace $W$ of $\Q^n$.
  Assuming this subspace is |A|-stable, |A| induces an operator in $\Q^n/W$;
  return its matrix w.r.t the complement chosen by |adapted_direct_sum(M)|.
}
set quotient_matrix (mat A,mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in (R.inverse[c: , : ]*A*R[ : ,c: ])

set solve_ratvec (mat A, vec v) = ratvec:
  (A,ratvec:v).solve.(requisition("not in span"))

{ integer vector (lattice) solutions to linear system }


set in_lattice (mat A, ratvec u) = bool: { whether v in image lattice of A }
  let (b,n)=%u in n=1 and can(solve(A,b))

set vec_solve (mat A, ratvec u) = Maybe<vec>: { integer solution to A*x=b }
  let (b,n)=%u in if n>1 then none() else solve(A,b) fi

{ express columns of M relative to basis A of a sub-lattice that contains them
  A: nxm matrix, columns are a basis of a Z-module V of rank m
  M: nxr matrix, columns span a submodule of V; returns mxr matrix C,
  column i gives column i of M as a sum of columns of A i.e., A*C=M
}
set in_lattice_basis (mat A,mat M) = mat:
  #A { size m of solutions } # for v in M do required_solution(A,v) od
