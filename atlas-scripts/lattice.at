<basic.at
<matrix.at { for |ech_up@(mat,[int])| }

{ General linear algebra over $\Z$. In so far as saturation of lattices is
  done, this actually relates to vector spaces over $\Q$, but all computations
  are done with integers only, distinguishing this script from Gaussian-elim.at
}

{ Compute what appears to be called the Hermite form of an integral matrix.

  |M| is an $n\times k$ matrix, so columns of |M| span a $\Z$-submodule
  $ W=image(M)$ of $\Z^n$; get canonical generators for this submodule
}
set image_lattice (mat A) = mat:
   let (M,,pivots,)=echelon(A) then c=#M
in for i@j in pivots
   do let col=M[j] then pivot=col[i]
   in for l: c-1-j from j+1 do M[l]-:=col*(M[i,l]\pivot) od
   od; M

{ whether |image_lattice(M)| is a saturated lattice (direct factor of $\Z^n$) }
set is_saturated (mat M) = bool:
   let (M,,pivots,)=echelon(M)
in set (M,):=ech_up(M,pivots); product(M.main_diagonal)=1

{ A function that avoids using |adapted_basis|, |diagonalize|, or other
  functions that may suffer severe coefficient growth; to be used in situations
  where only the (saturated) image subspace as a whole, and possibly a choice
  of a complementary subspace, are needed, not a special basis for the image

  Find dimension |c| of image, and a $\Z$-inverible matrix whose first |c|
  columns span saturation of the image; remaining ones span a chosen complement
}
set adapted_direct_sum (mat M) = (int,mat):
   let (M,,pivot,)=echelon(M) then (r,c)=shape(M), !M0=M
   then R=id_mat(r) { record row operations, held in inversed form }
in { now do coordinate change to make |M| upper triangular }
   for j:c { loop over columns of M while it is being modified in the loop }
   do let col=M[j], piv_j=pivot[j]+1 { only consider few rows now: |j:piv_j| }
   in if j<piv_j { avoid doing any work when our range is a single rows }
      then
         let (d,C)=Bezout(col[j:piv_j]), tM=^M
         then tM_C=tM[j:piv_j] * C, R_C = R[j:piv_j] * ^C.inverse
         { updated rows are now spliced into place in |M| and |R|: }
      in M := c^ for i:r do if i<j or i>pivot[j] then tM[i] else tM_C[i-j] fi od
      ;  R := r# for i:r do if i<j or i>pivot[j] then  R[i] else  R_C[i-j] fi od
      ; assert(M[j,j]=d)
      fi
   od; assert(R*M=M0); (c,R)

set image_subspace (mat M) = mat: { generators for $\Q$-span of image of |M| }
   let (c,R)=adapted_direct_sum(M) in R[:c]

set image_complement_basis (mat M) = mat:
   let (c,R)=adapted_direct_sum(M) in R[c:]

set saturation = image_subspace@mat { intersection of $\Z^n$ with $\Q$-span }

{ a basis representing the quotient by sublattice spanned by columns of |M|;
  tests that this sublattice is a direct factor, and throws an error if not }
set free_quotient_lattice_basis (mat M) = mat:
( let (E,,,)=echelon(M) in { pre-compute echelon }
  assert(E.is_saturated,"sublattice is not a direct factor")
; image_complement_basis(E)
)

{ a basis representing the quotient by saturation of sublattice, so no test }
set saturation_quotient_basis = image_complement_basis@mat


{ |M| is an $n\times k$ matrix; its columns span a submodule $W$ of $\Z^n$.
  Compute $n\times n$ matrix of projection onto the saturation (or $\Q$-span)
  of $W$, parallel to its complement from |adapted_sirect_sum(M)|.
}
set projector_to_image (mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in R[ : , :c] * R.inverse[ :c, : ]


{ complementary projector, to chosen complement to |image_subspace(M)| }
set projector_mod_image (mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in R[ : ,c: ] * R.inverse[c: , : ]

{ |M| is an $n\times k$ matrix; its columns span a submodule $W$ of $\Z^n$.
  A complement to |image_subspace(M)| is chosen by |adapted_direct_sum(M)|, and
  |decompose(M,w)=(u,v)| with |u| in |image_subspace(M)| and |v| in complement.
}
set decompose (mat M, vec v)= (vec,vec):
   let (c,R)=adapted_direct_sum(M) then R1=R.inverse
in (R[:,:c] * (R.inverse[:c,:] * v), R[:,c:] * (R.inverse[c:,:] * v) )

set decompose (mat M, ratvec w) = (ratvec,ratvec):
   let (v,d)=%w then (v1,v2)=decompose(M,v) in (v1/d,v2/d)


{ assuming M injective and Im(M) is A-stable, return unique B with A*M=M*B,
  which is action of A restricted to that sublattice $\Z^m$, embedded via M
}
set restrict_action (mat A, mat M) = mat: { shapes A: n by n, M: n by m }
   case solve(M,A*M) | some(B): B
   | else error("Image lattice M is not fixed by A")
   esac

{ assuming M full row rank and ker(M) is A-stable, find unique B with M*A=B*M }
set corestrict_action (mat M,mat A) = mat:  { shapes M: m by n, A: n by n }
   case solve(^M,^(M*A)) | some(tB): ^tB
   | else error("Kernel of M is not fixed by A")
   esac

{ |M| is an $n\times k$ matrix; its columns span a subspace $W$ of $\Q^n$.
  Assuming this subspace is |A|-stable, |A| induces an operator in $\Q^n/W$;
  return its matrix w.r.t the complement chosen by |adapted_direct_sum(M)|.
}
set quotient_matrix (mat A,mat M) = mat:
  let (c,R)=adapted_direct_sum(M) in (R.inverse[c: , : ]*A*R[ : ,c: ])

set solve_ratvec (mat A, vec v) = ratvec:
  (A,ratvec:v).solve.(rat_requisition("not in span"))

{ integer vector (lattice) solutions to linear system }


set in_lattice (mat A, ratvec u) = bool: { whether v in image lattice of A }
  let (b,n)=%u in n=1 and solve(A,b).any

set vec_solve (mat A, ratvec u) = Maybe<vec>: { integer solution to A*x=b }
  let (b,n)=%u in if n>1 then none() else solve(A,b) fi

{ express columns of M relative to basis A of a sub-lattice that contains them
  A: nxm matrix, columns are a basis of a Z-module V of rank m
  M: nxr matrix, columns span a submodule of V; returns mxr matrix C,
  column i gives column i of M as a sum of columns of A i.e., A*C=M
}
set in_lattice_basis (mat A,mat M) = mat:
  #A { size m of solutions } # for v in M do required_solution(A,v) od
