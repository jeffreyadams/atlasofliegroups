<W_reps.at
<coherent.at
<hodgeParamLaurentPol.at
<stable.at

set sign(Param p,Param q)=int:(-1)^(length(p)-length(q))

{W_graph@Param is built-in, returns (int,WGraph)
 here is just the W_graph, analogous to block_of@Param}
set W_graph_of(Param p)=let (,g)=W_graph(p) in g

{better implementation of coherent translation in basis of irreducibles
see coherent_irr(p) in coherent.at
}

set mu(WGraph graph,int i,int j)=
let (,g)=graph[i]  then
index=first(for (k,)@t in g do k=j od) in
if index=-1 then 0 else let (,mu)=g[index] in mu fi

set mu([Param] params,WGraph graph, Param p,Param q)=int:
mu(graph,find(params,p),find(params,q))

{matrix of T_alpha, given by graph, with q=1
 action is described in wgraphs.help
 however this matrix is the TRANSPOSE of the one given by graph_action@(WGraph,int) in
 in W_reps.at
 Also note: this is the coherent continuation action on the basis of {(-1)^length(p)*p}
 this function shouldn't be needed, but is included for instructional purposes;
 what we really use is graph_action_column
}
set graph_action (WGraph graph,int s) = sparse_mat:
let rv=sparse_mat:[] in
for node@i in graph do
 let col=sparse_column:[] in
 if is_member(node.tau)(s)
   then col#:=(i,1)
   else
   col#:=(i,-1);
   for j:#graph do
    if not j=i and  is_member(graph[j].tau)(s) then
     let mu=mu(graph,j,i) in
       if !=mu then col#:=(j,mu(graph,j,i)) fi
    fi
   od
 fi;
rv#:=col
od;rv

{column of matrix of action of T_s, coming from W-graph, with q=1
 This is the coherent continuation action in the basis of {(-1)^(length(p))p}
Example: big block of SL(2,R)
graph_action_column(graph,0,0)=[(0,-1),(2,1)]
graph_action_column(graph,1,0)=[(1,-1),(2,1)]
graph_action_column(graph,2,0)=[(2,1)]
graph_action(graph,0)= (list of these columns) -> matrix

-1 0  0
0 -1  0
1  1  1
see filtrations.pdf, end of section 1
}
set graph_action_column (WGraph graph,int col_number,int s) = sparse_column:
let rv=sparse_column:[] then
i=col_number then
node=graph[i] in
 let col=sparse_column:[] in
 if is_member(node.tau)(s)
   then col#:=(i,1)
   else
   col#:=(i,-1);
   for j:#graph do
    if not j=i and  is_member(graph[j].tau)(s) then
     let mu=mu(graph,j,i) in
       if !=mu then col#:=(j,mu(graph,j,i)) fi
    fi
   od
 fi;
col



{same as previous, except in the basis of irreducibles (rather than \pm irreducible)
 need the list of parameters just for the lengths
 this is precisely what is needed to compute coherent continuation in the basis of irreducibles
}
set graph_action_column ([Param] parameters,WGraph graph,int col_number,int s) = sparse_column:
let rv=sparse_column:[] then
i=col_number then
node=graph[i] in
 let col=sparse_column:[] in
 if is_member(node.tau)(s)
   then col#:=(i,1)
   else
   col#:=(i,-1);
   for j:#graph do
    if not j=i and  is_member(graph[j].tau)(s) then
     let mu=mu(graph,j,i) in
       if !=mu then col#:=(j,mu(graph,j,i)*sign(parameters[j],parameters[i])) fi
    fi
   od
 fi;
col



{just as graph_action was mainly for testing, this function
isn't essential but is a useful tool}
set graph_action ([Param] params,WGraph graph,int s) = sparse_mat:
let rv=sparse_mat:[] in
for node@i in graph do
 let col=sparse_column:[] in
 if is_member(node.tau)(s)
   then col#:=(i,1)
   else
   col#:=(i,-1);
   for j:#graph do
    if not j=i and  is_member(graph[j].tau)(s) then
     let mu=mu(graph,j,i) in
       if !=mu then col#:=(j,mu(graph,j,i)*sign(params[i],params[j])) fi
    fi
   od
 fi;
 rv#:=col
od;rv

{coherent continuation of irreducibles is defined using the W-graph,
keeping in mind the W-graph is the action in the basis of (-1)^length(p)p
}
set coherent_irr([Param] block,WGraph graph,Param p,int s)=ParamPol:
assert(is_regular(p),"infinitesimal character is not regular");
let index=find(block,p) in
null_module(p.real_form) +
for (index,coeff) in graph_action_column(block,graph,index,s) do
 (-1)*coeff*block[index] od

set coherent_irr ([Param] block,WGraph graph,ParamPol P,int s) = ParamPol:
  0*P + for coeff@p in P do  coeff*coherent_irr(block,graph,p,s) od
set coherent_irr ([Param] block,WGraph graph,Param p,[int] w) = ParamPol:
  let P=virtual(p) in for s in w do P:=coherent_irr(block,graph,P,s) od; P
set coherent_irr ([Param] block,WGraph graph,ParamPol P,[int] w) = ParamPol:
  for s in w do P:=coherent_irr(block,graph,P,s) od; P
set coherent_irr ([Param] block,WGraph graph,Param p,WeylElt w) = ParamPol:
 coherent_irr(block,graph,p,w.word)
set coherent_irr ([Param] block,WGraph graph,ParamPol P,[int] w) = ParamPol:
  for s in w do P:=coherent_irr(block,graph,P,s) od; P
set coherent_irr ([Param] block,WGraph graph,ParamPol P,WeylElt w) = ParamPol:
  coherent_irr(block,graph,P,w.word)

{replace coherent_irr(p,i) with coherent_irr(block_of(p),W_graph_of(p),p,s)}
set coherent_irr_new (Param p,int s)=ParamPol:coherent_irr(block_of(p),W_graph_of(p),p,s)
set coherent_irr_new (ParamPol P,int s) = ParamPol:coherent_irr(block_of(P.first_param),W_graph_of(P.first_param),P,s)
set coherent_irr_new (Param p,[int] w) = ParamPol:coherent_irr(block_of(p),W_graph_of(p),p,w)
set coherent_irr_new (ParamPol P,[int] w) = ParamPol:coherent_irr(block_of(P.first_param),W_graph_of(P.first_param),P,w)
set coherent_irr_new (Param p,WeylElt w) = ParamPol:coherent_irr(block_of(p),W_graph_of(p),p,w)
set coherent_irr_new (ParamPol P,WeylElt w) = ParamPol:coherent_irr(block_of(P.first_param),W_graph_of(P.first_param),P,w)


{-----------------------Hecke action-------------------}

{the action of \tilde T_alpha=v^{-1}(-T_alpha+v^2)
 see filtrations.pdf in Dropbox
\tilde T_alpha(J(delta))=(v+1/v)J + \sum J(delta') + \sum mu(gamma,delta)J(gamma)
}

{tT stands for \tilde T=v^{-1}(-T+v^2)
action of \tilde T_\alpha in basis of irreducibles}
set tT([Param] params,WGraph graph,Param p,int i {simple root})=hodgeParamLaurentPol:
if in_tau(i,p)
 then nullHodgeParamLaurentPol(p.real_form)
 else
 let rv=v_sum*p in
  for q in params do
   if (length(q)<length(p) or length(q)=length(p)+1) and in_tau(i,q) then
    rv+:=mu(params,graph,q,p)*hodge_param_laurent_pol(q)
   fi
  od;rv
 fi

{action of \tilde T_\alpha on hodgeParamLaurentPol}
set tT([Param] params,WGraph graph,hodgeParamLaurentPol hplp,int i)=
let r=rearrange(hplp) { f_0(v)p_0 + ... f_n(v)p_n} then
rv=nullHodgeParamLaurentPol(hplp.real_form) in
 for (f,p) in r do
 let x=f*tT(params,graph,p,i) in
  rv+:=f*tT(params,graph,p,i)
 od;
rv

{action of \tilde T_\alpha on hodgeParamPol}
set tT([Param] params,WGraph graph,hodgeParamPol hpp,int i)=hodgeParamLaurentPol:
tT(params,graph,hodge_param_laurent_pol(hpp),i)

{action Weyl group element [int] on hodgeParamLaurentPol}
set tT([Param] params,WGraph graph,hodgeParamLaurentPol hplp,[int] w)=hodgeParamLaurentPol:
for j in w ~ do hplp:=tT(params,graph,hplp,j) od;hplp

{action Weyl group element WeylElt on hodgeParamLaurentPol}
set tT([Param] params,WGraph graph,hodgeParamLaurentPol hplp,WeylElt w)=hodgeParamLaurentPol:
tT(params,graph,hplp,w.word)

{get ordinary T_alpha from tT=\tilde T: T=v\tilde T+v^2}
set T([Param] params,WGraph graph,Param p,int i)=hodgeParamLaurentPol:
(-1)*vee*tT(params,graph,p,i) + v_laurent_squared*hodge_param_laurent_pol(p)

{get ordinary T_alpha from tT=\tilde T: T=v\tilde T+v^2 acting on hodgeParamLaurentPol}
set T([Param] params,WGraph graph,hodgeParamLaurentPol hplp,int i)=hodgeParamLaurentPol:
(-1)*vee*tT(params,graph,hplp,i) + v_laurent_squared*hplp

{get ordinary T_alpha from tT=\tilde T: T=v\tilde T+v^2 acting on hodgeParamPol}
set T([Param] params,WGraph graph,hodgeParamPol hpp,int i)=hodgeParamLaurentPol:
T(params,graph,hodge_param_laurent_pol(hpp),i)

{get ordinary product of T_alpha's, given by [int]}
set T([Param] params,WGraph graph,hodgeParamLaurentPol hplp,[int] w)=hodgeParamLaurentPol:
for j in w ~ do hplp:=T(params,graph,hplp,j) od;hplp

{get ordinary product of T_alpha's, given by WeylElt}
set T([Param] params,WGraph graph,hodgeParamPol hpp,WeylElt w)=hodgeParamLaurentPol:
T(params,graph,hodge_param_laurent_pol(hpp),w.word)

{T^{-1}=v^{-2}T +(v^2-1)}
set T_inv([Param] params,WGraph graph,Param p,int i)=hodgeParamLaurentPol:
v_minus_two*T(params,graph,p,i)+(v_minus_two-1)*hodge_param_laurent_pol(p)

set T_inv([Param] params,WGraph graph,hodgeParamLaurentPol hplp,int i)=hodgeParamLaurentPol:
v_minus_two*T(params,graph,hplp,i)+(v_minus_two-1)*hplp

{S=-T: S at v=1 is coherent continuation, i.e.
S(b,g,p,i).v_to_1=coherent_irr(p,i)}
set S([Param] params,WGraph graph,Param p,int i)=hodgeParamLaurentPol:(-1)*T(params,graph,p,i)
set S([Param] params,WGraph graph,hodgeParamLaurentPol hplp,int i)=hodgeParamLaurentPol:(-1)*T(params,graph,hplp,i)
set S([Param] params,WGraph graph,hodgeParamPol hpp,int i)=hodgeParamLaurentPol:S(params,graph,hodge_param_laurent_pol(hpp),i)

set S([Param] params,WGraph graph, hodgeParamLaurentPol hplp,[int] w)=hodgeParamLaurentPol:
for j in w ~ do hplp:=S(params,graph,hplp,j) od;hplp

set S([Param] params,WGraph graph,Param p,[int] w)=hodgeParamLaurentPol:
S(params,graph,hodge_param_laurent_pol(p),w)

set S([Param] params,WGraph graph, hodgeParamLaurentPol hplp,WeylElt w)=hodgeParamLaurentPol:
S(params,graph,hplp,w.word)

set S([Param] params,WGraph graph, Param p,WeylElt w)=hodgeParamLaurentPol:
tT(params,graph,hodge_param_laurent_pol(p),w)

{S_inv=S^{-1}=(-T)^-1}
set S_inv([Param] params,WGraph graph,Param p,int i)=hodgeParamLaurentPol:(-1)*T_inv(params,graph,p,i)
set S_inv([Param] params,WGraph graph,hodgeParamLaurentPol hplp,int i)=hodgeParamLaurentPol:(-1)*T_inv(params,graph,hplp,i)
set S_inv([Param] params,WGraph graph,hodgeParamPol hpp,int i)=hodgeParamLaurentPol:S_inv(params,graph,hodge_param_laurent_pol(hpp),i)

set S_inv([Param] params,WGraph graph, hodgeParamLaurentPol hplp,[int] w)=hodgeParamLaurentPol:
for j in w ~ do hplp:=S_inv(params,graph,hplp,j) od;hplp

set S_inv([Param] params,WGraph graph,Param p,[int] w)=hodgeParamLaurentPol:
S_inv(params,graph,hodge_param_laurent_pol(p),w)

set S_inv([Param] params,WGraph graph, hodgeParamPol hpp,[int] w)=hodgeParamLaurentPol:
S_inv(params,graph,hodge_param_laurent_pol(hpp),w)

set S_inv([Param] params,WGraph graph, hodgeParamLaurentPol hplp,WeylElt w)=hodgeParamLaurentPol:
S_inv(params,graph,hplp,w.word)

set S_inv([Param] params,WGraph graph, Param p,WeylElt w)=hodgeParamLaurentPol:
tT(params,graph,hodge_param_laurent_pol(p),w.word)

set S_inv([Param] params,WGraph graph, hodgeParamPol hpp,WeylElt w)=hodgeParamLaurentPol:
S_inv(params,graph,hodge_param_laurent_pol(hpp),w)

{hodgeParamPol giving grading on standard module}
set graded_standard(Param std)=hodgeParamLaurentPol:
let b=block_of(std) then
Q=KL_Q_polynomials(std) then
rv=nullHodgeParamLaurentPol(std.real_form) in
for irr in b do
 let f=KL_Q_polynomial(b,Q,irr,std) in
  if sum(f).> then let
     f1=poly_as_laurent_poly(f.at_v_squared)*v_laurent_power(length(irr)-length(std))  then
     f2=hodge_param_laurent_pol(irr)
     in rv+:=f1*f2
     fi
 od;
rv

set reverse(hodgeParamLaurentPol hplp)=ParamPol: character_formula(hplp.v_to_1)

set quad_test([Param] params,WGraph graph,hodgeParamLaurentPol hplp,int i)=
let tp=tT(params,graph,hplp,i) then
x=tT(params,graph,tp,i) then
y=tT(params,graph,x,i) in
(x,y,v_sum*x=y)

set quad_test([Param] params,WGraph graph,Param p,int i)=
quad_test(params,graph,hodge_param_laurent_pol(p),i)

set quad_test([Param] params,WGraph graph,[Param] list,int i)=
for p in list do let (,,z)=quad_test(params,graph,p,i) in z od


{
cross(p)=q^{-1/2}(tTp-q^{-1/2}
         =v^{-1}(tTp)-v^{-2}p
}
set cross([Param] params,WGraph graph,  hodgeParamLaurentPol hplp,int i)=
v_inverse*tT(params,graph,hplp,i)-v_minus_two*hplp

set cross([Param] params,WGraph graph, hodgeParamPol hpp,int i)=
cross(params,graph,hodge_param_laurent_pol(hpp),i)

set cross([Param] params,WGraph graph,  ParamPol P,int i)=
cross(params,graph,hodge_param_laurent_pol(P),i)

set cross([Param] params,WGraph graph, Param p,int i)=
cross(params,graph,hodge_param_laurent_pol(p),i)

set cross([Param] params,WGraph graph,hodgeParamLaurentPol hplp,[int] w)=
for j in w ~ do hplp:=cross(params,graph,hplp,j) od;hplp

set cross([Param] params,WGraph graph,hodgeParamPol hpp,[int] w)=
cross(params,graph,hodge_param_laurent_pol(hpp),w)

set cross([Param] params,WGraph graph,ParamPol P,[int] w)=
cross(params,graph,hodge_param_laurent_pol(P),w)

set cross([Param] params,WGraph graph,Param p,[int] w)=
cross(params,graph,hodge_param_laurent_pol(p),w)

set icross([Param] params,WGraph graph,hodgeParamLaurentPol hplp,int i)=
vee*tT(params,graph,hplp,i)-v_laurent_power(2)*hplp

set cross([Param] params,WGraph graph,hodgeParamPol hpp,int i)=hodgeParamLaurentPol:
cross(params,graph,hodge_param_laurent_pol(hpp),i)

set cross_graded([Param] params,WGraph graph,Param p,int i)=
cross(params,graph,graded_standard(p),i)

set cross_graded([Param] params,WGraph graph,Param p,[int] w)=
cross(params,graph,graded_standard(p),w)

set icross([Param] params,WGraph graph, hodgeParamPol hpp,int i)=hodgeParamLaurentPol:
icross(params,graph,hodge_param_laurent_pol(hpp),i)

set icross([Param] params,WGraph graph, Param p,int i)=
icross(params,graph,hodge_param_laurent_pol(p),i)

set icross_graded([Param] params,WGraph graph, Param p,int i)=
icross(params,graph,graded_standard(p),i)

set cross_square([Param] params,WGraph graph, hodgeParamLaurentPol hplp,int i)=
icross(params,graph,cross(params,graph,hplp,i),i)

set cross_square([Param] params,WGraph graph, hodgeParamPol hpp,int i)=
cross_square(params,graph,hodge_param_laurent_pol(hpp),i)

set cross_square([Param] params,WGraph graph, Param p,int i)=
cross_square(params,graph,hodge_param_laurent_pol(p),i)

set cross_square([Param] params,WGraph graph, ParamPol P,int i)=
cross_square(params,graph,hodge_param_laurent_pol(P),i)

set cross_square_test([Param] params,WGraph graph, ParamPol P,int i)=bool:
cross_square(params,graph,P,i)=hodge_param_laurent_pol(P)

set cross_square_test([Param] params,WGraph graph, Param p,int i)=bool:
cross_square(params,graph,p,i)=hodge_param_laurent_pol(p)

{moved from induction.at to avoid circularity issue}

set theta_induce_irreducible_new (Param p, RealForm G)=ParamPol:
    let rd=root_datum(G), N=find_N (p,G), rhou=rho(G)-rho(real_form(p))
    then q=translate_by (p,ratvec_as_vec(N*2*rho(G))).monomials[0]
    then ind=parameter(embed_KGB(x(q),G),lambda(q)+rhou,nu(q))
    then ic=dominant(rd,infinitesimal_character(p)+rhou)
    then (,w)=conjugate_to(rd,ic,infinitesimal_character(p)+rhou)
    then P=coherent_irr_new(ind,word(inverse(w)))  {note new here}
    then result=null_module(G) in
       for coeff@q in P do result+:=coeff*T_irr(q,ic) od;
    result


{ in singular case,
  move to regular infinitesimal character, apply w, and move back
  Dangerous Bend (example):

  atlas> set G=Sp(6,R)
  atlas> set p=parameter(KGB(G,3),[3,2,2],[0,0,0])
  Value: zero parameter (x=3,lambda=[3,2,2]/1,nu=[0,0,0]/1)

  the root e2-e3 is compact, so this limit of DS is zero
  however its coherent continuation is not zero

  atlas> coherent_std(0,p)
  Value:
  -1*final parameter (x=4,lambda=[3,2,2]/1,nu=[0,0,0]/1)
  1*final parameter (x=9,lambda=[3,2,2]/1,nu=[1,-1,0]/2)
}

{ action of simple root on parameter, basis of standards }
{need to provide block and graph at regular infinitesimal character }
{
set coherent_irr ([Param] block_reg,WGraph graph_reg,Param p,int s) = ParamPol:
  if is_regular(p) then
    let block_gamma=for q in block_reg do first_param(T_irr(q,p.infinitesimal_character)) od in
    coherent_irr_reg(block_gamma,graph,p,s)
  else
    let gamma=infinitesimal_character(p)
    then p_reg=T(p,gamma+rho(real_form(p))) then
    block_gamma=for q in block_reg do first_param(T_irr(q,p.infinitesimal_character)) od
    in T(coherent_irr_reg(block_gamma,graph,p_reg,s),gamma)
  fi
  }


{use: set (b,g,gs,w)=h_init(G)
then
show(S_inv(b,g,w,gs)
}
set h_init(RealForm G)=
let p=G.trivial then
b=block_of(p) then
g=W_graph_of(p) then
gs=graded_standard(p) then
w=G.w0.word then
p=G.trivial
in
(G,p,b,g,gs,w)