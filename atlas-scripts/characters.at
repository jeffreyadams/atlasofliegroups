{ This contents of this file has been incoprorated into W_classes.at and
  the file will therefore disappear from Atlas soon

  The interface has changed as follows:

  Rather than having variants of functions that generate the conjugacy classes
  of W and their sizes, or use such values if passed as arguments, all
  functions in W_classes assume this done during construction of a
  |WeylClassTable| value. Some functions are in fact part of such a value,
  others are produced by functions taking a |WeylClassTable| as argument; the
  calling syntax is the same in foth cases: |ct.function(arguments)| where |ct|
  holds the |WeylClassTable| value.
  The function names are as follows (with |ct| as above referring to the table)

  operator * -> |ct.inner|
  |trivial_character| -> |ct.trivial|
  |sgn_character| -> |ct.sign|
  |reflection_character| -> |ct.reflection|
  |tensor| -> |ct.tensor_power|
  |dimension| -> |ct.dimension|
}

<basic.at
<Weylgroup.at { for |order_W@RootDatum| }
<W_classes.at { for |conjugacy_class_reps| }

{. data type for class functions .}
set_type ClassInfo = (WeylElt rep, int size)
set_type ClassDatum = (ClassInfo ci, int value)
set_type ClassFunction = [ClassDatum]

{. inner product of two class functions .}
set * (ClassFunction f,ClassFunction g) = int:
   assert(#f=#g and f[0].ci.rep=g[0].ci.rep and f~[0].ci.size=g~[0].ci.size);
   let denom = f[0].ci.rep.root_datum.order_W
   then (q,r) =
     for (ci,val)@i in f do ci.size*val*g[i].value od.sum \% denom
in assert(r=0,
     @:"Divisibility failure in character inner product "+q*denom+r+"/"+denom
   ); q

set classes_info (RootDatum rd) = [ClassInfo]:
   for w in conjugacy_class_reps(rd) do (w,size_of_conjugacy_class(w)) od

{. character of the trivial representation of W: assuming classes and sizes already defined .}
set trivial_character ([ClassInfo] cis) = ClassFunction:
   for ci in cis do (ci,1) od
{. character of the trivial representation of W .}
set trivial_character (RootDatum rd) = ClassFunction:
   rd.classes_info.trivial_character


{. character of the sgn representation of W: assuming classes and sizes already defined .}
set sign_character ([ClassInfo] cis) = ClassFunction:
   for ci in cis do (ci,ci.rep.matrix.det) od

{.character of the sgn representation of W .}
set sign_character (RootDatum rd) = ClassFunction:
   rd.classes_info.sign_character


{. character of the reflection (tautological) representation of W, classes and sizes already defined .}
set reflection_character ([ClassInfo] cis) = ClassFunction:
   for ci in cis do (ci,ci.rep.matrix.trace) od

{. character of the reflection (tautological) representation of W .}
{.character of the sgn representation of W .}
set reflection_character (RootDatum rd) = ClassFunction:
  rd.classes_info.reflection_character

{. character of n^th tensor power of a class function .}
set tensor (int n, ClassFunction f) = ClassFunction:
  for (ci,val) in f do (ci,val^n) od

set dimension(ClassFunction f) = int: f[0].value

set matrix_of_inner_products ([ClassFunction] S) = mat:
  for Sj in S do for Si in S do Si*Sj od od
