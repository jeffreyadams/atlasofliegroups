<all.at
<Kcone.at

set add_ht (RealForm G)=int:
   let rc=rho_check(G), rk=rho_c(G) in ceil(4*rc*rk)

set zeros (int n) = vec: for i:n do 0 od

set sets_of_card_n ([[int]] ps, int n)=[[int]]:
   ##for ints in ps do if #ints=n then [ints] else [] fi od

set dim_T_x (KGBElt x) = int:
   let ((c,C,r),,,)=x.Cartan_class.Cartan_info in C+c

set kwts(KGBElt x) = [vec]:
    let (G,posRoots,inv) = (x.real_form,posroots(x.real_form),x.involution)
    in ##for i:#posRoots do if is_imaginary(i,x)
       	     		    then if is_compact(i,x)
			          then [posRoots[i],-posRoots[i]]
				  else []
				  fi
			    else if (find(posRoots,inv*posRoots[i]) > i
			            or find(posRoots,-inv*posRoots[i]) > i)
				 then [posRoots[i],-posRoots[i]]
				 else if is_real(i,x)
			              then [posRoots[i]]
				      else []
				      fi
			     fi fi
			 od

set kwts(RealForm G) = [[vec]]:
   let zero=zeros(rank(G)) in
   for x in KGB(G)
    do let CSA=for i:dim_T_x(x)
               do zero
	       od
	in CSA##kwts(x)
    od

set wedge_weights ([[vec]] wts, [[int]] ps, int n) =[[vec]]:
   let list=sets_of_card_n(ps,n)
   in for xwts in wts
      do for subset in list
         do sum(for i in subset do xwts[i] od)
	 od
      od

set add_weights (Param p, [[vec]] wts) = ParamPol:
    let (G,j)= %p.x, lambda=p.lambda, x=p.x
    in sum(G,for v in wts[j] do
    standardize(parameter(x,lambda+v,0*lambda))*0 od)

set add_weights (ParamPol P,[[vec]] wts)= ParamPol:
   sum(real_form(P),for c@p in P do c*add_weights(p,wts) od)

set tensor_with_Wedge_k (K_Type mu,[[int]] ps,int n)=ParamPol:
   let G=real_form(mu), P=K_type_formula(mu)
    then wts=kwts(G)
    then bd=height_bound(wts,G)
    then Q= add_weights (P,wedge_weights(wts,ps,n))
    in branch_std(Q,hb)


set first_step (RealForm G, vec chi, int hb) = [[(Split,KHighestWeight)]]:
   let GC=complexification(G),r=rank(G)
   then p=parameter_m(GC,chi,zeros(r)/1)
   then (list,)= hodge_branch_std(p,hb)
   then hwts= for P in list
        do for c@q in P do (c,highest_weight(LKT(q)))
	                od
	od
    in hwts

set fold (vec long)= vec:
   let n=rat_as_int(#long/2)
    in for i:n do long[i]+long[i+n] od

set second_step ([[(Split,KHighestWeight)]] list)=[[(Split,vec)]]:
   for level in list
    do for (n,(,y,lam)) in level
        do (n,fold(lam))
	od
    od

set third_step (RealForm G,[[(Split,vec)]] list)=[ParamPol]:
   for level in list
    do sum(G, for (n,v) in level
       do let p =parameter(x_open(G),v+rho(G),v+rho(G))
          in n*branch_irr(p, height(K_Type:(KGB(G,0),v)))
       od)
    od

set steps_one_two_three (RealForm G,vec chi)=[ParamPol]:
   let list1=first_step(G,chi)
   then list2=second_step(list1)
   in third_step(G,list2)

set step_fourA (RealForm G,[ParamPol] list) = [ParamPol]:
   for level in list
    do sum(G,for c@p in level do c*K_type_formula(p) od)
    od


set last_step ([ParamPol] start,int kdim,RealForm G,int hb)=[ParamPol]:
   let wts=kwts(G), ps=power_set(kdim), ah=add_ht(G)
   then add_on=[ParamPol]:for i:kdim do 1*null_module(G) od
   then result=start##add_on
   in for i:kdim from 1
        do let ww=wedge_weights(wts,ps,i)
	   in for j:#start
	      do result[j+i]+:=(-1)^i*add_weights(start[j],ww)
	      od
	od;
    for P in result do branch_std(P,hb+ah) od

set Lucas_algorithm (RealForm G, vec chi, int hb) = [ParamPol]:
   let kdim=dimension(K_0(G)), list1=first_step(G,chi,hb)
   then list2=second_step(list1)
   then list3=third_step(G,list2)
   then start= step_fourA (G,list3)
   in last_step(start,kdim,G,hb)