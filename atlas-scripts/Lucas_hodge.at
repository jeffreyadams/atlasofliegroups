<hodge_K_type_formula.at
<Kcone.at
<complex.at

{Height of an arbitrary weight}
set ht_of_wt(RootDatum rd,ratvec alpha)=int:
   abs(rat_as_int(2*rho_check(rd)*alpha))

set ht_of_ratwt(RootDatum rd,ratvec v)=rat:
    abs(2*rho_check(rd)*v)

{All KGB elements attached to the fundamental Cartan}
set fundamental_fiber (RealForm G)=[KGBElt]:
   ##for x in KGB(G) do if Cartan_class(x)=Cartan_class(KGB(G,0))
                        then [x] else [] fi
		     od

set pos_nc_roots (KGBElt x)=[vec]:
   let pr=posroots(real_form(x))
   in ##for alpha in pr
        do if is_noncompact_imaginary(alpha,x) then [alpha] else []
	   fi
	od

{minimal height of noncompact roots}
set min_nc (RealForm G)=int:
   min(##for x in fundamental_fiber(G)
         do for a in pos_nc_roots(x)
	     do height(G,a) od od)

{maximal height of noncompact roots}
set max_nc (RealForm G)=int:
   max(##for x in fundamental_fiber(G)
         do for a in pos_nc_roots(x)
	     do height(G,a) od od)

{maximal height difference between a K-type and its highest weight}
set ht_shift (RealForm G)=int:
   let rd=root_datum(G)
   in max(for x in distinguished_fiber(G)
        do ht_of_wt(rd,2*rho_c(x)-rho(G)) od)

{maximal hight difference between K-type and its tensor product with
 wedge(k)}
set add_ht (RealForm G)=int:
   let rc=rho_check(G), rk=rho_c(G) in ceil(4*rc*rk)

set zeros (int n) = vec: for i:n do 0 od

set sets_of_card_n ([[int]] ps, int n)=[[int]]:
   ##for ints in ps do if #ints=n then [ints] else [] fi od

set dim_T_x (KGBElt x) = int:
   let ((c,C,r),,,)=x.Cartan_class.Cartan_info in C+c

{weights of k}
set kwts(KGBElt x) = [vec]:
    let (G,posRoots,inv) = (x.real_form,posroots(x.real_form),x.involution)
    in ##for i:#posRoots do if is_imaginary(i,x)
       	     		    then if is_compact(i,x)
			          then [posRoots[i],-posRoots[i]]
				  else []
				  fi
			    else if (find(posRoots,inv*posRoots[i]) > i
			            or find(posRoots,-inv*posRoots[i]) > i)
				 then [posRoots[i],-posRoots[i]]
				 else if is_real(i,x)
			              then [posRoots[i]]
				      else []
				      fi
			     fi fi
			 od

{weights of k; one list for each KGB element; an empty list if x has C- roots}
set kwts(RealForm G) = [[vec]]:
   let zero=zeros(rank(G)) in
   for x in KGB(G)
    do if no_Cminus_roots(x)
       then let CSA=for i:dim_T_x(x)
                    do zero
	            od
	     in CSA##kwts(x)
	else []
	fi
    od

{Weights occurring in wedge(k)^n; an empty list for x with C- roots}
set wedge_weights ([[vec]] wts, [[int]] ps, int n) =[[vec]]:
   let list=sets_of_card_n(ps,n)
   in for xwts in wts
      do if #xwts = 0
         then []
	 else for subset in list
              do sum(for i in subset do xwts[i] od)
	      od
         fi
      od

set add_weights (Param p, [[vec]] wts) = ParamPol:
    let (G,j)= %p.x, lambda=p.lambda, x=p.x
    in sum(G,for v in wts[j] do
    standardize(parameter(x,lambda+v,0*lambda))*0 od)

set add_weights (ParamPol P,[[vec]] wts)= ParamPol:
   sum(real_form(P),for c@p in P do c*add_weights(p,wts) od)

set tensor_with_Wedge_k (K_Type mu,[[int]] ps,int n)=ParamPol:
   let G=real_form(mu), P=K_type_formula(mu)
    then wts=kwts(G)
    then Q= add_weights (P,wedge_weights(wts,ps,n))
    in branch_std(Q,height(mu)+add_ht(G))

{Form parameter of complexification of G with lambda=chi, compute hodge
 filtration and list highest weights}
set first_step (RealForm G, vec chi, int hb) = [[(Split,KHighestWeight)]]:
   let GC=complexification(G),r=rank(G)
   then p=parameter_m(GC,chi,zeros(r)/1)
   then (list,)= hodge_branch_std(p,hb)
   then hwts= for P in list
        do for c@q in P do {prints(height(q));}(c,highest_weight(LKT(q)))
	                od
	od
    in hwts

set fold (vec long)= vec:
   let n=rat_as_int(#long/2)
    in for i:n do long[i]+long[i+n] od

{Turn highest weights for complexification (in previous step) into highest
weights for G}
set second_step ([[(Split,KHighestWeight)]] list)=[[(Split,vec)]]:
   for level in list
    do for (n,(,y,lam)) in level
        do (n,fold(lam))
	od
    od

{Restrict finite dimensionals with highest weights computed in second step
to K; with hodge degrees and split coefficients carried forward from
step 1, this gives a KHodgeParamPol}
set third_step (RealForm G,[[(Split,vec)]] list)=[ParamPol]:
   for level in list
    do sum(G, for (n,v) in level
       do let p =parameter(x_open(G),v+rho(G),v+rho(G))
          in n*branch_irr(p, height(K_Type:(KGB(G,0),v)))
       od)
    od

set third_step_test (RealForm G,[[(Split,vec)]] list,int bd)=[ParamPol]:
   for level in list
    do sum(G, for (n,v) in level
       do let p =parameter(x_open(G),v+rho(G),v+rho(G))
          in n*branch_irr(p,bd)
       od)
    od

set steps_one_two_three (RealForm G,vec chi,int hb)=[ParamPol]:
   let list1=first_step(G,chi,hb)
   then list2=second_step(list1)
   in third_step(G,list2)

set steps_one_two_three_test (RealForm G,vec chi,int hb,int n3)=[ParamPol]:
   let list1=first_step(G,chi,hb)
   then list2=second_step(list1)
   in third_step_test(G,list2,n3)

{Replace K-types in output of step 3 by their K-type formulas}
set step_fourA (RealForm G,[ParamPol] list) = [ParamPol]:
   for level in list
    do sum(G,for c@p in level do c*K_type_formula(p) od)
    od


set last_step_old ([ParamPol] start,int kdim,RealForm G,int hb)=[ParamPol]:
   let wts=kwts(G), ps=power_set(kdim), ah=add_ht(G)
   then add_on=[ParamPol]:for i:kdim do 1*null_module(G) od
   then result=start##add_on
   in for i:kdim from 1
        do let ww=wedge_weights(wts,ps,i)
	   in for j:#start
	      do result[j+i]+:=(-1)^i*add_weights(start[j],ww)
	      od
	od;
    for P in result do branch_std(P,hb+ah) od

{For each external power i, add (-1)^i*the appropriate weights to each parameter
and move the result up by i degrees; then do branch_std to convert back to K-types}
set last_step ([ParamPol] start,int kdim,RealForm G,int hb)=[ParamPol]:
   let n=#start,  wts=kwts(G), ps=power_set(kdim)
   then result=start
   in for i:kdim from 1
        do let ww=wedge_weights(wts,ps,i)
	   in for j:n-i
	      do result[j+i]+:=(-1)^i*add_weights(start[j],ww)
	      od
	od;
    for P in result do branch_std(P,hb) od

set Lucas_algorithm (RealForm G, vec chi, int hb) = [ParamPol]:
   let kdim=dimension(K_0(G)), ah=add_ht(G), M=max_nc(G), m=min_nc(G)
   then d=floor((hb+ht_shift(G))/(2*m))
   then bd=2*M*d
   then list1=first_step(G,chi,bd+ah)
   then list2=second_step(list1)
   then list3=third_step(G,list2)
   then start= step_fourA (G,list3)
   then last=last_step(start,kdim,G,hb+ah)
   in for i:d+1 do to_ht(hb)(last[i]) od

set Lucas_algorithm_old (RealForm G, vec chi, int hb) = [ParamPol]:
   let kdim=dimension(K_0(G)),  ah=add_ht(G)
   then list1=first_step(G,chi,hb+ah)
   then list2=second_step(list1)
   then list3=third_step(G,list2)
   then start= step_fourA (G,list3)
   in last_step_old(start,kdim,G,hb)

set test_hodge_heights (RealForm G, vec v, int n) = void:
   let list=Lucas_algorithm_old(G,v,n) then p=#list
   then pos_levels=int: let i=0 in while i<p and all(for c@q in list[i]
			             do int_part(c)>0 od)
			     do i+:=1 od; i
      then terms=[(int,int,int)]:
      for i:pos_levels
      do (sum(for c@q in list[i] do int_part(c) od),
          max(for c@q in list[i] do height(q) od),
	  min(for c@q in list[i] do height(q) od))
      od
   in prints(n," no levels: ",p,"    no pos levels: ", pos_levels,new_line,
             "no terms and max/min height: ", terms)

set test_heights(RealForm G, vec v, int d, int ht, int hb)=[ParamPol]:
   for i:d do to_ht(ht)(Lucas_algorithm(G,v,hb)[i]) od