<L_packet.at
<hodgeParamLaurentPol.at
<stable.at
<extParamPol.at

set te_verbose=true

{very preliminary version of twisted endoscopic lifting
given: (G,delta^v)
G=(split) real group
delta^v=distinguished involution of G^v
H^v=identity component of (G^v)^delta
H = dual group of H.split_form
  = endoscopic group for G
[Of course G shouldn't have to be split, and then H
will be the appropriate quasisplit form of H]

endoscopic(G,delta^v) returns (H,M)
H is complex (you should take its split_form)
and M is a matrix relating T_H and T_G

At the moment this has been designed for G=GL(n,R)
it probably doesn't work in other cases: the embed_KGB
function is clumsy

also inverse_lift_std is now done by a brute force search,
until we figure out the right way
}
{<mezo.at}

{from mezo.at:}
set delta_l_int_long(Param p,mat delta)=(int,int,int,rat):
if not is_fixed(delta,p) then (-1,-1,-1,-1) else
let rd=p.root_datum then
G=p.real_form then
ic=inner_class(rd,delta) then
rd_H_check=K_0(ic.quasicompact_form).root_datum then
rd_H=dual(rd_H_check) then
H=rd_H.split_form then
x_G=KGB(G,0) then
{proj_H=cocharacter_lattice_K(ic) then}
proj_H=projection_to_K_matrix(x_G) then
G=p.real_form then
gamma=p.infinitesimal_character then
gamma_H=proj_H*gamma then
theta=p.x.involution then
theta_H=proj_H*theta*right_inverse(proj_H) then
compact_rank_H=#kernel(theta_H-1) then
constant=split_rank(H.fundamental_Cartan) then
roots=##for alpha in rd_H.posroots do
 if is_positive_root(rd_H,theta_H*alpha) then [alpha] else [] fi od
in (#roots,compact_rank_H,constant, (#roots+compact_rank_H-constant)/2)
fi

set delta_l_int(Param p,mat delta)=int:
let (,,,x)=delta_l_int_long(p,delta) in rat_as_int(x)

{this should be a built-in, or at least in some other file}
{set partial_extended_block(Param p,mat delta)=[Param]:
let (B,,)=partial_extended_KL_block(p,delta) in B}

set is_stable(ParamPol P)=bool:
let (M,)=stable(monomials(P)) then
v=[int]: for (c,p) in %P do c.split_as_int od in
in_lattice(^M,v)
{
set partial_KL_P_polynomials (Param p, mat delta) = i_poly_mat:
   let (,P,polys) = partial_extended_KL_block(p,delta)
in for row in rows(P) { mat to i_pol_mat convention flip }
   do for index in row do if index.< then -polys[-index] else polys[index] fi od
   od
   }
{
set partial_fixed_block_of(mat delta,Param p)=
##for a in partial_block(p) do if is_fixed(delta,a) then [a] else [] fi od
}

set big_KL_P_polynomials(Param p,mat delta) = i_poly_mat:
{  let B=partial_fixed_block_of(delta,p) in}
  let (B,,)=partial_extended_KL_block(p,delta) in

  let (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta)
  then B_delta = for i in I_delta do B[i] od
  , P=KL_P_polynomials(p)
  then P_delta=KL_P_polynomials(p,delta)
  in
  if =#P_delta
  then prints("Note: block not delta-fixed")
  ; KL_P_polynomials(B) {block is not fixed by delta}
  else let n=#complete_indices then rv=zero_poly_matrix(n) in
     for a:n
     do let (i,epsilon_i)=complete_indices[a] in
        for b:n-a from a
        do let (j,epsilon_j)=complete_indices[b] in
{ prints("a=",a," b=",b," i=",i," e_i=",epsilon_i," j=",j," e_j=",epsilon_j); }
           if a=b
           then  rv:=update_matrix_entry(rv,a,b,one) {diagonal entries}
           elif (epsilon_i*epsilon_j=1) { entries have same sign: P+P^delta}
           then let x=g[i], y=g[j] in
{ prints("P[i][j]=",P[i][j]," x=",x," y=",y," , Pdelta[x][y]=",P_delta[x][y]); }
	     rv:=update_matrix_entry(rv,a,b,poly_add(P[i][j],P_delta[x][y])\2)
	   elif epsilon_i*epsilon_j=minus_1
	   then {(+,-) or (-,+): P-P^delta} let x=g[i], y=g[j] in
	     rv:=update_matrix_entry(rv,a,b,poly_sub(P[i][j],P_delta[x][y])\2)
	   elif abs(epsilon_i)=1 and epsilon_j=0 {(\pm,ind): P}
	   then rv:=update_matrix_entry(rv,a,b,P[i][j])
	   elif epsilon_i=0 and abs(epsilon_j)=1  {(ind,\pm): P}
	   then rv:=update_matrix_entry(rv,a,b,P[i][j])
	   elif epsilon_i=0 and epsilon_j=0
	   then {(ind,ind): P(gamma,mu)+P(gamma,mu^delta)}
	     rv:=update_matrix_entry
		 (rv,a,b,poly_add(P[i][j],P[i][delta_action[j]]))
           fi
        od
     od
  ; rv
  fi

set big_KL_P_signed_polynomials (Param p,mat delta) = i_poly_mat:
{  let B=partial_fixed_block_of(delta,p) in}
  let (B,,)=partial_extended_KL_block(p,delta) in
  let (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta) in
  if =#I_delta then KL_P_signed_polynomials(B)
  else
     let P=big_KL_P_signed_polynomials(B,delta)
     , lengths = for i:#g do length(B[i]) od
     , n=#complete_indices
     in
     for a:n do for b:n
     do let (i,)=complete_indices[a], (j,)=complete_indices[b] in
        P:=update_matrix_entry(P,a,b,P[a][b]*minus_1^(lengths[i]+lengths[j]))
     od od
  ; P
  fi

set twisted_root_datum(RootDatum G,mat T)=TwistedRootDatum:(G,T)

set pre_folded(TwistedRootDatum (rd,delta))=(mat,mat):
assert(is_distinguished(rd,delta),"delta is not distinguished");
let T=SubTorus:eigen_lattice(^delta,1) then   {T=(H^\delta)^0; columns are a basis of X_*(T)}
{T is nxr where n=rd.rank and r=dimension(T)}
{ T: matrix of map X_*(T)->X_*(H) \simeq Z^r -> Z^n: this is T.inject
 ^T: matrix of map X^*(H)->X^*(T) \simeq Z^n->Z^r:   this is T.project=T.restrict
}
roots_nonreduced=sort_u(for alpha in rd.posroots do T.restrict(alpha) od) then
roots=mat:##(for alpha in roots_nonreduced do if find(roots_nonreduced,2*alpha)=-1 then [alpha] else [] fi od) then
coroots=[] in
for alpha in roots do
 let pullback_alpha=let j=first(for beta in rd.roots do T.restrict(beta)=alpha od) in rd.roots[j] then
 v=sum(##(for beta in rd.roots do if T.restrict(beta)=alpha then  [coroot(rd,beta)]
   else []
  fi od)) then
 w=2*v/(v*pullback_alpha) {element of X_*(H) which lives in X_*(T)} then
 corestrict_w=solve(T,w).requisition {coordinates of w in the given basis of X_*(T)} in
 coroots#:=ratvec_as_vec(corestrict_w)
od;(roots,coroots)

set Folded(TwistedRootDatum (G,delta))=(RootDatum,mat):
{assert(G.is_semisimple or delta=id_mat(#delta),"root datum is not semisimple and delta !=1");}
assert(is_distinguished(G,delta),"delta is not distinguished");
let T_H=SubTorus:eigen_lattice(^delta,1) then   {T_H=(T^\delta)^0; columns are a basis of X_*(T_H)}
{T_H is nxr where n=dim(T_G) and r=dim(T_H)}
{ T_H: matrix of map X_*(T_H)->X_*(T_G) \simeq Z^r -> Z^n: this is T_H.inject
 ^T_H: matrix of map X^*(T_G)->X^*(T_H) \simeq Z^n->Z^r:   this is T_H.project=T_H.restrict
}
roots_nonreduced=sort_u(for alpha in G.posroots do T_H.restrict(alpha) od) then
{roots=mat:##(for alpha in roots_nonreduced do if find(roots_nonreduced,2*alpha)=-1 then [alpha] else [] fi od) then}
roots=mat:##(for alpha in roots_nonreduced do if find(2*roots_nonreduced,alpha)=-1 then [alpha] else [] fi od) then
coroots=[] in
for alpha in roots do
 let pullback_alpha=let j=first(for beta in G.roots do T_H.restrict(beta)=alpha od) in G.roots[j] then
 v=sum(##(for beta in G.roots do if T_H.restrict(beta)=alpha then  [coroot(G,beta)]
   else []
  fi od)) then
 w=2*v/(v*pullback_alpha) {element of X_*(H) which lives in X_*(T_H)} then
 corestrict_w=solve(T_H,w).requisition {cooGinates of w in the given basis of X_*(T_H)} in
 coroots#:=ratvec_as_vec(corestrict_w)
od;
(root_datum_from_positive((roots,coroots),G.prefers_coroots),T_H)
set Folded(RootDatum rd, mat delta)=(RootDatum,mat):Folded(twisted_root_datum(rd,delta))


{endoscopic(G,delta): this returns: (RootDatum H,mat M) where
 Gd=G.dual, T_Gd=Cartan of Gd
 Hd=identity component of Gd^{delta^t}
 T_Hd=Cartan of Gd= identity component of (T_Gd)^{delta^t}
 H=Hd.dual = (twisted) endoscopic group of G

M:  X^*(T_H) -> X^*(T_G)  OR X_*(T_{Hd}) -> X_*(T_{Gd})
^M: X_*(T_G) -> X_*(T_H)  OR X^*(T_{Gd}) -> X^*(T_{Hd})

 left multiplication by M: H.simple_roots -> root_lattice of G
 left multiplication by ^M: G.simple_coroots -> coroot_lattice of H
 }
set endoscopic(RootDatum G,mat delta)=(RootDatum,mat):
let Gd=G.dual then
trd=twisted_root_datum(Gd,^delta) then
(Hd,M)=Folded(Gd,^delta) then
H=Hd.dual in
(H,M)

{atlas> set G=GL(5,R)
Variable G: RealForm (overriding previous instance, which had type RealForm)
atlas> set delta=G.distinguished_involution
Variable delta: mat (overriding previous instance, which had type mat)
atlas> set (H,M)=endoscopic (G,delta)
Variable H: RootDatum (overriding previous instance, which had type RootDatum)
Variable M: mat
atlas> H
Value: adjoint root datum of Lie type 'B2'
atlas> M*H.simple_coroots
Value:
|  1,  0 |
| -1,  2 |
|  0,  0 |
|  1, -2 |
| -1,  0 |

atlas> M*H.simple_roots
Value:
|  1,  0 |
| -1,  1 |
|  0,  0 |
|  1, -1 |
| -1,  0 |
{THIS SAYS:  M: X_*(T_Hd) -> X_*(T_Gd);  Hd.simple_coroots -> (sums of) Gd.simple_coroots}

atlas> ^M*G.simple_coroots
Value:
| -1,  0,  0, -1 |
|  1, -1, -1,  1 |
}

set restrict_action_weak (mat A, mat M) =  { shapes A: n by n, M: n by m }
   case solve(M,A*M) | B.solution: B
   | else null(0,0)
   esac

set lift(mat m, RootDatum G,mat M)=WeylElt:
let W=G.W then
i=first(for w in W do any(solve(M,w.matrix*M)) and restrict_action(w.matrix,M)=m od)
in W[i]

set lift(mat theta_H,mat M,RealForm G)=mat:
let i=first(for x in KGB(G) do any(solve(M,x.involution*M)) and restrict_action(x.involution,M)=theta_H od) in
KGB(G,i).involution

set lift(KGBElt_gen x_H_gen,mat M, RealForm G)=KGBElt_gen:
let tf_H_raw=x_H_gen.unnormalized_torus_factor then
theta_G=lift(x_H_gen.involution,M,G) then
()=if te_verbose then prints("tf_H_raw=",tf_H_raw) fi then
tf_G_raw=M*tf_H_raw then
()=if te_verbose then prints("tf_G_raw=", tf_G_raw) fi then
tf_G=(2*tf_G_raw-G.rho_check)*(1+theta_G)/2 in
KGB_elt_gen(G.inner_class,theta_G,tf_G)

set lift(KGBElt x_H,mat M, RealForm G)=KGBElt_gen:
lift(KGB_elt_gen(x_H),M,G)

set lift_std(Param p_H,mat M,RealForm G, mat delta)=
let E_H=E(p_H.real_form.distinguished_involution,p_H) then
x=lift(p_H.x,M,G) then
gamma_G=M*p_H.infinitesimal_character then
lambda_rho_G=(M*(p_H.lambda)-G.rho)\1 {vec}  then
theta_G=lift(p_H.involution,G,M).matrix*delta then
{g_G=^M*E_H.g then
l_G=^M*E_H.l then
t_G=^M*E_H.t then
tau_G=M*E_H.tau in}
{g_G=solve(left_inverse(M),E_H.g).requisition then
l_G=solve(left_inverse(M),E_H.l).requisition then
tau_G=solve(left_inverse(M),E_H.tau).requisition then
t_G=solve(left_inverse(M),E_H.t).requisition in}


{g_G=M*E_H.g then
l_G=M*E_H.l then}
g_G=G.rho_check then
l_G=null(#g_G) then
tau_G=solve(^M,E_H.tau).requisition then
t_G=solve(^M,E_H.t).requisition in

ExtParam:(
G.inner_class,
G.distinguished_involution,
gamma_G,
lambda_rho_G,
theta_G,
g_G,
l_G,
-^theta_G,
tau_G,
t_G)


set extended_character_formula (Param p,mat delta) =
let (B,,)=partial_extended_KL_block(p,delta) in
let (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta),
{P=big_KL_P_signed_polynomials(p,delta) then}
P=big_KL_P_polynomials(p,delta) then
()=if te_verbose then printPolyMatrix(P) fi  then
index=find(complete_indices,(find(B,p),1)) in
{let ()=prints("index=", index) in}
null_module(p.real_form) +
for i:#complete_indices
do let f=eval(P[i][index],s) in
{let ()=prints(new_line,"i= ", i, " f=",f) in}
 let (j,c)=complete_indices[i] in
 {let ()=prints("j=",j, " f=",f, " c=",c, " ", "f*c=", f*c, "  ",B[j]) in} f*c*B[j]
od

set sign_difference(Param p_G, mat delta)=int:
(-1)^(length(p_G)-delta_l_int(p_G,delta))

{M  mxn integral matrix
 N  mxr integral matrix
 v= rational vector size m
 solve: M*w=v mod N
  i.e. Mw=v modulo the lattice spanned by the columns of N
  algorithm:  M##N is an mx(n+r) matrix
  solve M##N*w=v
  #w=r+n
  w=(w1,w2) #w1=r,#w2=n
  M##Nw=Mw1+Nw2=v
  Mw1=v-Nw2
  }
set solve(mat M,mat N,ratvec v)=maybe_a_ratvec:
  let sol=solve(M##N,v) in
  let ()=if te_verbose then prints("solving: ", v) fi in
   if any(sol) then
    let    ()=if te_verbose then prints("solution: ", sol.requisition) fi in
    let w=sol.requisition in w[:n_columns(M)].solution
   else
    ().no_ratvec
   fi


{gamma_H is the known infinitesimal character for H}
set inverse_lift_std(Param p_G,RealForm H,mat M, mat delta,ratvec gamma_H)=ParamPol:
let y_G=y_gen(p_G) then
action_H=restrict_action(y_G.involution,M) then
tf_u_G=y_G.unnormalized_torus_factor {unnormalized torus factor for G} then
theta=p_G.x.involution then
N=(1+theta)##id_mat(n_rows(theta)) then
()=if te_verbose then prints(M##N) fi then
tf_u_H_maybe=solve(M,N,tf_u_G) {solution to: M*tf_u_H=tf_u_G mod (X^*_Q)^[-theta]+X_*}  then
tf_u_H=if not any(tf_u_H_maybe) then error("no solution") else
        2*tf_u_H_maybe.requisition  {factor of 2}
fi  then
tf_H=(1+action_H)*(2*tf_u_H-H.rho)/2 {convert to normalized torus factor} then
()=if te_verbose then prints("tf_u_G: ", tf_u_G, new_line, "tf_u_H: ", tf_u_H, new_line, "tf_H: ", tf_H) fi then
y_H_gen=KGB_elt_gen(dual(inner_class(H)),action_H,tf_H) then
()=if te_verbose then prints("y_H_gen=", y_H_gen) fi in
if is_valid(y_H_gen,gamma_H) then
 let ()=if te_verbose then prints("is valid") fi in
 let  lp=L_packet(H,left_inverse(M)*p_G.infinitesimal_character,y_H_gen) then
 ()= if te_verbose then prints("lp="); for a in lp do prints(a) od fi in
 sign_difference(p_G,delta)*param_pol(lp)
else
 let ()=prints("not valid, consider using inverse_lift_std_by_search instead") in
 error("not valid")
fi

set inverse_lift_std_by_search(Param p_G,RealForm H,mat M,mat delta,ratvec gamma_H)=ParamPol:
let all=all_parameters_gamma(H,gamma_H) then
index=int: first(for p@i in all do  Finalize(lift_std(p,M,p_G.real_form,delta).parameter)=p_G od) in
if index=-1 then prints("inverse_lift_std_by_search failed for p_G=",p_G);null_module(H) else
sign_difference(p_G,delta)*param_pol(L_packet(all[index])) fi

set inverse_lift_std_mixed(Param p_G,RealForm H,mat M, mat delta,ratvec gamma_H)=ParamPol:
let y_G=y_gen(p_G) then
action_H=restrict_action(y_G.involution,M) then
tf_u_G=y_G.unnormalized_torus_factor then
{tf_u_H=left_inverse(M)*tf_u_G then}
theta=p_G.x.involution then
N=(1+theta)##id_mat(n_rows(theta)) then
()=if te_verbose then prints(M##N) fi then
tf_u_H_maybe=solve(M,N,tf_u_G) then
tf_u_H=if not any(tf_u_H_maybe) then error("no solution") else
        2*tf_u_H_maybe.requisition
fi  then
{tf_u_H=left_inverse(M)*tf_u_G then lift}
tf_H=(1+action_H)*(2*tf_u_H-H.rho)/2 then
()=if te_verbose then prints("tf_u_G: ", tf_u_G, new_line, "tf_u_H: ", tf_u_H, new_line, "tf_H: ", tf_H) fi then
y_H_gen=KGB_elt_gen(dual(inner_class(H)),action_H,tf_H) then
()=if te_verbose then prints("y_H_gen=", y_H_gen) fi in
if is_valid(y_H_gen,gamma_H) then
 let ()=if te_verbose then prints("is valid") fi in
 let  lp=L_packet(H,gamma_H,y_H_gen) then
 ()= if te_verbose then prints("lp="); for a in lp do prints(a) od fi in
 sign_difference(p_G,delta)*param_pol(lp)
else
 let ()=prints("not valid, using inverse_lift_std_by_search instead") in
 inverse_lift_std_by_search(p_G,H,M,delta,gamma_H)
fi

{
set inverse_lift_std_mixed(Param p_G,RealForm H,mat M, mat delta)=ParamPol:
let P=inverse_lift_std(p_G,H,M,delta) in
 if =P then prints("inverse lift failed, use search");inverse_lift_std_by_search(p_G,H,M,delta)
 else P fi
}
{returns a sum of standards}
set inverse_lift_irr_mixed(Param p_G,RealForm H,mat M,mat delta,ratvec gamma_H)=
let P=extended_character_formula(p_G,delta) then
()=if te_verbose then prints("P=",P) fi then
PH=null_module(H) + for (c,p) in %P do c*inverse_lift_std_mixed(p,H,M,delta,gamma_H) od then
()=if te_verbose then prints("inverse lift as sum of standards: ", PH) fi in
{composition_series(PH)}
PH

{returns a sum of standards}
set inverse_lift_irr(Param p_G,RealForm H,mat M,mat delta,ratvec gamma_H)=
let P=extended_character_formula(p_G,delta) then
()=if te_verbose then prints("P=",P) fi then
PH=null_module(H) + for (c,p) in %P do c*inverse_lift_std(p,H,M,delta,gamma_H) od then
()=if te_verbose then prints("inverse lift as sum of standards: ", PH) fi in
PH

{to use: set G=GL(n,R), delta=G.distinguished_involution,
(H,M)=endoscopic(G,delta) to define H,M,G,delta}
set abv_mixed(Param p_H,mat M,RealForm G,mat delta)=
let lift_std_ext=lift_std(p_H,M,G,delta) then
lift_std=parameter(lift_std_ext) then
inverse_lift=inverse_lift_irr_mixed(lift_std,p_H.real_form,M,delta,p_H.infinitesimal_character) {sum of standards} then
()=if te_verbose then prints("inverse_lift: (sum of stds): ", inverse_lift) fi in
(p_H,lift_std,inverse_lift,composition_series(inverse_lift))

{to use: set G=GL(n,R), delta=G.distinguished_involution,
(H,M)=endoscopic(G,delta) to define H,M,G,delta}
set abv(Param p_H,mat M,RealForm G,mat delta)=
let lift_std_ext=lift_std(p_H,M,G,delta) then
lift_std=parameter(lift_std_ext) then
inverse_lift=inverse_lift_irr(lift_std,p_H.real_form,M,delta,p_H.infinitesimal_character) then
()=if te_verbose then prints("lift_std=", lift_std) fi in
(p_H,lift_std,inverse_lift,composition_series(inverse_lift))



set print([(Param,Param,ParamPol)] data)=void:
let (p_H,p_G,)=data[0] then
()=prints("H=", p_H.real_form,new_line, "G=", p_G.real_form) in
for (p_H,p_G,abv)@i in data do
prints(new_line,"i: ", i, new_line, "p_H: ", p_H,new_line,"inf char(p_H): ", p_H.infinitesimal_character,
new_line, "p_G=lift(p_H): ", p_G, new_line,"inf_ char(p_G): ", p_G.infinitesimal_character	, new_line,"Packet(p_H): ", abv) od


{----------------------------------- Weyl group---------------------------}

set is_multiple(vec v,vec w)=bool:rank(mat:[v,w])=1

{lift simple root to list of simple roots restricting to a MULTIPLE of it}
set lift_root(RootDatum G,SubTorus T,vec alpha)=[vec]:
##for beta in G.simple_roots do
 if is_multiple(T.restrict(beta),alpha) then [beta] else [] fi od 

{set lift_root(RootDatum G,mat M,vec alpha)=[vec]:roots_restricting_to(G,M,alpha)}
set lift_root(RootDatum G,RootDatum H,mat M,int i_H)=[int]:for v in lift_root(G,M,root(H,i_H)) do root_index(G,v) od
 
{lift any root reflection}
set lift_reflection(RootDatum G,RootDatum H,mat M,int i)=
let roots=lift_root(G,H,M,i) in
assert(#roots>0 and #roots<4, "problem lifting root");
if #roots=1 then
  W_elt(G,reflection(G,roots[0]))
elif #roots=2 then
   W_elt(G,reflection(G,roots[0])*reflection(G,roots[1]))
elif #roots=3 then
 W_elt(G,reflection(G,roots[0])*reflection(G,roots[1])*reflection(G,roots[0]+roots[1])){assuming: roots[0]+roots[1] is a root}
else id_W(G)
fi

set lift_simple_reflection(RootDatum G,RootDatum H,mat M,int i)=
assert(i>-1 and i<ss_rank(H),"not a simple root for H");lift_reflection(G,H,M,i)

set lift_W_word(RootDatum G,RootDatum H, mat M,[int] word)=WeylElt:
let lift=id_W(G) in
 for i in word do lift*:=lift_simple_reflection(G,H,M,i) od;lift

set lift_W_word(RootDatum G,RootDatum H, mat M,WeylElt w)=lift_W_word(G,H,M,word(w))





set root_map(RootDatum G,mat delta)=
let (H,M)=folded(G,delta) in
for i:ss_rank(H) do lift_root(G,H,M,i) od

set G=GL(7)
set delta=distinguished_involution(GL(7,R))
set (H,M)=Folded(G,delta)



set *(mat M,KGBElt x)=KGBElt:
let G=x.root_datum then
tf_u=unnormalized_torus_factor(x) then
theta=involution(x) then
theta_1=M*theta*inverse(M) then
tf_1_u=M*tf_u then
tf_1=(2*tf_1_u-G.rho_check)*(1+theta_1)/2 in
KGB_elt(G,tf_1_u,theta_1)

set fixed_KGB(RealForm G,mat M)=[KGBElt]:
##for x in KGB(G) do
 if M*x=x then [x] else [] fi od

{M=KGB_Hasse(G)
 convert this to a poset
 row j of M: entry i =1 means: KGB(j)<KGB(i) (and these are the covering relations)
}
set poset_of_Hasse_matrix(mat M)=
  for v in ^M do
   for j:#v do if v[j]=1 then [j] else [] fi od.##
  od

set lift_KGB_cross(int j_H,[[int]] root_map,KGBElt x_G)=KGBElt:
let G=x_G.real_form then
y=x_G then
 roots=root_map[j_H] in
 if #roots<2 then
    cross(roots[0],y)
 elif is_orthogonal(G,roots[0],roots[1]) then
    for i in roots do y:=cross(i,y) od;y
 else
    let j=root_index(G,root(G,roots[0])+root(G,roots[1])) in
    for i in roots#j do y:=cross(i,y) od;y
 fi
 

set lift_KGB_Cayley(int j_H,[[int]] root_map,KGBElt x_G)=KGBElt:
let y=x_G in
 for i in root_map[j_H] do y:=Cayley(i,y) od;y

set embed_KGB(KGBElt x_H,KGBElt x_G,[[int]] root_map)=[(int,int)]:
let H=x_H.real_form then
G=x_G.real_form then
known_H=[x_H.number] then
known_G=[x_G.number] then
map=[(x_H.number,x_G.number)] then
done_H=[int]:[]  {x_H's for which we've computed all crosses and Cayleys} then
is_known_H(int i)=bool:in_list(known_H,i) then
is_known_G(int i)=bool:in_list(known_G,i) then
is_known_H(KGBElt x_H)=bool:in_list(known_H,x_H.number) then
is_known_G(KGBElt x_G)=bool:in_list(known_G,x_G.number) then
lookup(int i_G)=  {given i_G find i_H which we've already computed which maps to it}
  let index=first(for (,j) in map do j=i_G od) then (i_H,)=map[i_G] in i_H in
while #map<KGB_size(H) do
let ()=if te_verbose then prints("known_H: ", known_H, new_line, "known_G: ", known_G) fi in
let ()=if te_verbose then prints("map: ", map) fi in
let ()=if te_verbose then prints("done_H: ", done_H) fi in 
 {find (i,j)  so that (i,j) occurs in map, but i is NOT in done_H}
 let index_in_map= first(for (i,) in map do not in_list(done_H,i) od) then
    ()=if index_in_map=-1 then 
       prints("failed to compute complete map");prints("KGB size of H: ", KGB_size(H),new_line, "#map: ", #map);return(map) 
    fi then
    (i_H,i_G)=map[index_in_map] then
    x_H=KGB(H,i_H) then
    x_G=KGB(G,i_G) in
    let    ()=if te_verbose then prints(new_line,"x_H: ", x_H) fi  then
    ()=if te_verbose then prints("x_G: ", x_G) fi in
    done_H#:=i_H;
 for i:ss_rank(H) do
    let y_H=cross(i,x_H) in
    let ()=if te_verbose then prints("i=",i,"(cross)y_H=", y_H) fi in
      let ()=if not is_known_H(y_H) then
                let ()=if te_verbose then prints(i, " ", root_map, " ", x_G, " ", x_G.real_form) fi in
              let y_G=lift_KGB_cross(i, root_map,x_G) in
              let ()=if te_verbose then prints("y_G=",y_G) fi in
              {map may not be injectived: (i,j) and (k,j) could both occur
               for example on group side: G=GL(4,R), H=SO(3,2)->GL(4,R)}
                if  true then
{               if not is_known_G(y_G) then}
               if te_verbose then prints("adding: ", y_H.number, " ", y_G.number) fi; 
               map#:=(y_H.number, y_G.number);
               known_G#:=y_G.number;
               known_H#:=y_H.number
              fi
             fi
  in
  if is_noncompact(i,x_H) or is_real(i, x_H) then
       let y_H=Cayley(i,x_H) in
       let ()=if te_verbose then prints("i=",i,"(Cayley)y_H=", y_H) fi in
       if not is_known_H(y_H) then
               let y_G=lift_KGB_Cayley(i, root_map,x_G) in
               if not is_known_G(y_G) then
                 map#:=(y_H.number, y_G.number);
                 known_G#:=y_G.number;
                 known_H#:=y_H.number
               fi
              fi
     fi
  od{for i}
od{while #map};prints("KGB size of H: ", KGB_size(H),new_line, "#map: ", #map);map 

