<basic.at
<generics.at
<Levi_subgroups.at
<elliptic.at { for |elliptics_for_standard_Levi@(RootDatum,[int])| }
<cyclotomic.at {for |product_of_cyclotomic|}
<Weylgroup.at { for |is_relatively_elliptic| }
<tabulate.at { for |tabulate| }

{ This file serves to compute with Weyl group conjugacy classes and characters.

  A large initial part is dedicated to deciding conjugacy in the Weyl group, and
  finding an explicit witness of conjugacy from a class representative.
}


{ A first major task is to list the $W$ conjugacy classes.

  Every Weyl group element $w$ has an associated Levi subgroup (not necessarily
  standard), whose roots are those whose reflections fix all weights fixed by
  $w$ (its eigenspace for $1$ in the reflection representation). The function
  |Levi_info@WeylElt| defined in Levi_subgroups.at computes the |Levi_info| for
  this Levi subgroup. Then $w$ is in the Weyl group of this Levi subgroup, and
  by construction it is a relatively elliptic element there.

  The Weyl subgroup of any Levi subgroup is conjugate in $W$ to that of a
  standard Levi subgroup, so for the purpose of finding the conjugacy classes of
  $W$ it suffices to consider only standard Levi subgroups. These have been
  classified (under conjugacy by $W$) in Levi_subgroups.at. The function
  |standard_Levi_conjugacy_representatives| defined there lists standard Levi
  conjugacy class representatives, and the function |classify_standard_Levis|
  provides for a root datum more complete information in the form of a
  |StdLeviTable|, which also lists Levi conjugacy orbits for easy looking up.
}

{ A subsidiary task is to enumerate elliptic conjugacy classes for each standard
  Levi subsystem. The function |elliptics_for_standard_Levi@(RootDatum,[int])|
  defined in elliptic.at accomplishes this, partly by explicit listing.
}


{. list of conjugacy class representatives of W(rd) .}
set conjugacy_class_reps (RootDatum rd) = [WeylElt]:
  for subset in standard_Levi_conjugacy_representatives(rd)
  do elliptics_for_standard_Levi(rd,subset)
  od.##

set Levi_of (WeylElt w) = [int]: { posroot indices for simples of |w| system }
   w.Levi_info.simples { avoiding construction of a |RootDatum| }


set_type StdLeviWImage =
   (WeylElt actor { conjugator from |image| back to original |w| }
  , [int]   Levi  { simples for a standard Levi }
  , WeylElt image { an element for Levi, conjugate in |W| to original |w| }
  )
set_type StdLeviReducer = (WeylElt->StdLeviWImage)

{ it is easy (but not very useful) to find some "standard" conjugate of |w| }
set conjugate_from_some_standard_Levi = StdLeviReducer:
   (WeylElt w):
   let (chamber,unsorted_standard_Levi)
      = from_standard_Levi(w.root_datum,Levi_of(w))
   in StdLeviWImage: (chamber,unsorted_standard_Levi.sort,/chamber*w*chamber)


{ The usefulness of a |StdLeviReducer| is limited if it can choose different
  standard Levis for different element, even though they are conjugate. To be
  more useful, we must force finding a Levi from a fixed set of representatives.
  Both |levi_lookup| methods from Levi_subgroups.at will force choosing a Levi
  from a fixed set of representatives of classes of standard Levi subgroups.
}

set conjugate_from_elected_Levi (StdLeviFinder lookup) = StdLeviReducer:
   (WeylElt w): let (conj,elected_Levi) = lookup(Levi_of(w)) in
   StdLeviWImage: (conj,elected_Levi,/conj*w*conj)

Levi_reducer : (RootDatum->StdLeviReducer)
{ make this a variable; implements a map to standard Levi }

set Levi_reducer_rho (RootDatum rd) = StdLeviReducer:
   conjugate_from_elected_Levi(Levi_lookup(rd,orbits_table(rd)))
set Levi_reducer_classify (RootDatum rd) = StdLeviReducer:
   conjugate_from_elected_Levi(Levi_lookup(rd,classify_standard_Levis(rd)))

Levi_reducer := Levi_reducer_rho@RootDatum { this appears to be faster }

{ Conjugacy tests will always be curried (take one |WeylElt| first, then
  possibly after some preparation produce a function that takes a second one)
  and come in two forms: a strong one that can produce a withness of conjugacy
  in case it holds, and a weak one that just tells whether conjugacy holds.

  Our approach always begins with reducing to the relatively elliptic case:
  each $w$ is relatively elliptic in the (generally not standard) Levi subgroup
  |Levi_of(w)| and if $w,w'$ have |Levi_of(w)=Levi_of(w')| and are conjugate in
  $W$ they are already conjugate in |Levi_of(w)|; therefore to test an arbitrary
  pair for conjugacy we can first test their Levi subgroups for conjugacy, and
  if so conjugate the elements to a common Levi subgroup and test conjugacy
  there. (For practical reasons that common Levi will be taken to be standard.)
  To avoid unnecessarily creation of (sub-) root data, the reduced test will be
  performed inside the original Weyl group, but with a specified list of
  generators of the Levi subgroup passed as argument (being a stardard Levi,
  this will be a subset of the simple roots, not necessarily listed increasing).
}
set_type ConjugacyWitnesser     = (WeylElt->(WeylElt->Maybe<WeylElt>))
set_type ConjugacyTester        = (WeylElt->(WeylElt->bool))
set_type LeviConjugacyWitnesser = ([int],WeylElt->(WeylElt->Maybe<WeylElt>))
set_type LeviConjugacyTester    = ([int],WeylElt->(WeylElt->bool))

{ conjugacy test, using a provided |classify| method and an elliptic case test }

set conjugacy_witness (StdLeviReducer classify, LeviConjugacyWitnesser Lcw) =
   ConjugacyWitnesser:
   (WeylElt x):
   let rd=x.root_datum, ord_x = order(x), chi=char_poly(x)
   , class_x = StdLeviWImage: classify(x)
   then Levi_test = (WeylElt->Maybe<WeylElt>): Lcw(class_x.Levi,class_x.image)
in { end of preparations for |x|, now define the function of |y| }
   (WeylElt y) Maybe<WeylElt>:
   { start with easy necessary conditions on |y|: }
   if y.root_datum=rd and order(y)=ord_x and char_poly(y)=chi
   then
      let class_y = classify(y) in
      if class_y.Levi!=class_x.Levi then none()
      else
         case Levi_test(class_y.image)
	 | none(): none()
	 | some(w_Levi): some(class_x.actor * w_Levi * /class_y.actor)
	 esac
      fi
   else none()
   fi


{ Using an elliptic case test that does not provide a witness in case of a
  positive result, we can use the same approach but omit all the conjugacy
  computations (other than conjugating the given elements |w| to the elected
  standard Levi in the orbit of of |Levi_of(w)|, which happens inside |classify|.
}
set conjugacy_test (StdLeviReducer classify, LeviConjugacyTester Levi_test) =
   ConjugacyTester:
   (WeylElt x):
   let rd=x.root_datum, ord_x = order(x), chi=char_poly(x)
   , (,Levi,xx) = StdLeviWImage: classify(x)
   then test = (WeylElt->bool): Levi_test(Levi,xx)
in { end of preparations for |x|, now define the function of |y| }
   (WeylElt y) bool:
   { start with easy necessary conditions on |y|: }
   y.root_datum=rd and order(y)=ord_x and char_poly(y)=chi and
   (
     let (,Levi_y,yy) = classify(y) in
     Levi_y=Levi and test(yy)
   )

{ Our next task is giving a conjugacy test for the elliptic case. For that we
  shall use an explicit enumeration of the set of minimal length representatives
  of an elliptic element; once this is done for one element, we can test the
  other element by finding a minimal length conjugate and looking it up.
}

{ The following greedy algorithm is guaranteed to give at least one minimal
  length conjugate of any eleent |w| it may be applied to, and moreover to give
  *all* such conjugates if |w| is elliptic; these facts are due to He. This
  essentially says that one can conjugate |w| to a minimal length conjugate
  doing one simple, weakly length decreasing conjugation at a time; moreover,
  for a given minimal length elliptic element, all its conjugates of the same
  length can be obtained by a sequence of length-preserving simple conjugations.

  NOTE: in A2 the two simple generators are conjugate, but (obviously) not by
  either one of them, which shows that the elliptic hypothesis in the second
  part of the above claim cannot be dropped.

  So: given a Weyl group element |w|, generate simple conjugates of it that are
  not longer than it, replacing |w| whenever a shorter conjugate is found, while
  restarting the generation; as long as that does not happen, make a collection
  of all equal length conjugates generated, which is also used for producing
  furtehr simple conjugates (and cleared at a restart). For every conjugate
  generated, also record a conjugating element towards it from the original |w|.

  The function |minima_He| implements this. For generating equal length
  conjugates we use an orbit generation by shells of distance from the starting
  point at the current length.
}
set minima_He ([int] Levi,WeylElt w) =
  [WeylElt,WeylElt]: { $(w', g)$ with $g*w*/g = w'$ }
(  let !rd = w.root_datum
   then stack = [[],[(w,id_W(rd))]], lw=length(w)
   , gens = [WeylElt]: for i in Levi do W_gen(rd,i) od
   , absent([WeylElt,WeylElt] pairs, WeylElt w) = bool:
        none(pairs,(WeylElt x,WeylElt.)bool:x=w)
in while { loop with embedded |do| instances near end }
      let shorter=false, last2_levels = stack~[0] ## stack~[1]
      then new_level = [WeylElt,WeylElt]:
	 for s in gens
	    for (w,witness) in stack~[0]
	    do let sws=s*w*s in
	       case length(sws)-lw
	       then { less: }
		  stack:=[[],[(sws,s*witness)]] { reset }
	       ;  shorter:=true;  break break  { flag, and break |for(s)| }
	       in { equal: }
		 if absent(last2_levels,sws) { check 2 most recent shells }
	         do (sws,s*witness)  { contribute to |new_level|, and go on }
		 fi
	       else { greater: } [] { nothing to contribute, but continue }
	       esac
	    od
	 od.##
{ |do| for |while| is below, twice: }
   in if shorter { length decrease was flagged }
      then do lw:=lw-2 { restart |While| loop for a shorter length }
      else #new_level>0 { continue |while| loop if anything was contributed }
      do let filtered = new_level[:1] in { we still need to remove duplicates }
	 for (w,):pair in new_level[1:] { all except initial element are tested }
	 do if absent(filtered,w) then filtered #:= pair fi
	 od
      ;  stack#:=filtered
      fi
   od { while }
;  ##stack
)

{ one selected minimal length class representative, witness conjugating to it;
  this works whether or not |w| is (relatively) elliptic
}
set minimal_representative_with_witness (WeylElt w) = (WeylElt,WeylElt):
   minima_He(w.root_datum.all_simples,w)[0]
{ often one does not need a witness, so the following can be used instead }
set minimal_representative (WeylElt w) = WeylElt:
   w.minimal_representative_with_witness.fst

{ Even though finding a minimum can be done without, we can restrict to a Levi }
set minimal_representative_with_witness (([int],WeylElt) a) = (WeylElt,WeylElt):
   minima_He(a)[0]
{ often one does not need a witness, so the following can be used instead }
set minimal_representative (([int],WeylElt) a) = WeylElt:
   a.minimal_representative_with_witness.fst

set is_elliptic_for_Levi ([int] Levi,WeylElt w) = bool:
   w.word.to_bitset=Levi.to_bitset

set minimal_representatives_with_witness (([int],WeylElt)args) =
   [WeylElt,WeylElt]:
   assert(is_elliptic_for_Levi(args),"Element not elliptic for Levi subgroup");
      minima_He(args)
set minimal_representatives (([int],WeylElt)args) = [WeylElt]:
   args.minimal_representatives_with_witness.(map(fst))

set He_witnesser = LeviConjugacyWitnesser:
   (([int],WeylElt)(Levi,x):args):
   let minima = minimal_representatives_with_witness(args) in
   (WeylElt y) Maybe<WeylElt>:
   case get_last(fst,=@(WeylElt,WeylElt))(minima,y)
   | none: none()
   | some(,conj): some(conj)
   esac

set He_tester = LeviConjugacyTester:
   (([int],WeylElt)(Levi,):args) (WeylElt->bool):
   let test = (WeylElt->bool): is_member(minimal_representatives(args))
   in (WeylElt y) bool: test(minimal_representative(Levi,y))

{ Conjugacy test, using reduction to elliptic

  We use the fact that x,y are conjugate iff L_x=x.Levi_datum is
  conjugate to L_y=y.Levi_datum, and, after conjugating L_y to L_x,
  x_ell is L_x conjugate to y_ell, where x_ell, y_ell are the elliptic
  classes in L_x, L_y corresponding to x,y
  Note that there is a choice of how to conjugate L_y to L_x, however the
  result is independent of that choice, essentially because the only elliptic
  class in type A is the Coxeter element, and the elliptic classes in a
  simple group are fixed by all outer automorphisms.
}

set is_conjugate_in (RootDatum rd) = ConjugacyTester:
   conjugacy_test(Levi_reducer(rd),He_tester@([int],WeylElt))

{ similarly default to |He_witnesser| for |conjugacy_witness| }
set conjugacy_witness (StdLeviReducer classify) = ConjugacyWitnesser:
   conjugacy_witness(classify, He_witnesser@([int],WeylElt))

set conjugacy_witness_in (RootDatum rd) = ConjugacyWitnesser:
   conjugacy_witness(Levi_reducer(rd), He_witnesser@([int],WeylElt))


{ We can test for conjugacy without doing a classificatin of the standard Levis.
  The function |untabled_tester| conjugates |Levi_of(x)| for the first candidate
  |x| to some standard Levi |sLevi|, and generates the |rho_stabiliser_orbit|
  (which tabulates all Levis conjugate to it that have a dominant |two_rho|
  value). For the other candidate |y|, it first does some quick checks that will
  rule out many non-conjugate elements, and if this is not decisive, finds a
  Levi |L| conjugate to |Levi_of(y))| that has dominant |two_rho|; if this
  matches, |L| must be tabulated and we can find a conjugate from |Levi_of(y)|
  via |L| to |sLevi|; after conjugating both |x| and |y| into |sLevi|, the
  provided |LeviConjugacyTester| is applied to compare the images of |x| and |y|.

  Note that although we are not interested in getting a witness for conjugacy in
  case it should hold, we still must keep track of elemeent that conjugate the
  Levi subgroups in question to each other.
}
set untabled_tester (LeviConjugacyTester Levi_test) = ConjugacyTester:
(  (WeylElt x) (WeylElt->bool):
   let rd=x.root_datum, ord_x = order(x), chi=char_poly(x)
   then rho2 = dominant(rd,two_rho(Levi_info(x)))
   , (w_x,sLevi) = { w_x: conjugator some standard Levi |sLevi| to |Levi_of(x)| }
       from_standard_Levi(rd,Levi_of(x))
   then lookup = (int->Maybe<orbit_entry>):
      let orbit = [orbit_entry]: { sorted by their |L_int| componenta }
         rho_stabiliser_orbit(rd,sLevi)
      in lookup_in(orbit,L_int@orbit_entry,<=@(int,int))
   , ell_test = (WeylElt->bool):
     { first conjugate |x| to standard Levi |sLevi| and check that it arrived }
       let x_image = /w_x * x * w_x in
       assert(Levi_of(x_image)=sLevi.sort
             ,@: "Moving "+x.to_string+" to standard Levi "+sLevi.to_string
	         +" failed: "+x_image.to_string );
       Levi_test(sLevi,x_image)
in
   (WeylElt y) bool: { the actual test |is_conjugate_to(x)| }
   y.root_datum=rd and order(y)=ord_x and char_poly(y)=chi and
   ( { all quick checks having succeeded, we must do some real work for |y| }
      let LIy=Levi_info(y)
      then rho2Ly = two_rho(LIy)
      then (w0,rho2_y) = from_dominant(rd,rho2Ly)
   in rho2_y=rho2 and
      ( let L = int: act_up(/w0,simples(LIy)).combination_encode
        then conjugator =  { Levi_of(y) <-L <- sLevi=orbit.Levi_repr }
	  w0 *
	  case lookup(L)
	  | none: error("conjugate with dominant rho not found in orbit")
	  | some(,w): w { conjugates |sLevi| to image |L| of |Levi_of(y)| }
	  esac
      in ell_test(/conjugator*y*conjugator)
      )
   )
)



{ the following inefficient function is unused, but motivates the one after it }

{ $W$-orbit of (non standard) Levi subsystem, represented by simple systems }
set Levi_orbit (RootDatum rd, [int] Levi { posroot indices } ) = [[int]]:
(  let npr = rd.nr_of_posroots
   then root_perm = [vec]: { root permutations for all simple reflections }
     for i:rd.semisimple_rank
     do let perm = root_involution(rd,i)[npr:] { upper half } in
        for x in perm do x-npr od { shift values to usual posroot numbers }
     od { this is negative on the main diagonal, but those entries are unused }
   then act((int,int)(i,roots):arg) = Maybe<int>:
      { |i| is simple root index, |roots| a bitset encoding a set of posroots }
      if is_member_bitset(arg)
         { whether |i| nomalises the current root system |roots| }
      then none() { Levi's own simple reflection normalises system }
      else { |i| does not normalise; return its conjugation image of |roots| }
         let map = root_perm[i] in
	 some(for j in roots.set_bit_positions do map[j] od.to_bitset)
      fi
   , orbit = [Levi.to_bitset], current=0
in while current<#orbit
   do let L=orbit[current] next current+:=1
   in for s:rd.semisimple_rank
      do case act(s,L) | else ()
         | some(Levi):
	   if none(#orbit,(int i):orbit[i]=Levi) then orbit #:= Levi fi
	 esac
      od
   od
;  for Levi in orbit do Levi.set_bit_positions od { convert back to |[int]| }
)

{ Computing just the size of this Levi orbit can be done a bit more efficiently
  than generating it, though it requires a some preliminary computation. The e
  idea is to use the stabiliser subgroup $M$ in $W$ of $\rho_L$; although it
  does not contain the normaliser $N_L$ of the parabolic subgroup $L$ ow $W$
  (since elements of $N_L$ can send |simples(L)| to a different set that also
  generates $L$), the intersection $M\cap N_L$ has known index in $N_L$, namely
  the size of $W_L$ (every coset by $W_L$ meets the intersection uniquely: there
  is a unique element of $W_L$ that sends the image of |simples(L)| by an
  element of $N_L$ back to |simples(L)| as a set). So we generate the (hopefully
  small) orbit under $M$ of images of the Levi system |simples(L)|, then by
  dividing the size of $M$ by that of the orbit find the size of $M\cap N_L$,
  which multiplied by the size of $W_L$ gives the size of $N_L$; finally
  dividing the size of $W$ by that gives our Levi orbit size.

  The orbit generation here is tailored to the specific situation, whence we do
  it using local code (the |begin|-|end| block below) rather than writing or
  using a more general orbit generation. The special circumstance is that we
  know that all elements of the acting subgroup fix $\rho_L$, so the only way
  they can map all simple generators of $L$ to roots of $L$ is by permuting them
  among each other. We can then ignore the distinction between a root and its
  opposite (working only with positive root indices) and not worry about
  choosing the simple generators for the positive part of each Levi system
  (which is why we had to single out the "do nothing" case above): the Levi
  system implied by a set of indices is the one additively generated by those
  roots and their opposites, and this results in the same system only if the
  indices are the same up to permutation. So again we can use an equality test
  for orbit membership, provided we sort our lists of indices to be increasing.
}

set Levi_normalizer_index ((RootDatum,(int->bool))(rd,select):Levi_info) = int:
   let npr = rd.nr_of_posroots
   , rho2_L = two_rho(Levi_info)
   , Levi = [int]: simples(Levi_info)
   then rho_L_stab_gens = [int]:
      simples(LeviInfo:(rd,(int i)bool: coroot(rd,i)*rho2_L=0))
   then rho_L_stab_W_order = int:
      let (lt,)=Cartan_matrix_type(Cartan_matrix(rd,rho_L_stab_gens))
      in order_W(lt)
   , stab_orbit_size = int:
      begin
      let root_perm = [[int]]: { absroot perm.s by stabiliser simple refl.s }
         for i in rho_L_stab_gens
	 do for k in root_involution(rd,i)[npr:] { second half: posroots }
	    do if k<npr then ~k + npr else k - npr fi od
	 od
      then act(int i,[int] roots) = [int]:
         let map = root_perm[i] in for j in roots do map[j] od.sort
      , stack = [[int]]: [[],[combination_encode(Levi)]]
      , decode = combination_decode(#Levi) { decode numbers to |#Levi|-subsets }
      , present([int] sorted,int code) = bool:
	   binary_search_in(sorted,<=@(int,int))(code).succeeds
      in while { loop with |do| near end }
            let new_level = [int]:
	       for code in stack~[0]
	       do let L = [int]: decode(code)
	       in for k:#rho_L_stab_gens
                  do let M=combination_encode(act(k,L))
		  in if not (present(stack~[1],M) or present(stack~[0],M))
		     do M
		     fi
                  od.##
               od.##
	 in #new_level>0 { whether any new elements were found for new level }
	 do stack #:= new_level.sort_u
	 od
      ; { stab_orbit_size = } for level in stack do #level od.sum
      end
   in rho_L_stab_W_order \ stab_orbit_size { index of $W_L$ in $N_L$ }

set Levi_orbit_size ((RootDatum,(int->bool))(rd,):Levi_info) = int:
  rd.order_W \ (Levi_info.Levi_normalizer_index * Levi_info.Levi_datum.order_W)

{ Now onward to the task of getting the size of the conjugacy class of |w| for
  |Levi_datum(w)|, where, ignoring the central torus, it is elliptic. This root
  datum can have multiple simple factors, and we can decompose |w| as commuting
  product of elements of the Weyl groups of the simple factors, and its
  conjugacy class will be the Cartesian product of the conjugacy classes of the
  factors (the same goes for the centraliser). The following function determines
  this decomposition, where each |WeylElt| in the result is associated to a
  different root datum, which is simple up to a central torus.
}
set elliptic_simple_decomposition (WeylElt w) =
   [WeylElt,(string,int)]: { word in simple factor root datum, and latter type }
   let rd_L = Levi_datum(w)
   then (type,map)=Cartan_matrix_type(rd_L.Cartan_matrix)
   then codes = type.simple_factors, w_L=W_elt(rd_L,w.matrix) { convert }
   , offset=0 { rank within |type| already seen in loop below }
   , !r = rd_L.rank { full rank, needed when gathering roots/coroots }
in for (,rank):code in codes { traverse the simple factors }
   do let sub_map = map[offset:offset+rank] { index mapping for this factor }
      then factor_word =
         for s in w_L.word do let i=find(sub_map,s) in if i>=0 do i fi od.##
      , simple_datum = root_datum
	( r # for i in sub_map do rd_L.simple_roots[i]   od
	, r # for i in sub_map do rd_L.simple_coroots[i] od
	, w.root_datum.prefers_coroots
	)
   in ( W_elt(simple_datum,factor_word), code )
   next offset +:= rank
   od

set centralizer_order = (WeylElt->int):
  let elliptic_simple_order(WeylElt w,(string type, int rank)) = int:
     { here |w| is elliptic, with simple associated datum of given type,rank }
     case char_index(type,"ABCD")
     in rank+1 { type $A_n$ has unique elliptic, an $n+1$ cycle permutation }
     , order_of_centralizer_elliptic_BCD(w)
     , order_of_centralizer_elliptic_BCD(w)
     , order_of_centralizer_elliptic_BCD(w)
     else exceptional_elliptic_centr_order(type,rank,char_poly(w))
     esac
  in { centralizer_order = }
  (WeylElt w) int:
    for (w_i,type_rank) in elliptic_simple_decomposition(w)
    do elliptic_simple_order(w_i,type_rank)
    od . product * Levi_normalizer_index(w.Levi_info)

{. number of elements of a conjugacy class .}
set size_of_conjugacy_class (WeylElt w) = int:
  w.root_datum.order_W \ w.centralizer_order
set sizes_of_conjugacy_classes (RootDatum rd) = [int]:
  for w in conjugacy_class_reps(rd) do w.size_of_conjugacy_class od

{ A final production is a type for storing data relevant to W-characters,
  notably information about conjugacy classes. This will be a (mildly) "stateful
  value" in that some data, notably for the symmetric powers of the reflection
  representation, are computed and stored on demand only. In order to achieve
  this access is often via function components that can access the hidden state.
}
set_type
[ WeylClassTable =
  ( int order_W
  , [WeylElt] class_representatives
  , (WeylElt->int) class_of
  , [int] class_sizes
  , (int,int->int) class_power
  , [int] trivial
  , [int] sign
  , [int] reflection
  , ([int]->int) dimension
  , ([int]->int) norm2
  , ([int],[int]->int) inner
  , ([int],[int]->[int]) direct_sum
  , ([int],int->[int]) Cartesian_power
  , ([int],[int]->[int]) tensor
  , ([int],int->[int]) tensor_power
  , (int->[int]) sym_power_refl
  )
]

{ From the above functions, the generic table constructor will only use
  |conjugacy_class_reps|, |size_of_conjugacy_class|, and |is_conjugate| to get
  its information (and choices) concerning conjugacy. Since these general
  purpose functions may be much slower than type specific ones, our main
  constructor takes additional arguments in their place, and then the generic
  constructor will provide mentioned functions in thir place.
}
set W_class_table ( RootDatum rd
		  , [WeylElt] !reps { conjugacy class representatives }
		  , (int->int) class_size { size of class, by class numer }
		  , (WeylElt->int) class_nr_of { conjugacy classification }
		  , (int,int->int) power_map { for conjugacy classes }
		  ) = WeylClassTable:
   let !sizes = [int]: for i:#reps do class_size(i) od { tabulate function }
   , !ncc = #reps { number of conjugacy classes }
   , !nW = rd.order_W
   , !npr=rd.nr_of_posroots
   , !e = class_nr_of(id_W(rd))
   then inner ([int] x, [int] y) = int:
     assert(#x=ncc and #y=ncc,"Wrong sizes");
     let s = for size@i in sizes do size*x[i]*y[i] od.sum then (q,r)=s \% nW in
     if r=0 then q else error("Non integer inner product ",s/nW) fi
   , sum ([int] x, [int] y) = [int]: for xi@i in x do xi+y[i] od
   , product ([int] x, [int] y) = [int]: for xi@i in x do xi*y[i] od
   , refl_char_poly = [vec]: for w in reps do char_poly(w) od
   , !chi_deg = rd.rank { to limit reverse-indexing |refl_char_poly| entries }
   , power_table = [vec]: { tabulate relevant class powers for efficiency }
        for i:ncc do for k:reps[i].order do power_map(i,k) od od
   , reflection_sympowers = [[int]]: { characters of Sym^k(reflection_rep) }
        for :ncc do 1 od { initial symmetric 0-power, only one computed here }
	# for :npr do [int]:[] od { reserve empty table rows }
   , k=0 { last symmetric power computed}
in
( {order_W} nW
, {class_representatives} reps
, {class_of} class_nr_of
, {class_sizes} sizes
, {class_power} (int i,int n) int: let v=power_table[i] in v[n % #v]
, {trivial}     for :ncc do 1 od
, {sign}        for w in reps do minus_1^w.length od
, {reflection}  for w in reps do w.matrix.trace od
, {dimension}   ([int] val) int: val[e]
, {norm2} ([int] x) int: inner(x,x)
, {inner} inner
, {direct_sum}
  (([int],[int])(x,y):pair) [int]:
  assert(#x=ncc and #y=ncc,"Wrong sizes"); sum(pair)
, {Cartesian_power}
  ([int] x,int n) [int]: assert(#x=ncc,"Wrong size"); for v in x do n*v od
, {tensor}
  (([int],[int])(x,y):pair) [int]:
  assert(#x=ncc and #y=ncc,"Wrong sizes");  product(pair)
, {tensor_power}
   ([int] x, int n) [int]: assert(#x=ncc,"Wrong size"); for xi in x do xi^n od
, {sym_power_refl}
  (int n) [int]: assert(n<=npr,"No symmetric powers recorded beyond "+npr);
     while k<n { extend until |reflection_sympowers[n]| has been set }
     do k+:=1; reflection_sympowers[k] :=
        for j:ncc
	do let s=0, !chi=refl_char_poly[j] in
	   for i:min(chi_deg,k) from 1 { we have |#chi=chi_deg+1| }
	   do s-:=chi~[i]*reflection_sympowers[k-i][j]
	   od
	;  s
	od
     od
  ;  reflection_sympowers[n]
)

set W_class_table ( RootDatum rd
		  , [WeylElt] reps
		  , (WeylElt->int) class_size
		  , ConjugacyTester is_conjugate_to
		  ) = WeylClassTable:
   let memberships = [(WeylElt->bool)]: for r in reps do is_conjugate_to(r) od
   then class_of(WeylElt w) = int: first(#reps,(int i)bool: memberships[i](w))
in W_class_table( rd, reps
		, (int i) int: class_size(reps[i])
		, class_of
		, (int i, int k) int: let pred=is_conjugate_to(reps[i]^k) in
		    for r@j in reps do if pred(r) then return j fi od; minus_1
		)

{ a version with no help to find conjugacy classes, potentially much slower }
set W_class_table_generic (RootDatum rd) = WeylClassTable:
   W_class_table( rd, conjugacy_class_reps(rd)
		, size_of_conjugacy_class@WeylElt
		, conjugacy_test(Levi_reducer(rd),He_tester@([int],WeylElt))
		)

set W_class_table_untabled (RootDatum rd) = WeylClassTable:
   W_class_table( rd, conjugacy_class_reps(rd)
		, size_of_conjugacy_class@WeylElt
		, untabled_tester(He_tester@([int],WeylElt))
		)

{ A valid class table that can be used to initialise local variables }
set !trivial_class_table = W_class_table_generic(adjoint(""))

set n_classes (WeylClassTable tab) = int: #tab.class_representatives

set root_datum (WeylClassTable tab) = RootDatum:
    tab.class_representatives[0].root_datum { at least one class exists }

{ adapt an existing table to an externally imposed order of the classes }
set reorder (WeylClassTable tab, [WeylElt] reps) = WeylClassTable:
   let !n = tab.n_classes, rd = tab.root_datum
   then !class_map = [int]:
        assert(#reps=n,"There should be "+n+" class representatives")
      ; for w in reps do tab.class_of(w) od
in if class_map = #n then tab { no reordering needed }
   else
      let !inv_map = inverse(class_map)
      , sizes = for v in class_map do tab.class_sizes[v] od
      then export([int]chi) = [int]: for i:n do chi[class_map[i]] od
      , inner([int] x,[int] y) = int:
	 assert(#x=n and #y=n,"Wrong sizes");
	 let s = for size@i in sizes do size*x[i]*y[i] od.sum
	 then (q,r)=s \% tab.order_W
      in if r=0 then q else error("Non integer inner product ",s/tab.order_W) fi
   in
     ( {order_W} tab.order_W
     , {class_representatives} reps
     , {class_of} (WeylElt w) int: inv_map[tab.class_of(w)]
     , {class_sizes} sizes
     , {class_power} (int i,int k) int: inv_map[tab.class_power(class_map[i],k)]
     , {trivial}    tab.trivial { no reordering necessary here }
     , {sign}       tab.sign.export
     , {reflection} tab.reflection.export
     , {dimension}  let e=inv_map[tab.class_of(id_W(rd))] in ([int] v) int: v[e]
     , {norm2} ([int] x) int: inner(x,x)
     , {inner} inner
     , {direct_sum} tab.direct_sum { no change for reordering }
     , {Cartesian_power} tab.Cartesian_power { no change for reordering }
     , {tensor} tab.tensor { no change for reordering }
     , {tensor_power}  tab.tensor_power { no change for reordering }
     , {sym_power_refl} (int k)[int]: tab.sym_power_refl(k).export
     )
   fi

set class_representative (WeylClassTable tab) = (int i) WeylElt:
   tab.class_representatives[i]

set print_classes(WeylClassTable tab) = void:
   let data = ["nr","count","order","length","Levi type","representative"] #
     for w@i in tab.class_representatives
     do [ i.to_string
        , tab.class_sizes[i].to_string
        , w.order.to_string
        , w.length.to_string
        , w.Levi_datum.Lie_type.semisimple.str
	, w.to_string
        ]
     od
   in tabulate(data,"rrrrll",2," ")

{. index i for which w is conjugate to classes[i], in given WeylClassTable .}
set conjugacy_class_number (WeylClassTable ct,WeylElt w) = int: ct.class_of(w)

{. value of character at w\in W .}
set character_value (WeylClassTable ct, WeylElt w,[int] char) = int:
  char[ct.class_of(w)]

{ Adams's operation (not Jeff's): evaluate character at class of $w^n$ }
set Adams (WeylClassTable tab) = ([int]char, int n) [int]:
   for i:tab.n_classes do char[tab.class_power(i,n)] od

{ symmetric power of a character }
set sym_power (WeylClassTable tab) = ([int]char, int n) [int]:
{ with $h_k$ symmetric, $p_k$ Adams, use $kh_k=\sum_{i=0}{k-1} h_ip_{k-i}$ }
   let { define two local tables of characters, to be expanded in loop }
     p = { "power sum polynomials", results of Adams operations } [[int]]: [ ]
         { since there is no $p_0$, the $k$-the Adams operation gives the entry
           |p[k-1|, but never mind since we will always reverse-index |p| }
   , h = { "complete homogeneous polynomials", symmetric powers } [tab.trivial]
in for k:n from 1
   do p #:= tab.Adams(char,k) { expand }
   ;  let sum=p~[0]
   in for i:k-1 from 1 do sum:=tab.direct_sum(sum,tab.tensor(h[i],p~[i])) od
   ; h #:= for s in sum do s\k od { expand table by |sum\k| }
   od; h[n] { last symmetric power is the one we want }

{ exterior power of a character }
set ext_power (WeylClassTable tab) = ([int]char, int n) [int]:
{ with $e_k$ ext, $p_k$, use $ke_k=\sum_{i=0}{k-1}(-1)^{k-i-1} e_ip_{k-i}$ }
   let { define two local tables of characters, to be expanded in loop }
    sp = { "signed power sum polynomials", $(-1)^{i-1}p_i$ } [[int]]: [ ]
         { since there is no $p_0$, the $k$-the Adams operation gives the entry
           |p[k-1|, but never mind since we will always reverse-index |p| }
   , e = { "elementary symmetric polynomials", exterior powers } [tab.trivial]
in for k:n from 1
   do sp #:= tab.Cartesian_power(tab.Adams(char,k),minus_1^(k-1)) { expand }
   ;  let sum=sp~[0]
   in for i:k-1 from 1 do sum:=tab.direct_sum(sum,tab.tensor(e[i],sp~[i])) od
   ; e #:= for s in sum do s\k od { expand table by |sum\k| }
   od; e[n] { last symmetric power is the one we want }

{ Convenience functions }


{ test: sum of sizes of conjugacy class = |W| }
set test_size_of_conjugacy_classes (RootDatum rd,[WeylElt] c) = (int,int):
  (order_W(rd),sum(for w in c do  size_of_conjugacy_class(w)  od))

set test_size_of_conjugacy_classes (RootDatum rd) = bool:
  =test_size_of_conjugacy_classes(rd,conjugacy_class_reps(rd))

{. print order, length, Levi.}
set print_conjugacy_classes ([WeylElt] C) = void:
  let data=["order","length","Levi"] { column headers }
  # for w in C
    do [ w.order.to_string
       , w.length.to_string
       , w.Levi_datum.Lie_type.semisimple.str
       ]
    od
  in tabulate(data,"rrl",2," ")

{. print order, length, Levi.}
set print_conjugacy_classes_med ([WeylElt] C) = void:
  let data=["order","length","Levi","Cyclotomic"] { column headers }
  # for w in C
    do [ w.order.to_string
       , w.length.to_string
       , w.Levi_datum.Lie_type.semisimple.str
       , product_of_cyclotomic(rat_poly:("q",char_poly(w),())).to_string
       ]
    od
  in tabulate(data,"rrrl",2," ")

set print_conjugacy_classes_long ([WeylElt] C) = void:
  let data=["order","length","Levi","size","word"] { column headers }
  # for w in C
    do [ w.order.to_string
       , w.length.to_string
       , w.Levi_datum.Lie_type.semisimple.str
       , w.size_of_conjugacy_class.to_string
       , w.word.to_string
       ]
    od
  in tabulate(data,"rrlll",2," ")

set print_conjugacy_classes (RootDatum rd) = void:
  rd.conjugacy_class_reps.print_conjugacy_classes

set print_conjugacy_classes_long (RootDatum rd) = void:
  rd.conjugacy_class_reps.
  (sort_by(order@WeylElt, <=@(int,int))).
  print_conjugacy_classes_long

{. print elliptic classes only .}
set print_elliptic_conjugacy_classes (RootDatum rd) = void:
  elliptic_conjugacy_class_reps(rd).
  (sort_by(order@WeylElt, <=@(int,int))).
  print_conjugacy_classes

set print_elliptic_conjugacy_classes_long (RootDatum rd) = void:
  rd.elliptic_conjugacy_class_reps.
  (sort_by(order@WeylElt, <=@(int,int))).
  print_conjugacy_classes_long
