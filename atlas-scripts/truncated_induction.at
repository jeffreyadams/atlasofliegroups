<cells.at
<K_types.at
<springer_tables_reductive.at

{if pi is an irreducible representation of W_L, then
truncated induction takes pi to
the unique irreducible in Ind_{W(L)}^{W(G)}(pi_L)
of minimal degree (or an error if not unique)

truncated_induce_long returns (int min_degree,[int] characters)
min_degree is the minimal degree of all irreducibles
in Ind(pi_L)
characters is the list of characters in the induced of this degree
this list *should* have exactly one element
provide both ct_L and L, the latter so (unlike ct_L.root_datum) its
roots are a subset of the of G
}

set ti_verbose=true

{truncate character: keep only the components of minimal degree}
set truncate(CharacterTable ct_G,[int] char)=
let dec=ct_G.decompose(char) then
min_degree=ct_G.root_datum.nr_of_posroots then
rv=[int]:[] in
for i:#dec do
 if !=dec[i] then
  if ct_G.degrees[i]<min_degree then
   rv:=[i];min_degree:=ct_G.degrees[i]
  elif ct_G.degrees[i]=min_degree then rv#:=i
  fi
 fi
od;
if ti_verbose then
 prints("degree: ", min_degree,new_line,"index of character: ", rv[0], "  (all: ",rv,")")
fi;
(min_degree,rv)

{induce and truncate}
{basic version, using given embedding f}
set truncate_induce_character (CharacterTable ct_L,CharacterTable ct_G,(WeylElt->WeylElt) f,[int] pi_L) =
let ()=if ti_verbose then prints("Computing induced character: ") fi then
ind=induce_character(ct_L,ct_G,f,pi_L) then
()=if ti_verbose then prints("computed induced character: ", ind) fi then
 (,t)=truncate(ct_G,ind) then
 ()=if ti_verbose then prints("computed truncation of induced: ", t) fi in
assert(#t=1,"not a unique character in truncated induction");
t[0]

{standard form}
set truncate_induce_character(RootDatum L,RootDatum G,CharacterTable ct_L,CharacterTable ct_G,[int] pi_L)=
let ()=if ti_verbose then prints("Computing induced character: ") fi then
ind=induce_character(L,G,ct_L,ct_G,pi_L) then
()=if ti_verbose then prints("computed induced character: ", ind) fi then
(,t)=truncate(ct_G,ind) then
()=if ti_verbose then prints("computed truncation of induced: ", t) fi in
assert(#t=1,"not a unique character in truncated induction");
t[0]


{build ct_L, ct_G on the fly (slow)}
set truncate_induce_character(RootDatum L,RootDatum G,[int] pi_L)=
let ct_G=G.character_table then
ct_L=L.character_table in
truncate_induce_character(L,G,ct_L,ct_G,pi_L)

{build ct_L on the fly}
set truncate_induce_character(RootDatum L,RootDatum G,CharacterTable ct_G,[int] pi_L)=
let ct_L=L.character_table in
truncate_induce_character(L,G,ct_L,ct_G,pi_L)

{L is given as a subgroup of G, by specifying the simple roots of
L as a set of positive roots of G; for a Levi factor these
roots are simple for G}
set truncate_induce_character(RootDatum G,CharacterTable ct_G,[int] simple_roots_of_L,[int] pi_L)=
truncate(ct_G,induce_character(G,ct_G,simple_roots_of_L,pi_L))

{same as previous, build ct_G on the fly}
set truncate_induce_character(RootDatum G,[int] simple_roots_of_L,[int] pi_L)=
let ct_G=G.character_table in
truncate(ct_G,induce_character(G,ct_G,simple_roots_of_L,pi_L))

{induction of orbits}

{need Springer table for both L and G}
set induce_orbit(RootDatum L,RootDatum G,SpringerTable st_L,SpringerTable st_G,ComplexNilpotent O_L)=
let L=O_L.root_datum then
char_L=st_L.springer(O_L) then
()=if ti_verbose then prints("orbit_L: ", O_L.diagram,  new_line,"index of character_L: ", char_L, " (degree: ",st_L.ct.degrees[char_L],")") fi then
char_G=truncate_induce_character(L,G,st_L.ct,st_G.ct,st_L.ct.characters[char_L]) then
orbit=st_G.springer_inverse(char_G) in
if ti_verbose then prints("induced orbit: ", orbit.diagram,st_G.special_star(orbit)) fi;
orbit

{slow: computes Springer table for L and G}
set induce_orbit(RootDatum L,RootDatum G,ComplexNilpotent O_L)=
induce_orbit(L,G,L.springer_table, G.springer_table, O_L)

{not quite as slow: compute Springer table for L}
set induce_orbit(RootDatum L,RootDatum G,SpringerTable st_G,ComplexNilpotent O_L)=
induce_orbit(L,G,L.springer_table, st_G, O_L)

set test_induce_orbits(RootDatum G,[int] simple_roots_of_L)=
let L=Levi_datum(G,simple_roots_of_L) then
st_G=G.springer_table then
st_L=L.springer_table then
codim=G.dimension-L.dimension in
let ()=prints("codimension: ", codim) in
tabulate(
for O_L in L.orbits do
let O=induce_orbit(L,G,st_L,st_G,O_L) in
[O_L.diagram.to_string,O_L.dim_nilpotent.to_string,O.diagram.to_string,O.dim_nilpotent.to_string,(O_L.dim_nilpotent+codim-O.dim_nilpotent).to_string]
od
)

{only need Springer table for G, character table for L=integrality datum}
set associated_variety_ann(Param p,SpringerTable st_G,CharacterTable ct_int)=ComplexNilpotent:
let st=p.root_datum.springer_table then
()=if ti_verbose then prints("Computed Springer table") fi then
rd_int=integrality_datum(p.root_datum,p.infinitesimal_character) then
{ct_int=rd_int.character_table then}
special_character_int=special_character(ct_int,W_cell(p)) then
()=if ti_verbose then prints("Computed special_character_int: ", special_character_int) fi then
character_G=truncate_induce_character(rd_int,p.root_datum,ct_int,st.ct,ct_int.characters[special_character_int]) then
()=if ti_verbose then prints("Computed truncated induction: ", character_G)  fi then
orbit_0=st.springer_inverse(character_G) then
{might be for different root datum}
orbit=orbit_by_diagram(p.root_datum,orbit_0.diagram_normalized) in
if ti_verbose then
prints("orbit_0: ", orbit_0.diagram);
 prints("Special character: ", special_character_int, new_line,
 "orbit: ", orbit.diagram, st.special_star(orbit))
fi;
orbit

set associated_variety_ann(Param p,SpringerTable st_G)=ComplexNilpotent:
associated_variety_ann(p,st_G,integrality_datum(p.root_datum,p.infinitesimal_character).character_table)

set associated_variety_ann(Param p)=ComplexNilpotent:associated_variety_ann(p,p.root_datum.springer_table)

{assume all params have same G and same infinitesimal character}
{need Springer table for G and character table for integrality _datum}
set associated_variety_ann(SpringerTable st_G,CharacterTable ct_int,[Param] params)=[(Param,ComplexNilpotent)]:
if =#params then [] else
let p_0=params[0] then
rd_int=integrality_datum(p_0.root_datum,p_0.infinitesimal_character) in
for p in params do
 let special_character_int=special_character(ct_int,W_cell(p)) then
 character_G=truncate_induce_character(rd_int,p.root_datum,ct_int,st_G.ct,ct_int.characters[special_character_int]) then
 orbit_0=st_G.springer_inverse(character_G) then
 orbit=orbit_by_diagram(p.root_datum,orbit_0.diagram_normalized) in
 if ti_verbose then
  prints("orbit_0: ", orbit_0.diagram);
  prints("Special character: ", special_character_int, new_line,
  "orbit: ", orbit.diagram, st_G.special_star(orbit))
 fi;
(p,orbit) od fi

set associated_variety_ann([Param] params)=[(Param,ComplexNilpotent)]:
if =#params then [] else
let p_0=params[0] then
st=springer_table(p_0.root_datum) then
rd_int=integrality_datum(p_0.root_datum,p_0.infinitesimal_character) then
ct_int=rd_int.character_table in
for p in params do
 let special_character_int=special_character(ct_int,W_cell(p)) then
 character_G=truncate_induce_character(rd_int,p.root_datum,ct_int,st.ct,ct_int.characters[special_character_int]) then
 orbit_0=st.springer_inverse(character_G) then
 orbit=orbit_by_diagram(p.root_datum,orbit_0.diagram_normalized) in
 if ti_verbose then
  prints("orbit_0: ", orbit_0.diagram);
  prints("Special character: ", special_character_int, new_line,
  "orbit: ", orbit.diagram, st.special_star(orbit))
 fi;
(p,orbit) od fi

set show([(Param,ComplexNilpotent)] pairs)=tabulate(
["x","lambda","nu","diagram(O)","GK-dim"]#
for (p,O) in pairs~ do
 [(#p.x).to_string,compact_ratvec(p.lambda),compact_ratvec(p.nu),O.diagram.to_string,(O.dim_nilpotent\2).to_string] od)

set av(RealForm GC {should be complex}, ratvec gamma) {size rank(GC)/2}=
let p=parameter(GC.x_open,GC.rho,gamma##gamma) then
p=parameter(GC.x_open,GC.rho,gamma##gamma) in
associated_variety_ann(p)

set av_maximal_ideal(RootDatum G,ratvec gamma,SpringerTable st,CharacterTable ct_int)=
let GC=complexification(G) then
p_final=finalize(parameter(GC.x_open,GC.rho,gamma##gamma)).first_param then
()=assert(LKT(p_final)=LKT(GC.trivial),"nonspherical representation") then
()=prints("computing av_ann of ",p_final) then
av=associated_variety_ann(p_final,st,ct_int) then
H=av.H then
orbit=ComplexNilpotent:(G,(),H[#H\2:]) in
prints("diagram of orbit: ", orbit.diagram);orbit

{integral case: get ct from st}
set av_maximal_ideal_int(RootDatum G,ratvec gamma,SpringerTable st)=
assert(is_integral(G,gamma),"infinitesimal character is not integral");
av_maximal_ideal(G,gamma,st,st.ct)

set av_maximal_ideal(RootDatum G,ratvec gamma,SpringerTable st)=
av_maximal_ideal(G,gamma,st,character_table(integrality_datum(complexification(G),gamma##gamma)))

set av_maximal_ideal(RootDatum G,ratvec gamma)=
av_maximal_ideal(G,gamma,G.springer_table)