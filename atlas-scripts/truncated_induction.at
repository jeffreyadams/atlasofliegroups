<springer_tables_reductive.at

{if pi is an irreducible representation of W_L, then
truncated induction takes pi to
the unique irreducible in Ind_{W(L)}^{W(G)}(pi_L)
of minimal degree (or an error if not unique)

truncated_induce_long returns (int min_degree,[int] characters)
min_degree is the minimal degree of all irreducibles
in Ind(pi_L)
characters is the list of characters in the induced of this degree
this list *should* have exactly one element
provide both ct_L and L, the latter so (unlike ct_L.root_datum) its
roots are a subset of the of G
}

set ti_verbose=false

{truncate character: keep only the components of minimal degree,
according to degree_function (degree or generic_degree)
returns (degree, list of indices of characters of this degree)
}

{degree_function: degree or generic_degree}
set truncate(CharacterTable ct_G,[int] char,(int->int) degree_function) =
      (int,[int]):  {first argument: value of degree function}
let dec=ct_G.decompose(char) then
()=if ti_verbose then prints("truncating character: ", char, new_line,"decomposed: ", dec) fi then
()=if ti_verbose then prints("all terms: ", ##for a@i in dec do if !=a then [(i,a)] else [] fi od) fi then
min_degree=ct_G.root_datum.nr_of_posroots then
rv=[int]:[] in
for i:#dec do
 if !=dec[i] then
    let degree= degree_function(i) in
  if degree<min_degree and degree>=0 then
   rv:=[i];min_degree:=degree
  elif degree=min_degree then rv#:=i
  fi
 fi
od;
if ti_verbose then
 prints("degree: ", min_degree,new_line,"index of character: ", rv[0], "  (all: ",rv,")")
fi;
(min_degree,rv)


set truncate(SpringerTable st_G,[int] char,(int->int) degree_function)=(int,[int]):truncate(st_G.ct,char,degree_function)

{induce and truncate}
{basic version, using given embedding f
 degree function is either degree or generic_degree
 return value is [int] since this can happen in the generic_degree case}
set truncate_induce_character(
   CharacterTable ct_L,
   CharacterTable ct_G,
   (WeylElt->WeylElt) f,
   (int->int) degree_function,
   [int] pi_L) =
      (int,[int]):
let ()=if ti_verbose then prints("Computing induced character: ") fi then
ind=induce_character(ct_L,ct_G,f,pi_L) then
()=if ti_verbose then prints("computed induced character: ", ind) fi then
 t=truncate(ct_G,ind,degree_function) then
 ()=if ti_verbose then prints("computed truncation of induced", new_line,"induced: ", t) fi in
t

{standard form: ordinary degree, returns int}
set truncate_by_degree_induce_character(RootDatum L,RootDatum G,CharacterTable ct_L,CharacterTable ct_G,[int] pi_L)=int:
let f(int j)=ct_G.degrees[j] in
let ()=if ti_verbose then prints("Computing induced character: ") fi then
ind=induce_character(L,G,ct_L,ct_G,pi_L) then
()=if ti_verbose then prints("computed induced character: ", ind) fi then
(,t)=truncate(ct_G,ind,f) then
 ()=if ti_verbose then prints("computed truncation of induced", new_line,"induced: ", t) fi in
assert(#t=1,"not a unique character in truncated induction");
t[0]

{standard form}
set truncate_degree_induce_character(RootDatum L,RootDatum G,CharacterTable ct_L,CharacterTable ct_G,[int] pi_L,(int->int) degree_function)=
(int,[int]):
let ()=if ti_verbose then prints("Computing induced character: ") fi then
ind=induce_character(L,G,ct_L,ct_G,pi_L) then
()=if ti_verbose then prints("computed induced character: ", ind) fi then
(deg,t)=truncate(ct_G,ind,degree_function) then
 ()=if ti_verbose then prints("computed truncation of induced",  new_line,"induced: ", t) fi in
(deg,t)

set truncate_induce_character(RootDatum L,RootDatum G,CharacterTable ct_L,CharacterTable ct_G,[int] pi_L,(int->int) degree_function)=(int,[int]):
truncate_degree_induce_character(L,G,ct_L,ct_G,pi_L,degree_function)


{build ct_L, ct_G on the fly (slow)}
set truncate_induce_character(RootDatum L,RootDatum G,[int] pi_L,(int->int) degree_function)=(int,[int]):
let ct_G=G.character_table then
ct_L=L.character_table in
truncate_induce_character(L,G,ct_L,ct_G,pi_L,degree_function)

{build ct_L on the fly}
set truncate_induce_character(RootDatum L,RootDatum G,CharacterTable ct_G,[int] pi_L,(int->int) degree_function)=(int,[int]):
let ct_L=L.character_table in
truncate_induce_character(L,G,ct_L,ct_G,pi_L,degree_function)

{L is given as a subgroup of G, by specifying the simple roots of
L as a set of positive roots of G; for a Levi factor these
roots are simple for G
}
set truncate_induce_character(RootDatum G,CharacterTable ct_G,[int] simple_roots_of_L,[int] pi_L,(int->int) degree_function)=(int,[int]):
truncate(ct_G,induce_character(G,ct_G,simple_roots_of_L,pi_L),degree_function)

{standard form: by degree, returns int}
set truncate_by_degree_induce_character(RootDatum G,CharacterTable ct_G,[int] simple_roots_of_L,[int] pi_L)=int:
let f(int i)=ct_G.degrees[i] then
(,t)=truncate(ct_G,induce_character(G,ct_G,simple_roots_of_L,pi_L),f)
in assert(#t=1,"not a unique character in truncated induction");t[0]

{same as previous, build ct_G on the fly}
set truncate_induce_character(RootDatum G,[int] simple_roots_of_L,[int] pi_L,(int->int) degree_function)=[int]:
let ct_G=G.character_table in
let (,t)=truncate(ct_G,induce_character(G,ct_G,simple_roots_of_L,pi_L),degree_function) in t

{induction of orbits}

{need Springer table for both L and G}
set induce_orbit(RootDatum L,RootDatum G,SpringerTable st_L,SpringerTable st_G,ComplexNilpotent O_L)=ComplexNilpotent:
let L=O_L.root_datum then
char_L=st_L.springer(O_L) then
()=if ti_verbose then prints("orbit_L: ", O_L.diagram,  new_line,"index of character_L: ", char_L, " (degree: ",st_L.ct.degrees[char_L],")") fi then
degree_function=(int->int): (int j):st_G.ct.degrees[j] then
(,char_G)=truncate_induce_character(L,G,st_L.ct,st_G.ct,st_L.ct.characters[char_L],degree_function) then
()=assert(#char_G=1,"not a unique term with given degree") then
(valid,orbit)=st_G.springer_inverse(char_G[0]) in
assert(valid,"induced orbit doesn't have springer_inverse");
if ti_verbose then prints("induced orbit: ", orbit.diagram,st_G.special_star(orbit)) fi;
orbit

{slow: computes Springer table for L and G}
set induce_orbit(RootDatum L,RootDatum G,ComplexNilpotent O_L)=ComplexNilpotent:
induce_orbit(L,G,L.springer_table, G.springer_table, O_L)

{not quite as slow: compute Springer table for L}
set induce_orbit(RootDatum L,RootDatum G,SpringerTable st_G,ComplexNilpotent O_L)=ComplexNilpotent:
induce_orbit(L,G,L.springer_table, st_G, O_L)

set test_induce_orbits(RootDatum G,[int] simple_roots_of_L)=void:
let L=Levi_datum(G,simple_roots_of_L) then
st_G=G.springer_table then
st_L=L.springer_table then
codim=G.dimension-L.dimension in
let ()=if ti_verbose then prints("codimension: ", codim)  fi in
tabulate(
for O_L in L.orbits do
let O=induce_orbit(L,G,st_L,st_G,O_L) in
[O_L.diagram.to_string,O_L.dim_nilpotent.to_string,O.diagram.to_string,O.dim_nilpotent.to_string,(O_L.dim_nilpotent+codim-O.dim_nilpotent).to_string]
od
)
