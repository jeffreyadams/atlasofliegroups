<cells.at
<K_types.at
<springer_tables_reductive.at

{if pi is an irreducible representation of W_L, then
truncated induction takes pi to
the unique irreducible in Ind_{W(L)}^{W(G)}(pi_L)
of minimal degree (or an error if not unique)

truncated_induce_long returns (int min_degree,[int] characters)
min_degree is the minimal degree of all irreducibles
in Ind(pi_L)
characters is the list of characters in the induced of this degree
this list *should* have exactly one element
provide both ct_L and L, the latter so (unlike ct_L.root_datum) its
roots are a subset of the of G
}

set ti_verbose=true

{truncate character: keep only the components of minimal degree}
set truncate(CharacterTable ct_G,[int] char)=
let dec=ct_G.decompose(char) then
min_degree=ct_G.root_datum.nr_of_posroots then
rv=[int]:[] in
for i:#dec do
 if !=dec[i] then
  if ct_G.degrees[i]<min_degree then
   rv:=[i];min_degree:=ct_G.degrees[i]
  elif ct_G.degrees[i]=min_degree then rv#:=i
  fi
 fi
od;
if ti_verbose then
 prints("degree: ", min_degree,new_line,"index of character: ", rv[0], "  (all: ",rv,")")
fi;
(min_degree,rv)

{induce and truncate}
{basic version, using given embedding f}
set truncate_induce_character (CharacterTable ct_L,CharacterTable ct_G,(WeylElt->WeylElt) f,[int] pi_L) =
let ()=if ti_verbose then prints("Computing induced character: ") fi then
ind=induce_character(ct_L,ct_G,f,pi_L) then
()=if ti_verbose then prints("computed induced character: ", ind) fi then
 (,t)=truncate(ct_G,ind) then
 ()=if ti_verbose then prints("computed truncation of induced: ", t) fi in
assert(#t=1,"not a unique character in truncated induction");
t[0]

{standard form}
set truncate_induce_character(RootDatum L,RootDatum G,CharacterTable ct_L,CharacterTable ct_G,[int] pi_L)=
let ()=if ti_verbose then prints("Computing induced character: ") fi then
ind=induce_character(L,G,ct_L,ct_G,pi_L) then
()=if ti_verbose then prints("computed induced character: ", ind) fi then
(,t)=truncate(ct_G,ind) then
()=if ti_verbose then prints("computed truncation of induced: ", t) fi in
assert(#t=1,"not a unique character in truncated induction");
t[0]


{build ct_L, ct_G on the fly (slow)}
set truncate_induce_character(RootDatum L,RootDatum G,[int] pi_L)=
let ct_G=G.character_table then
ct_L=L.character_table in
truncate_induce_character(L,G,ct_L,ct_G,pi_L)

{build ct_L on the fly}
set truncate_induce_character(RootDatum L,RootDatum G,CharacterTable ct_G,[int] pi_L)=
let ct_L=L.character_table in
truncate_induce_character(L,G,ct_L,ct_G,pi_L)

{L is given as a subgroup of G, by specifying the simple roots of
L as a set of positive roots of G; for a Levi factor these
roots are simple for G}
set truncate_induce_character(RootDatum G,CharacterTable ct_G,[int] simple_roots_of_L,[int] pi_L)=
truncate(ct_G,induce_character(G,ct_G,simple_roots_of_L,pi_L))

{same as previous, build ct_G on the fly}
set truncate_induce_character(RootDatum G,[int] simple_roots_of_L,[int] pi_L)=
let ct_G=G.character_table in
truncate(ct_G,induce_character(G,ct_G,simple_roots_of_L,pi_L))

{induction of orbits}

{need Springer table for both L and G}
set induce_orbit(RootDatum L,RootDatum G,SpringerTable st_L,SpringerTable st_G,ComplexNilpotent O_L)=
let L=O_L.root_datum then
char_L=st_L.springer(O_L) then
()=if ti_verbose then prints("orbit_L: ", O_L.diagram,  new_line,"index of character_L: ", char_L, " (degree: ",st_L.ct.degrees[char_L],")") fi then
char_G=truncate_induce_character(L,G,st_L.ct,st_G.ct,st_L.ct.characters[char_L]) then
orbit=st_G.springer_inverse(char_G) in
if ti_verbose then prints("induced orbit: ", orbit.diagram,st_G.special_star(orbit)) fi;
orbit

{slow: computes Springer table for L and G}
set induce_orbit(RootDatum L,RootDatum G,ComplexNilpotent O_L)=
induce_orbit(L,G,L.springer_table, G.springer_table, O_L)

{not quite as slow: compute Springer table for L}
set induce_orbit(RootDatum L,RootDatum G,SpringerTable st_G,ComplexNilpotent O_L)=
induce_orbit(L,G,L.springer_table, st_G, O_L)

set test_induce_orbits(RootDatum G,[int] simple_roots_of_L)=
let L=Levi_datum(G,simple_roots_of_L) then
st_G=G.springer_table then
st_L=L.springer_table then
codim=G.dimension-L.dimension in
let ()=prints("codimension: ", codim) in
tabulate(
for O_L in L.orbits do
let O=induce_orbit(L,G,st_L,st_G,O_L) in
[O_L.diagram.to_string,O_L.dim_nilpotent.to_string,O.diagram.to_string,O.dim_nilpotent.to_string,(O_L.dim_nilpotent+codim-O.dim_nilpotent).to_string]
od
)

{----- associated variety of annihlator  ----}

{many variants: precalculating the Springer table of G, or the character table of
the integrality datum, for speed
options:
associated_variety_ann_int(SpringerTable st_G,Param p)=
associated_variety_ann_int(Param p)=associated_variety_ann_int(p.root_datum.springer_table,p)
associated_variety_ann(SpringerTable st_G,CharacterTable ct_int,Param p)=
associated_variety_ann(SpringerTable st_G,Param p)=ComplexNilpotent:
associated_variety_ann(Param p)=ComplexNilpotent:
associated_variety_ann_int(SpringerTable st_G,[Param] params)=
associated_variety_ann_int([Param] params)=
associated_variety_ann(SpringerTable st_G,CharacterTable ct_int,[Param] params)=[(Param,ComplexNilpotent)]:
associated_variety_ann(SpringerTable st_G,[Param] params)=[(Param,ComplexNilpotent)]:
associated_variety_ann([Param] params)=[(Param,ComplexNilpotent)]:
}

{assuming infinitesimal character is integral, with precomputed Springer table}
set associated_variety_ann_int(SpringerTable st_G,Param p)=
assert(is_integral(p.root_datum,p.infinitesimal_character), "infinitesimal character must be integral");
if ti_verbose then prints("associated_variety_ann_int with given Springer table") fi;
let character_G=special_character(st_G.ct,W_cell(p)) then
 ()=if ti_verbose then prints("Computed character_G: ", character_G,
      new_line, "(integral infinitesimal character, no induction needed)") fi then
 orbit_0=st_G.springer_inverse(character_G) then
 {might be for different root datum}
 orbit=orbit_by_diagram(p.root_datum,orbit_0.diagram_normalized) in
 if ti_verbose then
  prints("orbit_0: ", orbit_0.diagram);
  prints("Special character: ", character_G, new_line,
  "orbit: ", orbit.diagram, st_G.special_star(orbit))
 fi; orbit

{compute Springer table}
set associated_variety_ann_int(Param p)=associated_variety_ann_int(p.root_datum.springer_table,p)

{provide Springer table for G, character table for L=integrality datum}
set associated_variety_ann(SpringerTable st_G,CharacterTable ct_int,Param p)=
let ()=if ti_verbose then prints("associated_variety_ann with given Springer and character tables") fi in
let orbit=
if is_integral(p.root_datum,p.infinitesimal_character) then
  if ti_verbose then prints("integral infinitesimal character") fi;
  associated_variety_ann_int(st_G,p)
else
 let rd_int=integrality_datum(p) then
 special_character_int=special_character(ct_int,W_cell(p)) then
 ()=if ti_verbose then prints("Computed special_character_int: ", special_character_int) fi then
 character_G=truncate_induce_character(rd_int,p.root_datum,ct_int,st_G.ct,ct_int.characters[special_character_int]) then
 ()=if ti_verbose then prints("Computed truncated induction: ", character_G) fi then
 orbit_0=st_G.springer_inverse(character_G) then
 {might be for different root datum}
 orbit=orbit_by_diagram(p.root_datum,orbit_0.diagram_normalized) in
 if ti_verbose then
  prints("orbit_0: ", orbit_0.diagram);
  prints("Special character: ", special_character_int, new_line,
  "orbit: ", orbit.diagram, st_G.special_star(orbit))
 fi;orbit
fi in orbit

{provide Springer table for G, calculate character table for rd_int if needed}
set associated_variety_ann(SpringerTable st_G,Param p)=ComplexNilpotent:
if ti_verbose then prints("associated_variety_ann with given Springer table") fi;
if is_integral(p.root_datum,p.infinitesimal_character) then
 if ti_verbose then prints("infinitesimal character is integral, no need to compute character table") fi;
 associated_variety_ann_int(st_G,p)
else
 let ct_int=character_table(integrality_datum(p)) in
 if ti_verbose then prints("calculated character table for integral datum: ", ct_int.root_datum) fi;
associated_variety_ann(st_G,ct_int,p)
fi

{compute Springer table, and character table if needed}
set associated_variety_ann(Param p)=ComplexNilpotent:
if ti_verbose then prints("associated_variety_ann: Computing Springer table, and character table if needed") fi;
let st=p.root_datum.springer_table in
if ti_verbose then prints("done computing Springer table") fi;
associated_variety_ann(p.root_datum.springer_table,p)

{----------list of parameters versions---------}

{assume all params have integral infinitesimal character}
set associated_variety_ann_int(SpringerTable st_G,[Param] params)=
assert(is_integral(params[0].root_datum,params[0].infinitesimal_character), "infinitesimal character must be integral");
if ti_verbose then prints("associated_variety_ann_int with given Springer table") fi;
for p in params do
let character_G=special_character(st_G.ct,W_cell(p)) then
 ()=if ti_verbose then prints("Computed character_G: ", character_G,
      new_line, "(integral infinitesimal character, no induction needed)") fi then
 orbit_0=st_G.springer_inverse(character_G) then
 {might be for different root datum}
 orbit=orbit_by_diagram(p.root_datum,orbit_0.diagram_normalized) in
 if ti_verbose then
  prints("orbit_0: ", orbit_0.diagram);
  prints("Special character: ", character_G, new_line,
  "orbit: ", orbit.diagram, st_G.special_star(orbit))
 fi; orbit
od

{all parameters must have integral infinitesimal character}
set associated_variety_ann_int([Param] params)=
if ti_verbose then prints("associated_variety_ann_int with ", #params, " parameters",new_line, "Computing Springer table") fi;
assert(is_integral(params[0].root_datum,params[0].infinitesimal_character),"infinitesimal character is not integral");
let st=params[0].root_datum.springer_table in
if ti_verbose then prints("done computing Springer table") fi ;
associated_variety_ann_int(st,params)

{assume all params have same infinitesimal character}
{need Springer table for G and character table for integrality _datum}
set associated_variety_ann(SpringerTable st_G,CharacterTable ct_int,[Param] params)=[(Param,ComplexNilpotent)]:
if ti_verbose then prints("associated_variety_ann with given Springer table, character table, and ", #params, " parameters") fi;
if =#params then [] else
let p_0=params[0] then
rd_int=integrality_datum(p_0) in
for p in params do
 let special_character_int=special_character(ct_int,W_cell(p)) then
 character_G=truncate_induce_character(rd_int,p.root_datum,ct_int,st_G.ct,ct_int.characters[special_character_int]) then
 orbit_0=st_G.springer_inverse(character_G) then
 orbit=orbit_by_diagram(p.root_datum,orbit_0.diagram_normalized) in
 if ti_verbose then
  prints("orbit_0: ", orbit_0.diagram);
  prints("Special character: ", special_character_int, new_line,
  "orbit: ", orbit.diagram, st_G.special_star(orbit))
 fi;
(p,orbit) od fi

set associated_variety_ann(SpringerTable st_G,[Param] params)=[(Param,ComplexNilpotent)]:
let gamma=params[0].infinitesimal_character in
if is_integral(st_G.root_datum,gamma) then
 associated_variety_ann(st_G,st_G.ct,params)
else
 let rd_int=integrality_datum(params[0]) then
 ct_int=rd_int.character_table in
 associated_variety_ann(st_G,ct_int,params)
fi

set associated_variety_ann([Param] params)=[(Param,ComplexNilpotent)]:
if ti_verbose then prints("associated_variety_ann, computing Springer table and character table if necessary") fi;
let st=params[0].root_datum.springer_table in
if ti_verbose then prints("done computing Springer table") fi;
associated_variety_ann(st,params)

{nice output}
set show([(Param,ComplexNilpotent)] pairs)=tabulate(
["x","lambda","nu","diagram(O)","GK-dim"]#
for (p,O) in pairs~ do
 [(#p.x).to_string,compact_ratvec(p.lambda),compact_ratvec(p.nu),O.diagram.to_string,(O.dim_nilpotent\2).to_string] od)

{associated variety of spherical representation of complex group,
with given infinitesimal character/nu parameter}
set associated_variety_of_spherical(RealForm GC {should be complex}, ratvec gamma) {size rank(GC)/2}=
let p=parameter(GC.x_open,GC.rho,gamma##gamma) then
p=parameter(GC.x_open,GC.rho,gamma##gamma) in
associated_variety_ann(p)

{associated variety of maximal ideal with given infinitesimal character gamma
algorithm:
if G is complex: compute associated variety of spherical representation with
infinitesimal character gamma
if G is not complex, set GC=complexification of G 
compute associated variety OC of spherical representation with nu parameter
(gamma,gamma)
Then OC has semisimple element of the form (H,H), this gives
the orbit for G with semsimple component H
}

{assuming G is a real group; given Springer table is for GC,
character table is for integrality datum of GC}

set associated_variety_of_maximal_ideal(RootDatum G,ratvec gamma,SpringerTable st_GC,CharacterTable ct_GC_int)=
let GC=complexification(G) then
p_final=finalize(parameter(GC.x_open,GC.rho,gamma##gamma)).first_param then
()=assert(LKT(p_final)=LKT(GC.trivial),"nonspherical representation") then
()=prints("computing associated_variety_ann of ",p_final) then
av=associated_variety_ann(st_GC,ct_GC_int,p_final) then
H=av.H then
orbit=ComplexNilpotent:(G,(),H[#H\2:]) in
prints("diagram of orbit: ", orbit.diagram, " dimension: ", orbit.dim_nilpotent);orbit

{integral case: get ct from st}
set associated_variety_maximal_ideal_int(RootDatum G,ratvec gamma,SpringerTable st)=
assert(is_integral(G,gamma),"infinitesimal character is not integral");
associated_variety_of_maximal_ideal(G,gamma,st,st.ct)

{if G is already complex, don't need to complexify again}
set associated_variety_of_maximal_ideal_C(RealForm GC,ratvec gamma,SpringerTable st_GC)=
let p_final=finalize(parameter(GC.x_open,GC.rho,gamma)).first_param then
()=assert(LKT(p_final)=LKT(GC.trivial),"nonspherical representation") then
()=prints("computing associated_varity_ann of ",p_final) then
av=associated_variety_ann(st_GC,p_final) then
H=av.H then
orbit=ComplexNilpotent:(G,(),H) in
prints("diagram of orbit: ", orbit.diagram, " dimension: ", orbit.dim_nilpotent);orbit

set associated_variety_of_maximal_ideal(RootDatum G,ratvec gamma,SpringerTable st_GC)=
assert(is_locally_isomorphic(complexification(G).derived,st_GC.root_datum), "Springer table must be for the complexification of G");
associated_variety_of_maximal_ideal(G,gamma,st_GC,character_table(integrality_datum(complexification(G),gamma##gamma)))

set associated_variety_of_maximal_ideal(RootDatum G,ratvec gamma)=
associated_variety_of_maximal_ideal(G,gamma,G.complexification.springer_table)