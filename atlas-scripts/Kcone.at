<K.at
<K_types.at
<to_ht.at

{.compute the cones of K-types above and below a fixed one.}
{
atlas identifies

irr of K  <---> irr tempered of real infl char
LKT(p)  <----   p
 mu       ----->  parameter(mu)

The partial order on K-hat is generated by the relations

mu \ge mu_0 if mu occurs in [WRONG: parameter(mu)|_K] [CORRECTION:
SOME standard with mu_0 as a LKT]. These relations in turn can be
understood by looking at the branching to K algorithm. I haven't done
that with enough care, but I think that they are close to what is
impleented below.  }

set standardize(K_Type mu) = K_Type_Pol:
standardize(parameter(mu)*0)

set standardize(K_Type_Pol P) = K_Type_Pol:
0*P + for c@p in P do standardize(p*0) od

set height(K_Type mu)=height(parameter(mu))

set find(Param p,ParamPol P)=bool:
   let list=monomials(P) in any(for q in list do p=q od)


{all K_types that occur with mu as LKTs in some standard module}
set R_packet(K_Type (x,lam))=ParamPol:
   let G=real_form(x),zero=0*lam, L=Levi_by_wt(lam+x.involution*lam,x)
   then kgbs=##for y in KGB(L)
               do let xprime = embed_KGB(y,G)
                 in if xprime.involution = x.involution then [xprime] else []
	            fi
	       od
   then result=null_module(G)
   in for xp in kgbs do result+:=standardize(parameter(xp,lam,zero))
                     od; result

set R_packet(Param p)=R_packet(LKTs(p)[0])

{Move one step down from mu in the partial order; may result in extra terms}
set pre_down(K_Type mu) = ParamPol:
   let q=parameter(mu), Q=LKT(parameter(mu))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in result+:=R
	   fi
	od; result

set pre_down(Param p)=pre_down(LKTs(p)[0])

set down_old(K_Type mu) = ParamPol:
   let q=parameter(mu), Q=LKT(parameter(mu))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in for m in monomials(R)
	              do if {find(q,branch_std(m,HT)) then result+:=m}
		      	    split_as_int(K_type_formula(m)[q]) < 0 then result+:=m
                         fi
	              od
	 fi od;
   result

{The function down@ParamPol (below) without test for removal}
set down_alt(ParamPol P)=ParamPol:
let result=null_module(P.real_form) in
for @p in P do result+:=pre_down(p) od; result

{Move down one step in the partial order for a list of K-types, assumed to
be in one R-packet; remove any K-types whose K_type_formula does not
contain any negative term from the list}
set down(ParamPol P)=ParamPol:
 {  let G=real_form(P), list=monomials(P) }
   let result=null_module(P.real_form) in
  for @p in P
       do for @m in pre_down(p)
          do if any(for @r in P do split_as_int(K_type_formula(m)[r])
				     < 0 od)
	     then result+:=m
	     fi
	  od
	od; result

set down_alt(K_Type mu)= { prints("Height of mu=
   ",height(parameter(mu))); }
   down_alt(R_packet(mu))

set down_alt(Param p)=down_alt(R_packet(p))

set down(K_Type mu)= {prints("Height of mu= ",height(parameter(mu)));}
   down(R_packet(mu))

set down(Param p)=down(R_packet(p))

{test whether the K-type is at the bottom of the preorder}
set bottom(K_Type mu) = bool:
    down(mu) = 0*mu

set down_cone(K_Type mu) = K_Type_Pol:
   let seen=ParamPol:null_module(mu.real_form)
   then result=seen
    in parameter(mu).( rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down(tau) do F(p); result +:= p od
        fi); result

{ omit testing }
set down_cone_alt(K_Type mu) = K_Type_Pol:
let seen=ParamPol:null_module(mu.real_form) then result=seen in
parameter(mu).( rec_fun F (Param tau) void:
if seen[tau].!= then ()
else seen +:= tau; for @p in down_alt(tau) do F(p); result +:= p od
fi); result

{up assumes mu = (x',lambda') is standard but perhaps not normal, and
nonzero. Moves one (possibly non-simple) step up in the partial
order.}


{Move one step up in the partial order of K-types}
set up(K_Type mu)=ParamPol:
   let result=null_module(real_form(mu))
   in for @m in R_packet(mu)
       do for c@p in K_type_formula(m)
                        do if int_part(c)<0 then result+:=p fi
                        od
		    od; result


{As previous function, but remove some terms that are further
up in the partial order}
set up_plus(K_Type mu)=ParamPol:
   let NM=null_module(real_form(mu)),start=up(mu)
   then result=NM
   in while start!=NM do let p=first_param(start)
                         in for q in monomials(start)
			    do if p!=q and K_type_formula(p)[q]!=0
			    then start-:=q
			       fi
			    od; start-:=p; result+:=p
		      od; result

set rec_fun up_cone(K_Type mu, int bound) = K_Type_Pol:
     if to_ht(bound)(up(mu)) = 0*mu then 0*mu
      else let result = 0*mu
            in result +:= to_ht(bound)(up(mu))
	         + for c@p in up(mu) do up_cone(K_type(p),bound)
		                     od fi

{set down_cone(K_Type mu) = K_Type_Pol:
   let seen=ParamPol:null_module(mu.real_form)
   then result=seen
    in parameter(mu).( rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down(tau) do F(p); result +:= p od
        fi); result}


set test_down(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_down_alt(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_alt(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_down_cone(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_cone(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_up(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(up(mu))
      do prints(p," ",height(p)," ",find(p,branch_std(q,height(p)))) od

set test_up_cone(K_Type mu,int n)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(up_cone(mu,n))
      do prints(p," ",height(p)," ",find(p,branch_std(q,height(p)))) od

{Test functions}
set rec_fun down_cone_alt(K_Type mu) = K_Type_Pol:
   let result = 0*mu
     in result +:= down_alt(mu) + for c@p in down_alt(mu) do down_cone_alt(K_type(p))
                                                       od

set test_down_cone_alt(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_cone_alt(mu))
   do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od
