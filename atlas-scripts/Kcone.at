<K.at
<K_types.at
<to_ht.at

{.compute the cones of K-types above and below a fixed one.}
{
atlas identifies

irr of K  <---> irr tempered of real infl char
LKT(p)  <----   p
 mu       ----->  parameter(mu)

The partial order on K-hat is generated by the relations

mu \ge mu_0 if mu occurs in parameter(mu)|_K. These relations in turn
can be understood by looking at the branching to K algorithm. I
haven't done that with enough care, but I think that they are close to
what is impleented below.
}

set standardize(K_Type mu) = K_Type_Pol:
standardize(parameter(mu)*0)

set standardize(K_Type_Pol P) = K_Type_Pol:
0*P + for c@p in P do standardize(p*0) od

set first_K_type(K_Type_Pol P) = K_type(first_param(P))

{down assumes mu = (x',lambda') is standard and nonzero but perhaps
not normal. Moves one (possibly non-simple) step down in the partial
order.}
{case avee noncompact imaginary needs an explicit Cayley??}

{set down(K_Type mu) = K_Type_Pol:
let q=parameter(mu), Q=LKTs(parameter(mu)) then HT=height(q), lambda =
Q[0].lambda then Lambda = lambda + (Q[0].x.involution)*lambda,
rd=mu.root_datum, zeroPol = null_module(q.real_form),
zero = 0*mu, zeronu=0*lambda in
zero+ ##for p in Q do let x=p.x  in for avee@j in
poscoroots(rd) do let R =  to_ht(HT-1)(standardize(standardize(parameter(x,
lambda-posroots(rd)[j], zeronu))*0))
 in if (Lambda*avee > 0 and not(is_compact(j,x)))
     then R else zero fi od od}

set down(K_Type mu) = ParamPol:
   let q=parameter(mu), Q=LKT(parameter(mu))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R =  to_ht(HT-1)(standardize(standardize(parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in for m in monomials(R)
	              do if find(q,branch_std(m,HT)) then result+:=m
                         fi
	              od
	 fi od;
   result


{test whether the K-type is at the bottom of the preorder}
set bottom(K_Type mu) = bool:
not(down(mu) = 0*mu)

set rec_fun down_cone(K_Type mu) = K_Type_Pol:
let result = 0*mu in
{ if bottom(mu) then result+:=0*mu else }
result +:= down(mu) + for
c@p in down(mu) do down_cone(K_type(p)) od {fi}

{up assumes mu = (x',lambda') is standard but perhaps not normal, and
nonzero. Moves one (possibly non-simple) step up in the partial
order.}

{S needs a separate case for avee real parity: CAYLEY. This should
only be needed when avee is simple as a real root(??). In that case
lambda*avee is meant to be ODD (otherwise the K-type was not final). I
HOPE that the formula
lambda' = lambda-(lambda*avee)*posroots(rd)[j]\2
then gives lambda'*avee = 1.
}
set up(K_Type mu) = K_Type_Pol:
let q=parameter(mu), Q=LKTs(parameter(mu)) then HT=height(q), lambda =
Q[0].lambda then Lambda = lambda + (Q[0].x.involution)*lambda,
rd=mu.root_datum, zeroPol = null_module(q.real_form),
zero = 0*mu, zeronu=0*lambda in
zero+ ##for p in Q do let x=p.x  in for avee@j in
poscoroots(rd) do let S=
case #is_real(j,x)
 in standardize(standardize(parameter(x,lambda+posroots(rd)[j], zeronu))*0),
standardize(standardize(parameter(Cayley(j,x), lambda-((lambda*avee)\2)*posroots(rd)[j], zeronu))*0) +
  standardize(standardize(parameter(cross(j,Cayley(j,x)), lambda-((lambda*avee)\2)*posroots(rd)[j]\2, zeronu))*0)
esac
then R = S- to_ht(HT)(S)
 in if (Lambda*avee >= 0 and not(is_compact(j,x))) then R
 else zero fi
od od

set rec_fun up_cone(K_Type mu, int bound) = K_Type_Pol:
if to_ht(bound)(up(mu)) = 0*mu then 0*mu
else let result = 0*mu in
result +:= to_ht(bound)(up(mu)) + for
c@p in up(mu) do up_cone(K_type(p),bound) od fi

{
testing:

set G=Sp(4,R)
set all = all_parameters_gamma(G,[4,2])

 for j:#all do prints(j,bottom(K_type(all[j]*0))) od

for j:#all do prints(j,"  ",height(all[j]),"  ",K_type(all[j]*0),"  ",
down(K_type(all[j]*0)),new_line)
od

for j:#all do prints(j,"  ",height(all[j])),"  ",K_type(all[j]*0),"  ",
down_cone(K_type(all[j]*0)),new_line)  od

{This is awful: need to replace print_K_types by output routine from
print_branch_?_long}
for j:#all do prints(new_line,j,"  ",height(all[j]),"  ",all[j]*0);
print_K_types(down_cone(K_type(all[j]*0)), KGB(G,3))  od
}

set find(Param p,ParamPol P)=bool:
   let list=monomials(P) in any(for q in list do p=q od)

set test_down(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_down_cone(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_cone(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_up(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(up(mu))
      do prints(p," ",height(p)," ",find(p,branch_std(q,height(p)))) od

set test_up_cone(K_Type mu,int n)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(up_cone(mu,n))
      do prints(p," ",height(p)," ",find(p,branch_std(q,height(p)))) od

