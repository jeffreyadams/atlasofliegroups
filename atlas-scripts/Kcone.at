<K.at
<K_types.at
<to_ht.at

{.compute the cones of K-types above and below a fixed one.}
{
atlas identifies

irr of K  <---> irr tempered of real infl char
LKT(p)  <----   p
 mu       ----->  parameter(mu)

The partial order on K-hat is generated by the relations

mu \ge mu_0 if mu occurs in [WRONG: parameter(mu)|_K] [CORRECTION:
SOME standard with mu_0 as a LKT]. These relations in turn can be
understood by looking at the branching to K algorithm. I haven't done
that with enough care, but I think that they are close to what is
impleented below.  }

set standardize(K_Type mu) = K_Type_Pol:
standardize(parameter(mu)*0)

set standardize(K_Type_Pol P) = K_Type_Pol:
0*P + for c@p in P do standardize(p*0) od

set height(K_Type mu)=height(parameter(mu))

set first_K_type(K_Type_Pol P) = K_type(first_param(P))

{all K_types that occur with mu as LKTs in some standard module}
set R_packet(K_Type (x,lam))=ParamPol:
   let G=real_form(x),zero=0*lam, L=Levi_by_wt(lam+x.involution*lam,x)
   then kgbs=##for y in KGB(L)
               do let xprime = embed_KGB(y,G)
                 in if xprime.involution = x.involution then [xprime] else []
	            fi
	       od
   then result=null_module(G)
   in for xp in kgbs do result+:=standardize(parameter(xp,lam,zero))
                     od; result
set R_packet(Param p)=R_packet(LKTs(p)[0])

{up assumes mu = (x',lambda') is standard but perhaps not normal, and
nonzero. Moves one (possibly non-simple) step up in the partial
order.}

{Move one step up in the partial order of K-types}
set pre_up(K_Type mu)=ParamPol:
   let result=null_module(real_form(mu))
   in for c@p in K_type_formula(mu)
                        do if int_part(c)<0 then result+:=p fi
                        od; result

set pre_up(Param p)=pre_up(first_K_type(standardize(p*0)))

set pre_up(K_Type mu, int N)=ParamPol:
   let result=null_module(real_form(mu))
   in for c@p in K_type_formula(parameter(mu),N)
                        do if int_part(c)<0 then result+:=p fi
                        od; result

set pre_up(Param p,int N)=pre_up(first_K_type(standardize(p*0)),N)


{As previous function, but remove some terms that are further
up in the partial order}
set up_tr(K_Type mu)=K_Type_Pol:
   let NM=null_module(real_form(mu)),start=pre_up(mu)
   then result=NM
   in while start!=NM
       do let p=last_param(start)
           in if all(for c@q in start do p=q or K_type_formula(q,height(p))[p]=0 od)
	      then result+:=p fi; start-:=start[p]*p
       od; result

set up_tr(Param p)=up_tr(first_K_type(standardize(p*0)))

{All K-types above mu up to height bound}
{set up_tr_cone(K_Type mu, int bound) = K_Type_Pol:
    let seen=ParamPol:null_module(mu.real_form)
    then result=seen
     in parameter(mu).(rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:=tau; for @p in to_ht(bound)(up_tr(tau)) do F(p);
           result +:=p od fi); result}

set up_tr_cone(K_Type mu, int bound) = K_Type_Pol:
    let seen=ParamPol:null_module(mu.real_form)
    then result=seen
     in parameter(mu).(rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:=tau; for @p in to_ht(bound)(pre_up(tau,bound)) do F(p);
           result +:=p od fi); result

set pre_up_R(K_Type mu)=ParamPol:
   let result=null_module(real_form(mu))
   in for @m in R_packet(mu)
       do for c@p in K_type_formula(m)
                        do if int_part(c)<0 then result+:=p fi
                        od
      od; result

set up_R(K_Type mu)=K_Type_Pol:
    let NM=null_module(real_form(mu)),start=pre_up_R(mu)
   then result=NM
   in while start!=NM do let p=last_param(start)
              in if all(for c@q in start do p=q or K_type_formula(q,height(p))[p]=0 od)
	         then result+:=p fi; start-:=start[p]*p
		      od; result

set up_R(Param p)=up_R(first_K_type(standardize(p*0)))

set up_R_cone(K_Type mu, int bound) = K_Type_Pol:
    let seen=ParamPol:null_module(mu.real_form)
    then result=seen
     in parameter(mu).(rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:=tau; for @p in to_ht(bound)(up_R(tau)) do F(p);
           result +:=p od fi); result

set is_ge_tr(K_Type tau,K_Type mu)=bool:
    if tau=mu then true
    elif height(tau)<=height(mu) then false
    else up_tr_cone(mu,height(tau))[parameter(tau)]!=0 fi

{Move one step down from mu in the partial order; may result in extra terms}
set pre_down(K_Type mu) = ParamPol:
   let q=parameter(mu) then Q=first_K_type(standardize(q*0))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in result+:=R
	   fi
	od; result

set pre_down(Param p)=pre_down(first_K_type(standardize(p*0)))

{Move one step down from mu in the partial order <_tr; remove terms
for which mu does not occur in the K-type formula}
set down_tr_one_root(K_Type mu) = ParamPol:
   let q=parameter(mu) then Q=first_K_type(standardize(q*0))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x
   then rhoL=rho(Levi_by_wt(Lambda,x)), pr=posroots(rd)
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(composition_series(standardize
	                  (parameter(x,lambda-pr[j], rhoL-pr[j]))))
                   in for @ m in R
	              do for lkt in LKTs(m)
		         do if (result[parameter(lkt)]=0 and is_ge_tr(Q,lkt))
			    then result+:=parameter(lkt)
                            fi
	              od od
	 fi od;
   result

set down_tr_one_root(Param p)=down_tr_one_root(first_K_type(standardize(p*0)))

set down_tr_two_roots(K_Type mu)=ParamPol:
   let q=parameter(mu) then Q=first_K_type(standardize(q*0))
   then HT=height(q), lambda =Q.lambda, x=Q.x
   then Lambda = lambda + (x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form)
   then pr=posroots(rd),
        usedpcr = ##for avee@j in poscoroots(rd) do if (Lambda*avee > 0 and
   not( is_compact(j,x))) then [j] else [] fi od
   then result=zeroPol
     in for j@i in usedpcr do for k:i do let R=to_ht(HT-1)(composition_series(standardize
                 (parameter(x,lambda-pr[j]-pr[usedpcr[k]], rho_r(x)-pr[j]-pr[usedpcr[k]]))))
            in for @m in R do
	       for lkt in LKTs(m) do
	       if (result[parameter(lkt)]=0 and is_ge_tr(Q,lkt))
	       then result+:=parameter(lkt);prints(pr[j]," ",pr[usedpcr[k]])
               fi od od od od;
    result

set down_tr(K_Type mu) = ParamPol:
   let q=parameter(mu) then Q=first_K_type(standardize(q*0))
   then HT=height(q), lambda =Q.lambda, x=Q.x
   then Lambda = lambda + (x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form)
   then pr=posroots(rd),
        usedpcr = ##for avee@j in poscoroots(rd) do if (Lambda*avee > 0 and
   not( is_compact(j,x))) then [j] else [] fi od
   then result=zeroPol
     in for j in usedpcr do let R=to_ht(HT-1)(composition_series(standardize
                 (parameter(x,lambda-pr[j], rho_r(x)-pr[j]))))
                   in for @ m in R
             do for lkt in LKTs(m) do
	       if (result[parameter(lkt)]=0 and is_ge_tr(Q,lkt))
	       then result+:=parameter(lkt)
                fi od od od;
   for j@i in usedpcr do for k:i do let R=to_ht(HT-1)(composition_series(standardize
                 (parameter(x,lambda-pr[j]-pr[usedpcr[k]], rho_r(x)-pr[j]-pr[usedpcr[k]]))))
            in for @m in R do
	       for lkt in LKTs(m) do
	       if (result[parameter(lkt)]=0 and is_ge_tr(Q,lkt))
	       then result+:=parameter(lkt)
               fi od od od od;
    result

set down_tr_old(K_Type mu) = ParamPol:
   let q=parameter(mu) then Q=first_K_type(standardize(q*0))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in for @ m in R
	              do if is_ge_tr(Q,K_type(m)) then result+:=m
                         fi
	              od
	 fi od;
   result


{set down_tr_old(K_Type mu) = ParamPol:
   let q=parameter(mu) then Q=first_K_type(standardize(q*0))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in for @ m in R
	              do if split_as_int(K_type_formula(m)[q]) < 0 then result+:=m
                         fi
	              od
	 fi od;
   result}


set down_tr(Param p)=down_tr(first_K_type(standardize(p*0)))

{Move down one step in the partial order for a list of K-types, assumed to
be in one R-packet; remove any K-types whose K_type_formula does not
contain any negative term from the list}
set down(ParamPol P)=ParamPol:
   let result=null_module(P.real_form) in
  for @p in P
       do for @m in pre_down(p)
          do if any(for @r in P do is_ge_tr(K_type(r),K_type(m)) od)
	     then result+:=m
	     fi
	  od
	od; result


set down_R(K_Type mu)= {prints("Height of mu= ",height(parameter(mu)));}
   down(R_packet(mu))

set down_R(Param p)=down_R(first_K_type(standardize(p*0)))

{test whether the K-type is at the bottom of the preorder; not used?}
set bottom(K_Type mu) = bool:
    pre_down(mu) = 0*mu

set down_R_cone(K_Type mu) = K_Type_Pol:
   let seen=ParamPol:null_module(mu.real_form)
   then result=seen
    in parameter(mu).( rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down_R(tau) do F(p); result +:= p od
        fi); result

set down_tr_cone(K_Type mu) = K_Type_Pol:
   let seen=ParamPol:null_module(mu.real_form)
   then result=seen
    in parameter(mu).( rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down_tr(tau) do F(p); result +:= p od
        fi); result

set down_tr_one_cone(K_Type mu) = K_Type_Pol:
   let seen=ParamPol:null_module(mu.real_form)
   then result=seen
    in parameter(mu).( rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down_tr_one_root(tau) do F(p); result +:= p od
        fi); result

{The function down@ParamPol (above) without test for removal}
{This gives incorrectly too many terms in G=Sp(4,R)
      down_alt((KGB(G,6),[2,1]/1))
Answer includes (KGB(Sp(G,3),[1,0]) which is wrong.
Comes from subtracting root 0 = [1,-1] from lambda, giving nonfinal
parameter (KGB(G,6),[1,2],[0,0]), which standardizes to sum of TWO
limits of discrete series: (G, 3 or 1, [1,0], [0,0]). The "1" is
right, the "3" is wrong; don't understand why.}

set down_alt(ParamPol P)=ParamPol:
let result=null_module(P.real_form) in
for @p in P do result+:=pre_down(p) od; result

set down_alt(K_Type mu)= { prints("Height of mu=
   ",height(parameter(mu))); }
   down_alt(R_packet(mu))

set down_alt(Param p)=down_alt(R_packet(p))

set down_alt_cone(K_Type mu) = K_Type_Pol:
    let seen=ParamPol:null_module(mu.real_form) then result=seen in
    parameter(mu).( rec_fun F (Param tau) void:
      if seen[tau].!= then ()
      else seen +:= tau; for @p in down_alt(tau) do F(p); result +:= p od
      fi); result


{Testing whether down_tr_cone yields all K-types that are below mu. The entry list
should be all K-types of K-norm less than the K-norm of mu.}
set test_down(K_Type mu, [K_Type] list)=bool:
   let downlist=down_tr_cone(mu)
   then candidates=##for kt in list do if downlist[parameter(kt)]=0 then [kt]
   			       	       else [] fi
				    od
   in {for kt in candidates do prints(kt," ",height(kt)) od;}
      all (for kt in candidates do up_tr_cone(kt,height(mu))[parameter(mu)]=0 od)

set test_down(RealForm G,int bound)=void:
   let kts=##for kt in K_parameters_height_upto(G,bound)
              do if height(kt)=bound then [kt] else [] fi
	      od
   then list=K_parameters_height_upto(G,bound-1)
   in for kt in kts do prints(kt," ",test_down(kt,list)) od

set test_down_one(K_Type mu, [K_Type] list)=(bool,[K_Type]):
   let downlist=down_tr_one_cone(mu)
   then candidates=##for kt in list do if downlist[parameter(kt)]=0 then [kt]
   			       	       else [] fi
				    od
   then result=##for kt in candidates
                 do if up_tr_cone(kt,height(mu))[parameter(mu)]=0 then [] else [kt] fi od
   in (#result=0,result)

set test_down_one(RealForm G,int bound)=void:
   let kts=##for kt in K_parameters_height_upto(G,bound)
              do if height(kt)=bound then [kt] else [] fi
	      od
   then list=K_parameters_height_upto(G,bound-1)
   in for kt in kts do prints(LKT(parameter(kt))," ",test_down_one(kt,list)) od

{.constructs parameter for the algebraic finite-dimensional of
extremal weight lambda.}
set finite_dimensional(RealForm G, vec lambda) = Param:
let lambdadomrho = dominant(G,lambda)+G.rho  in
parameter(x_open(G),lambdadomrho,lambdadomrho)

set ht(RealForm G, vec lambda) = int:
rat_as_int(dominant(G,lambda)*G.rho_check*2)

{.tensor product of algebraic reps of G of extremal wts gamma1 and gamma2,
returned as ParamPol of corresponding G parameters}
set tensor_product(RealForm G, vec gamma1, vec gamma2) = ParamPol:
let GC=G.complexification then gamma=finite_dimensional(GC,gamma1##gamma2)
then B=branch_irr(gamma, ht(GC,gamma1##gamma2)) in
sum(G, for c@p in B do c*finite_dimensional(G,complex_LKT(p)) od )

{tensor product of two K0-parameters}
set tensor_product(Param p,Param q)=ParamPol:
   let K=real_form(p),(,,mu)=highest_weight(p),(,,tau)=highest_weight(q)
   in tensor_product(K,mu,tau)

set K_param_from_K0_param (KGBElt x, Param p)=Param:
   let (,,v)=highest_weight(p)
   then hwt= K_highest_weight_from_K0_weight (x,v)
   in hwt.K_type.parameter

{. Tensor product of two K-types; this assumes K is connected. The first entry is
given as KType, the second as KHighestWeight .}
set tensor_product(K_Type tau,KHighestWeight mu)=ParamPol:
   let G=real_form(tau)
   in assert(components_rank(G)=0, "K is disconnected");
   let p=K0_param(tau),q=K0_param(K_type(mu))
   then tp=tensor_product(p,q)
   then result=null_module(G)
   in for c@r in tp do result+:=c*K_param_from_K0_param(KGB(G,0),r) od;
   result

set down_P (K_Type mu,[KHighestWeight] pktype)=ParamPol:
   let n=height(mu)
   then list=null_module(real_form(mu))
   in for tau in pktype
       do for c@r in tensor_product(mu,tau)
         do if height(r)<=n then list+:=r fi od od;
   list

set down_P(Param p,[KHighestWeight] pkt)=down_P(first_K_type(standardize(p*0)),pkt)

set down_P_cone(K_Type mu,[KHighestWeight] pktype) = K_Type_Pol:
   let seen=ParamPol:null_module(mu.real_form)
   then result=seen
    in parameter(mu).( rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down_P(tau,pktype) do F(p); result +:= p od
        fi); result