<K.at
<K_types.at
<to_ht.at

{.compute the cones of K-types above and below a fixed one.}
{
atlas identifies

irr of K  <---> irr tempered of real infl char
LKT(p)  <----   p
 mu       ----->  parameter(mu)

The partial order on K-hat is generated by the relations

mu \ge mu_0 if mu occurs in [WRONG: parameter(mu)|_K] [CORRECTION:
SOME standard with mu_0 as a LKT]. These relations in turn can be
understood by looking at the branching to K algorithm. I haven't done
that with enough care, but I think that they are close to what is
impleented below.  }

set standardize(K_Type mu) = K_Type_Pol:
standardize(parameter(mu)*0)

set standardize(K_Type_Pol P) = K_Type_Pol:
0*P + for c@p in P do standardize(p*0) od

set first_K_type(K_Type_Pol P) = K_type(first_param(P))

set find(Param p,ParamPol P)=bool:
   let list=monomials(P) in any(for q in list do p=q od)


{all K_types that occur with mu as LKTs in some standard module}
set R_packet(K_Type (x,lam))=ParamPol:
   let G=real_form(x),zero=0*lam, L=Levi_by_wt(lam+x.involution*lam,x)
   then kgbs=##for y in KGB(L)
               do let xprime = embed_KGB(y,G)
                 in if xprime.involution = x.involution then [xprime] else []
	            fi
	       od
   then result=null_module(G)
   in for xp in kgbs do result+:=standardize(parameter(xp,lam,zero))
                     od; result

{Move one step down from mu in the partial order; may result in extra terms}
set pre_down(K_Type mu) = ParamPol:
   let q=parameter(mu), Q=LKT(parameter(mu))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in result+:=R
	   fi
	od; result

set pre_down(Param p)=pre_down(LKTs(p)[0])

set down_old(K_Type mu) = ParamPol:
   let q=parameter(mu), Q=LKT(parameter(mu))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in for m in monomials(R)
	              do if {find(q,branch_std(m,HT)) then result+:=m}
		      	    split_as_int(K_type_formula(m)[q]) < 0 then result+:=m
                         fi
	              od
	 fi od;
   result


{The function down@ParamPol (below) without test for removal}
{This gives incorrectly too many terms in G=Sp(4,R)
      down_alt((KGB(G,6),[2,1]/1))
Answer includes (KGB(Sp(G,3),[1,0]) which is wrong.
Comes from subtracting root 0 = [1,-1] from lambda, giving nonfinal
parameter (KGB(G,6),[1,2],[0,0]), which standardizes to sum of TWO
limits of discrete series: (G, 3 or 1, [1,0], [0,0]). The "1" is
right, the "3" is wrong; don't understand why.}

set down_alt(ParamPol P)=ParamPol:
let result=null_module(P.real_form) in
for @p in P do result+:=pre_down(p) od; result

{Move down one step in the partial order for a list of K-types, assumed to
be in one R-packet; remove any K-types whose K_type_formula does not
contain any negative term from the list}
set down(ParamPol P)=ParamPol:
 {  let G=real_form(P), list=monomials(P) }
   let result=null_module(P.real_form) in
  for @p in P
       do for @m in pre_down(p)
          do if any(for @r in P do split_as_int(K_type_formula(m)[r])
				     < 0 od)
	     then result+:=m
	     fi
	  od
	od; result

set down_alt(K_Type mu)= { prints("Height of mu=
   ",height(parameter(mu))); }
   down_alt(R_packet(mu))

set down(K_Type mu)= {prints("Height of mu= ",height(parameter(mu)));}
   down(R_packet(mu))

set down(Param p)=down(R_packet(first_K_type(standardize(p*0))))

{test whether the K-type is at the bottom of the preorder}
set bottom(K_Type mu) = bool:
    down(mu) = 0*mu

set down_cone(K_Type mu) = K_Type_Pol:
   let seen=ParamPol:null_module(mu.real_form)
   then result=seen
    in parameter(mu).( rec_fun F (Param tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down(tau) do F(p); result +:= p od
        fi); result

{ omit testing }
set down_cone_alt(K_Type mu) = K_Type_Pol:
let seen=ParamPol:null_module(mu.real_form) then result=seen in
parameter(mu).( rec_fun F (Param tau) void:
if seen[tau].!= then ()
else seen +:= tau; for @p in down_alt(tau) do F(p); result +:= p od
fi); result

{up assumes mu = (x',lambda') is standard but perhaps not normal, and
nonzero. Moves one (possibly non-simple) step up in the partial
order.}

{S needs a separate case for avee real parity: CAYLEY. This should
only be needed when avee is simple as a real root(??). In that case
lambda*avee is meant to be ODD (otherwise the K-type was not final). I
HOPE that the formula
lambda' = lambda-(lambda*avee)*posroots(rd)[j]\2
then gives lambda'*avee = 1.
}
set up_old(K_Type mu) = K_Type_Pol:
let q=parameter(mu), Q=LKTs(parameter(mu)) then HT=height(q), lambda =
Q[0].lambda then Lambda = lambda + (Q[0].x.involution)*lambda,
rd=mu.root_datum, zeroPol = null_module(q.real_form),
zero = 0*mu, zeronu=0*lambda in
zero+ ##for p in Q do let x=p.x  in for avee@j in
poscoroots(rd) do let S=
case #is_real(j,x)
 in standardize(standardize(parameter(x,lambda+posroots(rd)[j], zeronu))*0),
standardize(standardize(parameter(Cayley(j,x), lambda-((lambda*avee)\2)*posroots(rd)[j], zeronu))*0) +
  standardize(standardize(parameter(cross(j,Cayley(j,x)), lambda-((lambda*avee)\2)*posroots(rd)[j]\2, zeronu))*0)
esac
then R = S- to_ht(HT)(S)
 in if (Lambda*avee >= 0 and not(is_compact(j,x))) then R
 else zero fi
od od

{Move one step up in the partial order of K-types}
set up(K_Type mu)=ParamPol:
null_module(mu.real_form) + 
  for @p in R_packet(mu) do null_module(mu.real_form) + ##for c@m in
  K_type_formula(p) do if split_as_int(c)<0 then [m] else [] fi od od

{As previous function, but remove some terms that are further
up in the partial order}
{DV: this looks wrong?? haven't thought carefully}
set up_plus(K_Type mu)=ParamPol:
   let NM=null_module(real_form(mu)),start=up(mu)
   then result=NM
   in while start!=NM do let p=first_param(start)
                         in for q in monomials(start)
			    do if p!=q and find(q,K_type_formula(p))
			       then start-:=q
			       fi
			    od; start-:=p; result+:=p
		      od; result
{DV: starting to try to fix, not yet succeeding 
set up_plus(K_Type mu)=ParamPol:
   let NM=null_module(real_form(mu)),start=up(mu)
   then result=NM
   in while start!=NM do let p=first_param(start)
                         in for c@q in start
			    do if split_as_int(K_type_formula(p)[q]) <
			    0 then 
			       then start-:=(c,q)
			       fi
			    od; start-:=p; result+:=p
		      od; result
}


{have not incorporate MvL suggestions about avoiding recalculation of
"up" with something "seen."}
set rec_fun up_cone(K_Type mu, int bound) = K_Type_Pol:
0*mu + for @tauprime in R_packet(mu) do
 let muprime = K_type(tauprime) then start = to_ht(bound)(up(muprime)) in
 start + for @p in start do up_cone(K_type(p),bound) od od

{
testing:

set G=Sp(4,R)
set all = all_parameters_gamma(G,[4,2])

 for j:#all do prints(j,bottom(K_type(all[j]*0))) od

for j:#all do prints(j,"  ",height(all[j]),"  ",K_type(all[j]*0),"  ",
down(K_type(all[j]*0)),new_line)
od

for j:#all do prints(j,"  ",height(all[j])),"  ",K_type(all[j]*0),"  ",
down_cone(K_type(all[j]*0)),new_line)  od

{This is awful: need to replace print_K_types by output routine from
print_branch_?_long}
for j:#all do prints(new_line,j,"  ",height(all[j]),"  ",all[j]*0);
print_K_types(down_cone(K_type(all[j]*0)), KGB(G,3))  od
}

set test_down(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_down_alt(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_alt(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_down_cone(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_cone(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_up(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(up(mu))
      do prints(p," ",height(p)," ",find(p,branch_std(q,height(p)))) od

set test_up_cone(K_Type mu,int n)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(up_cone(mu,n))
      do prints(p," ",height(p)," ",find(p,branch_std(q,height(p)))) od

{Test functions}
set rec_fun down_cone_alt(K_Type mu) = K_Type_Pol:
   let result = 0*mu
     in result +:= down_alt(mu) + for c@p in down_alt(mu) do down_cone_alt(K_type(p))
                                                       od

set test_down_cone_alt(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_cone_alt(mu))
   do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od
