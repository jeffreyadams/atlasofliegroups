<K.at
<K_types.at
<to_ht.at
<K_norm.at
<tensor_product.at
<hodge_K_type_formula.at

{.compute the cones of K-types above and below a fixed one.}
{
atlas identifies

irr of K  <---> irr tempered of real infl char
LKT(p)  <----   p
 mu       ----->  parameter(mu)

The partial order on K-hat is generated by the relations

mu \ge mu_0 if mu occurs in [WRONG: parameter(mu)|_K] [CORRECTION:
SOME standard with mu_0 as a LKT]. These relations in turn can be
understood by looking at the branching to K algorithm. I haven't done
that with enough care, but I think that they are close to what is
impleented below.  }

set convert_to_K (ParamPol P)=KTypePol:
   let result=null_K_module(real_form(P))
   in for c@p in P do result+:=c*LKT(p) od;
   result

set standardize(KType mu) = KTypePol:
   K_type_pol(standardize(parameter(mu)*0))

set standardize(KTypePol P) = KTypePol:
0*P + for c@p in P do c*standardize(p) od

{all K_types that occur with mu as LKTs in some standard module}
set R_packet(KType t)=KTypePol:
   let G=real_form(t),lam=lambda(t), x=x(t)
   then zero=lam*0, L=Levi_by_wt(lam+x.involution*lam,x)
   then kgbs=##for y in KGB(L)
               do let xprime = embed_KGB(y,G)
                 in if xprime.involution = x.involution then [xprime] else []
	            fi
	       od
   then result=null_K_module(G)
   in for xp in kgbs
       do for m in monomials(standardize(parameter(xp,lam,zero)))
           do result+:= LKT(m)
           od
       od; result


set R_packet(KTypePol P)=sum(real_form(P),for m in monomials(P) do R_packet(m) od)

{up assumes mu = (x',lambda') is standard but perhaps not normal, and
nonzero. Moves one (possibly non-simple) step up in the partial
order.}

{Move one step up in the partial order of K-types: all K-types with negative
coefficients in the K-type formula}
set up_tr(KType mu)=KTypePol:
   let result=null_K_module(real_form(mu))
   in for c@p in K_type_formula(mu)
                        do if int_part(c)<0 then result+:=p fi
                        od; result

{As previous function, but including only K-types up to a given height}
set up_tr(KType mu, int N)=KTypePol:
   let result=null_K_module(real_form(mu))
   in for c@p in K_type_formula(mu,N)
                        do if int_part(c)<0 then result+:=p fi
                        od; result


{As up_tr, but remove some terms that are further
up in the partial order}
set up_tr_fewer_terms(KType mu)=KTypePol:
   let NM=null_K_module(real_form(mu)),start=up_tr(mu)
   then result=NM
   in while start!=NM
       do let p=last_K_type(start)
           in if all(for c@q in start do p=q or K_type_formula(q,height(p))[p]=0 od)
	      then result+:=p fi; start-:=start[p]*p
       od; result


{All K-types above mu up to height bound}
set up_tr_cone(KType mu, int bound) = KTypePol:
    let seen=KTypePol:null_K_module(mu.real_form)
    then result=seen
     in mu.(rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:=tau; for @p in to_ht(up_tr(tau,bound),bound) do F(p);
           result +:=p od fi); result


{Move one step up in the partial preorder <=_R; for each K-type mu in the R-packet,
add the R-packet of each K-type in up_tr(mu)}
set up_R(KType mu)=KTypePol:
   let result=null_K_module(real_form(mu))
   in for @m in R_packet(mu)
       do for c@p in K_type_formula(m)
                        do if int_part(c)<0 then result+:=R_packet(p) fi
                        od
      od; result

{As previous function, but adding only K-types, not R-packets}
set up_R_alt(KType mu)=KTypePol:
   let result=null_K_module(real_form(mu))
   in for @m in R_packet(mu)
       do for c@p in K_type_formula(m)
                        do if int_part(c)<0 then result+:=p fi
                        od
      od; result

{As up_R, but remove some terms higher up in the order}
set up_R_fewer_terms(KType mu)=KTypePol:
    let NM=null_K_module(real_form(mu)),start=up_R(mu)
   then result=NM
   in while start!=NM do let p=last_K_type(start)
             in if all(for c@q in start do p=q or K_type_formula(q,height(p))[p]=0 od)
	        then result+:=R_packet(p) fi; start-:=start[p]*p
		      od; result

{All K-types above mu in the R-order, up to given height}
set up_R_cone(KType mu, int bound) = KTypePol:
    let seen=KTypePol:null_K_module(mu.real_form)
    then result=seen
     in mu.(rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:=tau; for @p in to_ht(up_R(tau),bound) do F(p);
           result +:=p od fi); result

{This does not give the right answer; ex. Sp(4,R), K-type (x=0,lambda=[2,1])}
set up_R_alt_cone(KType mu, int bound) = KTypePol:
    let seen=KTypePol:null_K_module(mu.real_form)
    then result=seen
     in mu.(rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:=tau; for @p in to_ht(up_R_alt(tau),bound) do F(p);
           result +:=p od fi); result


set is_ge_tr(KType tau,KType mu)=bool:
    if tau=mu then true
    elif height(tau)<=height(mu) then false
    else up_tr_cone(mu,height(tau))[tau]!=0 fi


{Move one step down from mu in the partial order <_tr; remove terms
for which mu does not occur in the K-type formula}
set down_tr_one_root(KType mu) = KTypePol:
   let  Q=first_K_type(standardize(mu))
   then HT=height(Q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_K_module(mu.real_form), x=Q.x
   then rhoL=rho(Levi_by_wt(Lambda,x)), pr=posroots(rd)
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(composition_series(standardize
	                  (parameter(x,lambda-pr[j], rhoL-pr[j]))))
                   in for @ m in R
	              do for lkt in LKTs(m)
		         do if (result[lkt]=0 and is_ge_tr(Q,lkt))
			    then result+:=lkt
                            fi
	              od od
	 fi od;
   result

set down_tr_two_roots(KType mu)=KTypePol:
   let Q=first_K_type(standardize(mu))
   then HT=height(Q), lambda =Q.lambda, x=Q.x
   then Lambda = lambda + (x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_K_module(mu.real_form)
   then pr=posroots(rd),
        usedpcr = ##for avee@j in poscoroots(rd) do if (Lambda*avee > 0 and
   not( is_compact(j,x))) then [j] else [] fi od
   then result=zeroPol
     in for j@i in usedpcr do for k:i do let R=to_ht(HT-1)(composition_series(standardize
                 (parameter(x,lambda-pr[j]-pr[usedpcr[k]], rho_r(x)-pr[j]-pr[usedpcr[k]]))))
            in for @m in R do
	       for lkt in LKTs(m) do
	       if (result[lkt]=0 and is_ge_tr(Q,lkt))
	       then result+:=lkt;prints(pr[j]," ",pr[usedpcr[k]])
               fi od od od od;
    result

{Combine the results of the previous two functions: K-types obtained by moving one or
two steps down in the partial order}
set down_tr(KType mu) = KTypePol:
   let Q=first_K_type(standardize(mu))
   then HT=height(Q), lambda =Q.lambda, x=Q.x
   then Lambda = lambda + (x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_K_module(mu.real_form)
   then pr=posroots(rd),
        usedpcr = ##for avee@j in poscoroots(rd) do if (Lambda*avee > 0 and
   not( is_compact(j,x))) then [j] else [] fi od
   then result=zeroPol
     in for j in usedpcr do let R=to_ht(HT-1)(composition_series(standardize
                 (parameter(x,lambda-pr[j], rho_r(x)-pr[j]))))
                   in for @ m in R
             do for lkt in LKTs(m) do
	       if (result[lkt]=0 and is_ge_tr(Q,lkt))
	       then result+:=lkt
                fi od od od;
   for j@i in usedpcr do for k:i do let R=to_ht(HT-1)(composition_series(standardize
                 (parameter(x,lambda-pr[j]-pr[usedpcr[k]], rho_r(x)-pr[j]-pr[usedpcr[k]]))))
            in for @m in R do
	       for lkt in LKTs(m) do
	       if (result[lkt]=0 and is_ge_tr(Q,lkt))
	       then result+:=lkt
               fi od od od od;
    result

{Previous function without testing whether K-type appears in the K-type formula of any
K-type in the list}
set down_tr_alt(KType mu) = KTypePol:
   let Q=first_K_type(standardize(mu))
   then HT=height(Q), lambda =Q.lambda, x=Q.x
   then Lambda = lambda + (x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_K_module(mu.real_form)
   then pr=posroots(rd),
        usedpcr = ##for avee@j in poscoroots(rd) do if (Lambda*avee > 0 and
   not( is_compact(j,x))) then [j] else [] fi od
   then result=zeroPol
     in for j in usedpcr do let R=to_ht(HT-1)(composition_series(standardize
                 (parameter(x,lambda-pr[j], rho_r(x)-pr[j]))))
                   in for @ m in R
             do for lkt in LKTs(m) do
	       if result[lkt]=0
	       then result+:=lkt
                fi od od od;
   for j@i in usedpcr do for k:i do let R=to_ht(HT-1)(composition_series(standardize
                 (parameter(x,lambda-pr[j]-pr[usedpcr[k]], rho_r(x)-pr[j]-pr[usedpcr[k]]))))
            in for @m in R do
	       for lkt in LKTs(m) do
	       if result[lkt]=0
	       then result+:=lkt
               fi od od od od;
    result


{Move down one or two steps in the partial order for a list of K-types, assumed to
be in one R-packet; remove any K-types whose K_type_formula does not
contain any negative term from the list}
set down(KTypePol P)=KTypePol:
   let result=null_K_module(P.real_form) in
  for @p in P
  do  for @m in down_tr(p)
      do  result+:=m
      od
  od; result


set down_R(KType mu)= {prints("Height of mu= ",height(mu));}
   down(R_packet(mu)).R_packet


{test whether the K-type is at the bottom of the preorder; not used?}
set bottom(KType mu) = bool:
    down_tr(mu) = 0*mu

set down_R_cone(KType mu) = KTypePol:
   let seen=KTypePol:null_K_module(mu.real_form)
   then result=seen
    in mu.( rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down_R(tau) do F(p); result +:= p od
        fi); result

set down_tr_cone(KType mu) = KTypePol:
   let seen=KTypePol:null_K_module(mu.real_form)
   then result=seen
    in mu.( rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down_tr(tau) do F(p); result +:= p od
        fi); result

set down_tr_one_cone(KType mu) = KTypePol:
   let seen=KTypePol:null_K_module(mu.real_form)
   then result=seen
    in mu.( rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down_tr_one_root(tau) do F(p); result +:= p od
        fi); result

{The function down@ParamPol (above) without test for removal}
{This gives incorrectly too many terms in G=Sp(4,R)
      down_alt((KGB(G,6),[2,1]/1))
Answer includes (KGB(Sp(G,3),[1,0]) which is wrong.
Comes from subtracting root 0 = [1,-1] from lambda, giving nonfinal
parameter (KGB(G,6),[1,2],[0,0]), which standardizes to sum of TWO
limits of discrete series: (G, 3 or 1, [1,0], [0,0]). The "1" is
right, the "3" is wrong; don't understand why.}

set down_alt(KTypePol P)=KTypePol:
let result=null_K_module(P.real_form) in
for @p in P do result+:=down_tr_alt(p) od; result

set down_alt(KType mu)= { prints("Height of mu=
   ",height(parameter(mu))); }
   down_alt(R_packet(mu))


set down_alt_cone(KType mu) = KTypePol:
    let seen=KTypePol:null_K_module(mu.real_form) then result=seen in
    mu.( rec_fun F (KType tau) void:
      if seen[tau].!= then ()
      else seen +:= tau; for @p in down_alt(tau) do F(p); result +:= p od
      fi); result


{Testing whether down_tr_cone yields all K-types that are below mu. The entry list
should be all K-types of K-norm less than the K-norm of mu.}
set test_down(KType mu, [KType] list)=bool:
   let downlist=down_tr_cone(mu)
   then candidates=##for kt in list do if downlist[kt]=0 then [kt]
   			       	       else [] fi
				    od
   in {for kt in candidates do prints(kt," ",height(kt)) od;}
      all (for kt in candidates do up_tr_cone(kt,height(mu))[mu]=0 od)

set test_down(RealForm G,int bound)=void:
   let kts=##for kt in K_parameters_height_upto(G,bound)
              do if height(kt)=bound then [kt] else [] fi
	      od
   then list=K_parameters_height_upto(G,bound-1)
   in for kt in kts do prints(kt," ",test_down(kt,list)) od

set test_down_one(KType mu, [KType] list)=(bool,[KType]):
   let downlist=down_tr_one_cone(mu)
   then candidates=##for kt in list do if downlist[kt]=0 then [kt]
   			       	       else [] fi
				    od
   then result=##for kt in candidates
                 do if up_tr_cone(kt,height(mu))[mu]=0 then [] else [kt] fi od
   in (#result=0,result)

set test_down_one(RealForm G,int bound)=void:
   let kts=##for kt in K_parameters_height_upto(G,bound)
              do if height(kt)=bound then [kt] else [] fi
	      od
   then list=K_parameters_height_upto(G,bound-1)
   in for kt in kts do prints(kt," ",test_down_one(kt,list)) od

{.constructs parameter for the algebraic finite-dimensional of
extremal weight lambda.}
set finite_dimensional(RealForm G, vec lambda) = Param:
let lambdadomrho = dominant(G,lambda)+G.rho  in
parameter(x_open(G),lambdadomrho,lambdadomrho)

set ht(RealForm G, vec lambda) = int:
rat_as_int(dominant(G,lambda)*G.rho_check*2)

{.tensor product of algebraic reps of G of extremal wts gamma1 and gamma2,
returned as ParamPol of corresponding G parameters}
set tensor_product(RealForm G, vec gamma1, vec gamma2) = ParamPol:
let GC=G.complexification then gamma=finite_dimensional(GC,gamma1##gamma2)
then B=branch_irr(gamma, ht(GC,gamma1##gamma2)) in
sum(G, for c@p in B do c*finite_dimensional(G,complex_LKT(parameter(p))) od )

{tensor product of two K0-parameters}
set tensor_product(Param p,Param q)=ParamPol:
   let K=real_form(p),(,,mu)=highest_weight(p),(,,tau)=highest_weight(q)
   in tensor_product(K,mu,tau)

set K_param_from_K0_param (KGBElt x, Param p)=KType:
   let (,,v)=highest_weight(p)
   then hwt= K_highest_weight_from_K0_weight (x,v)
   in hwt.K_type

{. Tensor product of two K-types; this assumes K is connected. The first entry is
given as KType, the second as KHighestWeight .}
set tensor_product(KType tau,KHighestWeight mu)=KTypePol:
   let G=real_form(tau)
   in assert(components_rank(G)=0, "K is disconnected");
   let p=K0_param(tau),q=K0_param(K_type(mu))
   then tp=tensor_product(p,q)
   then result=null_K_module(G)
   in for c@r in tp do result+:=c*K_param_from_K0_param(KGB(G,0),r) od;
   result

set down_P (KType mu,[KHighestWeight] pktype)=KTypePol:
   let n=height(mu)
   then list=null_K_module(real_form(mu))
   in for tau in pktype
       do for c@r in tensor_product(mu,tau)
         do if height(r)<=n then list+:=r fi od od;
   list


set down_P_cone(KType mu,[KHighestWeight] pktype) = KTypePol:
   let seen=null_K_module(mu.real_form)
   then result=seen
    in mu.( rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:= tau; for @p in down_P(tau,pktype) do F(p); result +:= p od
        fi); result

set down_P_cone_alt(KType mu,[KHighestWeight] pktype)= KTypePol:
   let result=null_K_module(real_form(mu))
   in for c@p in down_P_cone(mu,pktype) do result+:=p od; result

set down_R_cone_true (KType mu)=KTypePol:
   let h=height(mu),G=real_form(mu)
   then result=null_K_module(G)
   in if h>0
      then let list=K_parameters_height_upto(G,h-1)
      	   in for kt in list
	      do if up_R_cone(kt,h)[mu]!=0
		 then result+:=kt
		  fi
	      od
      fi; result

set print_K_types_nice (KTypePol P,KGBElt x) = void:
   let header=["m","x","lambda","hw","dim","height"]
   then values=for c@q in P
               do let hw=highest_weight(q,x)
                  in [c.split_as_int.to_string,
		      let (,n)=%q.x in n.to_string,
		      q.lambda.to_string,
		      let (,,v)=hw in v.to_string,
		      dimension(q).to_string,height(q).to_string]
	       od in tabulate(header#values)

{This works only when \theta_x permutes the non-real positive roots;
that is always true for a normalized Param with nu=0, as for example a
term in a K_type_formula.}
set pwtsIRC(KGBElt x) = [vec]:
    let (G,posRoots,inv) = (x.real_form,posroots(x.real_form),x.involution)
    in ##for i:#posRoots do if {I} is_imaginary(i,x)
       	     		    then if {NC*} is_noncompact(i,x)
			          then [posRoots[i],-posRoots[i]]
				  else []
				  fi{NC}
			    else if {R*} is_real(i,x)
			         then [posRoots[i]]
				 else if {1st*} find(posRoots,inv*posRoots[i]) > i
				      then [posRoots[i],-posRoots[i]]
				      else []
				      fi{1st}
				 fi{R}
	 		    fi{I}
			 od


set dim_A_x (KGBElt x) = int:
   let ((,C,r),,,)=x.Cartan_class.Cartan_info in C+r

set ratpwtsIRC(KGBElt x) = [ratvec]:for v in pwtsIRC(x) do ratvec:v
od ## for i:dim_A_x(x) do null(rank(x.root_datum))/1 od

{This was meant to avoid recomputing; but it is wasteful, in that it
ought to ignore those x for which \theta_x does not permute nonreal
roots; those x will never appear in a K_type_formula.}
set pwts(RealForm G) = [[vec]]:
for x in KGB(G) do pwtsIRC(x) od


{The terms in the ParamPol at the end are all standard with nu=0, but
not necessarily normal or final. This seems to be harmless.}
set add_T_x_weights(KType p) = KTypePol:
   let x=p.x, lambda=p.lambda {, nu=p.nu}
   then result=dim_A_x(x)*p
   in for v in pwtsIRC(x)
      do result+:= convert_to_K(standardize(parameter(x,lambda+v,0*lambda))*0)
      od; result

{The terms in the ParamPol at the end are all standard with nu=0, but
not necessarily normal or final. This seems to be harmless.}
set add_T_x_weights(KType p, [[vec]] Pwts) = KTypePol:
    let (G,j)= %p.x, lambda=p.lambda, x=p.x
    in dim_A_x(p.x)*p + sum(G,for v in Pwts[j] do
    convert_to_K( standardize(parameter(x,lambda+v,0*lambda))*0) od)

set tensor_with_p (KType mu)=KTypePol:
    let P=K_type_formula(mu)
    in sum(mu.real_form, for c@p in P do c*add_T_x_weights(p) od)

{should be same as above}
{set tensor_with_pJDA (KType mu) = KTypePol:
    add_weights(mu,ratpwtsIRC@KGBElt)}
    {tensor_product(mulong,ratpwtsIRC@KGBElt)}

{This cures the non-standard/ non-final terms in tensor_with_p, but I
think it isn't needed.}
set tensor_with_p0 (KType mu) = standardize(tensor_with_p(mu))

{same as tensor_with_p, trying to avoid recomputation of pwtsIRC}
set tensor_with_p1 (KType mu)=KTypePol:
   let P=K_type_formula(mu), Pwts=pwts(mu.real_form) in
   sum(P.real_form,for c@p in P do c*add_T_x_weights(p,Pwts) od)

set down_B(KType mu,[Param] B)=KTypePol:
   let n=height(mu)
   then result=null_K_module(real_form(mu))
    in for p in B
        do for tau in highest_weights(p)
	   do for c@r in tensor_product(mu,tau)
              do if height(r)<n
	         then result+:=r
		 fi
	      od
	   od
	od; result

set down_B_alt(KType mu,[Param] B)=KTypePol:
   let n=height(mu)
    in sum(real_form(mu),##for p in B
        		   do ##for tau in highest_weights(p)
	                        do ##for c@r in tensor_product(mu,tau)
                                     do if height(r)<n
	         		        then [1*r]
		 		        else []
		 		        fi
	                             od
	   		        od
			   od)

set up_B(KType mu,[Param] B)=KTypePol:
   let n=height(mu)
    then result=null_K_module(real_form(mu))
    in for p in B
        do for tau in highest_weights(p)
	   do for c@r in tensor_product(mu,tau)
              do if height(r)>n
	         then result+:=r
		 fi
	      od
	   od
	od; result

set test_down_R_cone (KType mu) = bool:
   let P1=monomials(down_R_cone(mu)), P2=monomials(down_R_cone_true(mu))
   in #P1=#P2 and all(for i:#P1 do P1[i]=P2[i] od)

set down_PP(KType mu,int N) = KTypePol:
   let list=for p in monomials(branch_std(trivial(real_form(mu)),N)) do parameter(p) od
   in down_B(mu,list)

set up_PP(KType mu,int N) = KTypePol:
   let list=for p in monomials(branch_std(trivial(real_form(mu)),N)) do parameter(p) od
   in up_B(mu,list)

{set next1 (KType mu)=[KTypePol]:
   let G=real_form(mu),lam=mu.lambda_minus_rho
   then sr=simple_roots(G)
   in ##for alpha@i in sr
       do if is_real(alpha,mu.x)
          then let x=Cayley(i,mu.x)
	       in [1*K_type(x,lam)+K_type(cross(i,x),lam)]
	  else []
	  fi
       od}

set next_im (KType mu)=[KTypePol]:
   let G=real_form(mu),lam=mu.lambda_minus_rho
   then pr=posroots(G)
   in ##for alpha in pr
        do if is_imaginary(alpha,mu.x)
	   then [1*K_type(mu.x,lam+alpha)+K_type(cross(alpha,mu.x),lam)] else []
	   fi od

set prev_im_cx (KType mu)=[KTypePol]:
   let G=real_form(mu),lam=mu.lambda_minus_rho
   then pr=posroots(G)
   in ##for alpha in pr
        do if is_noncompact_imaginary(alpha,mu.x) or is_complex(alpha,mu.x)
	   then [1*K_type(mu.x,lam-alpha)] else []
	   fi od

{set next_K_types1 (KType mu)=[[KTypePol]]:
   let G=real_form(mu)
   then result=[next1(mu)]
   in for pol in next1(mu)
        do for c@tau in pol
	    do result#:=next_im(tau) od od;
   result#:=next_im(mu)}

set next_real (KType mu)=[KTypePol]:
   let G=real_form(mu),lam=mu.lambda_minus_rho
   then sr=simple_roots(G)
   in ##for alpha in sr
        do if is_real(alpha,mu.x)
            then let x=Cayley(alpha,mu.x)
	          in [1*K_type(x,lam)+K_type(cross(alpha,x),lam)]
	    else [] fi od

set next_K_types (KType mu)=[KTypePol]:
   let G=real_form(mu),lam=mu.lambda_minus_rho
   then pr=posroots(G)
   in ##for alpha@i in pr
       do let d = lam*poscoroots(G)[i]
       	  in if is_simple_root(G,alpha) and is_real(alpha,mu.x) and is_even(d)
             then let y=Cayley(i,mu.x)
	     	  then lamy = lam-floor(d/2)*alpha
	          in [1*K_type(y,lamy)+K_type(cross(i,y),lamy)]
	  elif is_noncompact_imaginary(alpha,mu.x) or is_complex(alpha,mu.x)
	      then [1*K_type(mu.x,lam+alpha)]
	  else []
	  fi
       od

set next_K_types (KTypePol P)=KTypePol:
   let list=##for c@p in P do c*next_K_types(p) od
   in sum(real_form(P),list)

set next_K_types_list (KType mu)=KTypePol:
   let G=real_form(mu)
   then P=next_K_types(1*mu)
   then result=[KType]:[]
   in for c@kt in P
	     do if find(result,kt)=-1
	        then result#:=kt
		fi
	     od;
    sum(G, for kt in result do kt od)

set next_R_K_types_list (KType tau)=KTypePol:
   let G=real_form(tau)
   then result=[KType]:[]
   in for c@mu in R_packet(tau)
       do let P=next_K_types(1*mu)
           in for c@kt in P
              do for n@p in R_packet(kt)
	         do if find(result,p)=-1
	             then result#:=p
	             fi
	         od
	      od
      od;
    sum(G, for kt in result do kt od)

set next_K_types_list (KTypePol P)=KTypePol:
   sum(real_form(P),for c@p in P do next_K_types_list(p) od)

set next_R_K_types_list (KTypePol P)=KTypePol:
   sum(real_form(P),for c@p in P do next_R_K_types_list(p) od)


set anti_finalize (Param p)=Param:
   let G=real_form(p)
   then pr=posroots(G), pcr=poscoroots(G)
     in while any(for alpha@i in pr do is_noncompact_imaginary(alpha,x(p))
                                        and pcr[i]*lambda(p)=0 od)
	do let n=first(for i:#pr do is_noncompact_imaginary(pr[i],x(p))
	                             and pcr[i]*lambda(p)=0 od)
	   in p:=Cayley(pr[n],p)
	od; p

set fold (vec v)=vec:
   let n=#v then k=floor(n/2)
   in for i:k do v[i]+v[k] od


set up_next_cone(KType mu, int bound) = KTypePol:
    let seen=KTypePol:null_K_module(mu.real_form)
    then result=seen
     in mu.(rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:=tau; for @p in to_ht(next_K_types_list(tau),bound) do F(p);
           result +:=p od fi); result

set up_next_R_cone(KType mu, int bound) = KTypePol:
    let seen=KTypePol:null_K_module(mu.real_form)
    then result=seen
     in mu.(rec_fun F (KType tau) void:
        if seen[tau].!= then ()
        else seen +:=tau; for @p in to_ht(next_R_K_types_list(tau),bound) do F(p);
           result +:=p od fi); result

set test_next (KType mu,int a)=(bool,bool):
   let upR=up_R_cone(mu,height(mu)+a).monomials
   then upN=up_next_R_cone(mu,height(mu)+a).monomials
   in (#upR=#upN,
      if #upR=0 and #upN=0 then true
      else  upR[0]=upN[0]
      fi)

set test_next2 (KType mu,int a)=(bool,bool,int):
   let upR=up_R_cone(mu,height(mu)+a).monomials
   then upN=up_next_R_cone(mu,height(mu)+a).monomials
   in (#upR=#upN,
      if #upR=0 and #upN=0 then true
      else all(for m@i in upR do m=upN[i] od)
      fi,
      #upR)

