<K.at
<K_types.at
<to_ht.at

{.compute the cones of K-types above and below a fixed one.}
{
atlas identifies

irr of K  <---> irr tempered of real infl char
LKT(p)  <----   p
 mu       ----->  parameter(mu)

The partial order on K-hat is generated by the relations

mu \ge mu_0 if mu occurs in parameter(mu)|_K. These relations in turn
can be understood by looking at the branching to K algorithm. I
haven't done that with enough care, but I think that they are close to
what is impleented below.
}

set standardize(K_Type mu) = K_Type_Pol:
standardize(parameter(mu)*0)

set standardize(K_Type_Pol P) = K_Type_Pol:
0*P + for c@p in P do standardize(p*0) od

set first_K_type(K_Type_Pol P) = K_type(first_param(P))

set find(Param p,ParamPol P)=bool:
   let list=monomials(P) in any(for q in list do p=q od)

{all K_types that occur with mu as LKTs in some standard module}
set R_packet(K_Type (x,lam))=ParamPol:
   let G=real_form(x),zero=0*lam, L=Levi_by_wt(lam+x.involution*lam,x)
   then kgbs=##for y in KGB(L)
               do let xprime = embed_KGB(y,G)
                 in if xprime.involution = x.involution then [xprime] else []
	            fi
	       od
   then result=null_module(G)
   in for xp in kgbs do result+:=standardize(parameter(xp,lam,zero))
                     od; result

{Move one step down from mu in the partial order; may result in extra terms}
set pre_down(K_Type mu) = ParamPol:
   let q=parameter(mu), Q=LKT(parameter(mu))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in result+:=R
	   fi
	od; result

set pre_down(Param p)=pre_down(LKTs(p)[0])

set down_old(K_Type mu) = ParamPol:
   let q=parameter(mu), Q=LKT(parameter(mu))
   then HT=height(q), lambda =Q.lambda
   then Lambda = lambda + (Q.x.involution)*lambda, rd=mu.root_datum,
        zeroPol = null_module(q.real_form), x=Q.x, zero = 0*mu, zeronu=0*lambda
   then result=zeroPol
     in for avee@j in poscoroots(rd)
        do if (Lambda*avee > 0 and not( is_compact(j,x)))
              then let R=to_ht(HT-1)(standardize(standardize
	                  (parameter(x,lambda-posroots(rd)[j], zeronu))*0))
                   in for m in monomials(R)
	              do if find(q,branch_std(m,HT)) then result+:=m
                         fi
	              od
	 fi od;
   result

{The function down@ParamPol (below) without test for removal}
set down_alt(ParamPol P)=ParamPol:
   let G=real_form(P), list=##for p in monomials(P) do LKTs(p) od
   then result=null_module(G)
   in for mu in list do result+:=pre_down(mu)
                     od; result

{Move down one step in the partial order for a list of K-types, assumed to
be in one R-packet; remove any K-types whose standard does not contain any K-type
from the list}
set down(ParamPol P)=ParamPol:
   let G=real_form(P), list=monomials(P)
   then HT=height(list[0]), result=null_module(G)
   in for p in list
       do for m in monomials(pre_down(p))
          do if any(for r in list do find(r,branch_std(m,HT)) od)
	     then result+:=m
	     fi
	  od
	od; result

set down_alt(K_Type mu)=prints("Height of mu= ",height(parameter(mu)));
   down_alt(R_packet(mu))

set down(K_Type mu)=prints("Height of mu= ",height(parameter(mu)));
   down(R_packet(mu))

{test whether the K-type is at the bottom of the preorder}
set bottom(K_Type mu) = bool:
    down(mu) = 0*mu

set rec_fun down_cone(K_Type mu) = K_Type_Pol:
   let result = 0*mu
   in result +:= down(mu) + for c@p in down(mu) do down_cone(K_type(p))
                                               od

{up assumes mu = (x',lambda') is standard but perhaps not normal, and
nonzero. Moves one (possibly non-simple) step up in the partial
order.}

{S needs a separate case for avee real parity: CAYLEY. This should
only be needed when avee is simple as a real root(??). In that case
lambda*avee is meant to be ODD (otherwise the K-type was not final). I
HOPE that the formula
lambda' = lambda-(lambda*avee)*posroots(rd)[j]\2
then gives lambda'*avee = 1.
}
set up_old(K_Type mu) = K_Type_Pol:
let q=parameter(mu), Q=LKTs(parameter(mu)) then HT=height(q), lambda =
Q[0].lambda then Lambda = lambda + (Q[0].x.involution)*lambda,
rd=mu.root_datum, zeroPol = null_module(q.real_form),
zero = 0*mu, zeronu=0*lambda in
zero+ ##for p in Q do let x=p.x  in for avee@j in
poscoroots(rd) do let S=
case #is_real(j,x)
 in standardize(standardize(parameter(x,lambda+posroots(rd)[j], zeronu))*0),
standardize(standardize(parameter(Cayley(j,x), lambda-((lambda*avee)\2)*posroots(rd)[j], zeronu))*0) +
  standardize(standardize(parameter(cross(j,Cayley(j,x)), lambda-((lambda*avee)\2)*posroots(rd)[j]\2, zeronu))*0)
esac
then R = S- to_ht(HT)(S)
 in if (Lambda*avee >= 0 and not(is_compact(j,x))) then R
 else zero fi
od od

{Move one step up in the partial order of K-types}
set up(K_Type mu)=ParamPol:
   let list=monomials(R_packet(mu))
   then result=null_module(real_form(mu))
   in for m in list do for (c,p) in %K_type_formula(m)
                        do if int_part(c)<0 then result+:=p fi
                        od
		    od; result

{As previous function, but remove some terms that are further
up in the partial order}
set up_plus(K_Type mu)=ParamPol:
   let NM=null_module(real_form(mu)),start=up(mu)
   then result=NM
   in while start!=NM do let p=first_param(start)
                         in for q in monomials(start)
			    do if p!=q and find(q,K_type_formula(p))
			       then start-:=q
			       fi
			    od; start-:=p; result+:=p
		      od; result

set rec_fun up_cone(K_Type mu, int bound) = K_Type_Pol:
     if to_ht(bound)(up(mu)) = 0*mu then 0*mu
      else let result = 0*mu
            in result +:= to_ht(bound)(up(mu))
	         + for c@p in up(mu) do up_cone(K_type(p),bound)
		                     od fi

{
testing:

set G=Sp(4,R)
set all = all_parameters_gamma(G,[4,2])

 for j:#all do prints(j,bottom(K_type(all[j]*0))) od

for j:#all do prints(j,"  ",height(all[j]),"  ",K_type(all[j]*0),"  ",
down(K_type(all[j]*0)),new_line)
od

for j:#all do prints(j,"  ",height(all[j])),"  ",K_type(all[j]*0),"  ",
down_cone(K_type(all[j]*0)),new_line)  od

{This is awful: need to replace print_K_types by output routine from
print_branch_?_long}
for j:#all do prints(new_line,j,"  ",height(all[j]),"  ",all[j]*0);
print_K_types(down_cone(K_type(all[j]*0)), KGB(G,3))  od
}

set test_down(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_down_alt(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_alt(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_down_cone(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_cone(mu))
      do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od

set test_up(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(up(mu))
      do prints(p," ",height(p)," ",find(p,branch_std(q,height(p)))) od

set test_up_cone(K_Type mu,int n)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(up_cone(mu,n))
      do prints(p," ",height(p)," ",find(p,branch_std(q,height(p)))) od

{Test functions}
set rec_fun down_cone_alt(K_Type mu) = K_Type_Pol:
   let result = 0*mu
     in result +:= down_alt(mu) + for c@p in down_alt(mu) do down_cone_alt(K_type(p))
                                                       od

set test_down_cone_alt(K_Type mu)=void:
   let h=height(parameter(mu)),q=parameter(mu)
   in prints("height of mu: ",h);
   for p in monomials(down_cone_alt(mu))
   do prints(p," ",height(p)," ",find(q,branch_std(p,h))) od
