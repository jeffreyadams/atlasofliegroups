<groups.at
<combinatorics.at { for type |Partition| nd related fucntions }
<Weylgroup.at
<cyclotomic.at
<ellipticExceptional.at { tabulates elliptic classes for exceptional types }

{ The purpose of this file is listing conjugacy classes of elliptic elements of
  the Weyl group for root data of simple type

  Elliptic Weyl group elements are those whose reflection action does not have
  any eigenvalue 1. Every Weyl group element is elliptic for a Levi subgroup
  (not necessesarily standard) and hence conjugate to an element elliptic for a
  standard Levi subgroup; this serves in conjugacy_classes.at as basis for the
  generation of representatives of all conjugacy classes of Weyl group elements.

  Our generation is based on a reduction to the simple case (and reconstruction
  from elements for the simple factors), andthen case by case according to type.
}

{
  Elliptic conjugacy classes in classical groups. This is based on an explicit
  construction, for each type (B and C are equal). Implementation will be done
  below inside the function |elliptic_simple|, so there is no code here.

  In type $A_n$ there is just the Coxeter element, with word |#n=[0,1,...,n-1]|
  (in the symmetric group, the conjugacy class of maximal length cycles).

  In type $B_n$, $C_n$, using realisation of $W$ as signed permutations of $n$,
  elliptic elements are products of cycles with on each cycle an odd number of
  sign changes. To generate the classes, we find the partitions of $n$ (from
  combinatorics.at), for each partition make a corresponding product of cycles
  (one for each part), each composed with a sign flip on the final element
  (which flip is obtained by conjugation from the final simple reflection).

  For type $D_n$ we follow the same idea, but it is complicated by the fact that
  sign flips come in pairs, so we can only use partitions with an even number of
  parts, and double sign flips must be conjugated from the product of the two
  final simple reflections (those on the teeth of the forked $D_n$ diagram).
}

{ Elliptic conjugacy classes in exceptional types. We simply tabulate here. }

set ! G2_elliptic_words = [[int]]: [ [0,1], [0,1,0,1], [0,1,0,1,0,1] ]
set ! F4_elliptic_words = [[int]]:
  [ #4 { Coxeter element }
  , [0,1,2,1,2,3]
  , [0,1,0,2,1,2,3,2]
  , [0,1,2,1,2,3,2,1,2,3]
  , [0,1,0,2,1,0,2,1,2,3]
  , [0,1,0,2,1,0,2,3,2,1,2,3]
  , [0,1,0,2,1,0,2,1,2,3,2,1,2,3]
  , [0,1,0,2,1,0,2,3,2,1,0,2,1,2,3,2]
  , [0,1,0,2,1,0,2,1,2,3,2,1,0,2,1,2,3,2,1,0,2,1,2,3]
  ]
set ! E6_elliptic_words = [[int]]:
  [ #6 { Coxeter element }
  , [0,1,2,3,1,4,3,5]
  , [0,1,2,0,3,1,2,3,4,3,5,4]
  , [0,1,2,3,1,2,3,4,3,1,2,3,4,5]
  , [0,1,2,0,3,1,2,0,3,4,3,1,2,0,3,4,5,4,3,1,2,3,4,5]
  ]
set ! E7_elliptic_words = [[int]]:
  [ #7 { Coxeter element }
  , [0,1,2,3,1,4,3,5,6]
  , [0,1,2,3,1,4,3,5,4,3,6]
  , [0,1,2,3,1,4,3,1,2,3,4,5,6]
  , [0,1,2,3,1,2,3,4,3,1,2,3,4,5,6]
  , [0,1,2,3,1,2,3,4,3,1,2,3,4,5,4,6,5]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,3,5,4,3,6,5,4]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,5,4,6,5]
  , [0,1,2,0,3,1,2,0,3,4,3,1,2,0,3,4,5,4,3,1,2,3,4,5,6]
  , [0,1,2,3,1,2,3,4,3,1,2,3,4,5,4,3,1,2,3,4,5,6,5,4,3,1,2,3,4,5,6]
  , [0,1,2,0,3,1,2,3,4,3,1,2,0,3,4,5,4,3,1,2,3,4,5,6,5,4,3,1,2,3,4,5,6]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,1,5,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5
    ,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5,4,3,1,2,3,4,5,6]
  ]
set ! E8_elliptic_words = [[int]]:
  [ #8 { Coxeter element }
  , [0,1,2,3,1,4,3,5,6,7]
  , [0,1,2,3,1,4,3,5,4,3,6,7]
  , [0,1,2,0,3,1,2,3,4,3,5,4,6,7]
  , [0,1,2,0,3,1,2,3,4,3,5,4,6,5,4,7]
  , [0,1,2,3,1,2,3,4,3,1,2,3,4,5,6,7]
  , [0,1,2,3,1,2,3,4,3,1,2,3,4,5,4,6,5,7]
  , [0,1,2,0,3,1,2,3,4,3,1,2,5,4,3,6,5,4,3,7]
  , [0,1,2,3,1,2,3,4,3,1,2,3,4,5,4,3,6,5,4,7,6,5]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,3,5,4,3,6,5,4,7]
  , [0,1,2,0,3,1,2,0,3,4,3,1,2,3,4,5,4,3,6,5,4,7,6,5]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,5,4,6,5,7]
  , [0,1,2,0,3,1,2,0,3,4,3,1,2,0,3,4,5,4,3,1,2,3,4,5,6,7]
  , [0,1,2,0,3,1,2,0,3,4,3,1,2,0,3,2,4,5,4,3,6,5,4,7,6,5]
  , [0,1,2,0,3,1,2,0,3,4,3,1,2,0,3,4,5,4,3,1,2,3,4,5,6,5,7,6]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,5,4,3,1,2,3,6,5,4,3,7,6,5,4]
  , [0,1,2,3,1,2,3,4,3,1,2,3,4,5,4,3,1,2,3,4,5,6,5,4,3,1,2,3,4,5,6,7]
  , [0,1,2,0,3,1,2,3,4,3,1,2,0,3,4,5,4,3,1,2,3,4,5,6,5,4,3,1,2,3,4,5,6,7]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,4,5,4,3,1,2,0,3,4,5,6,5,4,3,1,2,3,4,5,6,7,6
    ,5,4]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,1,5,4,3,1,2,0,3,4,5,6,5,4,3,1,2,3,4,5
    ,6,7,6,5]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,3,4,5,4,3,1,2,0,3,4,5,6,5,4,3,1,2,0,3,2,4,3,5,4
    ,6,5,7,6,5,4]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,5,4,3,1,2,3,4,5,6,5,4,3,2,0,7,6,5,4,3
    ,1,2,3,4,5,6]
  , [0,1,2,0,3,1,2,0,3,4,3,1,2,0,3,4,5,4,3,1,2,3,4,5,6,5,4,3,1,2,3,4,5,6,7,6,5,4
    ,3,1,2,3,4,5,6,7]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,4,5,4,3,1,2,0,3,2,4,5,6,5,4,3,1,2,0,3,2,4,3
    ,5,4,6,5,7,6,5,4]
  , [0,1,2,0,3,1,2,0,3,4,3,1,2,0,3,4,5,4,3,1,2,0,3,4,5,6,5,4,3,1,2,0,3,4,5,6,7,6
    ,5,4,3,1,2,3,4,5,6,7]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,1,5,4,3,1,2,3,4,6,5,4,3,1,2,0,3,2,4,3
    ,7,6,5,4,3,1,2,0,3,2,4,3,1,5,4,3,6,5,4,7,6,5]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,1,5,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5
    ,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5,4,3,1,2,3,4,5,6,7]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,1,5,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5
    ,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,7,6,5,4,3,1,2,3,4,5,6,7]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,5,4,3,1,2,0,3,2,4,3,1,5,6,5,4,3,1,2,0,3
    ,2,4,3,1,5,4,3,2,0,6,7,6,5,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5,4,3,1,2,3,4,5,6
    ,7,6,5,4]
  , [0,1,2,0,3,1,2,0,3,2,4,3,1,2,0,3,2,4,3,1,5,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5
    ,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5,4,3,1,2,3,4,5,6,7,6,5,4,3,1,2,0,3,2,4,3,1
    ,5,4,3,2,0,6,5,4,3,1,2,3,4,5,6,7,6,5,4,3,1,2,0,3,2,4,3,1,5,4,3,2,0,6,5,4,3,1
    ,2,3,4,5,6,7]
  ]

{ Weyl words (since we have no root datum here) for elliptic classes in Weyl
  group of a simple Lie type, using usual (Bourbaki) numbering of generators }
set elliptic_simple = (string,int->[[int]]):

  { local functions that could be global, but serve only here: }
  let up (int low, int count) = [int]: for i: count from low do i od
  , down (int low, int count) = [int]: for i: count from low ~do i od
  then BC_cycle(int a, int b, int n) = [int]: { cycle on interval [a:b[ }
    up(a,n-a) ## down(b-1,n-b)
    { think first factor as up(a,b-a-1) ## up(b-1,n-b) # (n-1) }
  , D_cycles(int a, int b, int c, int n) = [int]: { assuming |a<b<c<=n| }
    up(a,n-a) ## down(b-1,n-1-b) { first cycle with one sign, and a final -1 }
    ## { second cycle is similar, unless |c=n| which needs extra attention }
    if c<n then up(b,n-b) ## down(c-1,n-1-c)
    elif b<n-1 then up(b,n-b-2)#(n-1) { cancel generator |n-2| at end }
    else [] { case of last part equal to 1, cancel |n-1|, leaving nothing }
    fi
  in

  { elliptic_simple = } (string type,int rank) [[int]]:

  { local functions that use the |rank| argument: }
  let cycle_product (Partition lambda) { where |sum(lambda)=rank| } = [int]:
    let a=0 in ##for part in lambda do BC_cycle(a,a+part,rank) next a+:=part od
  , cycles_product (Partition lambda) { with |sum(lambda)=rank|, |#lambda| even}
    = [int]:
      let a=0 in
      ##for i:#lambda\2
	do let ii=i+i then b=a+lambda[ii] then c=b+lambda[ii+1]
	   in D_cycles(a,b,c,rank)
	next a:=c { afterwards advance over two parts }
	od
  in

  { body }
  case char_index(type,"ABCDEFG")
  in {A} [#rank] { just the class of the Coxeter element }
  , {B} for P in partitions(rank) do cycle_product(P) od
  , {C} for P in partitions(rank) do cycle_product(P) od
  , {D, same as BC but restricted to partitions with even number of parts }
    ## for P in partitions(rank) do case #P in [cycles_product(P)],[] esac od
  , {E}
    case rank-6
    in {E6} E6_elliptic_words, {E7} E7_elliptic_words, {E8} E8_elliptic_words
    esac
  , {F4} F4_elliptic_words
  , {G2} G2_elliptic_words
  else error("unknown type "+type)
  esac

{ Form "Cartesian product" of non-empty sequence of lists of elements of W:
  multiply together one element chosen from each list, in all possible ways

  The sequence must be non-empty, since we cannot take identity in unknown |W|.
}
set combine_W_lists ([[WeylElt]] lists) = [WeylElt]:
  let lengths = for l in lists do #l od, len=#lists in
  for p: product(lengths)
  do let (q,r)=p\%lengths~[0] then w=lists~[0][r] in
     for l@i in lengths[:1~] ~do set (q,r):=q\%l; w:=lists[i][r]*w od; w
  od

set elliptic (RootDatum rd) = [WeylElt]:
  let (lt,map_to_rd) = Cartan_matrix_type(rd.Cartan_matrix), offset=0 in
  if =#%lt then [id_W(rd)] { avoid passing empty list to |combine_W_lists| }
  else
     for (,rank):type_rank in %lt
     do for word in elliptic_simple(type_rank)
	do W_elt(rd,for s in word do map_to_rd[offset+s] od)
	od
     next offset+:=rank
     od
   . combine_W_lists
   fi

{ Order of an elliptic element of a Weyl group of type B, C, or D.
  We determine the signed cycle type of the signed permutation given by |w|;
  as |w| is assumed to be elliptic, all cycles must carry a minus sign (|true|).
  Then the centraliser in the full signed permutation group is the semidirect
  product of the product of cyclic groups generated by individual (negative)
  cycles (of order twice the cycle length) by the group permuting any cycles of
  the same lengths among each other (the normal factor, a product of symmetric
  groups). In type D this centraliser contains in particular any one (negative
  signed) cycle which is in the complement of the type D Weyl group, so for the
  centraliser in W this case requires one less factor 2. This argumnet also
  shows that n the $D_n$ case any conjugacy class in the full group of an
  elliptic element of $W$ remains a conjugacy class for $W$ (does not split).
}
set order_of_centralizer_elliptic_BCD (WeylElt w) = int:
  let signed_type = w.classic_permutation.signed_cycle_type in
  assert(for (,sign) in signed_type do sign od.all,"Not an elliptic element");
  let lambda = for (size,) in signed_type do size od
  , is_D = let (type,)=(%w.root_datum.Lie_type)[0] in type="D"
  in product(lambda) * 2^if is_D then #lambda-1 else #lambda fi *
    product(for m in frequencies(lambda) do fac(m) od)
