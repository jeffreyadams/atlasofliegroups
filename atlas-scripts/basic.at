set_type { union types for versions of |solve|, cannot share |void| tag }
[ maybe_a_vec =    (void no_solution | vec solution)
, maybe_a_ratvec = (void no_rational_solution | ratvec solution )
]

set !minus_1 = -1 { using this constant avoids evaluating unary minus }

set # (int n)= [int]: for i:n do i od       { [0,1,...,n-1] }
set # (bool b) = int: if b then 1 else 0 fi { Iverson symbol }

set ^ = !=@(bool,bool) { exclusive or }

set assert (bool b,string message) = void: if not b then error(message) fi
set assert (bool b) = void: assert(b,"assertion failed") { default message }

{ bitsets encoded as functions (int->bool) and upper bound limit }

set list (int limit, (int->bool) predicate) = [int]:
  ## for i:limit do if predicate(i) then [i] else [] fi od
set complement (int limit,(int->bool) predicate) = [int]:
  ## for i:limit do if predicate(i) then [] else [i] fi od
set complement (int n, [int] list) = [int]: { complement of increasing |list| }
  let i=0, v=0, !l=#list in { i next position to inspect, v next value to seek }
  while while i<l and list[i]=v do i+:=1; v+:=1 od; v<n do v next v+:=1 od

set count (int limit,(int->bool) predicate) = int:
  let c=0 in for i:limit do if predicate(i) then c+:=1 fi od; c

set all ([bool] p) = bool:
  for x in p do if not x then return false fi od; true
set any ([bool] p) = bool:
  for x in p do if x then return true fi od; false
set none ([bool] p) = bool:
  for x in p do if x then return false fi od; true
set first ([bool] p) = int:
  for x@i in p do if x then return i fi od; minus_1
set last ([bool] p) = int:
  let i=#p-1 in while >=i and not p[i] do i-:=1 od; i

set all (int limit,(int->bool) predicate) = bool:
  for i:limit do if not predicate(i) then return false fi od; true
set any (int limit,(int->bool) predicate) = bool:
  for i:limit do if predicate(i) then return true fi od; false
set none (int limit,(int->bool) predicate) = bool:
  for i:limit do if predicate(i) then return false fi od; true
set first (int limit,(int->bool) predicate) = int:
  for i:limit do if predicate(i) then return i fi od; minus_1
set last (int limit,(int->bool) predicate) = int:
  for i:limit ~do if predicate(i) then return i fi od; minus_1

{ if evaluating conditions is expensive, one can procedure them with '@:'}
set all ([(->bool)] p) = bool:
  for x in p do if not x() then return false fi od; true
set any ([(->bool)] p) = bool:
  for x in p do if x() then return true fi od; false
set none ([(->bool)] p) = bool:
  for x in p do if x() then return false fi od; true
set first ([(->bool)] p) = int:
  for x@i in p do if x() then return i fi od; minus_1
set last ([(->bool)] p) = int: { this is somewhat more efficient than first }
  let i=#p-1 in while >=i and not p[i]() do i-:=1 od; i

{ binary search first |i| in [low,high) with |pred(i)|, or |high| if none }
{ of course |pred| is assumed monotonic here: $pred(i)\implies pred(i+1)$ }
set binary_search_first ((int->bool)pred, int low, int high) = int:
  while low<high
  do let mid=(low+high)\2 in if pred(mid) then high:=mid else low:=mid+1 fi
  od; low

{ transform "stops" representation of weakly increasing function to function }
set from_stops ([int] stops) = (int->int):
  stops:=stops[1:]; { ignore the first stop, which should always be 0 }
  (int k): binary_search_first((int i):stops[i]>k,0,#stops) { first excess }

set inverse_permutation ([int] pi) = [int]:
   let n=#pi then result=for :n do n od in
   for v@i in pi
   do assert(v.>= and v<n and result[v]=n
            ,to_string("not a permutation (",v,")"))
   ; result[v]:=i
   od; result

{                               Integers                                }

set abs (int k)= int: if <k then -k else k fi
set sign (int k)= int: if >k then 1 elif <k then minus_1 else 0 fi

set is_odd  (int n) = bool: !=n%2
set is_even (int n) = bool:  =n%2

set min (int k, int l) = int: if k<l then k else l fi
set max (int k, int l) = int: if k<l then l else k fi

set min ([int] a) = int: let l=#a in assert(l.>,"Minimum of an empty list");
  let m=a~[0] in for i:l-1 do if a[i]<m then m:=a[i] fi od; m
set max ([int] a) = int: let l=#a in assert(l.>,"Maximum of an empty list");
  let m=a~[0] in for i:l-1 do if a[i]>m then m:=a[i] fi od; m

set min_loc ([int] a) = int: { position of first occurrence of minimum, or -1 }
  let l=#a in
  if =l then minus_1
  else let p=0, m=a[0] in
    for i:l-1 from 1 do if a[i]<m then set (p,m):=(i,a[i]) fi od; p
  fi
set max_loc ([int] a) = int: { position of first occurrence of maximum, or -1 }
  let l=#a in
  if =l then minus_1
  else let p=0, m=a[0] in
    for i:l-1 from 1 do if a[i]>m then set (p,m):=(i,a[i]) fi od; p
  fi

{ versions seeded with a "limit value" to use in case of an empty list }
set min (int !seed) = ([int]->int):
  ([int] l): let m=seed in for a in l do if a<m then m:=a fi od; m
set max (int !seed) = ([int]->int):
  ([int] l): let m=seed in for a in l do if a>m then m:=a fi od; m

set gcd (int a,int b) = int:
   if b.<= then if b.= then return a else b:=-b { force positive result} fi fi;
   while let r=a%b in r.!= do set (a,b):=(b,r) od; b

set lcm (int a,int b) = int: let d=gcd(a,b) in if d=1 then a*b else a\d*b fi.abs

set lcm ([int] v) = int: let m=1 in for x in v do m:=lcm(m,x) od; m

set =  ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0=x1 and y0=y1
set != ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0!=x1 or y0!=y1

{ scalar multiplication of list (note: *@(vec,int) returning vec is built-in) }
set * (int c,[int] r) = [int]: for a in r do c*a od

{ sum, product of a list of values }
set sum ([int] r) = int: let s=0 in for a in r do s+:=a od; s
set product ([int] r) = int: let p=1 in for a in r do p*:=a od; p

set half (int n) = int: let (q,r)=n\%2 in assert(=r,"Inexact halving"); q

set int_format = to_string@int

set is_member ([int] v) = (int->bool): { linear search; can be improved }
  (int val)bool: any(for x in v do x=val od)

set contains (int val) = ([int]->bool): ([int] v)bool:
  any(#v,(int i)bool:v[i]=val)



{                           Rational numbers                            }

set numer (rat a) = let (n,)=%a in n
set denom (rat a) = let (,d)=%a in d

set is_integer (rat r) = bool: denom(r)=1
set sign (rat a)= int: sign(numer(a)) { denominator is always positive }

set abs(rat a)=rat: sign(a)*a

set \ ((rat,rat)p) = int: floor(/p)
set \% ((rat,int)p) = (int,rat): (\p,%p) { shouldn't these two be built-in? }
set \% ((rat,rat)p) = (int,rat): (\p,%p)

{ these are mostly for ratvec arguments, but [rat] avoids coercion from vec }
set floor ([rat] v) = vec: for a in v do floor(a) od
set ceil  ([rat] v) = vec: for a in v do  ceil(a) od

set sum ([rat] r) = rat: let s=rat:0 in for a in r do s+:=a od; s
set product ([rat] r) = rat: let p=rat:1 in for a in r do p*:=a od; p

{ extend built-in scalar product of vectors to list of rational case }
set * ([rat] v, [rat] w) = rat:
   let s=rat:0 in for vi@i in v do s +:= vi*w[i] od; s

set * ([int] v, [rat] w) = rat:
   let s=rat:0 in for vi@i in v do s +:= vi*w[i] od; s

{ make a rational into an integer if possible }
set rat_as_int (rat r) = int:
  let (n,d)=%r in if d=1 then n else error("Not an integer") fi

set min (rat k, rat l) = rat: if k<l then k else l fi
set max (rat k, rat l) = rat: if k<l then l else k fi

set min ([rat] a) = rat: let l=#a in assert(l.>,"Minimum of an empty list");
  let m=a~[0] in for i:l-1 do if a[i]<m then m:=a[i] fi od; m
set max ([rat] a) = rat: let l=#a in assert(l.>,"Maximum of an empty list");
  let m=a~[0] in for i:l-1 do if a[i]>m then m:=a[i] fi od; m

set min_loc ([rat] a) = int: { position of first occurrence of minimum, or -1 }
  let l=#a in
  if =l then minus_1
  else let p=0, m=a[0] in
    for i:l-1 from 1 do if a[i]<m then set (p,m):=(i,a[i]) fi od; p
  fi
set max_loc ([rat] a) = int: { position of first occurrence of maximum, or -1 }
  let l=#a in
  if =l then minus_1
  else let p=0, m=a[0] in
    for i:l-1 from 1 do if a[i]>m then set (p,m):=(i,a[i]) fi od; p
  fi

{ versions seeded with a "limit value" to use in case of an empty list }
set min (rat !seed) = ([rat]->rat):
  ([rat] l): let m=seed in for a in l do if a<m then m:=a fi od; m
set max (rat !seed) = ([rat]->rat):
  ([rat] l): let m=seed in for a in l do if a>m then m:=a fi od; m

set with_decimals (int n) = (rat->string): (rat r) string:
   let sign=if >=r then "+" else r:=-r; "-" fi then i=floor(r), f=frac(r) in
   sign ## i.to_string ## "." ##
   ## for :n do let x=10*f in x.floor.to_string next f:=x.frac od


{                               Strings                                 }

set !new_line = ascii(10) { including this in a string passes to a new line }

set + = ##@(string,string) { + aliases string concatenation "ax" ## "is" }
set * = (string,int->string): { repeat string; use recursive doubling }
  let rec_fun rep(string s,int n) = string:
    if n=1 then s
    else let (q,r)=n\%2 then half=rep(s,q) in
      half + if =r then half else half+s fi
    fi
  in (string s,int n) string: if <=n then "" else rep(s,n) fi
set * (int n,string s) = string: s*n { allow factor to come first }

set + (string s, int i)= string: s + int_format(i)
set + (int i, string s)= string: int_format(i) + s

set + (string s, (int,int)(x,y)) = s + "(" + x + "," + y + ")"

set plural (int n) = string: if n=1 then "" else "s" fi
set plural (int n,string s) = string: n + if n=1 then s else s+"s" fi

set concat = ##@[string]

set l_adjust (int w, string s) = string:
  let d=w-#s in if <=d then s else s##(" "*d) fi
set r_adjust (int w, string s) = string:
  let d=w-#s in if <=d then s else (" "*d)##s fi
set c_adjust (int w, string s) = string:
  let d=w-#s in if <=d then s else let h=d\2 in (" "*h) ## s ## (" "*(d-h)) fi

set width (int n) = int: #int_format(n)

set split_lines (string text) = [string]:
  let result = [string]: [], a=for c in text do c od, last=0 in
  for c@i in a
  do if c=new_line then result #:= concat(a[last:i]); last:=i+1 fi
  od; result

set is_substring (string s, string text) = bool:
  let s0=for c in s do c od, t0=for c in text do c od in
  >=last(#t0-#s0,(int start):all(#s0,(int i):t0[start+i]=s0[i]))

set fgrep (string s, string text) = [string]:
  let result = [string]: [] in
  for line in split_lines(text)
  do if is_substring(s,line) then result#:=line fi
  od; result

{                               Vectors                                 }

set vector (int n,(int->int)f) = vec: for i:n do f(i) od

set ones (int n)= vec: for i:n do 1 od

set reverse (vec v)= vec: v~[:]
set lower (int k,vec v)= vec: v[:k]
set upper (int k,vec v)= vec: v[k~:]
set drop_lower (int k,vec v)= vec: v[k:]
set drop_upper (int k,vec v)= vec: v[:k~]

set <= (vec v) = bool: >= -v { anti-dominance (in fundamental weight coords) }
set <  (vec v) = bool: > -v  { strict anti-dominance }

set rec_fun all_0_1_vecs (int n) = [vec]:
  if n<=0 then [null(0)]
  else let list=all_0_1_vecs(n-1) in
    for v in list do v#0 od  ##  for v in list do v#1 od
  fi

set rec_fun power_set (int n) = [[int]]: { indices where 0_1_vecs have 1 }
  if =n then [[]] else let p=power_set(n-:=1) in p ## for S in p do S#n od fi
set power_set ([int] S) = [[int]]:
  for inx in power_set(#S) do for i in inx do S[i] od od


{                               Matrices                                }

{ matrix defined by its dimension and expression for general entry }
set matrix ((int,int)(r,c),(int,int->int) f) = mat:
  r#for j:c do for i:r do f(i,j) od od

set n_rows    (mat m) = int: let (r,) = shape(m) in r
set n_columns = #@mat { this one is built in as a # operator overload }

set column (vec v) = mat: [v] { interpret v as single column }
set row (vec v)    = mat: ^v  { interpret v as single row }

set row (mat A,int i) = vec: (^A)[i]
set column (mat A,int i) = vec: A[i]

set rows (mat A) = [vec]: ^A
set columns (mat A) = [vec]: A

set block_matrix (mat A,mat B) = mat:
  let ra=n_rows(A), rb=n_rows(B) then za=null(ra), zb=null(rb) in
  (ra+rb)# (for col in A do col##zb od ## for col in B do za##col od)

set main_diagonal (mat A) = vec:  for i:shape(A).min do A[i,i] od

{ test matrix against a multiple of the identity }
set = (mat m,int k) = bool: =(m-k)

{ add a column to a matrix, which is not predefined as operator # }
set # (mat m, vec v) = mat: n_rows(m) { require size match } # (([vec]:m)#v)
set # (vec v, mat m) = mat: n_rows(m) { require size match } # (v#([vec]:m))

{ add row to a matrix, which is similar; use operator ^ for it }
set ^ (mat m, vec v) = mat: n_columns(m) ^ (([vec]:^m)#v)
set ^ (vec v, mat m) = mat: n_columns(m) ^ (v#([vec]:^m))

set ## (mat A, mat B) = mat: { concatenate horizontally, must have same depth }
   n_rows(B) # (([vec]:A)##([vec]:B))
set ^ (mat A, mat B) = mat: { concatenate vertically, must have same width }
   n_columns(B) ^ (([vec]:^A)##([vec]:^B))

{ concatenate horizontally a list of matrices; each of n rows }
set ## (int n,[mat] L) = mat:
  n # ## for M in L do [vec]:M od

{ apply a function to all matrix entries }
set map_on (mat m) = ((int->int)->mat):
  let nr = n_rows(m)
  in ((int->int)f) mat: nr # for c in m do for e in c do f(e) od od

{ scalar multiplication }
set * (int c,mat m) = mat: map_on(m)((int e) int: c*e)
set - (mat m)= mat: { transform 36+128=164: 128 means negate entries }
  swiss_matrix_knife(164,m,0,0,0,0)

{ integer division }
set \ (mat m,int d) = mat: map_on(m)((int e) int: e\d)

{ entrywise modulo }
set % (mat m,int d) = mat: map_on(m)((int e) int: e%d)

{ version of invert@mat that uses only echelon@mat, less prone to overflow }
set invert_ech (mat A) = (mat,int):
   assert(=shape(A),"Cannot invert non square matrix");
   let (M,C,,) = A.echelon, n = A.n_columns in
   assert(=shape(M),to_string("Singular matrix (rank ",M.n_columns,"<",n,")"));
   let cols = [vec]:for :n do [] od
   , ech_inv (int k) = [rat]: { solve M[:k+1].x=id_mat(n)[k] }
        let sol = for :k do rat:0 od # /M[k,k] then b=-M[k][:k+1]*sol[k] in
        for col@j in M[:k+1,:k] ~do let m=b[j]/col[j] in b-:=col*(sol[j]:=m) od
      ; sol
   then (row_nums,common_d) = %(ratvec:
      for j:n do let(v,d)=%(ratvec:C[:j+1]*ech_inv(j)) in cols[j]:=v; /d od)
   in (n # for n@j in row_nums do cols[j]*n od , common_d)

{ matrix exponentiation }
set ^ =
  let matrix_power (mat m,int n)= mat: m { dummy for recursion } in
  begin matrix_power := { assign recursive function body }
    ( (mat m,int n): { we shall have n>0 }
      if n=1 then m
      else let (q,r)=n\%2 then mm=matrix_power(m,q) in
        mm*if =r then mm else mm*m fi
      fi
    )
  ; (mat m,int n) mat: { the actual operator ^ :}
      assert(=shape(m),"Non square matrix in exponentiation")
    ; if n>0 then matrix_power(m,n) elif =n then id_mat(n_rows(m))
      else let (m1,d)=invert_ech(m) in
        if d=1 then matrix_power(m1,-n)
        elif =d then error("Negative power of singular matrix")
        else error("Negative power of matrix not invertible over Z")
        fi
      fi
  end


set inverse (mat M) = mat:
  let (inv,d)=invert_ech(M) in
  if d=1 then inv else error("Matrix not invertible over the integers") fi

set det (mat A) = int:
( assert(=shape(A),"Determinant of non-square matrix")
; let (M,,,flip) = echelon(A) in
  if =shape(M) then flip*M.main_diagonal.product else 0 fi
)

set trace (mat A) = int:
  let (n,):sh=shape(A) in assert(=sh,"Non square matrix"); A.main_diagonal.sum

set char_poly (mat A) = vec: { characteristic polynomial of integer matrix }
  let ps = vec:[] { power sums of the eigenvalues }
  , es = vec:[1] { elementary sym.fct.s of minus the eigenvalues, reversed }
  , B=A, (n,):sh=shape(A)
  then trace (mat M) = sum(for i:n do M[i,i] od) { a bit faster than the above }
  in assert(=sh,"Non square matrix");
  { use Newton's identities $k*e_k=-\sum_{i=1}^k p_i*e_{k-i}$ to compute |es| }
  for k:n from 1 do ps #:= trace(B); B*:=A; es := (es*ps\-k) # es od; es

set saturated_span (mat M) = bool: { whether columns span saturated sublattice }
  let inv_f = inv_fact(M) in
  =#inv_f or inv_f~[0]=1 { all invariant factors are 1? test last one, if any }

{ test all columns }
set all (mat M,(vec->bool) predicate) = bool:
  all(#M,(int i)bool:M[i].predicate)
set any (mat M,(vec->bool) predicate) = bool:
  any(#M,(int i)bool:M[i].predicate)
set none (mat M,(vec->bool) predicate) = bool:
  none(#M,(int i)bool:M[i].predicate)
set first (mat M,(vec->bool) predicate) = int:
  first(#M,(int i)bool:M[i].predicate)
set last (mat M,(vec->bool) predicate) = int:
  last(#M,(int i)bool:M[i].predicate)

set columns_with ((int,vec->bool) p,mat m) = mat:
  n_rows(m)# ## for col@j in m do if p(j,col) then [col] else [] fi od
set columns_with ((vec->bool) p,mat m) = mat:
  n_rows(m)# ## for col in m do if p(col) then [col] else [] fi od
set columns_with ((int->bool) p,mat m) = mat:
  n_rows(m)# ## for col@j in m do if p(j) then [col] else [] fi od

set rows_with ((int,vec->bool) p,mat m) = mat:
  n_columns(m) ^ ## for row@i in ^m do if p(i,row) then [row] else [] fi od
set rows_with ((vec->bool) p,mat m) = mat:
  n_columns(m) ^ ## for row in ^m do if p(row) then [row] else [] fi od
set rows_with ((int->bool) p,mat m) = mat:
  n_columns(m) ^ ## for row@i in ^m do if p(i) then [row] else [] fi od

set >=(mat m) = bool: { non-negative (dominant) columns only } all(m,>=@vec)
set >(mat m) = bool: { strictly positive (dominant) columns only } all(m,>@vec)
set <=(mat m) = bool: all(m,<=@vec)
set <(mat m) = bool: all(m,<@vec)

set lookup_column (vec v,mat m) = int: last(m,(vec w)bool: w=v)
set lookup_row (vec v,mat m) = int: last(^m,(vec w)bool: w=v)

{ sum of columns of a matrix; this is so neat, avoid calling it sum_columns }
set sum (mat m)= vec: m*ones(n_columns(m))

{ solve(mat A,vec b): find a solution vec x of A*x=b, or indicate none exists
  method:
  - write A*C = M using echelon, with C an invertible matrix and, M echelon
  - solve M*y = b (possibly finding none); easy using the echelon form
  - if a solution is found, return x = C*y
}
set solve (mat A,vec b) = maybe_a_vec:
(  let (M,C,s,) = echelon(A) then (n,k)=shape(M)
   then j=0 { runs up to k, used to index backwards }, sol=null(k)
   in assert(#b=n,"equation mismatch")
;  for i:n
  ~do if j<#s and i=s~[j] { then it is a pivot row, with pivot at M[j][i] }
      then let Mj=M~[j] then (q,r)=b[i]\%Mj[i] in
         if !=r then return ().no_solution { because inexact division} fi
       ;  sol~[j]:=q; b-:=Mj*q { correct for contribution from sol[j~] }
       ;  j+:=1
       elif !=b[i] then return ().no_solution { because no pivot available }
       fi
   od
;  (C[:#sol]*sol).solution
)

set any (maybe_a_vec x) = bool:
   case x  | solution: true | no_solution: false esac
set requisition (string message) = (maybe_a_vec->vec):
   (maybe_a_vec x) vec: case x  | solution(s): s | else error(message) esac
set requisition = requisition("No solution found; having one was required")

set required_solution ((mat,vec) system) = vec: system.solve.requisition

{ multiplicative order of a matrix, hangs unless finite }
set order (mat !M) = int:
  let (n,):p =shape(M) in assert(=p,"Matrix is not square");
  let N=M, order=1, I=id_mat(n) in
  while N!=I do N *:= M; order+:=1 od; order



{                           Rational vectors                            }

set numer (ratvec a) = vec: let (n,)=%a in n
set denom (ratvec a) = int: let (,d)=%a in d

{ allow scalar multiplication form left; from right it is built-in }
set * (int i,ratvec v) = ratvec: v*i
set * (rat r,ratvec v) = ratvec: v*r

{ concatenate ratvec values: use conversion to and from [rat] }
set ## (ratvec a,ratvec b) = ratvec: ##([rat]:a,[rat]:b)
set ## ([ratvec] rs) = ratvec: ## for r in rs do [rat]:r od

set sum ([ratvec] list, int l) = ratvec: { sum of ratvecs of constant length l }
  let result = ratvec: null(l) in for v in list do result+:=v od; result

{ multiply rational matrix represented as list of columns by a rational vector
  the m*n matrix M is given as a list of n ratvec values of size m
  v is a ratvec of size n, the result is a ratvec of size m
}
set * ([ratvec] M,ratvec v) = ratvec:
  let m=#M { number of columns } in
  assert(!=m { cannot handle empty matrix } and m=#v,"size mismatch");
  let result = null(#M[0])/1 in for col@j in M do result +:= col*v[j] od;
  result

set is_integer (ratvec v) = bool: let (,d)=%v in d=1 { equivalently =(v%1) }

{ vector floor of quotient by int operation; makes vector from rational vector }
set \ (ratvec v, int k) = vec: let (n,d)=%v in n\(k*d)

{ do as |v\1| (or |\ %v|) would do, but protest if there would be a remainder }
set ratvec_as_vec (ratvec v) = vec:
  let (w,d)=%v in assert(d=1,"Not an integer vector"); w

set reverse (ratvec v)= ratvec: v~[:]
set lower (int k,ratvec v)= ratvec: v[:k]
set upper (int k,ratvec v)= ratvec: v[k~:]
set drop_lower (int k,ratvec v)= ratvec: v[k:]
set drop_upper (int k,ratvec v)= ratvec: v[:k~]

{ dominance conditions }
set <= (ratvec v) = bool: <=numer(v)
set <  (ratvec v) = bool: < numer(v)

{ solve(mat A,ratvec b): find a solution ratvec x of A*x=b, or indicate that
  none exists. Solution as in vec case, but exact division requirement is OK.
}
set solve (mat A, ratvec b) = maybe_a_ratvec:
(  let (M,C,s,) = echelon(A) then (n,k)=shape(M)
   then j=0 { runs up to k, used to index backwards }, sol=for :k do rat:0 od
   in assert(#b=n,"equation mismatch")
;  for i:n
  ~do if j<#s and i=s~[j] { then it is a pivot row, with pivot at M[j][i] }
      then let Mj=M~[j] then q=b[i]/Mj[i] in
         sol~[j]:=q; b-:=Mj*q { correct for contribution from sol[j~] }
      ;  j+:=1
      elif !=b[i] then return ().no_rational_solution { because no pivot here }
      fi
   od
;  (C[:#sol]*sol).solution
)

set any (maybe_a_ratvec x) = bool:
   case x  | solution: true | no_rational_solution: false esac
set rat_requisition (string message) = (maybe_a_ratvec->ratvec):
   (maybe_a_ratvec x) ratvec:
    case x  | solution(s): s | else error(message) esac
set requisition = rat_requisition("No solution found; having one was required")

set required_solution ((mat,ratvec) system) = ratvec: system.solve.requisition



{                           Split integers                              }

set !s = Split:(0,1) { ! means it is a constant }
set !split_1 = Split:1 { do conversion now }
set !one_minus_s = Split:(1,-1), !one_plus_s = Split:(1,1)  { near idempotents }

set int_part (Split x) = int: let (r,)=%x in r
set s_part (Split x) = int: let (,y)=%x in y
{ the names of the synonym operators are mysterious, but maybe convenient }
set + = int_part@Split
set ^ =   s_part@Split

set s_to_1 (Split x) = int: +%x        { let (a,b)=%x in a+b }
set s_to_minus_1 (Split x) = int: -%x  { let (a,b)=%x in a-b }
set times_s (Split x) = let (a,b)=%x in Split: (b,a)

set split_as_int (Split x) = int:
  let (r,y)=%x in assert(=y,"split is not an integer"); r
set \% (Split x, int n) = (Split,Split):
  let (a,b)=%x then (qa,rq)=a\%n, (qb,rb)=b\%n in ((qa,qb),(rq,rb))
{ divide Split by integer, quotient of \% but requiring rest to be zero }
set half (Split w) = Split: let (q,r)=w\%2 in assert(=r,"Inexact halving"); q
set / (Split w,int n) = Split:
  let (q,r)=w\%n in assert(=r,"Inexact division"); q
set % (Split w,int n) = Split: let (a,b)=%w in (a%n,b%n)
set exp_s(int n) = Split: if n.is_even then 1 else s fi

{ a Split coefficient is pure if it has at most one nonzero component }
set is_pure (Split w)=bool: =*%w { test if product of both components is zero }

{ nicer display of Splits }
set split_format (Split w) = string:
  let (a,b)=%w in
  if =a and !=b
  then if abs(b)>1 then int_format(b) elif b=1 then "" else "-" fi +"s"
  else int_format(a) +
    if abs(b)>1 then if <b then "" else "+" fi +int_format(b)+"s"
    elif =b then "" elif b=1 then "+s" else "-s"
    fi
  fi


set ^ = { exponentiation of split integers }
  let rec_fun split_power (Split x,int n) = Split: { we shall have n>0 }
    if n=1 then x
    else let (q,r)=n\%2 then y=split_power(x,q) in y*if =r then y else x*y fi
    fi
  in { set ^ = } (Split x,int n): Split:
    if let (a,b)=%x in abs(a)+abs(b)=1 { cases of invertible (unit) Split }
    then if n.is_even then split_1 else x fi { all are square roots of +1 }
    elif n.> then split_power(x,n)
    elif n.= then split_1
    else error("Negative power ",n," of split integer ",split_format(x))
    fi

set sum ([Split] list) = Split:
  let result=Split:0 in for x in list do result+:=x od; result

{                               Lie types				}

set Lie_type (string code, int rank) = LieType: extend(LieType:"",code,rank)

set rank (LieType t) = int: sum(for (,rank) in %t do rank od)

set semisimple_rank (LieType t) = int:
  sum(for (code,rank) in %t do if code="T" then 0 else rank fi od)

set semisimple (LieType t) = LieType:
  let s = LieType: "" in
  for (code,rank) in %t do if code!="T" then s:=extend(s,code,rank) fi od; s

set str (LieType t) = string:
  ## for (code,rank) in %t do code ## rank.to_string od

{                               Root data                               }

{ provide default values for coroot preference when building root data }

set root_datum (mat simple_roots, mat simple_coroots) = RootDatum:
  root_datum(simple_roots,simple_coroots,false) { by default prefer roots }

set root_datum (LieType type, mat lattice) = RootDatum:
  root_datum(type,lattice,false) { by default prefer roots }

set simply_connected (LieType type) = RootDatum:
  simply_connected(type,true) { by default prefer coroots here }

set adjoint (LieType type) = RootDatum:
  adjoint(type,false) { by default prefer roots here }

{ backwards compatibility function; used to be the built-in prototype }
set root_datum ([vec] simple_roots, [vec] simple_coroots, int r) = RootDatum:
  root_datum(r#simple_roots,r#simple_coroots,false)

set root_datum (LieType t, [ratvec] gens) = RootDatum:
  root_datum(t,quotient_basis(t,gens))

{ allow single kernel generator in root datum construction }
set root_datum (LieType t, ratvec gen) = RootDatum: root_datum(t,[gen])

{ the following uses that root_index(rd,v)=nr_of_posroots(rd) for a non-root v }
set is_root ((RootDatum,vec) (rd,):p) = bool:
  root_index(p)<nr_of_posroots(rd)
set is_coroot ((RootDatum,vec) (rd,):p) = bool:
  coroot_index(p)<nr_of_posroots(rd)
set is_posroot ((RootDatum,vec)(rd,):p) = bool:
  let ri=root_index(p) in >=ri and ri<nr_of_posroots(rd)
set is_poscoroot ((RootDatum,vec)(rd,):p) = bool:
  let cri=coroot_index(p) in >=cri and cri<nr_of_posroots(rd)

set posroot_index ((RootDatum,vec)p) = int: { fold roots to positive }
  let i=root_index(p) in if <i then minus_1-i else i fi
set poscoroot_index ((RootDatum,vec)p) = int: { fold coroots to positive }
  let i=coroot_index(p) in if <i then minus_1-i else i fi


set rho (RootDatum rd) = ratvec:
  let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_weight(rd,i) od; res
{ this uses fewer additions than computing half sum of the positive roots }

{ make rho as a vector of integers if possible }
set rho_as_vec (RootDatum r)= vec: ratvec_as_vec(rho(r))

set rho_check (RootDatum rd) = ratvec: { rho(dual(rd)), but a bit faster }
  let res= ratvec: null(rank(rd))
  in for i:semisimple_rank(rd) do res +:= fundamental_coweight(rd,i) od; res

{ see also rho_i@KGBElt and rho_r@KGBElt defined below }

{ these functions assume vec is a root/coroot }
set is_positive_root (RootDatum rd) = (vec->bool):
  let rc = rho_check(rd) in (vec alpha) bool: >rc*alpha
set is_positive_coroot (RootDatum rd) = (vec->bool):
  let rho = rho(rd) in (vec alphav) bool: >alphav*rho
set is_negative_root (RootDatum rd) = (vec->bool):
  let rc = rho_check(rd) in (vec alpha) bool: <rc*alpha
set is_negative_coroot (RootDatum rd) = (vec->bool):
  let rho = rho(rd) in (vec alphav) bool: <alphav*rho

set is_positive_root (RootDatum rd,vec alpha) = bool:
  is_positive_root(rd)(alpha)
set is_positive_coroot (RootDatum rd,vec alphav) = bool:
  is_positive_coroot(rd)(alphav)
set is_negative_root (RootDatum rd,vec alpha) = bool:
  is_negative_root(rd)(alpha)
set is_negative_coroot (RootDatum rd,vec alphav) = bool:
  is_negative_coroot(rd)(alphav)

{ the first 2 functions assume roots/coroots, the second pair tests for this }
set roots_all_positive (RootDatum rd) = (mat->bool): { no negative roots }
  let are_pos = is_positive_root(rd) in (mat roots) bool: all(roots,are_pos)
set coroots_all_positive (RootDatum rd) = (mat->bool): { no negative coroots }
  let are_pos = is_positive_coroot(rd) in
  (mat coroots) bool: all(coroots,are_pos)
set among_posroots (RootDatum rd) = (mat M)bool: { all colums M posroots? }
  all(M,(vec v)bool: is_posroot(rd,v))
set among_poscoroots (RootDatum rd) = (mat M)bool: { all colums M poscoroots? }
  all(M,(vec v)bool: is_poscoroot(rd,v))

set negative_system (mat posroots) = { the missing half of the root system }
  swiss_matrix_knife(172,posroots,0,0,0,0) { 172= 36+8+128: reverse cols,neg }

{ having _all_ roots can be useful }
set roots (RootDatum rd) = mat:
  let pr=posroots(rd) in negative_system(pr) ## pr
set coroots (RootDatum rd) = mat:
  let pcr=poscoroots(rd) in negative_system(pcr) ## pcr

{ the correspondence between roots and coroots }
set root (RootDatum rd, vec alpha_v) = vec: root(rd,coroot_index(rd,alpha_v))
set coroot (RootDatum rd, vec alpha) = vec: coroot(rd,root_index(rd,alpha))

{ reflection action of roots }
set reflection (RootDatum rd, int i) = mat: { i indexes a root/coroot pair }
  1 - column(root(rd,i))*row(coroot(rd,i))
set reflection ((RootDatum,vec)(rd,):p) = mat: { specify root (not coroot) }
  reflection(rd,root_index(p))
set coreflection (RootDatum rd, int i) = mat: { i indexes a root/coroot pair }
  1 - column(coroot(rd,i))*row(root(rd,i))
set coreflection ((RootDatum,vec)(rd,):p) = mat: { specify root (not coroot) }
  coreflection(rd,root_index(p))
set reflect (RootDatum rd, int i, vec v) = vec: { apply reflection(rd,i)*v }
  v -:= root(rd,i) * (coroot(rd,i)*v) { more efficient than matrix multiply }
set reflect (RootDatum rd, vec alpha, vec v) = vec: { reflection(rd,alpha)*v }
  v -:= alpha * (coroot(rd,alpha)*v)
set coreflect (RootDatum rd, vec v, int i) = vec: { apply v*reflection(rd,i) }
  v -:= (v*root(rd,i)) * coroot(rd,i)
set coreflect (RootDatum rd, vec v, vec alpha) = vec: { v*reflection(rd,alpha) }
  v -:= (v*alpha) * coroot(rd,alpha)

set reflect (RootDatum rd, int i, ratvec v) = ratvec:
  let (n,d) = %v in reflect(rd,i,n)/d
set reflect (RootDatum rd, vec alpha, ratvec v) = ratvec:
  let (n,d) = %v in reflect(rd,alpha,n)/d
set coreflect (RootDatum rd, ratvec v, int i) = ratvec:
  let (n,d) = %v in coreflect(rd,n,i)/d
set coreflect (RootDatum rd, ratvec v, vec alpha) = ratvec:
  let (n,d) = %v in coreflect(rd,n,alpha)/d

{ in matrix version reflect becomes left_reflect and coreflect right_reflect }
set left_reflect (RootDatum rd, int i, mat M) = mat: { reflection(rd,i)*M }
  n_rows(M) # for v in M do reflect(rd,i,v) od
set left_reflect (RootDatum rd, vec alpha, mat M) = mat:
  left_reflect(rd,root_index(rd,alpha),M)
set right_reflect (RootDatum rd, mat M, int i) = mat: { M*reflection(rd,i) }
  n_columns(M) ^ for row in ^M do coreflect(rd,row,i) od
set right_reflect (RootDatum rd, mat M, vec alpha) = mat:
  right_reflect(rd,M,root_index(rd,alpha))

set conjugate (RootDatum rd, int i, mat M) = mat: { r*M*r where r=reflection }
  left_reflect(rd,i,right_reflect(rd,M,i))
set conjugate (RootDatum rd, vec alpha, mat M) = mat:
  conjugate(rd,root_index(rd,alpha),M)


set singular_simple_indices (RootDatum rd,ratvec v) = [int]:
  let rv=[int]:[] { cannot use columns_with: must find _indices_ of columns }
  in for a@j in simple_coroots(rd) do if =a*v then rv:=rv#j fi od; rv

set is_imaginary (mat theta) = (vec->bool): (vec alpha): theta*alpha=alpha
set is_real      (mat theta) = (vec->bool): (vec alpha): theta*alpha=-alpha
set is_complex   (mat theta) = (vec->bool): (vec alpha):
  let ta = theta*alpha in ta!=alpha and ta!=-alpha

{ these functions are just for convenience; posroot versions are more useful }
set imaginary_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(theta),roots(rd))
set real_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(theta),roots(rd))

{ for coroots we need to use the transpose matrix }
set imaginary_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(^theta),coroots(rd))
set real_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(^theta),coroots(rd))

{ positive (co)roots versions are actually more useful }
set imaginary_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(theta),posroots(rd))
set real_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(theta),posroots(rd))
set imaginary_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(^theta),poscoroots(rd))
set real_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(^theta),poscoroots(rd))
set imaginary_sys ((RootDatum,mat)p) = (mat,mat):
  (imaginary_posroots(p),imaginary_poscoroots(p))
set real_sys ((RootDatum,mat)p) = (mat,mat):
  (real_posroots(p),real_poscoroots(p))

{ returns whether v is a weakly dominant weight for rd }
set is_dominant (RootDatum rd, ratvec v) = bool:
  >=(numer(v)*simple_coroots(rd))
set is_strictly_dominant (RootDatum rd, ratvec v) = bool:
  >(numer(v)*simple_coroots(rd))
set is_regular (RootDatum rd,ratvec v)= bool: { tests all positive coroots }
  all(for x in numer(v)*poscoroots(rd) do !=x od)
set is_integral (RootDatum rd, ratvec v) = bool: { integral on all coroots }
  =(v*simple_coroots(rd)%1)

{ the following should replace the needlessly complicacted built-ins they use }
set radical_basis (RootDatum rd) = mat: { columns are coweights }
  coroot_radical(rd)[:,semisimple_rank(rd):] { drop coroots part }
set coradical_basis (RootDatum rd) = mat: { columns are weights }
  root_coradical(rd)[:,semisimple_rank(rd):] { drop roots part }

set is_semisimple (RootDatum rd) = bool: semisimple_rank(rd) = rank(rd)

set derived_is_simply_connected (RootDatum rd) = bool:
  saturated_span(simple_coroots(rd))
set has_connected_center (RootDatum rd) = bool:
  saturated_span(simple_roots(rd))
set is_simply_connected (RootDatum rd) = bool:
  is_semisimple(rd) and derived_is_simply_connected(rd)
set is_adjoint (RootDatum rd) = bool:
  is_semisimple(rd) and has_connected_center(rd)

{ the following functions give but partial information; giving a more complete
  definition for InnerClass values needs more work (see group_operations.at)
}
set derived (RootDatum rd) = RootDatum: let (d,)=derived_info(rd) in d
set mod_central_torus (RootDatum rd) = RootDatum:
  let (d,)=mod_central_torus_info(rd) in d
set adjoint (RootDatum rd) = RootDatum: { change weight basis to simple roots }
  root_datum(id_mat(semisimple_rank(rd)),Cartan_matrix(rd))

{ from appropriate (subsystem) dual 2rho value, deduce test for being simple }
set is_simple_for (vec dual_two_rho) = (vec->bool):
  (vec alpha): dual_two_rho*alpha=2

{ get generating simple system from set of matching posroots and poscoroots }
set simple_from_positive (mat posroots,mat poscoroots) = (mat,mat):
  ( columns_with(is_simple_for(sum(poscoroots)),posroots)
  , columns_with(is_simple_for(sum(posroots)),poscoroots)
  )

set fundamental_weights (RootDatum rd) = [ratvec]:
  for i:semisimple_rank(rd) do fundamental_weight(rd,i) od
set fundamental_coweights (RootDatum rd) = [ratvec]:
  for i:semisimple_rank(rd) do fundamental_coweight(rd,i) od

{ find a root of maximal level; if |rd| is simple this is the highest root }
{.highest root.}
set highest_root (RootDatum rd) = vec:
{ root data produced by |dual@RootDatum| are not ordered by level, so do work: }
  let pr=posroots(rd), rho_check=rho_check(rd) in
  if =pr then error("Empty set of roots, none is highest")
  else pr[for alpha in pr do rho_check*alpha od.max_loc]
  fi

set word_making_dominant (RootDatum rd, ratvec lambda) = [int]:
   while let i = first(semisimple_rank(rd),(int i): <coroot(rd,i)*lambda) in
      >=i
   do i next lambda:=reflect(rd,i,lambda)
   od

{                               Inner classes                           }

set involution (LieType lt, string ict) = mat: involution(lt,#lt.rank,ict)

{ get inner class of G symbolically from root datum and inner class type
  Use the complex reductive group given by the root datum, but compute the
  distinguished involution from the string describing it symbolically.
}
set inner_class (RootDatum rd, string ict) = InnerClass:
   let inv0 = { involution named |ict|, for |simply_connected(Lie_type(rd))| }
     let (lt,pi) = rd.Cartan_matrix.Cartan_matrix_type { |lt| is semisimple }
     , r=rd.rank-rd.semisimple_rank { rank of the central torus }
     in involution(extend(lt,"T",r),pi ## for i:r from #pi do i od,ict)
   , P=^coroot_radical(rd) { sublattice basis, in |simply_connected(...)| }
   then (P1,d)=invert(P) then prod=P1*inv0*P { base change from |P|, times |d| }
   in assert(=(prod%d),"Inner class not compatible with root datum");
   inner_class(rd,prod\d) { construct inner class from explicit involution }

{ integrality inner class (dual side) defined by inf. character and involution }
set dual_integral (InnerClass ic, ratvec gamma) = InnerClass:
  inner_class(dual(integrality_datum(ic,gamma)),-^distinguished_involution(ic))

set big_block (InnerClass ic) = Block:
  block(quasisplit_form(ic), dual_quasisplit_form(ic))


{                               Cartan classes                          }

set Cartan_classes (InnerClass ic) = [CartanClass]:
  for i:nr_of_Cartan_classes(ic) do Cartan_class(ic,i) od

set print_Cartan_info (CartanClass cc) = void:
  let show (string s) = string: if s="" then "empty" else s fi
  , ((cr,Cr,sr),ww,(orbit_size,fiber_size),(i_tp,r_tp,C_tp)) = Cartan_info(cc)
  in
  ( "compact: ",cr,", complex: ",Cr,", split: ",sr, new_line
  , "canonical twisted involution: "
  ,  if =#ww then "e"
     else to_string(ww[0], ## for s in ww[1:] do to_string(",",s+1) od)
     fi
  , new_line
  , "twisted involution orbit size: ",orbit_size,
           "; fiber size: ",fiber_size,"; strong inv: ",orbit_size*fiber_size
  , new_line
  , "imaginary root system: ",show(str(i_tp)), new_line
  , "real root system: ",show(str(r_tp)), new_line
  , "complex factor: ",show(str(C_tp)), new_line
  ).prints


set fundamental_Cartan (InnerClass ic) = CartanClass: Cartan_class(ic,0)
{ implicitly fundamental_Cartan(RealForm f) = fundamental_Cartan(InnerClass:f) }
set most_split_Cartan (InnerClass ic) = CartanClass:
  Cartan_class(ic,nr_of_Cartan_classes(ic)-1)
{ also most_split_Cartan@RealForm is built-in, but is not that of inner class }

{ in the following, Complex factors count as half-compact, half-split }
set compact_rank (CartanClass cc) = int:
  let ((c,C,),,,) = Cartan_info(cc) in c+C
set split_rank (CartanClass cc) = int:
  let ((,C,s),,,) = Cartan_info(cc) in C+s

set compact_rank (InnerClass ic) = int: compact_rank(fundamental_Cartan(ic))
set split_rank (RealForm G)     = int: split_rank(most_split_Cartan(G))

set is_equal_rank (InnerClass ic) = bool: { whether distinguished_involution=1 }
  =split_rank(fundamental_Cartan(ic))
{ implicitly is_equal_rank (RealForm G) = bool: is_equal_rank(InnerClass:G) }

set is_split (RealForm G) = bool: { whether most split Cartan has theta = -1 }
  =compact_rank(most_split_Cartan(G))

{ equality of Cartan classes }
set = (CartanClass H,CartanClass J) = bool:
  let (,theta_H,,)=Cartan_info(H), (,theta_J,,)=Cartan_info(J) in
  theta_H=theta_J { compare their twisted involutions }

{ number of the Cartan class H in the list of those for the real form G }
set number(CartanClass H,RealForm G) = int:
  last(nr_of_Cartan_classes(G), (int i)bool: Cartan_class(G,i)=H)

{                               Real forms                              }

set form_name (RealForm f) = string: form_names(f)[form_number(f)]

set real_forms (InnerClass ic)= [RealForm]:
  real_forms(fundamental_Cartan(ic))
set dual_real_forms (InnerClass ic) = [RealForm]:
  dual_real_forms(most_split_Cartan(ic))

set is_quasisplit (RealForm G) = bool: form_number(G)=nr_of_real_forms(G)-1
set is_quasicompact (RealForm G) = bool: form_number(G)=0

set split_form (RootDatum r) = RealForm:
  quasisplit_form(inner_class(r,-id_mat(rank(r))))

{ split form of a Lie type is taken simply connected (times a split torus) }
set split_form (LieType t) = RealForm: split_form(simply_connected(t))

set quasicompact_form (InnerClass ic) = RealForm: real_form(ic,0)
{ quasisplit_form@InnerClass is built-in }

set is_compatible (RealForm f, RealForm g) = bool:
  let ic = inner_class(f) in
  inner_class(g)=dual(ic) and >block_sizes(ic)[form_number(f),form_number(g)]

set is_compact (RealForm G) = bool: { real form 0 in equal rank inner class }
  KGB_size(G)=1 and distinguished_involution(G)=1



{                              KGB elements                             }

set real_form (KGBElt x) = let (rf,) = %x in rf
set # (KGBElt x) = let (,n) = %x in n
set root_datum (KGBElt x) = RootDatum: real_form(x)
set inner_class (KGBElt x) = InnerClass: real_form(x)

set KGB (RealForm rf) = [KGBElt]: for i:KGB_size(rf) do KGB(rf,i) od

{ all KGB elements of G mapping to its Cartan class H }
set KGB (CartanClass H,RealForm G) = [KGBElt]:
  ## for x in KGB(G) do if Cartan_class(x)=H then [x] else [] fi od

set KGB_elt ((InnerClass, mat, ratvec) (,theta,v):all) = KGBElt:
  let rf = real_form(all)   { find real form within ic }
  in KGB_elt(rf,theta,v)    { find KGB element within rf }

{ NB: elements produced by the following function test unequal to any others }
set KGB_elt (RootDatum rd, mat theta, ratvec v) = KGBElt:
  let ic = inner_class(rd,theta)   { find the proper inner class }
  then rf = real_form(ic,theta,v)  { find real form within ic }
  in KGB_elt(rf,theta,v)           { find KGB element within rf }

set Cartan_class (InnerClass ic, mat theta) = CartanClass:
  KGB_elt(ic,theta,ratvec:null(rank(ic))).Cartan_class

{ use the following as follows: |set <= = Bruhat_order(G)| }
set Bruhat_order (RealForm G) = (KGBElt,KGBElt->bool):
  let M=inverse(1-KGB_Hasse(G)) in (KGBElt x, KGBElt y) bool: !=M[#x,#y]

set status (vec alpha,KGBElt x) = int: status(root_index(real_form(x),alpha),x)

set cross (vec alpha,KGBElt x) = KGBElt:
  cross(root_index(root_datum(x),alpha),x)
set Cayley (vec alpha,KGBElt x) = KGBElt:
  Cayley(root_index(real_form(x),alpha),x)

{ cross action of Weyl group element; avoid name conflict cross@(vec,KGBElt) }
set W_cross ([int] w,KGBElt x) = KGBElt:
  for s in w ~ do x:=cross(s,x) od; x

set KGB_status_text (int i) = string: ["C-","ic","r ","nc","C+"][i]

set status_text ((int,KGBElt)p) = string: KGB_status_text(status(p))
set status_text ((vec,KGBElt)p) = string: KGB_status_text(status(p))
set status_texts (KGBElt x) = [string]:
  for s:semisimple_rank(real_form(x)) do status_text(s,x) od

set is_complex ((int,KGBElt)p) = status(p)%4=0
set is_real ((int,KGBElt)p) = status(p)=2
set is_imaginary ((int,KGBElt)p) = status(p)%2=1
set is_noncompact ((int,KGBElt)p) = status(p)=3
set is_compact ((int,KGBElt)p) = status(p)=1
set is_descent ((int,KGBElt)p) = status(p)<3
set is_ascent ((int,KGBElt)p) = status(p)>=3
set is_strict_descent ((int,KGBElt)p) = is_descent(p) and not is_compact(p)

{ status of general roots for a KGBElt (which here just represents its fiber) }

set is_imaginary (KGBElt x) = (vec->bool): is_imaginary(involution(x))
set is_real (KGBElt x)      = (vec->bool): is_real(involution(x))
set is_complex (KGBElt x)   = (vec->bool): is_complex(involution(x))


set imaginary_posroots (KGBElt x) = mat:
  imaginary_posroots(root_datum(x),involution(x))
set real_posroots (KGBElt x) = mat:
  real_posroots(root_datum(x),involution(x))
set imaginary_poscoroots (KGBElt x) = mat:
  imaginary_poscoroots(root_datum(x),involution(x))
set real_poscoroots (KGBElt x) = mat:
  real_poscoroots(root_datum(x),involution(x))
set imaginary_sys (KGBElt x) = (mat,mat):
  let p = (root_datum(x),involution(x))
  in (imaginary_posroots(p),imaginary_poscoroots(p))
set real_sys (KGBElt x) = (mat,mat):
  let p = (root_datum(x),involution(x))
  in (real_posroots(p),real_poscoroots(p))

set rho_i (KGBElt x) = ratvec: sum(imaginary_posroots(x))/2
set rho_r (KGBElt x) = ratvec: sum(real_posroots(x))/2
set rho_check_i (KGBElt x) = ratvec: sum(imaginary_poscoroots(x))/2
set rho_check_r (KGBElt x) = ratvec: sum(real_poscoroots(x))/2

set rho_i ((RootDatum,mat) rd_theta) = ratvec:
  sum(imaginary_posroots(rd_theta))/2
set rho_r ((RootDatum,mat) rd_theta) = ratvec:
  sum(real_posroots(rd_theta))/2
set rho_check_i ((RootDatum,mat) rd_theta) = ratvec:
  sum(imaginary_poscoroots(rd_theta))/2
set rho_check_r ((RootDatum,mat) rd_theta) = ratvec:
  sum(real_poscoroots(rd_theta))/2

{ compact/noncompact status for a given KGBElt of general imaginary roots }
set is_compact (KGBElt x) = (vec->bool):
  let coweight = rho_check_i(x)+torus_factor(x), is_im=is_imaginary(x)
  in (vec alpha) bool: assert(is_im(alpha)); =(coweight*alpha)%2
set is_noncompact (KGBElt x) = (vec->bool):
  let coweight = rho_check_i(x)+torus_factor(x), is_im=is_imaginary(x)
  in (vec alpha) bool: assert(is_im(alpha)); !=(coweight*alpha)%2

{ for roots not known to be imaginary, use these functions instead }
set is_compact_imaginary (KGBElt x) = (vec->bool):
  let p=is_imaginary(x), q=is_compact(x) { allow pre-computation for x }
  in (vec alpha) bool: p(alpha) and q(alpha)
set is_noncompact_imaginary (KGBElt x) = (vec->bool):
  let p=is_imaginary(x), q=is_noncompact(x) { allow pre-computation for x }
  in (vec alpha) bool: p(alpha) and q(alpha)

set compact_posroots (KGBElt x) = mat:
  columns_with(is_compact(x),imaginary_posroots(x))
set noncompact_posroots (KGBElt x) = mat:
  columns_with(is_noncompact(x),imaginary_posroots(x))

set rho_ci (KGBElt x)  = ratvec: sum(compact_posroots(x))/2
set rho_nci (KGBElt x) = ratvec: sum(noncompact_posroots(x))/2

set is_imaginary (vec v,KGBElt x) = bool: v.(is_imaginary(x))
set is_real (vec v,KGBElt x) =      bool: v.(is_real(x))
set is_complex (vec v,KGBElt x) =   bool: v.(is_complex(x))
set is_compact_imaginary (vec v,KGBElt x) = bool: v.(is_compact_imaginary(x))
set is_noncompact_imaginary (vec v,KGBElt x) = bool:
  v.(is_noncompact_imaginary(x))

set print_KGB (KGBElt x) = void:
( prints(new_line,"Element is number ",#x, " in following KGB set")
; print_KGB(real_form(x)) )

set no_Cminus_roots (KGBElt x) = bool:
  none(semisimple_rank(real_form(x)), (int i)bool: =status(i,x))
set no_Cplus_roots (KGBElt x) = bool:
  none(semisimple_rank(real_form(x)), (int i)bool: status(i,x)=4)

{                               Blocks                                  }

set blocks (RealForm rf) = [Block]:
   let ic=InnerClass:rf then sizes=(^block_sizes(ic))[rf.form_number] in
## for drf in dual_real_forms(ic)
   do if >sizes[drf.form_number] then [block(rf,drf)] else [] fi
   od

set blocks (InnerClass ic) = [Block]:
   let sizes=block_sizes(ic) in
## for rf@i in real_forms(ic)
   do
   ## for drf@j in dual_real_forms(ic)
      do if >sizes[i,j] then [block(rf,drf)] else [] fi
      od
   od

set raw_KL  ((RealForm,RealForm) p) = (mat,[vec],vec): raw_KL(block(p))
set dual_KL ((RealForm,RealForm) p) = (mat,[vec],vec): dual_KL(block(p))

set print_block  ((RealForm,RealForm) p) = void: print_block (block(p))
set print_blocku ((RealForm,RealForm) p) = void: print_blocku(block(p))
set print_blockd ((RealForm,RealForm) p) = void: print_blockd(block(p))
set print_KL_basis ((RealForm,RealForm) p) = void: print_KL_basis(block(p))
set print_prim_KL  ((RealForm,RealForm) p) = void: print_prim_KL(block(p))
set print_KL_list  ((RealForm,RealForm) p) = void: print_KL_list(block(p))
set print_W_cells  ((RealForm,RealForm) p) = void: print_W_cells(block(p))
set print_W_graph  ((RealForm,RealForm) p) = void: print_W_cells(block(p))


{                           Module parameters                           }

set root_datum (Param p) = RootDatum: real_form(p)
set inner_class (Param p) = InnerClass: real_form(p)

set null_module (Param p) = ParamPol:
  null_module(real_form(p)) { avoid using ParamPol version below, could throw }

set x (Param p) = KGBElt: let (x,,) =%p in x
set lambda_minus_rho (Param p) = vec: let (,lambda_rho,) =%p in lambda_rho
set lambda (Param p) = ratvec: lambda_minus_rho(p)+rho(real_form(p))
set infinitesimal_character (Param p) = ratvec: let (,,gamma) =%p in gamma
set d_lambda (Param p) = ratvec: let (x,,gamma) =%p in (1+involution(x))*gamma/2
set nu (Param p) = ratvec:       let (x,,gamma) =%p in (1-involution(x))*gamma/2
set Cartan_class (Param p) = CartanClass: Cartan_class(x(p))

set involution (Param p)=involution(x(p))

set integrality_datum (Param p)= RootDatum:
  integrality_datum(root_datum(p),infinitesimal_character(p))

set is_regular (Param p) = bool:
  is_regular(root_datum(p),infinitesimal_character(p))

{. Test whether (the infinitesimal character of) a parameter is
   strongly regular. .}
set is_strongly_regular (Param p)=bool:
   let G=real_form(p) in let ic=infinitesimal_character(p)
   in is_dominant(root_datum(G),ic-rho(G))

{ whether irreducible rpn survives translation functor from regular inf.char. }
set survives (Param p) = bool:
  is_final(p) { was recently defined to mean exactly that }

set trivial (RealForm G) = Param: { parameter for the trivial representation }
  param(KGB(G,KGB_size(G)-1),null(rank(G)),rho(G))

{ cross action of Weyl group element; avoid name conflict cross@(vec,Param) }
set W_cross ([int] w,Param p) = Param:
  for s in w ~ do p:=cross(s,p) od; p

{ parameter(G,x,lambda,nu)=param(KGB(G,x),lambda-rho(G),nu), so you can enter
  lambda without the rho shift; lambda may have denominator 2 or be a vec
}
set parameter (RealForm G,int x,ratvec lambda,ratvec nu) = Param:
  param(KGB(G,x),ratvec_as_vec(lambda-G.rho),nu)
set parameter (KGBElt x,ratvec lambda,ratvec nu) = Param:
  param(x,ratvec_as_vec(lambda-x.real_form.rho),nu)

{ set parameter ensuring (upon sucess) that the infinitesimal char. is |gamma|;
  achieve this by ignoring |(1+theta)*lambda|, replace it by |(1+theta)*gamma| }
set parameter_gamma(KGBElt x, ratvec lambda, ratvec gamma) = Param:
  let (G,nx)=%x, theta=involution(x) in
  { ((1-theta)*lambda+(1+theta)*gamma)/2 = lambda+(1+theta)*(gamma-lambda)/2 }
  parameter(G,nx,lambda+(1+theta)*(gamma-lambda)/2,gamma)

{ variation of built-in |block@Param| that weeds out non-starred block elts }
set singular_block (Param p) = ([Param],int):
  let (B,i)=block(p)
  then block = ## for q in B do if q.survives then [q] else [] fi od
  in (block, { new index of |p|:} first(for q in block do p=q od))

{ get just the parameters from a block, just a shorcut to: (params,)=block(p) }
set block_of (Param p) = [Param]: let (params,)=block(p) in params
set singular_block_of (Param p) = [Param]:
  let (params,)=singular_block(p) in params

{ status of parameter with respect to integrality generator s, or root alpha }

set imaginary_type (int s, Param p) = int: if cross(s,p)=p then 2 else 1 fi
set real_type (int s,Param p) = int: if cross(s,p)=p then 1 else 2 fi

set imaginary_type (vec alpha, Param p) = int:
  if cross(alpha,p)=p then 2 else 1 fi
set real_type (vec alpha, Param p) = int:
  if cross(alpha,p)=p then 1 else 2 fi

set is_nonparity (int s,Param p)=bool: is_real(s,x(p)) and Cayley(s,p)=p
set is_parity (int s,Param p)= bool: is_real(s,x(p)) and Cayley(s,p)!=p

set is_nonparity (vec alpha,Param p)=bool:
  is_real(alpha,x(p)) and Cayley(alpha,p)=p
set is_parity (vec alpha,Param p)= bool:
  is_real(alpha,x(p)) and Cayley(alpha,p)!=p

set status (vec alpha,Param p) = int: { enum: C-, ic, r1, r2, C+, rn, i1, i2 }
  let st=status(alpha,x(p)) in
  if st<=1 or st=4 then st { complex and imaginary compact cases keep old code }
  elif st=3 then { imaginary non-compact } 5+imaginary_type(alpha,p)
  elif Cayley(alpha,p)=p then { real non-parity } 5
  else 1+real_type(alpha,p)
  fi

set status (int s,Param p) = int: { this is NOT related to status(s,x(p)) }
  status(root(integrality_datum(p),s),p)

set block_status_text (int i) = string:
  case i in "C-","ic","r1","r2","C+","rn","i1","i2" esac

set status_text (int s,Param p) = string: block_status_text(status(s,p))
set status_texts (Param p) = [string]:
  for s:semisimple_rank(real_form(p)) do status_text(s,p) od

set status_text ((vec,Param) ap) = string: block_status_text(status(ap))

set parity_poscoroots (Param p) = mat: { set of positive real parity coroots }
  let (alpha,real_poscoroots)=real_sys(x(p))
  in columns_with((int i):status(alpha[i],p)!=5,real_poscoroots)
set nonparity_poscoroots (Param p) = mat: { positive real nonparity coroots }
  let (alpha,real_poscoroots)=real_sys(x(p))
  in columns_with((int i):status(alpha[i],p)=5,real_poscoroots)

set is_descent (int s,Param p) = bool: status(s,p)<4
set tau_bitset (Param p) = (int,(int->bool)):
  (p.real_form.semisimple_rank, (int s): is_descent(s,p))

set tau (Param p)            = [int]: list(tau_bitset(p))
set tau_complement (Param p) = [int]: complement(tau_bitset(p))

set is_descent ((vec,Param) ap) = bool: status(ap)<4

set lookup (Param p, [Param] block) = int:
  let i=#block-1 in while >=i and block[i]!=p do i-:=1 od; i

{ (moved from hermitian.at) orientation_number_term(orientation_nr(p),q) =
  s^{[\ell_0(p)-\ell_0(q)]/2} which should be defined and gives 1 or s
}
set orientation_nr_term = (int,Param->Split):
  let err()=
    error("computing orientation number for odd difference of lengths")
  in (int ori_nr_p,Param q) Split:
  case (ori_nr_p-orientation_nr(q))%4 in 1, err(), s, err() esac


{                       Extended blocks                                 }

set extended_status_texts = [string]:
  [ { 0:} "1C+","1C-","1i1","1r1f","1i2f","1r2","1i2s","1r1s","1rn","1ic"
  , {10:} "2C+","2C-","2Ci","2Cr"
     ,"2i11","2r11","2i12f","2r21f","2i22","2r22","2i12s","2r21s","2rn","2ic"
  , {24:} "3C+","3C-","3Ci","3r","3i","3Cr","3rn","3ic"
  ]

set print_extended_block = (Param,mat->):
  let has_double_Cayley (int n) =
    if n<5 then n>=3 else n>=15 and n<19 fi { 1r1f,1i2f,2r11,2i12f,2r21f,2i22 }
  , has_defect(int n) =
    if n<14 then n>=12 else n>=26 and n<30 fi { 2Ci, 2Cr, 3Ci, 3r, 3i, 3Cr }
  in (Param p, mat delta) void:
  let (block,types,L0,L1) = extended_block(p,delta)
  , G=p.real_form, parent_block=block_of(p)
  then (l,r)=shape(types)
  , indices =
      let i=0 in for p in block do while parent_block[i]!=p do i+:=1 od; i od
  then wx=width(G.KGB_size-1), wp=width(#parent_block-1)
  , with_sign(int n) = string:
    if n<0 then "-"+(indices[minus_1-n]) else "+"+indices[n] fi
  in
  for q@i in block
  do prints
  (r_adjust(wp,int_format(indices[i]))
  ,": ["
  , ## { statuses }
    for j:r
    do if j=0 then "" else "," fi
    ## l_adjust(5,extended_status_texts[types[i,j]])
    od
  , "]"
  , ## { cross actions }
    for j:r
    do r_adjust (wp+2, with_sign(
       if L0[i,j]=l or has_double_Cayley(types[i,j]) or has_defect(types[i,j])
       then i { self cross when either 0 or 2 Cayleys or there is a defect }
       elif L1[i,j]=l then L0[i,j] else L1[i,j] { complex resp single Cayley }
       fi))
    od
  , "; "
  , ## { Cayley transforms }
    for j:r
    do c_adjust (2*wp+3,
       if has_double_Cayley(types[i,j])
       then L0[i,j].with_sign+","+L1[i,j].with_sign { double valued Cayley }
       elif has_defect(types[i,j]) or L1[i,j]<l
       then L0[i,j].with_sign { defect case or other single valued Cayley }
       else "." { compact, nonparity or complex: no Cayley }
       fi)
    od
  , "  x=" , r_adjust(wx,to_string(#x(q))) , ", " , lambda_minus_rho(q)
  )
  od

{                   Polynomials in module parameters                    }

set null_module (ParamPol P) = ParamPol: 0*P { built-in does this efficiently }
set -(ParamPol P) = ParamPol: minus_1*P

set first_param (ParamPol P) = Param: let (,p)=first_term(P) in p
set last_param (ParamPol P)  = Param: let (,p)=last_term(P) in p

set s_to_1 (ParamPol P)       = ParamPol: 0*P + for x@q in P do (+%x,q) od
set s_to_minus_1 (ParamPol P) = ParamPol: 0*P + for x@q in P do (-%x,q) od

{ counterpart to built-in +@(ParamPol,(Split,Param)) }
set - (ParamPol a, (Split,Param) (c,p)) = ParamPol: a+(-c,p)

set sum (RealForm G,[ParamPol] Ps) = ParamPol:
  let n=#Ps in
  if n=0 then G.null_module
  else Ps. { do divide and conquer so as to privilege balanced additions }
    ( rec_fun s([ParamPol] Ps) ParamPol: { |Ps| has at least one term }
        let h = (#Ps)\2 in if =h then Ps[0] else s(Ps[:h])+s(Ps[h:]) fi
    )
  fi

set map ((Param->Param)f, ParamPol P) = ParamPol:
  0*P + for c@p in P do (c,f(p)) od

set map ((Param->ParamPol)f, ParamPol P) = ParamPol:
  sum(P.real_form,for c@p in P do c*f(p) od)

set half (ParamPol P) = ParamPol: 0*P+ for c@t in P do (half(c),t) od
{ inverse of multiplication *@(int,ParamPol); don't confuse with scaling }
set divide_by (int n, ParamPol P) = ParamPol: 0*P+ for c@t in P do (c/n,t) od

{ simulate coercion (KGBElt->RealForm) in some cases }
set root_datum (ParamPol P) = RootDatum: real_form(P)

set virtual (Param p) = ParamPol: p { for making implicit conversion explcit }
set virtual (RealForm G, [Param] ps) = ParamPol:
  let one=Split:(1,0) in null_module(G)+for p in ps do (one,p) od
{ DON'T define virtual ([Param] pp): cannot be correctly defined when #pp=0 }

{ branch to get only the coefficient of a specific K-type }
set branch (Param std, Param K_type) = int:
  branch(std,height(K_type))[K_type].int_part

set branch (ParamPol P, Param K_type) = Split: { Split coefficients possible }
  branch(P,height(K_type))[K_type]

{ nice output of ParamPol: split_format the coefficients }
set pol_format (ParamPol P)= string:
  ## for w@p in P do to_string("(",w.split_format,")*",p,new_line) od

{ find what should be unique infintesimal character shared by all terms }
set infinitesimal_character(ParamPol P) = ratvec:
  assert(!=P,"empty polynomial has no infinitesimal character");
  let (,,gamma)=%first_param(P) in
  for @p in P
  do assert(infinitesimal_character(p)=gamma
           ,"infinitesimal character not unique")
  od; gamma

{ split up a ParamPol into terms below a given height and the rest }
set height_split (ParamPol P, int h) = (ParamPol,ParamPol):
  let below=0*P, above=0*P in
  for c@q in P
  do if q.height<h then below+:=(c,q) else above+:=(c,q) fi
  od; (below,above)

{ more generally, groups terms into different ParamPol, by value of gamma }
set separate_by_infinitesimal_character (ParamPol P) = [(ratvec,ParamPol)]:
  let M = [(ratvec,ParamPol)]:[]
  then insert ((Split,Param)(,p):term ) = void: { insert into M }
    let inserted=false, gamma=infinitesimal_character(p) in
    for (key,P)@i in M
    do if key=gamma then M[i]:=(key,P+term); inserted:=true fi
    od
  ; if not inserted then M #:= (gamma,ParamPol: p) fi
  in for c@p in P do insert(c,p) od; M

{ whether all coefficients are integer repectively integer mulitples of |s| }
set is_pure_1 (ParamPol P)=bool: all(for c in P do c.s_part.= od)
set is_pure_s (ParamPol P)=bool: all(for c in P do c.int_part.= od)

{ a module is considered pure if either all coefficients are integer of if all
  coefficients are integer multiples of s; stronger than all coefficents pure }
set is_pure (ParamPol P)=bool: P.is_pure_1 or P.is_pure_s

{ report number of integer, purely s, and mixed terms }
set purity (ParamPol P)=(int,int,int):
  let (x,y,z)=(0,0,0) in
  for coef in P
  do let (a,b)=%coef in { we know (a,b)/=(0,0), so 3 cases arise }
    if =b then x+:=1 elif =a then y+:=1 else z+:=1 fi
  od; (x,y,z)

{                               Miscellaneous                           }

{                   Miscellaneous find functions                     }

{ find index of item in list, or -1 if not found; first does this }

set find ([int] v, int k) = int:      first(#v,(int i)bool:v[i]=k)
set find ([Param] P,Param p) = int:   first(#P,(int i)bool:P[i]=p)
set find ([KGBElt] S,KGBElt x) = int: first(#S,(int i)bool:S[i]=x)
set find ([vec] S,vec v) = int:       first(#S,(int i)bool:S[i]=v)

{ No version for finding [int] due to potential ambiguity with vec version.
  Note that |find(L,x)| has alternative |first(for y in L do x=y od)| which
  can be used for all types having =, without separate definition of |find|
}

set in_string_list (string s,[string] S) = bool:
  >=first(for t in S do s=t od)

{ delete one term from a list }
set delete ([int] v, int k)     =[int]:     v[:k]##v[k+1:]
set delete ([vec] v, int k)     =[vec]:     v[:k]##v[k+1:]
set delete ([ratvec] v, int k)  =[ratvec]:  v[:k]##v[k+1:]
set delete ([[ratvec]] v, int k)=[[ratvec]]:v[:k]##v[k+1:]
set delete ([[vec]] v, int k)   =[[vec]]:   v[:k]##v[k+1:]
set delete ([ParamPol] P, int k)=[ParamPol]:P[:k]##P[k+1:]

set positive_imaginary_roots_and_coroots = imaginary_sys@(RootDatum,mat)
set positive_imaginary_roots_and_coroots = imaginary_sys@KGBElt

set imaginary_roots_and_coroots ((RootDatum, mat)p) = (mat,mat):
  let (a,b)=imaginary_sys(p) in (negative_system(a)##a, negative_system(b)##b)
set imaginary_roots_and_coroots (KGBElt x) = (mat,mat):
  imaginary_roots_and_coroots (root_datum(real_form(x)),involution(x))

set positive_real_roots_and_coroots = real_sys@(RootDatum,mat)
set positive_real_roots_and_coroots = real_sys@KGBElt

set real_roots_and_coroots ((RootDatum, mat)p) = (mat,mat):
  let (a,b)=real_sys(p) in (negative_system(a)##a, negative_system(b)##b)
set real_roots_and_coroots (KGBElt x) = (mat,mat):
  real_roots_and_coroots (root_datum(real_form(x)),involution(x))

set complex_posroots (RootDatum rd,mat theta) =  mat:
  columns_with(is_complex(theta),posroots(rd))
set complex_posroots (KGBElt x) =  mat:
  complex_posroots(root_datum(x),involution(x))

{ pad string with blanks (for lining up columns in tables) }
set pad(string s,int padding)=string: l_adjust(padding,s)

{ for user convenience; a ParamPol is an associative array ParamPol->Split
  so selecting its monomials (Param values) by position is not reliable, but
  allowing so is useful in user sessions to pick terms from a computed result
}
set monomials (ParamPol P) = [Param]: for c@p in P do p od
set monomial  (ParamPol P,int i) = Param: monomials(P)[i]

{. Convert a list of ParamPols into the list of distinct parameters occuring;
   careful: don't let terms cancel! .}
set monomials([ParamPol] list)=[Param]:
   let sum=null_module(real_form(list[0])) in
   for P in list do for c@p in P do sum+:=p od od;monomials(sum)