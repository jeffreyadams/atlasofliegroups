set_type { union types for versions of |solve|, cannot share |void| tag }
[ maybe_a_vec =    ( void no_vec | vec solution)
, maybe_a_ratvec = ( void no_ratvec | ratvec solution )
, maybe_a_mat =    ( void no_mat | mat solution )
]

set !minus_1 = -1 { using this constant avoids evaluating unary minus }
set ~ (int n) = minus_1-n { subtract from -1, or bitwise complement }

set # (int n)= [int]: for i:n do i od       { [0,1,...,n-1] }
set # (bool b) = int: if b then 1 else 0 fi { Iverson symbol }
set sign (bool b) = int: { |minus_1^#b|, i.e.: } if b then minus_1 else 1 fi

set ^ = !=@(bool,bool) { exclusive or }

set assert (bool b,string message) = void: if not b then error(message) fi
set assert (bool b) = void: assert(b,"assertion failed") { default message }

{ bitsets encoded as functions (int->bool) together with upper bound |limit| }

set bitset ([int] L) =
  let map=[bool]:[], len=0 { invariant len=#map } in
  for x in L ~ { reversing loop minimises expansions for many lists }
  do if x<len then map[x]:=true
     else map := for i:x+1 do if i<len then map[i] else i=x fi od ; len := x+1
     fi
  od; (len,(int i)bool: map[i])

set list (int limit, (int->bool) predicate) = [int]:
  ## for i:limit do if predicate(i) then [i] else [] fi od
set complement (int limit,(int->bool) predicate) = [int]:
  ## for i:limit do if predicate(i) then [] else [i] fi od
set complement (int n, [int] list) = [int]:
  let (len,f)=bitset(list) in complement(n,(int i)bool: i<len and f(i))

set count (int limit,(int->bool) predicate) = int:
  let c=0 in for i:limit do if predicate(i) then c+:=1 fi od; c

set all ([bool] p) = bool:
  for x in p do if not x then return false fi od; true
set any ([bool] p) = bool:
  for x in p do if x then return true fi od; false
set none ([bool] p) = bool:
  for x in p do if x then return false fi od; true
set first ([bool] p) = int:
  for x@i in p do if x then return i fi od; minus_1
set last ([bool] p) = int:
  let i=#p-1 in while >=i and not p[i] do i-:=1 od; i
set count ([bool] p) = int: { count (sum) number of truths in list }
  let c=0 in for b in p do if b then c+:=1 fi od; c

set all (int limit,(int->bool) predicate) = bool:
  for i:limit do if not predicate(i) then return false fi od; true
set any (int limit,(int->bool) predicate) = bool:
  for i:limit do if predicate(i) then return true fi od; false
set none (int limit,(int->bool) predicate) = bool:
  for i:limit do if predicate(i) then return false fi od; true
set first (int limit,(int->bool) predicate) = int:
  for i:limit do if predicate(i) then return i fi od; minus_1
set last (int limit,(int->bool) predicate) = int:
  for i:limit ~do if predicate(i) then return i fi od; minus_1

{ if evaluating conditions is expensive, one can procedure them with '@:'}
set all ([(->bool)] p) = bool:
  for x in p do if not x() then return false fi od; true
set any ([(->bool)] p) = bool:
  for x in p do if x() then return true fi od; false
set none ([(->bool)] p) = bool:
  for x in p do if x() then return false fi od; true
set first ([(->bool)] p) = int:
  for x@i in p do if x() then return i fi od; minus_1
set last ([(->bool)] p) = int: { this is somewhat more efficient than first }
  let i=#p-1 in while >=i and not p[i]() do i-:=1 od; i

{ binary search first |i| in [low,high) with |pred(i)|, or |high| if none }
{ of course |pred| is assumed monotonic here: $pred(i)\implies pred(i+1)$ }
set binary_search_first ((int->bool)pred, int low, int high) = int:
  while low<high
  do let mid=(low+high)\2 in if pred(mid) then high:=mid else low:=mid+1 fi
  od; low

{ transform "stops" representation of weakly increasing function to function }
set from_stops ([int] stops) = (int->int):
  stops:=stops[1:]; { ignore the first stop, which should always be 0 }
  (int k): binary_search_first((int i):stops[i]>k,0,#stops) { first excess }

{                               Integers                                }

set abs (int k)= int: if <k then -k else k fi
set sign (int k)= int: if >k then 1 elif <k then minus_1 else 0 fi

set is_odd  (int n) = bool: !=n%2
set is_even (int n) = bool:  =n%2

set min (int k, int l) = int: if k<l then k else l fi
set max (int k, int l) = int: if k<l then l else k fi

set min ([int] a) = int: let l=#a in assert(l.>,"Minimum of an empty list");
  let m=a~[0] in for i:l-1 do if a[i]<m then m:=a[i] fi od; m
set max ([int] a) = int: let l=#a in assert(l.>,"Maximum of an empty list");
  let m=a~[0] in for i:l-1 do if a[i]>m then m:=a[i] fi od; m

set min_loc ([int] a) = int: { position of first occurrence of minimum, or -1 }
  let l=#a in
  if =l then minus_1
  else let p=0, m=a[0] in
    for i:l-1 from 1 do if a[i]<m then set (p,m):=(i,a[i]) fi od; p
  fi
set max_loc ([int] a) = int: { position of first occurrence of maximum, or -1 }
  let l=#a in
  if =l then minus_1
  else let p=0, m=a[0] in
    for i:l-1 from 1 do if a[i]>m then set (p,m):=(i,a[i]) fi od; p
  fi

{ versions seeded with a "limit value" to use in case of an empty list }
set min (int !seed) = ([int]->int):
  ([int] l): let m=seed in for a in l do if a<m then m:=a fi od; m
set max (int !seed) = ([int]->int):
  ([int] l): let m=seed in for a in l do if a>m then m:=a fi od; m

set gcd (int a,int b) = int:
   if b.<= then if b.= then return a else b:=-b { force positive result} fi fi;
   while let r=a%b in r.!= do a:=b; b:=r od; b

set lcm (int a,int b) = int: let d=gcd(a,b) in if d=1 then a*b else a\d*b fi.abs

set lcm ([int] v) = int: let m=1 in for x in v do m:=lcm(m,x) od; m

set =  ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0=x1 and y0=y1
set != ((int,int)(x0,y0),(int,int)(x1,y1)) = bool: x0!=x1 or y0!=y1

{ scalar multiplication of list (note: *@(vec,int) returning vec is built-in) }
set * (int c,[int] r) = [int]: for a in r do c*a od

{ sum, product of a list of values }
set sum ([int] r) = int: let s=0 in for a in r do s+:=a od; s
set product ([int] r) = int: let p=1 in for a in r do p*:=a od; p

set half (int n) = int: let (q,r)=n\%2 in assert(=r,"Inexact halving"); q
set exact_divide (int a, int b) = int:
    let (q,r)=a\%b in assert(=r,"Inexact division"); q

set int_format = to_string@int

set is_member ([int] v) = (int->bool):
  (int val)bool: any(#v,(int i)bool: v[i]=val)

set contains (int val) = ([int]->bool): ([int] v)bool:
  any(#v,(int i)bool:v[i]=val)

set fac (int n) = int: let p=1 in for i:n-1 from 2 do p *:=i od; p

{ convert to base n as polynomial: small coef polynomial evaluating to k at n }
set to_base_poly (int n) = (int->vec): (int k) vec: assert(k.>=);
  let r=0{dummy for mulit-assign} in while !=k do set (k,r):=k\%n; r od

set to_base (int n, (int->string) digit) = (int->string):
  let tbp=to_base_poly(n) in
  (int k) string: assert(k.>=); ##for c in tbp(k) ~do c.digit od

set binary = (int->string):
  let f=to_base(2,to_string@int) in
  (int n)string: if n.< then "-"##f(-n) else f(n) fi

set hexadecimal = (int->string):
  let !shift = "A".ascii-10
  then f=to_base(16,(int k): if k<=9 then k.to_string else ascii(k+shift) fi)
  in (int n)string: if n.< then "-"##f(-n) else f(n) fi

{                           Rational numbers                            }

set numer (rat a) = let (n,)=%a in n
set denom (rat a) = let (,d)=%a in d

set is_integer (rat r) = bool: denom(r)=1
set sign (rat a)= int: sign(numer(a)) { denominator is always positive }

set abs(rat a)=rat: sign(a)*a

set \ ((rat,rat)p) = int: floor(/p)
set \% ((rat,int)p) = (int,rat): (\p,%p) { shouldn't these two be built-in? }
set \% ((rat,rat)p) = (int,rat): (\p,%p)

{ these are mostly for ratvec arguments, but [rat] avoids coercion from vec }
set floor ([rat] v) = vec: for a in v do floor(a) od
set ceil  ([rat] v) = vec: for a in v do  ceil(a) od

set sum ([rat] r) = rat: let s=rat:0 in for a in r do s+:=a od; s
set product ([rat] r) = rat: let p=rat:1 in for a in r do p*:=a od; p

{ extend built-in scalar product of vectors to list of rational case }
set * ([rat] v, [rat] w) = rat:
   let s=rat:0 in for vi@i in v do s +:= vi*w[i] od; s

set * ([int] v, [rat] w) = rat:
   let s=rat:0 in for vi@i in v do s +:= vi*w[i] od; s

{ make a rational into an integer if possible }
set rat_as_int (rat r) = int:
  let (n,d)=%r in if d=1 then n else error("Not an integer") fi

set min (rat k, rat l) = rat: if k<l then k else l fi
set max (rat k, rat l) = rat: if k<l then l else k fi

set min ([rat] a) = rat: let l=#a in assert(l.>,"Minimum of an empty list");
  let m=a~[0] in for i:l-1 do if a[i]<m then m:=a[i] fi od; m
set max ([rat] a) = rat: let l=#a in assert(l.>,"Maximum of an empty list");
  let m=a~[0] in for i:l-1 do if a[i]>m then m:=a[i] fi od; m

set min_loc ([rat] a) = int: { position of first occurrence of minimum, or -1 }
  let l=#a in
  if =l then minus_1
  else let p=0, m=a[0] in
    for i:l-1 from 1 do if a[i]<m then set (p,m):=(i,a[i]) fi od; p
  fi
set max_loc ([rat] a) = int: { position of first occurrence of maximum, or -1 }
  let l=#a in
  if =l then minus_1
  else let p=0, m=a[0] in
    for i:l-1 from 1 do if a[i]>m then set (p,m):=(i,a[i]) fi od; p
  fi

{ versions seeded with a "limit value" to use in case of an empty list }
set min (rat !seed) = ([rat]->rat):
  ([rat] l): let m=seed in for a in l do if a<m then m:=a fi od; m
set max (rat !seed) = ([rat]->rat):
  ([rat] l): let m=seed in for a in l do if a>m then m:=a fi od; m

set with_decimals (int n) = (rat->string): (rat r) string:
   let sign=if >=r then "+" else r:=-r; "-" fi, i=floor(r), f=frac(r) in
   sign ## i.to_string ## "." ##
   ## for :n do let x=10*f in x.floor.to_string next f:=x.frac od


{                               Strings                                 }

set !new_line = ascii(10) { including this in a string passes to a new line }

set char_index (string c, string s) = int: first(#s,(int i)bool: c=s[i])

set + = ##@(string,string) { + aliases string concatenation "ax" ## "is" }
set * = (string,int->string): { repeat string; use recursive doubling }
  let rec_fun rep(string s,int n) = string:
    if n=1 then s
    else let (q,r)=n\%2 then half=rep(s,q) in
      half + if =r then half else half+s fi
    fi
  in (string s,int n) string: if <=n then "" else rep(s,n) fi
set * (int n,string s) = string: s*n { allow factor to come first }

set + (string s, int i)= string: s + int_format(i)
set + (int i, string s)= string: int_format(i) + s

set + (string s, (int,int)(x,y)) = s + "(" + x + "," + y + ")"

set plural (int n) = string: if n=1 then "" else "s" fi
set plural (int n,string s) = string: n + if n=1 then s else s+"s" fi

set concat = ##@[string]

set l_adjust (int w, string s) = string:
  let d=w-#s in if <=d then s else s##(" "*d) fi
set r_adjust (int w, string s) = string:
  let d=w-#s in if <=d then s else (" "*d)##s fi
set c_adjust (int w, string s) = string:
  let d=w-#s in if <=d then s else let h=d\2 in (" "*h) ## s ## (" "*(d-h)) fi

set width (int n) = int: #int_format(n)

set split_lines (string text) = [string]:
  let result = [string]: [], a=for c in text do c od, last=0 in
  for c@i in a
  do if c=new_line then result #:= concat(a[last:i]); last:=i+1 fi
  od; result

set is_substring (string s, string text) = bool:
  let s0=for c in s do c od, t0=for c in text do c od in
  >=last(#t0-#s0,(int start):all(#s0,(int i):t0[start+i]=s0[i]))

set fgrep (string s, string text) = [string]:
  let result = [string]: [] in
  for line in split_lines(text)
  do if is_substring(s,line) then result#:=line fi
  od; result

{                               Vectors                                 }

set vector (int n,(int->int)f) = vec: for i:n do f(i) od

set ones (int n)= vec: for i:n do 1 od

set ~ (vec v)= vec: v~[:]
set reverse ([int] r) = [int]: for x in r do x ~od
set lower (int k,vec v)= vec: v[:k]
set upper (int k,vec v)= vec: v[k~:]
set drop_lower (int k,vec v)= vec: v[k:]
set drop_upper (int k,vec v)= vec: v[:k~]

set <= (vec v) = bool: >= -v { anti-dominance (in fundamental weight coords) }
set <  (vec v) = bool: > -v  { strict anti-dominance }

set rec_fun all_0_1_vecs (int n) = [vec]:
  if n<=0 then [null(0)]
  else let list=all_0_1_vecs(n-1) in
    for v in list do v#0 od  ##  for v in list do v#1 od
  fi

set rec_fun power_set (int n) = [[int]]: { indices where 0_1_vecs have 1 }
  if =n then [[]] else let p=power_set(n-:=1) in p ## for S in p do S#n od fi
set power_set ([int] S) = [[int]]:
  for inx in power_set(#S) do for i in inx do S[i] od od
set choices_from ([int] S, int k) = [[int]]: { all $k$-subsets of $S$ }
  if k>#S then []
  else { now we will assume $n\geq k$ }
    let rec_fun from_first(int n,int k) = [[int]]: { $k$ from first $n$ of $S$ }
      if k=0 then [[]] { unique choice of 0 }
      else ## { generate by final element, and concatenate }
        for i:n-k+1 from k-1
        do let Si=S[i] in for l in from_first(i,k-1) do l#Si od
        od
      fi
    in from_first(#S,k)
  fi


{. number of times n occurs in [int] S .}
set multiplicity (int n, [int] S) = int: for x in S do x=n od.count

{                               Matrices                                }

{ matrix defined by its dimension and expression for general entry }
set matrix ((int,int)(r,c),(int,int->int) f) = mat:
  r#for j:c do for i:r do f(i,j) od od

set n_rows    (mat m) = int: let (r,) = shape(m) in r
set n_columns = #@mat { this one is built in as a # operator overload }

set column (vec v) = mat: [v] { interpret v as single column }
set row (vec v)    = mat: ^v  { interpret v as single row }

set row (mat A,int i) = vec: (^A)[i]
set column (mat A,int i) = vec: A[i]

set rows (mat A) = [vec]: ^A
set columns (mat A) = [vec]: A

set ~ (mat A) = mat: { reverse rows and reverse columns }
  swiss_matrix_knife(45,A,0,0,0,0) { transform 45 = 36 + 9, rows&cols reversed }

set block_matrix (mat A,mat B) = mat:
  let ra=n_rows(A), rb=n_rows(B) then za=null(ra), zb=null(rb) in
  (ra+rb)# (for col in A do col##zb od ## for col in B do za##col od)

set block_matrix ([mat] list) = mat:
  let m = sum(for A in list do n_rows(A) od), pos=0
  in m #
  ##for A in list
    do let pre=null(pos) then {sequential!} post=null(m-(pos+:=n_rows(A))) in
       for col in A do pre##col##post od
    od

set main_diagonal (mat A) = vec:  for i:shape(A).min do A[i,i] od

{ test matrix against a multiple of the identity }
set = (mat m,int k) = bool: =(m-k)

{ add a column to a matrix, which is not predefined as operator # }
set # (mat m, vec v) = mat: n_rows(m) { require size match } # (([vec]:m)#v)
set # (vec v, mat m) = mat: n_rows(m) { require size match } # (v#([vec]:m))

{ add row to a matrix, which is similar; use operator ^ for it }
set ^ (mat m, vec v) = mat: n_columns(m) ^ (([vec]:^m)#v)
set ^ (vec v, mat m) = mat: n_columns(m) ^ (v#([vec]:^m))

set ## (mat A, mat B) = mat: { concatenate horizontally, must have same depth }
   n_rows(B) # (([vec]:A)##([vec]:B))
set ^ (mat A, mat B) = mat: { concatenate vertically, must have same width }
   n_columns(B) ^ (([vec]:^A)##([vec]:^B))

{ concatenate horizontally a list of matrices; each of n rows }
set ## (int n,[mat] L) = mat:
  n # ## for M in L do [vec]:M od

{ apply a function to all matrix entries }
set map_on (mat m) = ((int->int)->mat):
  let nr = n_rows(m)
  in ((int->int)f) mat: nr # for c in m do for e in c do f(e) od od

{ scalar multiplication }
set * (int c,mat m) = mat: map_on(m)((int e) int: c*e)
set - (mat m)= mat: { transform 36+128=164: 128 means negate entries }
  swiss_matrix_knife(164,m,0,0,0,0)

{ sum of list of matrices, with given shape for when list is empty }
set sum ((int,int) shape, [mat] L) = mat:
  let len=#L in
  if =len then null(shape)
  else let s=L~[0] in assert(shape(s)=shape); for i:len-1 ~do s +:= L[i] od; s
  fi
{ square matrices are frequent, so there is a spacial case of |sum| for them }
set sum (int n,[mat] L) = mat: sum((n,n),L)

{ product of list of square matrices, with given size for when list is empty }
set product (int n, [mat] L) = mat:
  let len=#L in
  if =len then id_mat(n)
  else let p=L~[0] in assert(shape(p)=(n,n)); for i:len-1 ~do p *:= L[i] od; p
  fi

set gcd(mat M) = int: gcd(for c in M do gcd(c) od)

{ integer division }
set \ (mat m,int d) = mat: map_on(m)((int e) int: e\d)

{ entrywise modulo }
set % (mat m,int d) = mat: map_on(m)((int e) int: e%d)

set Smith_basis (mat M) = mat: let (basis,)=Smith(M) in basis
set inv_fact (mat M) = vec: let (,invf)=Smith(M) in invf

{ matrix exponentiation }
set ^ = (mat,int->mat):
  let rec_fun matrix_power (mat m,int n) = mat:
    if n=1 then m
    else let (q,r)=n\%2 then mm=matrix_power(m,q) in
        mm*if =r then mm else mm*m fi
    fi
  in { ^@(mat,int) = } (mat m,int n) mat:
    assert(=shape(m),"Non square matrix in exponentiation");
  if n>0 then matrix_power(m,n) elif =n then id_mat(n_rows(m))
  else let (m1,d)=invert(m) in
     if d=1 then matrix_power(m1,-n)
     elif =d then error("Negative power of singular matrix")
     else error("Negative power of matrix not invertible over Z")
     fi
  fi

set inverse (mat M) = mat:
  let (inv,d)=invert(M) in
  if d=1 then inv else error("Matrix not invertible over the integers") fi

set / = inverse@mat { so |/M| is the same as |M^-1|, but more direct }

set rank (mat A) = int: let (,,pivots,)=A.echelon in #pivots

set det (mat A) = int:
( assert(=shape(A),"Determinant of non-square matrix")
; let (M,,,flip) = echelon(A) in
  if =shape(M) then flip*M.main_diagonal.product else 0 fi
)

set trace (mat A) = int:
  let (n,):sh=shape(A) in assert(=sh,"Non square matrix"); A.main_diagonal.sum

set char_poly (mat A) = vec: { characteristic polynomial of integer matrix }
  let ps = vec:[] { power sums of the eigenvalues }
  , es = vec:[1] { elementary sym.fct.s of minus the eigenvalues, reversed }
  , B=A, (n,):sh=shape(A)
  then trace (mat M) = sum(for i:n do M[i,i] od) { a bit faster than the above }
  in assert(=sh,"Non square matrix");
  { use Newton's identities $k*e_k=-\sum_{i=1}^k p_i*e_{k-i}$ to compute |es| }
  for k:n from 1 do ps #:= trace(B); B*:=A; es := (es*ps\-k) # es od; es

set cokernel (mat M) = ^kernel(^M) { minimal matrix wose kernel is our image }

set saturated_span (mat M) = bool: { whether columns span saturated sublattice }
  let inv_f = inv_fact(M) in
  =#inv_f or inv_f~[0]=1 { all invariant factors are 1? test last one, if any }

{ test all columns }
set all (mat M,(vec->bool) predicate) = bool:
  all(#M,(int i)bool:M[i].predicate)
set any (mat M,(vec->bool) predicate) = bool:
  any(#M,(int i)bool:M[i].predicate)
set none (mat M,(vec->bool) predicate) = bool:
  none(#M,(int i)bool:M[i].predicate)
set first (mat M,(vec->bool) predicate) = int:
  first(#M,(int i)bool:M[i].predicate)
set last (mat M,(vec->bool) predicate) = int:
  last(#M,(int i)bool:M[i].predicate)

set columns_with ((int,vec->bool) p,mat m) = mat:
  n_rows(m)# ## for col@j in m do if p(j,col) then [col] else [] fi od
set columns_with ((vec->bool) p,mat m) = mat:
  n_rows(m)# ## for col in m do if p(col) then [col] else [] fi od
set columns_with ((int->bool) p,mat m) = mat:
  n_rows(m)# ## for col@j in m do if p(j) then [col] else [] fi od
set a_column_with ((vec->bool) p,mat m) = maybe_a_vec:
  for col in m do if p(col) then return solution(col) fi od; no_vec()

set rows_with ((int,vec->bool) p,mat m) = mat:
  n_columns(m) ^ ## for row@i in ^m do if p(i,row) then [row] else [] fi od
set rows_with ((vec->bool) p,mat m) = mat:
  n_columns(m) ^ ## for row in ^m do if p(row) then [row] else [] fi od
set rows_with ((int->bool) p,mat m) = mat:
  n_columns(m) ^ ## for row@i in ^m do if p(i) then [row] else [] fi od
set a_row_with ((vec->bool) p,mat m) = maybe_a_vec:
  for row in ^m do if p(row) then return solution(row) fi od; no_vec()

set >=(mat m) = bool: { non-negative (dominant) columns only } all(m,>=@vec)
set >(mat m) = bool: { strictly positive (dominant) columns only } all(m,>@vec)
set <=(mat m) = bool: all(m,<=@vec)
set <(mat m) = bool: all(m,<@vec)

set lookup_column (vec v,mat m) = int: last(m,(vec w)bool: w=v)
set lookup_row (vec v,mat m) = int: last(^m,(vec w)bool: w=v)

{ sum of columns of a matrix; this is so neat, avoid calling it sum_columns }
set sum (mat m)= vec: m*ones(n_columns(m))

{ solve(mat A,vec b): find a |vec| solution x of A*x=b, or indicate none exists
  Method:
  - write A*C = M using echelon, with C an invertible matrix and, M echelon
  - solve M*y = b (possibly finding none); this is easy using the echelon form
  - if a solution is found, return x = C*y
}
set solve (mat A,vec b) = maybe_a_vec:
(  let (M,C,s,) = echelon(A) then (n,k)=shape(M)
   then j=0 { runs up to k, used to index backwards }, sol=null(k)
   in assert(#b=n,"equation mismatch")
;  for i:n
  ~do if j<#s and i=s~[j] { then it is a pivot row, with pivot at M[j][i] }
      then let Mj=M~[j] then (q,r)=b[i]\%Mj[i] in
         if !=r then return ().no_vec { because inexact division} fi
       ;  sol~[j]:=q; b-:=Mj*q { correct for contribution from sol[j~] }
       ;  j+:=1
       elif !=b[i] then return ().no_vec { because no pivot available }
       fi
   od
;  (C[:k]*sol).solution
)

set solve (mat A,mat B) = maybe_a_mat: { matrix |X| satifying |A*X=B|, if any }
(  let (M,C,s,) = echelon(A) then (n,k)=shape(M)
   then sols = mat: { column |j| is solutions of |M*y=B[j]| }
      assert(n_rows(B)=n,"equation mismatch");
      k { size of each solution column} #
      for b in B
      do let j=0 { runs up to |k|, used to index |s|, |M| backwards }
	 , sol=null(k), rem=b { remaining RHS, gets modified }
      in for i:n
	~do if j<#s and i=s~[j] { a pivot row, with pivot at |M~[j][i]| }
	    then let Mj=M~[j] then (q,r)=rem[i]\%Mj[i]
	    in if !=r then return ().no_mat { because inexact division} fi
	    ;  sol~[j]:=q; rem-:=Mj*q { correct for contribution from sol[j~] }
	    ;  j+:=1
	    elif !=rem[i] then return ().no_mat { because no pivot available }
	    fi
	 od
      ;  sol
      od
   in (C[:k]*sols).solution
)

set any (maybe_a_vec x) = bool: case x  | solution: true | no_vec: false esac
set requisition (string message) = (maybe_a_vec->vec):
   (maybe_a_vec x) vec: case x  | solution(s): s | else error(message) esac
set requisition = requisition("No solution found; having one was required")

set required_solution ((mat,vec) system) = vec: system.solve.requisition

{ multiplicative order of a matrix, hangs unless finite }
set order (mat !M) = int:
  let (n,):p =shape(M) in assert(=p,"Matrix is not square");
  let N=M, order=1, I=id_mat(n) in
  while N!=I do N *:= M; order+:=1 od; order



{                           Rational vectors                            }

set numer (ratvec a) = vec: let (n,)=%a in n
set denom (ratvec a) = int: let (,d)=%a in d

{ allow scalar multiplication form left; from right it is built-in }
set * (int i,ratvec v) = ratvec: v*i
set * (rat r,ratvec v) = ratvec: v*r

{ concatenate ratvec values: use conversion to and from [rat] }
set ## (ratvec a,ratvec b) = ratvec: ##([rat]:a,[rat]:b)
set ## ([ratvec] rs) = ratvec: ## for r in rs do [rat]:r od

set sum (int l,[ratvec] list) = ratvec: { sum of ratvecs of constant length l }
  let result = ratvec: null(l) in for v in list do result+:=v od; result


{ multiply rational matrix represented as list of columns by a rational vector
  the m*n matrix M is given as a list of n ratvec values of size m
  v is a ratvec of size n, the result is a ratvec of size m
}
set * ([ratvec] M,ratvec v) = ratvec:
  let m=#M { number of columns } in
  assert(!=m { cannot handle empty matrix } and m=#v,"size mismatch");
  let result = null(#M[0])/1 in for col@j in M do result +:= col*v[j] od;
  result

set is_integer (ratvec v) = bool: let (,d)=%v in d=1 { equivalently =(v%1) }

{ vector floor of quotient by int operation; makes vector from rational vector }
set \ (ratvec v, int k) = vec: let (n,d)=%v in n\(k*d)

{ do as |v.numer| (or |\ %v|) would do, but check that denominator is 1 }
set ratvec_as_vec (ratvec v) = vec:
  let (w,d)=%v in assert(d=1,"Not an integer vector"); w

set reverse (ratvec v)= ratvec: v~[:]
set lower (int k,ratvec v)= ratvec: v[:k]
set upper (int k,ratvec v)= ratvec: v[k~:]
set drop_lower (int k,ratvec v)= ratvec: v[k:]
set drop_upper (int k,ratvec v)= ratvec: v[:k~]

{ dominance conditions }
set <= (ratvec v) = bool: <=numer(v)
set <  (ratvec v) = bool: < numer(v)

{ solve(mat A,ratvec b): find a solution ratvec x of A*x=b, or indicate that
  none exists. Solution as in vec case, but exact division requirement is OK.
}
set solve (mat A, ratvec b) = maybe_a_ratvec:
(  let (M,C,s,) = echelon(A) then (n,k)=shape(M)
   then j=0 { runs up to k, used to index backwards }, sol=for :k do rat:0 od
   in assert(#b=n,"equation mismatch")
;  for i:n
  ~do if j<#s and i=s~[j] { then it is a pivot row, with pivot at M[j][i] }
      then let Mj=M~[j] then q=b[i]/Mj[i] in
         sol~[j]:=q; b-:=Mj*q { correct for contribution from sol[j~] }
      ;  j+:=1
      elif !=b[i] then return ().no_ratvec { because no pivot here }
      fi
   od
;  (C[:#sol]*sol).solution
)

set any (maybe_a_ratvec x) = bool:
   case x  | solution: true | no_ratvec: false esac
set rat_requisition (string message) = (maybe_a_ratvec->ratvec):
   (maybe_a_ratvec x) ratvec:
    case x  | solution(s): s | else error(message) esac
set requisition = rat_requisition("No solution found; having one was required")

set required_solution ((mat,ratvec) system) = ratvec: system.solve.requisition



{                           Split integers                              }

set !s = Split:(0,1) { ! means it is a constant }
set !split_1 = Split:1 { do conversion now }
set !split_minus_1 = Split: minus_1
set !one_minus_s = Split:(1,-1), !one_plus_s = Split:(1,1)  { near idempotents }

set int_part (Split x) = int: let (r,)=%x in r
set s_part (Split x) = int: let (,y)=%x in y

set s_to_1 (Split x) = int: +%x        { let (a,b)=%x in a+b }
set s_to_minus_1 (Split x) = int: -%x  { let (a,b)=%x in a-b }
set times_s (Split x) = let (a,b)=%x in Split: (b,a)

set split_as_int (Split x) = int:
  let (r,y)=%x in assert(=y,"split is not an integer"); r
set \% (Split x, int n) = (Split,Split):
  let (a,b)=%x then (qa,rq)=a\%n, (qb,rb)=b\%n in ((qa,qb),(rq,rb))
{ divide Split by integer, quotient of \% but requiring rest to be zero }
set half (Split w) = Split: let (q,r)=w\%2 in assert(=r,"Inexact halving"); q
set / (Split w,int n) = Split:
  let (q,r)=w\%n in assert(=r,"Inexact division"); q
set % (Split w,int n) = Split: let (a,b)=%w in (a%n,b%n)
set exp_s(int n) = Split: if n.is_even then 1 else s fi

{ a Split coefficient is pure if it has at most one nonzero component }
set is_pure (Split w)=bool: =*%w { test if product of both components is zero }

{ nicer display of Splits }
set split_format (Split w) = string:
  let (a,b)=%w in
  if =a
  then case b+1 in "-s","0","s" else int_format(b)+"s" esac
  else int_format(a) +
     case b+1 then int_format(b)+"s" in "-s","","+s"
              else "+"+int_format(b)+"s"
     esac
  fi

{ same formatting, but supplying parentheses when necessary if used as factor }
set split_factor_format (Split w) = string:
  if =*%w { pure } then split_format(w) else "(" +  split_format(w) + ")" fi

set ^ = (Split,int->Split): { exponentiation of split integers }
  let rec_fun split_power (Split x,int n) = Split: { we shall have n>0 }
    if n=1 then x
    else let (q,r)=n\%2 then y=split_power(x,q) in y*if =r then y else x*y fi
    fi
  in { ^@(Split,int) = } (Split x,int n): Split:
    if let (a,b)=%x in abs(a)+abs(b)=1 { cases of invertible (unit) Split }
    then if n.is_even then split_1 else x fi { all are square roots of +1 }
    elif n.> then split_power(x,n)
    elif n.= then split_1
    else error("Negative power ",n," of split integer ",split_format(x))
    fi

set sum ([Split] list) = Split:
  let result=Split:0 in for x in list do result+:=x od; result

{                               Lie types				}

set Lie_type (string code, int rank) = LieType: extend(LieType:"",code,rank)

set semisimple_rank (LieType t) = int:
  for (,rank) in simple_factors(t) do rank od.sum

set central_torus_rank (LieType t) = int: t.rank-t.semisimple_rank

set factors (LieType t) = [string,int]:
  let tr = central_torus_rank(t) in
  if =tr then  t.simple_factors else t.simple_factors#("T",tr) fi

set semisimple (LieType t) = LieType:
  let s = LieType: "" in
  for (code,rank) in simple_factors(t) do s:=extend(s,code,rank) od; s

set derived_is_simple (LieType t) = bool: #simple_factors(t)=1
set is_simple (LieType t) = bool: t.derived_is_simple and =t.central_torus_rank

set str (LieType t) = string:
  (## for (code,rank) in factors(t) do code ## rank.to_string ## "." od)[:1~]



{                               Root data                               }

{ provide default values for coroot preference when building root data }

set derived_is_simple(RootDatum rd) = bool: Lie_type(rd).derived_is_simple
set is_simple(RootDatum rd) = bool: Lie_type(rd).is_simple

set root_datum (mat simple_roots, mat simple_coroots) = RootDatum:
  root_datum(simple_roots,simple_coroots,false) { by default prefer roots }

set root_datum (LieType type, mat lattice) = RootDatum:
  root_datum(type,lattice,false) { by default prefer roots }

set simply_connected (LieType type) = RootDatum:
  simply_connected(type,true) { by default prefer coroots here }

set adjoint (LieType type) = RootDatum:
  adjoint(type,false) { by default prefer roots here }

set sub_datum (RootDatum rd, [int]S) = RootDatum:
  let in_S = is_member(S) in
  root_datum(columns_with(in_S,rd.simple_roots)
	    ,columns_with(in_S,rd.simple_coroots))

{ backwards compatibility function; used to be the built-in prototype }
set root_datum ([vec] simple_roots, [vec] simple_coroots, int r) = RootDatum:
  root_datum(r#simple_roots,r#simple_coroots,false)

set root_datum (LieType t, [ratvec] gens) = RootDatum:
  root_datum(t,quotient_basis(t,gens))

{ allow single kernel generator in root datum construction }
set root_datum (LieType t, ratvec gen) = RootDatum: root_datum(t,[gen])

{ list of indices of all simple roots or coroots }
set all_simples (RootDatum rd) = [int]: #semisimple_rank(rd)

{ the following uses that root_index(rd,v)=nr_of_posroots(rd) for a non-root v }
set is_root ((RootDatum,vec) (rd,):p) = bool:
  root_index(p)<nr_of_posroots(rd)
set is_coroot ((RootDatum,vec) (rd,):p) = bool:
  coroot_index(p)<nr_of_posroots(rd)
set is_posroot ((RootDatum,vec)(rd,):p) = bool:
  let ri=root_index(p) in >=ri and ri<nr_of_posroots(rd)
set is_poscoroot ((RootDatum,vec)(rd,):p) = bool:
  let cri=coroot_index(p) in >=cri and cri<nr_of_posroots(rd)

set posroot_index ((RootDatum,vec)p) = int: { fold roots to positive }
  let i=root_index(p) in if <i then minus_1-i else i fi
set poscoroot_index ((RootDatum,vec)p) = int: { fold coroots to positive }
  let i=coroot_index(p) in if <i then minus_1-i else i fi


set rho (RootDatum rd) = ratvec: rd.two_rho/2
set rho_check (RootDatum rd) = ratvec: rd.two_rho_check/2
{ see also rho_i@KGBElt and rho_r@KGBElt defined below }

{ these functions assume the vec alpha or alphav is a root resp. coroot }
set is_positive_root (RootDatum rd) = (vec->bool):
  let rc = rho_check(rd) in (vec alpha) bool: >rc*alpha
set is_positive_coroot (RootDatum rd) = (vec->bool):
  let rho = rho(rd) in (vec alphav) bool: >alphav*rho
set is_negative_root (RootDatum rd) = (vec->bool):
  let rc = rho_check(rd) in (vec alpha) bool: <rc*alpha
set is_negative_coroot (RootDatum rd) = (vec->bool):
  let rho = rho(rd) in (vec alphav) bool: <alphav*rho

{ uncurried versions of the previous four; again being root/coroot is assumed }
set is_positive_root (RootDatum rd,vec alpha) = bool:
  is_positive_root(rd)(alpha)
set is_positive_coroot (RootDatum rd,vec alphav) = bool:
  is_positive_coroot(rd)(alphav)
set is_negative_root (RootDatum rd,vec alpha) = bool:
  is_negative_root(rd)(alpha)
set is_negative_coroot (RootDatum rd,vec alphav) = bool:
  is_negative_coroot(rd)(alphav)

{ test whether all colums, being assumed root/coots, are positive }
set roots_all_positive (RootDatum rd) = (mat->bool): { no negative roots }
  let are_pos = is_positive_root(rd) in (mat roots) bool: all(roots,are_pos)
set coroots_all_positive (RootDatum rd) = (mat->bool): { no negative coroots }
  let are_pos = is_positive_coroot(rd) in
  (mat coroots) bool: all(coroots,are_pos)

{ the following test rather than assume that columns are roots/cooroots }
set among_posroots (RootDatum rd) = (mat M)bool: { all colums M posroots? }
  all(M,(vec v)bool: is_posroot(rd,v))
set among_poscoroots (RootDatum rd) = (mat M)bool: { all colums M poscoroots? }
  all(M,(vec v)bool: is_poscoroot(rd,v))

set negative_system (mat posroots) = { the missing half of the root system }
  swiss_matrix_knife(172,posroots,0,0,0,0) { 172= 36+8+128: reverse cols,neg }

{ having _all_ roots can be useful }
set roots (RootDatum rd) = mat:
  let pr=posroots(rd) in negative_system(pr) ## pr
set coroots (RootDatum rd) = mat:
  let pcr=poscoroots(rd) in negative_system(pcr) ## pcr

{ the correspondence between roots and coroots }
set root (RootDatum rd, vec alpha_v) = vec: root(rd,coroot_index(rd,alpha_v))
set coroot (RootDatum rd, vec alpha) = vec: coroot(rd,root_index(rd,alpha))

{ reflection action of roots }
set reflection (RootDatum rd, int i) = mat: { i indexes a root/coroot pair }
  1 - column(root(rd,i))*row(coroot(rd,i))
set reflection ((RootDatum,vec)(rd,):p) = mat: { specify root (not coroot) }
  reflection(rd,root_index(p))
set reflect (RootDatum rd, int i, vec v) = vec: { apply reflection(rd,i)*v }
  v -:= root(rd,i) * (coroot(rd,i)*v) { more efficient than matrix multiply }
set reflect (RootDatum rd, vec alpha, vec v) = vec: { reflection(rd,alpha)*v }
  v -:= alpha * (coroot(rd,alpha)*v)
set coreflect (RootDatum rd, vec v, int i) = vec: { apply v*reflection(rd,i) }
  v -:= (v*root(rd,i)) * coroot(rd,i)
set coreflect (RootDatum rd, vec v, vec alpha) = vec: { v*reflection(rd,alpha) }
  v -:= (v*alpha) * coroot(rd,alpha)

set reflect (RootDatum rd, int i, ratvec v) = ratvec:
  let (n,d) = %v in reflect(rd,i,n)/d
set reflect (RootDatum rd, vec alpha, ratvec v) = ratvec:
  let (n,d) = %v in reflect(rd,alpha,n)/d
set coreflect (RootDatum rd, ratvec v, int i) = ratvec:
  let (n,d) = %v in coreflect(rd,n,i)/d
set coreflect (RootDatum rd, ratvec v, vec alpha) = ratvec:
  let (n,d) = %v in coreflect(rd,n,alpha)/d

{ in matrix version reflect becomes left_reflect and coreflect right_reflect }
set left_reflect (RootDatum rd, int i, mat M) = mat: { reflection(rd,i)*M }
  n_rows(M) # for v in M do reflect(rd,i,v) od
set left_reflect (RootDatum rd, vec alpha, mat M) = mat:
  left_reflect(rd,root_index(rd,alpha),M)
set right_reflect (RootDatum rd, mat M, int i) = mat: { M*reflection(rd,i) }
  n_columns(M) ^ for row in ^M do coreflect(rd,row,i) od
set right_reflect (RootDatum rd, mat M, vec alpha) = mat:
  right_reflect(rd,M,root_index(rd,alpha))

set conjugate (RootDatum rd, int i, mat M) = mat: { r*M*r where r=reflection }
  left_reflect(rd,i,right_reflect(rd,M,i))
set conjugate (RootDatum rd, vec alpha, mat M) = mat:
  conjugate(rd,root_index(rd,alpha),M)


{ orthogonal projection on span of subset of simple roots, a rational matrix }
set root_span_projector (RootDatum rd ,[int] S) = (mat,int):
  let in_S = is_member(S)
  then sub_simple_roots   =  columns_with(in_S,rd.simple_roots)
  , tr_sub_simple_coroots = ^columns_with(in_S,rd.simple_coroots)
  then (M,d) = invert(tr_sub_simple_coroots * sub_simple_roots)
  then A=sub_simple_roots*M*tr_sub_simple_coroots
  then dd=gcd([d,gcd(A)])
  in (A\dd,d\dd)

{ complementary orthogonal projection, to intersection of walls }
set wall_projector ((RootDatum,[int]) arg) = (mat,int):
   let (A,d)=root_span_projector(arg) in (d-A,d)


set singular_simple_indices (RootDatum rd,ratvec v) = [int]:
  ## for a@j in simple_coroots(rd) do if =a*v then [j] else [] fi od

set is_imaginary (mat theta) = (vec->bool): (vec alpha): theta*alpha=alpha
set is_real      (mat theta) = (vec->bool): (vec alpha): theta*alpha=-alpha
set is_complex   (mat theta) = (vec->bool): (vec alpha):
  let ta = theta*alpha in ta!=alpha and ta!=-alpha

{ these functions are just for convenience; posroot versions are more useful }
set imaginary_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(theta),roots(rd))
set real_roots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(theta),roots(rd))

{ for coroots we need to use the transpose matrix }
set imaginary_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_imaginary(^theta),coroots(rd))
set real_coroots (RootDatum rd, mat theta) = mat:
  columns_with(is_real(^theta),coroots(rd))

{ positive (co)roots versions are actually more useful }
set imaginary_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(theta),posroots(rd))
set real_posroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(theta),posroots(rd))
set imaginary_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_imaginary(^theta),poscoroots(rd))
set real_poscoroots (RootDatum rd,mat theta) = mat:
  columns_with(is_real(^theta),poscoroots(rd))
set imaginary_sys ((RootDatum,mat)p) = (mat,mat):
  (imaginary_posroots(p),imaginary_poscoroots(p))
set real_sys ((RootDatum,mat)p) = (mat,mat):
  (real_posroots(p),real_poscoroots(p))

{ whether v is a weakly dominant weight for rd }
set is_dominant (RootDatum rd, ratvec v) = bool:
  >=(numer(v)*simple_coroots(rd))
set is_strictly_dominant (RootDatum rd, ratvec v) = bool:
  >(numer(v)*simple_coroots(rd))
set is_regular (RootDatum rd,ratvec v)= bool: { tests all positive coroots }
  all(for x in numer(v)*poscoroots(rd) do !=x od)
set is_integral (RootDatum rd, ratvec v) = bool: { integral on all coroots }
  =(v*simple_coroots(rd)%1)

{ reversing order, simplilar questions about coweight v }
set is_dominant (ratvec v, RootDatum rd) = bool:
  >=(numer(v)*simple_roots(rd))
set is_strictly_dominant (ratvec v,RootDatum rd) = bool:
  >(numer(v)*simple_coroots(rd))
set is_regular (ratvec v, RootDatum rd)= bool: { tests all positive roots }
  all(for x in numer(v)*posroots(rd) do !=x od)
set is_integral (ratvec v, RootDatum rd) = bool: { integral on all roots }
  =(v*simple_roots(rd)%1)

{ the following should replace the needlessly complicacted built-ins they use }
set radical_basis (RootDatum rd) = mat: { columns are coweights }
  coroot_radical(rd)[:,semisimple_rank(rd):] { drop coroots part }
set coradical_basis (RootDatum rd) = mat: { columns are weights }
  root_coradical(rd)[:,semisimple_rank(rd):] { drop roots part }

set is_semisimple (RootDatum rd) = bool: semisimple_rank(rd) = rank(rd)

set derived_is_simply_connected (RootDatum rd) = bool:
  saturated_span(simple_coroots(rd))
set has_connected_center (RootDatum rd) = bool:
  saturated_span(simple_roots(rd))
set is_simply_connected (RootDatum rd) = bool:
  is_semisimple(rd) and derived_is_simply_connected(rd)
set is_adjoint (RootDatum rd) = bool:
  is_semisimple(rd) and has_connected_center(rd)

{ the following functions give but partial information; giving a more complete
  definition for InnerClass values needs more work (see group_operations.at)
}
set derived (RootDatum rd) = RootDatum: let (d,)=derived_info(rd) in d
set mod_central_torus (RootDatum rd) = RootDatum:
  let (d,)=mod_central_torus_info(rd) in d
set adjoint (RootDatum rd) = RootDatum: { change weight basis to simple roots }
  root_datum(id_mat(semisimple_rank(rd)),Cartan_matrix(rd))

{ from appropriate (subsystem) dual 2rho value, deduce test for being simple }
set is_simple_for (vec dual_two_rho) = (vec->bool):
  (vec alpha): dual_two_rho*alpha=2

{ get generating simple system from set of matching posroots and poscoroots }
set simple_system_from_positive (mat posroots,mat poscoroots) = (mat,mat):
  ( columns_with(is_simple_for(sum(poscoroots)),posroots)
  , columns_with(is_simple_for(sum(posroots)),poscoroots)
  )

set root_datum_from_positive((mat,mat)pair) = RootDatum:
  pair.simple_system_from_positive.root_datum

set fundamental_weights (RootDatum rd) = [ratvec]:
  for i:semisimple_rank(rd) do fundamental_weight(rd,i) od
set fundamental_coweights (RootDatum rd) = [ratvec]:
  for i:semisimple_rank(rd) do fundamental_coweight(rd,i) od

{ find a root of maximal level; if |rd| is simple this is the highest root }
{.highest root.}
set highest_root (RootDatum rd) = vec:
{ root data produced by |dual@RootDatum| are not ordered by level, so do work: }
  let pr=posroots(rd) in
  if =pr then error("Empty set of roots, none is highest")
  elif not rd.prefers_coroots { when generated in root order, take short cut }
  then pr~[0] { since the last generated root will be a high root }
  else let level=rho_check(rd) in pr[for alpha in pr do level*alpha od.max_loc]
  fi

{                               Weyl group				}

set id_W = let e=vec:[] in (RootDatum rd): WeylElt: W_elt(rd,e)
set W_gen (RootDatum rd, int s) = W_elt (rd,[s])
set W_gens (RootDatum rd) = [WeylElt]:
  for s:rd.semisimple_rank do W_elt(rd,[s]) od
set * (WeylElt w,mat theta) = mat: theta.n_rows # for col in theta do w*col od
set * (mat theta,WeylElt w) = mat:
  theta.n_columns ^ for row in ^theta do row*w od

set product (RootDatum rd, [WeylElt] L) = WeylElt:
  let len=#L in
  if =len then id_W(rd)
  else let w=L~[0] in assert(w.root_datum=rd); for i:len-1 ~do w *:= L[i] od; w
  fi

set order (WeylElt !w) = int: let x=w in 1+(int:while !=x do x*:=w od)
set rho_diff (WeylElt w) = vec: let rho2=w.root_datum.two_rho in (rho2-w*rho2)\2
set rho_check_diff (WeylElt w) = vec:
  let rho_check2=w.root_datum.two_rho_check in (rho_check2-rho_check2*w)\2

set chamber ((RootDatum,vec) rd_lambda) = WeylElt:
  let (w,)=from_dominant(rd_lambda) in w
set dominant ((RootDatum,vec) rd_lambda) = vec:
  let (,dom_wt)=from_dominant(rd_lambda) in dom_wt
set chamber ((vec,RootDatum) lambda_rd) = WeylElt:
  let (,w)=from_dominant(lambda_rd) in w
set dominant ((vec,RootDatum) lambda_rd) = vec:
  let (dom_cwt,)=from_dominant(lambda_rd) in dom_cwt
set w0 (RootDatum rd) = chamber(rd,-rd.two_rho)

set * (WeylElt w, ratvec gamma) = ratvec: let (n,d)=%gamma in (w*n)/d
set * (ratvec gamma, WeylElt w) = ratvec: let (n,d)=%gamma in (n*w)/d
set from_dominant (RootDatum rd, ratvec gamma) = (WeylElt,ratvec):
  let (n,d)=%gamma then (w,v)=from_dominant(rd,n) in (w,v/d)
set chamber (RootDatum rd, ratvec gamma) = WeylElt: chamber(rd,gamma.numer)
set dominant ((RootDatum,ratvec) rd_gamma) = ratvec:
  let (,dom_wt)=from_dominant(rd_gamma) in dom_wt
set from_dominant (ratvec gamma,RootDatum rd) = (ratvec,WeylElt):
  let (n,d)=%gamma then (v,w)=from_dominant(n,rd) in (v/d,w)
set chamber (ratvec gamma,RootDatum rd) = WeylElt: chamber(gamma.numer,rd)
set dominant ((ratvec,RootDatum) gamma_rd) = ratvec:
  let (dom_cwt,)=from_dominant(gamma_rd) in dom_cwt

set inverse (WeylElt w) = WeylElt: /w
set ^ = (WeylElt,int->WeylElt):
  let rec_fun power (WeylElt w,int n) = WeylElt:
    if n=1 then w
    else let (q,r)=n\%2 then wq=power(w,q) in wq*if =r then wq else wq*w fi
    fi
  in (WeylElt w,int n) WeylElt:
  if n>0 then power(w,n) elif =n then id_W(root_datum(w)) else /power(w,-n) fi

set matrix (WeylElt w) = mat: for c in id_mat(w.root_datum.rank) do w*c od
set W_elt (RootDatum rd, mat M) = WeylElt:
  let w = chamber(rd,M*two_rho(rd))
  in assert(matrix(w)=M,"Not the matrix of any Weyl group element"); w


{                               Inner classes                           }

set involution (LieType lt, string ict) = mat: involution(lt,#lt.rank,ict)

{ get inner class of G symbolically from root datum and inner class type
  Use the complex reductive group given by the root datum, but compute the
  distinguished involution from the string describing it symbolically.
}
set inner_class (RootDatum rd, string ict) = InnerClass:
   let inv0 = { involution named |ict|, for |simply_connected(Lie_type(rd))| }
     let (lt,pi) = rd.Cartan_matrix.Cartan_matrix_type { |lt| is semisimple }
     , r=rd.rank-rd.semisimple_rank { rank of the central torus }
     in involution(extend(lt,"T",r),pi ## for i:r from #pi do i od,ict)
   , P=^coroot_radical(rd) { sublattice basis, in |simply_connected(...)| }
   then (P1,d)=invert(P) then prod=P1*inv0*P { base change from |P|, times |d| }
   in assert(=(prod%d),"Inner class not compatible with root datum");
   inner_class(rd,prod\d) { construct inner class from explicit involution }

set inner_class (LieType lt, [ratvec] gens, string ict) = InnerClass:
   let basis = quotient_basis(lt,gens) in
   inner_class(root_datum(lt,basis),involution(lt,basis,ict))

{ integrality inner class (dual side) defined by inf. character and involution }
set dual_integral (InnerClass ic, ratvec gamma) = InnerClass:
  inner_class(dual(integrality_datum(ic,gamma)),-^distinguished_involution(ic))

set big_block (InnerClass ic) = Block:
  block(quasisplit_form(ic), dual_quasisplit_form(ic))


{                               Cartan classes                          }

set Cartan_classes (InnerClass ic) = [CartanClass]:
  for i:nr_of_Cartan_classes(ic) do Cartan_class(ic,i) od

set print_Cartan_info (CartanClass cc) = void:
  let show (string s) = string: if s="" then "empty" else s fi
  , ((cr,Cr,sr),ww,(orbit_size,fiber_size),(i_tp,r_tp,C_tp)) = Cartan_info(cc)
  in
  ( "compact: ",cr,", complex: ",Cr,", split: ",sr, new_line
  , "canonical twisted involution: "
  ,  if =#ww then "e"
     else to_string(ww[0]+1, ## for s in ww[1:] do to_string(",",s+1) od)
     fi
  , new_line
  , "twisted involution orbit size: ",orbit_size,
           "; fiber size: ",fiber_size,"; strong inv: ",orbit_size*fiber_size
  , new_line
  , "imaginary root system: ",show(str(i_tp)), new_line
  , "real root system: ",show(str(r_tp)), new_line
  , "complex factor: ",show(str(C_tp)), new_line
  ).prints


set fundamental_Cartan (InnerClass ic) = CartanClass: Cartan_class(ic,0)
{ implicitly fundamental_Cartan(RealForm f) = fundamental_Cartan(InnerClass:f) }
set most_split_Cartan (InnerClass ic) = CartanClass:
  Cartan_class(ic,nr_of_Cartan_classes(ic)-1)
{ also most_split_Cartan@RealForm is built-in, but is not that of inner class }

{ in the following, Complex factors count as half-compact, half-split }
set compact_rank (CartanClass cc) = int:
  let ((c,C,),,,) = Cartan_info(cc) in c+C
set split_rank (CartanClass cc) = int:
  let ((,C,s),,,) = Cartan_info(cc) in C+s

set compact_rank (InnerClass ic) = int: compact_rank(fundamental_Cartan(ic))
set split_rank (RealForm G)     = int: split_rank(most_split_Cartan(G))

set is_equal_rank (InnerClass ic) = bool: { whether distinguished_involution=1 }
  =split_rank(fundamental_Cartan(ic))
{ implicitly is_equal_rank (RealForm G) = bool: is_equal_rank(InnerClass:G) }

set is_split (RealForm G) = bool: { whether most split Cartan has theta = -1 }
  =compact_rank(most_split_Cartan(G))

{ equality of Cartan classes }
set = (CartanClass H,CartanClass J) = bool:
  let (,theta_H,,)=Cartan_info(H), (,theta_J,,)=Cartan_info(J) in
  theta_H=theta_J { compare their twisted involutions }

{ number of the Cartan class H in the list of those for the real form G }
set number(CartanClass H,RealForm G) = int:
  last(nr_of_Cartan_classes(G), (int i)bool: Cartan_class(G,i)=H)

{                               Real forms                              }

set form_name (RealForm f) = string: form_names(f)[form_number(f)]

set real_forms (InnerClass ic)= [RealForm]:
  real_forms(fundamental_Cartan(ic))
set dual_real_forms (InnerClass ic) = [RealForm]:
  dual_real_forms(most_split_Cartan(ic))

set dual_real_forms (RealForm G) = [RealForm]:
  dual_real_forms(most_split_Cartan(G))

set is_quasisplit (RealForm G) = bool: form_number(G)=nr_of_real_forms(G)-1
set is_quasicompact (RealForm G) = bool: form_number(G)=0

set split_form (RootDatum r) = RealForm:
  quasisplit_form(inner_class(r,-id_mat(rank(r))))

{ split form of a Lie type is taken simply connected (times a split torus) }
set split_form (LieType t) = RealForm: split_form(simply_connected(t))

set quasicompact_form (InnerClass ic) = RealForm: real_form(ic,0)
{ quasisplit_form@InnerClass is built-in }

set is_compatible (RealForm f, RealForm g) = bool:
  let ic = inner_class(f) in
  inner_class(g)=dual(ic) and >block_sizes(ic)[form_number(f),form_number(g)]

set is_compact (RealForm G) = bool: { real form 0 in equal rank inner class }
  KGB_size(G)=1 and distinguished_involution(G)=1



{                              KGB elements                             }

set real_form (KGBElt x) = let (rf,) = %x in rf
set # (KGBElt x) = let (,n) = %x in n
set root_datum (KGBElt x) = RootDatum: real_form(x)
set inner_class (KGBElt x) = InnerClass: real_form(x)

set KGB (RealForm rf) = [KGBElt]: for i:KGB_size(rf) do KGB(rf,i) od

{ all KGB elements of G mapping to its Cartan class H }
set KGB (CartanClass H,RealForm G) = [KGBElt]:
  ## for x in KGB(G) do if Cartan_class(x)=H then [x] else [] fi od

set KGB_elt ((InnerClass, mat, ratvec) (,theta,v):all) = KGBElt:
  let rf = real_form(all)   { find real form within ic }
  in KGB_elt(rf,theta,v)    { find KGB element within rf }

{ NB: elements produced by the following function test unequal to any others }
set KGB_elt (RootDatum rd, mat theta, ratvec v) = KGBElt:
  let ic = inner_class(rd,theta)   { find the proper inner class }
  then rf = real_form(ic,theta,v)  { find real form within ic }
  in KGB_elt(rf,theta,v)           { find KGB element within rf }

set Cartan_class (InnerClass ic, mat theta) = CartanClass:
  KGB_elt(ic,theta,ratvec:null(rank(ic))).Cartan_class

{ use the following as follows: |set <= = Bruhat_order(G)| }
set Bruhat_order (RealForm G) = (KGBElt,KGBElt->bool):
  let M=inverse(1-KGB_Hasse(G)) in (KGBElt x, KGBElt y) bool: !=M[#x,#y]

set status (vec alpha,KGBElt x) = int: status(root_index(real_form(x),alpha),x)

set cross (vec alpha,KGBElt x) = KGBElt:
  cross(root_index(root_datum(x),alpha),x)
set Cayley (vec alpha,KGBElt x) = KGBElt:
  Cayley(root_index(real_form(x),alpha),x)

{ cross action of Weyl group element; avoid name conflict cross@(vec,KGBElt) }
set W_cross ([int] w,KGBElt x) = KGBElt:
  for s in w ~ do x:=cross(s,x) od; x

set KGB_status_text (int i) = string:
  case i in "C-","ic","r ","nc","C+" else error("Illegal KGB status") esac

set status_text ((int,KGBElt)p) = string: KGB_status_text(status(p))
set status_text ((vec,KGBElt)p) = string: KGB_status_text(status(p))
set status_texts (KGBElt x) = [string]:
  for s:semisimple_rank(real_form(x)) do status_text(s,x) od

set is_complex ((int,KGBElt)p) = status(p)%4=0
set is_real ((int,KGBElt)p) = status(p)=2
set is_imaginary ((int,KGBElt)p) = status(p)%2=1
set is_noncompact ((int,KGBElt)p) = status(p)=3
set is_compact ((int,KGBElt)p) = status(p)=1
set is_descent ((int,KGBElt)p) = status(p)<3
set is_ascent ((int,KGBElt)p) = status(p)>=3
set is_strict_descent ((int,KGBElt)p) = { is_descent(p) and not is_compact(p) }
  case status(p) in true,false,true,false,false esac

{ status of general roots for a KGBElt (which here just represents its fiber) }

set is_imaginary (KGBElt x) = (vec->bool): is_imaginary(involution(x))
set is_real (KGBElt x)      = (vec->bool): is_real(involution(x))
set is_complex (KGBElt x)   = (vec->bool): is_complex(involution(x))


set imaginary_posroots (KGBElt x) = mat:
  imaginary_posroots(root_datum(x),involution(x))
set real_posroots (KGBElt x) = mat:
  real_posroots(root_datum(x),involution(x))
set imaginary_poscoroots (KGBElt x) = mat:
  imaginary_poscoroots(root_datum(x),involution(x))
set real_poscoroots (KGBElt x) = mat:
  real_poscoroots(root_datum(x),involution(x))
set imaginary_sys (KGBElt x) = (mat,mat):
  let p = (root_datum(x),involution(x))
  in (imaginary_posroots(p),imaginary_poscoroots(p))
set real_sys (KGBElt x) = (mat,mat):
  let p = (root_datum(x),involution(x))
  in (real_posroots(p),real_poscoroots(p))

set rho_i (KGBElt x) = ratvec: sum(imaginary_posroots(x))/2
set rho_r (KGBElt x) = ratvec: sum(real_posroots(x))/2
set rho_check_i (KGBElt x) = ratvec: sum(imaginary_poscoroots(x))/2
set rho_check_r (KGBElt x) = ratvec: sum(real_poscoroots(x))/2

set rho_i ((RootDatum,mat) rd_theta) = ratvec:
  sum(imaginary_posroots(rd_theta))/2
set rho_r ((RootDatum,mat) rd_theta) = ratvec:
  sum(real_posroots(rd_theta))/2
set rho_check_i ((RootDatum,mat) rd_theta) = ratvec:
  sum(imaginary_poscoroots(rd_theta))/2
set rho_check_r ((RootDatum,mat) rd_theta) = ratvec:
  sum(real_poscoroots(rd_theta))/2

{ compact/noncompact status for a given KGBElt of general imaginary roots }
set is_compact (KGBElt x) = (vec->bool):
  let coweight = rho_check_i(x)+torus_factor(x), is_im=is_imaginary(x)
  in (vec alpha) bool: assert(is_im(alpha)); =(coweight*alpha)%2
set is_noncompact (KGBElt x) = (vec->bool):
  let coweight = rho_check_i(x)+torus_factor(x), is_im=is_imaginary(x)
  in (vec alpha) bool: assert(is_im(alpha)); !=(coweight*alpha)%2

{ for roots not known to be imaginary, use these functions instead }
set is_compact_imaginary (KGBElt x) = (vec->bool):
  let p=is_imaginary(x), q=is_compact(x) { allow pre-computation for x }
  in (vec alpha) bool: p(alpha) and q(alpha)
set is_noncompact_imaginary (KGBElt x) = (vec->bool):
  let p=is_imaginary(x), q=is_noncompact(x) { allow pre-computation for x }
  in (vec alpha) bool: p(alpha) and q(alpha)

set compact_posroots (KGBElt x) = mat:
  columns_with(is_compact(x),imaginary_posroots(x))
set noncompact_posroots (KGBElt x) = mat:
  columns_with(is_noncompact(x),imaginary_posroots(x))

set dimension (KGBElt x) = int: { dimension as $K$-orbit on $G/B$ }
  let G=x.real_form then x0=KGB(G,0), posroots=G.posroots in
( x.length
+ #columns_with(is_compact_imaginary(x0),posroots)
+ #columns_with(is_complex(x0.involution),posroots)\2
)


set rho_ci (KGBElt x)  = ratvec: sum(compact_posroots(x))/2
set rho_nci (KGBElt x) = ratvec: sum(noncompact_posroots(x))/2

set is_imaginary (vec v,KGBElt x) = bool: v.(is_imaginary(x))
set is_real (vec v,KGBElt x) =      bool: v.(is_real(x))
set is_complex (vec v,KGBElt x) =   bool: v.(is_complex(x))
set is_compact_imaginary (vec v,KGBElt x) = bool: v.(is_compact_imaginary(x))
set is_noncompact_imaginary (vec v,KGBElt x) = bool:
  v.(is_noncompact_imaginary(x))

set print_KGB (KGBElt x) = void:
( prints(new_line,"Element is number ",#x, " in following KGB set")
; print_KGB(real_form(x)) )

set no_Cminus_roots (KGBElt x) = bool:
  none(semisimple_rank(real_form(x)), (int i)bool: =status(i,x))
set no_Cplus_roots (KGBElt x) = bool:
  none(semisimple_rank(real_form(x)), (int i)bool: status(i,x)=4)

{                               Blocks                                  }

set blocks (RealForm rf) = [Block]:
   let ic=InnerClass:rf then sizes=(^block_sizes(ic))[rf.form_number] in
## for drf in dual_real_forms(ic)
   do if >sizes[drf.form_number] then [block(rf,drf)] else [] fi
   od

set blocks (InnerClass ic) = [Block]:
   let sizes=block_sizes(ic) in
## for rf@i in real_forms(ic)
   do
   ## for drf@j in dual_real_forms(ic)
      do if >sizes[i,j] then [block(rf,drf)] else [] fi
      od
   od

set raw_KL  ((RealForm,RealForm) p) = (mat,[vec],vec): raw_KL(block(p))
set dual_KL ((RealForm,RealForm) p) = (mat,[vec],vec): dual_KL(block(p))

set print_block  ((RealForm,RealForm) p) = void: print_block (block(p))
set print_blocku ((RealForm,RealForm) p) = void: print_blocku(block(p))
set print_blockd ((RealForm,RealForm) p) = void: print_blockd(block(p))
set print_KL_basis ((RealForm,RealForm) p) = void: print_KL_basis(block(p))
set print_prim_KL  ((RealForm,RealForm) p) = void: print_prim_KL(block(p))
set print_KL_list  ((RealForm,RealForm) p) = void: print_KL_list(block(p))
set print_W_cells  ((RealForm,RealForm) p) = void: print_W_cells(block(p))
set print_W_graph  ((RealForm,RealForm) p) = void: print_W_cells(block(p))


{                           Module parameters                           }

set root_datum (Param p) = RootDatum: real_form(p)
set inner_class (Param p) = InnerClass: real_form(p)

set null_module (Param p) = ParamPol:
  null_module(real_form(p)) { avoid using ParamPol version below, could throw }

set x (Param p) = KGBElt: let (x,,) =%p in x
set lambda_minus_rho (Param p) = vec: let (,lambda_rho,) =%p in lambda_rho
set lambda (Param p) = ratvec: lambda_minus_rho(p)+rho(real_form(p))
set infinitesimal_character (Param p) = ratvec: let (,,gamma) =%p in gamma
set d_lambda (Param p) = ratvec: let (x,,gamma) =%p in (1+involution(x))*gamma/2
set nu (Param p) = ratvec:       let (x,,gamma) =%p in (1-involution(x))*gamma/2
set Cartan_class (Param p) = CartanClass: Cartan_class(x(p))

set involution (Param p)=involution(x(p))

set integrality_datum (Param p)= RootDatum:
  integrality_datum(root_datum(p),infinitesimal_character(p))

set is_regular (Param p) = bool:
  is_regular(root_datum(p),infinitesimal_character(p))

{. Test whether (the infinitesimal character of) a parameter is
   strongly regular. .}
set is_strongly_regular (Param p)=bool:
   let G=real_form(p) in let ic=infinitesimal_character(p)
   in is_dominant(root_datum(G),ic-rho(G))

{ whether irreducible rpn survives translation functor from regular inf.char. }
set survives (Param p) = bool:
  is_final(p) { was recently defined to mean exactly that }

set trivial (RealForm G) = Param: { parameter for the trivial representation }
  param(KGB(G,KGB_size(G)-1),null(rank(G)),rho(G))

{ cross action of Weyl group element; avoid name conflict cross@(vec,Param) }
set W_cross ([int] w,Param p) = Param:
  for s in w ~ do p:=cross(s,p) od; p

{ parameter(G,x,lambda,nu)=param(KGB(G,x),lambda-rho(G),nu), so you can enter
  lambda without the rho shift; lambda may have denominator 2 or be a vec
}
set parameter (RealForm G,int x,ratvec lambda,ratvec nu) = Param:
  param(KGB(G,x),ratvec_as_vec(lambda-G.rho),nu)
set parameter (KGBElt x,ratvec lambda,ratvec nu) = Param:
  param(x,ratvec_as_vec(lambda-x.real_form.rho),nu)

{ set parameter ensuring (upon sucess) that the infinitesimal char. is |gamma|;
  achieve this by ignoring |(1+theta)*lambda|, replace it by |(1+theta)*gamma| }
set parameter_gamma(KGBElt x, ratvec lambda, ratvec gamma) = Param:
  let (G,nx)=%x, theta=involution(x) in
  { ((1-theta)*lambda+(1+theta)*gamma)/2 = lambda+(1+theta)*(gamma-lambda)/2 }
  parameter(G,nx,lambda+(1+theta)*(gamma-lambda)/2,gamma)

{ variation of built-in |block@Param| that weeds out non-starred block elts }
set singular_block (Param p) = ([Param],int):
  let (B,i)=block(p)
  then block = ## for q in B do if q.survives then [q] else [] fi od
  in (block, { new index of |p|:} first(for q in block do p=q od))

{ get just the parameters from a block, just a shorcut to: (params,)=block(p) }
set block_of (Param p) = [Param]: let (params,)=block(p) in params
set singular_block_of (Param p) = [Param]:
  let (params,)=singular_block(p) in params

{ status of parameter with respect to integrality generator s, or root alpha }

set imaginary_type (int s, Param p) = int: if cross(s,p)=p then 2 else 1 fi
set real_type (int s,Param p) = int: if cross(s,p)=p then 1 else 2 fi

set imaginary_type (vec alpha, Param p) = int:
  if cross(alpha,p)=p then 2 else 1 fi
set real_type (vec alpha, Param p) = int:
  if cross(alpha,p)=p then 1 else 2 fi

set is_nonparity (int s,Param p)=bool: is_real(s,x(p)) and Cayley(s,p)=p
set is_parity (int s,Param p)= bool: is_real(s,x(p)) and Cayley(s,p)!=p

set is_nonparity (vec alpha,Param p)=bool:
  is_real(alpha,x(p)) and Cayley(alpha,p)=p
set is_parity (vec alpha,Param p)= bool:
  is_real(alpha,x(p)) and Cayley(alpha,p)!=p

set status (vec alpha,Param p) = int: { enum: C-, ic, r1, r2, C+, rn, i1, i2 }
  let st=status(alpha,x(p)) in
  if st<=1 or st=4 then st { complex and imaginary compact cases keep old code }
  elif st=3 then { imaginary non-compact } 5+imaginary_type(alpha,p)
  elif Cayley(alpha,p)=p then { real non-parity } 5
  else 1+real_type(alpha,p)
  fi

set status (int s,Param p) = int: { this is NOT related to status(s,x(p)) }
  status(root(integrality_datum(p),s),p)

set block_status_text (int i) = string:
  case i in "C-","ic","r1","r2","C+","rn","i1","i2"
  else error("Out of range status ",i)
  esac

set status_text (int s,Param p) = string: block_status_text(status(s,p))
set status_texts (Param p) = [string]:
  for s:semisimple_rank(real_form(p)) do status_text(s,p) od

set status_text ((vec,Param) ap) = string: block_status_text(status(ap))

set parity_poscoroots (Param p) = mat: { set of positive real parity coroots }
  let (alpha,real_poscoroots)=real_sys(x(p))
  in columns_with((int i):status(alpha[i],p)!=5,real_poscoroots)
set nonparity_poscoroots (Param p) = mat: { positive real nonparity coroots }
  let (alpha,real_poscoroots)=real_sys(x(p))
  in columns_with((int i):status(alpha[i],p)=5,real_poscoroots)

set is_descent (int s,Param p) = bool: status(s,p)<4
set tau_bitset (Param p) = (int,(int->bool)):
  (p.real_form.semisimple_rank, (int s): is_descent(s,p))

set tau (Param p)            = [int]: list(tau_bitset(p))
set tau_complement (Param p) = [int]: complement(tau_bitset(p))

set is_descent ((vec,Param) ap) = bool: status(ap)<4

set lookup (Param p, [Param] block) = int:
  let i=#block-1 in while >=i and block[i]!=p do i-:=1 od; i

{ (moved from hermitian.at) orientation_number_term(orientation_nr(p),q) =
  s^{[\ell_0(p)-\ell_0(q)]/2} which should be defined and gives 1 or s
}
set orientation_nr_term = (int,Param->Split):
  let err()=
    error("computing orientation number for odd difference of lengths")
  in (int ori_nr_p,Param q) Split:
  case ori_nr_p-orientation_nr(q) in 1, err(), s, err() esac


{                       Extended blocks                                 }

set extended_status_texts = [string]:
  [ { 0:} "1C+","1C-","1i1","1r1f","1i2f","1r2","1i2s","1r1s","1rn","1ic"
  , {10:} "2C+","2C-","2Ci","2Cr"
     ,"2i11","2r11","2i12f","2r21f","2i22","2r22","2i12s","2r21s","2rn","2ic"
  , {24:} "3C+","3C-","3Ci","3r","3i","3Cr","3rn","3ic"
  ]

set print_extended_block = (Param,mat->):
  let has_double_Cayley (int n) =
    if n<5 then n>=3 else n>=15 and n<19 fi { 1r1f,1i2f,2r11,2i12f,2r21f,2i22 }
  , has_defect(int n) =
    if n<14 then n>=12 else n>=26 and n<30 fi { 2Ci, 2Cr, 3Ci, 3r, 3i, 3Cr }
  in (Param p, mat delta) void:
  let (block,types,L0,L1) = extended_block(p,delta)
  , G=p.real_form, parent_block=block_of(p)
  then (l,r)=shape(types), pbs=#parent_block
  then indices =
      let i=0 in
      for p in block
      do for j:pbs from 1
         do if parent_block[(i+j)%pbs]=p then i:=(i+j)%pbs; break fi
	 od
      ; i
      od
  then wx=width(G.KGB_size-1), wp=width(#parent_block-1)
  , with_sign(int n) = string:
    if n<0 then "-"+(indices[minus_1-n]) else "+"+indices[n] fi
  in
  for q@i in block
  do prints
  (r_adjust(wp,int_format(indices[i]))
  ,": ["
  , ## { statuses }
    for j:r
    do if j=0 then "" else "," fi
    ## l_adjust(5,extended_status_texts[types[i,j]])
    od
  , "]"
  , ## { cross actions }
    for j:r
    do r_adjust (wp+2, with_sign(
       if L0[i,j]=l or has_double_Cayley(types[i,j]) or has_defect(types[i,j])
       then i { self cross when either 0 or 2 Cayleys or there is a defect }
       elif L1[i,j]=l then L0[i,j] else L1[i,j] { complex resp single Cayley }
       fi))
    od
  , "; "
  , ## { Cayley transforms }
    for j:r
    do c_adjust (2*wp+3,
       if has_double_Cayley(types[i,j])
       then L0[i,j].with_sign+","+L1[i,j].with_sign { double valued Cayley }
       elif has_defect(types[i,j]) or L1[i,j]<l
       then L0[i,j].with_sign { defect case or other single valued Cayley }
       else "." { compact, nonparity or complex: no Cayley }
       fi)
    od
  , "  x=" , r_adjust(wx,to_string(#x(q))) , ", " , lambda_minus_rho(q)
  )
  od

{                   Polynomials in module parameters                    }

set null_module (ParamPol P) = ParamPol: 0*P { built-in does this efficiently }
set -(ParamPol P) = ParamPol: minus_1*P

set first_param (ParamPol P) = Param: let (,p)=first_term(P) in p
set last_param (ParamPol P)  = Param: let (,p)=last_term(P) in p

set s_to_1 (ParamPol P)       = ParamPol: 0*P + for x@q in P do (+%x,q) od
set s_to_minus_1 (ParamPol P) = ParamPol: 0*P + for x@q in P do (-%x,q) od

{ counterpart to built-in +@(ParamPol,(Split,Param)) }
set - (ParamPol a, (Split,Param) (c,p)) = ParamPol: a+(-c,p)

set + (ParamPol P, [Param] ps) = ParamPol: P+for p in ps do (split_1,p) od
set - (ParamPol P, [Param] ps) = ParamPol: P+for p in ps do (split_minus_1,p) od

{ |ParamPol| summation by divide and conquer to privilege balanced additions }
set sum = (RealForm,[ParamPol]->ParamPol):
 { do divide and conquer so as to privilege balanced additions }
  let rec_fun s([ParamPol] Ps) = ParamPol: { |Ps| has at least one term }
        let h = (#Ps)\2 in if =h then Ps[0] else s(Ps[:h])+s(Ps[h:]) fi
  in (RealForm G,[ParamPol] Ps) ParamPol:
  if =#Ps then G.null_module else s(Ps) fi

set + (ParamPol P,[ParamPol] Ps) = ParamPol: P+sum(P.real_form,Ps)
set - (ParamPol P,[ParamPol] Ps) = ParamPol: P-sum(P.real_form,Ps)


set map ((Param->Param)f, ParamPol P) = ParamPol:
  0*P + for c@p in P ~do (c,f(p)) od

set map ((Param->ParamPol)f, ParamPol P) = ParamPol:
  sum(P.real_form,for c@p in P ~do c*f(p) od)

set half (ParamPol P) = ParamPol: 0*P+ for c@t in P do (half(c),t) od
{ inverse of multiplication *@(int,ParamPol); don't confuse with scaling }
set divide_by (int n, ParamPol P) = ParamPol: 0*P+ for c@t in P do (c/n,t) od

{ simulate coercion (KGBElt->RealForm) in some cases }
set root_datum (ParamPol P) = RootDatum: real_form(P)

set virtual (Param p) = ParamPol: p { for making implicit conversion explcit }
set virtual (RealForm G, [Param] ps) = ParamPol:
  let one=Split:(1,0) in null_module(G)+for p in ps do (one,p) od
{ DON'T define virtual ([Param] pp): cannot be correctly defined when #pp=0 }

{ branch to get only the coefficient of a specific K-type }
set branch (Param std, Param K_type) = int:
  branch(std,height(K_type))[K_type].int_part

set branch (ParamPol P, Param K_type) = Split: { Split coefficients possible }
  branch(P,height(K_type))[K_type]

{ nice output of ParamPol: split_format the coefficients }
set pol_format (ParamPol P)= string:
  ## for w@p in P do to_string("(",w.split_format,")*",p,new_line) od

{ find what should be unique infintesimal character shared by all terms }
set infinitesimal_character(ParamPol P) = ratvec:
  assert(!=P,"empty polynomial has no infinitesimal character");
  let (,,gamma)=%first_param(P) in
  for @p in P
  do assert(infinitesimal_character(p)=gamma
           ,"infinitesimal character not unique")
  od; gamma

{ split up a ParamPol into terms below a given height and the rest }
set height_split (ParamPol P, int h) = (ParamPol,ParamPol):
  let below=0*P, above=0*P in
  for c@q in P
  do if q.height<h then below+:=(c,q) else above+:=(c,q) fi
  od; (below,above)

{ more generally, groups terms into different ParamPol, by value of gamma }
set separate_by_infinitesimal_character (ParamPol P) = [(ratvec,ParamPol)]:
  let M = [(ratvec,ParamPol)]:[]
  then insert ((Split,Param)(,p):term ) = void: { insert into M }
    let inserted=false, gamma=infinitesimal_character(p) in
    for (key,P)@i in M
    do if key=gamma then M[i]:=(key,P+term); inserted:=true fi
    od
  ; if not inserted then M #:= (gamma,ParamPol: p) fi
  in for c@p in P do insert(c,p) od; M

{ whether all coefficients are integer repectively integer mulitples of |s| }
set is_pure_1 (ParamPol P)=bool: all(for c in P do c.s_part.= od)
set is_pure_s (ParamPol P)=bool: all(for c in P do c.int_part.= od)

{ a module is considered pure if either all coefficients are integer of if all
  coefficients are integer multiples of s; stronger than all coefficents pure }
set is_pure (ParamPol P)=bool: P.is_pure_1 or P.is_pure_s

{ report number of integer, purely s, and mixed terms }
set purity (ParamPol P)=(int,int,int):
  let (x,y,z)=(0,0,0) in
  for coef in P
  do let (a,b)=%coef in { we know (a,b)/=(0,0), so 3 cases arise }
    if =b then x+:=1 elif =a then y+:=1 else z+:=1 fi
  od; (x,y,z)

{                               Miscellaneous                           }

{                   Miscellaneous find functions                     }

{ find index of item in list, or -1 if not found; first does this }

set find ([int] v, int k) = int:      first(#v,(int i)bool:v[i]=k)
set find ([Param] P,Param p) = int:   first(#P,(int i)bool:P[i]=p)
set find ([KGBElt] S,KGBElt x) = int: first(#S,(int i)bool:S[i]=x)
set find ([vec] S,vec v) = int:       first(#S,(int i)bool:S[i]=v)

{ No version for finding [int] due to potential ambiguity with vec version.
  Note that |find(L,x)| has alternative |first(for y in L do x=y od)| which
  can be used for all types having =, without separate definition of |find|
}

set in_string_list (string s,[string] S) = bool:
  >=first(for t in S do s=t od)

{ delete one term from a list }
set delete ([int] v, int k)     =[int]:     v[:k]##v[k+1:]
set delete ([vec] v, int k)     =[vec]:     v[:k]##v[k+1:]
set delete ([ratvec] v, int k)  =[ratvec]:  v[:k]##v[k+1:]
set delete ([[ratvec]] v, int k)=[[ratvec]]:v[:k]##v[k+1:]
set delete ([[vec]] v, int k)   =[[vec]]:   v[:k]##v[k+1:]
set delete ([ParamPol] P, int k)=[ParamPol]:P[:k]##P[k+1:]

set positive_imaginary_roots_and_coroots = imaginary_sys@(RootDatum,mat)
set positive_imaginary_roots_and_coroots = imaginary_sys@KGBElt

set imaginary_roots_and_coroots ((RootDatum, mat)p) = (mat,mat):
  let (a,b)=imaginary_sys(p) in (negative_system(a)##a, negative_system(b)##b)
set imaginary_roots_and_coroots (KGBElt x) = (mat,mat):
  imaginary_roots_and_coroots (root_datum(real_form(x)),involution(x))

set positive_real_roots_and_coroots = real_sys@(RootDatum,mat)
set positive_real_roots_and_coroots = real_sys@KGBElt

set real_roots_and_coroots ((RootDatum, mat)p) = (mat,mat):
  let (a,b)=real_sys(p) in (negative_system(a)##a, negative_system(b)##b)
set real_roots_and_coroots (KGBElt x) = (mat,mat):
  real_roots_and_coroots (root_datum(real_form(x)),involution(x))

set complex_posroots (RootDatum rd,mat theta) =  mat:
  columns_with(is_complex(theta),posroots(rd))
set complex_posroots (KGBElt x) =  mat:
  complex_posroots(root_datum(x),involution(x))

{ pad string with blanks (for lining up columns in tables) }
set pad(string s,int padding)=string: l_adjust(padding,s)

{ for user convenience; a ParamPol is an associative array ParamPol->Split
  so selecting its monomials (Param values) by position is not reliable, but
  allowing so is useful in user sessions to pick terms from a computed result
}
set monomials (ParamPol P) = [Param]: for c@p in P do p od
set monomial  (ParamPol P,int i) = Param: monomials(P)[i]

{. Convert a list of ParamPols into the list of distinct parameters occuring;
   careful: don't let terms cancel! .}
set monomials([ParamPol] list)=[Param]:
   let sum=null_module(real_form(list[0])) in
   for P in list do for c@p in P do sum+:=p od od;monomials(sum)
