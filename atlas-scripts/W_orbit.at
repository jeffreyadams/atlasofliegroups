<basic.at  { for assert, #@int,... }
<sort.at
<hash.at

{
  The next function is not needed for generating orbits for the reflection
  representations of the Weyl group on weights and coweights, for which the
  built-in |Weyl_orbit| can be used to find the orbit, and |from_dominant| to
  recover for each orbit element a representative Weyl group element. Therefore
  the name of the function, which reflects the orginal main used to generate the
  orbit of a dominant weight, is no longer very appropriate.

  An optimised orbit generation procedure, which assumes that generators can
  detect and eliminate (by returning |none()|) backwards or stationary steps
  (in the main application we generate the orbit of a dominant weight, whence
  the function name, and "forward" will then mean subtracting posroots) and that
  the poset structure on the orbit is graded (as is true for the weak order on
  $W$ or on $W/P$ for a parabolic subgroup $P$). This allows the orbit to be
  partitioned into levels, with equality testing only within current level.

  Arguments are a row |S| of generating maps and a starting dominant weight |v|;
  it returns a list of pairs of a weight |b| and a representative word in the
  generators, which when applied right-to-left transforms |v| into |b|.

  The algorithm is to generate an array of such pairs, with a counter |done|
  saying how many have been considered for successors, and a marker |stop|
  saying where the newest level (where duplicates must be avoided) starts.
}
set generate_from_dom ([(vec->Maybe<vec>)] S,vec start) = [vec,[int]]:
(  let stack = [[vec,[int]]]: { each level |rlex_leq|-sorted by its |vec| }
               [ [], [(start,[])] ] { start with two levels }
   , absent([vec,[int]] level, vec target) = bool:
      binary_search_in(level,fst,rlex_leq@(vec,vec))(target).fails
in while
      let new_level =
         for (a,word) in stack~[0]
	    for f@i in S
	    do case f(a)
	       | some(b):
	         if absent(stack~[1],b) and absent(stack~[0],b) do (b,i#word) fi
	       | else [] { skip when no new vector is returned }
	       esac
	    od
	 od.##
   in {while}#new_level>0
   do stack #:=
      { sort |new_level| by weight components (lexicogr.), removing duplicates }
      sort_u_by ((vec v,[int].)vec: v,rlex_leq@(vec,vec)) (new_level)
   od
;  ##stack { concatenate generated levels, without merging the (sorted) lists }
)

{ Same as above, but also compose |gens_rep| matrices for applied generators;
  for callers that need this, this avoids repeated matrix multiplications that
  would occur when multiplying out the matrices for all the returned words.
  This is typically used for representations of W other than the standard
  reflection representation (for which |matrix@WeylElt| can find the action).
}
set generate_action_from_dom \
   ( [(vec->Maybe<vec>)] S
   , vec start
   , int dim
   , [mat] gens_rep
   ) = [vec,[int],mat]:
(  let stack = [[vec,[int],mat]]: { each level |lex_leq|-sorted by its |vec| }
               [ [], [(start,[],id_mat(dim))] ]  { start with two levels }
   , absent([vec,[int],mat] level, vec target) = bool:
      binary_search_in(level, (vec v,[int].,mat.):v, rlex_leq@(vec,vec))
                      (target).fails
in while
      let new_level =
         for (a,word,act) in stack~[0]
	    for f@i in S
	    do case f(a)
	       | some(b):
	         if absent(stack~[1],b) and absent(stack~[0],b)
		 do (b,i#word,gens_rep[i]*act)
		 fi
	       | else [] { skip when no new vector is returned }
	       esac
	    od
	 od.##
   in {while} #new_level>0
   do stack #:=
      { sort |new_level| by weight components (lexicogr.), removing duplicates }
      sort_u_by ((vec v,[int].,mat.)vec: v,rlex_leq@(vec,vec)) (new_level)
   od
;  ##stack { concatenate generated levels, without merging the (sorted) lists }
)

{ "lowering only" standard simple reflection actions on weights }
set simple_actor (RootDatum rd, int i) = (vec -> Maybe<vec>):
   let s=W_refl(rd,i), av=coroot(rd,i) in
   (vec x) Maybe<vec>: if av*x>0 then some(s*x) else none() fi

{ For Weyl group action on X^*, wrap previous form in pre/post processing }
set generate_from_dom (RootDatum rd,[int] S,vec v) = [vec,WeylElt]:
   for (x,word) in generate_from_dom(for s in S do simple_actor(rd,s) od,v)
   do (x,product(rd,for i in word do W_refl(rd,S[i]) od)) od


{ get orbit of |v| under parabolic subgroup of Weyl group with generators |S|,
  and witnessing (minimal) Weyl group elements |w|: |x=w*v| for |x| in orbit }
set generate_from (RootDatum rd,[int] S,vec v) = [vec,WeylElt]:
   let (chamber,dom_wt) = from_dominant(rd,S,v)
   then orbit =
      generate_from_dom(for s in S do simple_actor(rd,s) od,dom_wt)
   ,  to_dom= WeylElt: inverse(chamber)
in for (x,word) in orbit
   do (x,product(rd,for i in word do W_refl(rd,S[i]) od)*to_dom)
   od

{ when no |WeylElt| elements are needed in the end, we can simplify a bit }
set W_orbit_of_dom ((RootDatum,[int], vec) triple) = [vec]:
   for (x,) in generate_from_dom(triple) do x od
set W_orbit ((RootDatum,[int], vec) triple) = [vec]:
   for (x,) in generate_from(triple) do x od

{ minimal coset representatives for stabilizer in $W_S$ of dominant weight |v| }
set stabiliser_quotient_of_dom ((RootDatum,[int],vec) triple) = [WeylElt]:
   for (,w) in generate_from_dom(triple) do w od
set stabiliser_quotient ((RootDatum,[int],vec) triple) = [WeylElt]:
   for (,w) in generate_from(triple) do w od

{ minimal coset representatives for stabilizer in $W_S$ of (any weight) |v| }
{ for reflection representation with |S| all simple roots, use built-in instead }
set W_orbit = (RootDatum,vec->mat): Weyl_orbit@(RootDatum,vec)
set W_orbit_of_dominant = { same }  Weyl_orbit@(RootDatum,vec)

set W_orbit = (vec {coweight},RootDatum->mat): Weyl_orbit@(vec,RootDatum)

set stabiliser_quotient {W/P} = (RootDatum,vec->[WeylElt]):
   Weyl_orbit_ws@(RootDatum,vec)
set stabiliser_quotient {P\W} = (vec,RootDatum->[WeylElt]):
   Weyl_orbit_ws@(vec,RootDatum)
set W_orbit_with_witness ((RootDatum,vec) (,v{weight}):args) = [vec,WeylElt]:
   for w in Weyl_orbit_ws(args) do (w*v,w) od
set W_orbit_with_witness ((vec,RootDatum) (v{coweight},):args) = [WeylElt,vec]:
   for w in Weyl_orbit_ws(args) do (w,v*w) od

set W_parabolic_iterator (RootDatum rd, [int] gens) = Iterator<WeylElt>:
   let !ssr = rd.semisimple_rank, !r=rd.rank, ng = #gens
   then !subquotient_stack = [[WeylElt]]:
      for k : ng
      do let para = gens[:k+1] { generators of current parabolic subgroup }
         then A = mat: { linear forms to vanish, or for |k| be positive, on |v| }
	 (r ^ for i in para do coroot(rd,i) od) { to fix coroot evaluations }
	  ^ cokernel(r # for i in para do root(rd,i) od) { to stay in root span }
	 then v = vec: required_solution(A,identity_row(r,k)/1).numer
      in stabiliser_quotient_of_dom(rd, para, v)
      od
   then state = null(ng), m = vec: map(#@T[T])(subquotient_stack)
in ( @Maybe<WeylElt>:
       if state~[0]=m~[0] { we've run out of last index } then none()
       else product(rd,for n@i in state do subquotient_stack[i][n] ~od).some
       fi
   , @void:
       for i:ng-1 do if (state[i]+:=1)<m[i] then return() else state[i]:=0 fi od
     ; state~[0] +:= 1 { for most significant index, do not wrap around }
   )

set W_parabolic_iterator_with_action \
   (RootDatum rd, [int] gens, int dim, [mat] gens_rep) = Iterator<(WeylElt,mat)>:
   let !ssr = rd.semisimple_rank, !r=rd.rank, ng = #gens
   then !subquotient_stack = [[WeylElt,mat]]:
      for k : ng
      do let para = gens[:k+1] { generators of current parabolic subgroup }
	 then actors = for gen in para do simple_actor(rd,gen) od
         then A = mat: { linear forms to vanish, or for |k| be positive, on |v| }
	 (r ^ for i in para do coroot(rd,i) od) { to fix coroot evaluations }
	  ^ cokernel(r # for i in para do root(rd,i) od) { to stay in root span }
	 then v = vec: required_solution(A,identity_row(r,k)/1).numer
      in for (,word,act) in
             generate_action_from_dom(actors, v, dim, gens_rep[:k+1])
         do (product(rd,for i in word do W_refl(rd,gens[i]) od),act)
	 od
      od
   then state = null(ng), m = vec: map(#@T[T])(subquotient_stack)
in ( @Maybe<(WeylElt,mat)>:
       if state~[0]=m~[0] { we've run out of last index } then none()
       else
          (product(rd ,for n@i in state do subquotient_stack[i][n].fst ~od)
	  ,product(dim,for n@i in state do subquotient_stack[i][n].snd ~od)
	  ).some
       fi
   , @void:
       for i:ng-1 do if (state[i]+:=1)<m[i] then return() else state[i]:=0 fi od
     ; state~[0] +:= 1 { for most significant index, do not wrap around }
   )

set W_iterator (RootDatum rd) = Iterator<WeylElt>:
   W_parabolic_iterator(rd,all_simples(rd))
{ all elements of Weyl group of RootDatum, in parabolic	quotient lex order }
set W (RootDatum rd) = [WeylElt]: rd.W_iterator.to_list

set W_orbit (RootDatum rd, ratvec rv {weight}) = [ratvec]:
   let (v,d) = %rv in for x in W_orbit(rd,v) do x/d od
set W_orbit (ratvec rv {coweight},RootDatum rd) = [ratvec]:
   let (v,d) = %rv in for x in W_orbit(v,rd) do x/d od

set stabiliser_quotient {W/P} (RootDatum rd,ratvec rv) = [WeylElt]:
   Weyl_orbit_ws(rd,numer(rv))
set stabiliser_quotient {P\W} (RootDatum rd,ratvec rv) = [WeylElt]:
   Weyl_orbit_ws(numer(rv),rd)

set W_orbit_with_witness (RootDatum rd,ratvec rv) = [ratvec,WeylElt]:
   for w in Weyl_orbit_ws(rd,numer(rv)) do (w*rv,w) od
set W_orbit_with_witness (ratvec rv,RootDatum rd) = [WeylElt,ratvec]:
   for w in Weyl_orbit_ws(numer(rv),rd) do (w,rv*w) od

{ variants of the above for |ratvec| instead of |vec|; reduce to |vec| case }
{ default S to full set of simple roots }
set generate_from_dom (RootDatum rd, [int] S, ratvec rv) = [ratvec,WeylElt]:
  let (n,d) = %rv in for (v,w) in generate_from_dom(rd,S,n) do (v/d,w) od
set generate_from (RootDatum rd, [int] S, ratvec rv) = [ratvec,WeylElt]:
  let (n,d) = %rv in for (v,w) in generate_from(rd,S,n) do (v/d,w) od
set W_orbit_of_dom (RootDatum rd, [int] S, ratvec rv) = [ratvec]:
  let (n,d) = %rv in for (v,) in generate_from(rd,S,n) do v/d od
set W_orbit (RootDatum rd, [int] S, ratvec rv) = [ratvec]:
  let (n,d) = %rv in for (v,) in generate_from(rd,S,n) do v/d od
set stabiliser_quotient_of_dom (RootDatum rd, [int] S, ratvec rv) = [WeylElt]:
  stabiliser_quotient_of_dom(rd,S,numer(rv))
set stabiliser_quotient (RootDatum rd, [int] S, ratvec rv) = [WeylElt]:
  stabiliser_quotient(rd,S,numer(rv))

{
  General orbit generation of |v| for the monoid generated by |S|.

  Presumably |S| are involutions coming from some Weyl group action, but not
  necessarily simple reflections. However even them being involutions is not
  assumed here, nor anything about how these generators relate to dominance; not
  even that the generated directed acyclic graph is graded.

  No |RootDatum| is passed to this function, although the maps |f_i| that are
  passed may themselves have access to a |RootDatum| to do their thing.

  Example of use: finding the $W^{\delta}$-orbit of a root, in which the
  generators would be the actions of certain $\delta$-stable elements of $W$.


  Here we use, instead of |generate_from_dom|, a simplified but less
  efficient method, using linear search over the full orbit generated so far.
}
set generate ([(ratvec->ratvec)] S,ratvec v) = [ratvec,[int]]:
(  let bag=make_ratvec_hash()
   then it = bag.iterator(), words=[[int]]:[[]], i=0
in bag.match(v)
;  while
      case it.get()
      | none: dont
      | some(a): do
        let w = words[i] next i+:=1 in
	for f@j in S
	do if bag.could_add(f(a)) then words #:= j#w fi
	od
      ; it.incr()
      esac
   od
;  zip(bag.list(),words)
)

{
  The following function calls the previous one with the actions of Weyl
  group elements given as second argument. The words in these indices of these
  generators are converted upon returing into Weyl group elements.
}

set generate (RootDatum rd,[WeylElt] S,ratvec v) = [ratvec,WeylElt]:
   for (x,word) in generate(for s in S do (ratvec x) ratvec: s*x od, v)
   do (x,product(rd,for s in word do S[s] od))
   od
