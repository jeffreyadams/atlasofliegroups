<basic.at  { for assert, #@int,... }
<sort.at
<hash.at { used in general |generate| method }

{
  The next function is not needed for generating orbits for the reflection
  representations of the Weyl group on weights and coweights, for which the
  built-in |Weyl_orbit| can be used to find the orbit, and |from_dominant| to
  recover for each orbit element a representative Weyl group element. Therefore
  the name of the function, which is that of the script function originally used
  to generate the orbit of a dominant weight, is no longer very appropriate.

  An optimised orbit generation procedure, which assumes that generators can
  detect and eliminate (by returning |none()|) backwards or stationary steps
  (in the main application we generate the orbit of a dominant weight, whence
  the function name, and "forward" will then mean subtracting posroots) and that
  the poset structure on the orbit is graded (as is true for the weak order on
  $W$ or on $W/P$ for a parabolic subgroup $P$). This allows the orbit to be
  partitioned into levels, with equality testing only within current level.

  Arguments are a row |S| of generating maps and a starting dominant weight |v|;
  it returns a list of pairs of a weight |b| and a representative word in the
  generators, which when applied right-to-left transforms |v| into |b|.

  The algorithm is to generate an array of such pairs, with a counter |done|
  saying how many have been considered for successors, and a marker |stop|
  saying where the newest level (where duplicates must be avoided) starts.
}
set generate_from_dom ([(vec->Maybe<vec>)] S,vec start) = [vec,[int]]:
(  let stack = [[vec,[int]]]: { each level |rlex_leq|-sorted by its |vec| }
               [ [], [(start,[])] ] { start with two levels }
   , absent([vec,[int]] level, vec target) = bool:
      binary_search_in(level,fst,rlex_leq@(vec,vec))(target).fails
in while
      let new_level =
         for (a,word) in stack~[0]
	    for f@i in S
	    do case f(a)
	       | some(b):
	         if absent(stack~[1],b) and absent(stack~[0],b) do (b,i#word) fi
	       | else [] { skip when no new vector is returned }
	       esac
	    od
	 od.##
   in {while}#new_level>0
   do stack #:=
      { sort |new_level| by weight components (lexicogr.), removing duplicates }
      sort_u_by ((vec v,[int].)vec: v,rlex_leq@(vec,vec)) (new_level)
   od
;  ##stack { concatenate generated levels, without merging the (sorted) lists }
)

{ Same as above, but also compose |gens_rep| matrices for applied generators;
  for callers that need this, this avoids repeated matrix multiplications that
  would occur when multiplying out the matrices for all the returned words.
  This is typically used for representations of W other than the standard
  reflection representation (for which |matrix@WeylElt| can find the action).
}
set generate_action_from_dom \
   ( [(vec->Maybe<vec>)] S
   , vec start
   , int dim
   , [mat] gens_rep
   ) = [vec,[int],mat]:
(  let stack = [[vec,[int],mat]]: { each level |lex_leq|-sorted by its |vec| }
               [ [], [(start,[],id_mat(dim))] ]  { start with two levels }
   , absent([vec,[int],mat] level, vec target) = bool:
      binary_search_in(level, (vec v,[int].,mat.):v, rlex_leq@(vec,vec))
                      (target).fails
in while
      let new_level =
         for (a,word,act) in stack~[0]
	    for f@i in S
	    do case f(a)
	       | some(b):
	         if absent(stack~[1],b) and absent(stack~[0],b)
		 do (b,i#word,gens_rep[i]*act)
		 fi
	       | else [] { skip when no new vector is returned }
	       esac
	    od
	 od.##
   in {while} #new_level>0
   do stack #:=
      { sort |new_level| by weight components (lexicogr.), removing duplicates }
      sort_u_by ((vec v,[int].,mat.)vec: v,rlex_leq@(vec,vec)) (new_level)
   od
;  ##stack { concatenate generated levels, without merging the (sorted) lists }
)

{ "lowering only" standard simple reflection actions on weights }
set simple_actor (RootDatum rd, int i) = (vec -> Maybe<vec>):
   let s=W_refl(rd,i), av=coroot(rd,i) in
   (vec x) Maybe<vec>: if av*x>0 then some(s*x) else none() fi

{ For refernce we recall how this was applied to the relflection action. Now
  that the built-in function can handle this musch faster, we don;t use them.

  { For Weyl group action on X^*, wrap previous form in pre/post processing }
  set generate_from_dom (RootDatum rd,[int] S,vec v) = [vec,WeylElt]:
     for (x,word) in generate_from_dom(for s in S do simple_actor(rd,s) od,v)
     do (x,product(rd,for i in word do W_refl(rd,S[i]) od)) od
  { get orbit of |v| under parabolic subgroup of Weyl group with generators |S|,
    and witnessing (minimal) Weyl group elements |w|: |x=w*v| for |x| in orbit }
  set generate_from (RootDatum rd,[int] S,vec v) = [vec,WeylElt]:
     let (chamber,dom_wt) = from_dominant(rd,S,v)
     then orbit =
	generate_from_dom(for s in S do simple_actor(rd,s) od,dom_wt)
     ,  to_dom= WeylElt: inverse(chamber)
  in for (x,word) in orbit
     do (x,product(rd,for i in word do W_refl(rd,S[i]) od)*to_dom)
     od
  { when no |WeylElt| elements are needed in the end, we can simplify a bit }
  set W_orbit_of_dom ((RootDatum,[int], vec) triple) = [vec]:
     for (x,) in generate_from_dom(triple) do x od
  set W_orbit ((RootDatum,[int], vec) triple) = [vec]:
     for (x,) in generate_from(triple) do x od
  { minimal coset reprs for stabilizer in $W_S$ of dominant weight |v| }
  set stabiliser_quotient_of_dom ((RootDatum,[int],vec) triple) = [WeylElt]:
     for (,w) in generate_from_dom(triple) do w od
  set stabiliser_quotient ((RootDatum,[int],vec) triple) = [WeylElt]:
     for (,w) in generate_from(triple) do w od
}

set W_orbit = (RootDatum,vec{weight}->mat):    Weyl_orbit@(RootDatum,vec)
set W_orbit = (vec {coweight},RootDatum->mat): Weyl_orbit@(vec,RootDatum)
set W_orbit = (RootDatum,[int],vec{weight}->mat):
   Weyl_orbit@(RootDatum,[int],vec)
set W_orbit = (vec{coweight},RootDatum,[int]->mat):
   Weyl_orbit@(vec,RootDatum,[int])

{ minimal coset representatives for stabilizer in $W_S$ of (any weight) |v| }
{ for reflection representation with |S| all simple roots, using built-ins }
set stabiliser_quotient {W/P} = (RootDatum,vec{weight}->[WeylElt]):
   Weyl_orbit_ws@(RootDatum,vec)
set stabiliser_quotient {P\W} = (vec{coweight},RootDatum->[WeylElt]):
   Weyl_orbit_ws@(vec,RootDatum)
set stabiliser_quotient = (RootDatum,[int],vec{weight}->[WeylElt]):
   Weyl_orbit_ws@(RootDatum,[int],vec)
set stabiliser_quotient = (vec{coweight},RootDatum,[int]->[WeylElt]):
   Weyl_orbit_ws@(vec,RootDatum,[int])

set W_orbit_with_witness ((RootDatum,vec) (,v{weight}):args) = [vec,WeylElt]:
   for w in Weyl_orbit_ws(args) do (w*v,w) od
set W_orbit_with_witness ((vec,RootDatum) (v{coweight},):args) = [WeylElt,vec]:
   for w in Weyl_orbit_ws(args) do (w,v*w) od
set W_orbit_with_witness ((RootDatum,[int],vec)(,,v{weight}):args) =
      [vec,WeylElt]:
   for w in Weyl_orbit_ws(args) do (w*v,w) od
set W_orbit_with_witness ((vec,RootDatum,[int])(v{coweight},,):args) =
      [vec,WeylElt]:
   for w in Weyl_orbit_ws(args) do (v*w,w) od

{ When it is just required to visit all elements of an orbit, one can avoid
  storing the full orbit in memory by using iterators. This will still use
  built-in functions for generating parabolic quotients, but these are smaller.
}

{ Iterator for running through the Weyl subgroup with simple generators |gens| }
set W_parabolic_iterator (RootDatum rd, [int] gens) = Iterator<WeylElt>:
   let !ssr = rd.semisimple_rank, !r=rd.rank, ng = #gens
   then !subquotient_stack = [[WeylElt]]:
      for k : ng
      do let para = gens[:k+1] { generators of current parabolic subgroup }
         then A = mat: { linear forms to vanish, or for |k| be positive, on |v| }
	 (r ^ for i in para do coroot(rd,i) od) { to fix coroot evaluations }
	  ^ cokernel(r # for i in para do root(rd,i) od) { to stay in root span }
	 then v = vec: required_solution(A,identity_row(r,k)/1).numer
      in stabiliser_quotient(rd, para, v)
      od
   then state = null(ng), m = vec: map(#@T[T])(subquotient_stack)
in ( @Maybe<WeylElt>:
       if state~[0]=m~[0] { we've run out of last index } then none()
       else product(rd,for n@i in state do subquotient_stack[i][n] ~od).some
       fi
   , @void:
       for i:ng-1 do if (state[i]+:=1)<m[i] then return() else state[i]:=0 fi od
     ; state~[0] +:= 1 { for most significant index, do not wrap around }
   )

{ given action of generators, get action of each generated element on the fly }
set W_parabolic_iterator_with_action \
   (RootDatum rd, [int] gens, int dim, [mat] gens_rep) = Iterator<(WeylElt,mat)>:
   let !ssr = rd.semisimple_rank, !r=rd.rank, ng = #gens
   then !subquotient_stack = [[WeylElt,mat]]:
      for k : ng
      do let para = gens[:k+1] { generators of current parabolic subgroup }
	 then actors = for gen in para do simple_actor(rd,gen) od
         then A = mat: { linear forms to vanish, or for |k| be positive, on |v| }
	 (r ^ for i in para do coroot(rd,i) od) { to fix coroot evaluations }
	  ^ cokernel(r # for i in para do root(rd,i) od) { to stay in root span }
	 then v = vec: required_solution(A,identity_row(r,k)/1).numer
      in for (,word,act) in
             generate_action_from_dom(actors, v, dim, gens_rep[:k+1])
         do (product(rd,for i in word do W_refl(rd,gens[i]) od),act)
	 od
      od
   then state = null(ng), m = vec: map(#@T[T])(subquotient_stack)
in ( @Maybe<(WeylElt,mat)>:
       if state~[0]=m~[0] { we've run out of last index } then none()
       else
          (product(rd ,for n@i in state do subquotient_stack[i][n].fst ~od)
	  ,product(dim,for n@i in state do subquotient_stack[i][n].snd ~od)
	  ).some
       fi
   , @void:
       for i:ng-1 do if (state[i]+:=1)<m[i] then return() else state[i]:=0 fi od
     ; state~[0] +:= 1 { for most significant index, do not wrap around }
   )

set W_iterator (RootDatum rd) = Iterator<WeylElt>:
   W_parabolic_iterator(rd,all_simples(rd))

{ if we don't mind storing the full Weyl group, us built-in which is faster }
set W (RootDatum rd) = [WeylElt]: Weyl_orbit_ws(rd,rd.two_rho)

set W_orbit (RootDatum rd, ratvec rv {weight}) = [ratvec]:
   let (v,d) = %rv in for x in W_orbit(rd,v) do x/d od
set W_orbit (ratvec rv {coweight},RootDatum rd) = [ratvec]:
   let (v,d) = %rv in for x in W_orbit(v,rd) do x/d od

set stabiliser_quotient {W/P} (RootDatum rd,ratvec rv) = [WeylElt]:
   Weyl_orbit_ws(rd,numer(rv))
set stabiliser_quotient {P\W} (ratvec rv,RootDatum rd) = [WeylElt]:
   Weyl_orbit_ws(numer(rv),rd)

set W_orbit_with_witness (RootDatum rd,ratvec rv) = [ratvec,WeylElt]:
   for w in Weyl_orbit_ws(rd,numer(rv)) do (w*rv,w) od
set W_orbit_with_witness (ratvec rv,RootDatum rd) = [WeylElt,ratvec]:
   for w in Weyl_orbit_ws(numer(rv),rd) do (w,rv*w) od

{ variants of the above for subgroups }
set W_orbit (RootDatum rd, [int] S, ratvec rv{weight}) = [ratvec]:
  let (n,d) = %rv in for v in W_orbit(rd,S,n) do v/d od
set W_orbit (ratvec rv{coweight},RootDatum rd, [int] S) = [ratvec]:
  let (n,d) = %rv in for v in W_orbit(n,rd,S) do v/d od
set stabiliser_quotient (RootDatum rd, [int] S, ratvec rv{weight}) = [WeylElt]:
  stabiliser_quotient(rd,S,numer(rv))
set stabiliser_quotient (ratvec rv{coweight},RootDatum rd, [int] S) = [WeylElt]:
  stabiliser_quotient(numer(rv),rd,S)
set W_orbit_with_witness (RootDatum rd, [int] S, ratvec rv{weight}) =
     [ratvec,WeylElt]:
  let (n,d) = %rv in for (v,w) in W_orbit_with_witness(rd,S,n) do (v/d,w) od
set W_orbit_with_witness (ratvec rv{coweight},RootDatum rd, [int] S) =
     [ratvec,WeylElt]:
  let (n,d) = %rv in for (v,w) in W_orbit_with_witness(n,rd,S) do (v/d,w) od

{
  General orbit generation of |v| for the monoid generated by |S|.

  Presumably |S| are involutions coming from some Weyl group action, but not
  necessarily simple reflections. However even them being involutions is not
  assumed here, nor anything about how these generators relate to dominance; not
  even that the generated directed acyclic graph is graded.

  No |RootDatum| is passed to this function, although the maps |f_i| that are
  passed may themselves have access to a |RootDatum| to do their thing.

  Example of use: finding the $W^{\delta}$-orbit of a root, in which the
  generators would be the actions of certain $\delta$-stable elements of $W$.


  Here we use, instead of |W_orbit_with_witness|, a simplified but less
  efficient method, using hash table search over the full orbit generated so far.
}
set generate ([(ratvec->ratvec)] S,ratvec v) = [ratvec,[int]]:
(  let bag=make_ratvec_hash()
   then it = bag.iterator(), words=[[int]]:[[]], i=0
in bag.match(v)
;  while
      case it.get()
      | none: dont
      | some(a): do
        let w = words[i] next i+:=1 in
	for f@j in S
	do if bag.could_add(f(a)) then words #:= j#w fi
	od
      ; it.incr()
      esac
   od
;  zip(bag.list(),words)
)

{
  The following function calls the previous one with the actions of Weyl
  group elements given as second argument. The words in these indices of these
  generators are converted upon returing into Weyl group elements.
}

set generate (RootDatum rd,[WeylElt] S,ratvec v) = [ratvec,WeylElt]:
   for (x,word) in generate(for s in S do (ratvec x) ratvec: s*x od, v)
   do (x,product(rd,for s in word do S[s] od))
   od
