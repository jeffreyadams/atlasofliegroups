<combinatorics.at
<partitions.at
<W_reps_type_BC.at

{[BMSZ]=Barbasch, Ma, Sun, Zhu: Special Unipotent Representations of Real Classical
Groups: Construction and Unitarity"; arXiv:1712:05552v6 18 Feb 2025}

{shorthand for rat_as_int(n/2), with check that n is even}
set h(int n)=int:
assert(is_even(n),"trying to take half of odd integer");n\2 

set labels=["A","A~", "B","D","C","C~","C*","D*"]
set bi_labels=["B+","B-", "C","D","C~","C*","D*"]  {for PaintedBiPartitions see Def 3.3}

set find(string S,[string] list)=int:first(for x in list do S=x od)
set is_in(string S,[string] list)=bool:find(S,list)!=-1

set is_descending([int] list)=bool:first(for i:#list-1 do list[i] < list[i+1] od)=-1
set is_strongly_descending([int] list)=bool:first(for i:#list-1 do list[i] <= list[i+1] od)=-1

set is_ascending([int] list)=bool:first(for i:#list-1 do list[i] > list[i+1] od)=-1
set is_strongly_ascending([int] list)=bool:first(for i:#list-1 do list[i] >= list[i+1] od)=-1
set is_valid(Partition P)=is_descending(P)

set order(Partition P)=int:sum(P)

set star_string(int n)=string:let rv="" in for i:n do rv:=rv+"*" od;rv

set show_partition(Partition P)=void:
for r in P do prints(star_string(r)) od

set symbols=[string]:["*","s","r","c","d"]
set symbol(int k)=string:assert(k>=0 and k<=4,"k out of range");symbols[k]

{generate partitions recursively}
{[a_1,...,a_n] ->
  [[a_1,...,a_n,1]] if a_{n-1}=a_n         if a_{n-1}=a_n
  [[a_1,...,a_n,1],[a_1,...,a_{n-1},a_n+1] otherwise
}
set add_one([int] P)=[[int]]:
if (#P>1 and P~[0]<P~[1]) or #P=1 then
[P#1,P~[0]+:=1;P] else [P#1] fi

{recursively compute partitions of n:
 [for each partition Q of n-1 do add_one(Q) od]
}
set par(int n)=
let rec_fun f(int n)=[[int]]:
  if n=0
     then [[int]]:[]
  elif n=1
     then [[int]]:[[1]]
  else
     for P in f(n-1) do add_one(P)  od.##
  fi in f(n)



{P[i]=[a0,a1,...,an] means:
 row i has length n+1, j^th entry has color symbols[a_j]  (0<=a_j<=#symbols-1=4)}
set_type PaintedPartition=[[int]]

set partition(PaintedPartition P)=Partition:for row in P do #row od
set number_rows(PaintedPartition P)=int:#P
set number_columns(PaintedPartition P)=int:#transpose(partition(P))
set size(PaintedPartition P)=int:size(partition(P))

set null_painted_partition=PaintedPartition:[]

set equal(PaintedPartition P,PaintedPartition Q)=bool:
number_rows(P)=number_rows(Q) and all(for row@i in P do row=Q[i] od)

set symbol_string([int] row)=string:##for j in row do symbol(j) od
set symbol_string(PaintedPartition P)=[string]: for row in P do symbol_string(row) od

{list of symbols which occur at least once}
set symbols([int] row)=sort_u(row)
set symbols(PaintedPartition P)=symbols(##P)

set column_of(PaintedPartition P)=(int->[int]):(int i):
##for j:number_rows(P) do if i<#P[j] then [P[j][i]] else [] fi  od

set transpose_of(PaintedPartition P)=PaintedPartition:
let f=column_of(P) in for i:number_columns(P) do f(i) od

set count([int] row, int symbol)=int:count(for i in row do i=symbol od)

set count_in_row(PaintedPartition P,int row,int symbol)=int:count(P[row],symbol)
set count_in_column(PaintedPartition P, int column, int symbol)=int:count_in_row(transpose_of(P),column,symbol)
set count(PaintedPartition P, int symbol)=sum(for row in P do count(row,symbol) od)
{replace each entry = symbol  with -1; used in is_valid(PaintedPartition)}

set delete_by_symbols(PaintedPartition P,[int] excluded_symbols)=PaintedPartition:
for row in P do
  for j in row do if is_member(excluded_symbols)(j) then [-1] else [j] fi od.##
 od

set delete_by_symbols(PaintedPartition P,int excluded_symbol)=PaintedPartition:delete_by_symbols(P,[excluded_symbol])

{no_holes([int] row): row=[0,0,1,3,-1]: every entry after the first -1 must be a -1,
i.e. row=[a_0,...,a_f,-1,-1,...,-1]  where a_i\ne -1}
set no_holes([int] row)=bool:let f=first(for j:#row do row[j]=-1 od) in
if f=-1 then true else row[f:]=-ones(#row-f) fi
set no_holes_by_rows(PaintedPartition P)=bool:all(for row in P do no_holes(row) od)
set no_holes_by_columns(PaintedPartition P)=bool:all(for row in transpose_of(P) do no_holes(row) od)
{*,s,r,c,d}
{0,1,2,3,4}

set is_valid(PaintedPartition P)=bool:
is_valid(partition(P)) and
all(for row:number_rows(P) do count_in_row(P,row,1)<=1 od)and  {1=s}
all(for row:number_rows(P) do count_in_row(P,row,2)<=1 od)and  {2=r}
all(for column:number_columns(P) do count_in_column(P,column,3)<=1 od)and  {3=c}
all(for column:number_columns(P) do count_in_column(P,column,4)<=1 od) and {4=d}
all(for S in [[4],[3,4],[2,3,4],[1,2,3,4]] do
 let Q=delete_by_symbols(P,S) in no_holes_by_rows(Q) and no_holes_by_columns(Q) od)

set locations(PaintedPartition P,int i)=
##for row@j in P do
 ##for c@k in row do if c=i then [(j,k)] else [] fi od od


set same_zeroes(PaintedPartition P,PaintedPartition Q)=bool:
let loc_P=locations(P,0) then loc_Q=locations(Q,0) in
#loc_P=#loc_Q and all(for i:#loc_P do loc_P[i]=loc_Q[i] od)

{add single box to first column of P}
{brute force version}
set add_one_to_first_column(PaintedPartition P)=[PaintedPartition]:
for i:5 do if is_valid(P#[i]) then [P#[i]] else [] fi od.##

set add_one_to_last_row(PaintedPartition P)=[PaintedPartition]:
if #P=0
 then [ [[0]],[[1]],[[2]],[[3]],[[4]] ]
elif #P=1
 then
 for i:5 do let Q=[P[0]#i] in
   if is_valid(Q) then [Q] else [] fi od.##
elif #P~[0]<#P~[1]
 then
 for i:5 do let Q=P then ()=Q~[0]:=Q~[0]#i in if is_valid(Q) then [Q] else [] fi od.##
else
 []
fi

set painted_partitions(int n)=
let rec_fun f(int n)=[PaintedPartition]:
if n=0
 then [[]]
elif n=1 then
  [ [[0]],[[1]],[[2]],[[3]],[[4]] ]
else
 for P in f(n-1) do  add_one_to_first_column(P)##add_one_to_last_row(P) od.##
fi in f(n)

set_type PaintedBiPartition=(PaintedPartition P,PaintedPartition Q,string bi_label)

set label_of(string bi_label)=string:if is_in(bi_label,["B+","B-"]) then "B" else bi_label fi
set label(PaintedBiPartition Z)=string:label_of(bi_label(Z))

set size(PaintedBiPartition (P,Q,))=int:size(P)+size(Q)
set count(PaintedBiPartition (P,Q,),int symbol)=int:count(P,symbol)+count(Q,symbol)

{*,s,r,c,d}
{0,1,2,3,4}
set is_valid_left(PaintedPartition P, string bi_label)=
let label=label_of(bi_label) in 
let S=symbols(P) then
excluded=[int]:
 if   label="B" then [1,2,4]
 elif label="C" then [1]
 elif label="D" then []
 elif label="C~" then [2,4]
 elif label="C*" then [1,2,3,4]
 elif label="D*" then [2,3,4]
else
 error("missing case in is_valid_left")
fi
in all(for x in excluded do count(S,x)=0 od)

set is_valid_right(PaintedPartition Q, string bi_label)=
let label=label_of(bi_label) in 
let S=symbols(Q) then
excluded=[int]:
 if label="B" then [3]
 elif label="C" then [2,3,4]
 elif label="D" then [1,2,3,4]
 elif label="C~" then [1,3]
 elif label="C*" then [3,4]
 elif label="D*" then [1,3,4]
else
 error("missing case in is_valid_right")
fi
in all(for x in excluded do count(S,x)=0 od)

set is_valid(PaintedBiPartition Z)=bool:
same_zeroes(Z.P,Z.Q) and is_valid_left(Z.P,Z.label) and is_valid_right(Z.Q,Z.label)

set p(PaintedBiPartition Z)=int:
if is_in(Z.bi_label,["B+","B-","D","C*"]) then
 let extra= if Z.bi_label="B+" then 1 else 0 fi in 
 count(Z,0) + 2*count(Z,2) + count(Z,3) + count(Z,4) + extra
else
 size(Z)
fi

set q(PaintedBiPartition Z)=int:
if is_in(Z.bi_label,["B+","B-","D","C*"]) then
 let extra= if Z.bi_label="B-" then 1 else 0 fi in 
 count(Z,0) + 2*count(Z,1) + count(Z,3) + count(Z,4) + extra
else
 size(Z)
fi

set_type GroupDatum=(string name,int p,int q)
set =(GroupDatum A,GroupDatum B)=bool:
 A.name=B.name and A.p=B.p and A.q=B.q

set all_group_data(int rank,string label)=[GroupDatum]:
if is_in(label,["B"]) then
 for i:2*rank+2 do ("SO",2*rank+1-i,i) od
elif label="D" then
 for i:2*rank+1 do ("SO",2*rank-i,i) od
elif label="C" then [("Sp",2*rank,-1)]
elif label="C*" then 
 for i:rank+1 do ("Sp",rank-i,i) od
elif label="D*" then [("SO*",2*rank,0)]
elif label="C~" then [("Mp",2*rank,0)]
else error("incorrect data")
fi
 
{nice text version of group_datum}
set group_name(GroupDatum G)=string:
if G.name="SO" 
 then "SO("+G.p+","+G.q+")"
elif G.name="Sp" and G.q=-1
 then "Sp("+G.p+",R)"
elif G.name="Sp" and G.q>=0
 then "Sp("+G.p+","+G.q+")"
elif G.name="SO*" 
 then "SO*("+2*G.p+")"
else
 prints("incorrect bi_label");""
fi

{distinguish between SO(p,q) and SO(q,p), etc.}
set group_datum(PaintedBiPartition Z)=GroupDatum:
if is_in(Z.bi_label,["B+","B-","D"]) then
    ("SO",p(Z),q(Z))
 elif Z.bi_label="C" then
    ("Sp",2*p(Z),-1)  {-1 to indicate Sp(2n,R) not Sp(p,q)}
 elif Z.bi_label="C*" then
    ("Sp",h(p(Z)),h(q(Z)))
 elif Z.bi_label="D*" then
    ("SO*",2*p(Z),0)
 elif Z.bi_label="C~" then
    ("Mp*",2*size(Z),0)
else
  error("incorrect bi_label")
fi

{go directly from PaintedBiPartition to GroupName}
set group_name(PaintedBiPartition Z)=string:
if is_in(Z.bi_label,["B+","B-","D"]) 
 then "SO("+p(Z)+","+q(Z)+")"
elif Z.bi_label="C"
 then "Sp("+2*size(Z)+",R)"
elif Z.bi_label="C*" then
 "Sp("+rat_as_int(p(Z)/2)+","+ rat_as_int(q(Z)/2)+")"
elif Z.bi_label="D*" then 
 "SO*("+2*size(Z)+")"
elif Z.bi_label="C~" then 
 "Mp("+2*size(Z)+")"
else
 prints("incorrect bi_label");""
fi

set dim_tau(PaintedBiPartition Z)=int:
if Z.bi_label="B+" or Z.bi_label="B-" then 2*size(Z)+1 else 2*size(Z) fi

{O=Orbit=Partition  O=[O[0],...,O[n-2],O[n-1]]
 see Definition 3.5
 condition: parity condition on i and
 O[i-1]-O[i] is even (O[i-1] is the i^th entry of O)
 i=1 -> O[0]-O[1] is even...
 i=n-1 -> O[n-2]-O[n-1] is even
 i=n -> O[n-1] is even
}
set is_primitive_parity(int i, string bi_label)=bool:
let label=label_of(bi_label) in 
if is_in(label,["C","C~","C*"])
 then is_odd(i)
elif is_in(label,["B","D","D*"])
 then is_even(i)
else
 error("missing case in is_primitive_parity")
fi

set is_primitive(Orbit O,int i, string label)=bool:
assert(i>0 and i<=#O, "i out of range");
is_primitive_parity(i,label) and
if i<#O 
 then is_even(O[i-1]-O[i]) and O[i-1]-O[i]>0
 else is_even(O[i-1])
fi

{set of integers}
set primitive_pairs(Orbit O,string label)=[int]:##for i:#O-1 from 1 do if is_primitive(O,i,label) then [i] else [] fi od
set pp(Orbit O,string label)=[int]:primitive_pairs(O,label)
set number_primitive(Orbit O,string label)=int:#primitive_pairs(O,label)

{A_bar is the set of subset of pp(O,label)}
set A_bar(Orbit O, string label)=[[int]]:power_set(pp(O,label))
set A_bar_rank(Orbit O,string label)=int:#pp(O,label)
set A_bar_order(Orbit O,string label)=int:#A_bar(O,label)

set show_partition(PaintedPartition P)=void:show_partition(partition(P))

set show_painted_partition(PaintedPartition P)=void:
for row in P do prints(symbol_string(row)) od

set show(PaintedBiPartition (P,Q,bi_label))=void:
prints("P:");show_painted_partition(P);
prints("---------",new_line,"Q:");show_painted_partition(Q)

set show_short(PaintedBiPartition (P,Q,bi_label))=void:
prints(P, " ", Q, " ", bi_label, " ", group_name(P,Q,bi_label))

set show_short([PaintedBiPartition] list)=void:
tabulate(for (P,Q,bi_label) in list do
 [P.to_string,Q.to_string,bi_label,group_name(P,Q,bi_label)] od)

