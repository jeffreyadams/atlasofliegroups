<basic.at
<generics.at { for |fst|, |snd| }
<W_orbit.at
<Levi_subgroups.at
<simple_factors.at
<lietypes.at  { for |is_locally_isomorphic| }
<group_operations.at

{ Goal: given two sub-root systems of |rd|, find |w| taking one to the other

N.B. If these are Levi subsystems, this can be done efficiently by using
  a |StdLeviFinder| like |Levi_lookup(rd,orbits_table(rd))|, which for both
  subsystems will find a conjugate standard Levi subgroup, with a witness.
  The functions here however do not require de sub-rootsystem to be saturated.

Algorithm:

  Given (rd,[vec] A,[vec] B)
  where A,B are subsets of roots of rd of same cardinality
  implicitly assuming A, B are set of simple roots of
  a sub root system (subgroup of the complex group)
  containing the Cartan T

maybe_a_conjugator_strict:
  first test that A,B give the same Cartan matrix
   assuming A,B are each the set of simple roots of a RootDatum
  if this passes then
  look for w\in W(rd) taking A[0] to B[0]
  if found:
   rd->centralizer(rd,B[0])
   A-> delete(0,A)
   B-> delete(0,B)
  recursion, ends if #A=#B=0
  return value is maybe_a_conjugator: (void no_w| WeylElt w)

maybe_a_conjugator:
  run over all of the permutation of A (symmetric group of size |A|)
  many choices will fail quickly from the Cartan matrix test

These work for any sub root system

}


{ root datum of coroots perpendicular to all columns of |wts| }
set centralizer(RootDatum rd,mat wts) = RootDatum:
  sub_datum(rd,(int i) bool: =coroot(rd,i)*wts)

set move_by_Levi (RootDatum rd,[int]Levi,int alpha,int beta) = Maybe<WeylElt>:
   let (x,dom0) = from_dominant_root(rd,Levi,alpha)
     , (y,dom1) = from_dominant_root(rd,Levi,beta)
in if dom0=dom1 then (y*/x).some else ().none fi

{ Find all Weyl group elements that send the |mamas| in order to the |papas|
  The result is in general a right coset for a Levis subgroup, we we return
}
set transporter(RootDatum rd, [int] mamas, [int] papas) =
      Maybe<([int],WeylElt)>: { (L,w) represents right coset |Levi_of(L)*w| }
   if Cartan_matrix(rd,mamas) = Cartan_matrix(rd,papas)
   else none()
   then
      let cur_w = id_W(rd), Levi = [int]: all_simples(rd)
   in
      for (alpha,beta) in zip(mamas,papas)
      do case move_by_Levi(rd,Levi,permuted_root(cur_w,alpha),beta)
	 | none: return none()
	 | some(w): cur_w := w*cur_w { combine from right to left }
	   ; let (,select) = Levi_info(rd,Levi)
	     then stricter (int i) = bool:
	        select(i) and coroot(rd,i)*root(rd,beta)=0
	     in Levi := simples(rd,stricter)
	 esac
     ~od
   ;  some(Levi,cur_w)
   fi

{ The same, but forget the Levi subgroup, return just a coset representative }
set maybe_conjugate_strict (RootDatum rd,[vec] A,[vec] B) =
   Maybe<WeylElt>:
   let rts1 = for alpha in A do root_index(rd,alpha) od
   ,   rts2 = for alpha in B do root_index(rd,alpha) od
in case transporter(rd,rts1,rts2)| none: none() | some(,w): some(w) esac

{ Now try all permutations, intelligently }

{ Find some Weyl group element that sends the |mamas| in to the |papas|
  as sets of root indices, possibly permuting them.
}
set permuting_transporter(RootDatum rd, [int] mamas, [int] papas) =
      Maybe<(WeylElt)>:
   let degree(int i,[int]js) = int:
      for j in js do coroot(rd,i)*root(rd,j)!=0 od.count
   , n = if #mamas=#papas then #mamas else return none() fi
   , crts = mat: rd.rank # for m in mamas do coroot(rd,m) od { by columns }
   then mdegs = for i in mamas do degree(i,mamas) od
   ,    pdegs = for i in papas do degree(i,papas) od
   ,  maps = [[int]]:
      { maps |indices(mamas)->indices(papas)| preserving degree and more }
      ([]).
      (rec_fun perms([int]f) [[int]]:
       let k=#f in { now |f| maps #k->#n injectively }
       if k=n then [f]
       else
          let deg = degree(mamas[k],mamas), mcr_vec = root(rd,mamas[k])*crts[:k]
          , pcr = mat: rd.rank # for i:k do coroot(rd,papas[f[i]]) od
       in for im in complement(n,f)
          do if =(deg,degree(papas[im],papas))
	    and =(mcr_vec,coroot(rd,papas[im])*pcr)
	     do perms(f#im)
	     fi
	  od.##.##
       fi
      )
in for f in maps
   do case transporter(rd,mamas,for v in f do papas[v] od)
      | none: () { skip unproductive maps  }
      | some(,w): return some(w)
      esac
   od; none()

set is_conjugate_weak (RootDatum rd,RootDatum sub1,RootDatum sub2) = bool:
   dominant(rd,two_rho(sub1))=dominant(rd,two_rho(sub2))
set is_conjugate_weak (RootDatum sub1,RootDatum sub2,RootDatum rd) = bool:
   dominant(two_rho_check(sub1),rd)=dominant(two_rho_check(sub2),rd)

{ which standard Levi is conjugate to (the non-standard) L, and by which w? }
{ actually: makes a choice from a list of representatives of conjugacy classes
  of Levi subgroups. Here |L| can be non-standard, but even if it is standard
  it will return another Levi in case it isn't the elected representative }
set standard_Levi_and_witness (RootDatum rd,RootDatum rd_L) =
      (RootDatum,WeylElt):
   let finder = StdLeviFinder: Levi_lookup(rd,orbits_table(rd))
   , Levi = for alpha in simple_roots(rd_L) do root_index(rd,alpha) od
   then (w,std_Levi) = finder(Levi) { |w| conjugates |std_Levi| to |Levi| }
in (Levi_datum(rd,std_Levi),inverse(w)) { our convention is inverse for |w| }

set standard_Levi ((RootDatum,RootDatum) args) = RootDatum:
   fst(standard_Levi_and_witness(args))

{ return a WeylElt, assumed to exist, taking rd_L to a standard Levi root datum }
set standard_Levi_witness ((RootDatum,RootDatum) args) = WeylElt:
   snd(standard_Levi_and_witness(args))


{ witness of conjugation from |rd_L| to |rd_M|, using standard Levi in |rd| }
set Levi_witness(RootDatum rd, RootDatum rd_L,RootDatum rd_M) = WeylElt:
   let finder = StdLeviFinder: Levi_lookup(rd,orbits_table(rd))
   , L = for alpha in simple_roots(rd_L) do root_index(rd,alpha) od
   , M = for alpha in simple_roots(rd_M) do root_index(rd,alpha) od
   then (w1,Levi1)= finder(L), (w2,Levi2) = finder(M)
in assert(Levi1=Levi2,"Non conjugate Levi data"); /w2*w1

{ automorphisms given by permutations of simple roots/coroots
  automorphism of Lie algebra
}
set diagram_automorphisms (RootDatum rd) = [mat]: { permutations of diagram }
   let C=rd.Cartan_matrix
in for w in W(GL(#C)) if w*C=C*w do matrix(w) fi od

{this only works for rd semisimple}
set outer_automorphism_group (RootDatum rd) = [mat]: { isomorphisms of X^* }
   if rd.is_abelian then []
   else
      assert(rd.is_semisimple,"RootDatum is not semisimple (or abelian)")
   ;  let A=simple_roots(rd) { viewed as basis change canonical->simple roots }
      then A_inverse = ratmat: rational_inverse(A)
   in for P in diagram_automorphisms(rd)
      do {P is a permutation, M is in correct basis of X^*}
         let (M,,d) = A*P*A_inverse { compute and take apart rational matrix }
      in if d=1 do M fi { only use diagram automorphisms that extend to X^* }
      od.##
   fi

{ return list of pairs (P,m)
  here P is a permutation matrix of size semisimple_rank(rd_L)
  WeylElt is in W(rd)
}
set normalizer (RootDatum rd_L,RootDatum rd,[mat] outer_automorphisms) =
      [(mat,WeylElt)]:
   let A=simple_roots(rd_L) in
   for P in outer_automorphisms
   do case maybe_conjugate_strict(rd,A,A*P)
      | none: []
      | some(m): [(P,m)]
      esac
   od.##

set normalizer (RootDatum rd_L,RootDatum rd) = [(mat,WeylElt)]:
   let A=simple_roots(rd_L)
   , automorphisms = [mat]:
      if rd_L.is_semisimple
      then rd_L.outer_automorphism_group {if semsimple cut down to this}
      else { when not semisimple, try all diagram automorphisms }
          rd_L.diagram_automorphisms
      fi
in for P in automorphisms
   do case maybe_conjugate_strict(rd,A,A*P)
      | none: []
      | some(m): [(P,m)]
      esac
   od.##
