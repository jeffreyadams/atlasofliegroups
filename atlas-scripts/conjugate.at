<basic.at
<generics.at { for |fst|, |snd| }
<W_orbit.at
<Levi_subgroups.at
<simple_factors.at
<lietypes.at  {for locally isomorphic}
<group_operations.at

{ Goal: given two sub-root systems of |rd|, find |w| taking one to the other

N.B. If these are Levi subsystems, this can be done efficiently by using
  a |StdLeviFinder| like |Levi_lookup(rd,orbits_table(rd))|, which for both
  subsystems will find a conjugate standard Levi subgroup, with a witness.
  The functions here however do not require de sub-rootsystem to be saturated.

Algorithm:

  Given (rd,[vec] A,[vec] B)
  where A,B are subsets of roots of rd of same cardinality
  implicitly assuming A, B are set of simple roots of
  a sub root system (subgroup of the complex group)
  containing the Cartan T

maybe_a_conjugator_strict:
  first test that A,B give the same Cartan matrix
   assuming A,B are each the set of simple roots of a RootDatum
  if this passes then
  look for w\in W(rd) taking A[0] to B[0]
  if found:
   rd->centralizer(rd,B[0])
   A-> delete(0,A)
   B-> delete(0,B)
  recursion, ends if #A=#B=0
  return value is maybe_a_conjugator: (void no_w| WeylElt w)

maybe_a_conjugator:
  run over all of the permutation of A (symmetric group of size |A|)
  many choices will fail quickly from the Cartan matrix test

These work for any sub root system

}

{given subset of positive roots, which are
return the root datum for which these are
the simple roots
}
set sub_datum_for_roots(RootDatum rd,[vec] roots) = RootDatum:
   sub_datum(rd,for alpha in roots do root_index(rd,alpha) od)

{Cartan matrix just from a set of roots in rd
 (which are the simple roots of a sub root system)
 }
set Cartan_matrix_for_roots(RootDatum rd,[vec] roots) = mat:
   Cartan_matrix(rd,for alpha in roots do root_index(rd,alpha) od)

{ root datum of coroots perpendicular to all columns of |wts| }
set centralizer(RootDatum rd,mat wts) = RootDatum:
  sub_datum(rd,(int i) bool: =coroot(rd,i)*wts)


{Two versions, weights and coweights}

{Version 1: elements of X^*}

{ try to find $w\in W$ such that $w*u=v$, for given $u,v\in X^*$ }
set mover(RootDatum rd, vec u, vec v) = Maybe<WeylElt>:
   let (x,u_1) = from_dominant(rd,u), (y,v_1)= from_dominant(rd,v) in
   if u_1=v_1 then (y*inverse(x)).some else ().none fi

set is_conjugate (RootDatum rd, vec u, vec v) = bool: { succeeds(mover(rd,u,v)) }
   dominant(rd,u)=dominant(rd,v)

set mover (RootDatum rd, ratvec u, ratvec v) = Maybe<WeylElt>:
{ since $W$-action stabilizes $\Z^n$, it cannot change ratvec denominators }
   let (a,b)=%u, (c,d)=%v in if b=d then mover(rd,a,c) else ().none fi

set is_conjugate (RootDatum rd, ratvec u, ratvec v) = bool:
   let (a,b)=%u, (c,d)=%v in b=d and is_conjugate(rd,a,c)


{Version 2: elements of X_*}

{ try to find $w\in W$ so u*w=v$, for given $u,v\in X_*$ }
set mover (vec u, vec v,RootDatum rd) = Maybe<WeylElt>:
   let (u_1,x)=from_dominant(u,rd), (v_1,y)=from_dominant(v,rd) in
   if u_1=v_1 then (inverse(x)*y).some else ().none fi

set is_conjugate(vec u, vec v,RootDatum rd) = bool: { succeeds(mover(u,v,rd)) }
   dominant(u,rd)=dominant(v,rd)

set mover (ratvec u, ratvec v,RootDatum rd) = Maybe<WeylElt>:
   let (a,b)=%u, (c,d)=%v in if b=d then mover(a,c,rd) else ().none fi

set is_conjugate(ratvec u, ratvec v,RootDatum rd) = bool:
   let (a,b)=%u, (c,d)=%v in b=d and is_conjugate(a,c,rd)


{ make an element of W(rd) from [W_Elt] for smaller root data}
set make_W_element ([WeylElt] S,RootDatum rd) = WeylElt:
   product(rd,for w in S do W_elt(rd,w.matrix) od)

{try to conjugate A[0], A[1],... to B[0], B[1] *in this order*}
{return value is Maybe<WeylElt>}
set maybe_conjugate_strict (RootDatum !rd_orig,[vec] A,[vec] B) =
   Maybe<WeylElt>:
   if (#A != #B) then ().none
   elif Cartan_matrix_for_roots(rd_orig,A) != Cartan_matrix_for_roots(rd_orig,B)
   then ().none
   else
	{keep rd_orig for computing cartan_matrix(rd_orig,*)
	 modify |rd| while building up a sequence of acting elments }
      let rd=rd_orig, S=[WeylElt]: [] in
      for (a,b) in zip(A,B)
      do case mover(rd,make_W_element(S,rd_orig)*a,b) { apply prev mapping }
	 | none: return none()
	 | some(w):
	     rd :=centralizer(rd,[b]) { henceforth restrict to fixing |b| }
	   ; S := w#S { prepend |w| to list of elements acting }
	 esac
      od
   ;  make_W_element(S,rd_orig).some { wrap up }
   fi

set is_conjugate_strict((RootDatum,[vec],[vec]) args)=bool:
  succeeds(maybe_conjugate_strict(args))

{error if w doesn't exist}
set conjugate_strict((RootDatum,[vec],[vec]) args)=WeylElt:
   requisition(maybe_conjugate_strict(args))

{try all permutations}

set maybe_conjugate(RootDatum rd,[vec] A,[vec] B) = Maybe<WeylElt>:
   if rank(rd)=0 or #A=0 and #B=0 then id_W(rd).some
   elif (#A=0 and #B>0) or (#A>0 and #B=0) then ().none { trivial cases }
   else let Amat = mat: #A[0] # A { convert to matrix with given columns }
   in for w in W(GL(#A))
      do case maybe_conjugate_strict(rd,Amat*w,B)
         | some(w): return some(w)
	 | none: ()
	 esac
      od
   ;  ().none { report failure if loop runs to completion }
   fi

set is_conjugate((RootDatum,[vec],[vec]) args)=bool:
  succeeds(maybe_conjugate(args))

{error if w doesn't exist}
set conjugate((RootDatum,[vec],[vec]) args)=WeylElt:
   requisition(maybe_conjugate(args))

set is_conjugate (RootDatum rd,[vec] A,[vec] B) = bool:
   succeeds(maybe_conjugate(rd,A,B))


set maybe_conjugate_strict (RootDatum rd,RootDatum sub_1,RootDatum sub_2) =
      Maybe<WeylElt>:
{very easy test first}
   if not is_locally_isomorphic(sub_1,sub_2) then ().none
   elif {rho_check test next}
       not is_conjugate(rd,rho_check(sub_1),rho_check(sub_2))
   then ().none
   else maybe_conjugate_strict(rd,simple_roots(sub_1),simple_roots(sub_2))
   fi

set maybe_conjugate (RootDatum rd,RootDatum sub_1,RootDatum sub_2) =
      Maybe<WeylElt>:
{very easy test first}
   if not is_locally_isomorphic(sub_1,sub_2) then ().none
   {rho_check test next}
   elif not is_conjugate(rho_check(sub_1),rho_check(sub_2),rd) then ().none
   else maybe_conjugate(rd,simple_roots(sub_1),simple_roots(sub_2))
   fi

set is_conjugate ((RootDatum,RootDatum,RootDatum)args) = bool:
   succeeds(maybe_conjugate(args))

set is_conjugate_weak (RootDatum rd,RootDatum sub_1,RootDatum sub_2) = bool:
   is_conjugate(rd,rho(sub_1),rho(sub_2))

{ which standard Levi is conjugate to (the non-standard) L, and by which w? }
{ actually: makes a choice from a list of representatives of conjugacy classes
  of Levi subgroupe. Here |L| can be non-standard, but even if it is standard
  it will return anoth Levi in case it isn't the elected representative }
set standard_Levi_and_witness (RootDatum rd,RootDatum rd_L) =
      (RootDatum,WeylElt):
   let finder = StdLeviFinder: Levi_lookup(rd,orbits_table(rd))
   , Levi = for alpha in simple_roots(rd_L) do root_index(rd,alpha) od
   then (w,std_Levi) = finder(Levi) { |w| conjugates |std_Levi| to |Levi| }
in (Levi_datum(rd,std_Levi),inverse(w)) { our convention is inverse for |w| }

set standard_Levi ((RootDatum,RootDatum) args) = RootDatum:
   fst(standard_Levi_and_witness(args))

{ return a WeylElt, assumed to exist, taking rd_L to a standard Levi root datum }
set standard_Levi_witness ((RootDatum,RootDatum) args) = WeylElt:
   snd(standard_Levi_and_witness(args))


{ witness of conjugation from |rd_L| to |rd_M|, using standard Levi in |rd| }
set Levi_witness(RootDatum rd, RootDatum rd_L,RootDatum rd_M) = WeylElt:
   let finder = StdLeviFinder: Levi_lookup(rd,orbits_table(rd))
   , L = for alpha in simple_roots(rd_L) do root_index(rd,alpha) od
   , M = for alpha in simple_roots(rd_M) do root_index(rd,alpha) od
   then (w1,Levi1)= finder(L), (w2,Levi2) = finder(M)
in assert(Levi1=Levi2,"Non conjugate Levi data"); /w2*w1

{ automorphisms given by permutations of simple roots/coroots
  automorphism of Lie algebra
}
set diagram_automorphisms (RootDatum rd) = [mat]: { permutations of diagram }
   let C=rd.Cartan_matrix
in for w in W(GL(#C)) if w*C=C*w do matrix(w) fi od

{this only works for rd semisimple}
set outer_automorphism_group (RootDatum rd) = [mat]: { isomorphisms of X^* }
   if rd.is_abelian then []
   else
      assert(rd.is_semisimple,"RootDatum is not semisimple (or abelian)")
   ;  let A=simple_roots(rd) { viewed as basis change canonical->simple roots }
      then A_inverse = ratmat: rational_inverse(A)
   in for P in diagram_automorphisms(rd)
      do {P is a permutation, M is in correct basis of X^*}
         let (M,,d) = A*P*A_inverse { compute and take apart rational matrix }
      in if d=1 do M fi { only use diagram automorphisms that extend to X^* }
      od.##
   fi

{ return list of pairs (mat,WeylElt)
  mat is a permutation matrix of size semisimple_rank(rd_L)
  WeylElt is in W(rd)
}
set normalizer (RootDatum rd_L,RootDatum rd,[mat] outer_automorphisms) =
      [(mat,WeylElt)]:
   let A=simple_roots(rd_L) in
   for P in outer_automorphisms
   do case maybe_conjugate_strict(rd,A,P*A)
      | none: []
      | some(m): [(P,m)]
      esac
   od.##

set normalizer (RootDatum rd_L,RootDatum rd) = [(mat,WeylElt)]:
   let A=simple_roots(rd_L)
   , automorphisms = [mat]:
      if rd_L.is_semisimple
      then rd_L.outer_automorphism_group {if semsimple cut down to this}
      else { when not semisimple, try all diagram automorphisms }
          rd_L.diagram_automorphisms
      fi
in for P in automorphisms
   do case maybe_conjugate_strict(rd,A,P*A)
      | none: []
      | some(m): [(P,m)]
      esac
   od.##

set scad (RootDatum rd) = string:
   if rd.is_simply_connected then "sc" elif rd.is_adjoint then "ad" else "" fi
