<K_highest_weights {for all_lambda_differential_zero}
<lattice {for vec_solve}
{ <chopping_facets_fast.at {for chop_coroots(G, vertices)}}
<face_classes {for ordering on facets}
<hash {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<FPP_localDirac
<cohIndUnip {for weakly fair cohom ind}
<derived_cover {for simply connected acover of derived group}
<R_packets.at {for trying to combine x's with same LKT}
<steve.at {for unitarity by Steve's theorem}

{functions for computing the entire FPP_unitary dual}
{typically functions take a Param_hash Uhash and fill it with all
unitary reps having infinitesimal character in the FPP. Each p is
replaced by herm_center(p), at the barycenter of its local facet,
so that the lists are finite.}

{. This controls the maximum denominator size kept in chop_coroots,
used in moving unitarity information from a Levi to G. Large values
allow more chopped faces, and so convey more information to G; but
small values are faster. Too small a value cannot lead to wrong
answers, but only to running more is_unitary tests .}
set chop_bound = int: 6

set kill_for_big_uTime_flag = false

set kill_for_big_uTime_bound = int: -1

set activate_kill_for_big_uTime(int T) = void:
    let () = kill_for_big_uTime_flag :=  true
    in kill_for_big_uTime_bound:= T

set kill_for_big_uTime() = void:
    if (kill_for_big_uTime_flag)
       and (kill_for_big_uTime_bound.>=)
       and (unitaryTime > kill_for_big_uTime_bound)
    then prints("I can't live...if living is without U")
    fi

set UFast() = void:
    prints("Setting old_test_interrupt_flag:=false, deformed_hash_flag:=true");
    old_test_interrupt_flag:=false;
    deformed_hash_flag:=true

set ULoud() = void:
    test_interrupt_verbose:=true

{if true, compute reps weakly fair cohom induced from Arthur unipotent}
{set coh_ind_few_flag = false}

{if true, use coh_ind_most; gets everything at least to rank about 6??}
set coh_ind_most_flag = false

{if true, use (much) slower but complete coh_ind_all}
set coh_ind_all_flag = false

{if true, load Arthur unipotent reps into unitary hash before starting FPP.
Computing Arthur unipotents takes a long time for high rank (e.g. rank 4
complex}
{definition moved to FPP_localDirac.at}
{set unip_flag = true}

{next functions aim to compute FULL spherical dual in non-split case,
when several different x give spherical reps}

{if face_verbose is true, report after each |lambda_skip| lambda's
are treated in FPP_unitary}
set lambda_skip = int:10

{if true, then report summary each lambda in FPP_unitary}
set every_lambda_flag = false

{if true, then report progress during each lambda in FPP_unitary}
set every_lambda_deets_flag = false

{if true, then report summary each KGBElt in FPP_unitary}
set every_KGB_flag = false

{whether to use the "tester" version in FPP_unitary_hash_steve, which uses steve only for
 vertices and edges}
set steve_tester_flag = true

{whether to switch to _steve when x = x_open}
set prefer_steve_long_flag = true

set revert_steve_flag(KGBElt x) = bool:
    let G = x.real_form
    in prefer_steve_long_flag and
       is_quasisplit(G) and
       (x.number = #KGB(G) - 1){ and
       (lambda != G.rho)}

set revert_steve_flag(KGBElt x, ratvec lambda) = bool:
    let G = x.real_form
    in prefer_steve_long_flag and
       is_quasisplit(G) and
       (x.number = #KGB(G) - 1) and
       (lambda != G.rho)

set contragredient(KGBElt x) = KGBElt:
    let wzero = w0(x.root_datum) in cross(wzero,x)

set K_ss_rk = (RealForm -> int):
    let Ghash = make_RealForm_hash()
    then kssrks = vec:[]
    in (RealForm -> int): (RealForm G) int:
       let N = Ghash.size()
       then n = Ghash.match(G)
       in if n=N
       	  then let r = rank(K_0(adjoint(G)))
	       in kssrks#:=r
	  fi;
	  kssrks[n]

{if false, then always use bottom layer when it's called for}
{set test_bl_flag = false} {true; changed to false AFTER 11/14 commit}
{DELETED 11/16: accomplish by easy_test_flag:=false and hard_test_flag:=false}

{if true, and test_bl_flag true, then introduce more_shift when appropriate}
set test_more_flag = true

{how close to next_heights(G) the largest more_shift can be; maybe in range (0,1)?}
set more_shift_frac = rat:2/3

set more_bound = rat: 1/4
{Very large suggested values of more_shift in E8_s lead to very slow more_bottom calculations. Need to bound somehow.
Try size of lambda/4???}

set KGB_frac_flag =true

{if KGB_frac_flag and x is less than this fraction of KGB, then switch from bottom_layer to one_level}
set KGB_frac = rat:1/3

{if more_KGB_frac_flag and x between these fractions of KGB, use more}
set start_more_KGB_frac = rat: 4/5
set end_more_KGB_frac = rat: 49/50
{set one_level_frac_flag =true}


{if true, use test_bl to decide about bottom_layer}
set hard_test_flag = false

{if true, and hard_test_flag is false, then use easy_test_flag}
set easy_test_flag = true

{If one_level_frac_flag and x exceeds this fraction of KGB, then make one_level_revert_flag true}
{set one_level_frac = 2/3}

{if NOT KGB_frac, and height is smaller than this fraction of max height, then switch
    from bottom_layer to one_level or hash2}
set lambda_frac = rat: 2/3

set bl_shift(KGBElt x, ratvec lambda, LocalVertexData Lvd) = int:
    let pmax = pmax(x,lambda,Lvd), rd = x.root_datum, theta = x.involution
    then GAM = height(rd, pmax.infinitesimal_character)
    then LAM = height(rd, (1+theta)*lambda/2)
    in floor(min((LAM+1)*more_bound, (GAM - LAM)*shift_frac)) + 1

{Meant to be the biggest useful more-shift??}
set most_more(RealForm G) = (G.semisimple_rank - 3)*(G.semisimple_rank - 3)

{returning "true" means bottom layer ought to be used}
{start messing again 11/5/25. This version  sets more_shift to be zero
unless x.number >= (#KGB)*start_more_KGB_frac, and L(x,lambda) is not maximal.}
set hard_test_bl(KGBElt x, ratvec lambda) = bool:
    if semisimple_rank(x.real_form) < 7 then return false fi;
    if KGB_frac_flag and x.number < KGB_frac*(#KGB(x.real_form)) then return false fi;
    if not test_more_flag then return true fi;
    let start = elapsed_ms(), G=x.real_form,
        N = #KGB(x.real_form), n = x.number
    then () = if n < start_more_KGB_frac*N
    	      then more_shift(0);
	      	   test_bl_time +:= elapsed_ms() - start;
	      	   return true
	      else more_shift(most_more(G))
	      fi
    then p = parameter(x,lambda,0*lambda)
    then (Q,) = theta_stable_quasi_data(p)
    then L = Q.Levi
    in if K_ss_rk(L) >= K_ss_rk(G) - 1
       then more_shift(0)
       fi;
       test_bl_time +:= elapsed_ms() - start;
       true

{returning "true" means bottom layer ought to be used}
set easy_test_bl(KGBElt x) = bool:
    let G = x.real_form
    then N = #KGB(G), n = x.number
    in if semisimple_rank(x.real_form) < 7
       then false
       elif KGB_frac_flag and n < KGB_frac*N
       then false
       elif n > start_more_KGB_frac*N and
       	    n < end_more_KGB_frac*N
       then more_shift(most_more(G));
       	    true
       else more_shift(0);
       	    true
       fi

{whether to adjust next_heightC_flag}
set test_next_flag = true

set KGB_next_frac = 3/5

set test_next(KGBElt x) = void:
    if not test_next_flag then return () fi;
    if x.real_form.semisimple_rank >= 6 and x.number > KGB_next_frac * #(KGB(x.real_form)) 
    then next_heightC_flag:=true
    else next_heightC_flag:=false
    fi

set test_no_unitary(KGBElt x, ratvec lambda, LocalVertexData Lvd) = bool:
    if twist(x) != x
    then finish(x,lambda);
    	 return true fi;
    if fewer_reducible_unitary_flag and
       not is_pos_on_LKTs(parameter(x,lambda, 0*lambda))
    then finish(x,lambda);
    	 return true
    fi;
    let  start = elapsed_ms(), (Rs,CORs) = simple_real_subsystem(x)
    then colCORs = [vec]: for alpha@j in Rs
		      	  do if (((CORs[j]*lambda).numer)%2).= {parity at zero}
			     then [CORs[j]]
			     else []
			     fi
			  od.##
    then answer = not is_pos_on_LKTs(parameter(x,lambda, 0*lambda)) and
       	   	      all(for v in Lvd.list
	       	      	  do @bool: all(for colCOR in colCORs
			     	    	do @bool: (v*colCOR).>
			     		od)
	      		  od) {no parity real coroots vanish on any nu}
    then () = test_no_unitary_time +:= elapsed_ms() - start
    in if answer
       then finish(x,lambda)
       fi;
       answer

set test_no_unitary(KGBElt x, ratvec lambda) = bool:
    test_no_unitary(x,lambda,Lvd(x,lambda))

{if twist(x) != x then return false fi;
    if fewer_reducible_unitary_flag and
       not is_pos_on_LKTs(parameter(x,lambda, 0*lambda))
    then return true fi;
        let  start = elapsed_ms()
    then () = if is_pos_on_LKTs(parameter(x,lambda,0*lambda))
     	      then test_no_unitary_time +:= elapsed_ms() - start; return false
	      fi
    then (Rs,CORs) = simple_real_subsystem(x)
    then colCORs = [vec]: for alpha@j in Rs
		      	  do if (((CORs[j]*lambda).numer)%2).= {parity at zero}
			     then [CORs[j]]
			     else []
			     fi
			  od.##
    then answer = all(for v in local_FPP_extrema(x,lambda)
	       	      do @bool: all(for colCOR in colCORs
			     	    do @bool: (v*colCOR).>
			     	    od)
	      	      od) {no parity real coroots vanish on any nu}
    then () = test_no_unitary_time +:= elapsed_ms() - start
    in answer}

set test_no_Dirac(KGBElt x, ratvec lambda, LocalVertexData Lvd) = bool:
    if twist(x) != x
    then finish(x,lambda);
    	 return true
    fi;
    let start = elapsed_ms(), DiracBD = DiracBD(x,lambda), Q = invariant_form(x.real_form)
    then answer = none(for v in Lvd.list
       	   	        do @bool: Q(v,v) <= DiracBD od)
    then () = test_no_Dirac_time +:= elapsed_ms() - start
    in if answer then finish(x,lambda) fi;
       answer

{just test extremal vertices. Not clear that this is OK: Dirac could
fail for the extreme points, but pass for some interior point. Also SLOWER than test_no_Dirac
except for #Lvd.list approximately 50000???}
set test_no_Dirac_extr(KGBElt x, ratvec lambda) = bool:
    if twist(x) != x then return true fi;
    let start = elapsed_ms(), DiracBD = DiracBD(x,lambda), Q = invariant_form(x.real_form)
    then answer = none(for v in local_FPP_extrema(x,lambda)
    	 	       do @bool: Q(v,v) <= DiracBD od)
    then () = test_no_Dirac_time +:= elapsed_ms() - start
    in answer

set test_no_Dirac_extr(KGBElt x, ratvec lambda) = bool:
    test_no_Dirac(x, lambda, Lvd(x, lambda))

{if lots of local verts, then use local_FPP_extrema; increasing this means
use local_FPP_extrema less}
set test_list_frac = rat:11/10 {at the moment FPP_extrema is too slow to be helpful}

set test_neither_flag = true

set test_neither(KGBElt x, ratvec lambda, LocalVertexData Lvd) = bool:
    if not test_neither_flag then return false fi;
    if twist(x) != x then return false fi;
    test_no_unitary(x,lambda,Lvd) or
    	if #Lvd.list > test_list_frac*(#FPP_vertices(x.real_form))
    	then test_no_Dirac_extr(x,lambda)
    	else test_no_Dirac(x, lambda, Lvd)
    	fi

set test_neither(KGBElt x, ratvec lambda) = bool:
    if not test_neither_flag then return false fi;
    if twist(x) != x then return false fi;
    test_neither(x, lambda, Lvd(x, lambda))

set contragredient(KGBElt x, ratvec lambda) = (KGBElt, ratvec):
    let p = contragredient(parameter(x,lambda,0*lambda))
    in (p.x, p.lambda)

{cheating with x.number means list has repetitions; tries to add to KGB(SU(p,q) KGBElts for SU(q,p)}
set isotwistKGBs(KGBElt x) = [KGBElt]:
    let G = x.real_form, theta = x.involution, tf = x.torus_factor, rd = x.root_datum
    {then p = parameter(x,G.rho, G.rho)
    then dp = p.dual}
    then twists = all_even_lambda_differential_0(rd.dual, -theta.^), X = KGB(G)
    in for tau in twists do X[KGB_elt(rd, theta, tf + tau).number] od


set spherical_xs(RealForm G) = [KGBElt]:
    let real_rank = rank(x_open(G).involution + 1)
    in for x in KGB(G)
       do if rank(x.involution + 1) = real_rank
       	  then [x]
	  else []
	  fi
       od.##

{meant to hold barycenters of unitary faces}
set unitary_hash = make_Param_hash()

{meant to hold all unitary parameters found (maybe not final)}
set Uparamhash = make_Param_hash()

{whether to record unitary parameters in Uparamhash}
set Uparamhash_flag = false

{load a bunch of Param_hash's into one}
set transfer([Param_hash] Us, Param_hash target) = void:
    for U in Us
    do for j:U.size()
       do target.match(U.index(j))
       od
    od

{derived simple factors of all Levis of theta-stable P, omitting P=G}
set DSFLevis(RealForm G) = [RealForm]:
    for P in theta_stable_parabolics(G)~[1:]
    do derived_simple_factorsRF(P.Levi) od.##

set DSFLevi_hash(RealForm G) = RealForm_hash:
    make_RealForm_hash(DSFLevis(G), hash_code@(RealForm,int))

{if true, move computation to most split Cartan in R-packet}
set R_packet_flag = false
{as presently implemented, this misses unitary representations in
R-packets containing also nonunitary representations. Reason is that
these parameters are studied only on most split Cartan; software finds
that a parameter there has a nonunitary (reducible) LQ, and fails to
to record unitary factors.}


{uses LPm_table to keep track of local face info}
set FPP_unitary_hash_general([(KGBElt,ratvec)] xlambdas, Param_hash Uhash,
    (Param->bool) fancy_tester, (KGBElt, ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)->[Param])
    local) = void:
    if #xlambdas = 0 then return () fi;
    let (x,) = xlambdas[0]
    then G = x.real_form
    in if is_compact(G)
       then for p in all_parameters_gamma(G,G.rho)
       	    do Uhash.match(p)
	    od;
	    for (x,lambda) in xlambdas
	    do finish(x,lambda)
	    od;
            return ()
        fi;
    let xlambdasW = if R_packet_flag
    	      	    then for (x,lambda) in xlambdas
	      	         do up_Cayley_match_LKTs(x,lambda)
		   	 od
		    else xlambdas
	      	    fi
    then () = if #xlambdasW = 0
    	      then for (x,lambda) in xlambdas
	      	   do finish(x,lambda)
	    	   od;
            	   return ()
    	      else let (x,) = xlambdasW[0]
    then G = x.real_form, revert_steve_flag = false
    then {vd = FPP_vertex_data(G),} start = elapsed_ms(),  zeroNu = null(G.rank)/1
    then () = if FPP_report_flag
    	      then unitaryTime := 0; charTime := 0; FD12Time:=0; FD12bzTime:=0; red_count_time :=0;
	      	   branch_builtin_time :=0; branch_script_time := 0
	      fi
    then () = if FPP_report_flag
    	      then {clear_report_tested();} DTcount:=0; DBTcount:=0
	      fi
    then xnums = for (x,) in xlambdasW do x.number od
    then lambdas = for (,lambda) in xlambdasW do lambda od
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then startLPmss = elapsed_ms()
    then LPmss = for (x,lambda) in xlambdasW
    	       	 do LPm_table.LPm_entry(G,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
              	 od
    then () = if every_lambda_deets_flag and FPP_report_flag
    	      then prints("time for LPmss = ",print_time_string(elapsed_ms() - startLPmss))
	      fi
    then () = face_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_all_flag 
    	      then coh_ind_unip_all(G,Uhash) {this takes several seconds for F4_s}
	      elif coh_ind_most_flag
	      then coh_ind_unip_most(G,Uhash)
	      {elif coh_ind_few_flag
then coh_ind_unip_few(G,Uhash)}
	      fi
    then xlambdatimes = [int]: null(#xlambdasW)
    then answerCards = [int]: null(#xlambdasW) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    then current = elapsed_ms(), oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
         oldUtime = unitaryTime, currentUtime = unitaryTime, oldCtime = charTime, currentCtime = charTime,
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
		   oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count()
    {then () = if every_lambda_deets_flag
    	      then prints("time up to main loop = ",print_time_string(elapsed_ms() - start))
	      fi}
    then () = for (x,lambda)@k in xlambdasW
    	      do {xlambdasW}
	      	test_next(x);
	      	if twist(x) != x {close 482}
		then big_unitary_hash.finishx(x)
		elif is_finished(x,lambda) {this includes possibility that x is finished}
		then if FPP_report_flag
		     then prints("Already computed (",x,",",lambda,")")
		     fi;
		     ()
		else let xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
		     then tw = first(for y in xtwists[1:] do is_finished(y, lambda) od)
		     then twnum = if tw.>=
		     	  	  then last(for (y,tau) in xlambdasW[k:]
				       	    do y=xtwists[tw+1] and tau = lambda
					    od)
				  else -1
				  fi
		     then () = if twnum.>=
		     	       then answerCards[k]:= answerCards[twnum];
			       {too low if xtwist wasn't calculated here}
			       	    if Uparamhash_flag
	    	 	       	    then for p in Uparamhash.list()
	              	       	    	 do if p.x = xtwists[tw+1] and p.lambda = lambda
		      	     	       	    then Uparamhash.match(parameter(x,lambda,p.nu))
		    	 	       	    fi
		      	     	    	 od
			       	     fi
			  	 fi
		     then () = if tw.>=
		     	       then for p in Uhash.list()
			       	    do if p.x = xtwists[tw+1] and p.lambda = lambda
				       then Uhash.match(parameter(x,lambda,p.nu))
				       fi
				    od;
				    if FPP_report_flag and every_lambda_flag
		   		    then prints("Matching (",x,",",lambda,") with previously computed")
				    fi;
				    finish(x,lambda)
				fi
		     then (xcont,lambdacont) = contragredient(x,lambda)
		     then () = if tw.< and is_finished(xcont,lambdacont)
			       then for p in Uhash.list()
			       	    do if p.x = xcont and p.lambda = lambdacont
				       then Uhash.match(contragredient(p))
				       fi
				    od;
				    if FPP_report_flag and every_lambda_flag
		   		    then prints("Contragredient of (",x,",",lambda,") was previously computed")
				    fi;
				    tw:=0;
				    finish(x,lambda)
			       fi
	      	     in if tw.< {still have work to do close 482}
		     	then adjust_Dirac_flags(x);
			     if x=x_open(G)
			     then revert_steve_flag := revert_steve_flag(x,lambda)
			     fi;
		     	     let startxl = elapsed_ms(), startUhash = Uhash.size(),
		     	     	startUcounter = unitary_test_counter.use_count(),
			     	startCcounter = char_counter.use_count(),
			     	startUTime = unitaryTime, startCTime = charTime, theta = x.involution
		 		then p0 = parameter(x,lambda,zeroNu)
		 	{then () = prints("time before LPmss[",k,"] = ",
			      print_time_string(elapsed_ms() - start))}
		 	      	then (Lvd, Perm2) = LPmss[k]
		 		then () = if every_lambda_flag and FPP_report_flag
      	      	   	      	     	  then prints("     start #", k,
					       " = (",x,",",lambda,"), Uhash.size() = ",
			      		       Uhash.size(), ", runtime = ",
					       print_time_string(elapsed_ms() - start),
			      		       ", #uparams so far = ",sum(answerCards));
		   		   	       prints("  ------------------")
        	   	   		   fi {every_lambda_flag}
		 	        then startLF = elapsed_ms()
		 		in if test_no_unitary(x,lambda,Lvd) {close 481}
		    		   then ()
		    		   else adjust_Dirac_flags(x);
				   	let startDTcount = DTcount {now we're actually computing}
				   	then LF = [[FaceVertsIndex]]:
		      	   		     if revert_steve_flag
					     then [[]]
		      	   		     elif by_zero_flag {and height(p0) > 0}
		      	   		     then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
			   		     else localFD_1Dirac2(x, lambda, Lvd, Perm2)
			   		     fi {just red_count to edge_offset}
		 			then () = if every_lambda_deets_flag and FPP_report_flag
					     	     and not revert_steve_flag
    	      	      	   			  then prints("time for localFD_1Dirac2* = ",
						       print_time_string(elapsed_ms() - startLF),
			   			       " to find [",#LF[0],",",#LF[1],
						       "] verts and edges; Dirac eliminated ",
			  			        DTcount - startDTcount)
	      		   			   fi
		 			 in if (not revert_steve_flag) and (#LF = 0 or #LF[0]=0) {close 480}
		    			    then finish(x,lambda);
		    	 		    	 none_count +:=1; ()
		     			    else if every_lambda_deets_flag
			 		    	 then face_verbose := old_face_verbose;
						      time_verbose := old_time_verbose;
			       			      test_verbose :=old_test_verbose;
						      test_slightly_verbose := old_test_slightly_verbose
			  			  fi;
			  			  let answer =
						      if revert_steve_flag
			      	       		      then edge_offset:=1;
							   local_test_GEO_hash_steve(x, lambda, Lvd,
						      Uhash, fancy_tester)
			      	       		      else local(x, lambda, Lvd, LF, pol_hash, Uhash,
						      fancy_tester)
				       		      fi
			  			   in finish(x,lambda);
			  			      answerCards[k] := #answer;
			  			      if Uparamhash_flag
			       	    		      then for p in answer do Uparamhash.match(p) od
				    		      fi;
   		    	  			      current := elapsed_ms(); currentUhash := Uhash.size();
			       	    		      currentUcounter := unitary_test_counter.use_count();
				    		      currentCcounter := char_counter.use_count();
    		 	  			      xlambdatimes[k] := current - startxl;
    			if every_lambda_flag and FPP_report_flag
	      		then prints("  ",print_time_string(xlambdatimes[k]), " = time for (x,lambda) #",k,
			     " = (", xnums[k], ",",lambdas[k],")", test_string);
			     prints("    #LF = ", for L in LF do #L od, "; #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests for lambda = ", unitary_test_counter.use_count() - startUcounter,
				 ", time = ", print_time_string(unitaryTime - startUTime));
			     prints("     #char calcs for this lambda = ",
			     	char_counter.use_count() - startCcounter,
				 ", time = ",print_time_string(charTime - startCTime));
			     report_tested_cum("for (x,lam)=(#"+to_string(x.number)+","+to_string(lambda)+")",
			     			    "running totals");
			     prints("  ------------------")
			  fi {every_lambda_flag}
		    fi {not revert_steve_flag and #LF[0]=0 line 442}
		    fi {test_no_unitary line 424}
		    fi {tw.< line 404}
		    fi{twist(x)!=x line 375}
		 od{xlambdasW line 374}
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    then () = if FPP_report_flag
       then prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xnums[longest], ",",
	      lambdas[longest],")");
       	    prints(" Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count() - oldUcounter);
	    prints(" Time spent in char calcs = ",print_time_string(charTime - oldCtime),
	      ", number of char calcs = ",char_counter.use_count() - oldCcounter,
	      ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
       	    if mix_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params more-missed = ",
		    more_bad_hash.size(), ", #Params more-caught = ", more_good_hash.size{befmoreCount})
	    fi;
       	    {prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(), ", #hash_dumb = ", hash_dumbCounter.use_count(),
       	      	 	   ", #hash_def_dumb = ", hash_def_dumbCounter.use_count());}
       	    {prints("  #hash = ", hashCounter.use_count(), ", #hash2 = ", hash2Counter.use_count(),
	      	 	", #hash_one_level = ", hash_one_levelCounter.use_count(), ", #hash_bottom_layer = ",
			hash_bottom_layerCounter.use_count());}
	    report_tested("CUMULATIVE TOTALS");
       	    prints("Number of unitary params = ", sum(answerCards), ", time for is_finished = ",
	    print_time_string(is_finished_time), ", time for position = ",
	    print_time_string(position_time));
       	    prints("Number of FPP-unitary faces = ",Uhash.size(), ", number found on this run = ", Uhash.size() - oldUhash)
	fi {FPP_report_flag}
       in () fi {#xlambdasW = 0}
     in kill_for_big_uTime(); ()

set FPP_unitary_hash_general([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester,
    (KGBElt, ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash,(Param->bool)->[Param])
    local) = void:
    if #xs = 0
    then return ()
    fi;
    let G = xs[0].real_form
    in if is_compact(G)
       then for p in all_parameters_gamma(G,G.rho)
       	    do Uhash.match(p)
	    od;
            return ()
        fi;
    let () = if tilde_flag
    	      then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      fi
    then G = xs[0].real_form, revert_steve_flag = false
    then start = elapsed_ms(), zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then () = if FPP_report_flag
    	      then unitaryTime := 0; charTime := 0; FD12Time:=0; FD12bzTime:=0; red_count_time :=0
	      fi
    {then {xnums = for x in xs do x.number od, xtimes = null(#xs),}}
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then () = if FPP_report_flag
    	      then {clear_report_tested();} DTcount:=0; DBTcount:=0
	      fi
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = face_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_all_flag 
    	      then coh_ind_unip_all(G,Uhash) {this takes several seconds for F4_s}
	      elif coh_ind_most_flag
	      then coh_ind_unip_most(G,Uhash)
	      {elif coh_ind_few_flag
	      then coh_ind_unip_few(G,Uhash)}
	      fi
    then times = [int]: null(#xs)
    then red_count_times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
     then current = elapsed_ms()
    then oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
	 oldUtime = unitaryTime, oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count()
    then skipx = false
    then () = for x@j in xs
    	      do {xs}
	 test_next(x);
	 if twist(x) != x
	 then big_unitary_hash.finishx(x)
	 else
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter,
	     formerUtime = unitaryTime, formerCcounter = currentCcounter, formerCharTime = charTime,
	     former_red_count_time = red_count_time
	 then xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
	 then M = #FPP_lambdas(x)
	 then full_M = to_bitset([M])-1
	 then known_x = big_unitary_hash.x_known(G)
	 then () = skipx:= is_member_bitset(x.number,known_x)
	 then tw = first(for y in xtwists[1:] do is_member_bitset(y.number, known_x) od)
	      {there's a twist of x which is known}
	      {full_M = big_unitary_hash.xl_known(G)[y.number]}
	 then xtwist = if tw.>= and not skipx
	      	       then skipx := true;
		       	    xtwists[tw+1]
		       else x
		       fi
	 then twnum = last(for y in xs[:j] do y=xtwist od) 
	 then () = if{A} twnum.>=  {now xtwist is xs[twnum]}
	      	   then answerCards[j]:= answerCards[twnum]; {this is too low if xtwist wasn't calculated here}
	    	   	if Uparamhash_flag
	    	 	then for p in Uparamhash.list()
	              	     do if p.x = xtwists[tw]
		      	     	then Uparamhash.match(parameter(x,p.lambda,p.nu))
		    	 	fi
		      	     od
	    	 	 fi
		    fi{A}
	then () = if xtwist != x
	     	  then {prints("skipping x = ",x.number," for xtwist = ",xtwist.number);}
	    	       for p in Uhash.list()
	    	       do if p.x = xtwist
	       	       	  then Uhash.match(parameter(x, p.lambda, p.nu))
	       	    	  fi
	    	       od;
	    	       big_unitary_hash.finish(x, full_M); {mark as done all lambdas for x}
	   	       big_unitary_hash.finishx(x)
		   fi
	 then xcont_cand = contragredient(x)
	 then xcont = if xcont_cand != x and is_member_bitset(xcont_cand.number, known_x) and not skipx
	      	      then skipx := true;
		      	   xcont_cand
		      else x
		      fi
	 then contnum = last(for y in xs[:j] do y = xcont od)
	 then () = if{B} contnum.>= {now xcont is xs[contnum]}
	    	   then answerCards[j]:= answerCards[contnum];
		    	if Uparamhash_flag
		    	then for p in Uparamhash.list()
			     do if p.x = xcont
			    	then Uparamhash.match(contragredient(p))
			    	fi
			      od
			fi
		     fi{B}
	  then () = if xcont != x
		    then {prints("skipping x = ",x.number," for xcont = ",xcont.number);}
		       	 for p in Uhash.list()
	      	       	 do if p.x = xcont
		       	    then Uhash.match(contragredient(p))
		    	    fi
		       	 od;
		         big_unitary_hash.finish(x,full_M); {mark as done all lambdas for x}
		       	 big_unitary_hash.finishx(x)
		     fi
	  then () = if {C} skipx = false
	       	    then let lambdas = FPP_lambdas(x)
    	 	    	 then Ncases = #lambdas
	          	 then tempanswerCards = null(Ncases)
	 	  	 then templambdatimes = null(Ncases)
	 		 then () = if every_KGB_flag and FPP_report_flag
      	      	   	      then prints("     start KGBElt #", x.number, ", #lambdas = ",#lambdas,
		   	       " Uhash.size() = ", Uhash.size(), ", runtime = ",
			       	 print_time_string(elapsed_ms() - start), ", #uparams so far = ",
			       sum(for list in answerCards do sum(list) od) + sum(tempanswerCards));
		   		   prints("  ------------------")
        	   		   fi {every_KGB_flag}
			 then xW = x
	 		 then () = for lambda@index in lambdas
	      	   	      	   do if x=x_open(G)
		      	      	      then revert_steve_flag:=revert_steve_flag(x,lambda)
				      fi;
				      let lambdaW = lambda
				      then () = if R_packet_flag
				      	      	then let (xprime,lambdaprime) = up_Cayley_match_LKTs(x,lambda)
				      		then () = xW:=xprime
				      		then () = lambdaW:=lambdaprime
				     		in ()
				      		fi
				      then lambdacont = parameter(xW,lambdaW,0*lambdaW).lambda
				      then lcontnum = if lambdacont != lambdaW
				      	   	     then last(for kappa in lambdas[:index] do kappa = lambdacont od)
						     else -1
						     fi

		 		      then () = if every_lambda_flag and FPP_report_flag
      	      	   	     	      	      	then prints("     start #", index, " = (",x,",",lambda,
						"), Uhash.size() = ", Uhash.size(),
						", runtime = ", print_time_string(elapsed_ms() - start),
			      			", #uparams so far = ",sum(for list in answerCards do sum(list) od) + sum(tempanswerCards));
		   		   prints("  ------------------")
        	   		   fi {every_lambda_flag}
				      in if lcontnum.>=
				      	 then tempanswerCards[index]:= tempanswerCards[lcontnum];
		    	 		      for p in Uparamhash.list()
			 		      do if p.x = xW and p.lambda = lambdacont
					      	 then Uparamhash.match(contragredient(p))
			    		    	 fi
			 		       od;
		    	 	               big_unitary_hash.finish(xW,to_bitset([index]));
					       {mark as done this lambda for xW}
			            	       for p in Uhash.list()
	      	       		    	       do if p.x = xW and p.lambda = lambdacont
		       	  	       	       	  then Uhash.match(contragredient(p))
		    	  	       		  fi
		       		    	       od
					  else let lamthlam = ((1+xW.involution)*lambdaW).numer
		      		      	       then (Lvd, Perm2{, mapAct}) = LPm_table.LPm_entry(G,xW.involution,lamthlam)
		      		      	       then  startlambda = elapsed_ms(), startUhash = Uhash.size(),
					       	     startUcounter = unitary_test_counter.use_count(),
						     startUtime = unitaryTime, startCcounter =
						     char_counter.use_count(), startCtime = charTime
				      	       then startLF = elapsed_ms()
		 			       in if test_no_unitary(x,lambda,Lvd)
		   				  then {none_count +:= 1;} {prints("SKIPPED ",x,",",lambda);} ()
		    			       else adjust_Dirac_flags(xW);
					       	    let startDTcount = DTcount
 		      		      	       then LF = [[FaceVertsIndex]]:
					       	         if revert_steve_flag
					       	       	 then [[]]
					       		 elif by_zero_flag
		      	      	      	      	       	 then localFD_1Dirac2_by_zero(xW, lambdaW, Lvd, Perm2)
			   				 else localFD_1Dirac2(xW, lambdaW, Lvd, Perm2)
			   				 fi {by_zero_flag}
				      	       then () = if every_lambda_deets_flag and FPP_report_flag and
					       	       	    not revert_steve_flag
    	      	      	              	       	       	 then prints("time for localFD_1Dirac2* = ",
				      	       	    	      print_time_string(elapsed_ms() - startLF),
			   			    	      " to find [",#LF[0],",",#LF[1],
							      "] verts and edges; Dirac eliminated ",DTcount - startDTcount)
	      		   			    	 fi
			 		   in if (not revert_steve_flag) and (#LF = 0 or #LF[0] = 0)
					      then none_count +:=1;
					      	   finish(x, lambda); []
			    		      else if every_lambda_deets_flag
			       	 	      	   then face_verbose := old_face_verbose;
						   time_verbose := old_time_verbose;
				    	 	   test_verbose :=old_test_verbose;
						   test_slightly_verbose := old_test_slightly_verbose
				 		   fi;
				 		   let answer =
						       if revert_steve_flag
			      	       		       then edge_offset:=1;
							    local_test_GEO_hash_steve(xW, lambdaW, Lvd,
								Uhash, fancy_tester)
						       else local(xW, lambdaW, Lvd, LF, pol_hash, Uhash,
								fancy_tester)
						       fi
			  	 		   then () = tempanswerCards[index] := #answer
				 		   then () = if every_lambda_deets_flag
			    	      	   	   	     then face_verbose := old_face_verbose; time_verbose := old_time_verbose;
				 	   		     	  test_verbose := old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
				 	   		     fi
 			 	 		   then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 		   in if every_lambda_flag and FPP_report_flag
				    		      then prints("  ",print_time_string(templambdatimes[index]),
			   	    	 	      	   " = time for (x,lambda) = (", xW.number, ",",index," = ",
							   lambdaW, ")", test_string);
				         		   prints("    #LF = ", for L in LF do #L od,
							   ", #unitary params = ", tempanswerCards[index],
			     	                	   ", #new unitary = ", Uhash.size() - startUhash,
							   ", #tests for this lambda = ",
							   unitary_test_counter.use_count() - startUcounter,
							   ", unitary time for lambda = ",
							   print_time_string(unitaryTime -startUtime));
					 		   prints("  char calcs for lambda = ",
						   	   char_counter.use_count() - startCcounter,
					 	 	   " char time = ", print_time_string(charTime - startCtime));
				  			   report_tested(
			"cumulative totals after (x,lam)=(#"+to_string(x.number)+","+to_string(lambda)+")");
					 		   prints("  ------------------")
				    		       fi{every_lambda_flag}
			      			 fi{#LF[0] = 0}
					      fi {test_no_unitary}
					    fi{lcontnum.>=}
                   		od{lambda}
				{would be easy enough to get [Param] for each (x,lambda), but for now just
				put unitary reps in Uhash}
{this is a bad idea because don't have here a list of all final unitary faces at (x,lambda)}
{	  then xtwistsNew = for y in xtwists
			    do if not is_member_bitset(y.number, known_x)
			       then [y]
			       else []
			       fi
			    od.## {should always include x}
			       			   then () = for q in answer
				       	 	   	     do for y in xtwistsNew
				     	    		     	do let r = parameter(y, q.lambda, q.nu)
				     	       		     	   then () = if Uparamhash_flag
							     	       	     then Uparamhash.match(r)
									     fi
							           in for t in monomials(finalize(r))
								      do Uhash.match(t)
								      od
								od {let r}
							     od {for y}
						   then () = for y in xtwistsNew
					   	    	     do finish(y,lambda)
					   		     od
}

           then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	   	     red_count_times[j] := red_count_time - former_red_count_time;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     currentCcounter := char_counter.use_count(); answerCards[j]:= tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag and FPP_report_flag
                     then  prints("     time for KGBElt ",x.number," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for #", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
			  prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary faces = ",
			     currentUhash - formerUhash, ", #tests for this x = ",
		     	     currentUcounter-formerUcounter,", time = ", print_time_string(unitaryTime-formerUtime));
       	    		  prints("Time spent in char calcs = ",print_time_string(charTime-formerCharTime),
       	      		  	 ", number of char calcs = ", char_counter.use_count() - formerCcounter,
				 " time spent in red_count = ",  print_time_string(red_count_times[j]));
			 report_tested_cum("for x=#"+to_string(x.number),"running totals")
                     fi
	   then () = big_unitary_hash.finish(x, full_M) {mark as done all lambdas for x}
	   in big_unitary_hash.finishx(x) {mark as done all lambdas for x}
	   fi {C}
	   in ()
	 fi
         od {xs}
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    then () = if FPP_report_flag
       then prints("----------------");
       	    prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xs[longest].number);
       	    prints("Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count() - oldUcounter);
       	    prints("Time spent in char calcs = ",print_time_string(charTime),
       	      ", number of char calcs = ", char_counter.use_count() - oldCcounter,
	      ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
	    if mix_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params more-missed = ",
		    more_bad_hash.size(), ", #Params more-caught = ",more_good_hash.size(){befmoreCount})
	    fi;
       	    {prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb = ", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb = ", hash_def_dumbCounter.use_count());
       	    prints("  #hash = ", hashCounter.use_count(),
	      ", #hash2 = ", hash2Counter.use_count(),
	      ", #hash_one_level = ", hash_one_levelCounter.use_count(),
              ", #hash_bottom_layer = ", hash_bottom_layerCounter.use_count());}
       	    prints("Number of unitary params = ", sum((for list in answerCards do sum(list) od)),
	    		   ", time for is_finished = ", print_time_string(is_finished_time),
			   ", time for position = ", print_time_string(position_time));
      	    prints("Number of known FPP-unitary faces = ",Uhash.size(),
       	      ", number found on this run = ", Uhash.size() - oldUhash);
	    report_tested("CUMULATIVE TOTALS")
      fi {FPP_report_flag}
   in kill_for_big_uTime(); ()

set FPP_unitary_hash_general(RealForm G,Param_hash Uhash, (Param->bool) fancy_tester,
    (KGBElt,ratvec, LocalVertexData, [[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)->[Param])
    local) = void:
    if is_compact(G)
    then for p in all_parameters_gamma(G,G.rho)
    do Uhash.match(p) od
    else
    FPP_unitary_hash_general(KGB(G), Uhash, fancy_tester, local)
    fi
{STEVE HERE}

{uses LPm_table to keep track of local face info}
set FPP_unitary_hash_steve([(KGBElt,ratvec)] xlambdas, Param_hash Uhash,
    (Param->bool) fancy_tester) = void:
    if #xlambdas = 0 then return () fi;
    let (x,) = xlambdas[0]
    then G = x.real_form
    in if is_compact(G)
       then for p in all_parameters_gamma(G,G.rho)
       	    do Uhash.match(p)
	    od;
            return ()
        fi;
    let xlambdasW = if R_packet_flag
    	      	    then for (x,lambda) in xlambdas
	      	         do up_Cayley_match_LKTs(x,lambda)
		   	 od
		    else xlambdas
	      	    fi
    then () = if #xlambdasW = 0 then return ()
    	      else let (x,) = xlambdasW[0]
    then start = elapsed_ms(),  zeroNu = null(G.rank)/1
    then () = if FPP_report_flag
    	      then unitaryTime := 0; charTime := 0; FD12Time:=0; FD12bzTime:=0; red_count_time :=0;
	      	   branch_builtin_time :=0; branch_script_time := 0
	      fi
    then () = if FPP_report_flag
    	      then {clear_report_tested();} DTcount:=0; DBTcount:=0; report_steve_clear()
	      fi
    then xnums = for (x,) in xlambdasW do x.number od
    then lambdas = for (,lambda) in xlambdasW do lambda od
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then startLPmss = elapsed_ms()
    then LPmss = for (x,lambda) in xlambdasW
    	       	 do LPm_table.LPm_entry(G,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
              	 od
    then () = if every_lambda_deets_flag and FPP_report_flag
    	      then prints("time for LPmss = ",print_time_string(elapsed_ms() - startLPmss))
	      fi
    then () = face_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_all_flag 
    	      then coh_ind_unip_all(G,Uhash) {this takes several seconds for F4_s}
	      elif coh_ind_most_flag
	      then coh_ind_unip_most(G,Uhash)
	      {elif coh_ind_few_flag
then coh_ind_unip_few(G,Uhash)}
	      fi
    then xlambdatimes = [int]: null(#xlambdasW)
    then answerCards = [int]: null(#xlambdasW) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    then current = elapsed_ms(), oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
         oldUtime = unitaryTime, currentUtime = unitaryTime, oldCtime = charTime, currentCtime = charTime,
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
		   oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count()
    {then () = if every_lambda_deets_flag
    	      then prints("time up to main loop = ",print_time_string(elapsed_ms() - start))
	      fi}
    then () = for (x,lambda)@k in xlambdasW
    	      do {xlambdasW}
		test_next(x);
	      	if twist(x) != x
		then big_unitary_hash.finishx(x)
		elif is_finished(x,lambda) {this includes possibility that x is finished}
		then if FPP_report_flag
		     then prints("Already computed (",x,",",lambda,")")
		     fi;
		     ()
		else let xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
		     then tw = first(for y in xtwists[1:] do is_finished(y, lambda) od)
		     then twnum = if tw.>=
		     	  	   then last(for (y,tau) in xlambdasW[k:]
				   	     do y=xtwists[tw+1] and tau = lambda
					     od)
				   else -1
				   fi
		     then () = if twnum.>=
		     	       then answerCards[k]:= answerCards[twnum];
			       {too low if xtwist wasn't calculated here}
			       	    if Uparamhash_flag
	    	 	       	    then for p in Uparamhash.list()
	              	       	    	 do if p.x = xtwists[tw+1] and p.lambda = lambda
		      	     	       	    then Uparamhash.match(parameter(x,lambda,p.nu))
		    	 	       	    fi
		      	     	    	 od
			       	     fi
			  	 fi
		     then () = if tw.>=
		     	       then for p in Uhash.list()
			       	    do if p.x = xtwists[tw+1] and p.lambda = lambda
				       then Uhash.match(parameter(x,lambda,p.nu))
				       fi
				    od;
				    if FPP_report_flag and every_lambda_flag
		   		    then prints("Matching (",x,",",lambda,") with previously computed")
				    fi;
				    finish(x,lambda)
				fi
		     then (xcont,lambdacont) = contragredient(x,lambda)
		     then () = if tw.< and is_finished(xcont,lambdacont)
			       then for p in Uhash.list()
			       	    do if p.x = xcont and p.lambda = lambdacont
				       then Uhash.match(contragredient(p))
				       fi
				    od;
				    if FPP_report_flag and every_lambda_flag
		   		    then prints("Contragredient of (",x,",",lambda,") was previously computed")
				    fi;
				    tw:=0;
				    finish(x,lambda)
			       fi
	      	     in if tw.< {still have work to do}
		     	then let startxl = elapsed_ms(), startUhash = Uhash.size(),
		     		   startUcounter = unitary_test_counter.use_count(),
				   startCcounter = char_counter.use_count(),
				   startUTime = unitaryTime, startCTime = charTime, theta = x.involution,
				   startminxl = good_hash.size(), startmorexl = more_good_hash.size()
		 then p0 = parameter(x,lambda,zeroNu)
		 {then () = prints("time before LPmss[",k,"] = ",print_time_string(elapsed_ms() - start))}
		 then (Lvd, Perm2) = LPmss[k]
		 then () = if every_lambda_flag and FPP_report_flag
      	      	   	      then prints("     start #", k, " = (",x,",",lambda,"), Uhash.size() = ",
			      Uhash.size(), ", runtime = ", print_time_string(elapsed_ms() - start),
			      ", #uparams so far = ",sum(answerCards));
		   		   prints("  ------------------")
        	   	   fi {every_lambda_flag}
		 then startLF = elapsed_ms()
		 then TNU = test_no_unitary(x,lambda,Lvd)
		 then UParams = [Param]:
		      if TNU
		      then []
		      else local_test_GEO_hash_steve(x, lambda, Lvd, Uhash, fancy_tester)
		      fi
		 then () = finish(x,lambda)
		 then () = if #UParams = 0
		      	   then none_count +:=1
			   fi
		 then () = if every_lambda_deets_flag and not TNU
			   then face_verbose := old_face_verbose; time_verbose := old_time_verbose;
			       test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			   fi
		 then () = answerCards[k] := #UParams
		 then () = if Uparamhash_flag
			   then for p in UParams do Uparamhash.match(p) od
			   fi
   		 then () = current := elapsed_ms(); currentUhash := Uhash.size();
			       	    currentUcounter := unitary_test_counter.use_count();
				    currentCcounter := char_counter.use_count()
    		 then () = xlambdatimes[k] := current - startxl
    		 in if every_lambda_flag and FPP_report_flag and not TNU
	      	    then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) #",k, " = (", xnums[k], ",",lambdas[k],")", test_string);
			 prints("   #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests for lambda = ", unitary_test_counter.use_count() - startUcounter,
				 ", time = ", print_time_string(unitaryTime - startUTime));
			 prints("     #char calcs for this lambda = ",char_counter.use_count() - startCcounter,
				 ", time = ",print_time_string(charTime - startCTime));
			 prints("Time in min_bottom_factors = ",print_time_string(mbfTime),
				 ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
			 prints("     #Params min-caught for this lambda = ", good_hash.size() - startminxl,
				 {", #Params min-missed = ", bad_hash.size()}
				 ", #min-caught total = ", good_hash.size());
 			 prints("Time in bottom_factors = ", print_time_string(bfTime),
				 ", time in bottom_elim_factors_more = ", print_time_string(befmoreTime),
				 ", more_shift_level = ", if bl_step_flag then
		    		       	     bl_step_count*bl_step_size else more_shift_level fi);
			 prints("     #Params more-caught for this lambda = ",
				 more_good_hash.size() - startmorexl, {befmoreCount}
      		 		 {", #Params more-missed = ", more_bad_hash.size());}
				 ", #more-caught total = ",more_good_hash.size());
			 report_tested_cum("for (x,lam)=(#"+to_string(x.number)+","+to_string(lambda)+")",
			 			"running totals");
			 prints("  ------------------")
		      fi {every_lambda_flag}
		    fi{tw.>=}
		    fi {twist(x)!=x}
		 od{xlambdasW}
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    then () = if FPP_report_flag
       then prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xnums[longest], ",",
	      lambdas[longest],")");
       	    prints(" Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count() - oldUcounter);
	    prints(" Time spent in char calcs = ",print_time_string(charTime - oldCtime),
	      ", number of char calcs = ",char_counter.use_count() - oldCcounter,
	      ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
       	    if mix_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params more-missed = ",
		    more_bad_hash.size(), ", #Params more-caught = ", more_good_hash.size{befmoreCount})
	    fi;
       	    {prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(), ", #hash_dumb = ", hash_dumbCounter.use_count(),
       	      	 	   ", #hash_def_dumb = ", hash_def_dumbCounter.use_count());
       	    prints("  #hash = ", hashCounter.use_count(), ", #hash2 = ", hash2Counter.use_count(),
	      	 	", #hash_one_level = ", hash_one_levelCounter.use_count(), ", #hash_bottom_layer = ",
			hash_bottom_layerCounter.use_count());}
	    report_tested("CUMULATIVE TOTALS");
	    report_steve_graph();
       	    prints("Number of unitary params = ", sum(answerCards), ", time for is_finished = ",
	    print_time_string(is_finished_time), ", time for position = ",
	    print_time_string(position_time));
       	    prints("Number of FPP-unitary faces = ",Uhash.size(), ", number found on this run = ", Uhash.size() - oldUhash)
	fi {FPP_report_flag}
       in () fi {#xlambdasW = 0}
     in kill_for_big_uTime(); ()

set FPP_unitary_hash_steve([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    if #xs = 0
    then return ()
    fi;
    let G = xs[0].real_form
    in if is_compact(G)
       then for p in all_parameters_gamma(G,G.rho)
       	    do Uhash.match(p)
	    od;
            return ()
        fi;
    let () = if tilde_flag
    	      then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      fi
    then G = xs[0].real_form
    then start = elapsed_ms(), zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then () = if FPP_report_flag
    	      then unitaryTime := 0; charTime := 0; FD12Time:=0; FD12bzTime:=0; red_count_time :=0
	      fi
    then () = if FPP_report_flag
    	      then {clear_report_tested();} DTcount:=0; DBTcount:=0; report_steve_clear()
	      fi
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = face_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_all_flag 
    	      then coh_ind_unip_all(G,Uhash) {this takes several seconds for F4_s}
	      elif coh_ind_most_flag
	      then coh_ind_unip_most(G,Uhash)
	      {elif coh_ind_few_flag
	      then coh_ind_unip_few(G,Uhash)}
	      fi
    then times = [int]: null(#xs)
    then red_count_times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
     then current = elapsed_ms()
    then oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
	 oldUtime = unitaryTime, oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count()
    then skipx = false
    then () = for x@j in xs
    	      do {xs}
	 test_next(x);
	 if twist(x) != x
	 then big_unitary_hash.finishx(x)
	 else
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter,
	     formerUtime = unitaryTime, formerCcounter = currentCcounter, formerCharTime = charTime,
	     former_red_count_time = red_count_time,
	     startmorex = more_good_hash.size(), startminbadx = bad_hash.size(), startminx = good_hash.size()
	 then xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
	 then M = #FPP_lambdas(x)
	 then full_M = to_bitset([M])-1
	 then known_x = big_unitary_hash.x_known(G)
	 then () = skipx:= is_member_bitset(x.number,known_x)
	 then tw = first(for y in xtwists[1:] do is_member_bitset(y.number, known_x) od) {there's a twist of x which is known}
			 {full_M = big_unitary_hash.xl_known(G)[y.number]}
	 then xtwist = if tw.>= and not skipx
	      	       then skipx := true;
		       	    xtwists[tw+1]
		       else x
		       fi
	 then twnum = last(for y in xs[:j] do y=xtwist od) 
	 then () = if{A} twnum.>=  {now xtwist is xs[twnum]}
	      	   then answerCards[j]:= answerCards[twnum]; {this is too low if xtwist wasn't calculated here}
	    	   	if Uparamhash_flag
	    	 	then for p in Uparamhash.list()
	              	     do if p.x = xtwists[tw]
		      	     	then Uparamhash.match(parameter(x,p.lambda,p.nu))
		    	 	fi
		      	     od
	    	 	 fi
		    fi{A}
	then () = if xtwist != x
	     	  then {prints("skipping x = ",x.number," for xtwist = ",xtwist.number);}
	    	       for p in Uhash.list()
	    	       do if p.x = xtwist
	       	       	  then Uhash.match(parameter(x, p.lambda, p.nu))
	       	    	  fi
	    	       od;
	    	       big_unitary_hash.finish(x, full_M); {mark as done all lambdas for x}
	   	       big_unitary_hash.finishx(x)
		   fi
	 then xcont_cand = contragredient(x)
	 then xcont = if xcont_cand != x and is_member_bitset(xcont_cand.number, known_x) and not skipx
	      	      then skipx := true;
		      	   xcont_cand
		      else x
		      fi
	 then contnum = last(for y in xs[:j] do y = xcont od)
	 then () = if{B} contnum.>= {now xcont is xs[contnum]}
	    	   then answerCards[j]:= answerCards[contnum];
		    	if Uparamhash_flag
		    	then for p in Uparamhash.list()
			     do if p.x = xcont
			    	then Uparamhash.match(contragredient(p))
			    	fi
			      od
			fi
		     fi{B}
	  then () = if xcont != x
		    then {prints("skipping x = ",x.number," for xcont = ",xcont.number);}
		       	 for p in Uhash.list()
	      	       	 do if p.x = xcont
		       	    then Uhash.match(contragredient(p))
		    	    fi
		       	 od;
		         big_unitary_hash.finish(x,full_M); {mark as done all lambdas for x}
		       	 big_unitary_hash.finishx(x)
		     fi
	  then () = if {C} skipx = false
	       	    then let lambdas = FPP_lambdas(x)
    	 	    	 then Ncases = #lambdas
	          	 then tempanswerCards = null(Ncases)
	 	  	 then templambdatimes = null(Ncases)
	 		 then () = if every_KGB_flag and FPP_report_flag
      	      	   	      then prints("     start KGBElt #", x.number, ", #lambdas = ",#lambdas,
		   	       " Uhash.size() = ", Uhash.size(), ", runtime = ",
			       	 print_time_string(elapsed_ms() - start), ", #uparams so far = ",
			       sum(for list in answerCards do sum(list) od) + sum(tempanswerCards));
		   		   prints("  ------------------")
        	   		   fi {every_KGB_flag}
			 then xW = x
	 		 then () = for lambda@index in lambdas
	      	   	      	   do let lambdaW = lambda
				      then () = if R_packet_flag
				      	      	then let (xprime,lambdaprime) = up_Cayley_match_LKTs(x,lambda)
				      		then () = xW:=xprime
				      		then () = lambdaW:=lambdaprime
				     		in ()
				      		fi
				      then lambdacont = parameter(xW,lambdaW,0*lambdaW).lambda
				      then lcontnum = if lambdacont != lambdaW
				      	   	     then last(for kappa in lambdas[:index] do kappa = lambdacont od)
						     else -1
						     fi

		 		      then () = if every_lambda_flag and FPP_report_flag
      	      	   	     	      	      	then prints("     start #", index, " = (",x,",",lambda,
						"), Uhash.size() = ", Uhash.size(),
						", runtime = ", print_time_string(elapsed_ms() - start),
			      			", #uparams so far = ",sum(for list in answerCards do sum(list) od) + sum(tempanswerCards));
		   		   prints("  ------------------")
        	   		   fi {every_lambda_flag}
				      in if lcontnum.>=
				      	 then tempanswerCards[index]:= tempanswerCards[lcontnum];
		    	 		      for p in Uparamhash.list()
			 		      do if p.x = xW and p.lambda = lambdacont
					      	 then Uparamhash.match(contragredient(p))
			    		    	 fi
			 		       od;
		    	 	               big_unitary_hash.finish(xW,to_bitset([index]));
					       {mark as done this lambda for xW}
			            	       for p in Uhash.list()
	      	       		    	       do if p.x = xW and p.lambda = lambdacont
		       	  	       	       	  then Uhash.match(contragredient(p))
		    	  	       		  fi
		       		    	       od
					  else let lamthlam = ((1+xW.involution)*lambdaW).numer
		      		      	       then (Lvd, Perm2) = LPm_table.LPm_entry(G,xW.involution,lamthlam)
		      		      	       then  startlambda = elapsed_ms(), startUhash = Uhash.size(),
					       	     startUcounter = unitary_test_counter.use_count(),
						     startUtime = unitaryTime, startCcounter =
						     char_counter.use_count(), startCtime = charTime
				      	       then startLF = elapsed_ms()
		 			       then TNU = test_no_unitary(x,lambda,Lvd)
					       then UParams = [Param]:
					       	    if TNU
						    then []
						    else local_test_GEO_hash_steve(x, lambda, Lvd, Uhash, fancy_tester)
						    fi
					       then () = finish(x,lambda)
					       then () = if #UParams = 0
		      	   		       	       	 then none_count +:=1
			   				 fi
		 			       then () = if every_lambda_deets_flag and not TNU
			   		       	       	 then face_verbose := old_face_verbose; time_verbose := old_time_verbose;
			       test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			       		    		 fi
						then () = tempanswerCards[index]:=#UParams
		 				then () = if Uparamhash_flag
			   			     	  then for p in UParams do Uparamhash.match(p) od
			   				  fi
 			 	 		then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 		in if every_lambda_flag and FPP_report_flag and not TNU
				    		      then prints("  ",print_time_string(templambdatimes[index]),
			   	    	 	      	   " = time for (x,lambda) = (", xW.number, ",",index," = ",
							   lambdaW, ")", test_string);
				         		   prints("     #unitary params = ", tempanswerCards[index],
			     	                	   ", #new unitary = ", Uhash.size() - startUhash,
							   ", #tests for this lambda = ",
							   unitary_test_counter.use_count() - startUcounter,
							   ", unitary time for lambda = ",
							   print_time_string(unitaryTime -startUtime));
					 		   prints("  char calcs for lambda = ",
						   	   char_counter.use_count() - startCcounter,
					 	 	   " char time = ", print_time_string(charTime - startCtime));
				  			   report_tested(
				"cumulative totals after (x,lam)=(#"+to_string(x.number)+","+to_string(lambda)+")");
					 		   prints("  ------------------")
				    		       fi{every_lambda_flag}
					    fi{lcontnum.>=}
                   		od{lambda}
				{would be easy enough to get [Param] for each (x,lambda), but for now just
				put unitary reps in Uhash}
           then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	   	     red_count_times[j] := red_count_time - former_red_count_time;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     currentCcounter := char_counter.use_count(); answerCards[j]:= tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag and FPP_report_flag
                     then  prints("     time for KGBElt ",x.number," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for #", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
       	    		  prints("Time in min_bottom_factors = ",print_time_string(mbfTime),
	    		  	 ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
	    		  prints("     #Params min-caught for this x = ", good_hash.size() - startminx,
	    		  {", #Params min-missed for this x = ", bad_hash.size() - startminbadx}
	    		  ", #min-caught total = ",good_hash.size());
 	    		  prints("Time in bottom_factors = ", print_time_string(bfTime),
	    		  ", time in bottom_elim_factors_more = ", print_time_string(befmoreTime),
	    		  ", more_shift_level = ", if bl_step_flag then bl_step_count*bl_step_size else more_shift_level fi);
	    		  prints("     #Params more-caught for this x = ", more_good_hash.size() - startmorex,
      	    		  {", #Params more-missed for this x = ", more_bad_hash.size() - startmorebadx}
	    		  ", #more-caught total = ", more_good_hash.size());
			  prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary faces = ",
			     currentUhash - formerUhash, ", #tests for this x = ",
		     	     currentUcounter-formerUcounter,", time = ", print_time_string(unitaryTime-formerUtime));
       	    		  prints("Time spent in char calcs = ",print_time_string(charTime-formerCharTime),
       	      		  	 ", number of char calcs = ", char_counter.use_count() - formerCcounter,
				 " time spent in red_count = ",  print_time_string(red_count_times[j]));
			 report_tested_cum("for x=#"+to_string(x.number),"running totals");
			 report_steve_graph()
                     fi
	   then () = big_unitary_hash.finish(x, full_M) {mark as done all lambdas for x}
	   in big_unitary_hash.finishx(x) {mark as done all lambdas for x}
	   fi {C}
	   in ()
	 fi
         od {xs}
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    then () = if FPP_report_flag
       then prints("----------------");
       	    prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xs[longest].number);
       	    prints("Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count() - oldUcounter);
       	    prints("Time spent in char calcs = ",print_time_string(charTime),
       	      ", number of char calcs = ", char_counter.use_count() - oldCcounter,
	      ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
	    if mix_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params more-missed = ",
		    more_bad_hash.size(), ", #Params more-caught = ",more_good_hash.size(){befmoreCount})
	    fi;
       	    {prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb = ", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb = ", hash_def_dumbCounter.use_count());
       	    prints("  #hash = ", hashCounter.use_count(),
	      ", #hash2 = ", hash2Counter.use_count(),
	      ", #hash_one_level = ", hash_one_levelCounter.use_count(),
              ", #hash_bottom_layer = ", hash_bottom_layerCounter.use_count());}
       	    prints("Number of unitary params = ", sum((for list in answerCards do sum(list) od)),
	    		   ", time for is_finished = ", print_time_string(is_finished_time),
			   ", time for position = ", print_time_string(position_time));
      	    prints("Number of known FPP-unitary faces = ",Uhash.size(),
       	      ", number found on this run = ", Uhash.size() - oldUhash);
	    report_tested("CUMULATIVE TOTALS");
	    report_steve_graph()
      fi {FPP_report_flag}
   in kill_for_big_uTime(); ()

set FPP_unitary_hash_steve(RealForm G,Param_hash Uhash, (Param->bool) fancy_tester) = void:
    if is_compact(G)
    then for p in all_parameters_gamma(G,G.rho)
    do Uhash.match(p) od
    else
    FPP_unitary_hash_steve(KGB(G), Uhash, fancy_tester)
    fi
{END STEVE HERE}

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash,
    (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester,local_test_GEO_hash_real_dumb@(
    KGBElt,ratvec,LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_real_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form),
    fancy_tester)

set FPP_unitary_hash_real_dumb([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash_real_dumb@(
    KGBElt,ratvec,LocalVertexData,[[FaceVertsIndex]],KTypePol_hash,Param_hash,(Param->bool)))

set FPP_unitary_hash_real_dumb([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_real_dumb(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_real_dumb(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_real_dumb(KGB(G), fancy_tester)

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) =
    void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash_def_dumb@(
    KGBElt,ratvec,{VertexData,} LocalVertexData,[[FaceVertsIndex]], KTypePol_hash, Param_hash,
    (Param->bool)))

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_def_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form),
    fancy_tester)

set FPP_unitary_hash_def_dumb([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    let () = def_flag:=true then () = real_flag:=false in
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash_def_dumb@(KGBElt,ratvec,
    LocalVertexData, [[FaceVertsIndex]], KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_def_dumb([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_def_dumb(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_def_dumb(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_def_dumb(KGB(G), fancy_tester)

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    let () = def_flag:=false then () = real_flag:=false in
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash_dumb@(
    KGBElt,ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form),
    fancy_tester)

set FPP_unitary_hash_dumb([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    let () = def_flag:=false then () = real_flag:=false in
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash_dumb@(
    KGBElt,ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_dumb([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_dumb(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_dumb(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_dumb(KGB(G), fancy_tester)

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash@(
    KGBElt,ratvec, LocalVertexData, [[FaceVertsIndex]], KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form), fancy_tester)

set FPP_unitary_hash([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash@(
    KGBElt,ratvec,{VertexData,} LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash([KGBElt] xs,(Param->bool) fancy_tester) = void:
    FPP_unitary_hash(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash(KGB(G), big_unitary_hash.uhash(G), fancy_tester)

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash2@(
   KGBElt,ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash2(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form), fancy_tester)

set FPP_unitary_hash2([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash2@(
    KGBElt,ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash2([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash2(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash2(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash2(KGB(G), fancy_tester)

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) =
    void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash_one_level@(
    KGBElt,ratvec,LocalVertexData,[[FaceVertsIndex]], KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_one_level(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form),
    fancy_tester)

set FPP_unitary_hash_one_level([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash_one_level@(
    KGBElt,ratvec, LocalVertexData,[[FaceVertsIndex]], KTypePol_hash, Param_hash,
    (Param->bool)))

set FPP_unitary_hash_one_level([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_one_level(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_one_level(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_one_level(KGB(G), fancy_tester)

set FPP_unitary_hash_steve([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_steve(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form), fancy_tester)

set FPP_unitary_hash_steve([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_steve(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_steve(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_steve(G, big_unitary_hash.uhash(G), fancy_tester)


set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas, Param_hash UhashG, (Param->bool)
fancy_tester) = void:
    if #xlambdas = 0 then return () fi;
    let (x,) = xlambdas[0]
    then G = x.real_form
    then most_more = most_more(G)
    in if is_compact(G)
       then for p in all_parameters_gamma(G,G.rho)
       	    do UhashG.match(p)
	    od;
            return ()
        fi;
	{if x =x_open(x.real_form) then return FPP_unitary_hash_steve(xlambdas, UhashG, fancy_tester) fi;}
    let disconn_flag = components_rank(G) > 0
    then (Gsc,M) = if disconn_flag
    	      	   then derived_cover_real_form_info(G)
	      	   else (G,id_mat(G.rank))
	      	   fi
    then xlambdas_sc = if disconn_flag
    	      	       then for (x,lambda) in xlambdas
		       	    do let (xt,lambdat) = (inverse_embed_KGB2(x, Gsc, M), M*lambda)
			       {then () = if is_finished(x,lambda)
			       	       	 then finish(xt,lambdat)
					 fi}
			       in (xt,lambdat)
			    od
		       else xlambdas
	      	       fi
    then () = if disconn_flag
    	      then for (x,lambda) in list_all_finished(G)
	      	   do let (xt,lambdat) = (inverse_embed_KGB2(x, Gsc, M), M*lambda)
	      	      in finish(xt,lambda)
	      	   od
	       fi
    then Uhash = if disconn_flag {this will hold the unitary reps on Gsc}
    	      	 then big_unitary_hash.uhash(Gsc) {make_Param_hash()}
		 {this is for unitary reps of Gsc that factor to G}
		 else UhashG
		 fi
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then () = if FPP_report_flag
    	      then {clear_report_tested();} DTcount:=0; DBTcount:=0
	      fi
    then start = elapsed_ms()
    then () = if FPP_report_flag
    	      then unitaryTime := 0; charTime := 0; FD12Time:=0; FD12bzTime:=0; red_count_time :=0
	      fi
    then xnums = for (x,) in xlambdas do let (,m) = %x in m od
    {then lambdas = for (,lambda) in xlambdas do lambda od}
    then LPmss = for (x,lambda) in xlambdas_sc
    	       	 do LPm_table.LPm_entry(Gsc,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
		 od
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = face_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,UhashG)
	      fi
    then () = if coh_ind_all_flag
    	      then coh_ind_unip_all(G,UhashG)
	      elif coh_ind_most_flag
	      then coh_ind_unip_most(G,Uhash)
	      {elif coh_ind_few_flag
	      then coh_ind_unip_few(G,Uhash)}
	      fi
    then () = if disconn_flag
    	      then for j:UhashG.size()
	      	   do for psc in sc_lifts2(UhashG.index(j), Gsc, M)
		      do Uhash.match(psc)
		      od
		   od{; prints("# unitary faces on Gsc = ",Uhash.size())}
	      fi
    then xlambdatimes = [int]: null(#xlambdas)
    then answerCards = [int]: null(#xlambdas) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    {then () = adjust_global_top(Gsc)}
    {then () = if by_zero_flag
    	      then global_faces_by_zero := low_FPP_faces_by_zero(global_faces)
	      fi}
    then current = elapsed_ms(), oldUhash = UhashG.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
	 currentUtime = unitaryTime, currentCtime = charTime,
	 oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count()
		   {start_min_L_bottom_factors = minBottomData.min_L_bottom_factors_time()}
    then () = for (x,lambda)@k in xlambdas
    	      do {xlambdas}
		test_next(x);
		if twist(x) != x {start 1545}
		 then big_unitary_hash.finishx(x)
		 elif is_finished(x,lambda) {this includes possibility that x is finished}
		 then if FPP_report_flag
		      then prints("Already computed (",x,",",lambda,")")
		      fi
		 else let xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
		      then tw = first(for y in xtwists[1:] do is_finished(y, lambda) od)
		      then twnum = if tw.>=
		     	  	   then last(for (y,tau) in xlambdas[k:]
				       	    do y=xtwists[tw+1] and tau = lambda
					    od)
				    else -1
				    fi
		      then () = if twnum.>=
		     	       	then answerCards[k]:= answerCards[twnum];
			       	{too low if xtwist wasn't calculated here}
			       	    if Uparamhash_flag
	    	 	       	    then for p in Uparamhash.list()
	              	       	    	 do if p.x = xtwists[tw+1] and p.lambda = lambda
		      	     	       	    then Uparamhash.match(parameter(x,lambda,p.nu))
		    	 	       	    fi
		      	     	    	 od
			       	     fi
			  	 fi
		      then () = if tw.>=
		     	       	then for p in Uhash.list()
			       	     do if p.x = xtwists[tw+1] and p.lambda = lambda
				       	then Uhash.match(parameter(x,lambda,p.nu))
				       	fi
				     od;
				     if FPP_report_flag and every_lambda_flag
		   		     then prints("Matching (",x,",",lambda,") with previously computed")
				     fi;
				     finish(x,lambda)
				fi
		      then (xcont,lambdacont) = contragredient(x,lambda)
		      then () = if tw.< and is_finished(xcont,lambdacont)
			        then for p in Uhash.list()
			       	     do if p.x = xcont and p.lambda = lambdacont
				        then Uhash.match(contragredient(p))
				        fi
				     od;
				     if FPP_report_flag and every_lambda_flag
		   		     then prints("Contragredient of (",x,",",lambda,") was previously computed")
				     fi;
				     tw:=0;
				     finish(x,lambda)
			         fi
	      	     in if tw.< {still have work to do close 1545; here 1581}
		     	then let revert_steve_flag = revert_steve_flag(x,lambda)
			     then startminxl = good_hash.size(), startmorexl = more_good_hash.size()
			     then local_test_bl_flag = bool:
			     	  if hard_test_flag
				  then hard_test_bl(x,lambda)
			     	  elif easy_test_flag
				  then easy_test_bl(x)
				  else true
				  fi
		 	     in let startxl = elapsed_ms(), startUhash = Uhash.size(),
			     	    (x_sc,lambda_sc) = xlambdas_sc[k],
		     		   startUcounter = unitary_test_counter.use_count(),
				   startUtime = unitaryTime, theta = x.involution,
				   startCcounter = char_counter.use_count(), startCtime = charTime,
				   startCTime = charTime, startmorebad = more_bad_hash.size()
				   {startUparamhash = Uparamhash.size(),} 
		 		 then (Lvd, Perm2{, mapAct}) = LPmss[k] {already lives on Gsc}
		 		 then () = if every_lambda_flag and FPP_report_flag
      	      	   	      then prints("     start #", k, " = (",x,",",lambda,"), Uhash.size() = ",
			      Uhash.size(), ", runtime = ", print_time_string(elapsed_ms() - start),
			      ", #uparams so far = ",sum(answerCards));
		   		   prints("  ------------------")
        	   		   fi {every_lambda_flag}
		 then startLF = elapsed_ms(){, startDTcount = DTcount}
	 	 then p0 = parameter(x,lambda, 0*lambda)
		 in if test_no_unitary(x,lambda,Lvd) {here 1600; close 1685}
		    then ()
		    else adjust_Dirac_flags(x);
		    	 let startDTcount = DTcount
		    	 then LF = [[FaceVertsIndex]]:
		      	   if revert_steve_flag
			   then [[]]
		      	   elif by_zero_flag {and height(parameter(x,lambda,0*lambda)) > 0}
		      	   then localFD_1Dirac2_by_zero(x_sc, lambda_sc, Lvd, Perm2)
			   else localFD_1Dirac2(x_sc, lambda_sc, Lvd, Perm2)
			   fi
		        then () = if every_lambda_deets_flag and FPP_report_flag and not revert_steve_flag
    	      	      	     	  then prints("time for localFD_1Dirac2* = ",
				       print_time_string(elapsed_ms() - startLF),
			   	       " to find [",#LF[0],",",#LF[1],"] verts and edges; Dirac eliminated ",
				       DTcount - startDTcount)
	      		   	   fi
		 in if (not revert_steve_flag) and (#LF = 0 or #LF[0] = 0)
		    then let () = finish(x_sc, lambda_sc)
		    	 then ()= none_count +:= 1
			 in if disconn_flag
			    then finish(x,lambda)
			    fi; ()
		    else if every_lambda_deets_flag
			 then face_verbose := true{old_face_verbose}; time_verbose := true{old_time_verbose};
			      test_verbose :=true{old_test_verbose}; test_slightly_verbose := true {old_test_slightly_verbose}
			 fi;
			 let answer = if revert_steve_flag {and lambda_sc!=Gsc.rho}
			     	      then edge_offset:=1;
					   local_test_GEO_hash_steve(x_sc, lambda_sc, Lvd, Uhash,
				      	   fancy_tester)
				       elif local_test_bl_flag
			     	       then local_test_GEO_hash_bottom_layer(x_sc,
						lambda_sc, Lvd, LF, pol_hash, Uhash, fancy_tester)
				       elif one_level_revert_flag
				       then local_test_GEO_hash_one_level(x_sc, lambda_sc, Lvd,
				       	    	LF, pol_hash, Uhash, fancy_tester)
				       elif real_dumb_revert_flag
				       then local_test_GEO_hash_real_dumb(x_sc, lambda_sc, Lvd,
				       	    	LF, pol_hash, Uhash, fancy_tester)
				       else local_test_GEO_hash2(x_sc, lambda_sc, Lvd,
				       	    	LF, pol_hash, Uhash, fancy_tester)
				       fi
			 then () = finish(x_sc, lambda_sc)
			 then () = if disconn_flag
			      	   then finish(x,lambda)
				   fi
			 then () = answerCards[k] := #answer
			 then () = if Uparamhash_flag
			      	   then for p in answer do Uparamhash.match(p) od
				   fi;
   		    	 	   current := elapsed_ms(); currentUhash := Uhash.size();
			       	   currentUcounter := unitary_test_counter.use_count();
				   currentUtime := unitaryTime;
				   currentCcounter := char_counter.use_count();
				   currentCtime := charTime
    		 	 then () = xlambdatimes[k] := current - startxl
    			 in if every_lambda_flag and FPP_report_flag
	      		    then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) #",k, " = (", xnums[k],",",xlambdas[k],"), ht = ",
				  height(parameter(x,lambda,0*lambda)), ", L = ", let (Q,) =
				  if small_test_flag then theta_stable_data_small(parameter(x,lambda,0*lambda))
				  else theta_stable_quasi_data(parameter(x,lambda,0*lambda))
				  fi in Q.Levi.Lie_type,
				  ",",test_string);
			         prints("    #LF = ", for L in LF do #L od, "; #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests for this lambda = ", currentUcounter - startUcounter,
				 ", unitary time = ", print_time_string(currentUtime - startUtime));
				 prints("  #char calcs = ", currentCcounter - startCcounter,
				 ", char time = ", print_time_string(currentCtime - startCtime),
				 {", #Params more-missed = ", more_bad_hash.size() - startmorebad,}
				 ", #unitary params so far = ",sum(answerCards));
       	    			 prints("Time in min_bottom_factors = ",print_time_string(mbfTime),
				 ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
				 prints("     #Params min-caught for this lambda = ", good_hash.size() - startminxl,
				 {", #Params min-missed = ", bad_hash.size()}
				 ", #min-caught total = ", good_hash.size());
 			         prints("Time in bottom_factors = ", print_time_string(bfTime),
				 ", time in bottom_elim_factors_more = ", print_time_string(befmoreTime),
				 ", more_shift_level = ", if bl_step_flag then
		    		       	     bl_step_count*bl_step_size else more_shift_level fi);
				 prints("     #Params more-caught for this lambda = ",
				 more_good_hash.size() - startmorexl, {befmoreCount}
      		 		 {", #Params more-missed = ", more_bad_hash.size());}
				 ", #more-caught total = ",more_good_hash.size());
				 report_tested_cum("for (x,lam)=(#"+to_string(x.number)+","+to_string(lambda)+")",
				 "running totals");
				 prints("  ------------------")
			    fi
		    fi{#LF[0] = 0}
		   fi {test_no_unitary line 1600}
		 fi {tw.< line 1581}
		 fi {twist(x)!=x line 1545}
		 od{xlambdas}
    then () = if disconn_flag
	      then for j: Uhash.size()
		   do for p in sc_descends(Uhash.index(j), G, M)
		      do UhashG.match(p)
		      od
		   od
	       fi
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    then () =  if FPP_report_flag
       	       then prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xlambdas[longest], {",", lambdas[longest],}")");
       	    if small_test_flag
	    then prints("Time spent in is_unitary = ",print_time_string(unitaryTime),
	    ", #unitarity tests = ",
       		unitary_test_counter.use_count() - oldUcounter, ", #(x,lambda) studied = ",
		minSmallBottomData.size())
	    else prints("Time spent in is_unitary = ",print_time_string(unitaryTime), ", #unitarity tests = ",
       		unitary_test_counter.use_count() - oldUcounter, ", #K-types studied = ", minBottomData.size())
	    fi;
	    prints("Time spent in char calcs = ",print_time_string(charTime),
	           ", #char calcs = ", char_counter.use_count() - oldCcounter ,
	      	   ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time),
	    ", in script branch = ",
	    		 print_time_string(branch_script_time));
       	    prints("Time in derived_factor_K_types_info = ", print_time_string(dfkiTime),
	    ", time in natural KGB = ", print_time_string(nKeTime));
       	    prints("Time in min_bottom_factors = ",print_time_string(mbfTime),
	    ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
	    prints("     #Params min-caught = ", good_hash.size(){,
	    ", #Params min-missed = ", bad_hash.size()});
 	    prints("Time in bottom_factors = ", print_time_string(bfTime),
				 ", time in bottom_elim_factors_more = ", print_time_string(befmoreTime),
				 ", more_shift_level = ", if bl_step_flag then
		    		       	     bl_step_count*bl_step_size else more_shift_level fi);
	    prints("     #Params more-caught = ", more_good_hash.size(){befmoreCount});
      		 		 {", #Params more-missed = ", more_bad_hash.size());}
       	    {prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(),",  #hash_dumb = ", hash_dumbCounter.use_count(),
	      ", #hash_def_dumb = ", hash_def_dumbCounter.use_count(),
	      ", #hash2 = ", hash2Counter.use_count(), ", #hash_one_level = ", hash_one_levelCounter.use_count(),
	      ", #hash_bottom_layer = ", hash_bottom_layerCounter.use_count());}
       	    prints("Number of unitary params = ", sum(answerCards), ", time for is_finished = ",
	    		   print_time_string(is_finished_time), ", time for position = ",
	    		   print_time_string(position_time));
       	    prints("Number of FPP-unitary faces = ",UhashG.size(), ", number found on this run = ", UhashG.size() - oldUhash);
	    report_tested("CUMULATIVE TOTALS")
	    fi {FPP_report_flag}
     in kill_for_big_uTime(); () 


set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas, (Param -> bool) fancy_tester) = void:
    FPP_unitary_hash_bottom_layer(xlambdas, let (x,lambda) = xlambdas[0]
    in big_unitary_hash.uhash(x.real_form), fancy_tester)

set FPP_unitary_hash_bottom_layer([KGBElt] xs, Param_hash UhashG, (Param->bool) fancy_tester) = void:
    if #xs = 0
    then return ()
    fi;
    let G = xs[0].real_form
    then most_more = most_more(G)
    in if is_compact(G)
       then for p in all_parameters_gamma(G,G.rho)
       	    do UhashG.match(p)
	    od;
            return ()
        fi;
    let () = if tilde_flag
    	     	  then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      	  fi
    then G = xs[0].real_form
    then disconn_flag = components_rank(G) > 0
    then (Gsc,M) = if disconn_flag
    	      	   then derived_cover_real_form_info(G)
	      	   else (G,id_mat(G.rank))
	      	   fi
    then xs_sc = if disconn_flag
    	       	 then for x in xs do inverse_embed_KGB2(x, Gsc, M) od
	      	 else xs
	      	 fi
    then Uhash = if disconn_flag {this will hold the unitary irrs on Gsc}
    	       	 then big_unitary_hash.uhash(Gsc) {make_Param_hash()}
		 else UhashG
		 fi
    then UparamhashTilde = if disconn_flag {this will hold the unitary standard Params on Gsc}
    	       	 	   then make_Param_hash()
		 	   else Uparamhash
		 	   fi
    then start = elapsed_ms(), zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then () = unitaryTime := 0
    then () = charTime :=0
    then () = dfkiTime := 0
    then () = FD12Time := 0
    then () = FD12bzTime :=0
    then () = red_count_time :=0
    {then {xnums = for x in xs do let (,m) = %x in m od,} xtimes = null(#xs)}
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then () = if FPP_report_flag
    	      then {clear_report_tested();} DTcount:=0; DBTcount:=0
	      fi
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = face_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,UhashG)
	      fi
    then () = if coh_ind_all_flag
    	      then coh_ind_unip_all(G,UhashG)
	      elif coh_ind_most_flag
    	      then coh_ind_unip_most(G,UhashG)
	      {elif coh_ind_few_flag
	      then coh_ind_unip_few(G,UhashG)}
	      fi
    then () = if disconn_flag
    	      then for j:UhashG.size()
	      	   do for psc in sc_lifts2(UhashG.index(j), Gsc, M)
		      do Uhash.match(psc)
		      od
		   od
	       fi
    then times = [int]: null(#xs)
    then red_count_times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
    {then () = adjust_global_top(Gsc)}
    {then () = global_faces_by_zero := low_FPP_faces_by_zero(global_faces)}
    then current = elapsed_ms()
    then oldUhash = UhashG.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
	 oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count(), oldUtime = unitaryTime,
	 oldcharTime = charTime, currentcharTime = charTime, currentUtime = unitaryTime
{try to deal with x already recorded as known}
    then skipx = false
    then () = for x@j in xs
    	      do {xs}
	 test_next(x);
	 if twist(x) != x
	 then big_unitary_hash.finishx(x)
	 fi;
	 let revert_steve_flag = revert_steve_flag(x){prefer_steve_long_flag and (x.number = #KGB(G) - 1)}
	 then former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter, x_sc = xs_sc[j],
	     formerUtime = unitaryTime, formerCcounter = currentCcounter, formerCharTime = charTime,
	     former_red_count_time = red_count_time,  startmorebadx = more_bad_hash.size(),
	     startmorex = more_good_hash.size(), startminbadx = bad_hash.size(), startminx = good_hash.size()
	 then xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
	 then N1 = #FPP_lambdas(x)
	 then full_N1 = to_bitset([N1])-1
	 then known_x = big_unitary_hash.x_known(G)
	 then () = skipx:= is_member_bitset(x.number,known_x)
	 then tw = first(for y in xtwists[1:] do is_member_bitset(y.number, known_x) od)
	      {there's a twist of x which is known}
	 then xtwist = if tw.>= and not skipx
	      	       then skipx := true;
		       	    xtwists[tw+1]
		       else x
		       fi
	 then twnum = last(for y in xs[:j] do y=xtwist od)
	 then () = if{A} twnum.>=  {now xtwist is xs[twnum]}
	      	   then answerCards[j]:= answerCards[twnum]; {this is too low if xtwist wasn't calculated here}
	    	   	if Uparamhash_flag
	    	 	then for p in Uparamhash.list()
	              	     do if p.x = xtwists[tw]
		      	     	then Uparamhash.match(parameter(x,p.lambda,p.nu))
		    	 	fi
		      	     od
	    	 	 fi
		    fi{A}
	then () = if xtwist != x
	     	  then {prints("skipping x = ",x.number," for xtwist = ",xtwist.number);}
	    	       for p in Uhash.list()
	    	       do if p.x = xtwist
	       	       	  then Uhash.match(parameter(x, p.lambda, p.nu))
	       	    	  fi
	    	       od;
	    	       big_unitary_hash.finish(x, full_N1); {mark as done all lambdas for x}
	   	       big_unitary_hash.finishx(x)
		   fi {xtwist != x}
	 then xcont_cand = contragredient(x)
	 then xcont = if xcont_cand != x and is_member_bitset(xcont_cand.number, known_x) and not skipx
	      	      then skipx := true;
		      	   xcont_cand
		      else x
		      fi
	 then contnum = last(for y in xs[:j] do y = xcont od)
	 then () = if{B} contnum.>= {now xcont is xs[contnum]}
	    	   then answerCards[j]:= answerCards[contnum];
		    	if Uparamhash_flag
		    	then for p in Uparamhash.list()
			     do if p.x = xcont
			    	then Uparamhash.match(contragredient(p))
			    	fi
			      od
			fi
		     fi{B}
	  then () = if xcont != x
		    then {prints("skipping x = ",x.number," for xcont = ",xcont.number);}
		       	 for p in Uhash.list()
	      	       	 do if p.x = xcont
		       	    then Uhash.match(contragredient(p))
		    	    fi
		       	 od;
		         big_unitary_hash.finish(x,full_N1); {mark as done all lambdas for x}
		       	 big_unitary_hash.finishx(x)
		     fi
	 then () = if {C} skipx = false
	 then let lambdas = FPP_lambdas(x)
	      then local_test_bl_flag =
	      	   if easy_test_flag and not hard_test_flag
		   then easy_test_bl(x)
		   else true
		   fi
    	 then Ncases = #lambdas
	 then tempanswerCards = null(Ncases)
	 then templambdatimes = null(Ncases)
	 then () = if every_KGB_flag and FPP_report_flag
      	      	   then prints("     start KGBElt #", x.number, ", #lambdas = ",Ncases,
		   	       " Uhash.size() = ", Uhash.size(), ", runtime = ",
			       print_time_string(elapsed_ms() - start), ", #uparams so far = ",
			       sum(for list in answerCards do sum(list) od));
		   	prints("  ------------------")
        	   fi
	 then () = for lambda@index in lambdas {ought to look at contragredient(x,lambda) here!}
	      	   do let lamthlam = ((1+x.involution)*lambda).numer
		      then (Lvd1, Perm2{, mapAct}) = LPm_table.LPm_entry(G,x.involution,lamthlam)
		      then Lvd = if disconn_flag
		      	       	 then to_vertex_data(for v in Lvd1.list do M*v od, Lvd1.pair_start)
			   	 else Lvd1
				 fi
		      then  startlambda = elapsed_ms(), startUhash = Uhash.size(), startUcounter =
		      	    unitary_test_counter.use_count(), startUtime = unitaryTime,
			    startminxl = good_hash.size(), startminbadlambda = bad_hash.size(),
			    startmorebadlambda = more_bad_hash.size(), startmorexl = more_good_hash.size(),
			    startLF = elapsed_ms(),
			    startCcounter = char_counter.use_count(), startCtime = charTime
		      then () = if every_lambda_flag and FPP_report_flag
      	      	   	     	then prints("     start #", index, " = (",x,",",lambda,
					    "), Uhash.size() = ", Uhash.size(),
					    ", runtime = ", print_time_string(elapsed_ms() - start){,
			      		    ", #uparams so far = ",sum(answerCards)});
		   		   prints("  ------------------")
        	   		fi {every_lambda_flag}
		      then () = if hard_test_flag
		      	      	then local_test_bl_flag := hard_test_bl(x,lambda)
				fi
		      then () = if x=x_open(G)
		      	      	then revert_steve_flag:=revert_steve_flag(x,lambda)
				fi
		      then startDTcount = DTcount
		      {then revert_steve_flag = revert_steve_flag(x,lambda)}
		     in if {test_neither}test_no_unitary(x,lambda,Lvd)
		       	then {none_count +:= 1;} {prints("SKIPPED ",x,",",lambda);} ()
		    	else adjust_Dirac_flags(x);
			     let LF = [[FaceVertsIndex]]:
			     	      if revert_steve_flag then [[]]
				      elif by_zero_flag {and dominant(G,lamthlam)*G.two_rho_check > 0}
 		      	      	      then localFD_1Dirac2_by_zero(x_sc, M*lambda, Lvd, Perm2)
			   	      else localFD_1Dirac2(x, lambda, Lvd, Perm2)
			   	      fi
		             then () = if every_lambda_deets_flag and FPP_report_flag and not revert_steve_flag
    	      	      	      	then prints("time for localFD_1Dirac2* = ",
				print_time_string(elapsed_ms() - startLF),
				" to find [",#LF[0],",",#LF[1],"] verts and edges; Dirac eliminated ",
				DTcount - startDTcount)
	      		   	fi
		       in if not revert_steve_flag and (#LF = 0 or #LF[0] = 0)
			  then none_count+:=1;
			       finish(x,lambda); []
			  else if every_lambda_deets_flag
			       then face_verbose := old_face_verbose; time_verbose := old_time_verbose;
				    test_verbose :=old_test_verbose; test_slightly_verbose :=
					 	      old_test_slightly_verbose
			       fi;
			       let answer = [Param]:
			       	      if revert_steve_flag
			       	      then edge_offset:=1;
				      	   local_test_GEO_hash_steve(x_sc, M*lambda, Lvd, Uhash,
				      	   fancy_tester)
			       	      elif local_test_bl_flag
			     	      then local_test_GEO_hash_bottom_layer(x_sc, M*lambda, Lvd, LF,
				      	   pol_hash, Uhash, fancy_tester)
				      elif one_level_revert_flag
				      then local_test_GEO_hash_one_level(x_sc, M*lambda, Lvd,
				      	   LF, pol_hash, Uhash, fancy_tester)
				      elif real_dumb_revert_flag
				      then local_test_GEO_hash_real_dumb(x_sc, M*lambda, Lvd,
				      	   LF, pol_hash, Uhash, fancy_tester)
				      else local_test_GEO_hash2(x_sc, M*lambda, Lvd,
				      	   LF, pol_hash, Uhash, fancy_tester)
				      fi
			       then () = tempanswerCards[index] := #answer
			       {better to do next when y_sc is called for}
			       {then y_scs = isotwistKGBs(x_sc)
			       then () = for qsc in answer
				       	 do for y_sc in y_scs
				     	    do let rsc = parameter(y_sc, qsc.lambda, qsc.nu)
				     	       then () = Uparamhash.match(rsc)
			             	       then () = if disconn_flag
					       	       	 then for r in sc_descends(rsc,G,M)
						    	      do Uparamhash.match(r)
						    	      od
					       	  	 fi
					        in for tsc in monomials(finalize(rsc))
				           	   do Uhash.match(tsc);
					      	      if disconn_flag
					      	      then for t in sc_descends(tsc,G,M)
						      	   do UhashG.match(t)
						   	   od
					       	       fi
					    	   od {tsc}
				      	     od {y_sc}
				    	   od{qsc}
			         then () = for y_sc in y_scs
					   do finish(y_sc,M*lambda)
					   od}
 			 	 then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 in if every_lambda_flag and FPP_report_flag
				    then prints("  ",print_time_string(templambdatimes[index]),
			   	    " = time for (x,lambda) = (", x.number, ", #",index," = ",lambda, "), ht = ",
				    height(parameter(x,lambda,0*lambda)),", L = ", let (Q,) =
				    if small_test_flag then theta_stable_data_small(parameter(x,lambda,0*lambda))
				    else theta_stable_quasi_data(parameter(x,lambda,0*lambda))
				    fi in Q.Levi.Lie_type, ",",test_string);
				         {if more_flag or bl_step_flag
					 then} prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",
					      	tempanswerCards[index], ", #new unitary = ", Uhash.size() - startUhash,
						", #tests for this lambda = ", unitary_test_counter.use_count() - startUcounter,
						", time = ",print_time_string(unitaryTime - startUtime));
					      prints("     #char calcs for lambda = ", char_counter.use_count() - startCcounter,
					        ", char time = ", print_time_string(charTime - startCtime));
       	    prints("Time in min_bottom_factors = ",print_time_string(mbfTime),
	    ", time in min_bottom_elim_factors = ", print_time_string(mbefTime);
	    prints("     #Params min-caught for lambda = ", good_hash.size() - startminxl,
	    {", #Params min-missed for lambda = ", bad_hash.size() - startminbadlambda}
	    ", #min-caught total = ",good_hash.size());
 	    prints("Time in bottom_factors = ", print_time_string(bfTime),
	    ", time in bottom_elim_factors_more = ", print_time_string(befmoreTime),
	    ", more_shift_level = ", if bl_step_flag then bl_step_count*bl_step_size else more_shift_level fi);
	    prints("     #Params more-caught for lambda = ", more_good_hash.size() - startmorexl);
      	    {", #Params more-missed for lambda = ", more_bad_hash.size() - startmorebadlambda}
	    ", #more-caught total = ", more_good_hash.size());
	    report_tested("CUMULATIVE TOTALS");
	    prints("  ------------------")
				    fi{every_lambda_flag}
			       fi{#LF = 0}
			     fi {test_no_unitary}
                 od {lambdas} {good_entries} {would be easy enough to get [Param] for each (x,lambda),
		    	      		     but for now just put unitary reps in Uhash}
    	   then () = if disconn_flag
	   	     then for j: Uhash.size()
		     	  do for p in sc_descends(Uhash.index(j), G, M)
			     do UhashG.match(p)
			     od
			  od
		     fi
            then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	    	     red_count_times[j] := red_count_time - former_red_count_time; currentUtime := unitaryTime;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     currentCcounter := char_counter.use_count(); answerCards[j] := tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag and FPP_report_flag
                     then  prints("     time for KGBElt ",x.number," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for ", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
       	    prints("Time in min_bottom_factors = ",print_time_string(mbfTime),
	    ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
	    prints("     #Params min-caught for this x = ", good_hash.size() - startminx,
	    {", #Params min-missed for this x = ", bad_hash.size() - startminbadx}
	    ", #min-caught total = ",good_hash.size());
 	    prints("Time in bottom_factors = ", print_time_string(bfTime),
	    ", time in bottom_elim_factors_more = ", print_time_string(befmoreTime),
	    ", more_shift_level = ", if bl_step_flag then bl_step_count*bl_step_size else more_shift_level fi);
	    prints("     #Params more-caught for this x = ", more_good_hash.size() - startmorex,
      	    {", #Params more-missed for this x = ", more_bad_hash.size() - startmorebadx}
	    ", #more-caught total = ", more_good_hash.size());
	    prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary faces = ",
	    currentUhash - formerUhash, ", #tests for this x = ", currentUcounter - formerUcounter,
	    ", time in is_unitary = ", print_time_string(unitaryTime - formerUtime));
	    prints("     Time spent in char calcs = ", print_time_string(charTime - formerCharTime),
			      	     ", number of char calcs = ", currentCcounter - formerCcounter,
				     ", time for red_count = ",print_time_string(red_count_times[j]));
			   report_tested_cum("for x=#"+to_string(x.number),"running totals")
                     fi {every_KGB_flag}
	   then () = big_unitary_hash.finish(x, full_N1) {mark as done all lambdas for x}
	   in big_unitary_hash.finishx(x)
	   fi {C}
           in ()
{
	 fi {contnum.>= and contnum < j}
	 fi {twnum.>= and twnum < j}

}
         od {xs}
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    then () = if FPP_report_flag
       then prints("----------------");
       	    prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xs[longest].number);
	    if small_test_flag
	    then prints("Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime), ", #unitarity tests = ",
       		unitary_test_counter.use_count() - oldUcounter, ", #(x,lambda) studied = ", minSmallBottomData.size())
	    else prints("Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime), ", #unitarity tests = ",
       		unitary_test_counter.use_count() - oldUcounter, ", #K-types studied = ", minBottomData.size())
	    fi;
	    prints("Time spent in char calcs = ", print_time_string(charTime-oldcharTime), ", number of char calcs = ",
	        char_counter.use_count() - oldCcounter,
	      ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
       	    prints("Time in derived_factor_K_types_info = ",print_time_string(dfkiTime),", time in natural KGB = ", print_time_string(nKeTime));

       	    prints("Time in min_bottom_factors = ",print_time_string(mbfTime),
	    ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
	    prints("     #Params min-caught = ", good_hash.size(),
	    {", #Params min-missed = ", bad_hash.size(),}
	    ", #Params more-caught = ", more_good_hash.size());
 	    prints("Time in bottom_factors = ", print_time_string(bfTime),
	    ", time in bottom_elim_factors_more = ", print_time_string(befmoreTime),
	    ", more_shift_level = ", if bl_step_flag then
		    		       	     bl_step_count*bl_step_size else more_shift_level fi);
	    {prints("     #Params more-caught = ", more_good_hash.size(), 
      	    ", #Params more-missed = ", more_bad_hash.size());}
       	    {prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(),",  #hash_dumb = ", hash_dumbCounter.use_count(),
	    	   ", #hash_def_dumb = ", hash_def_dumbCounter.use_count(),
	    	   ", #hash2 = ",hash2Counter.use_count(), ", #hash_one_level = ", hash_one_levelCounter.use_count(), ", #hash_bottom_layer = ",
	    hash_bottom_layerCounter.use_count());}
       	    prints("Number of unitary params = ", sum(for list in answerCards do sum(list) od),
	    		   ", time for is_finished = ", print_time_string(is_finished_time),
			   ", time for position = ", print_time_string(position_time));
            prints("Number of known FPP-unitary faces = ",UhashG.size(),
       	      ", number found on this run = ", UhashG.size() - oldUhash);
	    report_tested("CUMULATIVE TOTALS")
      fi {FPP_report_flag}
     in kill_for_big_uTime(); ()

set FPP_unitary_hash_bottom_layer([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_bottom_layer(xs, big_unitary_hash.uhash(xs[0].real_form),fancy_tester)

set FPP_unitary_hash_bottom_layer(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_bottom_layer(KGB(G), fancy_tester)

{Following functions invoke David/Mason-Brown result from February 2025: if infl char is on
 some one-walls of the FPP, and those roots NOT in tau-invariant, then rep is either non-unitary,
 or coh ind from the parabolic whose Levi omits those one-walls; so unitarity is determined on Levi.}
 
{does is_unitary on Levi by running FPP}
set recursive_tester_flag = false

{does is_unitary on Levi with FPP} {TTF}
set Lucas_full_rec() = void:
    is_FPP_unitary_flag:=true;
    recursive_tester_flag:= true;
    Lucas_fast_flag:=false

{does is_unitary on Levi one at a time}
set Lucas_non_rec() = void: {TFF}
    is_FPP_unitary_flag:=true;
    recursive_tester_flag:=false;
    Lucas_fast_flag:=false

{Lucas test, but no unitarity test on L}
set Lucas_fast() = void: {T*T}
    is_FPP_unitary_flag:=true;
    Lucas_fast_flag:=true

{don't apply test. This is now the default.}
set Lucas_no() = void: {F**}
    is_FPP_unitary_flag:=false

{meant to be used only on FPP reps p of simple G}
{Computes the (p.x,p.lambda) part of the unitary dual of p.real_form. That's good
if one is going to do a bunch of related is_unitary tests, for ex as in known_unitaries}
set MyFancyTester(Param p) = bool:
    let () = FPP_unitary_hash2([(p.x,p.lambda)], is_unitary_hash_big_SIMPLE@Param)
    {then () = prints("invoked MFT at p = ",p,", real form = ",p.real_form)}
    in big_unitary_hash.uhash(p.real_form).lookup(herm_center(p)).>=

set FPP_unitary_hash_real_dumb([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_real_dumb(xls, MyFancyTester@Param)
   else FPP_unitary_hash_real_dumb(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_real_dumb([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_real_dumb(xs, MyFancyTester@Param)
   else FPP_unitary_hash_real_dumb(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_real_dumb(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_real_dumb(rf, MyFancyTester@Param)
   else FPP_unitary_hash_real_dumb(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_def_dumb([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_def_dumb(xls, MyFancyTester@Param)
   else FPP_unitary_hash_def_dumb(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_def_dumb([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_def_dumb(xs, MyFancyTester@Param)
   else FPP_unitary_hash_def_dumb(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_def_dumb(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_def_dumb(rf, MyFancyTester@Param)
   else FPP_unitary_hash_def_dumb(rf, is_unitary_hash_big_SIMPLE@Param)
   fi


set FPP_unitary_hash_dumb([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_dumb(xls, MyFancyTester@Param)
   else FPP_unitary_hash_dumb(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_dumb([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_dumb(xs, MyFancyTester@Param)
   else FPP_unitary_hash_dumb(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_dumb(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_dumb(rf, MyFancyTester@Param)
   else FPP_unitary_hash_dumb(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash(xls, MyFancyTester@Param)
   else FPP_unitary_hash(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash(xs, MyFancyTester@Param)
   else FPP_unitary_hash(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash(rf, MyFancyTester@Param)
   else FPP_unitary_hash(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_one_level([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_one_level(xls, MyFancyTester@Param)
   else FPP_unitary_hash_one_level(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_one_level([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_one_level(xs, MyFancyTester@Param)
   else FPP_unitary_hash_one_level(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_one_level(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_one_level(rf, MyFancyTester@Param)
   else FPP_unitary_hash_one_level(rf, is_unitary_hash_big_SIMPLE@Param)
   fi



set FPP_unitary_hash2([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash2(xls, MyFancyTester@Param)
   else FPP_unitary_hash2(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash2([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash2(xs, MyFancyTester@Param)
   else FPP_unitary_hash2(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash2(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash2(rf, MyFancyTester@Param)
   else FPP_unitary_hash2(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_steve([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_steve(xls, MyFancyTester@Param)
   else FPP_unitary_hash_steve(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_steve([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_steve(xs, MyFancyTester@Param)
   else FPP_unitary_hash_steve(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_steve(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_steve(rf, MyFancyTester@Param)
   else FPP_unitary_hash_steve(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_bottom_layer([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_bottom_layer(xls, MyFancyTester@Param)
   else FPP_unitary_hash_bottom_layer(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_bottom_layer([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_bottom_layer(xs, MyFancyTester@Param)
   else FPP_unitary_hash_bottom_layer(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_bottom_layer(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_bottom_layer(rf, MyFancyTester@Param)
   else FPP_unitary_hash_bottom_layer(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

{all nu so parameter(x,lambda,nu) is in unitary hash for G}
set unitary_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let list = big_unitary_hash.uhash(G).list()
    in for p in list
       do if p.x = x and p.lambda = lambda then [p.nu]
	  else []
	  fi
       od.##

{one list for each (x,lambda)}
set unitary_nus(RealForm G) = [[[ratvec]]]:
    let answer = [[[ratvec]]]:
    	for x in KGB(G)
	do for lambda in FPP_lambdas(x)
	   do []
	   od
	od
     then list = big_unitary_hash.uhash(G).list()
     then () = for p in list
       	       do let answerx = answer[p.x.number]
	       	  then () = answerx[position(p.x, p.lambda)] #:= p.nu
	     	  in answer[p.x.number] :=answerx
	       od
      in answer


{all local vertex nu for (x,lambda). To be applied only to G simple mod center.}
set all_vertex_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let (Lvd,Perm2{, mapAct}) = LPm_table.LPm_entry(G,x.involution,((1+x.involution)*lambda).numer)
    then LF = if by_zero_flag {and height(parameter(x,lambda,0*lambda)) > 0}
	      then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	      fi
    then gammas = for v in LF[0] do Lvd.list[v[0]] od ##
    	 	  for w in LF[1] do face_bary(Lvd,w) od
    in for gamma in gammas
       do if is_final(parameter(x,lambda,gamma))
       	     and is_hermitian(parameter(x,lambda,gamma))
       	  then [gamma]
	  else []
	  fi
       od.##

{all nu so parameter(x,lambda,nu) is final nonunitary vertex or edge for G. To be applied only to
G simple mod center. Best applied after FPP unitary dual of G is computed.}
set non_unitary_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let params = for nu in all_vertex_nus(G, x, lambda)
    	 	  do parameter(x,lambda,nu)
		  od
    in for p in params
       do if is_final(p) and is_hermitian(p) 
       	     and not big_unitary_hash.check(p)
	  then [p.nu]
	  else []
	  fi
	od.##

{assume precompute has been done, so that all FPP unitary are known
for all derived simple factors of theta-stable Levis of G. For maximal LRi run
over unitary (xin,lambdainm) and put into unitary_hash all (x,lambda_nu) that are
induced from some PROPER real Levi. }
set theta_induced(RealForm G) = void:
    let maxLthis = max_Ls(G)
    then maxLthidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLthi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLthi in maxLthis
	 do derived_simple_factors_info(maxLthi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLthidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then unitary_nu_lists = [[[[[ratvec]]]]]:
    	 for Lidata in maxLthidatas
	 do for (,derLik,) in Lidata
	    do unitary_nus(derLik)
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLthidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLthidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]:
    	 for maxLthi in maxLthis
	 do KGB(maxLthi)
	 od
    then KGBEltGs = [[KGBElt]]:
    	 for maxLthi@i in maxLthis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from an Lthi}
    	 for maxLthi@i in maxLthis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then rhois = [ratvec]: for maxLthi in maxLthis do G.rho - maxLthi.rho od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis
     	     do for xin in list
	     	do derived_factor_KGBs0(xin)
	     od
	 od
    then lambdainms = [[[ratvec]]]: {one list of Lthi lambdas for each xin}
    	 for maxLthi@i in maxLthis
	 do for xin@n in KGB(maxLthi)
	    do for lambdaG in lambdainmGs[i][n]
	       do let lambda_testi = lambdaG - rhois[i]
	       	  then pintest = parameter(xin, lambda_testi, 0*lambda_testi)
		  then pintests = derived_factor_params0(pintest)
		  then lamtests = for pintest@k in pintests do pintest.lambda od
		   in if all(for lam@k in lamtests do position(KGBEltinks[i][n][k],lam).>= od)
		      then [pintest.lambda] {[ratvec]}
		      else []
		      fi
		od.## {m, but just keep some [ratvec]}
	   od {n}
	 od {i}
     then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdain, and derLik}
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params0(pinm)
		   then lambdas = for pinmk in pinmks do pinmk.lambda od
		   then xinms = for pinmk in pinmks do pinmk.x od
		   {then finalPinmks = for pinmk@k in pinmks
		   	     	      do if position(xinms[k], lambdas[k]) = -1
		   	     	      then []
				      else [pinmk]
				      fi
			     	      od.##}
		   in for pinmk in pinmks do pinmk.lambda od
		od
	     od
	  od
     then unitary_listinmks = [[[[[ratvec]]]]]:
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
	     	do for lambdainmk@k in lambdainmks[i][n][m]
		   do for nuinmj@j in unitary_nu_lists[i][k][KGBEltinks[i][n][k].number]
		      [position(KGBEltinks[i][n][k],lambdainmks[i][n][m][k])]
		      do Mikinvs[i][k]*nuinmj
		      od {[ratvec]}
		   od {[[ratvec]]}
	     	od {[[[ratvec]]]}
	     od
	  od
     then Binmks = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin
	     	do box(for unitary_listinmk in unitary_listinm do #unitary_listinmk od)
		od
	     od
	  od
     then nuinms = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin {unitary_listinm has two indices: k (simple factor)
	     and j (place on list)}
	        do for B in Binmks[i][n][m]
		   do sum(G.rank, for b@k in B do unitary_listinm[k][b] od)
		   od
		od
	     od
	  od
     then cands = [[Param]]: {one list on each maxLthi}
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do for nuinmj in nuinms[i][n][m]
		   do let pL = parameter(xin, lambdainm, nuinmj)
		      then gamma = pL.infinitesimal_character + rhois[i]
		      in if is_dominant(G,gamma) and is_dom_FPP(G,gamma) {need weakly good!}
		      	 then [pL]
			 else {prints("parameter ",pL," failed to be FPP");}
			      []
			 fi
		   od.## {list of relevant pL for this x,lambda}
		od.## {put all lambda together}
	     od.## {put all x together}
	  od {but keep a separate list for each max Levi maxLthi}
     {then bads = for list in cands
     	      	 do first (for pL in list do not is_unitary(pL) od)
		 od
     then () = if not bads.>=
     	       then badi = first (for f in bads do f.>= od)
	       else badi = -1}
     then () = for maxLthi@i in maxLthis
	     	  do for pL in cands[i]
	     	     do for q in monomials(theta_induce_irreducible(pL,G))
		   	do big_unitary_hash.umatch(herm_center(q))
			od
	     	     od
		  od
     in ()

{simple derived factors of all theta-stable Levis of G}
set SDLF(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for L in Ls(G) {these are PROPER Levis of theta-stable parabolics}
    	      ~do for Lj in derived_simple_factorsRF(L) {~ to put the small L first}
	      	  do answer.match(Lj)
	    	  od
	      	od
    in for k:answer.size()
       do answer.index(k)
       od

{these are the restricted fundamental weights for G: the ones defining maximal real parabolics
 at x_open(G)}
set resFund(RealForm G) = [ratvec]:
    let xo = x_open(G), simples = [vec]: G.simple_roots
    then theta = xo.involution
    then S0 = for j:G.semisimple_rank do if status(j,xo) = 1 then [j] else [] fi od.## {simple imag for M}
    then S1 = complement(G.semisimple_rank, S0)
    then Q0 = KGPElt: (S0,xo)
    then L0 = Q0.Levi
    then wL0 = w0(L0)
    then thetaL0 = matrix(wL0)
    then dualDelta = -theta*thetaL0 {preserves positive}
    then fixDual = for a in S1 do if dualDelta*simples[a] = simples[a] then [a] else [] fi od.##
    then pairsDual = for a in S1
    	 	     do for b:#simples - a-1 from a+1
    	 	       	do if dualDelta*simples[a] = simples[b]
			   then [[a,b]]
			   else []
			   fi
			od.##
		     od.##
    in for a in fixDual do G.fundamental_weights[a] od ##
       for v in pairsDual do G.fundamental_weights[v[0]] + G.fundamental_weights[v[1]] od

{all maximal real parabolics of G}
set max_QRs(RealForm G) = [KGPElt]:
    let xo = x_open(G)
    in for xi in resFund(G) do parabolic_by_wt(xi,xo) od

{all maximal real Levis of G}
set max_LRs(RealForm G) = [RealForm]:
    for QR in max_QRs(G) do QR.Levi od

{all real parabolics of G, starting with G and ending with MAN}
set QRs(RealForm G) = [KGPElt]:
    let xo = x_open(G), res_fund = resFund(G)
    then B = box(2,#res_fund)
    in for wt in columns(res_fund*B)
       do parabolic_by_wt(wt,xo)
       od

{simple derived factors of all real Levis of G}
set LRs(RealForm G) = [RealForm]:
    let Q_Rs = QRs(G)
    in if #Q_Rs = 1 then []
       else for QR in Q_Rs[1:]
    	    do QR.Levi
    	    od
       fi

{simple derived factors of all real Levis of G}
set SDLRF(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for LR in LRs(G) {these are PROPER Levis of real parabolics}
    	      ~do for LRk in derived_simple_factorsRF(LR) {tilde to put small LR first}
	      	  do answer.match(LRk)
	    	  od
	       od
    in for m:answer.size()
       do answer.index(m)
       od

{simple derived factors of all proper real and theta-stable Levis of G}
set SDLALL(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for L in Ls(G) {these are PROPER Levis of theta-stable parabolics}
    	      ~do for Lj in derived_simple_factorsRF(L) {~ to put the small L first}
	      	  do answer.match(Lj)
	    	  od
	      	od
    then () = for LR in LRs(G) {these are PROPER Levis of real parabolics}
    	      ~do for LRk in derived_simple_factorsRF(LR) {tilde to put small LR first}
	      	  do answer.match(LRk)
	    	  od
	       od
    then rank_lists = [[RealForm]]: for r:G.semisimple_rank do [] od
    then () = for k:answer.size()
      	      do let rf =answer.index(k)
	      	 in rank_lists[rf.semisimple_rank] #:= rf
       	      od
     in rank_lists.##

{assume precompute has been done, so that all FPP unitary are known
for all derived simple factors of real Levis of G. For maximal LRi run
over FPP (xin,lambdainm) and put into unitary_hash all (x,lambda_nu) that are
induced from some PROPER real Levi. }
set real_induced(RealForm G) = void:
    let maxLRis = max_LRs(G), start_time = elapsed_ms()
    then maxLRidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLRi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLRi in maxLRis
	 do derived_simple_factors_info(maxLRi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then () = prints("In time ",print_time_string(elapsed_ms() - start_time), ", complete setup for ",
    	    for list in maxLRidatas do #list od," derived simple factors")
    then unitary_nu_lists = [[[[[ratvec]]]]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do unitary_nus(derLik)
	    od
	 od
    then () = prints("At time ",print_time_string(elapsed_ms() - start_time), ", have unitary lists on derived simple")
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLRidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLRidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]: {one list on maxLRi for each i}
    	 for maxLRi in maxLRis
	 do KGB(maxLRi)
	 od
    then KGBEltGs = [[KGBElt]]:
    	 for maxLRi@i in maxLRis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
    {then () = prints("At time ",print_time_string(elapsed_ms() - start_time), ", complete matching KGBs")}
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from an LRi}
    	 for maxLRi@i in maxLRis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then lambdainms = [[[ratvec]]]: {one list of LRi lambdas for each xin}
    	 for maxLRi@i in maxLRis
	 do let rhoi = G.rho - maxLRi.rho
	    in for n:#KGB(maxLRi)
	       do for lambdaG in lambdainmGs[i][n]
	       	  do lambdaG - rhoi
		  od
	       od
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis {indexed by i}
     	     do for xin in list {indexed by n}
	     	do derived_factor_KGBs0(xin) {indexed by k}
	     od
	 od
     then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdain, and derLik}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params0(pinm)
		   in for pinmk@k in pinmks
		      do {if position(pinmk.x,pinmk.lambda).>=
		      {is_FPP(derLiks[i][k], pinmk.infinitesimal_character)}
		      	 then [}pinmk.lambda{]}
			 {else prints("not in FPP_lambdas(x) ",pinmk); []
			 fi}
		      od{.##}
		od
	     od
	  od
     {then () = prints("At time ",print_time_string(elapsed_ms() - start_time), ", complete matching lambdas")}
     then unitary_listinmks = [[[[[ratvec]]]]]:
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n] {list of lambdas for xin on maxLRi}
	     	do for lambdainmk@k in lambdainmks[i][n][m] {factor on derLik}
		   do let m = position(KGBEltinks[i][n][k],lambdainmk)
		      in if m.>=
		      	 then for nuinmj@j in unitary_nu_lists[i][k][KGBEltinks[i][n][k].number][m]
		      {[position(KGBEltinks[i][n][k],lambdainmks[i][n][m][k])]}
			      do Mikinvs[i][k]*nuinmj
		      	      od {[ratvec]}
			 else []
			 fi
		   od {[[ratvec]]}
	     	od {[[[ratvec]]]}
	     od
	  od
     then Binmks = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin
	     	do box(for unitary_listinmk in unitary_listinm do #unitary_listinmk od)
		od
	     od
	  od
     then nuinms = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin {unitary_listinm has two indices: k (simple factor)
	     and j (place on list)}
	        do for B in Binmks[i][n][m]
		   do sum(G.rank, for b@k in B do unitary_listinm[k][b] od)
		   od
		od
	     od
	  od
     then () = prints("At time ",print_time_string(elapsed_ms() - start_time), ", complete lifting nus to Levis")
     then cands = [[Param]]: {one list on each maxLRi}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do for nuinmj in nuinms[i][n][m]
		   do let pL = parameter(xin, lambdainm, nuinmj)
		      then gamma = dominant(G,pL.infinitesimal_character)
		      in if is_FPP(G,gamma)
		      	 then [pL]
			 else {prints("parameter ",pL," failed to be FPP");}
			      []
			 fi
		   od.## {list of relevant pL for this x,lambda}
		od.## {put all lambda together}
	     od.## {put all x together}
	  od {but keep a separate list for each max Levi maxLRi}
     then () = prints("At time ",print_time_string(elapsed_ms() - start_time), ", start computing induction")
     then () = for maxLRi@i in maxLRis
	       do {prints("At time ",print_time_string(elapsed_ms() - start_time), ", start induction from parabolic ",i);}
	          for pL in cands[i]
		  do for q in monomials(real_induce_irreducible(pL,G))
		     do let qdeflist = [q]##
		            if wiggle_flag
			    then for Qdef in local_defs(q)
			     	 do monomials(composition_series(Qdef))
			     	 od.##
			    else [Param]: []
			    fi
		     	in for qdef in qdeflist
			   do big_unitary_hash.umatch(herm_center(qdef))
			   od {qdef in qdeflist}
       		    od {for q in monommials}
	     	 od {for pL in cands[i]}
	      od {for maxLRi in maxLRis}
     then () = prints("At time ",print_time_string(elapsed_ms() - start_time), ", done computing induction")
     in ()

set NUR_verbose = true

set non_unitary_real_induced(RealForm G) = void:
    let maxLRis = max_LRs(G)
    then maxLRidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLRi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLRi in maxLRis
	 do derived_simple_factors_info(maxLRi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLRidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLRidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]: {one list for each max real Levi LRi}
    	 for maxLRi in maxLRis
	 do KGB(maxLRi)
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis
     	     do for xin in list
	     	do derived_factor_KGBs0(xin)
	     od
	 od
    then KGBEltGs = [[KGBElt]]: {one list for each maxLRi}
    	 for maxLRi@i in maxLRis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
	 {need to know which lambdainm on maxLRi for xin can induce to FPP on G. Maybe this is some of them??}
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from a maxLRi}
    	 for maxLRi@i in maxLRis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then lambdainms = [[[ratvec]]]: {one list of LRi lambdas for each xin; omit those that don't descend to FPP}
    	 for maxLRi@i in maxLRis
	 do let rhoi = G.rho - maxLRi.rho
	    in for xin@n in KGB(maxLRi)
	       do for lambdaG in lambdainmGs[i][n]
	       	  do let lambda_testi = lambdaG - rhoi
		     then pintest = parameter(xin, lambda_testi, 0*lambda_testi)
		     then pintests = derived_factor_params0(pintest)
		     then lamtests = for pintest@k in pintests do pintest.lambda od
		     in if all(for lam@k in lamtests do position(KGBEltinks[i][n][k],lam).>= od)
		     	then [pintest.lambda] {[ratvec]}
			else []
			fi
		  od.## {m, but just keep some [ratvec]}
	       od {n}
	 od {i}
         then () = if NUR_verbose
     	       	   then prints("In non_unitary_real_induced, considering ",sum(
		   for listi@i in lambdainms
		   do for listn@n in listi
		      do for listm@m in listn
		      	 do #listm
			 od
		      od.##
		   od.##), " triples (Li, xin, lambdainm).")
		   fi
    {then () = prints(lambdainms)}
    then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdainm, and derLik}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params0(pinm)
		   in for pinmk in pinmks do pinmk.lambda od {[ratvec]}
		od
	     od
	  od
    {indices are max Levi i, KGBElt n, lambda m}
     then ratvec_hashes = [[[ratvec_hash]]]:
          for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
	     	do make_ratvec_hash()
		od {m}
	     od {n}
	  od {i}
     {indices are max Levi i, KGBElt n, lambda m, derived factor k, nu j}
     then all_listinmks = [[[[[ratvec]]]]]:
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainmks[i][n]
	     	do if #lambdainm <= 1
		   then [[ratvec]]:[[]] {indices k and j}
		   else for lambdainmk@k in lambdainm
		      	do for nuinmj@j in all_vertex_nus(derLiks[i][k],KGBEltinks[i][n][k], lambdainmk)
		      	   do Mikinvs[i][k]*nuinmj
		      	   od {[ratvec], one for each j}
		      	od {one for each k and j [[ratvec]]}
		   fi
		od {one for each lambdainm on maxLRi [[[ratvec]]]}
	     od {xin on maxLRi [[[[ratvec]]]]}
	  od {maxLRi [[[[[ratvec]]]]] }
     {indices are max Levi i, KGBElt n, lambda m, nonunitary factor k0, derived factor k, nu j}
     then non_unitary_listinmk0ks = [[[[[[ratvec]]]]]]: {k0 is the nonunitary factor}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainmks[i][n]
	     	do if #lambdainm = 0
		   then [[[ratvec]]]:[[[]]]
		   else for k0:#lambdainm
		    	do let list = all_listinmks[i][n][m] {[[ratvec]]}
			   {then () = prints(new_line, "ALL at ",[i,n,m,k0]," ",list)}
			   then () = list[k0] := {replace list k0 by nonunitary nu's}
			   	for nuinmj@j in non_unitary_nus(derLiks[i][k0],KGBEltinks[i][n][k0],
			   	   	       	   lambdainm[k0])
				do Mikinvs[i][k0]*nuinmj
				od
		           {then () = prints("NU ",list)}
			   in list {[[ratvec]]}
			od {keep track of which factor is nonunitary; [[[ratvec]]]}
		    fi
	     	od {one for each lambdainm on maxLRi [[[ratvec]]]}
	     od {xin on maxLRi [[[[[ratvec]]]]]}
	  od {maxLRi [[[[[ratvec]]]]]] }
{need to take every nu that's non-unitary (vertex) on one derLik, arbitrary on the other (verts). This will
make a rep non-unitary on maxLRi. If induction to G is irreducible, add it.}
     {then () = prints(non_unitary_listinmk0ks)}
     then Binmk0ks = for non_unitary_listi@i in non_unitary_listinmk0ks {[[[[[ratvec]]]]]}
     	  	   do for non_unitary_listin@n in non_unitary_listi {[[[[ratvec]]]]}
	     	      do for non_unitary_listinm@m in non_unitary_listin {[[[ratvec]]]}
		      	 do for non_unitary_listinmk0 in non_unitary_listinm
	     		    do box(for non_unitary_listinmk0k in non_unitary_listinmk0 do #non_unitary_listinmk0k od)
			    od
			 od
	     	      od
	  	   od
     then () = for non_unitary_listi@i in non_unitary_listinmk0ks
     	  do for non_unitary_listin@n in non_unitary_listi
	     do for non_unitary_listinm@m in non_unitary_listin 
	     	do for non_unitary_listinmk0@k0 in non_unitary_listinm
		   {unitary_listinmk0 has two indices: k (simple factor) and j (place on list)}
	           do for B in Binmk0ks[i][n][m][k0]
		      do {prints([i,n,m,k0]);}
		      	 let nu = sum(G.rank, for b@k in B do non_unitary_listinmk0[k][b] od)
		      	 in ratvec_hashes[i][n][m].match(nu)
			 {in prints(nu)}
			 {in nu}
		      od {B}
		   od {k0}
		od {m}
	     od {n}
	  od {i}
     then () = if NUR_verbose
     	       then prints("In non_unitary_real_induced, considering ",sum(
		   for listi@i in ratvec_hashes
		   do for listn@n in listi
		      do for hashm@m in listn
		      	 do hashm.size()
			 od
		      od.##
		   od.##), " quadruples (Li, xin, lambdainm, nuinmj).")
	       fi
     {then IG = big_unitary_hash.rf_number(G)}
     then () = for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do let nu_list = ratvec_hashes[i][n][m].list()
		   in for nu in nu_list
		      do let pL = parameter(xin, lambdainm, nu)
		      	 {then () = if is_unitary(first_param(finalize(pL)))
		      	      	   then prints("OOPS! ",[i,n,m,k0], " pL = ")
				   fi}
		      	 then gamma = dominant(G,pL.infinitesimal_character)
			 in if is_hermitian(pL) and is_FPP(G,gamma)
		      	    then let P = real_induce_irreducible(pL,G)
			    	 {then () = prints("pL = ", pL)}
		      	    	 in if #P = 1
				    then big_unitary_hash.numatch(herm_center(first_param(P)))
				    fi
			    fi
		      od {nu}
		od {m}
	     od {n}
	  od {i}
     in ()

{get complete FPP dual for each derived simple factor of a theta-stable Levi; and then cohom ind
all those things in weakly good range to G}
set pre_bottom_flag = false
set pre_def_dumb_flag = false
set precomputeTheta(RealForm G) = void:
    let rflist = SDLF(G)
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do prints("starting # ",k," = ",rf);
	      	 theta_induced(rf);
		 real_induced(rf);
	 	 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 elif pre_def_dumb_flag
		 then FPP_unitary_hash_def_dumb(rf)
		 else FPP_unitary_hash2(rf)
		 fi
	      od
    then () = FPP_report_flag:=temp_report_flag
    in theta_induced(G)

set precomputeR(RealForm G) = void:
    let rflist = SDLRF(G)
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do prints("starting # ",k," = ",rf, " of ",#rflist);
	      	 real_induced(rf);
		 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 elif pre_def_dumb_flag
		 then FPP_unitary_hash_def_dumb(rf)
		 else FPP_unitary_hash2(rf)
		 fi
	      od
    then () = FPP_report_flag:=temp_report_flag
    in () {real_induced(G)}

set precomputeNUR(RealForm G) = void:
    let rflist = SDLRF(G), start = elapsed_ms()
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do prints("starting # ",k," = ",rf, " of ", #rflist);
	      	 {real_induced(rf);}
		 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 elif pre_def_dumb_flag
		 then FPP_unitary_hash_def_dumb(rf)
		 else FPP_unitary_hash2(rf)
		 fi;
		 {big_unitary_hash.nuhash_fill(rf);}
		 prints("found ",big_unitary_hash.nuhash(rf).size(), " nonunitary reps")
	      od
    then () = FPP_report_flag:=true
    in ()
    {then NUhash = non_unitary_real_induced(G)
    in prints("In time ",print_time_string(elapsed_ms() - start)," found ", NUhash.size(),
       	      " nonunitary reps.")}

set precomputeALL(RealForm G) = void:
    let start = elapsed_ms(), rflist = SDLALL(G)
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do real_induced(rf);
		 theta_induced(rf);
		 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 elif pre_def_dumb_flag
		 then FPP_unitary_hash_def_dumb(rf)
		 else FPP_unitary_hash2(rf)
		 fi;
		 prints("At time ",print_time_string(elapsed_ms() - start), ", finished # ",k,"/",
	      	 	    #rflist," = ",rf, ", #FPPreps = ",big_unitary_hash.uhash(rf).size())
	      od
    then FPP_time = elapsed_ms()
    then () = FPP_report_flag:=temp_report_flag
    then N0 = big_unitary_hash.uhash(G).size()
    then () = real_induced(G)
    then NR = big_unitary_hash.uhash(G).size()
    then () = prints("In ",print_time_string(elapsed_ms() -FPP_time), ", real induction found ",NR-N0,
    	      		 " FPP unitary faces for G.")
    then RI_time = elapsed_ms()
    then () = theta_induced(G)
    then NTheta =  big_unitary_hash.uhash(G).size()
    then () = prints("In ",print_time_string(elapsed_ms() -RI_time), ", coh induction found additional ",NTheta-NR,
       		  	" FPP unitary faces for G.")
    then Th_time = elapsed_ms()
    then unips = unipotent_representations(G), IG = big_unitary_hash.rf_number(G)
    then () = for p in unips do big_unitary_hash.long_umatch(p,IG) od
    then NUnip =  big_unitary_hash.uhash(G).size()
    then () = prints("In ",print_time_string(elapsed_ms() -Th_time), ", found additional ",NUnip - NTheta,
       		  	" unipotent faces for G.")
    in prints("Altogether found ",NUnip-N0, " FPP unitary faces for G.")

set FPPpre(RealForm G) = void:
    let start = elapsed_ms()
    then temp_KGB_flag = every_KGB_flag
    then () = every_KGB_flag:= false
    then () = precomputeALL(G)
    then () = every_KGB_flag := temp_KGB_flag
    then () = if pre_bottom_flag
       	      then FPP_unitary_hash_bottom_layer(G)
	      elif pre_def_dumb_flag
	      then FPP_unitary_hash_def_dumb(G)
       	      else FPP_unitary_hash2(G)
       	      fi
    in prints("Total time required was ",print_time_string(elapsed_ms() - start))

set long_flags = true

{report on status of flags}
set FPP_flags() = void:
    prints(new_line,"prefer_to_hts = ",prefer_to_hts," (default true).");
    if long_flags
    then prints("     true means prefer is_unitary_to_hts(p,[HTs]) to is_unitary_to_ht(p,HTs~[0])")
    fi;
    prints(new_line,"deform_flag = ",deform_flag," (default false).");
    if long_flags
    then prints("     true means when calculating at (x,lambda), record also unitary reps (at strictly",
    	 	new_line,"     higher (x',lambda')) arising by deformation from these.")
    fi;
    prints(new_line,"step_flag = ",step_flag," (default false).");
    if long_flags
    then prints("     true means one_level adds an extra to_ht step before going to the fixed level.")
    fi;
    prints(new_line,"short_hts_flag = ",short_hts_flag," (default false).");
    if long_flags
    then prints("     true means is_unitary_to_ht uses short_hts, which is slower to calculate than",
    	 	new_line,"     next_hts, but perhaps better?")
    fi;
    prints(new_line,"unip_flag = ",unip_flag," (default true).");
    if long_flags
    then prints("     false means do NOT preload Arthur's unipotent representations.")
    fi;
    prints(new_line,"edge_offset = ",edge_offset," (default 3).");
    if long_flags
    then prints("     Start is_unitary_to_ht at next_heights(p,edge_offset)~[0].")
    fi;
    prints(new_line,"edge_skip = ",edge_skip," (default 1).");
    if long_flags
    then prints("     How much to increase index in next_heights at each step.")
    fi;
    prints(new_line,"KU_flag = ",KU_flag," (default true).");
    if long_flags
    then prints("     false means do not look up known unitary classes in local_testK_hash")
    fi;
    prints(new_line,"KNU_flag = ",KU_flag," (default true).");
    if long_flags
    then prints("     false means do not look up known nonunitary classes in local_testK_hash")
    fi;
    prints(new_line,"ICPU_flag = ",ICPU_flag," (default false).");
    if long_flags
    then prints("     true means try to realize each param as induced from unitary in local_testK_hash")
    fi;
    prints(new_line,"ICPNU_flag = ",ICPNU_flag," (default false).");
    if long_flags
    then prints("     true means try to realize each param as induced from nonunitary in local_testK_hash")
    fi;
    prints(new_line,"tilde_flag = ",tilde_flag," (default false).");
    if long_flags
    then prints("     true means FPP_unitary_hash functions on [KGBElt] work last to first")
    fi;
    prints(new_line,"wiggle_flag0 = ",wiggle_flag0," (default false).");
    if long_flags
    then prints("     true means deform params in local_test_K_hash_bottom_layer to look for nonunitarity")
    fi;
    prints(new_line,"wiggle_flag1 = ",wiggle_flag1," (default false).");
    if long_flags
    then prints("     true means deform params in local_test_K_hash to look for nonunitarity")
    fi;
    prints(new_line,"final_wiggle_flag = ",final_wiggle_flag," (default false).");
    if long_flags
    then prints("     true means deform params in local_test_hash ('final approadch') to look for nonunitarity")
    fi;
    prints(new_line,"sort_LFD_flag = ",sort_LFD_flag," (default true).");
    if long_flags
    then prints("     false means do NOT sort candidate faces by height(infl char)")
    fi;
    prints(new_line,"one_two_reverse_flag = ",one_two_reverse_flag," (default false).");
    if long_flags
    then prints("     true means each face list LFDKH[d] is reversed before unitarity tests.")
    fi;
    prints(new_line,"test_interrupt_flag = ",test_interrupt_flag," (default true).");
    if long_flags
    then prints("     false means use is_unitary_test_big_SIMPLE instead of is_unitary_test_big_simple_interrupt.")
    fi;
    prints(new_line,"def_flag = ",def_flag," (default false).");
    if long_flags
    then prints("     true means hash_dumb uses is_unitary_def_test.")
    fi;
    prints(new_line,"real_flag = ",real_flag," (default false).");
    if long_flags
    then prints("     true means hash_dumb does less to_ht.")
    fi;
    prints(new_line,"long_out_flag = ",long_out_flag," (default false).");
    if long_flags
    then prints("     true means put output for (x,lambda) into global vars ParamsByDim and LFDKHByDim.")
    fi;
    prints(new_line,"bl_interrupt_flag = ",bl_interrupt_flag," (default false).");
    if long_flags
    then prints("     true means use interrupted version of bottom_layer.")
    fi;
    prints(new_line,"bl_step_flag = ",bl_step_flag," (default false).");
    if long_flags
    then prints("     true means use stepped version of bottom_layer.")
    fi;
    prints(new_line,"bl_step_count = ",bl_step_count," (default 2).");
    if long_flags
    then prints("     Number of different shifts to try in bl_interrupt and bl_step.")
    fi;
    prints(new_line,"bl_step_size = ",bl_step_size," (default 5).");
    if long_flags
    then prints("     How much to increase the shift at each step.")
    fi;
    prints(new_line,"fewer_reducible_unitary_flag = ",fewer_reducible_unitary_flag," (default true).");
    if long_flags
    then prints("     false means allow (x,lambda) where invt form is INDEF on LKTs.")
    fi
