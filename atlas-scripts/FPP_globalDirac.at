<K_highest_weights {for all_lambda_differential_zero}
<lattice {for vec_solve}
{ <chopping_facets_fast.at {for chop_coroots(G, vertices)}}
<face_classes {for ordering on facets}
<hash {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<FPP_localDirac
<cohIndUnip {for weakly fair cohom ind}
<derived_cover {for simply connected cover of derived group}
<R_packets.at {for trying to combine x's with same LKT}

{functions for computing the entire FPP_unitary dual}
{typically functions take a Param_hash Uhash and fill it with all
unitary reps having infinitesimal character in the FPP. Each p is
replaced by herm_center(p), at the barycenter of its local facet,
so that the lists are finite.}

{. This controls the maximum denominator size kept in chop_coroots,
used in moving unitarity information from a Levi to G. Large values
allow more chopped faces, and so convey more information to G; but
small values are faster. Too small a value cannot lead to wrong
answers, but only to running more is_unitary tests .}
set chop_bound = int: 6

{if true, compute reps weakly fair cohom induced from Arthur unipotent}
{set coh_ind_few_flag = false}

{if true, use coh_ind_most; gets everything at least to rank about 6??}
set coh_ind_most_flag = false

{if true, use (much) slower but complete coh_ind_all}
set coh_ind_all_flag = false

{if true, load Arthur unipotent reps into unitary hash before starting FPP.
Computing Arthur unipotents takes a long time for high rank (e.g. rank 4
complex}
{definition moved to FPP_localDirac.at}
{set unip_flag = true}

{next functions aim to compute FULL spherical dual in non-split case,
when several different x give spherical reps}

{if face_verbose is true, report after each |lambda_skip| lambda's
are treated in FPP_unitary}
set lambda_skip = int:10

{if true, then report summary each lambda in FPP_unitary}
set every_lambda_flag = false

{if true, then report progress during each lambda in FPP_unitary}
set every_lambda_deets_flag = false

{if true, then report summary each KGBElt in FPP_unitary}
set every_KGB_flag = false

set contragredient(KGBElt x) = KGBElt:
    let wzero = w0(x.root_datum) in cross(wzero,x)

set contragredient(KGBElt x, ratvec lambda) = (KGBElt, ratvec):
    let p = contragredient(parameter(x,lambda,0*lambda))
    in (p.x, p.lambda)

{cheating with x.number means list has repetitions; tries to add to KGB(SU(p,q) KGBElts for SU(q,p)}
set isotwistKGBs(KGBElt x) = [KGBElt]:
    let G = x.real_form, theta = x.involution, tf = x.torus_factor, rd = x.root_datum
    {then p = parameter(x,G.rho, G.rho)
    then dp = p.dual}
    then twists = all_even_lambda_differential_0(rd.dual, -theta.^), X = KGB(G)
    in for tau in twists do X[KGB_elt(rd, theta, tf + tau).number] od

set spherical_xs(RealForm G) = [KGBElt]:
    let real_rank = rank(x_open(G).involution + 1)
    in for x in KGB(G)
       do if rank(x.involution + 1) = real_rank
       	  then [x]
	  else []
	  fi
       od.##

{meant to hold barycenters of unitary faces}
set unitary_hash = make_Param_hash()

{meant to hold all unitary parameters found (maybe not final)}
set Uparamhash = make_Param_hash()

{whether to record unitary parameters in Uparamhash}
set Uparamhash_flag = false

{load a bunch of Param_hash's into one}
set transfer([Param_hash] Us, Param_hash target) = void:
    for U in Us
    do for j:U.size()
       do target.match(U.index(j))
       od
    od

{derived simple factors of all Levis of theta-stable P, omitting P=G}
set DSFLevis(RealForm G) = [RealForm]:
    for P in theta_stable_parabolics(G)~[1:]
    do derived_simple_factorsRF(P.Levi) od.##

set DSFLevi_hash(RealForm G) = RealForm_hash:
    make_RealForm_hash(DSFLevis(G), hash_code@(RealForm,int))

{if true, move computation to most split Cartan in R-packet}
set R_packet_flag = false
{as presently implemented, this misses unitary representations in
R-packets containing also nonunitary representations. Reason is that
these parameters are studied only on most split Cartan; software finds
that a parameter there has a nonunitary (reducible) LQ, and fails to
to record unitary factors.}

{uses LPm_table to keep track of local face info}
set FPP_unitary_hash_general([(KGBElt,ratvec)] xlambdas, Param_hash Uhash,
    (Param->bool) fancy_tester, (KGBElt, ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)->[Param])
    local) = void:
    let xlambdasW = if R_packet_flag
    	      	    then for (x,lambda) in xlambdas
	      	         do up_Cayley_match_LKTs(x,lambda)
		   	 od
		    else xlambdas
	      	    fi
    then () = if #xlambdasW = 0 then return ()
    	      else let (x,) = xlambdasW[0]
    then G = x.real_form
    then {vd = FPP_vertex_data(G),} start = elapsed_ms(),  zeroNu = null(G.rank)/1
    then () = if FPP_report_flag
    	      then unitaryTime := 0; charTime := 0; FD12Time:=0; FD12bzTime:=0; red_count_time :=0;
	      	   branch_builtin_time :=0; branch_script_time := 0
	      fi
    then xnums = for (x,) in xlambdasW do x.number od
    then lambdas = for (,lambda) in xlambdasW do lambda od
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then startLPmss = elapsed_ms()
    then LPmss = for (x,lambda) in xlambdasW
    	       	 do LPm_table.LPm_entry(G,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
              	 od
    then () = if every_lambda_deets_flag and FPP_report_flag
    	      then prints("time for LPmss = ",print_time_string(elapsed_ms() - startLPmss))
	      fi
    then () = face_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_all_flag 
    	      then coh_ind_unip_all(G,Uhash) {this takes several seconds for F4_s}
	      elif coh_ind_most_flag
	      then coh_ind_unip_most(G,Uhash)
	      {elif coh_ind_few_flag
then coh_ind_unip_few(G,Uhash)}
	      fi
    then xlambdatimes = [int]: null(#xlambdasW)
    then answerCards = [int]: null(#xlambdasW) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    {then () = adjust_global_top(G)}
    {then () = prints("time thru global_faces = ",print_time_string(elapsed_ms() - start))}
    {then () = global_faces_by_zero := low_FPP_faces_by_zero(global_faces)}
    {then () = prints("time thru global_faces_by_zero = ",print_time_string(elapsed_ms() - start))}
    then current = elapsed_ms(), oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
         oldUtime = unitaryTime, currentUtime = unitaryTime, oldCtime = charTime, currentCtime = charTime,
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
		   oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count()
    {then () = if every_lambda_deets_flag
    	      then prints("time up to main loop = ",print_time_string(elapsed_ms() - start))
	      fi}
    then () = for (x,lambda)@k in xlambdasW
    	      do {xlambdasW}
	      	let skip_lambda= is_finished(x,lambda)
		in if skip_lambda
		   then if FPP_report_flag
		   	then prints("Already computed (",x,",",lambda,")")
			fi; return ()
		   else
	 	 let startxl = elapsed_ms(), startUhash = Uhash.size(),
		     		   startUcounter = unitary_test_counter.use_count(),
				   startCcounter = char_counter.use_count(),
				   startUTime = unitaryTime, startCTime = charTime, theta = x.involution
		 then p0 = parameter(x,lambda,zeroNu)
		 {then () = prints("time before LPmss[",k,"] = ",print_time_string(elapsed_ms() - start))}
		 then (Lvd, Perm2{, mapAct}) = LPmss[k]
		 then () = if every_lambda_flag and FPP_report_flag
      	      	   	      then prints("     start #", k, " = (",x,",",lambda,"), Uhash.size() = ",
			      Uhash.size(), ", runtime = ", print_time_string(elapsed_ms() - start),
			      ", #uparams so far = ",sum(answerCards));
		   		   prints("  ------------------")
        	   	   fi {every_lambda_flag}
		 then startLF = elapsed_ms()
		 {then () = prints("time thru start [",k,"] =
		 ",print_time_string(startLF - start))}
		 then startDTcount = DTcount
		 then LF = if by_zero_flag {and height(p0) > 0}
		      	   then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
			   else localFD_1Dirac2(x, lambda, Lvd, Perm2)
			   fi
		 then () = if every_lambda_deets_flag and FPP_report_flag
    	      	      	   then prints("time for localFD_1Dirac2* = ",print_time_string(elapsed_ms() - startLF),
			   " to find [",#LF[0],",",#LF[1],"] verts and edges; Dirac eliminated ",
			   DTcount - startDTcount)
	      		   fi
		 in if #LF[0] = 0 then ()
		     else if every_lambda_deets_flag
			  then face_verbose := old_face_verbose; time_verbose := old_time_verbose;
			       test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			  fi;
			  let answer = local(x, lambda, {LPm_table.FPP_vertex_data(G) ,} Lvd, LF,
			      	     pol_hash, Uhash, fancy_tester)
			  then () = finish(x,lambda)
			  then () = answerCards[k] := #answer
			  then () = if Uparamhash_flag
			       	    then for p in answer do Uparamhash.match(p) od
				    fi
   		    	  then () = current := elapsed_ms(); currentUhash := Uhash.size();
			       	    currentUcounter := unitary_test_counter.use_count();
				    currentCcounter := char_counter.use_count()
    		 	  then () = xlambdatimes[k] := current - startxl
    			  in if every_lambda_flag and FPP_report_flag
	      		     then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) #",k, " = (", xnums[k], ",",lambdas[k],")", test_string);
			         prints("    #LF = ", for L in LF do #L od, "; #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests for lambda = ", unitary_test_counter.use_count() - startUcounter,
				 ", time = ", print_time_string(unitaryTime - startUTime));
				 prints("     #char calcs for this lambda = ",char_counter.use_count() - startCcounter,
				 ", time = ",print_time_string(charTime - startCTime));
				  report_tested();
				 prints("  ------------------")
			     fi
		    fi {#LF[0]=0}
		    fi{skip_lambda}
		 od{xlambdasW}
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    in if FPP_report_flag
       then prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xnums[longest], ",",
	      lambdas[longest],")");
       	    prints(" Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count() - oldUcounter);
	    prints(" Time spent in char calcs = ",print_time_string(charTime - oldCtime),
	      ", number of char calcs = ",char_counter.use_count() - oldCcounter,
	      ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
       	    if mix_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params missed by more = ",
		    more_bad_hash.size())
	    fi;
       	    prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(), ", #hash_dumb = ", hash_dumbCounter.use_count(),
       	      	 	   ", #hash_def_dumb = ", hash_def_dumbCounter.use_count());
       	    prints("  #hash = ", hashCounter.use_count(), ", #hash2 = ", hash2Counter.use_count(),
	      	 	", #hash_one_level = ", hash_one_levelCounter.use_count(), ", #hash_bottom_layer = ",
			hash_bottom_layerCounter.use_count());
	    report_tested();
       	    prints("Number of unitary params = ", sum(answerCards), ", time for is_finished = ",
	    print_time_string(is_finished_time), ", time for position = ",
	    print_time_string(position_time));
       	    prints("Number of FPP-unitary faces = ",Uhash.size(), ", number found on this run = ", Uhash.size() - oldUhash)
       fi {FPP_report_flag}
       fi {#xlambdasW = 0}
     in ()

set FPP_unitary_hash_general([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester,
    (KGBElt, ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash,(Param->bool)->[Param])
    local) = void:
    if #xs = 0
    then return ()
    else
    {let () = deform_flag:=true}
    let () = if tilde_flag
    	      then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      fi
    then G = xs[0].real_form
    then start = elapsed_ms(), zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then () = if FPP_report_flag
    	      then unitaryTime := 0; charTime := 0; FD12Time:=0; FD12bzTime:=0; red_count_time :=0
	      fi
    {then {xnums = for x in xs do x.number od, xtimes = null(#xs),}}
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then () = if FPP_report_flag
    	      then clear_report_tested(); DTcount:=0; DBTcount:=0
	      fi
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = face_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_all_flag 
    	      then coh_ind_unip_all(G,Uhash) {this takes several seconds for F4_s}
	      elif coh_ind_most_flag
	      then coh_ind_unip_most(G,Uhash)
	      {elif coh_ind_few_flag
	      then coh_ind_unip_few(G,Uhash)}
	      fi
    then times = [int]: null(#xs)
    then red_count_times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
     then current = elapsed_ms()
    then oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
	 oldUtime = unitaryTime, oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count()
    then skipx = false
    then () = for x@j in xs
    	      do {xs}
	 if twist(x) != x
	 then big_unitary_hash.finishx(x)
	 else
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter,
	     formerUtime = unitaryTime, formerCcounter = currentCcounter, formerCharTime = charTime,
	     former_red_count_time = red_count_time
	 then xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
	 then M = #FPP_lambdas(x)
	 then full_M = to_bitset([M])-1
	 then known_x = big_unitary_hash.x_known(G)
	 then () = skipx:= is_member_bitset(x.number,known_x)
	 then tw = first(for y in xtwists[1:] do is_member_bitset(y.number, known_x) od) {there's a twist of x which is known}
			 {full_M = big_unitary_hash.xl_known(G)[y.number]}
	 then xtwist = if tw.>= and not skipx
	      	       then skipx := true;
		       	    xtwists[tw+1]
		       else x
		       fi
	 then twnum = last(for y in xs[:j] do y=xtwist od) 
	 then () = if{A} twnum.>=  {now xtwist is xs[twnum]}
	      	   then answerCards[j]:= answerCards[twnum]; {this is too low if xtwist wasn't calculated here}
	    	   	if Uparamhash_flag
	    	 	then for p in Uparamhash.list()
	              	     do if p.x = xtwists[tw]
		      	     	then Uparamhash.match(parameter(x,p.lambda,p.nu))
		    	 	fi
		      	     od
	    	 	 fi
		    fi{A}
	then () = if xtwist != x
	     	  then {prints("skipping x = ",x.number," for xtwist = ",xtwist.number);}
	    	       for p in Uhash.list()
	    	       do if p.x = xtwist
	       	       	  then Uhash.match(parameter(x, p.lambda, p.nu))
	       	    	  fi
	    	       od;
	    	       big_unitary_hash.finish(x, full_M); {mark as done all lambdas for x}
	   	       big_unitary_hash.finishx(x)
		   fi
	 then xcont_cand = contragredient(x)
	 then xcont = if xcont_cand != x and is_member_bitset(xcont_cand.number, known_x) and not skipx
	      	      then skipx := true;
		      	   xcont_cand
		      else x
		      fi
	 then contnum = last(for y in xs[:j] do y = xcont od)
	 then () = if{B} contnum.>= {now xcont is xs[contnum]}
	    	   then answerCards[j]:= answerCards[contnum];
		    	if Uparamhash_flag
		    	then for p in Uparamhash.list()
			     do if p.x = xcont
			    	then Uparamhash.match(contragredient(p))
			    	fi
			      od
			fi
		     fi{B}
	  then () = if xcont != x
		    then {prints("skipping x = ",x.number," for xcont = ",xcont.number);}
		       	 for p in Uhash.list()
	      	       	 do if p.x = xcont
		       	    then Uhash.match(contragredient(p))
		    	    fi
		       	 od;
		         big_unitary_hash.finish(x,full_M); {mark as done all lambdas for x}
		       	 big_unitary_hash.finishx(x)
		     fi
	  then () = if {C} skipx = false
	       	    then let lambdas = FPP_lambdas(x)
    	 	    	 then Ncases = #lambdas
	          	 then tempanswerCards = null(Ncases)
	 	  	 then templambdatimes = null(Ncases)
	 		 then () = if every_KGB_flag and FPP_report_flag
      	      	   	      then prints("     start KGBElt #", x.number, ", #lambdas = ",#lambdas,
		   	       " Uhash.size() = ", Uhash.size(), ", runtime = ",
			       	 print_time_string(elapsed_ms() - start), ", #uparams so far = ",
			       sum(for list in answerCards do sum(list) od));
		   		   prints("  ------------------")
        	   		   fi {every_KGB_flag}
			 then xW = x
	 		 then () = for lambda@index in lambdas
	      	   	      	   do let lambdaW = lambda
				      then () = if R_packet_flag
				      	      	then let (xprime,lambdaprime) = up_Cayley_match_LKTs(x,lambda)
				      		then () = xW:=xprime
				      		then () = lambdaW:=lambdaprime
				     		in ()
				      		fi
				      then lambdacont = parameter(xW,lambdaW,0*lambdaW).lambda
				      then lcontnum = if lambdacont != lambdaW
				      	   	     then last(for kappa in lambdas[:index] do kappa = lambdacont od)
						     else -1
						     fi

		 		      then () = if every_lambda_flag and FPP_report_flag
      	      	   	     	      	      	then prints("     start #", index, " = (",x,",",lambda,
						"), Uhash.size() = ", Uhash.size(),
						", runtime = ", print_time_string(elapsed_ms() - start),
			      			", #uparams so far = ",sum(answerCards));
		   		   prints("  ------------------")
        	   		   fi {every_lambda_flag}
				      in if lcontnum.>=
				      	 then tempanswerCards[index]:= tempanswerCards[lcontnum];
		    	 		      for p in Uparamhash.list()
			 		      do if p.x = xW and p.lambda = lambdacont
					      	 then Uparamhash.match(contragredient(p))
			    		    	 fi
			 		       od;
		    	 	               big_unitary_hash.finish(xW,to_bitset([index]));
					       {mark as done this lambda for xW}
			            	       for p in Uhash.list()
	      	       		    	       do if p.x = xW and p.lambda = lambdacont
		       	  	       	       	  then Uhash.match(contragredient(p))
		    	  	       		  fi
		       		    	       od
					  else let lamthlam = ((1+xW.involution)*lambdaW).numer
		      		      	       then (Lvd, Perm2{, mapAct}) = LPm_table.LPm_entry(G,xW.involution,lamthlam)
		      		      	       then  startlambda = elapsed_ms(), startUhash = Uhash.size(),
					       	     startUcounter = unitary_test_counter.use_count(),
						     startUtime = unitaryTime, startCcounter =
						     char_counter.use_count(), startCtime = charTime
				      	       then startLF = elapsed_ms(), startDTcount = DTcount
 		      		      	       then LF = if by_zero_flag {and dominant(G,lamthlam)*G.two_rho_check > 0}
		      	      	      	      	       	 then localFD_1Dirac2_by_zero(xW, lambdaW, Lvd, Perm2)
			   				 else localFD_1Dirac2(xW, lambdaW, Lvd, Perm2)
			   				 fi {by_zero_flag}
				      	       then () = if every_lambda_deets_flag and FPP_report_flag
    	      	      	              	       	       	 then prints("time for localFD_1Dirac2* = ",
				      	       	    	      print_time_string(elapsed_ms() - startLF),
			   			    	      " to find [",#LF[0],",",#LF[1],
							      "] verts and edges; Dirac eliminated ",DTcount - startDTcount)
	      		   			    	 fi
			 		   in if #LF[0] = 0
					      then finish(x, lambda); []
			    		      else if every_lambda_deets_flag
			       	 	      	   then face_verbose := old_face_verbose;
						   time_verbose := old_time_verbose;
				    	 	   test_verbose :=old_test_verbose;
						   test_slightly_verbose := old_test_slightly_verbose
				 		   fi;
				 		   let answer = local(xW, lambdaW, {LPm_table.FPP_vertex_data(G),}
						       Lvd, LF, pol_hash, Uhash, fancy_tester)
						   then () = finish(x, lambda)
						   {then p = parameter(Sp(6,R),8,[2,1,1],[1,-1,0]/2)
						   then Lp = big_unitary_hash.lookup(p)
						   then () = prints ("Lp = ",Lp," at (",x,",",lambda, ")")}
				 		   then () = for p in answer do Uparamhash.match(p) od
			  	 		   then () = tempanswerCards[index] := #answer
			  	 		   then () = for p in answer do Uparamhash.match(p) od
				 		   then () = if every_lambda_deets_flag
			    	      	   	   	     then face_verbose := false; time_verbose := false;
				 	   		     	  test_verbose := false; test_slightly_verbose := false
				 	   		     fi
 			 	 		   then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 		   in if every_lambda_flag and FPP_report_flag
				    		      then prints("  ",print_time_string(templambdatimes[index]),
			   	    	 	      	   " = time for (x,lambda) = (", xW.number, ",",index," = ",
							   lambdaW, ")", test_string);
				         		   prints("    #LF = ", for L in LF do #L od,
							   ", #unitary params = ", tempanswerCards[index],
			     	                	   ", #new unitary = ", Uhash.size() - startUhash,
							   ", #tests for this lambda = ",
							   unitary_test_counter.use_count() - startUcounter,
							   ", unitary time for lambda = ",
							   print_time_string(unitaryTime -startUtime));
					 		   prints("  char calcs for lambda = ",
						   	   char_counter.use_count() - startCcounter,
					 	 	   " char time = ", print_time_string(charTime - startCtime));
				  			   report_tested();
					 		   prints("  ------------------")
				    		       fi{every_lambda_flag}
			      			 fi{#LF[0] = 0}
					    fi{lcontnum.>=}
                   		od{lambda}
				{would be easy enough to get [Param] for each (x,lambda), but for now just
				put unitary reps in Uhash}
           then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	   	     red_count_times[j] := red_count_time - former_red_count_time;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     currentCcounter := char_counter.use_count(); answerCards[j]:= tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag and FPP_report_flag
                     then  prints("     time for KGBElt ",x.number," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for #", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
			  prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary faces = ",
			     currentUhash - formerUhash, ", #tests for this x = ",
		     	     currentUcounter-formerUcounter,", time = ", print_time_string(unitaryTime-formerUtime));
			     {", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count());}
       	    		  prints("Time spent in char calcs = ",print_time_string(charTime-formerCharTime),
       	      		  	 ", number of char calcs = ", char_counter.use_count() - formerCcounter,
				 " time spent in red_count = ",  print_time_string(red_count_times[j]));
			 report_tested()
                     fi
	   then () = big_unitary_hash.finish(x, full_M) {mark as done all lambdas for x}
	   in big_unitary_hash.finishx(x) {mark as done all lambdas for x}
	   fi {C}
	   in ()
	 fi
         od {xs}
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    in if FPP_report_flag
       then prints("----------------");
       	    prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xs[longest].number);
       	    prints("Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count() - oldUcounter);
       	    prints("Time spent in char calcs = ",print_time_string(charTime),
       	      ", number of char calcs = ", char_counter.use_count() - oldCcounter,
	      ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
	    if mix_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params missed by more = ",
		    more_bad_hash.size())
	    fi;
       	    prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb = ", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb = ", hash_def_dumbCounter.use_count());
       	    prints("  #hash = ", hashCounter.use_count(),
	      ", #hash2 = ", hash2Counter.use_count(),
	      ", #hash_one_level = ", hash_one_levelCounter.use_count(),
              ", #hash_bottom_layer = ", hash_bottom_layerCounter.use_count());
       	    prints("Number of unitary params = ", sum((for list in answerCards do sum(list) od)),
	    		   ", time for is_finished = ", print_time_string(is_finished_time),
			   ", time for position = ", print_time_string(position_time));
      	    prints("Number of known FPP-unitary faces = ",Uhash.size(),
       	      ", number found on this run = ", Uhash.size() - oldUhash);
	    report_tested()
      fi {FPP_report_flag}
   fi {#xs = 0}

set FPP_unitary_hash_general(RealForm G,Param_hash Uhash, (Param->bool) fancy_tester,
    (KGBElt,ratvec,{VertexData,}LocalVertexData, [[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)->[Param])
    local) = void:
    if is_compact(G)
    then for p in all_parameters_gamma(G,G.rho)
    do Uhash.match(p) od
    else
    FPP_unitary_hash_general(KGB(G), Uhash, fancy_tester, local)
    fi

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash,
    (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester,local_test_GEO_hash_dumb@(
    KGBElt,ratvec,LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_real_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form),
    fancy_tester)

set FPP_unitary_hash_real_dumb([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash_real_dumb@(
    KGBElt,ratvec,LocalVertexData,[[FaceVertsIndex]],KTypePol_hash,Param_hash,(Param->bool)))

set FPP_unitary_hash_real_dumb([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_real_dumb(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_real_dumb(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_real_dumb(KGB(G), fancy_tester)

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) =
    void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash_def_dumb@(
    KGBElt,ratvec,{VertexData,} LocalVertexData,[[FaceVertsIndex]], KTypePol_hash, Param_hash,
    (Param->bool)))

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_def_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form),
    fancy_tester)

set FPP_unitary_hash_def_dumb([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    let () = def_flag:=true then () = real_flag:=false in
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash_def_dumb@(KGBElt,ratvec,
    LocalVertexData, [[FaceVertsIndex]], KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_def_dumb([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_def_dumb(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_def_dumb(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_def_dumb(KGB(G), fancy_tester)

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    let () = def_flag:=false then () = real_flag:=false in
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash_dumb@(
    KGBElt,ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form),
    fancy_tester)

set FPP_unitary_hash_dumb([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    let () = def_flag:=false then () = real_flag:=false in
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash_dumb@(
    KGBElt,ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_dumb([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_dumb(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_dumb(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_dumb(KGB(G), fancy_tester)

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash@(
    KGBElt,ratvec, LocalVertexData, [[FaceVertsIndex]], KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form), fancy_tester)

set FPP_unitary_hash([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash@(
    KGBElt,ratvec,{VertexData,} LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash([KGBElt] xs,(Param->bool) fancy_tester) = void:
    FPP_unitary_hash(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash(KGB(G), big_unitary_hash.uhash(G), fancy_tester)

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash2@(
   KGBElt,ratvec, LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash2(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form), fancy_tester)

set FPP_unitary_hash2([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash2@(
    KGBElt,ratvec,{VertexData,}LocalVertexData,[[FaceVertsIndex]],
    KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash2([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash2(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash2(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash2(KGB(G), fancy_tester)

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, (Param->bool) fancy_tester) =
    void:
    FPP_unitary_hash_general(xlambdas, Uhash, fancy_tester, local_test_GEO_hash_one_level@(
    KGBElt,ratvec,LocalVertexData,[[FaceVertsIndex]], KTypePol_hash, Param_hash, (Param->bool)))

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_one_level(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form),
    fancy_tester)

set FPP_unitary_hash_one_level([KGBElt] xs, Param_hash Uhash, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_general(xs, Uhash, fancy_tester, local_test_GEO_hash_one_level@(
    KGBElt,ratvec,{VertexData,} LocalVertexData,[[FaceVertsIndex]], KTypePol_hash, Param_hash,
    (Param->bool)))

set FPP_unitary_hash_one_level([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_one_level(xs, big_unitary_hash.uhash(xs[0].real_form), fancy_tester)

set FPP_unitary_hash_one_level(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_one_level(KGB(G), fancy_tester)

set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas, Param_hash UhashG, (Param->bool)
fancy_tester) = void:
    if #xlambdas = 0 then return ()
    else let (x,) = xlambdas[0]
    then G = x.real_form
    then disconn_flag = components_rank(G) > 0
    then (Gsc,M) = if disconn_flag
    	      	   then derived_cover_real_form_info(G)
	      	   else (G,id_mat(G.rank))
	      	   fi
    then xlambdas_sc = if disconn_flag
    	      	       then for (x,lambda) in xlambdas
		       	    do let (xt,lambdat) = (inverse_embed_KGB2(x, Gsc, M), M*lambda)
			       {then () = if is_finished(x,lambda)
			       	       	 then finish(xt,lambdat)
					 fi}
			       in (xt,lambdat)
			    od
		       else xlambdas
	      	       fi
    then () = if disconn_flag
    	      then for (x,lambda) in all_finished(G)
	      	   do let (xt,lambdat) = (inverse_embed_KGB2(x, Gsc, M), M*lambda)
	      	      in finish(xt,lambda)
	      	   od
	       fi
    then Uhash = if disconn_flag {this will hold the unitary reps on Gsc}
    	      	 then big_unitary_hash.uhash(Gsc) {make_Param_hash()}
		 {this is for unitary reps of Gsc that factor to G}
		 else UhashG
		 fi
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then () = if FPP_report_flag
    	      then clear_report_tested(); DTcount:=0; DBTcount:=0
	      fi
    then start = elapsed_ms()
    then () = if FPP_report_flag
    	      then unitaryTime := 0; charTime := 0; FD12Time:=0; FD12bzTime:=0; red_count_time :=0
	      fi
    then xnums = for (x,) in xlambdas do let (,m) = %x in m od
    {then lambdas = for (,lambda) in xlambdas do lambda od}
    then LPmss = for (x,lambda) in xlambdas_sc
    	       	 do LPm_table.LPm_entry(Gsc,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
		 od
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = face_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,UhashG)
	      fi
    then () = if coh_ind_all_flag
    	      then coh_ind_unip_all(G,UhashG)
	      elif coh_ind_most_flag
	      then coh_ind_unip_most(G,Uhash)
	      {elif coh_ind_few_flag
	      then coh_ind_unip_few(G,Uhash)}
	      fi
    then () = if disconn_flag
    	      then for j:UhashG.size()
	      	   do for psc in sc_lifts2(UhashG.index(j), Gsc, M)
		      do Uhash.match(psc)
		      od
		   od{; prints("# unitary faces on Gsc = ",Uhash.size())}
	      fi
    then xlambdatimes = [int]: null(#xlambdas)
    then answerCards = [int]: null(#xlambdas) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    {then () = adjust_global_top(Gsc)}
    {then () = if by_zero_flag
    	      then global_faces_by_zero := low_FPP_faces_by_zero(global_faces)
	      fi}
    then current = elapsed_ms(), oldUhash = UhashG.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
	 currentUtime = unitaryTime, currentCtime = charTime,
	 oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count()
		   {start_min_L_bottom_factors = minBottomData.min_L_bottom_factors_time()}
    then () = for (x,lambda)@k in xlambdas
    	      do {xlambdas}
	      	 let skip_xlambda = is_finished(x,lambda)
		 in if skip_xlambda
		    then if every_lambda_flag and FPP_report_flag
		    	 then prints("Already computed (",x,",",lambda,")")
		      	 fi
	 	    else let startxl = elapsed_ms(), startUhash = Uhash.size(), (x_sc,lambda_sc) = xlambdas_sc[k],
		     		   startUcounter = unitary_test_counter.use_count(),
				   startUtime = unitaryTime, theta = x.involution,
				   startCcounter = char_counter.use_count(), startCtime = charTime,
				   startCTime = charTime, startmorebad = more_bad_hash.size()
				   {startUparamhash = Uparamhash.size(),} 
		 then (Lvd, Perm2{, mapAct}) = LPmss[k] {already lives on Gsc}
		 then () = if every_lambda_flag and FPP_report_flag
      	      	   	      then prints("     start #", k, " = (",x,",",lambda,"), Uhash.size() = ",
			      Uhash.size(), ", runtime = ", print_time_string(elapsed_ms() - start),
			      ", #uparams so far = ",sum(answerCards));
		   		   prints("  ------------------")
        	   		   fi {every_lambda_flag}
		 then startLF = elapsed_ms(), startDTcount = DTcount
		 then () = time_verbose := old_time_verbose {REMOVE THIS LINE??}
		 then LF = if by_zero_flag {and height(parameter(x,lambda,0*lambda)) > 0}
		      	   then localFD_1Dirac2_by_zero(x_sc, lambda_sc, Lvd, Perm2)
			   else localFD_1Dirac2(x_sc, lambda_sc, Lvd, Perm2)
			   fi
		 then () = if every_lambda_deets_flag and FPP_report_flag
    	      	      	   then prints("time for localFD_1Dirac2* = ", print_time_string(elapsed_ms() - startLF),
			   	       " to find [",#LF[0],",",#LF[1],"] verts and edges; Dirac eliminated ",DTcount - startDTcount)
	      		   fi
		 in if #LF[0] = 0
		    then let () = finish(x_sc, lambda_sc)
			 in if disconn_flag
			    then finish(x,lambda)
			    fi; ()
		    else if every_lambda_deets_flag
			 then face_verbose := old_face_verbose; time_verbose := old_time_verbose;
			      test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			 fi;
			 let answer = local_test_GEO_hash_bottom_layer(x_sc, lambda_sc,
			     Lvd, LF, pol_hash, Uhash, fancy_tester)
			 then () = finish(x_sc, lambda_sc)
			 then () = if disconn_flag
			      	   then finish(x,lambda)
				   fi
			 then () = answerCards[k] := #answer
			 then () = for p in answer do Uparamhash.match(p) od
   		    	 then () = current := elapsed_ms(); currentUhash := Uhash.size();
			       	   currentUcounter := unitary_test_counter.use_count();
				   currentUtime := unitaryTime;
				   currentCcounter := char_counter.use_count();
				   currentCtime := charTime
    		 	 then () = xlambdatimes[k] := current - startxl
    			 in if every_lambda_flag and FPP_report_flag
	      		    then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) #",k, " = (", xnums[k],",",xlambdas[k],"), ht = ",
				  height(parameter(x,lambda,0*lambda)), ", L = ", let (Q,) =
				  if small_test_flag then theta_stable_data_small(parameter(x,lambda,0*lambda))
				  else theta_stable_quasi_data(parameter(x,lambda,0*lambda))
				  fi in Q.Levi.Lie_type,
				  ",",test_string);
			         prints("    #LF = ", for L in LF do #L od, "; #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests for this lambda = ", currentUcounter - startUcounter,
				 ", unitary time = ", print_time_string(currentUtime - startUtime));
				 prints("  #char calcs = ", currentCcounter - startCcounter,
				 ", char time = ", print_time_string(currentCtime - startCtime),
				 ", #Params missed by more = ", more_bad_hash.size() - startmorebad,
				 ", #unitary params so far = ",sum(answerCards));
				  report_tested();
				 prints("  ------------------")
			    fi
		    fi{#LF[0] = 0}
		 fi {is_finished(x,lambda)}
		 od{xlambdas}
    then () = if disconn_flag
	      then for j: Uhash.size()
		   do for p in sc_descends(Uhash.index(j), G, M)
		      do UhashG.match(p)
		      od
		   od
	       fi
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    in if FPP_report_flag
       then prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xlambdas[longest], {",", lambdas[longest],}")");
       	    if small_test_flag
	    then prints("Time spent in is_unitary = ",print_time_string(unitaryTime), ", #unitarity tests = ",
       		unitary_test_counter.use_count() - oldUcounter, ", #(x,lambda) studied = ", minSmallBottomData.size())
	    else prints("Time spent in is_unitary = ",print_time_string(unitaryTime), ", #unitarity tests = ",
       		unitary_test_counter.use_count() - oldUcounter, ", #K-types studied = ", minBottomData.size())
	    fi;
	    prints("Time spent in char calcs = ",print_time_string(charTime),
	           ", #char calcs = ", char_counter.use_count() - oldCcounter ,
	      	   ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
       	    prints("Time in derived_factor_K_types_info = ", print_time_string(dfkiTime), ", time in natural KGB = ", print_time_string(nKeTime));
       	    prints("Time in min_bottom_factors = ",print_time_string(mbfTime), ", time in min_bottom_elim_factors = ",print_time_string(mbefTime));
       	    {prints("Time in bottom layer branching = ",print_time_string(rf_sig_tables.bottom_branch_time()),
       		    ", time in bottom layer sig = ", print_time_string(rf_sig_tables.bottom_sig_time()));}
       	    if more_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi);
      		 prints("     #Params missed by more = ", more_bad_hash.size())
	    fi;
       	    prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(),",  #hash_dumb = ", hash_dumbCounter.use_count(),
	      ", #hash_def_dumb = ", hash_def_dumbCounter.use_count(),
	      ", #hash2 = ", hash2Counter.use_count(), ", #hash_one_level = ", hash_one_levelCounter.use_count(),
	      ", #hash_bottom_layer = ", hash_bottom_layerCounter.use_count());
       	    prints("Number of unitary params = ", sum(answerCards), ", time for is_finished = ",
	    		   print_time_string(is_finished_time), ", time for position = ",
	    		   print_time_string(position_time));
       	    prints("Number of FPP-unitary faces = ",UhashG.size(), ", number found on this run = ", UhashG.size() - oldUhash);
	    report_tested()
       fi {FPP_report_flag}
    fi {#xlambdas = 0}

set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas, (Param -> bool) fancy_tester) = void:
    FPP_unitary_hash_bottom_layer(xlambdas, let (x,lambda) = xlambdas[0]
    in big_unitary_hash.uhash(x.real_form), fancy_tester)

set FPP_unitary_hash_bottom_layer([KGBElt] xs, Param_hash UhashG, (Param->bool) fancy_tester) = void:
    if #xs = 0
    then return ()
    else let () = if tilde_flag
    	     	  then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      	  fi
    then G = xs[0].real_form
    then disconn_flag = components_rank(G) > 0
    then (Gsc,M) = if disconn_flag
    	      	   then derived_cover_real_form_info(G)
	      	   else (G,id_mat(G.rank))
	      	   fi
    then xs_sc = if disconn_flag
    	       	 then for x in xs do inverse_embed_KGB2(x, Gsc, M) od
	      	 else xs
	      	 fi
    then Uhash = if disconn_flag {this will hold the unitary irrs on Gsc}
    	       	 then big_unitary_hash.uhash(Gsc) {make_Param_hash()}
		 else UhashG
		 fi
    then UparamhashTilde = if disconn_flag {this will hold the unitary standard Params on Gsc}
    	       	 	   then make_Param_hash()
		 	   else Uparamhash
		 	   fi
    then start = elapsed_ms(), zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then () = unitaryTime := 0
    then () = charTime :=0
    then () = dfkiTime := 0
    then () = FD12Time := 0
    then () = FD12bzTime :=0
    then () = red_count_time :=0
    {then {xnums = for x in xs do let (,m) = %x in m od,} xtimes = null(#xs)}
    {then () = pol_hash.clear()} {in recursive calls, this screws up bigger G, which has
    	  already indexed some K_chars here.}
    then () = if FPP_report_flag
    	      then clear_report_tested(); DTcount:=0; DBTcount:=0
	      fi
    then old_face_verbose = face_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = face_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,UhashG)
	      fi
    then () = if coh_ind_all_flag
    	      then coh_ind_unip_all(G,UhashG)
	      elif coh_ind_most_flag
    	      then coh_ind_unip_most(G,UhashG)
	      {elif coh_ind_few_flag
	      then coh_ind_unip_few(G,UhashG)}
	      fi
    then () = if disconn_flag
    	      then for j:UhashG.size()
	      	   do for psc in sc_lifts2(UhashG.index(j), Gsc, M)
		      do Uhash.match(psc)
		      od
		   od
	       fi
    then times = [int]: null(#xs)
    then red_count_times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
    {then () = adjust_global_top(Gsc)}
    {then () = global_faces_by_zero := low_FPP_faces_by_zero(global_faces)}
    then current = elapsed_ms()
    then oldUhash = UhashG.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
	 oldCcounter = char_counter.use_count(), currentCcounter = char_counter.use_count(), oldUtime = unitaryTime,
	 oldcharTime = charTime, currentcharTime = charTime, currentUtime = unitaryTime
{try to deal with x already recorded as known}
    then skipx = false
    then () = for x@j in xs
    	      do {xs}
	 if twist(x) != x
	 then big_unitary_hash.finishx(x)
	 else
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter, x_sc = xs_sc[j],
	     formerUtime = unitaryTime, formerCcounter = currentCcounter, formerCharTime = charTime,
	     former_red_count_time = red_count_time,  startmorebadx = more_bad_hash.size()
	 then xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
	 then N1 = #FPP_lambdas(x)
	 then full_N1 = to_bitset([N1])-1
	 then known_x = big_unitary_hash.x_known(G)
	 then () = skipx:= is_member_bitset(x.number,known_x)
	 then tw = first(for y in xtwists[1:] do is_member_bitset(y.number, known_x) od)
	      {there's a twist of x which is known}
	 then xtwist = if tw.>= and not skipx
	      	       then skipx := true;
		       	    xtwists[tw+1]
		       else x
		       fi
	 then twnum = last(for y in xs[:j] do y=xtwist od) 
	 then () = if{A} twnum.>=  {now xtwist is xs[twnum]}
	      	   then answerCards[j]:= answerCards[twnum]; {this is too low if xtwist wasn't calculated here}
	    	   	if Uparamhash_flag
	    	 	then for p in Uparamhash.list()
	              	     do if p.x = xtwists[tw]
		      	     	then Uparamhash.match(parameter(x,p.lambda,p.nu))
		    	 	fi
		      	     od
	    	 	 fi
		    fi{A}
	then () = if xtwist != x
	     	  then {prints("skipping x = ",x.number," for xtwist = ",xtwist.number);}
	    	       for p in Uhash.list()
	    	       do if p.x = xtwist
	       	       	  then Uhash.match(parameter(x, p.lambda, p.nu))
	       	    	  fi
	    	       od;
	    	       big_unitary_hash.finish(x, full_N1); {mark as done all lambdas for x}
	   	       big_unitary_hash.finishx(x)
		   fi {xtwist != x}
	 then xcont_cand = contragredient(x)
	 then xcont = if xcont_cand != x and is_member_bitset(xcont_cand.number, known_x) and not skipx
	      	      then skipx := true;
		      	   xcont_cand
		      else x
		      fi
	 then contnum = last(for y in xs[:j] do y = xcont od)
	 then () = if{B} contnum.>= {now xcont is xs[contnum]}
	    	   then answerCards[j]:= answerCards[contnum];
		    	if Uparamhash_flag
		    	then for p in Uparamhash.list()
			     do if p.x = xcont
			    	then Uparamhash.match(contragredient(p))
			    	fi
			      od
			fi
		     fi{B}
	  then () = if xcont != x
		    then {prints("skipping x = ",x.number," for xcont = ",xcont.number);}
		       	 for p in Uhash.list()
	      	       	 do if p.x = xcont
		       	    then Uhash.match(contragredient(p))
		    	    fi
		       	 od;
		         big_unitary_hash.finish(x,full_N1); {mark as done all lambdas for x}
		       	 big_unitary_hash.finishx(x)
		     fi
	 then () = if {C} skipx = false
	 then let lambdas = FPP_lambdas(x)
    	 then Ncases = #lambdas
	 then tempanswerCards = null(Ncases)
	 then templambdatimes = null(Ncases)
	 then () = if every_KGB_flag and FPP_report_flag
      	      	   then prints("     start KGBElt #", x.number, ", #lambdas = ",Ncases,
		   	       " Uhash.size() = ", Uhash.size(), ", runtime = ",
			       print_time_string(elapsed_ms() - start), ", #uparams so far = ",
			       sum(for list in answerCards do sum(list) od));
		   	prints("  ------------------")
        	   fi
	 then () = for lambda@index in lambdas
	      	   do let lamthlam = ((1+x.involution)*lambda).numer
		      then (Lvd1, Perm2{, mapAct}) = LPm_table.LPm_entry(G,x.involution,lamthlam)
		      then Lvd = if disconn_flag
		      	       	 then to_vertex_data(for v in Lvd1.list do M*v od, Lvd1.pair_start)
			   	 else Lvd1
				 fi
		      then  startlambda = elapsed_ms(), startUhash = Uhash.size(), startUcounter =
		      	    unitary_test_counter.use_count(), startUtime = unitaryTime,
			    startmorebadlambda = more_bad_hash.size(), startLF = elapsed_ms(),
			    startCcounter = char_counter.use_count(), startCtime = charTime
		      then () = if every_lambda_flag and FPP_report_flag
      	      	   	     	then prints("     start #", index, " = (",x,",",lambda,
					    "), Uhash.size() = ", Uhash.size(),
					    ", runtime = ", print_time_string(elapsed_ms() - start){,
			      		    ", #uparams so far = ",sum(answerCards)});
		   		   prints("  ------------------")
        	   		fi {every_lambda_flag}
		      then startDTcount = DTcount
 		      then LF = if by_zero_flag {and dominant(G,lamthlam)*G.two_rho_check > 0}
		      	      	then localFD_1Dirac2_by_zero(x_sc, M*lambda, Lvd, Perm2)
			   	else localFD_1Dirac2(x, lambda, Lvd, Perm2)
			   	fi
		      then () = if every_lambda_deets_flag and FPP_report_flag
    	      	      	      	then prints("time for localFD_1Dirac2* = ",
				print_time_string(elapsed_ms() - startLF),
				" to find [",#LF[0],",",#LF[1],"] verts and edges; Dirac eliminated ",
				DTcount - startDTcount)
	      		   	fi
		       in if #LF[0] = 0
			  then []
			  else if every_lambda_deets_flag
			       then face_verbose := old_face_verbose; time_verbose := old_time_verbose;
				    	 test_verbose :=old_test_verbose; test_slightly_verbose :=
					 	      old_test_slightly_verbose
			       fi;
			       let answer = local_test_GEO_hash_bottom_layer(x_sc, M*lambda,
			       	   	    Lvd, LF, pol_hash, Uhash, fancy_tester)
			       then y_scs = isotwistKGBs(x_sc)
			       then () = for y_sc in y_scs
					 do finish(y_sc,M*lambda)
					 od
			       then () = tempanswerCards[index] := #answer
			       then () = for qsc in answer
				       	 do for y_sc in y_scs
				     	    do let rsc = parameter(y_sc, qsc.lambda, qsc.nu)
				     	       then () = Uparamhash.match(rsc)
			             	       then () = if disconn_flag
					       	       	 then for r in sc_descends(rsc,G,M)
						    	      do Uparamhash.match(r)
						    	      od
					       	  	 fi
					        in for tsc in monomials(finalize(rsc))
				           	   do Uhash.match(tsc);
					      	      if disconn_flag
					      	      then for t in sc_descends(tsc,G,M)
						      	   do UhashG.match(t)
						   	   od
					       	       fi
					    	   od {tsc}
				      	     od {y_sc}
				    	   od{qsc}
 			 	 then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 in if every_lambda_flag and FPP_report_flag
				    then prints("  ",print_time_string(templambdatimes[index]),
			   	    " = time for (x,lambda) = (", x.number, ", #",index," = ",lambda, "), ht = ",
				    height(parameter(x,lambda,0*lambda)),", L = ", let (Q,) =
				    if small_test_flag then theta_stable_data_small(parameter(x,lambda,0*lambda))
				    else theta_stable_quasi_data(parameter(x,lambda,0*lambda))
				    fi in Q.Levi.Lie_type, ",",test_string);
				         if more_flag
					 then prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",
					      	tempanswerCards[index], ", #new unitary = ", Uhash.size() - startUhash,
						", #tests for this lambda = ", unitary_test_counter.use_count() - startUcounter,
						", time = ",print_time_string(unitaryTime - startUtime));
					      prints("     #char calcs for lambda = ", char_counter.use_count() - startCcounter,
					        ", char time = ", print_time_string(charTime - startCtime));
					      prints("     more_shift_level = ",if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params missed by more = ",
					     	more_bad_hash.size() - startmorebadlambda);
	    					report_tested()
					 else prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",
					      	tempanswerCards[index],
			     	                ", #new unitary = ", Uhash.size() - startUhash,
						", #tests for this lambda = ", unitary_test_counter.use_count() - startUcounter,
						", time = ",print_time_string(unitaryTime - startUtime));
					      prints("    #char calcs for lambda = ", char_counter.use_count() - startCcounter,
					       ", char time = ", print_time_string(charTime - startCtime));
					       report_tested()
					 fi ;
					 prints("  ------------------")
				    fi{every_lambda_flag}
			       fi{#LF = 0}
                 od {lambdas} {good_entries} {would be easy enough to get [Param] for each (x,lambda), but for now
		       just put unitary reps in Uhash}
    	   then () = if disconn_flag
	   	     then for j: Uhash.size()
		     	  do for p in sc_descends(Uhash.index(j), G, M)
			     do UhashG.match(p)
			     od
			  od
		     fi
            then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	    	     red_count_times[j] := red_count_time - former_red_count_time; currentUtime := unitaryTime;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     currentCcounter := char_counter.use_count(); answerCards[j] := tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag and FPP_report_flag
                     then  prints("     time for KGBElt ",x.number," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for ", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
			  if more_flag
			  then prints("       more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params missed by more for this x = ",
			     	       more_bad_hash.size() - startmorebadx)
			  fi;
			  prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary faces = ",
			     currentUhash - formerUhash, ", #tests for this x = ",
		     	     currentUcounter - formerUcounter, ", time in is_unitary = ", print_time_string(unitaryTime - formerUtime));
			     {", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count());}
			   prints("     Time spent in char calcs = ", print_time_string(charTime - formerCharTime),
			      	     ", number of char calcs = ", currentCcounter - formerCcounter,
				     ", time for red_count = ",print_time_string(red_count_times[j]));
			   report_tested()
                     fi {every_KGB_flag}
	   then () = big_unitary_hash.finish(x, full_N1) {mark as done all lambdas for x}
	   in big_unitary_hash.finishx(x)
	   fi {C}
           in ()
{
	 fi {contnum.>= and contnum < j}
	 fi {twnum.>= and twnum < j}

}
	 fi {twist(x) != x}
         od {xs}
    then () = face_verbose:=old_face_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    in if FPP_report_flag
       then prints("----------------");
       	    prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xs[longest].number);
	    if small_test_flag
	    then prints("Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime), ", #unitarity tests = ",
       		unitary_test_counter.use_count() - oldUcounter, ", #(x,lambda) studied = ", minSmallBottomData.size())
	    else prints("Time spent in is_unitary = ",print_time_string(unitaryTime - oldUtime), ", #unitarity tests = ",
       		unitary_test_counter.use_count() - oldUcounter, ", #K-types studied = ", minBottomData.size())
	    fi;
	    prints("Time spent in char calcs = ", print_time_string(charTime-oldcharTime), ", number of char calcs = ",
	        char_counter.use_count() - oldCcounter,
	      ", time spent in red_count = ",  print_time_string(red_count_time));
	    prints("Time in localFD_1Dirac2* = ", print_time_string(FD12Time + FD12bzTime),
	      ", in localFD_1Dirac2 = ",print_time_string(FD12Time),
	    	     ", in localFD_1Dirac2_by_zero = ",print_time_string(FD12bzTime));
	    prints("Time for built-in branch = ",print_time_string(branch_builtin_time), ", in script branch = ",
	    		 print_time_string(branch_script_time));
       	    prints("Time in derived_factor_K_types_info = ",print_time_string(dfkiTime),", time in natural KGB = ", print_time_string(nKeTime));
       	    prints("Time in min_bottom_factors = ",print_time_string(mbfTime), ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
       	    {prints("Time in bottom layer branching = ",print_time_string(rf_sig_tables.bottom_branch_time()),
       		    ", time in bottom layer sig = ", print_time_string(rf_sig_tables.bottom_sig_time()));}
       	    if more_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	   	      print_time_string(befmoreTime));
		 prints("     more_shift_level = ", if bl_interrupt_flag then
		    bl_step_count*bl_step_size else more_shift_level fi, ", #Params missed by more = ", more_bad_hash.size())
	    fi;
       	    prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(),",  #hash_dumb = ", hash_dumbCounter.use_count(),
	    	   ", #hash_def_dumb = ", hash_def_dumbCounter.use_count(),
	    	   ", #hash2 = ",hash2Counter.use_count(), ", #hash_one_level = ", hash_one_levelCounter.use_count(), ", #hash_bottom_layer = ",
	    hash_bottom_layerCounter.use_count());
       	    prints("Number of unitary params = ", sum(for list in answerCards do sum(list) od),
	    		   ", time for is_finished = ", print_time_string(is_finished_time),
			   ", time for position = ", print_time_string(position_time));
            prints("Number of known FPP-unitary faces = ",UhashG.size(),
       	      ", number found on this run = ", UhashG.size() - oldUhash);
	    report_tested()
      fi {FPP_report_flag}
   fi {#xs = 0}

set FPP_unitary_hash_bottom_layer([KGBElt] xs, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_bottom_layer(xs, big_unitary_hash.uhash(xs[0].real_form),fancy_tester)

set FPP_unitary_hash_bottom_layer(RealForm G, (Param->bool) fancy_tester) = void:
    FPP_unitary_hash_bottom_layer(KGB(G), fancy_tester)

{Following functions invoke David/Mason-Brown result from February 2025: if infl char is on
 some one-walls of the FPP, and those roots NOT in tau-invariatn, then rep is either non-unitary,
 or coh ind from the parabolic whose Levi omits those one-walls; so unitarity is determined on Levi.}
 
{does is_unitary on Levi by running FPP}
set recursive_tester_flag = false

{does is_unitary on Levi with FPP} {TTF}
set Lucas_full_rec() = void:
    is_FPP_unitary_flag:=true;
    recursive_tester_flag:= true;
    Lucas_fast_flag:=false

{does is_unitary on Levi one at a time}
set Lucas_non_rec() = void: {TFF}
    is_FPP_unitary_flag:=true;
    recursive_tester_flag:=false;
    Lucas_fast_flag:=false

{Lucas test, but no unitarity test on L}
set Lucas_fast() = void: {T*T}
    is_FPP_unitary_flag:=true;
    Lucas_fast_flag:=true

{don't apply test. This is now the default.}
set Lucas_no() = void: {F**}
    is_FPP_unitary_flag:=false

{meant to be used only on FPP reps p of simple G}
{Computes the (p.x,p.lambda) part of the unitary dual of p.real_form. That's good
if one is going to do a bunch of related is_unitary tests, for ex as in known_unitaries}
set MyFancyTester(Param p) = bool:
    let () = FPP_unitary_hash2([(p.x,p.lambda)], is_unitary_hash_big_SIMPLE@Param)
    {then () = prints("invoked MFT at p = ",p,", real form = ",p.real_form)}
    in big_unitary_hash.uhash(p.real_form).lookup(herm_center(p)).>=

set FPP_unitary_hash_def_dumb([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_def_dumb(xls, MyFancyTester@Param)
   else FPP_unitary_hash_def_dumb(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_def_dumb([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_def_dumb(xs, MyFancyTester@Param)
   else FPP_unitary_hash_def_dumb(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_def_dumb(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_def_dumb(rf, MyFancyTester@Param)
   else FPP_unitary_hash_def_dumb(rf, is_unitary_hash_big_SIMPLE@Param)
   fi


set FPP_unitary_hash_dumb([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_dumb(xls, MyFancyTester@Param)
   else FPP_unitary_hash_dumb(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_def_dumb([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_dumb(xs, MyFancyTester@Param)
   else FPP_unitary_hash_dumb(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_dumb(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_dumb(rf, MyFancyTester@Param)
   else FPP_unitary_hash_dumb(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash(rf, MyFancyTester@Param)
   else FPP_unitary_hash(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_one_level([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_one_level(xls, MyFancyTester@Param)
   else FPP_unitary_hash_one_level(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_one_level([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_one_level(xs, MyFancyTester@Param)
   else FPP_unitary_hash_one_level(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_one_level(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_one_level(rf, MyFancyTester@Param)
   else FPP_unitary_hash_one_level(rf, is_unitary_hash_big_SIMPLE@Param)
   fi



set FPP_unitary_hash2([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash2(xls, MyFancyTester@Param)
   else FPP_unitary_hash2(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash2([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash2(xs, MyFancyTester@Param)
   else FPP_unitary_hash2(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash2(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash2(rf, MyFancyTester@Param)
   else FPP_unitary_hash2(rf, is_unitary_hash_big_SIMPLE@Param)
   fi


set FPP_unitary_hash_bottom_layer([(KGBElt, ratvec)] xls) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_bottom_layer(xls, MyFancyTester@Param)
   else FPP_unitary_hash_bottom_layer(xls, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_bottom_layer([KGBElt] xs) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_bottom_layer(xs, MyFancyTester@Param)
   else FPP_unitary_hash_bottom_layer(xs, is_unitary_hash_big_SIMPLE@Param)
   fi

set FPP_unitary_hash_bottom_layer(RealForm rf) = void:
   if recursive_tester_flag
   then FPP_unitary_hash_bottom_layer(rf, MyFancyTester@Param)
   else FPP_unitary_hash_bottom_layer(rf, is_unitary_hash_big_SIMPLE@Param)
   fi

{all nu so parameter(x,lambda,nu) is in unitary hash for G}
set unitary_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let list = big_unitary_hash.uhash(G).list()
    in for p in list
       do if p.x = x and p.lambda = lambda then [p.nu]
	  else []
	  fi
       od.##

{one list for each (x,lambda)}
set unitary_nus(RealForm G) = [[[ratvec]]]:
    let answer = [[[ratvec]]]:
    	for x in KGB(G)
	do for lambda in FPP_lambdas(x)
	   do []
	   od
	od
     then list = big_unitary_hash.uhash(G).list()
     then () = for p in list
       	       do let answerx = answer[p.x.number]
	       	  then () = answerx[position(p.x, p.lambda)] #:= p.nu
	     	  in answer[p.x.number] :=answerx
	       od
      in answer


{all local vertex nu for (x,lambda). To be applied only to G simple mod center.}
set all_vertex_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let (Lvd,Perm2{, mapAct}) = LPm_table.LPm_entry(G,x.involution,((1+x.involution)*lambda).numer)
    then LF = if by_zero_flag {and height(parameter(x,lambda,0*lambda)) > 0}
	      then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2)
	      else localFD_1Dirac2(x, lambda, Lvd, Perm2)
	      fi
    then gammas = for v in LF[0] do Lvd.list[v[0]] od ##
    	 	  for w in LF[1] do face_bary(Lvd,w) od
    in for gamma in gammas
       do if is_final(parameter(x,lambda,gamma))
       	     and is_hermitian(parameter(x,lambda,gamma))
       	  then [gamma]
	  else []
	  fi
       od.##

{all nu so parameter(x,lambda,nu) is final nonunitary vertex or edge for G. To be applied only to
G simple mod center. Best applied after FPP unitary dual of G is computed.}
set non_unitary_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let params = for nu in all_vertex_nus(G, x, lambda)
    	 	  do parameter(x,lambda,nu)
		  od
    in for p in params
       do if is_final(p) and is_hermitian(p) 
       	     and not big_unitary_hash.check(p)
	  then [p.nu]
	  else []
	  fi
	od.##

{assume precompute has been done, so that all FPP unitary are known
for all derived simple factors of theta-stable Levis of G. For maximal LRi run
over unitary (xin,lambdainm) and put into unitary_hash all (x,lambda_nu) that are
induced from some PROPER real Levi. }
set theta_induced(RealForm G) = void:
    let maxLthis = max_Ls(G)
    then maxLthidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLthi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLthi in maxLthis
	 do derived_simple_factors_info(maxLthi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLthidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then unitary_nu_lists = [[[[[ratvec]]]]]:
    	 for Lidata in maxLthidatas
	 do for (,derLik,) in Lidata
	    do unitary_nus(derLik)
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLthidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLthidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]:
    	 for maxLthi in maxLthis
	 do KGB(maxLthi)
	 od
    then KGBEltGs = [[KGBElt]]:
    	 for maxLthi@i in maxLthis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from an Lthi}
    	 for maxLthi@i in maxLthis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then rhois = [ratvec]: for maxLthi in maxLthis do G.rho - maxLthi.rho od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis
     	     do for xin in list
	     	do derived_factor_KGBs0(xin)
	     od
	 od
    then lambdainms = [[[ratvec]]]: {one list of Lthi lambdas for each xin}
    	 for maxLthi@i in maxLthis
	 do for xin@n in KGB(maxLthi)
	    do for lambdaG in lambdainmGs[i][n]
	       do let lambda_testi = lambdaG - rhois[i]
	       	  then pintest = parameter(xin, lambda_testi, 0*lambda_testi)
		  then pintests = derived_factor_params0(pintest)
		  then lamtests = for pintest@k in pintests do pintest.lambda od
		   in if all(for lam@k in lamtests do position(KGBEltinks[i][n][k],lam).>= od)
		      then [pintest.lambda] {[ratvec]}
		      else []
		      fi
		od.## {m, but just keep some [ratvec]}
	   od {n}
	 od {i}
     then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdain, and derLik}
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params0(pinm)
		   then lambdas = for pinmk in pinmks do pinmk.lambda od
		   then xinms = for pinmk in pinmks do pinmk.x od
		   {then finalPinmks = for pinmk@k in pinmks
		   	     	      do if position(xinms[k], lambdas[k]) = -1
		   	     	      then []
				      else [pinmk]
				      fi
			     	      od.##}
		   in for pinmk in pinmks do pinmk.lambda od
		od
	     od
	  od
     then unitary_listinmks = [[[[[ratvec]]]]]:
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
	     	do for lambdainmk@k in lambdainmks[i][n][m]
		   do for nuinmj@j in unitary_nu_lists[i][k][KGBEltinks[i][n][k].number]
		      [position(KGBEltinks[i][n][k],lambdainmks[i][n][m][k])]
		      do Mikinvs[i][k]*nuinmj
		      od {[ratvec]}
		   od {[[ratvec]]}
	     	od {[[[ratvec]]]}
	     od
	  od
     then Binmks = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin
	     	do box(for unitary_listinmk in unitary_listinm do #unitary_listinmk od)
		od
	     od
	  od
     then nuinms = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin {unitary_listinm has two indices: k (simple factor)
	     and j (place on list)}
	        do for B in Binmks[i][n][m]
		   do sum(G.rank, for b@k in B do unitary_listinm[k][b] od)
		   od
		od
	     od
	  od
     then cands = [[Param]]: {one list on each maxLthi}
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do for nuinmj in nuinms[i][n][m]
		   do let pL = parameter(xin, lambdainm, nuinmj)
		      then gamma = pL.infinitesimal_character + rhois[i]
		      in if is_dominant(G,gamma) and is_dom_FPP(G,gamma) {need weakly good!}
		      	 then [pL]
			 else {prints("parameter ",pL," failed to be FPP");}
			      []
			 fi
		   od.## {list of relevant pL for this x,lambda}
		od.## {put all lambda together}
	     od.## {put all x together}
	  od {but keep a separate list for each max Levi maxLthi}
     {then bads = for list in cands
     	      	 do first (for pL in list do not is_unitary(pL) od)
		 od
     then () = if not bads.>=
     	       then badi = first (for f in bads do f.>= od)
	       else badi = -1}
     then () = for maxLthi@i in maxLthis
	     	  do for pL in cands[i]
	     	     do for q in monomials(theta_induce_irreducible(pL,G))
		   	do big_unitary_hash.umatch(herm_center(q))
			od
	     	     od
		  od
     in ()

{simple derived factors of all theta-stable Levis of G}
set SDLF(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for L in Ls(G) {these are PROPER Levis of theta-stable parabolics}
    	      ~do for Lj in derived_simple_factorsRF(L) {~ to put the small L first}
	      	  do answer.match(Lj)
	    	  od
	      	od
    in for k:answer.size()
       do answer.index(k)
       od

{these are the restricted fundamental weights for G: the ones defining maximal real parabolics
 at x_open(G)}
set resFund(RealForm G) = [ratvec]:
    let xo = x_open(G), simples = [vec]: G.simple_roots
    then theta = xo.involution
    then S0 = for j:G.semisimple_rank do if status(j,xo) = 1 then [j] else [] fi od.## {simple imag for M}
    then S1 = complement(G.semisimple_rank, S0)
    then Q0 = KGPElt: (S0,xo)
    then L0 = Q0.Levi
    then wL0 = w0(L0)
    then thetaL0 = matrix(wL0)
    then dualDelta = -theta*thetaL0 {preserves positive}
    then fixDual = for a in S1 do if dualDelta*simples[a] = simples[a] then [a] else [] fi od.##
    then pairsDual = for a in S1
    	 	     do for b:#simples - a-1 from a+1
    	 	       	do if dualDelta*simples[a] = simples[b]
			   then [[a,b]]
			   else []
			   fi
			od.##
		     od.##
    in for a in fixDual do G.fundamental_weights[a] od ##
       for v in pairsDual do G.fundamental_weights[v[0]] + G.fundamental_weights[v[1]] od

{all maximal real parabolics of G}
set max_QRs(RealForm G) = [KGPElt]:
    let xo = x_open(G)
    in for xi in resFund(G) do parabolic_by_wt(xi,xo) od

{all maximal real Levis of G}
set max_LRs(RealForm G) = [RealForm]:
    for QR in max_QRs(G) do QR.Levi od

{all real parabolics of G, starting with G and ending with MAN}
set QRs(RealForm G) = [KGPElt]:
    let xo = x_open(G), res_fund = resFund(G)
    then B = box(2,#res_fund)
    in for wt in columns(res_fund*B)
       do parabolic_by_wt(wt,xo)
       od

{simple derived factors of all real Levis of G}
set LRs(RealForm G) = [RealForm]:
    let Q_Rs = QRs(G)
    in if #Q_Rs = 1 then []
       else for QR in Q_Rs[1:]
    	    do QR.Levi
    	    od
       fi

{simple derived factors of all real Levis of G}
set SDLRF(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for LR in LRs(G) {these are PROPER Levis of real parabolics}
    	      ~do for LRk in derived_simple_factorsRF(LR) {tilde to put small LR first}
	      	  do answer.match(LRk)
	    	  od
	       od
    in for m:answer.size()
       do answer.index(m)
       od

{simple derived factors of all proper real and theta-stable Levis of G}
set SDLALL(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for L in Ls(G) {these are PROPER Levis of theta-stable parabolics}
    	      ~do for Lj in derived_simple_factorsRF(L) {~ to put the small L first}
	      	  do answer.match(Lj)
	    	  od
	      	od
    then () = for LR in LRs(G) {these are PROPER Levis of real parabolics}
    	      ~do for LRk in derived_simple_factorsRF(LR) {tilde to put small LR first}
	      	  do answer.match(LRk)
	    	  od
	       od
    then rank_lists = [[RealForm]]: for r:G.semisimple_rank do [] od
    then () = for k:answer.size()
      	      do let rf =answer.index(k)
	      	 in rank_lists[rf.semisimple_rank] #:= rf
       	      od
     in rank_lists.##

{assume precompute has been done, so that all FPP unitary are known
for all derived simple factors of real Levis of G. For maximal LRi run
over FPP (xin,lambdainm) and put into unitary_hash all (x,lambda_nu) that are
induced from some PROPER real Levi. }
set real_induced(RealForm G) = void:
    let maxLRis = max_LRs(G)
    then maxLRidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLRi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLRi in maxLRis
	 do derived_simple_factors_info(maxLRi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then unitary_nu_lists = [[[[[ratvec]]]]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do unitary_nus(derLik)
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLRidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLRidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]: {one list on maxLRi for each i}
    	 for maxLRi in maxLRis
	 do KGB(maxLRi)
	 od
    then KGBEltGs = [[KGBElt]]:
    	 for maxLRi@i in maxLRis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from an LRi}
    	 for maxLRi@i in maxLRis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then lambdainms = [[[ratvec]]]: {one list of LRi lambdas for each xin}
    	 for maxLRi@i in maxLRis
	 do let rhoi = G.rho - maxLRi.rho
	    in for n:#KGB(maxLRi)
	       do for lambdaG in lambdainmGs[i][n]
	       	  do lambdaG - rhoi
		  od
	       od
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis {indexed by i}
     	     do for xin in list {indexed by n}
	     	do derived_factor_KGBs0(xin) {indexed by k}
	     od
	 od
     then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdain, and derLik}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params0(pinm)
		   in for pinmk@k in pinmks
		      do {if position(pinmk.x,pinmk.lambda).>=
		      {is_FPP(derLiks[i][k], pinmk.infinitesimal_character)}
		      	 then [}pinmk.lambda{]}
			 {else prints("not in FPP_lambdas(x) ",pinmk); []
			 fi}
		      od{.##}
		od
	     od
	  od
     then unitary_listinmks = [[[[[ratvec]]]]]:
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n] {list of lambdas for xin on maxLRi}
	     	do for lambdainmk@k in lambdainmks[i][n][m] {factor on derLik}
		   do let m = position(KGBEltinks[i][n][k],lambdainmk)
		      in if m.>=
		      	 then for nuinmj@j in unitary_nu_lists[i][k][KGBEltinks[i][n][k].number][m]
		      {[position(KGBEltinks[i][n][k],lambdainmks[i][n][m][k])]}
			      do Mikinvs[i][k]*nuinmj
		      	      od {[ratvec]}
			 else []
			 fi
		   od {[[ratvec]]}
	     	od {[[[ratvec]]]}
	     od
	  od
     then Binmks = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin
	     	do box(for unitary_listinmk in unitary_listinm do #unitary_listinmk od)
		od
	     od
	  od
     then nuinms = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin {unitary_listinm has two indices: k (simple factor)
	     and j (place on list)}
	        do for B in Binmks[i][n][m]
		   do sum(G.rank, for b@k in B do unitary_listinm[k][b] od)
		   od
		od
	     od
	  od
     then cands = [[Param]]: {one list on each maxLRi}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do for nuinmj in nuinms[i][n][m]
		   do let pL = parameter(xin, lambdainm, nuinmj)
		      then gamma = dominant(G,pL.infinitesimal_character)
		      in if is_FPP(G,gamma)
		      	 then [pL]
			 else {prints("parameter ",pL," failed to be FPP");}
			      []
			 fi
		   od.## {list of relevant pL for this x,lambda}
		od.## {put all lambda together}
	     od.## {put all x together}
	  od {but keep a separate list for each max Levi maxLRi}
     then () = for maxLRi@i in maxLRis
	     	  do for pL in cands[i]
	     	     do for q in monomials(real_induce_irreducible(pL,G))
		   	do let qdeflist = [q]## for Qdef in local_defs(q)
			   	      	    	do monomials(composition_series(Qdef))
					    	od.##
			   in for qdef in qdeflist
			      do big_unitary_hash.umatch(herm_center(qdef))
			      od
			od
	     	     od
		  od
     in ()

set NUR_verbose = true

set non_unitary_real_induced(RealForm G) = Param_hash:
    let maxLRis = max_LRs(G), NUhash = make_Param_hash()
    then maxLRidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLRi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLRi in maxLRis
	 do derived_simple_factors_info(maxLRi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLRidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLRidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]: {one list for each max real Levi LRi}
    	 for maxLRi in maxLRis
	 do KGB(maxLRi)
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis
     	     do for xin in list
	     	do derived_factor_KGBs0(xin)
	     od
	 od
    then KGBEltGs = [[KGBElt]]: {one list for each maxLRi}
    	 for maxLRi@i in maxLRis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
	 {need to know which lambdainm on maxLRi for xin can induce to FPP on G. Maybe this is some of them??}
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from a maxLRi}
    	 for maxLRi@i in maxLRis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then lambdainms = [[[ratvec]]]: {one list of LRi lambdas for each xin; omit those that don't descent to FPP}
    	 for maxLRi@i in maxLRis
	 do let rhoi = G.rho - maxLRi.rho
	    in for xin@n in KGB(maxLRi)
	       do for lambdaG in lambdainmGs[i][n]
	       	  do let lambda_testi = lambdaG - rhoi
		     then pintest = parameter(xin, lambda_testi, 0*lambda_testi)
		     then pintests = derived_factor_params0(pintest)
		     then lamtests = for pintest@k in pintests do pintest.lambda od
		     in if all(for lam@k in lamtests do position(KGBEltinks[i][n][k],lam).>= od)
		     	then [pintest.lambda] {[ratvec]}
			else []
			fi
		  od.## {m, but just keep some [ratvec]}
	       od {n}
	 od {i}
         then () = if NUR_verbose
     	       	   then prints("In non_unitary_real_induced, considering ",sum(
		   for listi@i in lambdainms
		   do for listn@n in listi
		      do for listm@m in listn
		      	 do #listm
			 od
		      od.##
		   od.##), " triples (Li, xin, lambdainm).")
		   fi
    {then () = prints(lambdainms)}
    then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdainm, and derLik}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params0(pinm)
		   in for pinmk in pinmks do pinmk.lambda od {[ratvec]}
		od
	     od
	  od
    {indices are max Levi i, KGBElt n, lambda m}
     then ratvec_hashes = [[[ratvec_hash]]]:
          for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
	     	do make_ratvec_hash()
		od {m}
	     od {n}
	  od {i}
     {indices are max Levi i, KGBElt n, lambda m, derived factor k, nu j}
     then all_listinmks = [[[[[ratvec]]]]]:
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainmks[i][n]
	     	do if #lambdainm <= 1
		   then [[ratvec]]:[[]] {indices k and j}
		   else for lambdainmk@k in lambdainm
		      	do for nuinmj@j in all_vertex_nus(derLiks[i][k],KGBEltinks[i][n][k], lambdainmk)
		      	   do Mikinvs[i][k]*nuinmj
		      	   od {[ratvec], one for each j}
		      	od {one for each k and j [[ratvec]]}
		   fi
		od {one for each lambdainm on maxLRi [[[ratvec]]]}
	     od {xin on maxLRi [[[[ratvec]]]]}
	  od {maxLRi [[[[[ratvec]]]]] }
     {indices are max Levi i, KGBElt n, lambda m, nonunitary factor k0, derived factor k, nu j}
     then non_unitary_listinmk0ks = [[[[[[ratvec]]]]]]: {k0 is the nonunitary factor}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainmks[i][n]
	     	do if #lambdainm = 0
		   then [[[ratvec]]]:[[[]]]
		   else for k0:#lambdainm
		    	do let list = all_listinmks[i][n][m] {[[ratvec]]}
			   {then () = prints(new_line, "ALL at ",[i,n,m,k0]," ",list)}
			   then () = list[k0] := {replace list k0 by nonunitary nu's}
			   	for nuinmj@j in non_unitary_nus(derLiks[i][k0],KGBEltinks[i][n][k0],
			   	   	       	   lambdainm[k0])
				do Mikinvs[i][k0]*nuinmj
				od
		           {then () = prints("NU ",list)}
			   in list {[[ratvec]]}
			od {keep track of which factor is nonunitary; [[[ratvec]]]}
		    fi
	     	od {one for each lambdainm on maxLRi [[[ratvec]]]}
	     od {xin on maxLRi [[[[[ratvec]]]]]}
	  od {maxLRi [[[[[ratvec]]]]]] }
{need to take every nu that's non-unitary (vertex) on one derLik, arbitrary on the other (verts). This will
make a rep non-unitary on maxLRi. If induction to G is irreducible, add it.}
     {then () = prints(non_unitary_listinmk0ks)}
     then Binmk0ks = for non_unitary_listi@i in non_unitary_listinmk0ks {[[[[[ratvec]]]]]}
     	  	   do for non_unitary_listin@n in non_unitary_listi {[[[[ratvec]]]]}
	     	      do for non_unitary_listinm@m in non_unitary_listin {[[[ratvec]]]}
		      	 do for non_unitary_listinmk0 in non_unitary_listinm
	     		    do box(for non_unitary_listinmk0k in non_unitary_listinmk0 do #non_unitary_listinmk0k od)
			    od
			 od
	     	      od
	  	   od
     then () = for non_unitary_listi@i in non_unitary_listinmk0ks
     	  do for non_unitary_listin@n in non_unitary_listi
	     do for non_unitary_listinm@m in non_unitary_listin 
	     	do for non_unitary_listinmk0@k0 in non_unitary_listinm
		   {unitary_listinmk0 has two indices: k (simple factor) and j (place on list)}
	           do for B in Binmk0ks[i][n][m][k0]
		      do {prints([i,n,m,k0]);}
		      	 let nu = sum(G.rank, for b@k in B do non_unitary_listinmk0[k][b] od)
		      	 in ratvec_hashes[i][n][m].match(nu)
			 {in prints(nu)}
			 {in nu}
		      od {B}
		   od {k0}
		od {m}
	     od {n}
	  od {i}
     then () = if NUR_verbose
     	       then prints("In non_unitary_real_induced, considering ",sum(
		   for listi@i in ratvec_hashes
		   do for listn@n in listi
		      do for hashm@m in listn
		      	 do hashm.size()
			 od
		      od.##
		   od.##), " quadruples (Li, xin, lambdainm, nuinmj).")
	       fi
     {then IG = big_unitary_hash.rf_number(G)}
     then () = for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do let nu_list = ratvec_hashes[i][n][m].list()
		   in for nu in nu_list
		      do let pL = parameter(xin, lambdainm, nu)
		      	 {then () = if is_unitary(first_param(finalize(pL)))
		      	      	   then prints("OOPS! ",[i,n,m,k0], " pL = ")
				   fi}
		      	 then gamma = dominant(G,pL.infinitesimal_character)
			 in if is_hermitian(pL) and is_FPP(G,gamma)
		      	    then let P = real_induce_irreducible(pL,G)
			    	 {then () = prints("pL = ", pL)}
		      	    	 in if #P = 1
				    then NUhash.match(herm_center(first_param(P)))
				    fi
			    fi
		      od {nu}
		od {m}
	     od {n}
	  od {i}
     in NUhash

{get complete FPP dual for each derived simple factor of a theta-stable Levi; and then cohom ind
all those things in weakly good range to G}
set pre_bottom_flag = false
set pre_def_dumb_flag = false
set precomputeTheta(RealForm G) = void:
    let rflist = SDLF(G)
    then () = coh_ind_all_flag:=false
    then () = coh_ind_most_flag:=false
    {then () = coh_ind_few_flag:=false}
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do prints("starting # ",k," = ",rf);
	      	 theta_induced(rf);
		 real_induced(rf);
	 	 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 elif pre_def_dumb_flag
		 then FPP_unitary_hash_def_dumb(rf)
		 else FPP_unitary_hash2(rf)
		 fi
	      od
    then () = FPP_report_flag:=temp_report_flag
    in theta_induced(G)

set precomputeR(RealForm G) = void:
    let rflist = SDLRF(G)
    then () = coh_ind_all_flag:=false
    then () = coh_ind_most_flag:=false
    {then () = coh_ind_few_flag:=false}
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do prints("starting # ",k," = ",rf);
	      	 real_induced(rf);
		 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 elif pre_def_dumb_flag
		 then FPP_unitary_hash_def_dumb(rf)
		 else FPP_unitary_hash2(rf)
		 fi
	      od
    then () = FPP_report_flag:=temp_report_flag
    in real_induced(G)

{ set precomputeNUR(RealForm G) = Param_hash:
    let rflist = SDLRF(G), start = elapsed_ms()
    then () = coh_ind_all_flag:=false
    then () = coh_ind_most_flag:=false
    {then () = coh_ind_few_flag:=false}
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do prints("starting # ",k," = ",rf);
	      	 {real_induced(rf);}
		 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 elif pre_def_dumb_flag
		 then FPP_unitary_hash_def_dumb(rf)
		 else FPP_unitary_hash2(rf)
		 fi;
		 big_unitary_hash.nuhash_fill(rf);
		 prints("found ",big_unitary_hash.nuhash(rf).size(), " nonunitary reps")
	      od
    then () = FPP_report_flag:=true
    then NUhash = non_unitary_real_induced(G)
    in prints("In time ",print_time_string(elapsed_ms() - start)," found ", NUhash.size(),
       	      " nonunitary reps.")}

set precomputeALL(RealForm G) = void:
    let start = elapsed_ms(), rflist = SDLALL(G)
    then () = coh_ind_all_flag:=false
    then () = coh_ind_most_flag:=false
    {then () = coh_ind_few_flag:=false}
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do real_induced(rf);
		 theta_induced(rf);
		 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 elif pre_def_dumb_flag
		 then FPP_unitary_hash_def_dumb(rf)
		 else FPP_unitary_hash2(rf)
		 fi;
		 prints("At time ",print_time_string(elapsed_ms() - start), ", finished # ",k,"/",
	      	 	    #rflist," = ",rf, ", #FPPreps = ",big_unitary_hash.uhash(rf).size())
	      od
    then FPP_time = elapsed_ms()
    then () = FPP_report_flag:=temp_report_flag
    then N0 = big_unitary_hash.uhash(G).size()
    then () = real_induced(G)
    then NR = big_unitary_hash.uhash(G).size()
    then () = prints("In ",print_time_string(elapsed_ms() -FPP_time), ", real induction found ",NR-N0,
    	      		 " FPP unitary faces for G.")
    then RI_time = elapsed_ms()
    then () = theta_induced(G)
    then NTheta =  big_unitary_hash.uhash(G).size()
    then () = prints("In ",print_time_string(elapsed_ms() -RI_time), ", coh induction found additional ",NTheta-NR,
       		  	" FPP unitary faces for G.")
    then Th_time = elapsed_ms()
    then unips = unipotent_representations(G), IG = big_unitary_hash.rf_number(G)
    then () = for p in unips do big_unitary_hash.long_umatch(p,IG) od
    then NUnip =  big_unitary_hash.uhash(G).size()
    then () = prints("In ",print_time_string(elapsed_ms() -Th_time), ", found additional ",NUnip - NTheta,
       		  	" unipotent faces for G.")
    in prints("Altogether found ",NUnip-N0, " FPP unitary faces for G.")

set FPPpre(RealForm G) = void:
    let start = elapsed_ms()
    then temp_KGB_flag = every_KGB_flag
    then () = every_KGB_flag:= false
    then () = precomputeALL(G)
    then () = every_KGB_flag := temp_KGB_flag
    then () = if pre_bottom_flag
       	      then FPP_unitary_hash_bottom_layer(G)
	      elif pre_def_dumb_flag
	      then FPP_unitary_hash_def_dumb(G)
       	      else FPP_unitary_hash2(G)
       	      fi
    in prints("Total time required was ",print_time_string(elapsed_ms() - start))
