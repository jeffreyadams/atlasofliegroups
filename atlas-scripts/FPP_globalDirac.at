<K_highest_weights {for all_lambda_differential_zero}
<lattice {for vec_solve}
{ <chopping_facets_fast.at {for chop_coroots(G, vertices)}}
<facet_classes {for ordering on facets}
<hash {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<FPP_localDirac
<cohIndUnip {for weakly fair cohom ind}
<derived_cover {for simply connected cover of derived group}
{functions for computing the entire FPP_unitary dual}
{typically functions take a Param_hash Uhash and fill it with all
unitary reps having infinitesimal character in the FPP. Each p is
replaced by herm_center(p), at the barycenter of its local facet,
so that the lists are finite.}

{. This controls the maximum denominator size kept in chop_coroots,
used in moving unitarity information from a Levi to G. Large values
allow more chopped facets, and so convey more information to G; but
small values are faster. Too small a value cannot lead to wrong
answers, but only to running more is_unitary tests .}
set chop_bound = int: 6

{if true, compute reps weakly fair cohom induced from Arthur unipotent}
set coh_ind_flag = false

{if true, load Arthur unipotent reps into unitary hash before starting FPP.
Computing Arthur unipotents takes a long time for high rank (e.g. rank 4
complex}
set unip_flag = true

{next functions aim to compute FULL spherical dual in non-split case,
when several different x give spherical reps}

{if facet_verbose is true, report after each |lambda_skip| lambda's
are treated in FPP_unitary}
set lambda_skip = int:10

{if true, then report summary each lambda in FPP_unitary}
set every_lambda_flag = false

{if true, then report progress during each lambda in FPP_unitary}
set every_lambda_deets_flag = false

{if true, then report summary each KGBElt in FPP_unitary}
set every_KGB_flag = false

{if true, uses the (faster?) function localFD_1Dirac2_by_zero to compute local vertices and edges}
{seems SLOWER in F4, E7}
set by_zero_flag = true

set contragredient(KGBElt x) = KGBElt:
    let wzero = w0(x.root_datum) in cross(wzero,x)

set contragredient(KGBElt x, ratvec lambda) = (KGBElt, ratvec):
    let p = contragredient(parameter(x,lambda,0*lambda))
    in (p.x, p.lambda)

{cheating with x.number means list has repetitions; tries to add to KGB(SU(p,q) KGBElts for SU(q,p)}
set isotwistKGBs(KGBElt x) = [KGBElt]:
    let G = x.real_form, theta = x.involution, tf = x.torus_factor, rd = x.root_datum
    {then p = parameter(x,G.rho, G.rho)
    then dp = p.dual}
    then twists = all_even_lambda_differential_0(rd.dual, -theta.^), X = KGB(G)
    in for tau in twists do X[KGB_elt(rd, theta, tf + tau).number] od

set spherical_xs(RealForm G) = [KGBElt]:
    let real_rank = rank(x_open(G).involution + 1)
    in for x in KGB(G)
       do if rank(x.involution + 1) = real_rank
       	  then [x]
	  else []
	  fi
       od.##

{meant to hold barycenters of unitary facets}
set unitary_hash = make_Param_hash()

{meant to hold all unitary parameters found (maybe not final}
{set uparam_hash = make_Param_hash()}

{load a bunch of Param_hash's into one}
set transfer([Param_hash] Us, Param_hash target) = void:
    for U in Us
    do for j:U.size()
       do target.match(U.index(j))
       od
    od

{derived simple factors of all Levis of theta-stable P, omitting P=G}
set DSFLevis(RealForm G) = [RealForm]:
    for P in theta_stable_parabolics(G)~[1:]
    do derived_simple_factors(P.Levi) od.##

set DSFLevi_hash(RealForm G) = RealForm_hash:
    make_RealForm_hash(DSFLevis(G), hash_code@(RealForm,int))

{if false, suppress printing of report after an FPP_unitary_hash* job}
set FPP_report_flag = true

{uses LPm_table to keep track of local facet info}
set FPP_unitary_hash_general([(KGBElt,ratvec)] xlambdas, Param_hash Uhash,
    {Param_hash Uparamhash,} (KGBElt, ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
    if #xlambdas = 0 then return ()
    else let (x,) = xlambdas[0]
    then G = x.real_form
    then {vd = FPP_vertex_data(G),} start = elapsed_ms(),  zeroNu = null(G.rank)/1
    then () = unitaryTime := 0
    then () = prepDirac(G)
    then xnums = for (x,) in xlambdas do let (,m) = %x in m od
    then lambdas = for (,lambda) in xlambdas do lambda od, pol_hash = make_KTypePol_hash()
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then startLPmss = elapsed_ms()
    then LPmss = for (x,lambda) in xlambdas
    	       	 do LPm_table.LPm_entry(G,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
              	 od
    {then () = if every_lambda_deets_flag
    	      then prints("time thru LPmss = ",print_time_string(elapsed_ms() - start))
	      fi}
    then () = facet_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_flag 
    	      then coh_ind_unip_long(G,Uhash) {this takes several seconds for F4_s}
	      fi
    then xlambdatimes = [int]: null(#xlambdas)
    then answerCards = [int]: null(#xlambdas) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    then startgf = elapsed_ms()
    {then () = adjust_global_top(G)}
    {then () = prints("time thru global_facets = ",print_time_string(elapsed_ms() - start))}
    {then () = global_facets_by_zero := low_FPP_facets_by_zero(global_facets)}
    {then () = prints("time thru global_facets_by_zero = ",print_time_string(elapsed_ms() - start))}
    then current = elapsed_ms(), oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 	   oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
    {then () = if every_lambda_deets_flag
    	      then prints("time up to main loop = ",print_time_string(elapsed_ms() - start))
	      fi}
    then () = for (x,lambda)@k in xlambdas
    	      do {xlambdas} 
	 	 let startxl = elapsed_ms(), startUhash = Uhash.size(),
		     		   startUcounter = unitary_test_counter.use_count(), theta = x.involution
		 then p0 = parameter(x,lambda,zeroNu)
		 {then () = prints("time before LPmss[",k,"] = ",print_time_string(elapsed_ms() - start))}
		 then (Lvd, Perm2, mapAct) = LPmss[k]
		 {then startLF = elapsed_ms()
		 then () = prints("time thru LPmss[",k,"] = ",print_time_string(startLF - start))}
		 then LF = if by_zero_flag and height(p0) > 0
		      	   then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2, mapAct)
			   else localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct)
			   fi
		 {then () = if every_lambda_deets_flag
    	      	      	   then prints("time for localFD_1Dirac = ",print_time_string(elapsed_ms() - startLF))
	      		   fi}
		 in if #LF[0] = 0 then ()
		     else if every_lambda_deets_flag
			  then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
			       test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			  fi;
			  let answer = local(x, lambda, LPm_table.FPP_vertex_data(G) , Lvd, LF, pol_hash, Uhash)
			  then () = answerCards[k] := #answer
			  {then () = for p in answer do Uparamhash.match(p) od}
   		    	  then () = current := elapsed_ms(); currentUhash := Uhash.size();
			       	    currentUcounter := unitary_test_counter.use_count()
    		 	  then () = xlambdatimes[k] := current - startxl
    			  in if every_lambda_flag
	      		     then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) = (", xnums[k], ",",k{lambdas[k]},")", test_string);
			         prints("    #LF = ", for L in LF do #L od, "; #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests = ", unitary_test_counter.use_count() - startUcounter);
				 prints("  ------------------")
			     fi
		    fi
		 od{xlambdas}
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    in if FPP_report_flag
       then prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xnums[longest], ",",
	      lambdas[longest],")");
       	    prints(" time spent in is_unitary = ",print_time_string(unitaryTime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count());
       	    if mix_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift = ", more_shift, ", #Params missed by more = ", more_bad_hash.size())
	    fi;
       	    prints("  #hash_real_dumb =",hash_real_dumbCounter.use_count(), ", #hash_dumb calls=", hash_dumbCounter.use_count(),
       	      	 	   ", #hash_def_dumb =", hash_def_dumbCounter.use_count());
       	    prints("  #hash =", hashCounter.use_count(), ", #hash2 =", hash2Counter.use_count(),
	      	 	", #hash_one_level =", hash_one_levelCounter.use_count(), ", #hash_bottom_layer = ",
			hash_bottom_layerCounter.use_count());
       	    prints("Number of unitary params = ", sum(answerCards), ", time for is_finished = ",
	    print_time_string(is_finished_time), ", time for position = ",
	    print_time_string(position_time));
       	    prints("Number of FPP-unitary facets = ",Uhash.size(), ", number found on this run = ", Uhash.size() - oldUhash)
       fi {FPP_report_flag}
       fi {#xlambdas = 0}

set FPP_unitary_hash_general([KGBElt] xs, Param_hash Uhash, {Param_hash Uparamhash,}
    (KGBElt, ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
    if #xs = 0
    then return ()
    else
    {let () = deform_flag:=true}
    let () = if tilde_flag
    	      then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      fi
    then G = xs[0].real_form
    then start = elapsed_ms(), zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then () = unitaryTime := 0
    then () = prepDirac(G)
    then {xnums = for x in xs do let (,m) = %x in m od, xtimes = null(#xs),} pol_hash = make_KTypePol_hash()
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = facet_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,Uhash)
	      fi
    then times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
     then current = elapsed_ms()
    then oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
    then () = for x@j in xs
    	      do {xs}
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter
	 then xtwists = isotwistKGBs(x), twists = all_lambda_differential_0(x)
	 then M = #FPP_lambdas(x)
	 then full_M = to_bitset([M])-1
	 then tw = first(for y in xtwists[1:]
	      	   	 do full_M = big_unitary_hash.xl_known(G)[y.number]
			 od)
	 then xtwist = if tw.>=
	      	       then {prints("skipping x = ",x.number," for xtwist = ",xtwists[tw].number);} xtwists[tw]
		       else x
		       fi
	 then twnum = if xtwist != x
	      	      then first(for y in xs do xtwist = y od)
		      else -1
		      fi
	 in if twnum.>=  and twnum < j {now xtwist is xs[twnum]}
	    then answerCards[j]:= answerCards[twnum];
	    	 {prints("skipping x = ",x.number," for xtwist = ",xtwist.number);}
		 big_unitary_hash.finish(x, full_M); {mark as done all lambdas for x}
		 for ell:Uhash.size()
	      	 do let p = Uhash.index(ell)
		    in if p.x = xtwist
		       then Uhash.match(parameter(x, p.lambda, p.nu))
		       fi
		 od
	    else let xcont = contragredient(x)
	    	 then contnum = if xcont != x
		      	      	then first(for y in xs do xcont = y od)
				else -1
				fi
	    	 in if contnum.>= and contnum < j {now xcont is xs[contnum]}
	    	    then answerCards[j]:= answerCards[contnum];
		         big_unitary_hash.finish(x,full_M); {mark as done all lambdas for x}
		       for ell:Uhash.size()
	      	       do let p = Uhash.index(ell)
		       	  in if p.x = xcont
		       	     then Uhash.match(contragredient(p))
		    	     fi
		       od
	     	    else let lambdas = FPP_lambdas(x) 
    	 	    	 then Ncases = #lambdas
	 		 then tempanswerCards = null(Ncases)
	 		 then templambdatimes = null(Ncases)
	 		 then () = if every_KGB_flag
      	      	   	      then prints("     start KGBElt #", x.number, ", #lambdas = ",#lambdas,
		   	       " Uhash.size() = ", Uhash.size(), ", runtime = ",
			       	 print_time_string(elapsed_ms() - start), ", #uparams so far = ",
			       sum(for list in answerCards do sum(list) od));
		   		   prints("  ------------------")
        	   		   fi {every_KGB_flag}
	 		 then () = for lambda@index in lambdas
	      	   	      	   do let lamthlam = ((1+x.involution)*lambda).numer
		      		      then (Lvd, Perm2, mapAct) = LPm_table.LPm_entry(G,x.involution,lamthlam)
		      		      then  startlambda = elapsed_ms(), startUhash = Uhash.size(), startUcounter =
		      	    	      	    unitary_test_counter.use_count()
 		      		      then LF = if by_zero_flag and dominant(G,lamthlam)*G.two_rho_check > 0
		      	      	      	      	then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2, mapAct)
			   			else localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct)
			   			fi {by_zero_flag}
			 in if #LF[0] = 0
			    then []
			    else if every_lambda_deets_flag
			       	 then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
				    	 test_verbose :=old_test_verbose; test_slightly_verbose :=
					 	      old_test_slightly_verbose
				 fi;
				 let answer = local(x, lambda, LPm_table.FPP_vertex_data(G), Lvd, LF, pol_hash, Uhash)
			  	 then () = tempanswerCards[index] := #answer
			  	 {then () = for p in answer do Uparamhash.match(p) od}
				 then () = if every_lambda_deets_flag
			    	      	   then facet_verbose := false; time_verbose := false;
				 	   	test_verbose := false; test_slightly_verbose := false
				 	   fi
 			 	 then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 in if every_lambda_flag
				    then prints("  ",print_time_string(templambdatimes[index]),
			   	    	 	" = time for (x,lambda) = (", x.number, ",",
						lambda, ")", test_string);
				         prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",
					 	 tempanswerCards[index],
			     	                ", #new unitary = ", Uhash.size() - startUhash,
						", #tests = ", unitary_test_counter.use_count() - startUcounter);
					 prints("  ------------------")
				    fi{every_lambda_flag}
			      fi{#LF[0] = 0}
                   od{lambda} {would be easy enough to get [Param] for each (x,lambda), but for now just put unitary reps in Uhash}
           then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     answerCards[j]:= tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag
                     then  prints("     time for KGBElt ",x.number," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for #", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
			  prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary facets = ",
			     currentUhash - formerUhash, ", #tests = ",
		     	     currentUcounter - formerUcounter, ", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count())
                     fi
	   then () = big_unitary_hash.finish(x, full_M) {mark as done all lambdas for x}
           in ()
	   fi {contnum.>= and contnum < j}
	   fi {twnum.>=  and twnum < j}
         od {xs}
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    in if FPP_report_flag
       then prints("----------------");
       	    prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xs[longest].number);
       	    prints("Time spent in is_unitary = ",print_time_string(unitaryTime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count());
       	    if mix_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift = ", more_shift, ", #Params missed by more = ",
		    more_bad_hash.size())
	    fi;
       	    prints("  #hash_real_dumb =",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb =", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb =", hash_def_dumbCounter.use_count());
       	    prints("  #hash =", hashCounter.use_count(),
	      ", #hash2 =", hash2Counter.use_count(),
	      ", #hash_one_level =", hash_one_levelCounter.use_count(),
              ", #hash_bottom_layer =", hash_bottom_layerCounter.use_count());
       	    prints("Number of unitary params = ", sum((for list in answerCards do sum(list) od)),
	    		   ", time for is_finished = ", print_time_string(is_finished_time),
			   ", time for position = ", print_time_string(position_time));
      	    prints("Number of known FPP-unitary facets = ",Uhash.size(),
       	      ", number found on this run = ", Uhash.size() - oldUhash)
      fi {FPP_report_flag}
   fi {#xlambdas = 0}

set FPP_unitary_hash_general(RealForm G,Param_hash Uhash, {Param_hash Uparamhash,}
    (KGBElt,ratvec,VertexData,VertexData, [[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
    if is_compact(G)
    then for p in all_parameters_gamma(G,G.rho)
    do Uhash.match(p) od
    else
    FPP_unitary_hash_general(KGB(G), Uhash, {Uparamhash,} local)
    fi

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    let () = real_flag:=true in
    FPP_unitary_hash_general(xlambdas, Uhash, {Uparamhash,} local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_real_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash_real_dumb([KGBElt] xs, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xs, Uhash, {Uparamhash,} local_test_GEO_hash_real_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_real_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_real_dumb(xs, big_unitary_hash.uhash(xs[0].real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash_real_dumb(RealForm G) = void:
    FPP_unitary_hash_real_dumb(KGB(G))

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xlambdas, Uhash, {Uparamhash,} local_test_GEO_hash_def_dumb@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_def_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash_def_dumb([KGBElt] xs, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xs, Uhash, {Uparamhash,} local_test_GEO_hash_def_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_def_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_def_dumb(xs, big_unitary_hash.uhash(xs[0].real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash_def_dumb(RealForm G) = void:
    FPP_unitary_hash_def_dumb(KGB(G))

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    let () = def_flag:=false in
    FPP_unitary_hash_general(xlambdas, Uhash{, Uparamhash}, local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_dumb(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash_dumb([KGBElt] xs, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    let () = def_flag:=false in
    FPP_unitary_hash_general(xs, Uhash, {Uparamhash,} local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_dumb(xs, big_unitary_hash.uhash(xs[0].real_form){unitary_hash}{, uparam_hash})

set FPP_unitary_hash_dumb(RealForm G) = void:
    FPP_unitary_hash_dumb(KGB(G))

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, {Uparamhash,} local_test_GEO_hash@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash([KGBElt] xs, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    FPP_unitary_hash_general(xs, Uhash, {Uparamhash,} local_test_GEO_hash@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash([KGBElt] xs) = void:
    FPP_unitary_hash(xs, big_unitary_hash.uhash(xs[0].real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash(RealForm G) = void:
    FPP_unitary_hash(KGB(G), big_unitary_hash.uhash(G) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, {Uparamhash,} local_test_GEO_hash2@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash2(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash2([KGBElt] xs, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    FPP_unitary_hash_general(xs, Uhash, {Uparamhash,} local_test_GEO_hash2@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash2([KGBElt] xs) = void:
    FPP_unitary_hash2(xs, big_unitary_hash.uhash(xs[0].real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash2(RealForm G) = void:
    FPP_unitary_hash2(KGB(G))

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, {Uparamhash,} local_test_GEO_hash_one_level@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_one_level(xlambdas, let (x,) = xlambdas[0] in big_unitary_hash.uhash(x.real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash_one_level([KGBElt] xs, Param_hash Uhash{, Param_hash Uparamhash}) = void:
    FPP_unitary_hash_general(xs, Uhash, {Uparamhash,} local_test_GEO_hash_one_level@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_one_level([KGBElt] xs) = void:
    FPP_unitary_hash_one_level(xs, big_unitary_hash.uhash(xs[0].real_form) {unitary_hash}{, uparam_hash})

set FPP_unitary_hash_one_level(RealForm G) = void:
    FPP_unitary_hash_one_level(KGB(G))

set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas, Param_hash UhashG{, Param_hash Uparamhash}) = void:
    if #xlambdas = 0 then return ()
    else let (x,) = xlambdas[0], pol_hash = make_KTypePol_hash()
    then G = x.real_form
    then disconn_flag = components_rank(G) > 0
    then (Gsc,M) = if disconn_flag
    	      	   then derived_cover_real_form_info(G)
	      	   else (G,id_mat(G.rank))
	      	   fi
    then xlambdas_sc = if disconn_flag
    	      	       then for (x,lambda) in xlambdas
		       	    do let (xt,lambdat) = (inverse_embed_KGB2(x, Gsc, M), M*lambda)
			       {then () = if is_finished(x,lambda)
			       	       	 then finish(xt,lambdat)
					 fi}
			       in (xt,lambdat)
			    od
		       else xlambdas
	      	       fi
    then () = if disconn_flag
    	      then for (x,lambda) in all_finished(G)
	      	   do let (xt,lambdat) = (inverse_embed_KGB2(x, Gsc, M), M*lambda)
	      	      in finish(xt,lambda)
	      	   od
	       fi
    then Uhash = if disconn_flag {this will hold the unitary reps on Gsc}
    	      	 then big_unitary_hash.uhash(Gsc) {make_Param_hash()}
		 {this is for unitary reps of Gsc that factor to G}
		 else UhashG
		 fi
    then start = elapsed_ms()
    then () = unitaryTime := 0
    then () = dfkiTime := 0
    then () = if Dirac_flag then prepDirac(Gsc) fi
    then xnums = for (x,) in xlambdas do let (,m) = %x in m od
    {then lambdas = for (,lambda) in xlambdas do lambda od}
    then LPmss = for (x,lambda) in xlambdas_sc
    	       	 do LPm_table.LPm_entry(Gsc,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
		 od
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = facet_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,UhashG)
	      fi
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,UhashG)
	      fi
    then () = if disconn_flag
    	      then for j:UhashG.size()
	      	   do for psc in sc_lifts2(UhashG.index(j), Gsc, M)
		      do Uhash.match(psc)
		      od
		   od{; prints("# unitary facets on Gsc = ",Uhash.size())}
	      fi
    then xlambdatimes = [int]: null(#xlambdas)
    then answerCards = [int]: null(#xlambdas) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    {then () = adjust_global_top(Gsc)}
    {then () = if by_zero_flag
    	      then global_facets_by_zero := low_FPP_facets_by_zero(global_facets)
	      fi}
    then current = elapsed_ms(), oldUhash = UhashG.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 	   oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
		   {start_min_L_bottom_factors = minBottomData.min_L_bottom_factors_time()}
    then () = for (x,lambda)@k in xlambdas
    	      do {xlambdas} 
	 	 let start = elapsed_ms(), startUhash = Uhash.size(), (x_sc,lambda_sc) = xlambdas_sc[k],
		     		   startUcounter = unitary_test_counter.use_count(), theta = x.involution,
				   {startUparamhash = Uparamhash.size(),} startmorebad = more_bad_hash.size()
		 then (Lvd, Perm2, mapAct) = LPmss[k] {already lives on Gsc}
		 then LF = if by_zero_flag and height(parameter(x,lambda,0*lambda)) > 0
		      	   then localFD_1Dirac2_by_zero(x_sc, lambda_sc, Lvd, Perm2, mapAct{, global_facets_by_zero})
			   else localFD_1Dirac2(x_sc, lambda_sc, Lvd, Perm2, mapAct{, global_facets})
			   fi
		 in if #LF[0] = 0 then ()
		    else if every_lambda_deets_flag
			 then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
			      test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			 fi;
			 let answer = local_test_GEO_hash_bottom_layer(x_sc, lambda_sc,
			     LPm_table.FPP_vertex_data(Gsc), Lvd, LF, pol_hash, Uhash)
			 then () = finish(x_sc, lambda_sc)
			 then () = if disconn_flag
			      	   then finish(x,lambda)
				   fi
			 then () = answerCards[k] := #answer
			 {then () = for p in answer do Uparamhash.match(p) od}
   		    	 then () = current := elapsed_ms(); currentUhash := Uhash.size();
			       	    currentUcounter := unitary_test_counter.use_count()
    		 	 then () = xlambdatimes[k] := current - start
    			 in if every_lambda_flag
	      		    then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) = (", xlambdas[k], {xnums[k], ",",k,}"), ht = ",
				  height(parameter(x,lambda,0*lambda)), ", L = ", let (Q,) =
				  theta_stable_quasi_data(parameter(x,lambda,0*lambda)) in Q.Levi,
				  ",",test_string);
			         prints("    #LF = ", for L in LF do #L od, "; #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests = ", unitary_test_counter.use_count() - startUcounter,
				 ", #Params missed by more = ", more_bad_hash.size() - startmorebad,
				 ", #unitary params so far = ",sum(answerCards));
				 prints("  ------------------")
			    fi
		    fi
		 od{xlambdas}
    then () = if disconn_flag
	      then for j: Uhash.size()
		   do for p in sc_descends(Uhash.index(j), G, M)
		      do UhashG.match(p)
		      od
		   od
	       fi
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    in if FPP_report_flag
       then prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xlambdas[longest], {",", lambdas[longest],}")");
       	    prints("Time spent in is_unitary = ",print_time_string(unitaryTime), ", #unitarity tests = ",
       		unitary_test_counter.use_count(), ", #K-types studied = ", minBottomData.size());
       	    prints("Time in derived_factor_K_types_info = ", print_time_string(dfkiTime), ", time in natural KGB = ", print_time_string(nKeTime));
       	    prints("Time in min_bottom_factors = ",print_time_string(mbfTime), ", time in min_bottom_elim_factors = ",print_time_string(mbefTime));
       	    prints("Time in bottom layer branching = ",print_time_string(rf_sig_tables.bottom_branch_time()),
       		    ", time in bottom layer sig = ", print_time_string(rf_sig_tables.bottom_sig_time()));
       	    if more_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	    print_time_string(befmoreTime), ", more_shift = ", more_shift);
      		 prints("     more_shift = ",more_shift,", #Params missed by more = ", more_bad_hash.size())
	    fi;
       	    {if surprise_flag and surprise_hash.size() > 0
	    then prints("  Found ", surprise_hash.size(), " counterexamples to coh_ind(unitary) = unitary; they're in surprise_hash.")
	    fi;}
       	    prints("  #hash_def_dumb =", hash_def_dumbCounter.use_count(),
	      ", #hash2 =", hash2Counter.use_count(), ", #hash_one_level = ", hash_one_levelCounter.use_count(),
	      ", #hash_bottom_layer =", hash_bottom_layerCounter.use_count());
       	    prints("Number of unitary params = ", sum(answerCards), ", time for is_finished = ",
	    		   print_time_string(is_finished_time), ", time for position = ",
	    		   print_time_string(position_time));
       	    prints("Number of FPP-unitary facets = ",UhashG.size(), ", number found on this run = ", UhashG.size() - oldUhash)
       fi {FPP_report_flag}
    fi {#xlambdas = 0}

set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_bottom_layer(xlambdas, let (x,lambda) = xlambdas[0]
    in big_unitary_hash.uhash(x.real_form) {,uparam_hash})

set FPP_unitary_hash_bottom_layer([KGBElt] xs, Param_hash UhashG{, Param_hash UparamhashG}) = void:
    if #xs = 0
    then return ()
    else let () = if tilde_flag
    	     	  then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      	  fi
    then G = xs[0].real_form
    then disconn_flag = components_rank(G) > 0
    then (Gsc,M) = if disconn_flag
    	      	   then derived_cover_real_form_info(G)
	      	   else (G,id_mat(G.rank))
	      	   fi
    then xs_sc = if disconn_flag
    	       	 then for x in xs do inverse_embed_KGB2(x, Gsc, M) od
	      	 else xs
	      	 fi
    then Uhash = if disconn_flag {this will hold the unitary reps on Gsc}
    	       	 then big_unitary_hash.uhash(Gsc) {make_Param_hash()}
		 else UhashG
		 fi
    {then Uparamhash = if disconn_flag {this will hold the unitary reps on Gsc}
    	       	 then make_Param_hash() {make_Param_hash()}
		 else UparamhashG
		 fi}
    then start = elapsed_ms(), zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then () = unitaryTime := 0
    then () = dfkiTime := 0
    then () = if Dirac_flag then prepDirac(Gsc) fi
    {then {xnums = for x in xs do let (,m) = %x in m od,} xtimes = null(#xs)}
    then pol_hash = make_KTypePol_hash()
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = facet_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,UhashG)
	      fi
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,UhashG)
	      fi
    then () = if disconn_flag
    	      then for j:UhashG.size()
	      	   do for psc in sc_lifts2(UhashG.index(j), Gsc, M)
		      do Uhash.match(psc)
		      od
		   od
	       fi
    then times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
    {then () = adjust_global_top(Gsc)}
    {then () = global_facets_by_zero := low_FPP_facets_by_zero(global_facets)}
    then current = elapsed_ms()
    then oldUhash = UhashG.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
    then () = for x@j in xs
    	      do {xs}
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter, x_sc = xs_sc[j],
	     startmorebadx = more_bad_hash.size()
	 then xtwists = isotwistKGBs(x), lambdas = FPP_lambdas(x), twists = all_lambda_differential_0(x)
	 then lambdas_sc = if disconn_flag
	      		   then for lambda in lambdas do M*lambda od
			   else lambdas
			   fi
	 then N1 = #lambdas
	 then full_N1 = to_bitset([N1])-1
	 then tw = first(for y in xtwists[1:]
	      	   	 do big_unitary_hash.xl_known(G)[y.number] = full_N1 {\Ypower)%two_power_Nl}
			 od)
	 then xtwist = if tw.>=
	      	       then xtwists[tw]
		       else x
		       fi
	 then twnum = if xtwist != x
                      then first(for y in xs do xtwist = y od)
                      else -1
                      fi
	 in if twnum.>= and twnum < j {now xtwist is xs[twnum]}
	    then answerCards[j]:= answerCards[twnum];
		 big_unitary_hash.finish(x, full_N1); {mark as done all lambdas for x}
		 for ell:UhashG.size()
	      	 do let p = UhashG.index(ell)
		    in if p.x = xtwist
		       then let ptwist = parameter(x, p.lambda, p.nu)
		       	    then () = UhashG.match(ptwist)
		       	    in if disconn_flag
			       then for psc in sc_lifts2(ptwist,Gsc,M)
				    do  Uhash.match(psc)
				    od
			       fi
		       fi
		 od
	    else let xcont = contragredient(x)
	    	 then contnum = if xcont != x
		      	      	then first(for y in xs do xcont = y od)
				else -1
				fi
	    	 in if contnum.>= and contnum < j
	    	    then answerCards[j]:= answerCards[contnum];
		    big_unitary_hash.finish(x, full_N1);
		    for ell:UhashG.size()
	      	    do let p = UhashG.index(ell)
		       in if p.x = xcont
		       	  then let pcont = contragredient(p)
			       then () = UhashG.match(pcont)
			       in if disconn_flag
				  then for psc in sc_lifts2(pcont,Gsc,M)
				       do Uhash.match(psc)
				       od
				  fi
		    	  fi
		    od
	     	    else let twists = all_lambda_differential_0(x)
    	 then Ncases = #lambdas
	 then tempanswerCards = null(Ncases)
	 then templambdatimes = null(Ncases)
	 then () = if every_KGB_flag
      	      	   then prints("     start KGBElt #", x.number, ", #lambdas = ",Ncases,
		   	       " Uhash.size() = ", Uhash.size(), ", runtime = ",
			       print_time_string(elapsed_ms() - start), ", #uparams so far = ",
			       sum(for list in answerCards do sum(list) od));
		   	prints("  ------------------")
        	   fi
	 then () = for lambda@index in lambdas
	      	   do let lamthlam = ((1+x.involution)*lambda).numer
		      then (Lvd1, Perm2, mapAct) = LPm_table.LPm_entry(G,x.involution,lamthlam)
		      then Lvd = if disconn_flag
		      	       	 then to_vertex_data(for v in Lvd1.list do M*v od)
			   	 else Lvd1
				 fi
		      then  startlambda = elapsed_ms(), startUhash = Uhash.size(), startUcounter =
		      	    unitary_test_counter.use_count(), startmorebadlambda = more_bad_hash.size()
 		      then LF = if by_zero_flag and dominant(G,lamthlam)*G.two_rho_check > 0
		      	      	then localFD_1Dirac2_by_zero(x_sc, M*lambda, Lvd, Perm2, mapAct)
			   	else localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct)
			   	fi
		       in if #LF[0] = 0
			  then []
			  else if every_lambda_deets_flag
			       then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
				    	 test_verbose :=old_test_verbose; test_slightly_verbose :=
					 	      old_test_slightly_verbose
			       fi;
			       let answer = local_test_GEO_hash_bottom_layer(x_sc, M*lambda,
			       	   	    LPm_table.FPP_vertex_data(Gsc), Lvd, LF, pol_hash, Uhash)
			       then y_scs = isotwistKGBs(x_sc)
			       then () = for y_sc in y_scs
					 do finish(y_sc,M*lambda)
					 od
			       then () = tempanswerCards[index] := #answer
			       then () = for qsc in answer
				       	 do for y_sc in y_scs
				     	    do let rsc = parameter(y_sc, qsc.lambda, qsc.nu)
				     	       {then () = Uparamhash.match(rsc)
			             	       then () = if disconn_flag
					       	       	 then for r in sc_descends(rsc,G,M)
						    	      do UparamhashG.match(r)
						    	      od
					       	  	 fi}
					        in for tsc in monomials(finalize(rsc))
				           	   do Uhash.match(tsc);
					      	      if disconn_flag
					      	      then for t in sc_descends(tsc,G,M)
						      	   do UhashG.match(t)
						   	   od
					       	       fi
					    	   od {tsc}
				      	     od {y_sc}
				    	   od{qsc}
 			 	 then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 in if every_lambda_flag
				    then prints("  ",print_time_string(templambdatimes[index]),
			   	    " = time for (x,lambda) = (", x.number, ",", lambda, "), ht = ",
				    height(parameter(x,lambda,0*lambda)),", L = ",
				    let (Q,) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
				    in Q.Levi, ",",test_string);
				         if more_flag
					 then prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",
					      	tempanswerCards[index], ", #new unitary = ", Uhash.size() - startUhash,
						", #tests = ", unitary_test_counter.use_count() - startUcounter);
					     prints("     more_shift = ",more_shift,", #Params missed by more = ",
					     	more_bad_hash.size() - startmorebadlambda)
					 else prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",
					      	tempanswerCards[index],
			     	                ", #new unitary = ", Uhash.size() - startUhash,
						", #tests = ", unitary_test_counter.use_count() - startUcounter)
					 fi ;
					 prints("  ------------------")
				    fi{every_lambda_flag}
			       fi{#LF = 0}
                          {od {twists}}
                 od {lambdas} {good_entries} {would be easy enough to get [Param] for each (x,lambda), but for now
		       just put unitary reps in Uhash}
    	   then () = if disconn_flag
	   	     then for j: Uhash.size()
		     	  do for p in sc_descends(Uhash.index(j), G, M)
			     do UhashG.match(p)
			     od
			  od
		     fi
            then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     answerCards[j] := tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag
                     then  prints("     time for KGBElt ",x.number," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for ", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
			  if more_flag then prints("       more_shift = ", more_shift, ", #Params missed by more for this x = ",
			     	       more_bad_hash.size() - startmorebadx) fi; 
			  prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary facets = ",
			     currentUhash - formerUhash, ", #tests = ",
		     	     currentUcounter - formerUcounter, ", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count())
                     fi
	   then () = big_unitary_hash.finish(x, full_N1) {mark as done all lambdas for x}
           in ()
	 fi {contnum.>= and contnum < j}
	 fi {twnum.>= and twnum < j}
         od {xs}
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    in if FPP_report_flag
       then prints("----------------");
       	    prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xs[longest].number);
       	    prints("Time spent in is_unitary = ",print_time_string(unitaryTime), ", number of unitarity tests = ",
       		unitary_test_counter.use_count(), ", #K-types studied = ", minBottomData.size());
       	    prints("Time in derived_factor_K_types_info = ",print_time_string(dfkiTime),", time in natural KGB = ", print_time_string(nKeTime));
       	    prints("Time in min_bottom_factors = ",print_time_string(mbfTime), ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
       	    prints("Time in bottom layer branching = ",print_time_string(rf_sig_tables.bottom_branch_time()),
       		    ", time in bottom layer sig = ", print_time_string(rf_sig_tables.bottom_sig_time()));
       	    if more_flag
	    then prints("Time in bottom_factors = ", print_time_string(bfTime), ", time in bottom_elim_factors_more = ",
       	  	   	      print_time_string(befmoreTime));
		 prints("     more_shift = ", more_shift, ", #Params missed by more = ", more_bad_hash.size())
	    fi;
       	    {if surprise_flag and surprise_hash.size() > 0
	    then prints("Found ", surprise_hash.size(), " counterexamples to coh_ind(unitary) = unitary; they're in surprise.hash.")
	    fi;}
       	    prints("  #hash_def_dumb =", hash_def_dumbCounter.use_count(), ", #hash2 = ", hash2Counter.use_count(),
	      ", #hash_one_level = ", hash_one_levelCounter.use_count(), ", #hash_bottom_layer = ", hash_bottom_layerCounter.use_count());
       	    prints("Number of unitary params = ", sum(for list in answerCards do sum(list) od),
	    		   ", time for is_finished = ", print_time_string(is_finished_time),
			   ", time for position = ", print_time_string(position_time));
            prints("Number of known FPP-unitary facets = ",UhashG.size(),
       	      ", number found on this run = ", UhashG.size() - oldUhash)
      fi {FPP_report_flag}
   fi {#xs = 0}

set FPP_unitary_hash_bottom_layer([KGBElt] xs) = void:
    FPP_unitary_hash_bottom_layer(xs, big_unitary_hash.uhash(xs[0].real_form){, uparam_hash})

set FPP_unitary_hash_bottom_layer(RealForm G) = void:
    FPP_unitary_hash_bottom_layer(KGB(G))

{all nu so parameter(x,lambda,nu) is in unitary hash for G}
set unitary_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let list = big_unitary_hash.uhash(G).list()
    in for p in list
       do if p.x = x and p.lambda = lambda then [p.nu]
	  else []
	  fi
       od.##

{one list for each (x,lambda)}
set unitary_nus(RealForm G) = [[[ratvec]]]:
    let answer = [[[ratvec]]]:
    	for x in KGB(G)
	do for lambda in FPP_lambdas(x)
	   do []
	   od
	od
     then list = big_unitary_hash.uhash(G).list()
     then () = for p in list
       	       do let answerx = answer[p.x.number]
	       	  then () = answerx[position(p.x, p.lambda)] #:= p.nu
	     	  in answer[p.x.number] :=answerx
	       od
      in answer

{
{all nu so parameter(x,lambda,nu) is in nonunitary hash for G. To be applied only to G simple mod center.}
set non_unitary_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let NUhash = big_unitary_hash.nuhash(G)
    in for j:NUhash.size()
       do let p = Uhash.index(j)
	  in if p.x = x and p.lambda = lambda then [p.nu]
	     else []
	     fi
       od.##
}

{
set non_unitary_vert_nus(RealForm G, KGBElt x, ratvec lambda) = [ratvec]:
    let maxLRis = max_LRs(G)
    then maxLRidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLRi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLRi in maxLRis
	 do derived_simple_factors_info(maxLRi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLRidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLRidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]: {one list for each max real Levi LRi}
    	 for maxLRi in maxLRis
	 do KGB(maxLRi)
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis
     	     do for xin in list
	     	do derived_factor_KGBs2(xin)
	     od
	 od
    then KGBEltGs = [[KGBElt]]: {one list for each maxLRi}
    	 for maxLRi@i in maxLRis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
{need to know which lambdainm on maxLRi for xin can induce to FPP on G. Maybe this is some of them??}
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from a maxLRi}
    	 for maxLRi@i in maxLRis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then lambdainms = [[[ratvec]]]: {one list of LRi lambdas for each xin}
    	 for maxLRi@i in maxLRis
	 do let rhoi = G.rho - maxLRi.rho
	    in for n:#KGB(maxLRi)
	       do for lambdaG in lambdainmGs[i][n]
	       	  do lambdaG - rhoi
		  od
	       od
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis
     	     do for xin in list
	     	do derived_factor_KGBs2(xin)
	     od
	 od
     then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdain, and derLik}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params2(pinm)
		   in for pinmk in pinmks do pinmk.lambda od
		od
	     od
	  od
     then non_unitary_listinmks = [[[[[ratvec]]]]]: {one list for each xink, lambdainmk}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
	     	do for lambdainmk@k in lambdainmks[i][n][m]
		   do for nuinmj@j in non_unitary_nus(derLiks[i][k],KGBEltinks[i][n][k], lambdainmk)
		      do Mikinvs[i][k]*nuinmj
		      od {[ratvec]}
		   od {[[ratvec]]}
	     	od {[[[ratvec]]]}
	     od
	  od
{need to take every nu that's non-unitary (vertex) on one derLik, arbitrary on the other (verts). This will
make a rep non-unitary on maxLRi. If induction to G is unitary, add it.}
     then Binmks = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin
	     	do box(for unitary_listinmk in unitary_listinm do #unitary_listinmk od)
		od
	     od
	  od
     then nuinms = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin {unitary_listinm has two indices: k (simple factor)
	     and j (place on list)}
	        do for B in Binmks[i][n][m]
		   do sum(G.rank, for b@k in B do unitary_listinm[k][b] od)
		   od
		od
	     od
	  od
     then cands = [[Param]]: {one list on each maxLRi}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do for nuinmj in nuinms[i][n][m]
		   do let pL = parameter(xin, lambdainm, nuinmj)
		      then gamma = dominant(G,pL.infinitesimal_character)
		      in if is_FPP(G,gamma)
		      	 then [pL]
			 else {prints("parameter ",pL," failed to be FPP");}
			      []
			 fi
		   od.## {list of relevant pL for this x,lambda}
		od.## {put all lambda together}
	     od.## {put all x together}
	  od {but keep a separate list for each max Levi maxLRi}
     then () = for maxLRi@i in maxLRis
	     	  do for pL in cands[i]
	     	     do for q in monomials(real_induce_irreducible(pL,G))
		   	do let qdeflist = [q]## for Qdef in local_defs(q)
			   	      	    	do monomials(composition_series(Qdef))
					    	od.##
			   in for qdef in qdeflist
			      do big_unitary_hash.match(herm_center(qdef))
			      od
			od
	     	     od
		  od
     in ()
}

{assume precompute has been done, so that all FPP unitary are known
for all derived simple factors of theta-stable Levis of G. For maximal LRi run
over unitary (xin,lambdainm) and put into unitary_hash all (x,lambda_nu) that are
induced from some PROPER real Levi. }
set theta_induced(RealForm G) = void:
    let maxLthis = max_Ls(G)
    then maxLthidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLthi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLthi in maxLthis
	 do derived_simple_factors_info(maxLthi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLthidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then unitary_nu_lists = [[[[[ratvec]]]]]:
    	 for Lidata in maxLthidatas
	 do for (,derLik,) in Lidata
	    do unitary_nus(derLik)
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLthidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLthidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]:
    	 for maxLthi in maxLthis
	 do KGB(maxLthi)
	 od
    then KGBEltGs = [[KGBElt]]:
    	 for maxLthi@i in maxLthis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from an Lthi}
    	 for maxLthi@i in maxLthis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then rhois = [ratvec]: for maxLthi in maxLthis do G.rho - maxLthi.rho od
    then lambdainms = [[[ratvec]]]: {one list of Lthi lambdas for each xin}
    	 for maxLthi@i in maxLthis
	 do for n:#KGB(maxLthi)
	    do for lambdaG in lambdainmGs[i][n]
	       do lambdaG - rhois[i]
	       od
	    od
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis
     	     do for xin in list
	     	do derived_factor_KGBs2(xin)
	     od
	 od
     then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdain, and derLik}
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params2(pinm)
		   in for pinmk in pinmks do pinmk.lambda od
		od
	     od
	  od
     then unitary_listinmks = [[[[[ratvec]]]]]:
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
	     	do for lambdainmk@k in lambdainmks[i][n][m]
		   do for nuinmj@j in unitary_nu_lists[i][k][KGBEltinks[i][n][k].number]
		      [position(KGBEltinks[i][n][k],lambdainmks[i][n][m][k])]
		      do Mikinvs[i][k]*nuinmj
		      od {[ratvec]}
		   od {[[ratvec]]}
	     	od {[[[ratvec]]]}
	     od
	  od
     then Binmks = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin
	     	do box(for unitary_listinmk in unitary_listinm do #unitary_listinmk od)
		od
	     od
	  od
     then nuinms = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin {unitary_listinm has two indices: k (simple factor)
	     and j (place on list)}
	        do for B in Binmks[i][n][m]
		   do sum(G.rank, for b@k in B do unitary_listinm[k][b] od)
		   od
		od
	     od
	  od
     then cands = [[Param]]: {one list on each maxLthi}
     	  for maxLthi@i in maxLthis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do for nuinmj in nuinms[i][n][m]
		   do let pL = parameter(xin, lambdainm, nuinmj)
		      then gamma = pL.infinitesimal_character + rhois[i]
		      in if is_FPP(G,gamma)
		      	 then [pL]
			 else {prints("parameter ",pL," failed to be FPP");}
			      []
			 fi
		   od.## {list of relevant pL for this x,lambda}
		od.## {put all lambda together}
	     od.## {put all x together}
	  od {but keep a separate list for each max Levi maxLthi}
     then () = for maxLthi@i in maxLthis
	     	  do for pL in cands[i]
	     	     do for q in monomials(theta_induce_irreducible(pL,G))
		   	do big_unitary_hash.match(herm_center(q))
			od
	     	     od
		  od
     in ()

{simple derived factors of all theta-stable Levis of G}
set SDLF(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for L in Ls(G) {these are PROPER Levis of theta-stable parabolics}
    	      ~do for Lj in derived_simple_factors(L) {~ to put the small L first}
	      	  do answer.match(Lj)
	    	  od
	      	od
    in for k:answer.size()
       do answer.index(k)
       od

{these are the restricted fundamental weights for G: the ones defining maximal real parabolics
 at x_open(G)}
set resFund(RealForm G) = [ratvec]:
    let xo = x_open(G), simples = [vec]: G.simple_roots
    then theta = xo.involution
    then S0 = for j:G.semisimple_rank do if status(j,xo) = 1 then [j] else [] fi od.## {simple imag for M}
    then S1 = complement(G.semisimple_rank, S0)
    then Q0 = KGPElt: (S0,xo)
    then L0 = Q0.Levi
    then wL0 = w0(L0)
    then thetaL0 = matrix(wL0)
    then dualDelta = -theta*thetaL0 {preserves positive}
    then fixDual = for a in S1 do if dualDelta*simples[a] = simples[a] then [a] else [] fi od.##
    then pairsDual = for a in S1
    	 	     do for b:#simples - a-1 from a+1
    	 	       	do if dualDelta*simples[a] = simples[b]
			   then [[a,b]]
			   else []
			   fi
			od.##
		     od.##
    in for a in fixDual do G.fundamental_weights[a] od ##
       for v in pairsDual do G.fundamental_weights[v[0]] + G.fundamental_weights[v[1]] od

{all maximal real parabolics of G}
set max_QRs(RealForm G) = [KGPElt]:
    let xo = x_open(G)
    in for xi in resFund(G) do parabolic_by_wt(xi,xo) od

{all maximal real Levis of G}
set max_LRs(RealForm G) = [RealForm]:
    for QR in max_QRs(G) do QR.Levi od

{all real parabolics of G, starting with G and ending with MAN}
set QRs(RealForm G) = [KGPElt]:
    let xo = x_open(G), res_fund = resFund(G)
    then B = box(2,#res_fund)
    in for wt in columns(res_fund*B)
       do parabolic_by_wt(wt,xo)
       od

{simple derived factors of all real Levis of G}
set LRs(RealForm G) = [RealForm]:
    let Q_Rs = QRs(G)
    in if #Q_Rs = 1 then []
       else for QR in Q_Rs[1:]
    	    do QR.Levi
    	    od
       fi

{simple derived factors of all real Levis of G}
set SDLRF(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for LR in LRs(G) {these are PROPER Levis of real parabolics}
    	      ~do for LRk in derived_simple_factors(LR) {tilde to put small LR first}
	      	  do answer.match(LRk)
	    	  od
	       od
    in for m:answer.size()
       do answer.index(m)
       od

{simple derived factors of all proper real and theta-stable Levis of G}
set SDLALL(RealForm G) = [RealForm]:
    let answer = make_RealForm_hash()
    then () = for L in Ls(G) {these are PROPER Levis of theta-stable parabolics}
    	      ~do for Lj in derived_simple_factors(L) {~ to put the small L first}
	      	  do answer.match(Lj)
	    	  od
	      	od
    then () = for LR in LRs(G) {these are PROPER Levis of real parabolics}
    	      ~do for LRk in derived_simple_factors(LR) {tilde to put small LR first}
	      	  do answer.match(LRk)
	    	  od
	       od
    then rank_lists = [[RealForm]]: for r:G.semisimple_rank do [] od
    then () = for k:answer.size()
      	      do let rf =answer.index(k)
	      	 in rank_lists[rf.semisimple_rank] #:= rf
       	      od
     in rank_lists.##

{assume precompute has been done, so that all FPP unitary are known
for all derived simple factors of real Levis of G. For maximal LRi run
over FPP (xin,lambdainm) and put into unitary_hash all (x,lambda_nu) that are
induced from some PROPER real Levi. }
set real_induced(RealForm G) = void:
    let maxLRis = max_LRs(G)
    then maxLRidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLRi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLRi in maxLRis
	 do derived_simple_factors_info(maxLRi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then unitary_nu_lists = [[[[[ratvec]]]]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do unitary_nus(derLik)
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLRidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLRidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]: {one list on maxLRi for each i}
    	 for maxLRi in maxLRis
	 do KGB(maxLRi)
	 od
    then KGBEltGs = [[KGBElt]]:
    	 for maxLRi@i in maxLRis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from an LRi}
    	 for maxLRi@i in maxLRis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od
    then lambdainms = [[[ratvec]]]: {one list of LRi lambdas for each xin}
    	 for maxLRi@i in maxLRis
	 do let rhoi = G.rho - maxLRi.rho
	    in for n:#KGB(maxLRi)
	       do for lambdaG in lambdainmGs[i][n]
	       	  do lambdaG - rhoi
		  od
	       od
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis {indexed by i}
     	     do for xin in list {indexed by n}
	     	do derived_factor_KGBs2(xin) {indexed by k}
	     od
	 od
     then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdain, and derLik}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params2(pinm)
		   in for pinmk@k in pinmks
		      do {if position(pinmk.x,pinmk.lambda).>=
		      {is_FPP(derLiks[i][k], pinmk.infinitesimal_character)}
		      	 then [}pinmk.lambda{]}
			 {else prints("not in FPP_lambdas(x) ",pinmk); []
			 fi}
		      od{.##}
		od
	     od
	  od
     then unitary_listinmks = [[[[[ratvec]]]]]:
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n] {list of lambdas for xin on maxLRi}
	     	do for lambdainmk@k in lambdainmks[i][n][m] {factor on derLik}
		   do let m = position(KGBEltinks[i][n][k],lambdainmk)
		      in if m.>=
		      	 then for nuinmj@j in unitary_nu_lists[i][k][KGBEltinks[i][n][k].number][m]
		      {[position(KGBEltinks[i][n][k],lambdainmks[i][n][m][k])]}
			      do Mikinvs[i][k]*nuinmj
		      	      od {[ratvec]}
			 else []
			 fi
		   od {[[ratvec]]}
	     	od {[[[ratvec]]]}
	     od
	  od
     then Binmks = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin
	     	do box(for unitary_listinmk in unitary_listinm do #unitary_listinmk od)
		od
	     od
	  od
     then nuinms = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin {unitary_listinm has two indices: k (simple factor)
	     and j (place on list)}
	        do for B in Binmks[i][n][m]
		   do sum(G.rank, for b@k in B do unitary_listinm[k][b] od)
		   od
		od
	     od
	  od
     then cands = [[Param]]: {one list on each maxLRi}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do for nuinmj in nuinms[i][n][m]
		   do let pL = parameter(xin, lambdainm, nuinmj)
		      then gamma = dominant(G,pL.infinitesimal_character)
		      in if is_FPP(G,gamma)
		      	 then [pL]
			 else {prints("parameter ",pL," failed to be FPP");}
			      []
			 fi
		   od.## {list of relevant pL for this x,lambda}
		od.## {put all lambda together}
	     od.## {put all x together}
	  od {but keep a separate list for each max Levi maxLRi}
     then () = for maxLRi@i in maxLRis
	     	  do for pL in cands[i]
	     	     do for q in monomials(real_induce_irreducible(pL,G))
		   	do let qdeflist = [q]## for Qdef in local_defs(q)
			   	      	    	do monomials(composition_series(Qdef))
					    	od.##
			   in for qdef in qdeflist
			      do big_unitary_hash.match(herm_center(qdef))
			      od
			od
	     	     od
		  od
     in ()
{
{assume precompute has been done, so that all FPP unitary are known
for all derived simple factors of real Levis of G. For maximal LRi run
over FPP (xin,lambdainm) and put into non-unitary_hash all (x,lambda,nu) that are
irr unitarily induced from nonunitary on some PROPER real Levi. For now, get nus by
factoring maxLRi into derived simple; put an ARB local vertex on most derLik, but NONUNITARY
local vertex on one.}
set real_inducedNU(RealForm G) = void:
    let maxLRis = max_LRs(G)
    then maxLRidatas = [[(RealForm, RealForm, mat)]]: {one list for each maxLRi, with
    	 	     an entry (Sik, derLik, Mik) for each derived simple factor derLik}
       	 for maxLRi in maxLRis
	 do derived_simple_factors_info(maxLRi)
	 od
    then derLiks = [[RealForm]]:
    	 for Lidata in maxLRidatas
	 do for (,derLik,) in Lidata
	    do derLik
	    od
	 od
    then Miks = [[mat]]: {each of these maps G weights to weights for one factor derLik}
       	 for Lidata in maxLRidatas
	 do for (,,Mik) in Lidata
	    do Mik
	    od
	 od
    then Mikinvs = [[ratmat]]: {each of these maps Lik weights to G weights}
	     for Lidata in maxLRidatas
	     do for (Lik, derLik, Mik) in Lidata
	     	do (Lik.simple_roots)*ratvecs_as_ratmat(derLik.fundamental_coweights).^
		od
	     od
    then KGBEltLis = [[KGBElt]]:
    	 for maxLRi in maxLRis
	 do KGB(maxLRi)
	 od
    then KGBEltGs = [[KGBElt]]:
    	 for maxLRi@i in maxLRis
	 do for xin in KGBEltLis[i]
	    do embed_KGB(xin,G)
	    od
	 od
    then lambdainmGs = [[[ratvec]]]: {one list for each KGBElt to G from an LRi}
    	 for maxLRi@i in maxLRis
	 do for x in KGBEltGs[i]
	    do FPP_lambdas(x)
	    od
	 od

    then lambdainms = [[[ratvec]]]: {one list of LRi lambdas for each xin}
    	 for maxLRi@i in maxLRis
	 do let rhoi = G.rho - maxLRi.rho
	    in for n:#KGB(maxLRi)
	       do for lambdaG in lambdainmGs[i][n]
	       	  do lambdaG - rhoi
		  od
	       od
	 od
    then KGBEltinks = [[[KGBElt]]]: {one KGBElt for each xin and derived simple factor derLik}
     	 for list in KGBEltLis
     	     do for xin in list
	     	do derived_factor_KGBs2(xin)
	     od
	 od
     then lambdainmks = [[[[ratvec]]]]: {one ratvec for each xin, corr lambdain, and derLik}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm in lambdainms[i][n]
		do let pinm = parameter(xin, lambdainm, 0*lambdainm)
		   then pinmks = derived_factor_params2(pinm)
		   in for pinmk in pinmks do pinmk.lambda od
		od
	     od
	  od
     then nonunitary_listinmks = [[[[[ratvec]]]]]:
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
	     	do for lambdainmk@k in lambdainmks[i][n][m]
		   do for nuinmj@j in nonunitary_nus(derLiks[i][k],KGBEltinks[i][n][k], lambdainmk)
		      do Mikinvs[i][k]*nuinmj
		      od {[ratvec]}
		   od {[[ratvec]]}
	     	od {[[[ratvec]]]}
	     od
	  od
     then Binmks = for nonunitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin
	     	do box(for unitary_listinmk in unitary_listinm do #unitary_listinmk od)
		od
	     od
	  od
     then nuinms = for unitary_listi@i in unitary_listinmks
     	  do for unitary_listin@n in unitary_listi
	     do for unitary_listinm@m in unitary_listin {unitary_listinm has two indices: k (simple factor)
	     and j (place on list)}
	        do for B in Binmks[i][n][m]
		   do sum(G.rank, for b@k in B do unitary_listinm[k][b] od)
		   od
		od
	     od
	  od
     then cands = [[Param]]: {one list on each maxLRi}
     	  for maxLRi@i in maxLRis
	  do for xin@n in KGBEltLis[i]
	     do for lambdainm@m in lambdainms[i][n]
		do for nuinmj in nuinms[i][n][m]
		   do let pL = parameter(xin, lambdainm, nuinmj)
		      then gamma = dominant(G,pL.infinitesimal_character)
		      in if is_FPP(G,gamma)
		      	 then [pL]
			 else {prints("parameter ",pL," failed to be FPP");}
			      []
			 fi
		   od.## {list of relevant pL for this x,lambda}
		od.## {put all lambda together}
	     od.## {put all x together}
	  od {but keep a separate list for each max Levi maxLRi}
     then () = for maxLRi@i in maxLRis
	     	  do for pL in cands[i]
	     	     do for q in monomials(real_induce_irreducible(pL,G))
		   	do let qdeflist = [q]## for Qdef in local_defs(q)
			   	      	    	do monomials(composition_series(Qdef))
					    	od.##
			   in for qdef in qdeflist
			      do big_unitary_hash.match(herm_center(qdef))
			      od
			od
	     	     od
		  od
     in ()

}

{get complete FPP dual for each derived simple factor of a theta-stable Levi; and then cohom ind
all those things in weakly good range to G}
set pre_bottom_flag = false

set precomputeTheta(RealForm G) = void:
    let rflist = SDLF(G)
    then () = coh_ind_flag:=false
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do prints("starting # ",k," = ",rf);
	      	 theta_induced(rf);
		 real_induced(rf);
	 	 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 else FPP_unitary_hash2(rf)
		 fi
	      od
    then () = FPP_report_flag:=true
    in theta_induced(G)

set precomputeR(RealForm G) = void:
    let rflist = SDLRF(G)
    then () = coh_ind_flag:=false
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do prints("starting # ",k," = ",rf);
	      	 real_induced(rf);
		 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 else FPP_unitary_hash2(rf)
		 fi
	      od
    then () = FPP_report_flag:=true
    in real_induced(G)

set precomputeALL(RealForm G) = void:
    let start = elapsed_ms(), rflist = SDLALL(G), iG = big_unitary_hash.rf_number(G)
    then Norig = big_unitary_hash.uhash(G).size()
    then () = coh_ind_flag:=false
    then temp_report_flag = FPP_report_flag
    then () = FPP_report_flag :=false
    then () = for rf@k in rflist
    	      do real_induced(rf);
		 theta_induced(rf);
		 if pre_bottom_flag
		 then FPP_unitary_hash_bottom_layer(rf)
		 else FPP_unitary_hash2(rf)
		 fi;
		 prints("At time ",print_time_string(elapsed_ms() - start), ", finished # ",k,"/",
	      	 	    #rflist," = ",rf, ", #FPPreps = ",big_unitary_hash.uhash(rf).size())
	      od
    then FPP_time = elapsed_ms()
    then () = FPP_report_flag:=true
    then () = real_induced(G)
    then NR = big_unitary_hash.uhash(G).size() - Norig
    then () = prints("In ",print_time_string(elapsed_ms() -FPP_time), ", real induction found ",NR,
    	      		 " FPP unitary facets for G.")
    then RI_time = elapsed_ms()
    then () = theta_induced(G)
    then NTheta =  big_unitary_hash.uhash(G).size() - NR - Norig
    then () = prints("In ",print_time_string(elapsed_ms() -RI_time),
    	 ", coh induction found additional ",
    	 NTheta," FPP unitary facets for G.")
    then ind_time = elapsed_ms()
    then Gunip = unipotent_representations(G)
    then () = for p in Gunip do big_unitary_hash.uhash(G).match(p) od
    then Nunip = big_unitary_hash.uhash(G).size() - NTheta - NR - Norig
    then () =  prints("In ",print_time_string(elapsed_ms() -ind_time),
    	 ", found additional ",
    	 Nunip," unipotent facets for G.")
    in prints("altogether found ", big_unitary_hash.uhash(G).size() -
    Norig," FPP unitary facets for G.")

set FPPpre(RealForm G) = void:
    let start = elapsed_ms()
    then temp_KGB_flag = every_KGB_flag
    then () = every_KGB_flag:= false
    then () = precomputeALL(G)
    then () = unip_flag:=false
    then () = every_KGB_flag := temp_KGB_flag
    then () = if pre_bottom_flag
       	      then FPP_unitary_hash_bottom_layer(G)
       	      else FPP_unitary_hash2(G)
       	      fi
    in prints("Total time required was ",print_time_string(elapsed_ms() - start))

{ lists real and/or complex simple factors }
{moved to cohom_reductionND.at}{
set simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
	simpleFactors = simple_factors(RootDatum: G),
	Factors = [RealForm]:[]
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex),
	 newDiagram = diagram_component(G,newSimpleRootIndex)
    in  if diagram=newDiagram then Factors##:=
	 [real_form(inner_class(rd,delta), delta, tf)]
	 else if diagram[0] < newDiagram[0] then Factors##:=
	 [real_form(inner_class(sub_datum(G,diagram##newDiagram),
		delta), delta, tf)]
	      fi
	fi
    od; Factors
}
{moved to cohom_reduction.at}
{
set derived_simple_factors(RealForm G) = [RealForm]:
    for S in simple_factors(G) do derived(S) od
}

{(M,N): M is natural restriction from X^*(G) onto X^*(D).
 N is right inverse of M.}
{ set derived_info(RealForm G) = (mat,mat):
    let (,M) = derived_info(G) in (M,required_solution(M, id_mat(G.semisimple_rank)))
}

{descend a parameter for G to all simple factors of theta-stable Levi support(x)}

{elsewhere}
{
set descents(Param p) = [Param]:
    let  x = p.x, G = p.real_form, lambda = p.lambda, nu = p.nu
    then P = Parabolic: (support(x), x) {, theta = x.involution}
    then L = P.Levi
    then lambdaL = lambda - G.rho + L.rho, nuL = nu, xL = inverse_embed_KGB(x,L)
    then SF = simple_factors(L)
    then xSs = for S in SF do inverse_embed_KGB(xL,S) od
    then nuSs = for xS in xSs do (nu - xS.involution*nu)/2 od
    in for S@j in SF do parameter(xSs[j], lambda - G.rho + S.rho, nuSs[j]) od
    {
    then DSF = for S in SF do derived(S) od
    then DSFinfos = for S in SF do derived_infos(S) od
    }
}
