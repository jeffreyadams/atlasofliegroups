<K_highest_weights {for all_lambda_differential_zero}
<lattice {for vec_solve}
{ <chopping_facets_fast.at {for chop_coroots(G, vertices)}}
<facet_classes {for ordering on facets}
<hash {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<cohom_reduction {for possible use of cohomological induction}
<FPP_localDirac
<cohIndUnip {for weakly fair cohom ind}

{functions for computing the entire FPP_unitary dual}
{typically functions take a Param_hash Uhash and fill it with all
unitary reps having infinitesimal character in the FPP. Each p is
replaced by herm_center(p), at the barycenter of its local facet,
so that the lists are finite.}

{. This controls the maximum denominator size kept in chop_coroots,
used in moving unitarity information from a Levi to G. Large values
allow more chopped facets, and so convey more information to G; but
small values are faster. Too small a value cannot lead to wrong
answers, but only to running more is_unitary tests .}
set chop_bound = int: 6

{if true, compute reps weakly fair cohom induced from Arthur unipotent}
set coh_ind_flag = true

{if true, pass through KGB backwards}
set tilde_flag = true
{next functions aim to compute FULL spherical dual in non-split case,
when several different x give spherical reps}

{if true, use old = November 20 2023 version of FPP_unitary}
set old_flag = false

{if true, use previous = November 22 2023 version of FPP_unitary}
set prev_flag = false

{if facet_verbose is true, report after each |lambda_skip| lambda's
are treated in FPP_unitary}
set lambda_skip = int:10

{if true, then report summary each lambda in FPP_unitary}
set every_lambda_flag = false

{if true, then report progress during each lambda in FPP_unitary}
set every_lambda_deets_flag = false

{if true, then report summary each KGBElt in FPP_unitary}
set every_KGB_flag = false

{if true, uses the (faster?) function localFD_1Dirac2_by_zero to compute local vertices and edges}
set by_zero_flag = true

set spherical_xs(RealForm G) = [KGBElt]:
    let real_rank = rank(x_open(G).involution + 1)
    in for x in KGB(G)
       do if rank(x.involution + 1) = real_rank
       	  then [x]
	  else []
	  fi
       od.##

{this seems to fail to find all relevant lambdas for some unequal rank cases.
Following function FPP_lambdas_big seems OK?}
set FPP_lambdas(KGBElt x) = [ratvec]:
    let G=x.real_form, twists = all_lambda_differential_0(x)
    then zeroPol = ParamPol: 0*G.trivial
    then rho = G.rho, verts = FPP_vertices(G)
    then th1 = x.involution + 1
    then lamthlams = [vec]:
    	 for v in verts
    	 do if ((th1*v).denom = 1) then [ratvec_as_vec(th1*v)]
	    else []
	    fi
	 od.##.no_reps
    then cands = [ratvec]:
    	 for lamthlam in lamthlams
    	 do case vec_solve(th1,lamthlam - th1*rho)
	    | else [ratvec]: []
	    | solution(lr):
	      let lambda = rho + lr
	      in for lambda0 in twists do lambda + lambda0 od
	    esac
	  od.##
    in for lambda in cands
       do let p = parameter(x,lambda,0*lambda)
       	  then lambdaNorm = p.lambda
	  in if 1*p = zeroPol
       	     then []
	     else [lambdaNorm]
	  fi
       od.##

set all_FPP_vertices(RootDatum G) = [ratvec]:
    let factors = for S in simple_factors(G)
    		  do FPP_vertices(S,-1)
		  od
    in case #factors
       in [ratvec:null(rank(G))/1],
       factors[0],
       for v in factors[0]
       do for w in factors[1]
       	  do v+w
	  od
       od.##
       esac

{not used?
{each term is a candidate lambda0 (mod comp gp char twists) and the
corresponding Lvd, Perm, mapAct}
set FPP_lambdas_big(KGBElt x, VertexData vd, mat_hash inv_hash, [vec_hash]
    dlambda_hashes, [[(VertexData, vec, vec)]] LvdEtcs) =
    		    [(ratvec,VertexData, vec, vec)]:
    let G=x.real_form
    then zeroPol = ParamPol: 0*G.trivial, theta = x.involution
    then i = inv_hash.lookup(theta)
    then rho = G.rho, verts = all_FPP_vertices(G)
    then th1 = theta + 1
    then lamthlams = [vec]:
    	 for v in verts
    	 do if ((th1*v).denom = 1) then [ratvec_as_vec(th1*v)]
	    else []
	    fi
	 od.##.no_reps
    in [(ratvec, VertexData, vec, vec)]:
    	 for lamthlam in lamthlams
    	 do case vec_solve(th1,lamthlam - th1*rho)
	    | else [(ratvec,VertexData,vec,vec)]: []
	    | solution(lr):
	      let lambda0 = rho + lr
	      then dlambda0 = ratvec_as_vec(lambda0 + theta*lambda0)
    	      then j = dlambda_hashes[i].match(dlambda0)
              then () = if j = #LvdEtcs[i]
                      	then
                      	LvdEtcs[i]:=LvdEtcs[i]#localFD_Lvd(x,lambda0,vd)
                      	fi
              then (Lvd, Perm, mapAct) = LvdEtcs[i][j]
	      in if #Lvd.list > 0 and
	      	    1*parameter(x,lambda0,0*lambda0) != zeroPol
		 then [(lambda0, Lvd, Perm, mapAct)]
	      	 else []
		 fi
	      esac
	  od.##
}


{each term is a candidate lambda0 (mod comp gp char twists) and the
corresponding Lvd, Perm, mapAct, LF, with LF the 0 and 1-diml local facets
Should use EITHER this OR FPP_lambdas_big in one session}
set FPP_lambdas_big(KGBElt x, VertexData vd, mat_hash inv_hash, [vec_hash]
    dlambda_hashes, [[(VertexData, vec, vec,[[FacetVertsIndex]])]] LvdEtAlia) =
    		    [(ratvec, VertexData, vec, vec,[[FacetVertsIndex]])]:
    let G=x.real_form
    then zeroPol = ParamPol: 0*G.trivial, theta = x.involution
    then i = inv_hash.lookup(theta)
    then rho = G.rho, verts = all_FPP_vertices(G)
    then th1 = theta + 1
    then lamthlams = [vec]:
    	 for v in verts
    	 do if ((th1*v).denom = 1) then [ratvec_as_vec(th1*v)]
	    else []
	    fi
	 od.##.no_reps
    in [(ratvec, VertexData, vec, vec, [[FacetVertsIndex]])]:
    	 for lamthlam in lamthlams
    	 do case vec_solve(th1,lamthlam - th1*rho)
	    | else [(ratvec,VertexData,vec,vec,[[FacetVertsIndex]])]: []
	    | solution(lr):
	      let lambda0 = rho + lr
	      then dlambda0 = ratvec_as_vec(lambda0 + theta*lambda0)
    	      then j = dlambda_hashes[i].match(dlambda0)
              then () = if j = #LvdEtAlia[i]
                      	then LvdEtAlia[i]:= (LvdEtAlia[i] next LvdEtAlia[i]:=[])#localFD_01(x,lambda0,vd)
                      	{LvdEtAlia[i]:=LvdEtAlia[i]#localFD_01(x,lambda0,vd)}
                      	fi
              then (Lvd, Perm, mapAct,LF) = LvdEtAlia[i][j]
	      in if #Lvd.list > 0 and
	      	    1*parameter(x,lambda0,0*lambda0) != zeroPol
		 then [(lambda0, Lvd, Perm, mapAct,LF)]
	      	 else []
		 fi
	      esac
	  od.##

{each term is a candidate lambda0 (mod comp gp char twists) and the
corresponding (Lvd, Perm, mapAct). If x is involution #i (in inv_hash), then ith term
in Lvd_Perm_mapAct is list of (Lvd,Perm,mapAct) for various dlambda (indexed by
dlambda_hashes[i])}
set FPP_lambdas_big_new(KGBElt x, VertexData vd, mat_hash inv_hash, [vec_hash]
    dlambda_hashes, [[(VertexData, PermOrderTwo, vec)]] Lvd_Perm2_mapAct,
    [(ratvec->int)] ELs) =[(ratvec, VertexData, PermOrderTwo, vec)]:
    let G=x.real_form
    then zeroPol = ParamPol: 0*G.trivial, theta = x.involution
    then i = inv_hash.lookup(theta)
    then rho = G.rho, verts = all_FPP_vertices(G)
    then th1 = theta + 1
    then lamthlams = [vec]:
    	 for v in verts
    	 do if ((th1*v).denom = 1) then [ratvec_as_vec(th1*v)]
	    else []
	    fi
	 od.##.no_reps
    in [(ratvec, VertexData, PermOrderTwo, vec)]:
    	 for lamthlam in lamthlams
    	 do case vec_solve(th1,lamthlam - th1*rho)
	    | else [(ratvec,VertexData,PermOrderTwo,vec)]: []
	    | solution(lr):
	      let lambda0 = rho + lr
	      then dlambda0 = ratvec_as_vec(lambda0 + theta*lambda0)
    	      then j = dlambda_hashes[i].match(dlambda0)
              then () = if j = #Lvd_Perm2_mapAct[i]
                      	then
			Lvd_Perm2_mapAct[i]:= (Lvd_Perm2_mapAct[i] next Lvd_Perm2_mapAct[i]:=[])
					      #localFD_Lvd2(x,lambda0,vd,ELs)
                      	{Lvd_Perm2_mapAct[i]:=Lvd_Perm2_mapAct[i]#localFD_Lvd2(x,lambda0,vd,ELs)}
                      	fi
              then (Lvd, Perm2, mapAct) = Lvd_Perm2_mapAct[i][j]
	      in if #Lvd.list > 0 and
	      	    1*parameter(x,lambda0,0*lambda0) != zeroPol
		 then [(lambda0, Lvd, Perm2, mapAct)]
	      	 else []
		 fi
	      esac
	  od.##

{take a list of x, get for each x a list of the output data above}
set FPP_lambdas_big_new([KGBElt] xs, VertexData vd, [(ratvec->int)] ELs) =
    		    [[(ratvec, VertexData, PermOrderTwo, vec)]]:
    let inv_hash = make_mat_hash()
then () = for x in xs do inv_hash.match(x.involution) od
    then NumInvs = inv_hash.size()
    then dlambda_hashes = for i:NumInvs do make_vec_hash() od
    then Lvd_Perm2_mapAct = for i:NumInvs do [(VertexData,PermOrderTwo,vec)]:[] od
    in for x in xs
       do FPP_lambdas_big_new(x, vd, inv_hash, dlambda_hashes, Lvd_Perm2_mapAct, ELs)
       od

{each term is a candidate lambda0 (mod comp gp char twists) and the
corresponding Lvd, Perm, mapAct, LF, with LF the 0 and 1-diml local facets
Should use EITHER this OR FPP_lambdas_big in one session}
set FPP_lambdas_big_global(KGBElt x, VertexData vd,
    [[FacetVertsIndex]] global_facets) =
    	[(ratvec, VertexData, vec, vec,[[FacetVertsIndex]])]:
    let G=x.real_form
    then zeroPol = ParamPol: 0*G.trivial, theta = x.involution
    then rho = G.rho, verts = vd.list
    then th1 = theta + 1
    then lamthlams = [vec]:
    	 for v in verts
    	 do if ((th1*v).denom = 1) then [ratvec_as_vec(th1*v)]
	    else []
	    fi
	 od.##.no_reps
    in [(ratvec, VertexData, vec, vec, [[FacetVertsIndex]])]:
    	 for lamthlam in lamthlams
    	 do case vec_solve(th1,lamthlam - th1*rho)
	    | else [(ratvec,VertexData,vec,vec,[[FacetVertsIndex]])]: []
	    | solution(lr):
	      let lambda0 = rho + lr
	      then twists = all_lambda_differential_0(x)
	      in for twist in twists
	      	 do let lambda = lambda0 + twist
		    then (Lvd, Perm, mapAct) = localFD_Lvd(x,lambda0+twist,vd)
		    then LF = localFD_1Dirac(x, lambda, Lvd, Perm,
		    	     mapAct, global_facets)
		    in if #LF[0] > 0 then [(lambda, Lvd, Perm, mapAct, LF)]
		       else []
		       fi
		 od.##
	      esac
	  od.##

set unitary_hash = make_Param_hash()

{load a bunch of Param_hash's into one}
set transfer([Param_hash] Us, Param_hash target) = void:
    for U in Us
    do for j:U.size()
       do target.match(U.index(j))
       od
    od

{derived simple factors of all Levis of theta-stable P, omitting P=G}
set DSFLevis(RealForm G) = [RealForm]:
    for P in theta_stable_parabolics(G)~[1:]
    do derived_simple_factors(P.Levi) od.##

set DSFLevi_hash(RealForm G) = RealForm_hash:
    make_RealForm_hash(DSFLevis(G), hash_code@(RealForm,int))

set FPP_unitary_hash_general_old(RealForm G,Param_hash Uhash,
    (KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
  if is_compact(G)
  then for p in all_parameters_gamma(G,G.rho)
       do Uhash.match(p) od
  else
    let inv_hash = make_mat_hash(), vd = FPP_vertex_data(G), start = elapsed_ms()
    then () = prepDirac(G)
    then () = for x in KGB(G) do inv_hash.match(x.involution) od
    then NumInvs = inv_hash.size(), pol_hash = make_KTypePol_hash()
    then dlambda_hashes = for i:NumInvs do make_vec_hash() od
    then LvdEtAlia = for i:NumInvs do [(VertexData,vec,vec,
    	 [[FacetVertsIndex]])]:[] od
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = facet_verbose:=false
    then () = deform_flag :=true
    then () = unipotents_to_hash(G,Uhash)
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,Uhash)
	      fi
    then times = [int]: null(#KGB(G))
    then global_facets = low_FPP_facets(G)
    then current = elapsed_ms()
    then X = KGB(G)
    then () = if tilde_flag
    	      then X:= for x in X ~do x od;
    	      	   deform_flag:=false
	      fi
    then () = for x@j in X
    	      do {KGB} if(old_facet_verbose)
      	      	       then prints(new_line, "KGBElt #", let (,m) = %x in m, ", #Uhash = ",
		       	     Uhash.size(), ", #tests = ",
		     	     unitary_test_counter.use_count(), ", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count());
		     	    prints("#hash_dumb calls = ", hash_dumbCounter.use_count(),
    		     	     ", #hash_def_dumb calls = ", hash_def_dumbCounter.use_count(),
		       	     ", #hash calls = ", hashCounter.use_count(),
		             ", #hash2 calls = ", hash2Counter.use_count(),
		             ", #hash_one_level calls = ", hash_one_levelCounter.use_count())
		        fi;
	 let former_time = current
	 then twists = all_lambda_differential_0(x)
      	 then FPPbig = FPP_lambdas_big(x, vd, inv_hash,
	      	     dlambda_hashes, LvdEtAlia)
	 then Ncases = #FPPbig * #twists
	 then () = for (lambda0, Lvd, Perm, mapAct,LF)@k in FPPbig
      	      	   do for tau@ell in twists
		      do if old_facet_verbose and
		      	    (k*#twists + ell)%lambda_skip = 0
                         then prints("  working on ",k*#twists + ell,"th lambda out of ",
                                     Ncases)
                         fi;
		      	 local(x, lambda0+tau, vd, Lvd, {Perm, mapAct,} {LF,}
		      	       	  for L@d in LF
		   	       	  do for v in L do if is_pos_on_LKTs(parameter(x,
			       	     	      lambda0+tau, facet_bary(Lvd.list,v[:d+1])))
				     then [v]
				     else []
				     fi
				  od.##
		   	       od,  pol_hash, Uhash)
		      od
		   od
	   then () = current := elapsed_ms()
	   then () = times[j] := current -former_time
	   then () = if old_time_verbose
	   	     then prints("time for KGBElt ",if tilde_flag then
    		     	  	  #X - j - 1 else j fi," was ",
			  print_time_string(times[j]), "; time so far ",
			  print_time_string(current-start),
			  ", #Uhash = ", Uhash.size())
		     fi
	   in ()
       	 od {X}
    then () = facet_verbose:=old_facet_verbose
    then () = time_verbose:=old_time_verbose
    then longest = max_loc(times)
    in prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(times[longest]),
	      " for KGBElt ",if tilde_flag then #X - longest - 1 else longest fi,
	      "; DiracIC time = ",print_time_string(DiracICtime));
       prints("#hash_dumb calls=", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb calls=", hash_def_dumbCounter.use_count(),
       	      ", #hash calls=", hashCounter.use_count(),
	      ", #hash2 calls=", hash2Counter.use_count(),
	      ", #hash_one_level calls=", hash_one_levelCounter.use_count());
       prints("Number of FPP-unitary facets = ",Uhash.size())
    fi

set FPP_unitary_hash_general_prev(RealForm G,Param_hash Uhash,
    (KGBElt,ratvec,VertexData,VertexData,{vec,vec,} [[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
  if is_compact(G)
  then for p in all_parameters_gamma(G,G.rho)
       do Uhash.match(p) od
  else
    let {inv_hash = make_mat_hash(),} vd = FPP_vertex_data(G),
    	start = elapsed_ms(), pol_hash = make_KTypePol_hash()
    then () = prepDirac(G)
    {then () = for x in KGB(G) do inv_hash.match(x.involution) od}
    {then NumInvs = inv_hash.size(), pol_hash = make_KTypePol_hash()}
{    then dlambda_hashes = for i:NumInvs do make_vec_hash() od
    then LvdEtAlia = for i:NumInvs do [(VertexData,vec,vec,
    	 [[FacetVertsIndex]])]:[] od}
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = facet_verbose:=false
    then () = deform_flag :=true
    then () = unipotents_to_hash(G,Uhash)
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,Uhash)
	      fi
    then times = [int]: null(#KGB(G))
    {then () = adjust_global_top(G)} {done internally by low_FPP_facets}
    then () = if #global_facets = 0 or #global_facets[0] != #vd.list
    	      then global_facets := low_FPP_facets(G)
	      fi
    then current = elapsed_ms()
    then X = KGB(G)
    then () = if tilde_flag
    	      then X:= for x in X ~do x od;
    	      	   deform_flag:=false
	      fi
    then () = for x@j in X
    	      do {KGB} if every_KGB_flag
      	      	       then prints(new_line, "KGBElt #", let (,m) = %x in m, ", #Uhash = ",
		       	     Uhash.size(), ", #tests = ",
		     	     unitary_test_counter.use_count(), ", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count());
		     	    prints("#hash_dumb calls = ", hash_dumbCounter.use_count(),
    		     	     ", #hash_def_dumb calls = ", hash_def_dumbCounter.use_count(),
		       	     ", #hash calls = ", hashCounter.use_count(),
		             ", #hash2 calls = ", hash2Counter.use_count(),
		             ", #hash_one_level calls = ", hash_one_levelCounter.use_count())
		        fi;
	 let former_time = current
      	 then FPPbigGlobal = FPP_lambdas_big_global(x, vd, global_facets)
	 then () = for (lambda, Lvd, Perm, mapAct, LF)@k in FPPbigGlobal
      	      	   do if old_facet_verbose and k%lambda_skip = 0
	      	      then prints("  working on ",k,"th lambda out of ",
		      	   	     #FPPbigGlobal)
	    	      fi;
		      local(x, lambda, vd, Lvd, {Perm, mapAct,} LF,
		      	       pol_hash, Uhash)
		   od
	   then () = current := elapsed_ms()
	   then () = times[j] := current -former_time
	   then () = if old_time_verbose
	   	     then prints("time for KGBElt ",if tilde_flag then
    		     	  	  #X - j - 1 else j fi," was ",
			  print_time_string(times[j]), "; time so far ",
			  print_time_string(current-start),
			  ", #Uhash = ", Uhash.size())
		     fi
	   in ()
       	 od {X}
    then () = facet_verbose:=old_facet_verbose
    then () = time_verbose:=old_time_verbose
    then longest = max_loc(times)
    in prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(times[longest]),
	      " for KGBElt ",if tilde_flag then #X - longest - 1 else longest fi,
	      "; DiracIC time = ",print_time_string(DiracICtime));
       prints("#hash_dumb calls=", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb calls=", hash_def_dumbCounter.use_count(),
       	      ", #hash calls=", hashCounter.use_count(),
	      ", #hash2 calls=", hash2Counter.use_count(),
	      ", #hash_one_level calls=", hash_one_levelCounter.use_count());
       prints("Number of FPP-unitary facets = ",Uhash.size())
    fi

{this version makes an involution_hash; for each involution, a list dlambda_hashes of
possible dlambda; and a list Lvd_Perm_mapActs (one for each dlambda) of
(Lvd, Perm, mapAct)}
set FPP_unitary_hash_general([(KGBElt,ratvec)] xlambdas, Param_hash Uhash,
    (KGBElt, ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
    if #xlambdas = 0 then return ()
    else let inv_hash = make_mat_hash()
    then (x,) = xlambdas[0]
    then G = x.real_form
    then vd = FPP_vertex_data(G), start = elapsed_ms()
    then () = unitaryTime := 0
    then () = prepDirac(G)
    then ELs = edge_list_lookups(G) {one minute, 250 mb for E8_s}
    then () = for (x,lambda) in xlambdas do inv_hash.match(x.involution) od
    then xnums = for (x,) in xlambdas do let (,m) = %x in m od
    then lambdas = for (,lambda) in xlambdas do lambda od
    then NumInvs = inv_hash.size(), pol_hash = make_KTypePol_hash()
    then dlambda_hashes = for i:NumInvs do make_vec_hash() od
    then Lvd_Perm2_mapAct = for i:NumInvs do [(VertexData,PermOrderTwo,vec)]:[] od
    {now compute all the local vertex data}
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = for (x,lambda) in xlambdas
    	      do let theta = x.involution
	      	 then i = inv_hash.lookup(theta)
		 then dlambda = ratvec_as_vec(lambda + theta*lambda)
    	      	 then j = dlambda_hashes[i].match(dlambda)
              	 then () =  if j = #Lvd_Perm2_mapAct[i]
                      	    then Lvd_Perm2_mapAct[i]:= (Lvd_Perm2_mapAct[i] next Lvd_Perm2_mapAct[i]:=[])
					      #localFD_Lvd2(x,lambda,vd,ELs)
					      {Lvd_Perm2_mapAct[i]:=Lvd_Perm2_mapAct[i]#localFD_Lvd2(x,lambda,
			    vd, ELs)}
                      	    fi
		in ()
	      od
    then () = facet_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = unipotents_to_hash(G,Uhash)
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,Uhash)
	      fi
    then xlambdatimes = [int]: null(#xlambdas)
    then oldUhash = Uhash.size()
    {then () = adjust_global_top(G)} {done internally by low_FPP_facets}
    then () = if #global_facets = 0 or #global_facets[0] != #vd.list
    	      then global_facets := low_FPP_facets(G)
	      fi
    then () = if by_zero_flag and (#global_facets_by_zero = 0 or #global_facets_by_zero[0] != #vd.list)
    	      then global_facets_by_zero := low_FPP_facets_by_zero(global_facets)
	      fi
    then current = elapsed_ms(), oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 	   oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
    then () = for (x,lambda)@k in xlambdas
    	      do {xlambdas} 
	 	 let start = elapsed_ms(), startUhash = Uhash.size(),
		     		   startUcounter = unitary_test_counter.use_count(), theta = x.involution
		 then i = inv_hash.lookup(theta)
		 then j = dlambda_hashes[i].lookup(ratvec_as_vec(lambda+theta*lambda))
		 then (Lvd, Perm2, mapAct) = Lvd_Perm2_mapAct[i][j]
		 then LF = if by_zero_flag
		      	   then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2, mapAct, global_facets_by_zero)
			   else localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct, global_facets)
			   fi
		 in if #LF[0] = 0 then ()
		     else if every_lambda_deets_flag
			  then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
			       test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			  fi;
			  let output = local(x, lambda, vd, Lvd, LF, pol_hash, Uhash)
   		    	  then () = current := elapsed_ms(); currentUhash := Uhash.size();
			       	    currentUcounter := unitary_test_counter.use_count()
    		 	  then () = xlambdatimes[k] := current - start
    			  in if every_lambda_flag
	      		     then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) = (", xnums[k], ",",k{lambdas[k]},")", test_string);
			         prints("    #LF = ", for L in LF do #L od, "; #unitary params = ",#output,
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests = ", unitary_test_counter.use_count() - startUcounter);
				 prints("  ------------------")
			     fi
		    fi
		 od{xlambdas}
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    in prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xnums[longest], ",", lambdas[longest],")");
       prints("  #hash_real_dumb_calls=",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb calls=", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb calls=", hash_def_dumbCounter.use_count());
       prints("  #hash calls=", hashCounter.use_count(),
	      ", #hash2 calls=", hash2Counter.use_count(),
	      ", #hash_one_level calls=", hash_one_levelCounter.use_count());
       prints("Number of FPP-unitary facets = ",Uhash.size(),
              ", number found on this run = ", Uhash.size() - oldUhash);
       prints("Number of unitarity tests = ", unitary_test_counter.use_count(),
       	      ", time spent in is_unitary = ",print_time_string(unitaryTime))
    fi

set FPP_unitary_hash_general([KGBElt] xs, Param_hash Uhash,
    (KGBElt, ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
    if #xs = 0
    then return ()
    fi;
    if tilde_flag
    then xs:= for x in xs ~do x od; deform_flag:=false
    fi;
    let inv_hash = make_mat_hash()
    then G = xs[0].real_form
    then vd = FPP_vertex_data(G), start = elapsed_ms()
    then ELs = edge_list_lookups(G) {one minute, 250 mb for E8_s}
    then () = unitaryTime := 0
    then () = prepDirac(G)
    then () = for x in xs do inv_hash.match(x.involution) od
    then xnums = for x in xs do let (,m) = %x in m od, xtimes = null(#xs)
    then NumInvs = inv_hash.size(), pol_hash = make_KTypePol_hash()
    then dlambda_hashes = for i:NumInvs do make_vec_hash() od
    then Lvd_Perm2_mapAct = for i:NumInvs do [(VertexData,PermOrderTwo,vec)]:[] od
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = facet_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = unipotents_to_hash(G,Uhash)
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,Uhash)
	      fi
    then times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    { then () = adjust_global_top(G) } {done internally by low_FPP_facets}
    then () = if #global_facets = 0 or #global_facets[0] != #vd.list
    	      then global_facets := low_FPP_facets(G)
	      fi
    then () = global_facets_by_zero := low_FPP_facets_by_zero(global_facets)
    then current = elapsed_ms()
    then oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
    then () = for x@j in xs
    	      do {xs} 
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter
	 then twists = all_lambda_differential_0(x)
      	 then FPPbigNew = FPP_lambdas_big_new(x, vd, inv_hash,
    	      		dlambda_hashes, Lvd_Perm2_mapAct, ELs)
	 then postFPPbigNew = elapsed_ms()
	 then lambdas = [ratvec]: for (lambda0,,,) in FPPbigNew
	      	      		  do for tau in twists
				     do lambda0+tau
				     od
				  od.##
    	 then Ncases = #lambdas
	 then templambdatimes = null(Ncases)
	 then () = if every_KGB_flag
      	      	   then prints("     start KGBElt #", xnums[j], ", #lambdas = ",#lambdas,
		   	       " Uhash.size() = ", Uhash.size());
		   	prints("  ------------------")
        	   fi
	 then () = for (lambda0, Lvd, Perm2, mapAct)@k in FPPbigNew
      	      	   do for tau@ell in twists
                      do let startlambda = elapsed_ms(), startUhash = Uhash.size(),
		      	     startUcounter = unitary_test_counter.use_count()
			 then LF = if by_zero_flag
		      	      	   then localFD_1Dirac2_by_zero(x, lambda0+tau, Lvd, Perm2, mapAct, global_facets_by_zero)
			   	   else localFD_1Dirac2(x, lambda0+tau, Lvd, Perm2, mapAct, global_facets)
			   	   fi
			 in if #LF[0] = 0
			    then []
                            else if every_lambda_deets_flag
			    	 then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
				 test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
				 fi;
				 let answer = local(x, lambda0+tau, vd, Lvd,
			      	     {Perm, mapAct,} LF, pol_hash, Uhash)
				 then () = if every_lambda_deets_flag
			    	      	   then facet_verbose := false; time_verbose := false;
				 	   	test_verbose := false; test_slightly_verbose := false
				 	   fi
 			 	 then () = templambdatimes [k*#twists + ell] := elapsed_ms() - startlambda
			 	 in if every_lambda_flag
				    then prints("  ",print_time_string(templambdatimes[k*#twists + ell]),
			   	    	 	" = time for (x,lambda) = (", xnums[j], ",",
						k*#twists + ell, ")", test_string);
				         prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",#answer,
			     	                ", #new unitary = ", Uhash.size() - startUhash,
						", #tests = ", unitary_test_counter.use_count() - startUcounter);
					 prints("  ------------------")
				    fi
			    fi
                      od
                   od {would be easy enough to get [Param] for each (x,lambda), but for now
		       just put unitary reps in Uhash}
           then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count()
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag
                     then  prints("     time for KGBElt ",xnums[j]," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for #", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
			  prints("     #new unitary facets = ", currentUhash - formerUhash, ", #tests = ",
		     	     currentUcounter - formerUcounter, ", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count())
                     fi
           in ()
         od {xs}
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    in prints("----------------");
       prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xnums[longest]);
       prints("  #hash_real_dumb_calls=",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb calls=", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb calls=", hash_def_dumbCounter.use_count());
       prints("  #hash calls=", hashCounter.use_count(),
	      ", #hash2 calls=", hash2Counter.use_count(),
	      ", #hash_one_level calls=", hash_one_levelCounter.use_count());
       prints("Number of known FPP-unitary facets = ",Uhash.size(),
       	      ", number found on this run = ", Uhash.size() - oldUhash);
       prints("Number of unitarity tests = ", unitary_test_counter.use_count(),
       	      ", time spent in is_unitary = ",print_time_string(unitaryTime))

set FPP_unitary_hash_general(RealForm G,Param_hash Uhash,
    (KGBElt,ratvec,VertexData,VertexData,{vec,vec,} [[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
  if old_flag
  then FPP_unitary_hash_general_old(G, Uhash, local)
  elif prev_flag
  then FPP_unitary_hash_general_prev(G, Uhash, local)
  else if is_compact(G)
       then for p in all_parameters_gamma(G,G.rho)
       do Uhash.match(p) od
       else
       FPP_unitary_hash_general(KGB(G), Uhash, local)
       fi
  fi

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash) = void:
    let () = real_flag:=true in
    FPP_unitary_hash_general(xlambdas, Uhash, local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_real_dumb(xlambdas, unitary_hash)

set FPP_unitary_hash_real_dumb([KGBElt] xs, Param_hash Uhash) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xs, Uhash, local_test_GEO_hash_real_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_real_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_real_dumb(xs, unitary_hash)

set FPP_unitary_hash_real_dumb(RealForm G) = void:
    FPP_unitary_hash_real_dumb(KGB(G))

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xlambdas, Uhash, local_test_GEO_hash_def_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_def_dumb(xlambdas, unitary_hash)

set FPP_unitary_hash_def_dumb([KGBElt] xs, Param_hash Uhash) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xs, Uhash, local_test_GEO_hash_def_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_def_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_def_dumb(xs, unitary_hash)

set FPP_unitary_hash_def_dumb(RealForm G) = void:
    FPP_unitary_hash_def_dumb(KGB(G))

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash) = void:
    let () = def_flag:=false in
    FPP_unitary_hash_general(xlambdas, Uhash, local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_dumb(xlambdas, unitary_hash)

set FPP_unitary_hash_dumb([KGBElt] xs, Param_hash Uhash) = void:
    let () = def_flag:=false in
    FPP_unitary_hash_general(xs, Uhash, local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_dumb(xs,unitary_hash)

set FPP_unitary_hash_dumb(RealForm G) = void:
    FPP_unitary_hash_dumb(KGB(G))

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas, Param_hash Uhash) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, local_test_GEO_hash@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))


set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash(xlambdas, unitary_hash)

set FPP_unitary_hash([KGBElt] xs, Param_hash Uhash) = void:
    FPP_unitary_hash_general(xs, Uhash, local_test_GEO_hash@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash([KGBElt] xs) = void:
    FPP_unitary_hash(xs,unitary_hash)

set FPP_unitary_hash(RealForm G) = void:
    FPP_unitary_hash(KGB(G),unitary_hash)

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas, Param_hash Uhash) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, local_test_GEO_hash2@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash2(xlambdas, unitary_hash)

set FPP_unitary_hash2([KGBElt] xs, Param_hash Uhash) = void:
    FPP_unitary_hash_general(xs, Uhash, local_test_GEO_hash2@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash2([KGBElt] xs) = void:
    FPP_unitary_hash2(xs, unitary_hash)

set FPP_unitary_hash2(RealForm G) = void:
    FPP_unitary_hash2(KGB(G))

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas, Param_hash Uhash) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, local_test_GEO_hash_one_level@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,} [[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_one_level(xlambdas, unitary_hash)

set FPP_unitary_hash_one_level([KGBElt] xs, Param_hash Uhash) = void:
    FPP_unitary_hash_general(xs, Uhash, local_test_GEO_hash_one_level@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,} [[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_one_level([KGBElt] xs) = void:
    FPP_unitary_hash_one_level(xs, unitary_hash)

set FPP_unitary_hash_one_level(RealForm G) = void:
    FPP_unitary_hash_one_level(KGB(G))

set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas, Param_hash Uhash) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, local_test_GEO_hash_bottom_layer@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,} [[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_bottom_layer(xlambdas, unitary_hash)

set FPP_unitary_hash_bottom_layer([KGBElt] xs, Param_hash Uhash) = void:
    FPP_unitary_hash_general(xs, Uhash, local_test_GEO_hash_bottom_layer@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,} [[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_bottom_layer([KGBElt] xs) = void:
    FPP_unitary_hash_bottom_layer(xs, unitary_hash)

set FPP_unitary_hash_bottom_layer(RealForm G) = void:
    FPP_unitary_hash_bottom_layer(KGB(G))

{ lists real and/or complex simple factors }
set simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
	simpleFactors = simple_factors(RootDatum: G),
	Factors = [RealForm]:[]
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex),
	 newDiagram = diagram_component(G,newSimpleRootIndex)
    in  if diagram=newDiagram then Factors##:=
	 [real_form(inner_class(rd,delta), delta, tf)]
	 else if diagram[0] < newDiagram[0] then Factors##:=
	 [real_form(inner_class(sub_datum(G,diagram##newDiagram),
		delta), delta, tf)]
	      fi
	fi
    od; Factors

set derived_simple_factors(RealForm G) = [RealForm]:
    for S in simple_factors(G) do derived(S) od

{(M,N): M is natural restriction from X^*(G) onto X^*(D).
 N is right inverse of M.}
{ set derived_info(RealForm G) = (mat,mat):
    let (,M) = derived_info(G) in (M,required_solution(M, id_mat(G.semisimple_rank)))
}

{descend a parameter for G to all simple factors of theta-stable Levi support(x)}

set descents(Param p) = [Param]:
    let  x = p.x, G = p.real_form, lambda = p.lambda, nu = p.nu
    then P = Parabolic: (support(x), x) {, theta = x.involution}
    then L = P.Levi
    then lambdaL = lambda - G.rho + L.rho, nuL = nu, xL = inverse_embed_KGB(x,L)
    then SF = simple_factors(L)
    then xSs = for S in SF do inverse_embed_KGB(xL,S) od
    then nuSs = for xS in xSs do (nu - xS.involution*nu)/2 od
    in for S@j in SF do parameter(xSs[j], lambda - G.rho + S.rho, nuSs[j]) od
    {
    then DSF = for S in SF do derived(S) od
    then DSFinfos = for S in SF do derived_infos(S) od
    }
