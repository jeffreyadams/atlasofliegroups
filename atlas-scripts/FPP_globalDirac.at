<K_highest_weights {for all_lambda_differential_zero}
<lattice {for vec_solve}
{ <chopping_facets_fast.at {for chop_coroots(G, vertices)}}
<facet_classes {for ordering on facets}
<hash {for KPolHash}
<TWOHEIGHTS {for HTA and HT}
<cohom_reduction {for possible use of cohomological induction}
<FPP_localDirac
<cohIndUnip {for weakly fair cohom ind}
<derived_cover {for simply connected cover of derived group}
{functions for computing the entire FPP_unitary dual}
{typically functions take a Param_hash Uhash and fill it with all
unitary reps having infinitesimal character in the FPP. Each p is
replaced by herm_center(p), at the barycenter of its local facet,
so that the lists are finite.}

{. This controls the maximum denominator size kept in chop_coroots,
used in moving unitarity information from a Levi to G. Large values
allow more chopped facets, and so convey more information to G; but
small values are faster. Too small a value cannot lead to wrong
answers, but only to running more is_unitary tests .}
set chop_bound = int: 6

{if true, compute reps weakly fair cohom induced from Arthur unipotent}
set coh_ind_flag = true

{if true, load Arthur unipotent reps into unitary hash before starting FPP.
Computing Arthur unipotents takes a long time for high rank (e.g. rank 4
complex}
set unip_flag = true

{if true, pass through KGB backwards}
set tilde_flag = true
{next functions aim to compute FULL spherical dual in non-split case,
when several different x give spherical reps}

{if facet_verbose is true, report after each |lambda_skip| lambda's
are treated in FPP_unitary}
set lambda_skip = int:10

{if true, then report summary each lambda in FPP_unitary}
set every_lambda_flag = false

{if true, then report progress during each lambda in FPP_unitary}
set every_lambda_deets_flag = false

{if true, then report summary each KGBElt in FPP_unitary}
set every_KGB_flag = false

{if true, uses the (faster?) function localFD_1Dirac2_by_zero to compute local vertices and edges}
set by_zero_flag = true

set spherical_xs(RealForm G) = [KGBElt]:
    let real_rank = rank(x_open(G).involution + 1)
    in for x in KGB(G)
       do if rank(x.involution + 1) = real_rank
       	  then [x]
	  else []
	  fi
       od.##

set all_lambda_differential_0(mat theta) = [vec]:
    let BLD0 = basis_lambda_differential_0(theta)
    in for v in all_0_1_vecs(n_columns(BLD0))
       do BLD0*v
       od

set_type Lvd_Perm2_mapAct = (VertexData Lvd, PermOrderTwo Perm2, vec mapAct)

{Record for each inner class a list of some involutions in inner class; and for each such involution,
 some possible lambdas; and for each such lambda, a list of (local vertex data, Perm2, mapAct)}
set_type
[Lvd_Perm2_mapAct_table =

( (->int) inner_class_size {number of inner classes included}
  , ( -> vec) ic_vlist_size {for each inner class, the number of FPP-vertices}
  , ( -> ) clear
  , ( -> vec) involution_size {for each inner class, number of involutions so far considered}
  , ( -> [vec]) lamthlam_size {for each inner class and involution, number of d_lambdas (actually lambda+theta*lambda)
      	 		       so far considered}
  , ( -> [[vec]]) Lvd_list_size {for each inner class and involution and d_lambda, size of Lvd.list}
  , (InnerClass -> VertexData) FPP_vertex_data {one for each inner class}
  , (InnerClass -> (vec -> int)) flippable_edge_lookup
  , (InnerClass -> [ratvec]) FPP_local_vertices {one for each inner class}
  , ((InnerClass, mat) -> [vec]) lamthlams {for each involution, list of allowed lambda+theta_lambda}
  , ((InnerClass, mat) -> [ratvec]) lambda0s {for each involution, list of allowed lambda mod twists}
  , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2_mapAct)]) LPm_entries {allowed lambda mod twists, corr entry}
    		       	  	    {like output of old FPP_lambdas_big_new}
  , ((InnerClass, mat, vec) -> VertexData) Lvd {local vertex data, one for each theta and lambda+theta*lambda}
  , ((InnerClass, mat, vec) -> Lvd_Perm2_mapAct) LPm_entry {one for each theta and lambda+theta*lambda}
{  , ((InnerClass, mat, vec) -> ) append {just compute, don't report LPm entry}}
  , (int -> InnerClass) inner_class_index
  , (int -> VertexData) vd_index {vertex data for inner class}
  , ((int,int,int) -> Lvd_Perm2_mapAct) Lvd_Perm2_mapAct_index {one for each inner class, involution,
    		      					       lambda + theta*lambda}
)
]

set make_Lvd_Perm2_mapAct_table() = Lvd_Perm2_mapAct_table:
(   let inner_class_hash = make_InnerClass_hash()
    then inv_hashes = [mat_hash]: [] {one for each inner class}
    then vertex_datas = [VertexData]: [] {one for each inner class}
    then FELs = [(vec->int)]: [] {one for each inner class}
    then FPP_local_verts = [[ratvec]]: [] {one list for each inner class}
    then lamthlam_hashess = [[vec_hash]]: [] {one for each inner class and involution}
    	 {entries are vecs of size ic.rank: lamba+theta*lambda, for a
	 	  certain choice of lambda (defined up to twist and equivalence}
    then entries = [[[Lvd_Perm2_mapAct]]]: [] {one list for each involution and lamthlam}
    then clear() = void:
    	 let () = inner_class_hash.clear()
	 then () = inv_hashes := []
	 then () = vertex_datas := []
	 then () = FELs := []
	 then () = FPP_local_verts := []
	 then () = lamthlam_hashess := []
	 then () = entries := []
	 in ()
    then add_inner_class(InnerClass ic) = int:
    	 let I = inner_class_hash.size()
	 then i = inner_class_hash.match(ic)
    	 then () = if i = I {haven't seen this inner class before}
	      	   then inv_hashes := (inv_hashes next inv_hashes:=[])#make_mat_hash();
	    	   	vertex_datas := (vertex_datas next vertex_datas := [])#FPP_vertex_data(ic);
	    	   	FELs := (FELs next FELs:=[])# FPP_flippable_edge_lookup(ic);
	    	   	FPP_local_verts := (FPP_local_verts next FPP_local_verts:=[])
		     	#FPP_local_vertices(ic, vertex_datas[i].list, FELs[i]);
	    	   	lamthlam_hashess := (lamthlam_hashess next lamthlam_hashess := [])#[];
	    	   	entries := (entries next entries :=[])# []
	    	   fi
	  in i
    then add_involution(InnerClass ic, mat theta) = (int, int):
    	 let i = add_inner_class(ic)
	 then J = inv_hashes[i].size()
      	 then j = inv_hashes[i].match(theta)
     	 then () = if j = J {haven't seen this involution before}
      	      	   then lamthlam_hashess[i] := (lamthlam_hashess[i] next lamthlam_hashess[i] := [])
		    	 			    # make_vec_hash();
		   	entries[i] := (entries[i] next entries[i] := []) # []
		   fi
	 in (i, j)
    then add_lamthlam_hash(InnerClass ic, mat theta) = (int, int):
      	 let (i,j) = add_involution(ic,theta)
      	 then th1 = 1+theta, verts = FPP_local_verts[i]
      	 then cands = for v in verts
      	   	      do if ((th1*v).denom = 1) then [ratvec_as_vec(th1*v)]
		      	 else []
		      	 fi
		      od.##.no_reps
      	 then () = for lamthlam in cands
      	      	   do case vec_solve(th1,lamthlam - th1*ic.rho)
                    | else () {[(ratvec,VertexData,PermOrderTwo,vec)]: []}
                    | solution(lr):
                      let k = lamthlam_hashess[i][j].match(lamthlam)
		      then tempi = entries[i]
                      then () = if k = #tempi[j]
                                then tempi[j]:=
                                (tempi[j] next tempi[j]:=[])
                                              #localFD_Lvd2(th1-1,lr+ic.rho,vertex_datas[i],FELs[i])
                                fi
		      then () = entries[i]:= tempi
		      in ()
                      esac
		   od
         in (i, j)
    in
    ( ( -> int): {inner_class_size} @int: inner_class_hash.size()
    , ( -> vec): {ic_vlist_size} @vec: for vd in vertex_datas do #vd.list od
    , ( -> ): {clear} clear
    , ( -> vec): {involution_size} @vec: for inv_hash in inv_hashes do inv_hash.size() od
    , ( -> [vec]): {lamthlam_size} @[vec]:
      for lamthlam_hashes in lamthlam_hashess {ith inner class}
      do for lamthlam_hash in lamthlam_hashes    {jth involution}
      	 do lamthlam_hash.size()
	 od
      od
    , ( -> [[vec]]): {Lvd_list_size} @[[vec]]:
      for i: #entries
      do for j: #entries[i]
	 do for k: #entries[i][j]
	    do #(entries[i][j][k].Lvd.list)
	    od {vec for involution}
	 od {[vec] for inner class}
      od
    , (InnerClass -> VertexData): {FPP_vertex_data}  (InnerClass ic) VertexData:
      let i = add_inner_class(ic)
      in vertex_datas[i]
    , (InnerClass -> (vec -> int)): {flippable_edge_lookup} (InnerClass ic) (vec -> int):
      let i = add_inner_class(ic)
      in FELs[i]
    , (InnerClass -> [ratvec]): {FPP_local_vertices} (InnerClass ic)  [ratvec]:
      let i = add_inner_class(ic)
       in FPP_local_verts[i]
    , ((InnerClass, mat) -> [vec]): {lamthlams} (InnerClass ic, mat theta) [vec]:
      let (i,j) = add_lamthlam_hash(ic,theta)
      in for k:lamthlam_hashess[i][j].size() do lamthlam_hashess[i][j].index(k)[:ic.rank] od
    , ((InnerClass, mat) -> [ratvec]): {lambda0s} (InnerClass ic, mat theta) [ratvec]:
      let (i,j) = add_lamthlam_hash(ic,theta)
      in for k:lamthlam_hashess[i][j].size()
      	 do let lamthlam = lamthlam_hashess[i][j].index(k), th1 = 1+theta
	    then lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
      	    in lr+ic.rho
	 od
    , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2_mapAct)]): {LPm_entries} (InnerClass ic, mat theta) [(ratvec, Lvd_Perm2_mapAct)]:
      let (i,j) = add_lamthlam_hash(ic,theta), th1 = theta+1
      in for k:lamthlam_hashess[i][j].size()
      	 do let lamthlam = lamthlam_hashess[i][j].index(k)
	    then lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
	    in (lr+ic.rho, entries[i][j][k])
	 od
    , ((InnerClass, mat, vec) -> VertexData): {Lvd} (InnerClass ic, mat theta, vec lamthlam) VertexData:
      let (i,j) = add_lamthlam_hash(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k].Lvd
    , ((InnerClass, mat, vec) -> Lvd_Perm2_mapAct): {LPm_entry} (InnerClass ic, mat theta, vec lamthlam) Lvd_Perm2_mapAct:
      let (i,j) = add_lamthlam_hash(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k]
    , (int -> InnerClass): {inner_class_index} (int i) InnerClass: inner_class_hash.index(i)
    , (int -> VertexData): {vd_index} (int i) VertexData: vertex_datas[i]
    , ((int,int,int) -> Lvd_Perm2_mapAct): {Lvd_Perm2_mapAct_index} (int i, int j, int k): Lvd_Perm2_mapAct: entries[i][j][k]
)
)

set LPm_table = make_Lvd_Perm2_mapAct_table()

{this is the list of all possible lambda + theta*lambda for ic and theta}
set FPP_lamthlams(InnerClass ic, mat theta) = [vec]:
    LPm_table.lamthlams(ic,theta)

{list of lambdas up to twist by differential zero}
set FPP_lambda0s(InnerClass ic, mat theta) = [ratvec]:
    LPm_table.lambda0s(ic, theta)

set FPP_lambdas(KGBElt x) = [ratvec]:
    let lambda0s = FPP_lambda0s(x.inner_class, x.involution), G = x.real_form
    then twists = all_lambda_differential_0(x.involution)
    then zeroPol = null_module(G), zeroNu = null(G.rank)/1
    in for lambda0 in lambda0s
       do if 1*parameter(x, lambda0, zeroNu) != zeroPol
       	  then for tau in twists
	       do parameter(x, lambda0+tau, zeroNu).lambda
	       od
	  else []
	  fi
       od.##

set FPP_lambdas([KGBElt] xs) = [[ratvec]]:
    for x in xs
    do FPP_lambdas(x)
    od

{meant to hold barycenters of unitary facets}
set unitary_hash = make_Param_hash()

{meant to hold all unitary parameters found (maybe not final}
set uparam_hash = make_Param_hash()

{load a bunch of Param_hash's into one}
set transfer([Param_hash] Us, Param_hash target) = void:
    for U in Us
    do for j:U.size()
       do target.match(U.index(j))
       od
    od

{derived simple factors of all Levis of theta-stable P, omitting P=G}
set DSFLevis(RealForm G) = [RealForm]:
    for P in theta_stable_parabolics(G)~[1:]
    do derived_simple_factors(P.Levi) od.##

set DSFLevi_hash(RealForm G) = RealForm_hash:
    make_RealForm_hash(DSFLevis(G), hash_code@(RealForm,int))

{uses LPm_table to keep track of local facet info}
set FPP_unitary_hash_general([(KGBElt,ratvec)] xlambdas, Param_hash Uhash,
    Param_hash Uparamhash, (KGBElt, ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
    if #xlambdas = 0 then return ()
    else let (x,) = xlambdas[0]
    then G = x.real_form
    then {vd = FPP_vertex_data(G),} start = elapsed_ms()
    then () = unitaryTime := 0
    then () = prepDirac(G)
    then xnums = for (x,) in xlambdas do let (,m) = %x in m od
    then lambdas = for (,lambda) in xlambdas do lambda od, pol_hash = make_KTypePol_hash()
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then LPmss = for (x,lambda) in xlambdas
    	       	 do LPm_table.LPm_entry(G,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
              	 od
    then () = facet_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,Uhash)
	      fi
    then xlambdatimes = [int]: null(#xlambdas)
    then answerCards = [int]: null(#xlambdas) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    {then () = adjust_global_top(G)} {done internally by low_FPP_facets}
    then () = if #global_facets = 0 or #global_facets[0] != LPm_table.FPP_vertex_data(G).list.#
    	      then global_facets := low_FPP_facets(G)
	      fi
    then () = if by_zero_flag and (#global_facets_by_zero = 0 or
    	      	 #global_facets_by_zero[0] != LPm_table.FPP_vertex_data(G).list.#)
    	      then global_facets_by_zero := low_FPP_facets_by_zero(global_facets)
	      fi
    then current = elapsed_ms(), oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 	   oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
    then () = for (x,lambda)@k in xlambdas
    	      do {xlambdas} 
	 	 let start = elapsed_ms(), startUhash = Uhash.size(),
		     		   startUcounter = unitary_test_counter.use_count(), theta = x.involution
		 then (Lvd, Perm2, mapAct) = LPmss[k]
		 then LF = if by_zero_flag
		      	   then localFD_1Dirac2_by_zero(x, lambda, Lvd, Perm2, mapAct, global_facets_by_zero)
			   else localFD_1Dirac2(x, lambda, Lvd, Perm2, mapAct, global_facets)
			   fi
		 in if #LF[0] = 0 then ()
		     else if every_lambda_deets_flag
			  then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
			       test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			  fi;
			  let answer = local(x, lambda, LPm_table.FPP_vertex_data(G) , Lvd, LF, pol_hash, Uhash)
			  then () = answerCards[k] := #answer
			  then () = for p in answer do Uparamhash.match(p) od
   		    	  then () = current := elapsed_ms(); currentUhash := Uhash.size();
			       	    currentUcounter := unitary_test_counter.use_count()
    		 	  then () = xlambdatimes[k] := current - start
    			  in if every_lambda_flag
	      		     then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) = (", xnums[k], ",",k{lambdas[k]},")", test_string);
			         prints("    #LF = ", for L in LF do #L od, "; #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests = ", unitary_test_counter.use_count() - startUcounter);
				 prints("  ------------------")
			     fi
		    fi
		 od{xlambdas}
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    in prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xnums[longest], ",",
	      lambdas[longest],")");
       prints(" time spent in is_unitary = ",print_time_string(unitaryTime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count());
       prints("  #hash_real_dumb =",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb calls=", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb =", hash_def_dumbCounter.use_count());
       prints("  #hash =", hashCounter.use_count(),
	      ", #hash2 =", hash2Counter.use_count(),
	      ", #hash_one_level =", hash_one_levelCounter.use_count(),
	      ", #hash_bottom_layer = ", hash_bottom_layerCounter.use_count());
       prints("Number of unitary params = ", sum(answerCards));
       prints("Number of FPP-unitary facets = ",Uhash.size(),
              ", number found on this run = ", Uhash.size() - oldUhash)
    fi

set FPP_unitary_hash_general([KGBElt] xs, Param_hash Uhash, Param_hash Uparamhash,
    (KGBElt, ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
    if #xs = 0
    then return ()
    else
    {let () = deform_flag:=true}
    let () = if tilde_flag
    	      then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      fi
    then G = xs[0].real_form
    then start = elapsed_ms(), zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then () = unitaryTime := 0
    then () = prepDirac(G)
    then xnums = for x in xs do let (,m) = %x in m od, xtimes = null(#xs), pol_hash = make_KTypePol_hash()
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = facet_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,Uhash)
	      fi
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,Uhash)
	      fi
    then times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
    then () = if #global_facets = 0 or #global_facets[0] != LPm_table.FPP_vertex_data(G).list.# {#vd.list}
    	      then global_facets := low_FPP_facets(G)
	      fi
    then () = global_facets_by_zero := low_FPP_facets_by_zero(global_facets)
    then current = elapsed_ms()
    then oldUhash = Uhash.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
    then () = for x@j in xs
    	      do {xs} 
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter
	 then twists = all_lambda_differential_0(x)
	 then LPm_entries = LPm_table.LPm_entries(G,x.involution)
         then good_entries = for (lambda0,entry) in LPm_entries
                              do  if 1*parameter(x,lambda0,zeroNu) != zeroPol
                                  then [(lambda0,entry)]
                                  else []
                                  fi
                              od.##
         then lambdas = [ratvec]:
              for (lambda0,) in good_entries
              do for tau in twists
                 do lambda0+tau
                 od
              od.##
    	 then Ncases = #lambdas
	 then tempanswerCards = null(Ncases)
	 then templambdatimes = null(Ncases)
	 then () = if every_KGB_flag
      	      	   then prints("     start KGBElt #", xnums[j], ", #lambdas = ",#lambdas,
		   	       " Uhash.size() = ", Uhash.size(), ", running time = ",
			       print_time_string(elapsed_ms() - start));
		   	prints("  ------------------")
        	   fi
	 then () = for (lambda0, (Lvd, Perm2, mapAct))@k in good_entries
      	      	   do for tau@ell in twists
                      do let startlambda = elapsed_ms(), startUhash = Uhash.size(),
		      	     startUcounter = unitary_test_counter.use_count(), index = k*#twists+ell
			 then LF = if by_zero_flag
		      	      	   then localFD_1Dirac2_by_zero(x, lambda0+tau, Lvd, Perm2, mapAct, global_facets_by_zero)
			   	   else localFD_1Dirac2(x, lambda0+tau, Lvd, Perm2, mapAct, global_facets)
			   	   fi
			 in if #LF[0] = 0
			    then []
                            else if every_lambda_deets_flag
			    	 then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
				 test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
				 fi;
				 let answer = local(x, lambda0+tau, LPm_table.FPP_vertex_data(G), Lvd, LF, pol_hash, Uhash)
			  	 then () = tempanswerCards[index] := #answer
			  	 then () = for p in answer do Uparamhash.match(p) od
				 then () = if every_lambda_deets_flag
			    	      	   then facet_verbose := false; time_verbose := false;
				 	   	test_verbose := false; test_slightly_verbose := false
				 	   fi
 			 	 then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 in if every_lambda_flag
				    then prints("  ",print_time_string(templambdatimes[index]),
			   	    	 	" = time for (x,lambda) = (", xnums[j], ",",
						k*#twists + ell, ")", test_string);
				         prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",
					 	 tempanswerCards[index],
			     	                ", #new unitary = ", Uhash.size() - startUhash,
						", #tests = ", unitary_test_counter.use_count() - startUcounter);
					 prints("  ------------------")
				    fi
			    fi
                      od
                   od {would be easy enough to get [Param] for each (x,lambda), but for now
		       just put unitary reps in Uhash}
           then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     answerCards[j]:= tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag
                     then  prints("     time for KGBElt ",xnums[j]," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for #", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
			  prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary facets = ",
			     currentUhash - formerUhash, ", #tests = ",
		     	     currentUcounter - formerUcounter, ", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count())
                     fi
           in ()
         od {xs}
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    in prints("----------------");
       prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xnums[longest]);
       prints("Time spent in is_unitary = ",print_time_string(unitaryTime),
       	      ", number of unitarity tests = ", unitary_test_counter.use_count());
       prints("  #hash_real_dumb =",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb =", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb =", hash_def_dumbCounter.use_count());
       prints("  #hash =", hashCounter.use_count(),
	      ", #hash2 =", hash2Counter.use_count(),
	      ", #hash_one_level =", hash_one_levelCounter.use_count(),
              ", #hash_bottom_layer =", hash_bottom_layerCounter.use_count());
       prints("Number of unitary params = ", sum((for list in answerCards do sum(list) od)));
       prints("Number of known FPP-unitary facets = ",Uhash.size(),
       	      ", number found on this run = ", Uhash.size() - oldUhash)
   fi

set FPP_unitary_hash_general(RealForm G,Param_hash Uhash, Param_hash Uparamhash,
    (KGBElt,ratvec,VertexData,VertexData, [[FacetVertsIndex]],
    KTypePol_hash, Param_hash->[Param])
    local) = void:
    if is_compact(G)
    then for p in all_parameters_gamma(G,G.rho)
    do Uhash.match(p) od
    else
    FPP_unitary_hash_general(KGB(G), Uhash, Uparamhash, local)
    fi

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, Param_hash Uparamhash) = void:
    let () = real_flag:=true in
    FPP_unitary_hash_general(xlambdas, Uhash, Uparamhash, local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_real_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_real_dumb(xlambdas, unitary_hash, uparam_hash)

set FPP_unitary_hash_real_dumb([KGBElt] xs, Param_hash Uhash, Param_hash Uparamhash) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xs, Uhash, Uparamhash, local_test_GEO_hash_real_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_real_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_real_dumb(xs, unitary_hash, uparam_hash)

set FPP_unitary_hash_real_dumb(RealForm G) = void:
    FPP_unitary_hash_real_dumb(KGB(G))

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, Param_hash Uparamhash) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xlambdas, Uhash, Uparamhash, local_test_GEO_hash_def_dumb@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_def_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_def_dumb(xlambdas, unitary_hash, uparam_hash)

set FPP_unitary_hash_def_dumb([KGBElt] xs, Param_hash Uhash, Param_hash Uparamhash) = void:
    let () = def_flag:=true in
    FPP_unitary_hash_general(xs, Uhash, Uparamhash, local_test_GEO_hash_def_dumb@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_def_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_def_dumb(xs, unitary_hash, uparam_hash)

set FPP_unitary_hash_def_dumb(RealForm G) = void:
    FPP_unitary_hash_def_dumb(KGB(G))

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, Param_hash Uparamhash) = void:
    let () = def_flag:=false in
    FPP_unitary_hash_general(xlambdas, Uhash, Uparamhash, local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_dumb([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_dumb(xlambdas, unitary_hash, uparam_hash)

set FPP_unitary_hash_dumb([KGBElt] xs, Param_hash Uhash, Param_hash Uparamhash) = void:
    let () = def_flag:=false in
    FPP_unitary_hash_general(xs, Uhash, Uparamhash, local_test_GEO_hash_dumb@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_dumb([KGBElt] xs) = void:
    FPP_unitary_hash_dumb(xs,unitary_hash, uparam_hash)

set FPP_unitary_hash_dumb(RealForm G) = void:
    FPP_unitary_hash_dumb(KGB(G))

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, Param_hash Uparamhash) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, Uparamhash, local_test_GEO_hash@(
    KGBElt,ratvec,VertexData,VertexData,{vec,vec,}[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash(xlambdas, unitary_hash, uparam_hash)

set FPP_unitary_hash([KGBElt] xs, Param_hash Uhash, Param_hash Uparamhash) = void:
    FPP_unitary_hash_general(xs, Uhash, Uparamhash, local_test_GEO_hash@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash([KGBElt] xs) = void:
    FPP_unitary_hash(xs,unitary_hash, uparam_hash)

set FPP_unitary_hash(RealForm G) = void:
    FPP_unitary_hash(KGB(G),unitary_hash, uparam_hash)

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, Param_hash Uparamhash) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, Uparamhash, local_test_GEO_hash2@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash2([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash2(xlambdas, unitary_hash, uparam_hash)

set FPP_unitary_hash2([KGBElt] xs, Param_hash Uhash, Param_hash Uparamhash) = void:
    FPP_unitary_hash_general(xs, Uhash, Uparamhash, local_test_GEO_hash2@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash2([KGBElt] xs) = void:
    FPP_unitary_hash2(xs, unitary_hash, uparam_hash)

set FPP_unitary_hash2(RealForm G) = void:
    FPP_unitary_hash2(KGB(G))

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas, Param_hash Uhash, Param_hash Uparamhash) = void:
    FPP_unitary_hash_general(xlambdas, Uhash, Uparamhash, local_test_GEO_hash_one_level@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_one_level([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_one_level(xlambdas, unitary_hash, uparam_hash)

set FPP_unitary_hash_one_level([KGBElt] xs, Param_hash Uhash, Param_hash Uparamhash) = void:
    FPP_unitary_hash_general(xs, Uhash, Uparamhash, local_test_GEO_hash_one_level@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))

set FPP_unitary_hash_one_level([KGBElt] xs) = void:
    FPP_unitary_hash_one_level(xs, unitary_hash, uparam_hash)

set FPP_unitary_hash_one_level(RealForm G) = void:
    FPP_unitary_hash_one_level(KGB(G))

set bottom_data = make_steady_bottom_data()

set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas, steady_bottom_data bott_data, Param_hash UhashG,
    Param_hash Uparamhash) = void:
    if #xlambdas = 0 then return ()
    else let (x,) = xlambdas[0], pol_hash = make_KTypePol_hash()
    then G = x.real_form
    then disconn_flag = components_rank(G) > 0
    then (Gsc,M) = if disconn_flag
    	      	   then derived_cover_real_form_info(G)
	      	   else (G,id_mat(G.rank))
	      	   fi
    then xlambdas_sc = if disconn_flag
    	      	       then for (x,lambda) in xlambdas do (inverse_embed_KGB(x, Gsc, M), M*lambda) od
	      	       else xlambdas
	      	       fi
    then Uhash = if disconn_flag
    	      	 then make_Param_hash() {this is for unitary reps of Gsc that factor to G}
		 else UhashG
		 fi
    then start = elapsed_ms()
    then () = unitaryTime := 0
    then () = dfkiTime := 0
    then () = prepDirac(Gsc)
    then xnums = for (x,) in xlambdas do let (,m) = %x in m od
    then lambdas = for (,lambda) in xlambdas do lambda od
    then LPmss = for (x,lambda) in xlambdas_sc
    	       	 do LPm_table.LPm_entry(Gsc,x.involution, ratvec_as_vec(lambda+x.involution*lambda))
		 od
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = facet_verbose:=false; time_verbose:=false; test_verbose:=false; test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,UhashG)
	      fi
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,UhashG)
	      fi
    then () = if disconn_flag
    	      then for j:UhashG.size()
	      	   do for psc in sc_lifts(UhashG.index(j), Gsc, M)
		      do Uhash.match(psc)
		      od
		   od
	      fi
    then xlambdatimes = [int]: null(#xlambdas)
    then answerCards = [int]: null(#xlambdas) {number of unitary parameters found}
    then oldUhash = Uhash.size()
    then () = if #global_facets = 0 or #global_facets[0] != LPm_table.FPP_vertex_data(Gsc).list.#
    	      then global_facets := low_FPP_facets(G)
	      fi
    then () = if by_zero_flag and (#global_facets_by_zero = 0 or #global_facets_by_zero[0] !=
    	      	 LPm_table.FPP_vertex_data(Gsc).list.#) {#vd_sc.list)}
    	      then global_facets_by_zero := low_FPP_facets_by_zero(global_facets)
	      fi
    then current = elapsed_ms(), oldUhash = UhashG.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 	   oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count(),
		   start_min_L_bottom_factors = bott_data.min_L_bottom_factors_time()
    then () = for (x,lambda)@k in xlambdas
    	      do {xlambdas} 
	 	 let start = elapsed_ms(), startUhash = Uhash.size(), (x_sc,lambda_sc) = xlambdas_sc[k],
		     		   startUcounter = unitary_test_counter.use_count(), theta = x.involution,
				   startUparamhash = Uparamhash.size()
		 then (Lvd, Perm2, mapAct) = LPmss[k] {already lives on Gsc}
		 then LF = if by_zero_flag
		      	   then localFD_1Dirac2_by_zero(x_sc, lambda_sc, Lvd, Perm2, mapAct, global_facets_by_zero)
			   else localFD_1Dirac2(x_sc, lambda_sc, Lvd, Perm2, mapAct, global_facets)
			   fi
		 in if #LF[0] = 0 then ()
		    else if every_lambda_deets_flag
			 then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
			      test_verbose :=old_test_verbose; test_slightly_verbose := old_test_slightly_verbose
			 fi;
			 let answer = local_test_GEO_hash_bottom_layer(x_sc, lambda_sc, LPm_table.FPP_vertex_data(Gsc),
			     	      					     Lvd, LF, bott_data, pol_hash, Uhash)
			 then () = answerCards[k] := #answer
			 then () = for p in answer do Uparamhash.match(p) od
   		    	 then () = current := elapsed_ms(); currentUhash := Uhash.size();
			       	    currentUcounter := unitary_test_counter.use_count()
    		 	 then () = xlambdatimes[k] := current - start
    			 in if every_lambda_flag
	      		    then prints("  ",print_time_string(xlambdatimes[k]),
			   	" = time for (x,lambda) = (", xnums[k], ",",k,"), ht = ",
				  height(parameter(x,lambda,0*lambda)), ", L = ", let (Q,) =
				  theta_stable_quasi_data(parameter(x,lambda,0*lambda)) in Q.Levi,
				  ",",test_string);
			         prints("    #LF = ", for L in LF do #L od, "; #unitary params = ", answerCards[k],
				 ", #new unitary = ", Uhash.size() - startUhash,
				 ", #tests = ", unitary_test_counter.use_count() - startUcounter);
				 prints("  ------------------")
			    fi
		    fi
		 od{xlambdas}
    then () = if disconn_flag
	      then for j: Uhash.size()
		   do for p in sc_descends(Uhash.index(j), G, M)
		      do UhashG.match(p)
		      od
		   od
	       fi
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose;
    	      test_verbose:=old_test_verbose; test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(xlambdatimes)
    in prints(new_line,"Total time = ", print_time_string(current-start),
       	      "; max time = ",print_time_string(xlambdatimes[longest]),
	      " for (x,lambda) = (",  xnums[longest], ",", lambdas[longest],")");
       prints("Time spent in is_unitary = ",print_time_string(unitaryTime), ", number of unitarity tests = ",
       		unitary_test_counter.use_count());
       prints("Time in min_L_bottom_factors = ",
       print_time_string(bott_data.min_L_bottom_factors_time() - start_min_L_bottom_factors),
	      ", number of K-types studied = ", bott_data.size());
       prints("Time in derived_factor_K_types_info = ", print_time_string(dfkiTime),
       	      ", time in min_bottom_elim_factors = ",print_time_string(mbefTime));
       prints("Time in bottom layer branching = ",print_time_string(rf_sig_tables.bottom_branch_time()),
       		    ", time in bottom layer sig = ", print_time_string(rf_sig_tables.bottom_sig_time()));
       prints("Time in min_bottom_elim_factors = ",print_time_string(mbefTime));
       prints("  #hash_real_dumb =",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb =", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb =", hash_def_dumbCounter.use_count());
       prints("  #hash =", hashCounter.use_count(),
	      ", #hash2 =", hash2Counter.use_count(),
	      ", #hash_one_level =", hash_one_levelCounter.use_count(),
	      ", #hash_bottom_layer =", hash_bottom_layerCounter.use_count());
       prints("Number of unitary params = ", sum(answerCards));
       prints("Number of FPP-unitary facets = ",UhashG.size(),
              ", number found on this run = ", UhashG.size() - oldUhash)
    fi

set FPP_unitary_hash_bottom_layer([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_bottom_layer(xlambdas, bottom_data, unitary_hash, uparam_hash)

set FPP_unitary_hash_bottom_layer([KGBElt] xs,  steady_bottom_data bott_data,
				  Param_hash UhashG, Param_hash Uparamhash) = void:
    if #xs = 0
    then return ()
    else let () = if tilde_flag
    	     	  then xs:= for x in xs ~do x od{; deform_flag:=false}
    	      	  fi
    then G = xs[0].real_form
    then disconn_flag = components_rank(G) > 0, zeroPol = null_module(G), zeroNu = null(G.rank)/1
    then (Gsc,M) = if disconn_flag
    	      	   then derived_cover_real_form_info(G)
	      	   else (G,id_mat(G.rank))
	      	   fi
    then xs_sc = if disconn_flag
    	       	 then for x in xs do inverse_embed_KGB(x, Gsc, M) od
	      	 else xs
	      	 fi
    then Uhash = if disconn_flag
    	       	 then make_Param_hash()
		 else UhashG
		 fi
    then start = elapsed_ms()
    then () = unitaryTime := 0
    then () = dfkiTime := 0
    then () = prepDirac(Gsc)
    then xnums = for x in xs do let (,m) = %x in m od, xtimes = null(#xs)
    then pol_hash = make_KTypePol_hash()
    then old_facet_verbose = facet_verbose, old_time_verbose = time_verbose,
    	 old_test_verbose = test_verbose, old_test_slightly_verbose = test_slightly_verbose
    then () = facet_verbose:=false
    then () = time_verbose:=false
    then () = test_verbose:=false
    then () = test_slightly_verbose:=false
    then () = if unip_flag
    	      then unipotents_to_hash(G,UhashG)
	      fi
    then () = if coh_ind_flag
    	      then coh_ind_unip_long(G,UhashG)
	      fi
    then () = if disconn_flag
    	      then for j:UhashG.size()
	      	   do for psc in sc_lifts(UhashG.index(j), Gsc, M)
		      do Uhash.match(psc)
		      od
		   od
	       fi
    then times = [int]: null(#xs)
    then lambdatimes = [[int]]: for j:#xs do [] od
    then answerCards = [[int]]: for j:#xs do [] od {number of unitary parameters found}
    then () = if #global_facets = 0 or #global_facets[0] != LPm_table.FPP_vertex_data(G).list.#
    	      then global_facets := low_FPP_facets(G)
	      fi
    then () = global_facets_by_zero := low_FPP_facets_by_zero(global_facets)
    then current = elapsed_ms()
    then oldUhash = UhashG.size(), currentUhash = Uhash.size(), formerUhash = Uhash.size(),
    	 oldUcounter = unitary_test_counter.use_count(), currentUcounter = unitary_test_counter.use_count()
    then () = for x@j in xs
    	      do {xs}
	 let former_time = current, formerUhash = currentUhash, formerUcounter = currentUcounter, x_sc = xs_sc[j]
	 then twists = all_lambda_differential_0(x)
	 then LPm_entries = [(ratvec, Lvd_Perm2_mapAct)]: LPm_table.LPm_entries(G, x.involution)
	 then good_entries = for (lambda0,entry) in LPm_entries
	      	       	      do  if 1*parameter(x,lambda0,zeroNu) != zeroPol
		       	      	  then [(lambda0,entry)]
			   	  else []
			   	  fi
		       	      od.##
	 then lambdas = [ratvec]:
	      for (lambda0,) in good_entries
	      do for tau in twists
	      	 do lambda0+M*tau
		 od
	      od.##
    	 then Ncases = #lambdas
	 then tempanswerCards = null(Ncases)
	 then templambdatimes = null(Ncases)
	 then () = if every_KGB_flag
      	      	   then prints("     start KGBElt #", xnums[j], ", #lambdas = ",Ncases,
		   	       " Uhash.size() = ", Uhash.size(), ", running time = ",
			       print_time_string(elapsed_ms() - start));
		   	prints("  ------------------")
        	   fi
	 then () = for (lambda1,(Lvd1,Perm2,mapAct)) @k in good_entries
	      	   do let lambda0 = M*lambda1
		      then Lvd = if disconn_flag
		      	      	 then to_vertex_data(for v in Lvd1.list do M*v od)
				 else Lvd1
				 fi
		      then () =
		      for tau@ell in twists
                      do let startlambda = elapsed_ms(), startUhash = Uhash.size(),
		      	     startUcounter = unitary_test_counter.use_count(), index = k*#twists + ell,
			     startUparamhash = Uparamhash.size()
			 then LF = if by_zero_flag
		      	      	   then localFD_1Dirac2_by_zero(x_sc, lambda0+M*tau, Lvd, Perm2,
						     mapAct, global_facets_by_zero)
			   	   else localFD_1Dirac2(x_sc, lambda0+M*tau, Lvd, Perm2, mapAct,
						     global_facets)
			   	   fi
			 in if #LF[0] = 0
			    then []
                            else if every_lambda_deets_flag
			    	 then facet_verbose := old_facet_verbose; time_verbose := old_time_verbose;
				      test_verbose :=old_test_verbose; test_slightly_verbose :=
				      old_test_slightly_verbose
				 fi;
				 let answer = local_test_GEO_hash_bottom_layer(x_sc, lambda0+M*tau,
				     	    LPm_table.FPP_vertex_data(Gsc), Lvd, LF, bott_data, pol_hash, Uhash)
			  	 then () = tempanswerCards[index] := #answer
			  	 then () = for p in answer do Uparamhash.match(p) od
				 then () = if every_lambda_deets_flag
			    	      	   then facet_verbose := false; time_verbose := false;
				 	   	test_verbose := false; test_slightly_verbose := false
				 	   fi
 			 	 then () = templambdatimes [index] := elapsed_ms() - startlambda
			 	 in if every_lambda_flag
				    then prints("  ",print_time_string(templambdatimes[index]),
			   	    " = time for (x,lambda) = (", xnums[j], ",", k*#twists + ell, "), ht = ",
				    height(parameter(x,lambda0+M*tau,0*tau)),", L = ",
				    let (Q,) = theta_stable_quasi_data(parameter(x,lambda0+M*tau,0*tau))
				    in Q.Levi, ",",test_string);
				         prints("    #LF = ", for L in LF do #L od, ", #unitary params = ",
					 tempanswerCards[index],
			     	                ", #new unitary = ", Uhash.size() - startUhash,
						", #tests = ", unitary_test_counter.use_count() - startUcounter);
					 prints("  ------------------")
				    fi
			       fi
                          od {twists}
	         in ()
                 od {good_entries} {would be easy enough to get [Param] for each (x,lambda), but for now
		       just put unitary reps in Uhash}
    	   then () = if disconn_flag
	   	     then for j: Uhash.size()
		     	  do for p in sc_descends(Uhash.index(j), G, M)
			     do UhashG.match(p)
			     od
			  od
		     fi
            then () = current := elapsed_ms(); currentUhash := Uhash.size();  times[j] := current -former_time;
	   	     lambdatimes[j] := templambdatimes; currentUcounter := unitary_test_counter.use_count();
		     answerCards[j] := tempanswerCards
	   then longLambdaLoc = max_loc(templambdatimes)
           then () = if every_KGB_flag
                     then  prints("     time for KGBElt ",xnums[j]," was ",
                          print_time_string(times[j]), "; longest lambda = ",
			  print_time_string(templambdatimes[longLambdaLoc]),
			  " for #", longLambdaLoc, " = ",lambdas[longLambdaLoc]);
			  prints("     #unitary params = ", sum(tempanswerCards), ", #new unitary facets = ",
			     currentUhash - formerUhash, ", #tests = ",
		     	     currentUcounter - formerUcounter, ", #def lookups = ",
		      	     deformLookupCounter.use_count(), ", #def calcs = ",
		     	     deformCalcCounter.use_count())
                     fi
           in ()
         od {xs}
    then () = facet_verbose:=old_facet_verbose; time_verbose:=old_time_verbose; test_verbose:=old_test_verbose;
    	      test_slightly_verbose:=old_test_slightly_verbose
    then longest = max_loc(times)
    in prints("----------------");
       prints("Total time = ", print_time_string(current-start),
              "; max time = ",print_time_string(times[longest]),
              " for KGBElt ",xnums[longest]);
       prints("Time spent in is_unitary = ",print_time_string(unitaryTime), ", number of unitarity tests = ",
       		unitary_test_counter.use_count());
       prints("Time in min_L_bottom_factors = ",
       	      print_time_string(bott_data.min_L_bottom_factors_time()),
	      ", number of K-types studied = ", bott_data.size());
       prints("Time in derived_factor_K_types_info = ",print_time_string(dfkiTime),
       	      ", time in min_bottom_elim_factors = ", print_time_string(mbefTime));
       prints("Time in bottom layer branching = ",print_time_string(rf_sig_tables.bottom_branch_time()),
       		    ", time in bottom layer sig = ", print_time_string(rf_sig_tables.bottom_sig_time()));
       prints("  #hash_real_dumb = ",hash_real_dumbCounter.use_count(),
	      ", #hash_dumb = ", hash_dumbCounter.use_count(),
       	      ", #hash_def_dumb =", hash_def_dumbCounter.use_count());
       prints("  #hash = ", hashCounter.use_count(),
	      ", #hash2 = ", hash2Counter.use_count(),
	      ", #hash_one_level = ", hash_one_levelCounter.use_count(),
	      ", #hash_bottom_layer = ", hash_bottom_layerCounter.use_count());
       prints("Number of unitary params = ", sum(for list in answerCards do sum(list) od));
        prints("Number of known FPP-unitary facets = ",UhashG.size(),
       	      ", number found on this run = ", UhashG.size() - oldUhash)
   fi

set FPP_unitary_hash_bottom_layer([KGBElt] xs) = void:
    FPP_unitary_hash_bottom_layer(xs,  bottom_data, unitary_hash, uparam_hash)

set FPP_unitary_hash_bottom_layer(RealForm G) = void:
    FPP_unitary_hash_bottom_layer(KGB(G))

{ lists real and/or complex simple factors }
{moved to cohom_reductionND.at}{
set simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
	simpleFactors = simple_factors(RootDatum: G),
	Factors = [RealForm]:[]
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex),
	 newDiagram = diagram_component(G,newSimpleRootIndex)
    in  if diagram=newDiagram then Factors##:=
	 [real_form(inner_class(rd,delta), delta, tf)]
	 else if diagram[0] < newDiagram[0] then Factors##:=
	 [real_form(inner_class(sub_datum(G,diagram##newDiagram),
		delta), delta, tf)]
	      fi
	fi
    od; Factors
}
{moved to cohom_reduction.at}
{
set derived_simple_factors(RealForm G) = [RealForm]:
    for S in simple_factors(G) do derived(S) od
}

{(M,N): M is natural restriction from X^*(G) onto X^*(D).
 N is right inverse of M.}
{ set derived_info(RealForm G) = (mat,mat):
    let (,M) = derived_info(G) in (M,required_solution(M, id_mat(G.semisimple_rank)))
}

{descend a parameter for G to all simple factors of theta-stable Levi support(x)}

{elsewhere}
{
set descents(Param p) = [Param]:
    let  x = p.x, G = p.real_form, lambda = p.lambda, nu = p.nu
    then P = Parabolic: (support(x), x) {, theta = x.involution}
    then L = P.Levi
    then lambdaL = lambda - G.rho + L.rho, nuL = nu, xL = inverse_embed_KGB(x,L)
    then SF = simple_factors(L)
    then xSs = for S in SF do inverse_embed_KGB(xL,S) od
    then nuSs = for xS in xSs do (nu - xS.involution*nu)/2 od
    in for S@j in SF do parameter(xSs[j], lambda - G.rho + S.rho, nuSs[j]) od
    {
    then DSF = for S in SF do derived(S) od
    then DSFinfos = for S in SF do derived_infos(S) od
    }
}
