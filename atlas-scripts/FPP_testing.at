<FPP_globalDirac
<bottom_layer

set local_verts_param_hash = make_Param_hash()

{if false, record ALL local vertices}
set local_test_only_big_flag = true

{this puts local parameters for local vertices into LF_hash for separate testing}
set local_LF(KGBElt x,ratvec lambda, VertexData vd, VertexData Lvd, [[FacetVertsIndex]] LF,
    KTypePol_hash pol_hash, Param_hash LF_hash) = [Param]:
    let () = for v in LF[0]
    	     do LF_hash.match(parameter(x,lambda,Lvd.list[v[0]]))
	     od
    in []

{this puts biggest local parameters for local vertex into LF_hash for separate testing}
set local_LF_big(KGBElt x,ratvec lambda, VertexData vd, VertexData Lvd, [[FacetVertsIndex]] LF,
    KTypePol_hash pol_hash, Param_hash LF_hash) = [Param]:
    let () = if local_test_only_big_flag
    	     then LF_hash.match(parameter(x,lambda,Lvd.list[LF[0]~[0][0]]))
	     else for v in LF[0]
    	     	  do LF_hash.match(parameter(x,lambda,Lvd.list[v[0]]))
	     	  od
	     fi
    in []

set FPP_unitary_hash_LF([(KGBElt,ratvec)] xlambdas, Param_hash LFhash) = void:
    let () = LFhash.clear()
    then coh_ind_flag_old = coh_ind_flag, load_unipotents_flag_old = load_unipotents_flag,
    	 sort_LFD_flag_old = sort_LFD_flag
    then () = coh_ind_flag :=false; load_unipotents_flag := false; sort_LFD_flag:=true
    then () = FPP_unitary_hash_general(xlambdas, local_verts_param_hash, local_LF_big@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))
    then () = coh_ind_flag:=coh_ind_flag_old; load_unipotents_flag:=load_unipotents_flag_old;
    	 sort_LFD_flag:=sort_LFD_flag_old
    in ()

set FPP_unitary_hash_LF([(KGBElt,ratvec)] xlambdas) = void:
    FPP_unitary_hash_LF(xlambdas, local_verts_param_hash)

set FPP_unitary_hash_LF([KGBElt] xs, Param_hash LFhash) = void:
    let () = LFhash.clear()
    then coh_ind_flag_old = coh_ind_flag, load_unipotents_flag_old = load_unipotents_flag,
    	  sort_LFD_flag_old = sort_LFD_flag
    then () = coh_ind_flag :=false; load_unipotents_flag := false
    then () =  FPP_unitary_hash_general(xs, LFhash, local_LF_big@(
    KGBElt,ratvec,VertexData,VertexData,[[FacetVertsIndex]],
    KTypePol_hash, Param_hash))
    then () = coh_ind_flag:=coh_ind_flag_old; load_unipotents_flag:=load_unipotents_flag_old;
    	 sort_LFD_flag:=sort_LFD_flag_old
    in ()

set FPP_unitary_hash_LF([KGBElt] xs) = void:
    FPP_unitary_hash_LF(xs, local_verts_param_hash)

set FPP_unitary_hash_LF(RealForm G) = void:
    FPP_unitary_hash_LF(KGB(G))

{the functions ending in _test actually determine unitarity. Others only rule out some possibles}
set time_test([Param] params) = void:
    let start_time = elapsed_ms(), N = #params
    then ps = for p in params do first_param(finalize(p)) od
    then bools = for j:N do false od
    then step = N
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then times = vec: null(N)
    then () = for p@j in ps
    	      do let startp = elapsed_ms()
	      	 then () = bools[j]:= is_unitary(p)
		 then () = times[j] := elapsed_ms() - startp
		 then () = if j%step = 0
		      	   then prints("param ",j," tests ",bools[j]," in ",
			   	print_time_string(times[j]))
			   fi
		 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("for is_unitary total time = ", print_time_string(elapsed_ms() - start_time),
    	      	     " for ", N, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()


set time_test(Param_hash LFhash) = void:
    let N = LFhash.size()
    then params = for j:N do LFhash.index(j) od
    in time_test(params)

set time_test() = time_test(local_verts_param_hash)

set time_next_test([Param] params, int m) = void:
    let start_time = elapsed_ms(), N = #params
    then ps = for p in params do first_param(finalize(p)) od
    then bools = for j:N do false od
    then step = N
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then times = vec: null(N)
    then () = for p@j in ps
    	      do let startp = elapsed_ms()
	      	 then () = bools[j]:= is_unitary_test_next(p,m)
		 then () = times[j] := elapsed_ms() - startp
		 then () = if j%step = 0
		      	   then prints("param ",j," tests ",bools[j]," in ",
			   	print_time_string(times[j]))
			   fi
		 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("for next_test to ",m, ", total time = ", print_time_string(elapsed_ms() - start_time),
    	      	     " for ", N, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()

set time_next_test(Param_hash LFhash, int m) = void:
    let N = LFhash.size()
    then params = for j:N do LFhash.index(j) od
    in time_next_test(params, m)

set time_next_test(int m) = time_next_test(local_verts_param_hash, m)

{m is number of heights to which to test}
set time_next([Param] params, int m) = void:
    let start_time = elapsed_ms(), N = #params
    then ps = for p in params do first_param(finalize(p)) od
    then step = N
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then bools = for j:N do false od
    then step = N
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then times = vec: null(N)
    then () = for p@j in ps
    	      do let startp = elapsed_ms()
	      	 then () = bools[j] := is_unitary_to_hts(p, next_heights(p,m))
		 then () = times[j] := elapsed_ms() - startp
		 then () = if j%step = 0
		      	   then prints("param ",j," tests ",bools[j]," in ",
			   	print_time_string(times[j]))
			   fi
		 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("for next to ", m, ", total time = ", print_time_string(elapsed_ms() - start_time),
    	      	     " for ", N, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()

set time_next(Param_hash LFhash, int m) = void:
    let N = LFhash.size()
    then params = for j:N do LFhash.index(j) od
    in time_next(params,m)

set time_next(int m) = time_next(local_verts_param_hash, m)

{use is_unitary_to_hts(p, deform_hts(p,m)}
set time_def([Param] params, int m) = void:
    let start_time = elapsed_ms(), N = #params
    then ps = for j:N do first_param(finalize(params[j])) od
    then bools = for j:N do false od
    then step = N
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then times = vec: null(N)
    then () = for p@j in ps
    	      do let startp = elapsed_ms()
	      	 then (DEFHTS,) = deform_hts(p,m)
	      	 then () = bools[j]:= is_unitary_to_hts(p, DEFHTS)
		 then () = times[j] := elapsed_ms() - startp
		 then () = if j%step = 0
		      	   then prints("param ",j," tests ",bools[j]," in ",
			   	print_time_string(times[j]))
			   fi
		 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("for def to ", m, ", total time = ", print_time_string(elapsed_ms() - start_time),
    	      	     " for ", N, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()

set time_def(Param_hash LFhash, int m) = void:
    let N = LFhash.size()
    then params = for j:N do LFhash.index(j) od
    in time_def(params, m)

set time_def(int m) = time_def(local_verts_param_hash, m)

set time_def_test([Param] params, int m) = void:
    let start_time = elapsed_ms(), N = #params
    then ps = for j:N do first_param(finalize(params[j])) od
    then bools = for j:N do false od
    then step = N
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then times = vec: null(N)
    then () = for p@j in ps
    	      do let startp = elapsed_ms()
	      	 then (DEFHTS,) = deform_hts(p,m)
	      	 then () = bools[j]:= is_unitary_test(p, DEFHTS)
		 then () = times[j] := elapsed_ms() - startp
		 then () = if j%step = 0
		      	   then prints("param ",j," tests ",bools[j]," in ",
			   	print_time_string(times[j]))
			   fi
		 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("for to_def_test to ", m, ", total time = ", print_time_string(elapsed_ms() - start_time),
    	      	     " for ", N, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()

set time_def_test(Param_hash LFhash, int m) = void:
    let N = LFhash.size()
    then params = for j:N do LFhash.index(j) od
    in time_def_test(params, m)

set time_def_test(int m) = time_def(local_verts_param_hash, m)
{doing timeTest second seems to give little speed advantage}

set time_mix_test([Param] params, int m) = void:
    let start_time = elapsed_ms(), N = #params, G = params[0].real_form
    then ps = for j:N do first_param(finalize(params[j])) od
    then bools = for j:N do false od
    then step = N, NK = #KGB(G)
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then times = vec: null(N)
    then () = for p@j in ps
    	      do let startp = elapsed_ms()
	      	 then DEFHTS = [int]:
		       if number(p.x) < NK*low_KGB_frac
		       then []
	      	       else let (answer,) = deform_hts(p,m)
			    in answer
		       fi
	      	 then () = bools[j]:= is_unitary_test(p, DEFHTS)
		 then () = times[j] := elapsed_ms() - startp
		 then () = if j%step = 0
		      	   then prints("param ",j," tests ",bools[j]," in ",
			   	print_time_string(times[j]))
			   fi
		 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("for to_mix_test to ", m, ", total time = ", print_time_string(elapsed_ms() - start_time),
    	      	     " for ", N, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()

set time_mix_test(Param_hash LFhash, int m) = void:
    let N = LFhash.size()
    then params = for j:N do LFhash.index(j) od
    in time_mix_test(params, m)

set time_mix_test(int m) = time_def(local_verts_param_hash, m)
{doing timeTest second seems to give little speed advantage}





set time_general([(Param,int)] data, ((Param,int)->bool) tester) = void:
    let start = elapsed_ms()
    then times = [int]: null(#data), bools = for j:#data do false od
    then () = for (p,d)@j in data
    	      do let local_start = elapsed_ms()
	      	 then () = bools[j]:= tester(p,d)
	    	 then () = times[j] := elapsed_ms() - local_start
	    	 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("total time = ", print_time_string(elapsed_ms() - start),
    	      	     " for ", #data, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()

{Take a bunch of Params, preferably with a small number of sets of LKTs}
set time_bottom([Param] params, int level) = void:
    let start_time = elapsed_ms(), N0 = #params
    then Khash = make_KTypePol_hash()
    then datas = [[(KType,[(KType,KType)])]] : []
       {datas is always supposed to be the same size as Khash}
    then ps = for param in params do monomials(finalize(param)) od.##
    then N = #ps
    {then datas_index = [int]: for j:N do minus_1 od}
       {bottom layer data for ps[j] is datas[datas_index[j]]}
    then () = for p in ps
    	      do for mu in LKTs(p)
		 do let M = Khash.size()
	      	    then m = Khash.match(mu)
		    then () = if m = M
		      	      then datas:= (datas next datas := [])
			   	#min_L_bottom_factors(mu,level)
			      fi
		    in ()
	      	 od
	      od
    then bools = for j:N do false od
    then step = N
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then times = vec: null(N)
    then () = for p@j in ps
    	      do let startp = elapsed_ms()
	      	 then () = bools[j]:= min_bottom_elim_factors(p,
		      	   for mu in LKTs(p) do datas[Khash.lookup(mu)] od.##)
		 then () = times[j] := elapsed_ms() - startp
		 then () = if j%step = 0
		      	   then prints("param ",j," tests ",bools[j]," in ",
			   	print_time_string(times[j]))
			   fi
		 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("for bottom to level ", level, ", total time = ",
    	      	     print_time_string(elapsed_ms() - start_time),
    	      	     " for ", N, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()

{
set time_def(Param_hash LFhash, int m) = void:
    let N = LFhash.size()
    then params = for j:N do LFhash.index(j) od
    in time_def(params, m)

set time_def(int m) = time_def(local_verts_param_hash, m)

set time_def_test([Param] params, int m) = void:
    let start_time = elapsed_ms(), N = #params
    then ps = for j:N do first_param(finalize(params[j])) od
    then bools = for j:N do false od
    then step = N
    then () = if test_slightly_verbose
    	      then step := step\20
	      fi
    then () = if test_verbose
    	      then step := 1
	      fi
    then times = vec: null(N)
    then () = for p@j in ps
    	      do let startp = elapsed_ms()
	      	 then (DEFHTS,) = deform_hts(p,m)
	      	 then () = bools[j]:= is_unitary_test(p, DEFHTS)
		 then () = times[j] := elapsed_ms() - startp
		 then () = if j%step = 0
		      	   then prints("param ",j," tests ",bools[j]," in ",
			   	print_time_string(times[j]))
			   fi
		 in ()
	      od
    then maxLoc = max_loc(times)
    then () = prints("for to_def_test to ", m, ", total time = ", print_time_string(elapsed_ms() - start_time),
    	      	     " for ", N, " parameters; #true = ", count(bools));
	      prints("longest = ", print_time_string(times[maxLoc]),
		     " for #", maxLoc)
    in ()

set time_def_test(Param_hash LFhash, int m) = void:
    let N = LFhash.size()
    then params = for j:N do LFhash.index(j) od
    in time_def_test(params, m)

set time_def_test(int m) = time_def(local_verts_param_hash, m)}
{doing timeTest second seems to give little speed advantage}
