<geck_generic { for |Springer_table_generic_degrees| }
<nci_nilrad_roots.at {for all_sums@([ratvec])}
<restricted_roots.at {for remove_zeros@[vec]}
<truncated_induction.at {for induce_orbit}

{The Lusztig map goes from triples (O,x,xi) to W^; here O is special,
x is in Lusztig's quotient of the component group A-bar(O), and xi is
a representation of A-bar(O)^x.

 This file implements an algorithm (conjectural) to implement and
 generalize Lusztig's map when xi=1. For us O is any nilpotent orbit, x~ in the
 centralizer in G of an O-representative, M is the centralizer of x~
 (a pseudoLevi in G). Write O_M for the intersection of O with m^*.

** WE REQUIRE THAT O_M IS SPECIAL IN M.

Each element x in A(O) has representatives x~ satisfying this
specialness requirement. One of them is the Sommers-McNinch M, in
which O_M is distinguished. This is what we use in the base functions
(like show_lusztig_cells). The "plus" versions try also som larger M
(subject to **).

The set obtained for fixed special O, running over x, is (almost always) a Lusztig
(left) cell.

The anomaly at present is that if O is the funny special in E7
(dim(sigma(O)) = 512) then algorithm gives for x in nonidentity component

sigma(O,x) = Springer for maximal O' in O-bar.

Lusztig's def is sigma(O,x) = zero rep.

G, O = nilpotent orbit for G, x\in A-bar(O), representative x~ in G
for x MAKING O SPECIAL IN G^x`

Algorithm:
(O,x~,1)  -> M=Cent_{G}(x~)^0
         -> O_M (same H; REQUIRED TO BE SPECIAL IN M)
         -> O_M_vee dual special for M_vee, sigma_M_vee = Springer(O_M_vee) in  W(M_vee)^
	 -> sigma_G_vee = truncated-by-fake-degree induction from W(M_vee) to W(G_vee)]
         -> sigma_G = sigma_G_vee \otimes sgn

Non-trivial \xi not yet considered
}

set sigma_lusztig_test_verbose=false

{main algorithm for computing sigma_lusztig, this won't usually be called by the user.
arguments:
 G given group with its coordinate, need this to compute roots of L in G
 O: given orbit for G
 M: pseudo-Levi in G meeting M in special O_M
 H_M: ss element for orbit of M
REQUIRE O_M SPECIAL IN M!}

{E endoscopic, M pseudoLevi, EM = E\cap M pseudoLevi in E, endoscopic in M/pseudoLevi
in E}
{OEM <--> HEM special for EM; require saturates to special OE for E.}
{dual OEMvee <--> HEMvee; should require saturates to special OMvee for Mvee, but not
now testing this.}

set sigma_lusztig_test(SpringerTable stG, RootDatum E, RootDatum M, vec HME) =
(RootDatum,RootDatum, vec,[int],ComplexNilpotent{,[int],ComplexNilpotent}):
    {returns (E,M,HEM,G reps via E, O{, G reps via M, Ovee})}
let G = stG.root_datum, ctG = stG.ct
then WctG = ctG.class_table {, Gvee = G.dual}
{M posroots may not be pos for E}
then MEpos = [int]: for alpha@j in M.posroots do if is_root(E,alpha) then [j] else [] fi od.##
then ME = if #MEpos = 0 then root_datum(null(G.rank,0),null(G.rank,0),true)
     	  else let MEtworho = sum(G.rank,for j in MEpos do M.posroots[j] od)
     	       then MEsimpleroot_nums = [int]: for j in MEpos 
     		       	      	do if M.poscoroots[j]*MEtworho = 2
     			      	   then [j]
				   else []
				   fi
				od.##
	       then MEsimpleroots = mat: for j in MEsimpleroot_nums do M.posroots[j] od
	       then MEsimplecoroots = mat: for j in MEsimpleroot_nums do M.poscoroots[j] od
	       in  root_datum(MEsimpleroots, MEsimplecoroots,true)
     	  fi
then stM = M.Springer_table
then OME = ComplexNilpotent: (ME,(),HME), ctM = stM.ct
then HE = dominant(HME,E), stE = E.Springer_table, stME = ME.Springer_table
then ctME = stME.ct, ctE = stE.ct
then OE=ComplexNilpotent: (E,(),HE)
then O = induce_orbit(G,OE), WctME = ctME.class_table
then stM = M.Springer_table, stE = E.Springer_table, WctE = ctE.class_table
then () = assert(is_special(stME,OME),
"in sigma_lusztig_test, "+OME.diagram.to_string+" is not special for "+ME.nice_format)
then () = assert(is_special(stE,OE),
"in sigma_lusztig_test, "+OE.diagram.to_string+" is not special for "+E.nice_format)
then targetE = stE.springer(OE) {automatically special}
then sigmaME_num = stME.springer(OME)
then sigmaME = ctME.characters[sigmaME_num]
then indE = induce_character(WctME,WctE,sigmaME)
then indE_decomposed = ctE.decompose(indE)
then resultE = for j:#indE_decomposed
     	       do if indE_decomposed[j] > 0 and
		     ctE.special(j) = targetE
		  then [j]
		  else []
		  fi
	       od.##
then () = if is_member_sorted(resultE)(targetE) then resultE := [targetE] fi
then resultEG = [int]: for j in resultE
     	      	       do let indj = induce_character(WctE,WctG,ctE.characters[j]),
		       	      	     targetj = ctE.degree(j)
		          then indj_decomposed = ctG.decompose(indj)
		   	  in for ell:#indj_decomposed
		      	     do if indj_decomposed[ell] > 0 and
		      	      	   ctG.degree(ell) = targetj
			      	then [ell]
			      	else []
			      	fi
		      	     od.##
		 	 od.##.sort_u
in (E,M,HME,resultEG, O)

set sigma_lusztig_double_test(SpringerTable stG, SpringerTable stGvee, RootDatum E,
    RootDatum M, vec HME) =
(RootDatum,RootDatum, vec,[int],ComplexNilpotent,[int],ComplexNilpotent):
    {returns (E,M,HEM,G reps via E, O, G reps via M, Ovee)}
let G = stG.root_datum, ctG = stG.ct
then WctG = ctG.class_table, Gvee = G.dual
{M posroots may not be pos for E}
then MEpos = [int]: for alpha@j in M.posroots do if is_root(E,alpha) then [j] else [] fi od.##
then ME = if #MEpos = 0 then root_datum(null(G.rank,0),null(G.rank,0),true)
     	  else let MEtworho = sum(G.rank,for j in MEpos do M.posroots[j] od)
     	       then MEsimpleroot_nums = [int]: for j in MEpos 
     		       	      	do if M.poscoroots[j]*MEtworho = 2
     			      	   then [j]
				   else []
				   fi
				od.##
	       then MEsimpleroots = mat: for j in MEsimpleroot_nums do M.posroots[j] od
	       then MEsimplecoroots = mat: for j in MEsimpleroot_nums do M.poscoroots[j] od
	       in  root_datum(MEsimpleroots, MEsimplecoroots,true)
     	  fi
then Mvee = M.dual {endoscopic in Gvee}, stM = M.Springer_table, stGvee = Gvee.Springer_table
then stMvee = Mvee.Springer_table, ctGvee = stGvee.ct
then OME = ComplexNilpotent: (ME,(),HME), Evee = dual(E) {pseudoLevi in Gvee}, ctM = stM.ct,
     ctMvee = stMvee.ct, WctGvee = ctGvee.class_table
then HE = dominant(HME,E), stE = E.Springer_table, stME = ME.Springer_table
then MEvee = ME.dual, OMEvee = stME.dual_map(OME), ctME = stME.ct, ctE = stE.ct
then OE=ComplexNilpotent: (E,(),HE), stMEvee = MEvee.Springer_table, ctME = stME.ct
then O = induce_orbit(G,OE), ctMEvee = stMEvee.ct, WctME = ctME.class_table
then stM = M.Springer_table, stE = E.Springer_table, WctMvee = ctMvee.class_table,
     WctE = ctE.class_table, WctMEvee = ctMEvee.class_table
then () = assert(is_special(stME,OME),
"in sigma_lusztig_test, "+OME.diagram.to_string+" is not special for "+ME.nice_format)
then () = assert(is_special(stE,OE),
"in sigma_lusztig_test, "+OE.diagram.to_string+" is not special for "+E.nice_format)
then targetE = stE.springer(OE) {automatically special}
then sigmaME_num = stME.springer(OME), sigmaMEvee_num = stMEvee.springer(OMEvee)
then sigmaME = ctME.characters[sigmaME_num], sigmaMEvee = ctMEvee.characters[sigmaMEvee_num]
then indE = induce_character(WctME,WctE,sigmaME)
then indE_decomposed = ctE.decompose(indE)
then resultE = for j:#indE_decomposed
     	       do if indE_decomposed[j] > 0 and
		     ctE.special(j) = targetE
		  then [j]
		  else []
		  fi
	       od.##
then () = if is_member_sorted(resultE)(targetE) then resultE := [targetE] fi
then HMvee = dominant(OMEvee.H,Mvee)
then OMvee = ComplexNilpotent: (Mvee,(),HMvee)
then () = assert(is_special(stMvee,OMvee),
"in sigma_lusztig_test, "+OMvee.diagram.to_string+" is not special for "+Mvee.nice_format)
then Ovee = induce_orbit(Gvee, OMvee)
then targetMvee = stMvee.springer(OMvee) {automatically special}
then indMvee = induce_character(WctMEvee,WctMvee,sigmaMEvee)
then indMvee_decomposed = ctMvee.decompose(indMvee)
then resultMvee = for k:#indMvee_decomposed
     		  do if indMvee_decomposed[k] > 0 and
		     	ctMvee.special(k) = targetMvee
		     then [k]
		     else []
		     fi
		     od.##
then () = if is_member_sorted(resultMvee)(targetMvee) then resultMvee := [targetMvee] fi
then resultEG = [int]: for j in resultE
     	      	       do let indj = induce_character(WctE,WctG,ctE.characters[j]),
		       	      	     targetj = ctE.degree(j)
		          then indj_decomposed = ctG.decompose(indj)
		   	  in for ell:#indj_decomposed
		      	     do if indj_decomposed[ell] > 0 and
		      	      	   ctG.degree(ell) = targetj
			      	then [ell]
			      	else []
			      	fi
		      	     od.##
		 	 od.##.sort_u
then resultMveeGvee = for k in resultMvee
     	      	do let indk = induce_character(WctMvee,WctGvee,ctMvee.characters[k]),
		       targetk = ctMvee.degree(k)
		   then indk_decomposed = ctGvee.decompose(indk)
		   in for ell:#indk_decomposed
		      do if indk_decomposed[ell] > 0 and
		      	 ctG.degree(ell) = targetk
			 then [ell]
			 else []
			 fi
		      od.##
		 od.##.sort_u
in (E,M,HME,resultEG, O, resultMveeGvee,Ovee)

{Given a nilpotent OG for G, find all endoscopic E and special nilpotent OE
in it so that OG=induce_orbit(G,OE). That such exist is Lusztig orange book, 13.3}
set special_ind(SpringerTable stG, ComplexNilpotent OG) = [(RootDatum, ComplexNilpotent)]:
    let i = stG.springer(OG) {number of Springer(OG) in character table}, ctG = stG.ct
    then d = ctG.degree(i), {sigmaG = ctG.characters[i],} G = stG.root_datum
    then Es = for Ev in pseudo_Levi_subgroups(G.dual) do Ev.dual od {endoscopic groups for G}
    in [(RootDatum, ComplexNilpotent)]:
    	 for E in Es do if #E.posroots >= d 
	       	     	then let stE = E.Springer_table, Edim = OG.dim - #G.roots + #E.roots
			     in for OE in stE.special_orbits
			     	do if OE.dim = Edim and
				      induce_orbit(G,OE) = OG
				   then [(E,OE)]
				   else[]
				   fi
				od.##
			 else[]
			 fi
		     od.##

set best_special_ind(SpringerTable stG, ComplexNilpotent OG) = [(RootDatum, ComplexNilpotent)]:
    let comp_reps = #component_representatives_plus(OG)
    then special_inds = special_ind(stG,OG)
    then comp_rep_sizes = for (,OE) in special_inds do #component_representatives_plus(OE) od
    then maxcr = max(comp_rep_sizes)
    then comp_best = for (E,OE)@j in special_inds
    	 	     do if comp_rep_sizes[j] = maxcr
		     	then [(E,OE)]
			else []
			fi
	             od.##

    then E_sizes = for(E,) in comp_best do #E.posroots od
    then maxsize = max(E_sizes)
    then sizes_best = for (E,OE)@k in comp_best
    	 	      do if E_sizes[k] = maxsize
		      	 then [(E,OE)]
		      	 else []
		      	 fi
		      od.##
    in sizes_best

set show_best_special_ind(RootDatum G) = void:
    let orbits = G.orbits, stG = G.Springer_table
    then bests = for orbit in orbits do best_special_ind(stG, orbit) od
    then header = ["OG", "#cands", "E", "OE", "#A(OG) classes", "#A(OE) classes"]
    then table = [[string]]:
    	for orbit@j in orbits
	do let (E,OE) = bests[j][0]
	   in [
		orbit.diagram.to_string
		, (#bests[j]).to_string
		, E.nice_format
		, OE.diagram.to_string
		, (#component_representatives_plus(orbit)).to_string
		, (#component_representatives_plus(OE)).to_string
	      ]
	od
     in (header#table).tabulate

{compute lusztig cell for one nilpotent; array has one entry for each
component class in A(E_orbit)}
set lusztig_cell_test (SpringerTable stG,ComplexNilpotent OG) =
      [(RootDatum,RootDatum,vec,[int],ComplexNilpotent)]:
      let (E,OE) = best_special_ind(stG,OG)[0]
      in for (M,H_M,) in component_representatives_plus(OE)
      do sigma_lusztig_test(stG,E,M,H_M) od

{compute lusztig cells, running over given list of nilpotents}
{returns: array, one entry for each orbit
 orbit -> array of [M,H_M,j_values]}
set lusztig_cells_test (SpringerTable st_G,[ComplexNilpotent] orbits) =
      [[(RootDatum,RootDatum,vec,[int],ComplexNilpotent{,[int],ComplexNilpotent})]]:
   for O in orbits
   do lusztig_cell_test(st_G,O)
   od

{include variants enlarging M, still only special orbit}
set lusztig_cell_plus_test\
    (SpringerTable st_G, ComplexNilpotent orbit) =
    [[(RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]:
    let G=st_G.root_datum
    then coxG = G.coxeter_number
    in for (M,H_M,y) in component_representatives_plus(orbit)
       do let basis=M.radical_basis
       	  in let variants=if =#basis
	    		  then [null(G.rank)]
			  else all_sums(basis)
			  fi
  	      in for v in variants
       	       	 do let L = centralizer(G,y+v/(coxG+1))
	       	    then st_L = L.Springer_table, H_L = dominant(H_M,L)
	   	    then O_L = (L,(),H_L)
          	    in if(is_special(st_L,O_L))
	     	       then [sigma_lusztig_test(st_G,G,L,H_L)]
	     	       else []
	    	       fi
       	         od.## {this is the list of results for various
  	       	      variants, one component}
      od {this is the list of lists for one orbit}

set lusztig_cells_plus_test\
  (SpringerTable st_G,[ComplexNilpotent] orbits) =
  [[[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]]:
  for orbit in orbits
  do lusztig_cell_plus_test(st_G,orbit)
  od

set lusztig_cells_special_test (SpringerTable st_G) =
      [[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]:
      lusztig_cells_test(st_G,st_G.special_orbits)

set lusztig_cells_test (SpringerTable st_G) =
      [[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]:
      lusztig_cells_test(st_G,st_G.orbits)

set lusztig_cells_special_test(RootDatum G) =
      [[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]:
   let st_G=G.Springer_table
   in lusztig_cells_test(st_G,st_G.special_orbits)

set lusztig_cells_test(RootDatum G) =
      [[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]:
   let st_G=G.Springer_table
   in lusztig_cells_test(st_G,st_G.orbits)

set lusztig_cells_special_plus_test(SpringerTable st_G) =
      [[[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]]:
      lusztig_cells_plus_test(st_G,st_G.special_orbits)

set lusztig_cells_plus_test(SpringerTable st_G) =
      [[[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]]:
      lusztig_cells_plus_test(st_G,st_G.orbits)

set lusztig_cells_special_plus_test(RootDatum G) =
      [[[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]]:
   let st_G=G.Springer_table
   in lusztig_cells_plus_test(st_G,st_G.special_orbits)

set lusztig_cells_plus_test(RootDatum G) =
      [[[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent) ]]]:
   let st_G=G.Springer_table
   in lusztig_cells_plus_test(st_G,st_G.orbits)

{show lusztig cell for one orbit}
set show_lusztig_cell_test\
   (SpringerTable st_G,ComplexNilpotent G_orbit) = void:
   let G=st_G.root_datum, ct_G = st_G.ct
   then Gvee = G.dual
   then st_Gvee = Gvee.Springer_table
   then ct_Gvee = st_Gvee.ct
   in prints("***************************",new_line,"orbit = "
      ,G_orbit.diagram.to_string + st_G.special_star(G_orbit)
      ," dim = ",G_orbit.dim_nilpotent);
    let table_header = ["E", "M","HME","sigmaEG","G orbit", "dim","deg"]
	, table = [ [string] ]:
      for (E,M,HME, iEGs, O) in lusztig_cell_test(st_G,G_orbit)
      do let st_M = M.Springer_table, ct_M = M.character_table
       	 in [E.nice_format
	    ,M.nice_format
	    ,HME.compact_string
	    ,iEGs.to_string
	    ,O.diagram.to_string
	    ,for i in iEGs do dimension(ct_G,i) od.to_string
	    ,for i in iEGs do ct_G.degree(i) od.to_string]
      od  {for data}
in  (table_header#table).tabulate

{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells_test\
   (SpringerTable st_G,[ComplexNilpotent] orbits) = void:
   let G=st_G.root_datum
   in
   prints("G=", G.nice_format, "  #orbits: ", #orbits);
   for orbit in orbits
   do show_lusztig_cell_test(st_G,orbit)
   od
 
{show lusztig cells, one nilpotent with variants on components}
set show_lusztig_cell_plus_test\
   (SpringerTable st_G,ComplexNilpotent G_orbit) = void:
   let G=st_G.root_datum, ct_G = st_G.ct
   then Gvee = G.dual
   then st_Gvee = Gvee.Springer_table
   then ct_Gvee = st_Gvee.ct
   in prints("***************************",new_line, "orbit = "
   ,G_orbit.diagram.to_string+st_G.special_star(G_orbit)
   ," dim = ",G_orbit.dim_nilpotent);
    let table_header = ["E", "M","HME","sigmaEG","G orbit", "dim", "deg"]
    in for data@i in lusztig_cell_plus_test(st_G,G_orbit)
      {[[(M,E,HME,sigmaEG,O))]]}
      	do prints("------------------------", new_line
      	   ,"     variants of component #",i);
	 let table = [[string]]:
      	     for (E,M,HME,iEGs,O) in data
      	     do  [E.nice_format
	     	 ,M.nice_format
	    	 ,HME.compact_string
	    	 ,iEGs.to_string
		 ,O.diagram.to_string
		 ,for i in iEGs do dimension(ct_G,i) od.to_string
		 ,for i in iEGs do ct_G.degree(i) od.to_string
	    	  ]
             od {finish running over variants of one component}
      	  in tabulate(table_header#table)
      od{finish running over components}


{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells_plus_test\
   (SpringerTable st_G,[ComplexNilpotent] orbits) = void:
   prints("G=", st_G.root_datum.nice_format, new_line, "#orbits: ", #orbits);
   for G_orbit in orbits
   do show_lusztig_cell_plus_test(st_G,G_orbit)
   od
{some shorthands which are handy but sometimes inefficient}

{set lusztig_cell_test (RootDatum G,ComplexNilpotent O) = [[int]]:
    lusztig_cell_test(G.Springer_table,O)}

set show_lusztig_cells_special_test (SpringerTable st_G) = void:
    show_lusztig_cells_test(st_G,st_G.special_orbits)

set show_lusztig_cells_test (SpringerTable st_G) = void:
    show_lusztig_cells_test(st_G,st_G.orbits)

set show_lusztig_cells_special_plus_test (SpringerTable st_G) = void:
    show_lusztig_cells_plus_test(st_G,st_G.special_orbits)

set show_lusztig_cells_plus_test (SpringerTable st_G) = void:
    show_lusztig_cells_plus_test(st_G,st_G.orbits)

set show_lusztig_cells_special_test(RootDatum G) = void:
   let st_G=Springer_table(G)
   in show_lusztig_cells_special_test(st_G)

set show_lusztig_cells_test(RootDatum G) = void:
   let st_G=Springer_table(G)
   in show_lusztig_cells_test(st_G)

set show_lusztig_cells_special_plus_test (RootDatum G) = void:
   let st_G=Springer_table(G) in show_lusztig_cells_special_plus_test(st_G)

set show_lusztig_cells_plus_test (RootDatum G) = void:
   let st_G=Springer_table(G) in show_lusztig_cells_plus_test(st_G)

set sigmas(SpringerTable st, ComplexNilpotent O) = [int]:
    let data=lusztig_cell_test(st,O)
    in (for (,,,js,{,,}) in data do js od.##).sort_u

set A_bar_test(SpringerTable st,ComplexNilpotent O)=([int],[[RootDatum]]):
let data=lusztig_cell_test(st,O) then
sigmas=(for (,,,js,) in data do js od.##).sort_u
in (sigmas,
	for i:#sigmas
	do for (,M,,js,) in data
	   do if  sigmas[i]=js[0] then [M] else [] fi
    	   od.##
	od)

set A_bar_test(SpringerTable st)=(ComplexNilpotent
    ->([int],[[RootDatum]])):(ComplexNilpotent O):
	A_bar_test(st,O)

{test whether algorithm gives unique and same sigma over all variants
of each component of a nilpotent orbit}
set test_test(SpringerTable st_G, ComplexNilpotent G_orbit) = bool:
let data = lusztig_cell_plus_test(st_G,G_orbit)
in all( for dataI in data
   	do let (,,,j0,{,,}) = dataI[0]
	   in all ( for (,,,j,{,,}) in dataI
       	      	    do j=j0
	 	    od)
        od)

set test_test(SpringerTable st_G, [ComplexNilpotent] orbits) = bool:
all(for G_orbit in orbits do test_test(st_G,G_orbit) od)

set test_test(SpringerTable st_G) = bool:
test_test(st_G,st_G.orbits)

set test_test(RootDatum G) = bool:
test_test(G.Springer_table)

{given special orbit O, list all W reps of degree \ge #pos_roots -
(dim O)/2 that DO NOT appear in sigmas(O') for O' of dimension at most
that of O. SO O SHOULD BE SPECIAL! These are candidates to appear be
sigma(O,1,xi).}

{set sigma_duals_missing0(SpringerTable st, ComplexNilpotent O) = [int]:
    let G=st.root_datum, ct = st.ct
    then () = assert(is_special(st,O),
    	 "in sigma_duals_missing, "+O.diagram.to_string+" is not special for "+G.nice_format)
    then specials = st.special_orbits
    then position = first(for orbit@i in specials do O=orbit od)
    then posSize = position {this will be the number of the last
    special of same dimension as O}
    then () = while posSize+1 < #specials and dim(specials[posSize+1]) = dim(O)
    	 do posSize:=posSize+1
	 od
    then d = #G.posroots - O.dim\2
    then above = [int]: for j:#ct.characters
    	       	 	do if ct.degree(j) >= d
    			   then [j]
			   else []
			   fi
			od.##
    in for j in above
       do if none(for k:posSize+1 do is_member( sigmas_dual0(st,specials[k]) ) (j) od)
       	  then [j]
	  else []
	  fi
       od.##
}
