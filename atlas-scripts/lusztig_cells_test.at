<geck_generic { for |Springer_table_generic_degrees| }
<nci_nilrad_roots.at {for all_sums@([ratvec])}
<restricted_roots.at {for remove_zeros@[vec]}
<truncated_induction.at {for induce_orbit}

{The Lusztig map goes from triples (O,x,xi) to W^; here O is special,
x is in Lusztig's quotient of the component group A-bar(O), and xi is
a representation of A-bar(O)^x.

 This file implements an algorithm (conjectural) to implement and
 generalize Lusztig's map when xi=1. For us O is any nilpotent orbit, x~ in the
 centralizer in G of an O-representative, M is the centralizer of x~
 (a pseudoLevi in G). Write O_M for the intersection of O with m^*.

** WE REQUIRE THAT O_M IS SPECIAL IN M.

Each element x in A(O) has representatives x~ satisfying this
specialness requirement. One of them is the Sommers-McNinch M, in
which O_M is distinguished. This is what we use in the base functions
(like show_lusztig_cells). The "plus" versions try also som larger M
(subject to **).

The set obtained for fixed special O, running over x, is (almost always) a Lusztig
(left) cell.

The anomaly at present is that if O is the funny special in E7
(dim(sigma(O)) = 512) then algorithm gives for x in nonidentity component

sigma(O,x) = Springer for maximal O' in O-bar.

Lusztig's def is sigma(O,x) = zero rep.

G, O = nilpotent orbit for G, x\in A-bar(O), representative x~ in G
for x MAKING O SPECIAL IN G^x`

Algorithm:
(O,x~,1)  -> M=Cent_{G}(x~)^0
         -> O_M (same H; REQUIRED TO BE SPECIAL IN M)
         -> O_M_vee dual special for M_vee, sigma_M_vee = Springer(O_M_vee) in  W(M_vee)^
	 -> sigma_G_vee = truncated-by-fake-degree induction from W(M_vee) to W(G_vee)]
         -> sigma_G = sigma_G_vee \otimes sgn

Non-trivial \xi not yet considered
}

set sigma_lusztig_test_verbose=false
set require_special = false
set top_degree(CharacterTable ct) = (int i)int:
    let is = ct.tensor_sign_index(i) in #ct.root_datum.posroots - ct.degree(is)

{main algorithm for computing sigma_lusztig, this won't usually be called by the user.
arguments:
 G given group with its coordinate, need this to compute roots of L in G
 O: given orbit for G
 M: pseudo-Levi in G meeting M in special O_M
 H_M: ss element for orbit of M
REQUIRE O_M SPECIAL IN M!}

{E endoscopic, M pseudoLevi, EM = E\cap M pseudoLevi in E, endoscopic in M/pseudoLevi
in E}
{OEM <--> HEM special for EM; require saturates to (maybe) special OE for E.}
{dual OEMvee <--> HEMvee; require saturates to (maybe) special OMvee for Mvee}

set sigma_lusztig_test(SpringerTable stG, RootDatum E, RootDatum M, vec HME) =
(RootDatum,RootDatum, vec,[int],ComplexNilpotent,[int],ComplexNilpotent):
    {returns (E,M,HEM,G reps via E, O, G reps via M, Ovee)}
let G = stG.root_datum, ctG = stG.ct
then WctG = ctG.class_table, Gvee = G.dual
{M posroots may not be pos for E}
then MEpos = [int]: for alpha@j in M.posroots do if is_root(E,alpha) then [j] else [] fi od.##
then ME = if #MEpos = 0 then root_datum(null(G.rank,0),null(G.rank,0),true)
     	  else let MEtworho = sum(G.rank,for j in MEpos do M.posroots[j] od)
     	       then MEsimpleroot_nums = [int]: for j in MEpos 
     		       	      	do if M.poscoroots[j]*MEtworho = 2
     			      	   then [j]
				   else []
				   fi
				od.##
	       then MEsimpleroots = mat: for j in MEsimpleroot_nums do M.posroots[j] od
	       then MEsimplecoroots = mat: for j in MEsimpleroot_nums do M.poscoroots[j] od
	       in  root_datum(MEsimpleroots, MEsimplecoroots,true)
     	  fi
then Mvee = M.dual {endoscopic in Gvee}, stM = M.Springer_table
then stMvee = Mvee.Springer_table
then OME = ComplexNilpotent: (ME,(),HME), Evee = dual(E) {pseudoLevi in Gvee}, ctM = stM.ct
then HE = dominant(HME,E), stE = E.Springer_table, stME = ME.Springer_table
then MEvee = ME.dual, OMEvee = stME.dual_map(OME), ctME = stME.ct, ctE = stE.ct
then OE=ComplexNilpotent: (E,(),HE), stMEvee = MEvee.Springer_table, WctME = ctME.class_table
then O = induce_orbit(G,OE)
then stM = M.Springer_table, stE = E.Springer_table, WctM = ctM.class_table, WctE = ctE.class_table
then () = assert(is_special(stME,OME),
"in sigma_lusztig_test, "+OME.diagram.to_string+" is not special for "+ME.nice_format)
then () = if(require_special) then assert(is_special(stE,OE),
"in sigma_lusztig_test, "+OE.diagram.to_string+" is not special for "+E.nice_format) fi
then targetEspecial = ctE.special(stE.springer(OE))
then sigmaME_num = stME.springer(OME)
then sigmaME = ctME.characters[sigmaME_num]
then indE = induce_character(WctME,WctE,sigmaME)
then indE_decomposed = ctE.decompose(indE)
then resultE = for j:#indE_decomposed
     		  do if indE_decomposed[j] > 0 and
		     	ctE.special(j) = targetEspecial
		     then [j]
		     else []
		     fi
		  od.##
then HMvee = dominant(OMEvee.H,Mvee)
then OMvee = ComplexNilpotent: (Mvee,(),HMvee)
then Ovee = induce_orbit(Gvee, OMvee)
then OM = stMvee.dual_map(OMvee)
then skip = not(is_special(stMvee,OMvee)) and require_special
then targetMspecial = ctM.special(stM.springer(OM))
then indM = induce_character(WctME,WctM,sigmaME)
then indM_decomposed = ctM.decompose(indM)
then resultM = for k:#indM_decomposed
     		  do if indM_decomposed[k] > 0 and
		     	ctM.special(k) = targetMspecial
		     then [k]
		     else []
		     fi
		  od.##
then resultEG = for j in resultE
     	      	do let indj = induce_character(WctE,WctG,ctE.characters[j]), targetj = ctE.degree(j)
		   then indj_decomposed = ctG.decompose(indj)
		   in for ell:#indj_decomposed
		      do if indj_decomposed[ell] > 0 and
		      	 ctG.degree(ell) = targetj
			 then [ell]
			 else []
			 fi
		      od.##
		 od.##.sort_u
then resultMG = for k in resultM
     	      	do let indk = induce_character(WctM,WctG,ctM.characters[k]),
		       targetk = ctM.top_degree(k) + #G.posroots - #M.posroots
		   then indk_decomposed = ctG.decompose(indk)
		   in for ell:#indk_decomposed
		      do if indk_decomposed[ell] > 0 and
		      	 ctG.top_degree(ell) = targetk
			 then [ell]
			 else []
			 fi
		      od.##
		 od.##.sort_u
then () = if skip then resultMG := [-1]##resultMG fi
in (E,M,HME,resultEG, O, resultMG,Ovee)

{compute lusztig cell for one nilpotent; array has one entry for each
component class in A(G_orbit)}
set lusztig_cell_test (SpringerTable st_G,ComplexNilpotent G_orbit) =
      [(RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent)]:
      for (M,H_M,) in component_representatives_plus(G_orbit)
      do sigma_lusztig_test(st_G,st_G.root_datum,M,H_M) od

{compute lusztig cell for one nilpotent; array has one entry for each
component class in A(G_orbit)}
set lusztig_cell_test2 (SpringerTable st_G,ComplexNilpotent O) =
      [[(RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent)]]:
      let G = st_G.root_datum
      then Es = for Evee in pseudo_Levi_subgroups(G.dual)
      	       	do Evee.dual
		od
      then pairs_to_O = for E in Es
      	       	       	do for OE in E.Springer_table.special_orbits
		       	   do if induce_orbit(G,OE) = O
			      then [(E,OE)]
			      else []
			      fi
			   od.##
			od.##
      in for (E,OE) in pairs_to_O
      	 do for (M,H_M,) in component_representatives_plus(OE)
      	    do sigma_lusztig_test(st_G,E,M,H_M)
	    od
	 od

{compute lusztig cells, running over given list of nilpotents}
{returns: array, one entry for each orbit
 orbit -> array of [M,H_M,j_values]}
set lusztig_cells_test (SpringerTable st_G,[ComplexNilpotent] orbits) =
      [[(RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent)]]:
   for O in orbits
   do lusztig_cell_test(st_G,O)
   od

{include variants enlarging M, still only special orbit}
set lusztig_cell_plus_test\
    (SpringerTable st_G, ComplexNilpotent orbit) =
    [[(RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent) ]]:
    let G=st_G.root_datum
    then coxG = G.coxeter_number
    in for (M,H_M,y) in component_representatives_plus(orbit)
       do let basis=M.radical_basis
       	  in let variants=if =#basis
	    		  then [null(G.rank)]
			  else all_sums(basis)
			  fi
  	      in for v in variants
       	       	 do let L = centralizer(G,y+v/(coxG+1))
	       	    then st_L = L.Springer_table, H_L = dominant(H_M,L)
	   	    then O_L = (L,(),H_L)
          	    in if(is_special(st_L,O_L))
	     	       then [sigma_lusztig_test(st_G,G,L,H_L)]
	     	       else []
	    	       fi
       	         od.## {this is the list of results for various
  	       	      variants, one component}
      od {this is the list of lists for one orbit}

set lusztig_cells_plus_test\
  (SpringerTable st_G,[ComplexNilpotent] orbits) =
  [[[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent) ]]]:
  for orbit in orbits
  do lusztig_cell_plus_test(st_G,orbit)
  od

set lusztig_cells_test (SpringerTable st_G) =
      [[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent) ]]:
   if require_special then lusztig_cells_test(st_G,st_G.special_orbits)
      		      else lusztig_cells_test(st_G,st_G.orbits)
   fi

set lusztig_cells_test(RootDatum G) =
      [[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent) ]]:
   let st_G=G.Springer_table in
   if require_special then lusztig_cells_test(st_G,st_G.special_orbits)
      		      else lusztig_cells_test(st_G,st_G.orbits)
   fi

set lusztig_cells_plus_test(SpringerTable st_G) =
      [[[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent) ]]]:
   if require_special then lusztig_cells_plus_test(st_G,st_G.special_orbits)
      		      else lusztig_cells_plus_test(st_G,st_G.orbits)
   fi

set lusztig_cells_plus_test(RootDatum G) =
      [[[ (RootDatum,RootDatum,vec,[int],ComplexNilpotent,[int],ComplexNilpotent) ]]]:
   let st_G=G.Springer_table
   in
      if require_special then lusztig_cells_plus_test(st_G,st_G.special_orbits)
      		      	 else lusztig_cells_plus_test(st_G,st_G.orbits)
      fi

{show lusztig cell for one orbit}
set show_lusztig_cell_test\
   (SpringerTable st_G,ComplexNilpotent G_orbit) = void:
   let G=st_G.root_datum, ct_G = st_G.ct
   in prints("***************************",new_line,"orbit = "
      ,G_orbit.diagram.to_string + st_G.special_star(G_orbit)
      ," dim = ",G_orbit.dim_nilpotent);
    let table_header = ["E", "M","HME" { indep. of sigma }
        ,"sigmaEG","G orbit", "sigmaMG","Gv orbit","dim","deg"], table = [ [string] ]:
      for (E,M,HME, iEGs, O, iMGs,Ovee) in lusztig_cell_test(st_G,G_orbit)
      do let st_M = M.Springer_table, ct_M = M.character_table
       	 in [E.nice_format
	    ,M.nice_format
	    ,HME.compact_string
	    ,iEGs.to_string
	    ,O.diagram.to_string
	    ,iMGs.to_string
	    ,Ovee.diagram.to_string
 	    ,dimension(st_G.ct,iEGs[0]).to_string
	    ,st_G.ct.degree(iEGs[0]).to_string	]
      od  {for data}
in  (table_header#table).tabulate

{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells_test\
   (SpringerTable st_G,[ComplexNilpotent] orbits) = void:
   let G=st_G.root_datum
   in
   prints("G=", G.nice_format, "  #orbits: ", #orbits);
   for orbit in orbits
   do show_lusztig_cell_test(st_G,orbit)
   od
 
{show lusztig cells, one nilpotent with variants on components}
set show_lusztig_cell_plus_test\
   (SpringerTable st_G,ComplexNilpotent G_orbit) = void:
   let G=st_G.root_datum, ct_G = st_G.ct
   in prints("***************************",new_line, "orbit = "
   ,G_orbit.diagram.to_string+st_G.special_star(G_orbit)
   ," dim = ",G_orbit.dim_nilpotent);
    let table_header = ["E", "M","HME" { indep. of sigma }
        ,"sigmaEG","G orbit", "sigmaMG","Gv orbit","dim","deg"]
    in for data@i in lusztig_cell_plus_test(st_G,G_orbit)
      {[[(M,E,HME,sigmaEG,O,sigmaMGs,Ovee))]]}
      	do prints("------------------------", new_line
      	   ,"     variants of component #",i);
	 let table = [[string]]:
      	     for (E,M,HME,iEGs,O,iMGs,Ovee) in data
      	     do  [E.nice_format
	     	 ,M.nice_format
	    	 ,HME.compact_string
	    	 ,iEGs.to_string
		 ,O.diagram.to_string
	    	 ,iMGs.to_string
		 ,Ovee.diagram.to_string
	    	 ,dimension(st_G.ct,iEGs[0]).to_string
	    	 ,ct_G.degree(iEGs[0]).to_string
	    	  ]
             od {finish running over variants of one component}
      	  in tabulate(table_header#table)
      od{finish running over components}


{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells_plus_test\
   (SpringerTable st_G,[ComplexNilpotent] orbits) = void:
   prints("G=", st_G.root_datum.nice_format, new_line, "#orbits: ", #orbits);
   for G_orbit in orbits
   do show_lusztig_cell_plus_test(st_G,G_orbit)
   od
{some shorthands which are handy but sometimes inefficient}

{set lusztig_cell_test (RootDatum G,ComplexNilpotent O) = [[int]]:
    lusztig_cell_test(G.Springer_table,O)}

set show_lusztig_cells_test (SpringerTable st_G) = void:
    if(require_special)
    then show_lusztig_cells_test(st_G,st_G.special_orbits)
    else show_lusztig_cells_test(st_G,st_G.orbits)
    fi

set show_lusztig_cells_test(RootDatum G) = void:
   let st_G=Springer_table(G) in show_lusztig_cells_test(st_G)

set show_lusztig_cells_plus_test (RootDatum G) = void:
   let st_G=Springer_table(G) in show_lusztig_cells_plus_test(st_G)

set sigmas(SpringerTable st, ComplexNilpotent O) = [int]:
    let data=lusztig_cell_test(st,O)
    in (for (,,,js,,,) in data do js od.##).sort_u

set A_bar_test(SpringerTable st,ComplexNilpotent O)=([int],[[RootDatum]]):
let data=lusztig_cell_test(st,O) then
sigmas=(for (,,,js,,,) in data do js od.##).sort_u
in (sigmas,
	for i:#sigmas
	do for (,M,,js,,,) in data
	   do if  sigmas[i]=js[0] then [M] else [] fi
    	   od.##
	od)

set A_bar_test(SpringerTable st)=(ComplexNilpotent
    ->([int],[[RootDatum]])):(ComplexNilpotent O):
	A_bar_test(st,O)


{
set show_A_bar_test([int] sigmas,[[RootDatum]] pseudolevis)=void:
for i:#sigmas do
 let str="" in
  for M in pseudolevis[i] do str+:=" " + nice_format(M) od
 ;prints(sigmas[i],str)
od
}

{
set show_A_bar_test(SpringerTable st,ComplexNilpotent orbit)=void:
let (sigmas,pseudolevis)=A_bar_test(st,orbit) in
prints("orbit: ", orbit.diagram);
for i:#sigmas do prints(sigmas[i], " ", #pseudolevis[i]) od;
prints(sigmas.to_string +
##for i:#sigmas do
 let str="" in
  for M in pseudolevis[i] do str+:=" " + nice_format(M) od
 ;"  " +sigmas[i].to_string + str
od)
}

{test whether algorithm gives unique and same sigma over all variants
of each component of a nilpotent orbit}
set test_test(SpringerTable st_G, ComplexNilpotent G_orbit) = bool:
let data = lusztig_cell_plus_test(st_G,G_orbit)
in all( for dataI in data
   	do let (,,,j0,,,) = dataI[0]
	   in all ( for (,,,j,,,) in dataI
       	      	    do j=j0
	 	    od)
        od)

set test_test(SpringerTable st_G, [ComplexNilpotent] orbits) = bool:
all(for G_orbit in orbits do test_test(st_G,G_orbit) od)

set test_test(SpringerTable st_G) = bool:
test_test(st_G,st_G.orbits)

set test_test(RootDatum G) = bool:
test_test(G.Springer_table)

{dual version for computing sigma_lusztig, this won't usually be called by the user.
arguments:
 reductive G
 E endoscopic for G: means M.dual is pseudoLevi in G.dual
 H_E: ss element for orbit OE of E
REQUIRE OE SPECIAL IN E!}
{TYPICALLY OE is SMALL: NOT induced}

{given special orbit O, list all W reps of degree \ge #pos_roots -
(dim O)/2 that DO NOT appear in sigmas(O') for O' of dimension at most
that of O. SO O SHOULD BE SPECIAL! These are candidates to appear be
sigma(O,1,xi).}

{set sigma_duals_missing0(SpringerTable st, ComplexNilpotent O) = [int]:
    let G=st.root_datum, ct = st.ct
    then () = assert(is_special(st,O),
    	 "in sigma_duals_missing, "+O.diagram.to_string+" is not special for "+G.nice_format)
    then specials = st.special_orbits
    then position = first(for orbit@i in specials do O=orbit od)
    then posSize = position {this will be the number of the last
    special of same dimension as O}
    then () = while posSize+1 < #specials and dim(specials[posSize+1]) = dim(O)
    	 do posSize:=posSize+1
	 od
    then d = #G.posroots - O.dim\2
    then above = [int]: for j:#ct.characters
    	       	 	do if ct.degree(j) >= d
    			   then [j]
			   else []
			   fi
			od.##
    in for j in above
       do if none(for k:posSize+1 do is_member( sigmas_dual0(st,specials[k]) ) (j) od)
       	  then [j]
	  else []
	  fi
       od.##
}
