{For now: G, H split; no issue with rho_G-rho_H cover
also: only pure strong real forms}
<L_hom.at

set e_verbose=false

{M: X^*(H_v) to X^*(G_v), i.e. also takes X_*(H) to X_*(G)}

set endoscopic_lift(L_homomorphism phi_H,RealForm G,mat M)=
phi(map_KGB_gen_tits(phi_H.y,dual_quasisplit_form(G),M),phi_H.gamma*M)

set lift_pair(KGBElt x_H,L_homomorphism phi_H,RealForm G,mat M)=(KGBElt,L_homomorphism):
assert(is_pure(x_H), "x_H is not pure (epstar only defined at the moment for pure real forms of H and G");
let y_H=phi_H.y then
gamma_H=phi_H.gamma then
()=if e_verbose then prints("y_H: ", y_H, new_line, "gamma_H: ", gamma_H) fi  then
gamma_G=M*gamma_H then
()=if e_verbose then prints("gamma_G: ", gamma_G) fi  then
y_G=map_KGB_gen_tits(y_H,dual_quasisplit_form(G),M) then
()=if e_verbose then prints("y_G: ", y_G) fi then
phi_G_0=phi(y_G,gamma_G) then
()=assert(is_valid(phi_G_0), "phi_G is not valid") then
theta_G_v=involution(y_G) then
theta_G=-^theta_G_v then
()=if e_verbose then prints("theta_G: ", theta_G,new_line,"torus_factor(x_H): ", torus_factor(x_H)) fi then
x_G_0=KGB_elt(inner_class(G),theta_G,x_H.torus_factor*M) then
()=if e_verbose then prints("x_G_0: ", x_G_0) fi then
()= if e_verbose then prints("x_G_0.real_form: ",x_G_0.real_form) fi then
()=if e_verbose then prints("x_G_0.torus_factor",x_G_0.torus_factor) fi then
(x_G,phi_G)=make_dominant(x_G_0,phi_G_0) in (x_G,phi_G)

{x_H must be a pure KGB element for H}
{long version includes p_G}
set epstar_std_long(KGBElt x_H,L_homomorphism phi_H,RealForm G,mat M)=(Param,ParamPol):
assert(is_pure(x_H), "x_H is not pure (epstar only defined at the moment for pure real forms of H and G");
let (x_G,phi_G)=lift_pair(x_H,phi_H,G,M) then
()=if e_verbose then prints("x_G: ", x_G, " ", x_G.real_form, " ", x_G.torus_factor) fi then
p_G=parameter(x_G,phi_G) then
()=if e_verbose then prints("p_G=", p_G) fi
in (p_G,finalize(p_G))

set epstar_std(KGBElt x_H,L_homomorphism phi_H,RealForm G,mat M)=ParamPol:let (,X)=epstar_std_long(x_H,phi_H,G,M) in X

{assume M=id}
set epstar_std(KGBElt x_H,L_homomorphism phi_H,RealForm G)=ParamPol:let (,X)=epstar_std_long(x_H,phi_H,G,id_mat(x_H.root_datum.rank)) in X

set epstar_std(Param p_H,RealForm G,mat M)=ParamPol:
let gamma_H=p_H.infinitesimal_character then
y_H=y_gen(p_H) then
phi_H=phi(y_H,gamma_H) then
x_H=p_H.x in
epstar_std(x_H,phi_H,G,M)

{assume M=id}
set epstar_std(Param p_H,RealForm G)=ParamPol:epstar_std(p_H,G,id_mat(G.rank))

set epstar_std(ParamPol P_H,RealForm G,mat M)=ParamPol:
sum(G,for c@p in P_H do c*epstar_std(p,G,M) od)

{assume M=id}
set epstar_std(ParamPol P_H,RealForm G)=ParamPol:epstar_std(P_H,G,id_mat(rank(G)))

set epstar(L_homomorphism phi_H,RealForm G,mat M)=L_homomorphism:
let y_H=phi_H.y then
gamma_H=phi_H.gamma then
()=if e_verbose then prints("y_H: ", y_H, new_line, "gamma_H: ", gamma_H) fi  then
gamma_G=M*gamma_H then
()=if e_verbose then prints("gamma_G: ", gamma_G) fi  then
y_G=map_KGB_gen_tits(y_H,dual_quasisplit_form(G),M) then
()=if e_verbose then prints("y_G: ", y_G) fi then
phi_G=phi(y_G,gamma_G) in
assert(is_valid(phi_G),"phi_G is not valid");phi_G

{assume M=id}
set epstar(L_homomorphism phi_H,RealForm G)=L_homomorphism:epstar(phi_H,G,id_mat(G.rank))


{for debugging
 usage: set (y_H,y_G,gamma_H,gamma_G,phi_G,theta_G,x_G,p_G) =epstar_std_info(x_H,phi_H,G,M)a
}
set epstar_std_info(KGBElt x_H,L_homomorphism phi_H,RealForm G,mat M)=(KGBElt_gen,KGBElt_gen,ratvec,ratvec,L_homomorphism,mat,KGBElt,ParamPol):
assert(is_pure(x_H), "x_H is not pure (epstar only defined at the moment for pure real forms of H and G");
let y_H=phi_H.y then
gamma_H=phi_H.gamma then
()=if e_verbose then prints("y_H: ", y_H, new_line, "gamma_H: ", gamma_H) fi  then
gamma_G=M*gamma_H then
()=if e_verbose then prints("gamma_G: ", gamma_G) fi  then
y_G=map_KGB_gen_tits(y_H,dual_quasisplit_form(G),M) then
()=if e_verbose then prints("y_G: ", y_G) fi then
phi_G=phi(y_G,gamma_G) then 
theta_G_v=involution(y_G) then
theta_G=-^theta_G_v then
()=if e_verbose then prints("theta_G: ", theta_G,new_line,"torus_factor(x_H): ", torus_factor(x_H)) fi then 
x_G=KGB_elt(inner_class(G),theta_G,torus_factor(x_H)*M) then
()=if e_verbose then prints("x_G: ", x_G, " ", x_G.real_form, " ", x_G.torus_factor) fi then
p_G=parameter(x_G,phi_G) then
()=if e_verbose then ("p_G=", p_G) fi
in (y_H,y_G,gamma_H,gamma_G,phi_G,theta_G,x_G,finalize(p_G))

set epstar_std_info(Param p_H,RealForm G,mat M)=(KGBElt_gen,KGBElt_gen,ratvec,ratvec,L_homomorphism,mat,KGBElt,ParamPol):
let gamma_H=p_H.infinitesimal_character then
y_H=y_gen(p_H) then
phi_H=phi(y_H,gamma_H) then
x_H=p_H.x in
epstar_std_info(x_H,phi_H,G,M)

{testing: given G, H, compute endoscopic lifting of all unipotent packets from H to (pure real forms of) G
sample usage:
set lifts=test_epstar_std(Sp(6,R),[1,1,1]/2)

to lift from H=compact torus, make s=rho_check(G)/Coxeter number, add long Weyl group element
set G=Sp(6,R)
set lifts=test_epstar_std(G,rho_check(G)/coxeter_number(G),w0(G))
}

set test_epstar_std(RealForm G,ratvec v,WeylElt w)=
let (H,M,Hd)=endoscopic_group(G,v,w) then
unip_H=unipotent_representations(H) then
lifts=##for ph@i in unip_H do
let ()=if e_verbose then prints("i=",i) fi then
 gamma_H=ph.infinitesimal_character then
 gamma_G=gamma_H*M then
 y=y_gen(ph) then
 y_G=map_KGB_gen_tits(y,dual_quasisplit_form(G),M) then
 phi_G=phi(y_G,gamma_G)  then
 phi_H=phi(y,gamma_H) then
 S_H=pure_component_group(phi_H)
 in for x in S_H do epstar_std(x,phi_H,G,M) od
od
in prints("G=",G,new_line,"s=",v,new_line,"H=",H);
prints("#lifts: ", #lifts);lifts

set test_epstar_std(RealForm G,ratvec v)=test_epstar_std(G,v,id_W(G))

{---------------irreducibles-----------}

set epstar_irr(Param p_H,RealForm G,mat M)=ParamPol:
composition_series(epstar_std(character_formula(p_H),G,M))

set epstar_irr(Param p_H,RealForm G)=ParamPol:epstar_irr(p_H,G,id_mat(rank(G)))

set epstar_irr(ParamPol P_H,RealForm G,mat M)=
sum(G,for (c,p) in %P_H do c*epstar_irr(p,G,M) od)

set epstar_irr(ParamPol P_H,RealForm G)=
sum(G,for (c,p) in %P_H do c*epstar_irr(p,G) od)

{P should be stable on G_qs, P is a ParamPol of irreducibles}
set epstar_stable(ParamPol P,RealForm G,mat M,ratvec z)=ParamPol:
let ps=pure_stabilize(P,z) in
sum(G,for P in ps do prints("P=",P);let ep=epstar_irr(P,G,M)  in prints("ep=",ep);ep od)

set epstar_stable(ParamPol P,RealForm G,ratvec z)=ParamPol:epstar_stable(P,G,id_mat(rank(G)),z)

set epstar_stable(L_homomorphism phi_H,RealForm G,ratvec z)=ParamPol:
let H=dual_quasisplit_form(inner_class(phi_H)) then
P_H=stable_sum(H,phi_H) in 
epstar_stable(P_H,G,z)

set test_epstar_stable([Param] params,RealForm G, ratvec z)=[(ParamPol,ParamPol)]:
for P in stable_sums_irr(params) do (P, epstar_stable(P,G,z)) od

{test_epstar_stable(weak_packets(H),G,z)}
set test_epstar_stable([([([Param],[WCell])],[(int,int,Param)])] wp_H,RealForm G,ratvec z)=[[(ParamPol,ParamPol)]]:
for packet in wp_H do test_epstar_stable(parameters(packet),G,z) od

set show([[(ParamPol,ParamPol)]] data)=void:
for a@i in data do 
 for (P,Q)@j in a do 
  prints("-------------------------------",new_line,"i=",i," j=",j,new_line,"P=",P,new_line,"lift(P)=",Q,new_line) od od


set quotient(mat A,mat B)=
let X=left_inverse(A)*B in finite_quotient(X)

set matrices(mat theta)=
let A=kernel(1+theta) then
B=1-theta in (A,B)

set matrices(KGBElt x)=matrices(x.involution)
set quotient(KGBElt x)=let (A,B)=matrices(x) in quotient(A,B)
set matrices(KGBElt_gen x)=matrices(x.involution)
set quotient(KGBElt_gen x)=let (A,B)=matrices(x) in quotient(A,B)

set quotient_elements(KGBElt_gen x)=[ratvec]:
let (A,B)=matrices(x) then 
q=quotient(A,B) in
if =#q then [] else let
Q=for (v,d) in q do v/d od then
vecs=box(2,#Q) in columns(A*Q*vecs) fi

set quotient_elements(KGBElt x)=[ratvec]:quotient_elements(KGB_elt_gen(x))

set endoscopic_elements(L_homomorphism phi)=[ratvec]:
quotient_elements(phi.y)















