< basic.at {for parameter}
<K_highest_weights.at {for LKTs}
{This script is about the new relation on pairs (x,lambda) defining a
standard Param (meaning lambda is dominant on the imaginary roots). I'm
interested in (x,lambda) so that there exists a nu making
(x,lambda,nu) weakly dominant, but I don't known how to test for this
condition easily.

The relation is the partial preorder GENERATED by

(x,lambda) \le_NEW (x',lambda')

if there are nu and nu' making irr(x',lambda',nu') a composition
factor of std(x,lambda,nu). This is really a relation on K-types, and
it has strictly fewer relations than the branching partial preorder
that Annegret has studied.

I will often have in mind an infinitesimal character gamma (dominant
ratvec), and just look at the stricter requirement

there and nu and nu' as above with height(infl_char(x,lambda,nu)) \le
height(gamma). (The composition factor assumption implies that

infl_char(x,lambda,nu) = infl_char(x',lambda',nu').)

The height of this gamma is meant to be the "Dup" appearing in these
functions. Could write

(x,lambda) \le_{NEW,Dup}  (x',lambda').

The reason this is interesting is this: any K-type (xc,lambdac)
appearing in the hermitian signature of irr(x,lambda,nu) (this last
having infl char gamma of height Dup) must satisfy

(x,lambda) \le_{NEW,Dup} (xc,lambdac)

So if you can compute the (necessarily finite) \le_{NEW,Dup} interval
{(xc,lambdac)} above (x,lambda), then you know that the signature
would have to change sign on one of the K-types (xc,lambdac).  So
those are the K-types you should look at to study signatures.

I think that \le_{NEW,Dup} behaves a lot like the Bruhat order, EXCEPT
WITH INEQUALITIES REVERSED!!!  (I thought about changing the direction
of all the <=, but the present choice seems really natural in
Annegret's setting: the highest weight of the KType is INCREASING as
you move up in the order.

What's awful about this is that it means you move UP in the order
using a DESCENT on a KGBElt: you reflect in a C- root (making it C+),
or you Cayley through a real root (making it noncompact
imaginary. HEIGHT increases as you move up, but LENGTH (of a KGBElt)
decreases.

}

{lambda is weakly dominant for imaginary roots}
set is_standard(KGBElt x, ratvec lambda) = bool:
    is_standard(parameter(x,lambda, 0*lambda))

set height(KGBElt x, ratvec lambda) = int:
    height(parameter(x,lambda,0*lambda))

{in (x,lambda), lambda is really a coset of (1-theta)X^*. Atlas has a preferred representative;
this function finds it.}
set coset(KGBElt x, ratvec lambda) = (KGBElt,ratvec):
    (x, parameter(x,lambda,0*lambda).lambda)

set K_types_NEW(KGBElt x, ratvec lambda) = [KType]:
    let p = parameter(x,lambda,0*lambda)
    in if (1*p).= then []
       else LKTs(p)
       fi

set K_types_NEW(xlambda_hash xlHash) = KType_hash:
    let answer = make_KType_hash()
    then () = for (x,lambda) in xlHash.list()
    	      do for mu in K_types_NEW(x,lambda)
	      	 do answer.match(mu)
	    	 od
	      od
    in answer

{one simple step descent from x}
set imm_pred_xs(KGBElt x) =[KGBElt]:
    let ans = [KGBElt]:[]
    then () = for i:x.real_form.semisimple_rank
    	      do if status(i,x) = 0 {C-}
	      	 then ans #:= cross(i,x)
 	     	 elif status(i,x) = 2
	     	 then let xprime0 = Cayley(i,x)
	     	      then xprime1 = cross(i,xprime0)
		      in ans##:= if xprime1 = xprime0
		       	     	 then [xprime0]
			     	 else [xprime1,xprime0]
			     	 fi
	         fi
	      od
     in ans

{one simple step descents from (x,lambda)}
set imm_pred(KGBElt x, ratvec lambda, int i, int Dup) = [(KGBElt,ratvec)]:
    let G = x.real_form
    then refl = reflection(G,i), alpha = simple_roots(G)[i], alphavee = simple_coroots(G)[i]
    then answer = [(KGBElt,ratvec)]: []
    then () =  if status(i,x) = 0 {C-}
       	       then let xprime = cross(i,x), m = int: 1, lambdaprime = refl*lambda+alpha
	       	    in while is_standard(xprime, lambdaprime)
	       	  	     and height(xprime, lambdaprime) <= Dup
		       do answer#:= coset(xprime,lambdaprime);
		       	  lambdaprime+:= alpha
		       od
	       elif status(i,x) = 2 {r}
	       then let xprime0 = Cayley(i,x)
	       	    then xprime1 = cross(i,xprime0)
	       	    then base = (lambda*alphavee).numer
	       	    then lambdaprime = lambda +((-base+2)\2)*alpha
	       	    in while is_standard(xprime0, lambdaprime) and
	    	 	    height(xprime0, lambdaprime) <= Dup
		       do answer##:=[coset(xprime0,lambdaprime),coset(xprime1,lambdaprime)];
		          lambdaprime+:= alpha
		       od
	       fi
    in answer

{one step up from (x,lambda) by simple root i, height bounded by Dup}
set imm_pred(RealForm G, xlambda_hash xlHashOld, xlambda_hash xlHashNew, int i, int Dup) = void:
    for (x,lambda) in xlHashOld.list()
    do for (xprime,lambdaprime) in imm_pred(x,lambda,i,Dup)
       do xlHashNew.match(xprime,lambdaprime)
       od
    od

set imm_succ(KGBElt x, ratvec lambda, int i, int Ddown) = [(KGBElt,ratvec)]:
    let G = x.real_form
    then refl = reflection(G,i), alpha = simple_roots(G)[i], alphavee = simple_coroots(G)[i]
    then Dup = height(x,lambda), answer = [(KGBElt,ratvec)]: []
    then () =  if status(i,x) = 4 {C+}
       	       then let xprime = cross(i,x), m = int: 1, lambdaprime = refl*lambda+alpha
	       	    in while is_standard(xprime, lambdaprime)
	       	  	     and height(xprime, lambdaprime) >= Ddown
			     and height(xprime, lambdaprime) < Dup
		       do answer#:= coset(xprime,lambdaprime);
		       	  lambdaprime+:= alpha
		       od
	       elif status(i,x) = 3 {nci}
	       then let xprime = Cayley(i,x)
	       	    then lambdaprime0 = lambda
		    then lambdaprime1 = lambda+alpha
	       	    in answer##:=[coset(xprime,lambdaprime0),coset(xprime,lambdaprime1)]
	       fi
    in answer

set imm_succ([(KGBElt, ratvec)] upList, int i, int Ddown) = [(KGBElt,ratvec)]:
    for (x,lambda) in upList do imm_succ(x,lambda,i,Ddown) od.##

{one step down from (x,lambda) by simple root j, height bounded below by Ddown}
set imm_succ(RealForm G, xlambda_hash xlHashOld, xlambda_hash xlHashNew, int i, int Ddown) = void:
    for (x,lambda) in xlHashOld.list()
    do for (xprime,lambdaprime) in imm_succ(x,lambda,i,Ddown)
       do xlHashNew.match(xprime,lambdaprime)
       od
    od

{|S| steps down from (x,xlHashOld by simple roots in S, height bounded below by Ddown. Insist that length(x)
goes down by |S|.}
set successors_by_S(RealForm G, xlambda_hash xlHashUp, [int] S, int Ddown) = xlambda_hash:
    let T = for h:#S do S[#S - h - 1] od
    then () = prints("T = ",T)
    then xlhashes = for h:#S+1 do make_xlambda_hash() od
    then () = xlhashes[0]:=xlHashUp
    then () = for i@h in T
    	      do let () = imm_succ(G,xlhashes[h],xlhashes[h+1],i,Ddown)
		 then () = prints("h = ", h, ", i = ",i,", current listSIZE = ",xlhashes[h+1].size())
	      	 in ()
	      od
    in xlhashes[#S]

{one step up from (x,lambda), height bounded by Dup}
set imm_pred(RealForm G, xlambda_hash xlHashOld, xlambda_hash xlHashNew, int Dup) = void:
    for i:G.semisimple_rank
    do imm_pred(G, xlHashOld, xlHashNew, i, Dup)
    od

{one step up from (x,lambda), height bounded below by Ddown}
set imm_succ(RealForm G, xlambda_hash xlHashOld, xlambda_hash xlHashNew, int Ddown) = void:
    for i:G.semisimple_rank
    do imm_succ(G, xlHashOld, xlHashNew, i, Ddown)
    od

{keep ascending from (x,lambda) until no ascents are possible: x's are
no C- and all real roots are too small to allow Cayley}
set xl_start(KGBElt x, ratvec lambda, int D) = xlambda_hash:
(   let G = x.real_form, h = length(x)
    then xlHashes = [xlambda_hash]: for n:length(x_open(G))+2 do make_xlambda_hash() od
    then new_size = int:1
    in xlHashes[h].match(x,lambda)
    ;  while new_size > 0 and h > 0
       do imm_pred(G, xlHashes[h],xlHashes[h-1],D)
       ;  new_size := xlHashes[h-1].size()
       ;  if new_size.> then h-:=1 fi
       od
    ;  xlHashes[h]
)

{keep ascending from (x,lambda) by j0, j1,...,j{m-1} until no ascents are possible: x's have all C- roots
to small to allow cross, and real roots are too small to allow Cayley. At each step, all the x's have same
involution.}
set xl_start_small(KGBElt x, ratvec lambda, int Dup) = (xlambda_hash,[int]):
(   let G = x.real_form, h = length(x), i0 = int: -1
    then xlHashes = [xlambda_hash]: for n:length(x_open(G))+2 do make_xlambda_hash() od
    then new_size = int:1, listans = vec: []
    then new_size = int:1
    in xlHashes[h].match(x,lambda)
    ;  while new_size > 0 and h > 0
       do i0 := first
          ( G.semisimple_rank
	  , (int i)bool:
	    let testxl = imm_pred(G,xlHashes[h],xlHashes[h-1],i,Dup)
	    in xlHashes[h-1].size() > 0
	  )
       ;  if i0>=0
	  then prints("i0 = ",i0,", h = ",h, "  ",xlHashes[h-1].list())
	  ; listans #:= i0
	  ; new_size:=xlHashes[h-1].size()
	  ; h-:=1
	  else new_size:=0
	  fi
       od
    ;  (xlHashes[h],listans)
)

{I think the (finite) interval above (x,lambda) might be obtained by
"ascending" to the pairs (xup,lambdaup) in the result hash.list(); all the
xup have the same involution, and are descents of x.  The sequence of
simple roots involved is recorded in S0 = [int]. THEN one chooses an
arbitrary subset S of S0, and descends by successive elements of S0 as
in successors_by_S. The result is too large, but it's not bad.}
