<basic.at
<generics.at
<sort.at { for |sort@[int]| }
<combinatorics.at { for |combination_encode|, and decode }
<Weylgroup.at { for |root_reflection| }

{ This file groups function concerning classification of and computation with
  Levi subgroups.

  It regroups things that used to be in W_classes.at and conjugate.at
}

{ We try as much as possible to work with Levi subgroups without building a
  complete |RootDatum| for them all the time, since that is somewhat costly. }

{ Some possible presentations of a Levi system

  A Levi system, not necessarily standard, can be defined either by the roots
  forming a simple system for it (represented by their indices, usually within
  |posroots(rd)|, though the code handles negative indices of negative roots
  too), or by a predicate selecting the indices of positive roots in the system.

  The function |Levi_info| deduces the predicate from the simple system, or from
  a Weyl group element $w$ (selecting coroots vanishing on $w$-fixed weights),
  and |Levi_datum| builds the root datum for the subsystem, given the predicate.
}

set_type LeviInfo = (RootDatum rd,(int->bool) select)

{ select posroots indices for (non standard) Levi, given by its simple system }
set Levi_info (RootDatum rd, [int] simples) = LeviInfo:
   let orth=kernel(rd.rank ^ for i in simples do coroot(rd,i) od)
   in (rd,(int j) bool: =coroot(rd,j)*orth)

{ the |select| predicate for the above functions to use for a given |w| }
set Levi_info (WeylElt w) = LeviInfo:
   let orth=eigen_lattice(matrix(w),1), rd=w.root_datum
   in (rd,(int i) bool: =coroot(rd,i)*orth)

set posroot_indices (LeviInfo(rd,member)) = [int]: list(rd.nr_of_posroots,member)

set simples (LeviInfo(rd,):LI) = [int]:
   let candidates = LI.posroot_indices.to_bitset
in while candidates>0
   do let i = first_set_bit(candidates)
      then bottoms = filter(>=@int)(coroot_ladder_bottoms(rd,i)).to_bitset
   in candidates:= AND(without_first_set_bit(candidates),bottoms)
   ;  i
   od
{ alternatively, with (rd,select):LI
     let rho2_L = two_rho(Levi_info)
     in list(rd.nr_of_posroots,(int i): select(i) and coroot(rd,i)*rho2_L=2)
}

set is_Levi ((RootDatum,[int]) (rd,simples):args) = bool:
   let r=#simples in
   is_Cartan_matrix(
      matrix((r,r),(int i,int j)int: coroot(rd,simples[i])*root(rd,simples[j]))
   ) and { no roots in the span of |simples| is orthogonal to their $2\rho$ }
(  let ind = posroot_indices(Levi_info(args)), rho2 = two_rho(args) in
   none(ind,(int i)bool: coroot(rd,i)*rho2=0)
)

{ a root datum can be formed from |Levi_info|, or simple (co)root index list }
set Levi_datum = sub_datum@(RootDatum,(int->bool)) { defined in basic.at }
set Levi_datum ((RootDatum,[int])pair) = RootDatum:
   pair.Levi_info.Levi_datum { convert to |LeviInfo| before calling |sub_datum }

set Levi_datum (WeylElt w) = RootDatum: w.Levi_info.Levi_datum

{ It turns out that Levi subsystems (whether or not standard) are conjugate in
  $W$ if and only if their |two_rho| weights are in the same $W$-orbit.
}

{ select from subsets of diagrams representatives of $2\rho$-value classes }
set standard_Levi_conjugacy_representatives (RootDatum rd) = [ [int] ]:
    let reps_by_rho = ([[int]]->[[int]]):
      representatives_by
         (([int] sub)vec:dominant(rd,two_rho(rd,sub)),rlex_leq@(vec,vec))
   , r = rd.semisimple_rank
in for k:r+1 do reps_by_rho(choices_from(#r,k)) od.##

{ The following functions, up to |classify_standard_Levis|, aim to classify
  standard Levis under conjugation _and_ find conjugators for each one from the
  first of their class. The Levi orbit table produced is used in some functions
  in W_classes.at; the ultimate goal of efficiently classifying Weyl group
  elements up to conjugation, with witnesses, is also achieved there.

  For each standard Levi system |standard_Levi| (a list of simple root indices)
  we determine the dominant orbit representative |rho2_dom| of its $2\rho$, a
  Weyl group element |w0| that witnesses this (|w0*rho2_dom=two_rho(rd,Levi)|),
  and the (non standard) image $L$ under |inverse(w0)| of |standard_Levi|, which
  has |two_rho(Levi_info(L))=rho2_dom| (this holds because the Levi system
  remains positive throughout the action by letters of |inverse(w0)|). A
  conjugate standard Levi system will give the same |rho2_dom|, but will not
  necessarily transform to the same system $L$; therefore we generate the orbit
  of $L$ under the stabiliser subgroup of the |rho2_dom|, which is also a Levi
  subgroup (of unrelated type) and therefore generated by the reflections that
  stabilise |rho2_dom|. The generation also finds witnesses of the conjugation.
}


{ Next task: given a standard Levi, list the non-standard Levis conjugate to it
  whose $2\rho$-value is dominant
}

set_type orbit_entry =
  ( int L_int  { Levi subgroup, as |[int]| encoded by |combination_encode| }
  , WeylElt w  { conjugator from standard Levi for which orbit was generated }
  )
set_type orbit_data = [orbit_entry]

{ Transform root set by Weyl group action. Is used only for making the $2\rho$
  value of |Levi| dominant, so all positive roots remain so; whence the name }
set act_up (WeylElt w,[int] Levi) = [int]:
  let npr=w.root_datum.nr_of_posroots, root_perm = root_permutation(w) in
  for i in Levi do root_perm[i+npr]-npr od.sort

{ The following function facilitates identifying all Levi subgroups conjugate to
  |standard_Levi|, by providing a full list of those (non standard) Levi
  subgroups whose $2\rho$-value is dominant, with witnesses of the action from
  |standard_Levi| to them; in other words it returns a list of |(L,w)| where
  |two_rho(L)=dominant(two_rho(standard_Levi)) and |L=w*standard_Levi| (but with
  |L| encoded as an integer, so these are not actually valid expressions).

  The orbit is generated for the stabiliser in the Weyl group of the mentioned
  dominant weight, called |rho2_dom| below. The values acted upon are
  fixed-sized sets of posroots (each set generating a subsystem whose sum of
  posroots equals |rho2_dom|) which are represented by a single integer for
  faster comparison. The encoding is done using |combination_encode| which
  generally produces smaller values than |to_bitset| (one could make the values
  even smaller by expointing the fact that only root numbers whose coroots are
  at level |2| for |rho@_dom| are involved, but no gain would be obtained).

  The acting stabiliser is a Levi subgroup (of unrelated type) so generated by
  involutions (root reflections for |simples| below). Orbit elements are
  generated while keeping track of the (first found) acting Weyl group element
  to each point. Since orbits can be very large (notably for E8), it pays to try
  to reduce equality testing by proceeding by shells defined by the distance (in
  the Cayley graph) from the initial point: each newly generated element needs
  to be tested for presence in the previous shell (a backwards move) or in the
  current shell (a move that does not change the distance). All new elements not
  thus filtered out are gathered, and passed through |sort_u| to remove
  duplicates before being integrated as a new shell. Each shell being sorted,
  looking up in each shell can be done using binary search.
}

set rho_stabiliser_orbit (RootDatum rd, [int] standard_Levi) = orbit_data:
(  let (w0,rho2_dom) = from_dominant(rd,two_rho(rd,standard_Levi))
   , npr = nr_of_posroots(rd)
   then gen_act = [vec,WeylElt]: { table for acting by stabiliser generators }
      for i in simples(LeviInfo:(rd,(int i)bool: coroot(rd,i)*rho2_dom=0))
      do ( { posroot permutations (involutions) for stabiliser generators }
           for j in root_involution(rd,i)[npr:] do j-npr od
	 , root_reflection(rd,root(rd,i)) { corresponding Weyl group element }
	 )
      od
   , decode = combination_decode(#standard_Levi)
   , act(vec map,[int] roots) = int:
        for j in roots do map[j] od.sort.combination_encode
   , stack = [orbit_data]:
	[[] { dummy orbit data to make |stack~[1]| valid initially }
	,[ let w=/w0 in ( act_up(w,standard_Levi).combination_encode , w ) ]
	  { starting point: a single |orbit_entry| }
	]
   , present(orbit_data sorted,int code) = bool:
        binary_search_in(sorted,L_int@orbit_entry,<=@(int,int))(code).succeeds
   , sanitise = { process new level of Levis: sort and remove duplicates }
        sort_u((orbit_entry x,orbit_entry y) bool: x.L_int<=y.L_int)
in while { loop with |do| near end }
      let new_level = [orbit_entry]:
	 for (code,w) in stack~[0]
	 do let L = [int]: decode(code) in
	    for (map,refl)@k in gen_act
	    do let M = int: act(map,L) in
	       if not (present(stack~[1],M) or present(stack~[0],M))
	       do (M,refl*w)
	       fi
	    od.##
	 od.##
   in #new_level>0 { whether any new elements were found for new level }
   do stack #:= sanitise(new_level)
   od
{ now |stack| holds all orbit entries in a list of lists; post-process it }
;  foldl(stack[1],merge_by(L_int,<=@(int,int)))(stack[2:])
)


{ in a |Std_Levi_orbit|, |Levi_repr| is an encoded standard Levi, as are first
  members |L| of |others|; for |(L,w) in others| one has |L=w*Levi_repr|
}
set_type other_entry = (int L, WeylElt w)
set_type StdLeviOrbit = (vec rho2, int Levi_repr, [other_entry] others)
set_type StdLeviTable = [[StdLeviOrbit]] { list of lists, grouped by |k| }

set show(StdLeviTable t) = [vec,[int],[[int],WeylElt]]:
  for group@i in t
  do let dec = combination_decode(i)
  in for (r,L,o) in group
     do (r,dec(L),for (n,w) in o do (dec(n),w) od)
     od
  od.##

{ Levi subgroups are conjugate if and only if they have |two_rho| values in the
  same W-orbit; however if two (standard) Levi subgroups are transformed so as
  to have the same (dominant) value of |two_rho|, they have not necessarily
  become equal. However one Levi subgroup is necessarily found in the
  |rho_stabiliser_orbit| of the other, with a witnessing Weyl group element, and
  this allows finding a conjugator from one Levi to the other. The
  classification of standard Levi subgroups then proceeds by transforming each
  to a situation with dominant |two_rho|, grouping together those with the same
  value pf |two_rho|; then in each group the first one is chosen to represent
  the orbit, |rho_stabiliser_orbit| is applied to it, and all other elements in
  the group are looked up in this orbit.
}

{ group together conjugate standard Levis, with witness conjugating from first }
set classify_standard_Levis (RootDatum rd) = StdLeviTable:
   let classify_group ([[int]] list) = [StdLeviOrbit]: { sorted by |rho2| }
      for class in [[ ([int],(WeylElt,vec)) ]]:
          list.
          (map( ([int]Levi):(Levi,from_dominant(rd,two_rho(rd,Levi))) )).
	  (partition_by( ([int].,(WeylElt.,vec rho2)) vec: rho2
	               , rlex_leq@(vec,vec)))
      do let (Levi0,(w0,rho2_dom))=class[0]
	 then orbit = [orbit_entry]: { sorted by their |L_int| componenta }
	    rho_stabiliser_orbit(rd,Levi0)
	 then w_of(int L) = WeylElt:
	    case binary_lookup_by(L_int,<=@(int,int)) (L,orbit)
	    | none: error("Levi ",combination_decode(#Levi0)(L)
	                 ," not found a dominant 2rho ",rho2_dom)
	    | some(pos): orbit[pos].w
	    esac
      in ( rho2_dom,combination_encode(Levi0)
	 , [other_entry]: { not sorted }
	   for (Levi,(w1,)) in class[1:]
	   do let Levi_dom = act_up(/w1,Levi).combination_encode in
	      other_entry: ( Levi.combination_encode, w1*w_of(Levi_dom) )
	   od
	 )
      od
   ,  r = rd.semisimple_rank
   in for k:r+1 do classify_group(choices_from(#r,k)) od

set_type StdLeviImage =
   (WeylElt actor { conjugator from |image| back to original |w| }
  , [int]   std_Levi  { simples for a standard Levi }
  )
set_type StdLeviFinder = ([int]->StdLeviImage)

{
  From $w$ we find the associated non-standard Levi subsystem, the minimal one
  in whose Weyl group $w$ occurs. Our next task, surprisingly difficult, is to
  find a standard Levi system conjugate to it, and a conjugating element of $W$.

  The difficulty that the set of generators for our system may contain negative
  roots, so that the sum of positive roots of the system is not a positive sum
  of the given generators, but of a different set |Levi_datum(rd,Levi).simples|
  (defining the same subsystem). That set is in the orbit of the former (even
  under the Weyl group of just the Levi itself), but using it woudtl be quite
  cumbersome. However the function |two_rho@(rd,[int])| from basic/at is defined
  in a positivity-agnostic way, so we can use that and proceed very similarly to
  how we looked up standard Levis (but using already computed |StdLeviTable|).
}

{ For looking up arbitrary Levi subgroups, we need a slightly different table
  than |StdLeviTable|: a list of one |orbit_data| for each |rho2_dom| value
}

set_type rho_data = ([int] Levi, vec rho2_dom, orbit_data orbit)

set orbits_table (RootDatum rd) = [[ rho_data ]]:
   let r=rd.semisimple_rank
in for k:r+1
   do let rho_infos = [[int],vec]:
         for Levi in choices_from(#r,k)
	 do (Levi,dominant(rd,two_rho(rd,Levi)))
	 od.
	 (representatives_by(snd,rlex_leq@(vec,vec)))
   in for (standard_Levi,rho2_dom) in rho_infos
      do (standard_Levi,rho2_dom,rho_stabiliser_orbit(rd,standard_Levi))
      od
   od

{ given |StdLeviTable|: tabled representative of any Levi, and conjugator }

set Levi_lookup (RootDatum rd, [[ rho_data ]] table) = StdLeviFinder:
   ([int] Levi): let (w0,rho2_dom) = from_dominant(rd,two_rho(rd,Levi)) in
   StdLeviImage:
   case binary_search_get(table[#Levi], rho2_dom@rho_data, rlex_leq@(vec,vec))
                         (rho2_dom)
   | none: error("No Levi subgroups with 2rho = ",rho2_dom," are known!")
   | some(standard_Levi,,data):
        let L_dom = act_up(/w0,Levi).combination_encode
     in case binary_search_get(data, L_int, <=@(int,int))(L_dom)
        | none: error("Levi subgroup absent in orbit!")
	| some(,w): (w0*w,standard_Levi)
	esac
   esac

{ Here is another approach that we previously used instead of using |two_rho|;
  we keep it because the implemented functionality might have other uses. For
  one, the function |from_standard_Levi| below is a fast way to find some
  conjugate standrad Levi of an arbitrary one, without doing classification.

  For the case where we are given a non standard list of simple generators (not
  all positive, and in arbitrary order) for the _full_ root system, there is an
  easy algorithm to find $w$ (called |chamber| below) that maps the set of
  simple roots of |rd| to those generators, and the permutation of them (map
  from positions to simple root index being mapped to it) so obtained. It goes:
  as long as the system contains a negative root, select one (recording its
  position) and apply the corresponding (non simple) root reflection to all
  roots; ultimately all roots become positive, and as a set we have obtained the
  simple roots. The list of their indices is our permutation; as letters of $w$,
  from right to left, take for each reflection applied the simple generator that
  ended up at the recorded position. This is done in |chamber_max_system| below.

  Our approach is then to extend the Levi system one root at a time to a maximal
  system, and then apply this algorithm; once this is, done we get a standard
  Levi conjugate to our original by truncating the above permutation to as many
  initial entries as the rank of our original Levi was, and a Weyl group element
  conjugating that standard Levi to the original (|from_standard_Levi | below).
  The classification of the standard Levi subgroups finally allows us to replace
  the standard Levi by the elected representative of its class.

  Extending to a maximal rank Levi is done by repeatedly finding a root by which
  we can extend the Levi system to a larger one; to this end we first locate
  using |minimal_extenders| a set of candidates (root indices, not necessarily
  positive ones), whose roots are minimally positive for some some linear form
  vanishing on |Levi|. From these, |extend_Levi| will then select a minimal one
  that extends |Levi| by adding a single root.
}

{ list of posroot indices, minimal>0 for some linear form vanishing on |Levi| }
set minimal_extenders (RootDatum rd,[int] Levi) = [int]:
   let orth = { columns: generators in $X_*$ of annihilator subspace of |Levi| }
      kernel(rd.rank ^ for i in Levi do root(rd,i) od)
in case a_column_with((vec alpha)bool: !=alpha*orth {@*(vec,mat)}, rd.posroots)
   | none(): [] { |Levi| already spans subspace containing all roots }
   | some(alpha):
      { find a column |f| of |orth| (coweight) witnessing |alpha*orth| nonzero }
      let f = requisition(a_column_with((vec cowt)bool: !=cowt*alpha, orth))
{
      , min=0 { minimal positive coroot evaluation on |wt| so far; 0 if none }
      , result = [int]: [] { list of root indices with minimal positive eval }
      in for beta@i in rd.posroots
         do let eval=f*beta then abs_eval=eval.abs in
            if =eval then () { ignore roots on which |f| vanishes }
            elif min=0 or abs_eval<min { cases where |result| is replaced }
            then min:=abs_eval; result:=[if eval<0 then -1-i else i fi]
            elif abs_eval=min { ex aequo case, now |result| is extended }
            then result #:= if eval<0 then -1-i else i fi
            fi
         od
      ; result
}
      then parts = [[vec]]:
         partition_by((vec alpha)int:abs(f*alpha),<=@(int,int))(rd.posroots)
      then part = parts[#(f*parts[0][0]=0)] { for minimal nonzero value of |f| }
      , ri(vec alpha) = int: let i=root_index(rd,alpha) in
                             if f*alpha>0 then i else ~i fi
      in map(ri)(part)
   esac

set extend_Levi (RootDatum rd,[int] Levi) = [int]:
(  let mins = minimal_extenders(rd,Levi), npr=rd.nr_of_posroots
   then bottoms = Levi.(foldl
      ( [npr*2].to_bitset-1
      , (int mask, int i) int:
         let bots = for j in root_ladder_bottoms(rd,i) do j+npr od in
	 AND(mask,to_bitset(bots))
      ))
in for m in mins do if is_member_bitset(m+npr,bottoms) then return Levi#m fi od
;  assert(#mins=0) { if there were any candidates, one should work }
;  [] { return indication that |Levi| was already maximal }
)

{ return maximal Levi containing |Levi|, ordered in the way they were found }
set maximise (RootDatum rd,[int] !Levi) = [int]:
   let ssr = rd.semisimple_rank, max=Levi in
   while #max<ssr do max:=extend_Levi(rd,max); assert(!=#max) od; max

{ find chamber defined by a maximal system, and its simple root permutation }
set chamber_max_system (RootDatum rd, [int] sys) = (WeylElt,[int]):
   let roots= rd.rank # for index in sys do root(rd,index) od
   , ssr=rd.semisimple_rank
   then positions = { a list of positions in |roots| (rather than a Weyl word) }
      assert(#sys=ssr) { first check that |sys| has enough roots };
      while let i=first(ssr,(int i)bool: not is_posroot(rd,roots[i]))
      in i>=0
      do roots := left_reflect(rd,roots[i],roots); i { record position }
     ~od
   then { convert |positions| to indices in |rd| of corresponding |roots| }
     perm= for alpha in roots do root_index(rd,alpha) od
   in assert(perm.sort=#ssr,"Not a complete system");
   (W_elt(rd,for pos in positions do perm[pos] od),perm)

{ for non-standard Levi: some conjugate standard Levi, and conjugator from it }
set from_standard_Levi ((RootDatum,[int]) (rd,Levi):arg) = StdLeviImage:
   { the |std_Levi| component of the result is not sorted }
   let (chamber,perm) = chamber_max_system(rd,maximise(arg)) in
   (chamber,perm[:#Levi] { select start of simple indices list })

{ given |StdLeviTable|: tabled representative of a standard Levi, conjugator }
{ does linear search for |rho2| in the table, then again in its orbit }
set standard_Levi_lookup (RootDatum rd,StdLeviTable full_table) =
   StdLeviFinder:
   ([int] unsorted_standard_Levi):
   let rho2 = dominant(rd,two_rho(rd,unsorted_standard_Levi))
   , Levi_code=unsorted_standard_Levi.sort.combination_encode
   , table = [StdLeviOrbit]: { list is sorted by their |rho2| components }
       full_table[#unsorted_standard_Levi]
   , decode = combination_decode(#unsorted_standard_Levi)
   then orbit = StdLeviOrbit:
      case binary_search_get(table,rho2@StdLeviOrbit,rlex_leq@(vec,vec))(rho2)
      | some(orbit): orbit | none: error("No orbit matches dominant ",rho2)
      esac
   in StdLeviImage:
   if Levi_code=orbit.Levi_repr
   then (id_W(rd),decode(Levi_code))
   else let conj =
      case get_last(L@other_entry,=@(int,int))(orbit.others,Levi_code)
      | none: error("No other entry for ",rho2," in table matches ",Levi_code)
      | some(entry): entry.w
      esac
   in (conj , decode(orbit.Levi_repr))
   fi

{ given |StdLeviTable|: tabled representative of any Levi, and conjugator }
set Levi_lookup (RootDatum rd,StdLeviTable table) = StdLeviFinder:
   let lookup = StdLeviFinder: standard_Levi_lookup(rd,table) in
   ([int] Levi) StdLeviImage:
   let (w,unsorted_standard_Levi) = from_standard_Levi(rd,Levi)
   then (conj,Levi) = StdLeviImage: lookup(unsorted_standard_Levi)
   in (w*conj,Levi) { keep the tabulated Levi found, adapt the conjugator }


forget orbit_data
forget other_entry
