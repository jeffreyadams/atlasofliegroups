<poset.at

{a simplicial complex consists of a list of facets, each facet is a vec
 nodes=[0,...,n-1]
 each node should be thought of as corresponding to a point in some D-dimensional space V
 facet=[a0,...,ad] <-> d-dimensional simplex generated by the points a0,...,ad in V
 the facets are implicitly given in a list [facet_0,...,facet_F]
 however what is recorded are the facets grouped by dimension, and an index function
  taking each facet to an integer 0,...,F
 sc.facets=[[vec]]: list of facets grouped by dimension
          =[facets of dim 0,...,facets of dim n]
 sc.index=[[int]] of same size as sc.facets
 index[i][j]=k means: if F=facets[i][j], then dimension(F)=i, and
  index of F in list of facets is k
}
set_type [SimplicialComplex=([[vec]] facets,[[int]] index),
          PreSimplicialComplex=[vec]]

set null_simplicial_complex=SimplicialComplex:([[vec]]:[],[[int]]:[])

set dimension(vec F)=int:#F-1
set dim(vec F)=int:dimension(F)
set dim(PreSimplicialComplex psc)=int:max(for facet in psc do #facet od)-1
set dim(SimplicialComplex sc)=#sc.facets-1
set #(SimplicialComplex sc)=int:sum(for v in sc.index do #v od)

{the facets are parametrized two ways: sc.facets=[[vec]] grouped by dimension,
 and sc.facets_flat=[vec] in a list
 in other words you can specify a facet by a pair of integers (d,j) or a single integer k
 lookup: from int k->vec F
 find:   vec F -> (int,int): (d,j)
 index:  vec F -> int:k
 sc.index[d][j]=int k
 sc.reverse_index(int k)=(int d,int j)
}

set lookup(SimplicialComplex sc, int k)=vec:
for d:#sc.index do
 let j=find(sc.index[d],k) in
  if j!=-1 then return(sc.facets[d][j])
 fi
od;[]

set facets_flat(SimplicialComplex sc)=[vec]:
for i:#sc do lookup(sc,i) od

set find(SimplicialComplex sc,vec F)=(int,int):
 let d=dim(F) in
 (d,find(sc.facets[d],F))

set index(SimplicialComplex sc,vec F)=int:
let (d,j)=find(sc,F) in sc.index[d][j]

set reverse_index(SimplicialComplex sc, int k)=(int,int):
find(sc,lookup(sc,k))

set simplicial_complex(PreSimplicialComplex psc)=SimplicialComplex:
let dim=dim(psc) then
facets=[[vec]]:for i:dim+1 do [vec]:[] od then
index=[[int]]:for i:dim+1 do [int]:[] od in
for facet@i in psc do
    facets[dim(facet)]##:=[facet];
    index[dim(facet)]#:=i
od;
(facets,index)



set simplex(int d)=SimplicialComplex:
let S=for i:d do i od then
all=generate_all_subsets(S)  in
simplicial_complex(for i:#all-1 from 1 do all[i] od)

{at least for now: all parameters should have the same (x,lambda), varying nu}

{provide (x,lambda,list of nus, vertex data)}
set simplicial_complex(KGBElt x,ratvec lambda,[ratvec] nus,VertexData vd)=SimplicialComplex:
let G=x.real_form then
(Lvd, Perm, mapAct) = localFD_Lvd(x,lambda,vd) in
simplicial_complex(lookup_vertices_for_barycenters(G,Lvd,nus))

{provide (x,lambda,list of nus), get the vertex data from x.real_form}
set simplicial_complex(KGBElt x,ratvec lambda,[ratvec] nus)=SimplicialComplex:
let G=x.real_form then
vd=FPP_vertex_data(G) in
simplicial_complex(x,lambda,nus,vd)

{given list of parameters, all with same (x,lambda), and vd}
set simplicial_complex([Param] parameters,VertexData vd)=SimplicialComplex:
if =#parameters then null_simplicial_complex else
let x=parameters[0].x then
lambda=parameters[0].lambda in
assert(all(for p in parameters do p.x=x and p.lambda=lambda od),"not all parameters have same x,lambda");
simplicial_complex(parameters[0].x, parameters[0].lambda, for p in parameters do p.nu od,vd) fi

{given list of parameters, all with same (x,lambda); compute Vertex Data}
set simplicial_complex([Param] parameters)=SimplicialComplex:
if =#parameters then null_simplicial_complex else
simplicial_complex(parameters,FPP_vertex_data(parameters[0].real_form)) fi

set poset(SimplicialComplex sc)=
for F in sc.facets_flat  do
 let dim=dim(F) in
  if dim>0 then
   ##for G@j in sc.facets[dim-1] do
      if is_subset(G,F) then [index(sc,G)] else [] fi od
  else [] fi
 od

set show(SimplicialComplex sc)=
prints("dimension of space: ", dim(sc),new_line,
"number of facets: ", #sc,new_line,
"#facets by dimension: ", (for v in sc.facets do #v od),new_line,
"i: index of F in facets_flat",new_line,
"(dim,j): F=facets[dim][j]");
tabulate(["i","dim","j","F"]#
for F@i in facets_flat(sc) do
 [i.to_string, dim(F).to_string, let (,j)=find(sc,F) in j.to_string,F.to_string] od)

set show_long(SimplicialComplex sc)=
prints("dimension of space: ", dim(sc),new_line,
"number of facets: ", #sc,new_line,
"#facets by dimension: ", (for v in sc.facets do #v od),new_line,
"i: index of F in facets_flat",new_line,
"(dim,j): F=facets[dim][j]");
tabulate(["i","dim","j","F"]#
for F@i in facets_flat(sc) do
 [i.to_string, dim(F).to_string, let (,j)=find(sc,F) in j.to_string,F.to_string] od);
 tabulate(["dim","#","facets this dimension"]#for d:#sc.facets do
 [d.to_string,(#sc.facets[d]).to_string,sc.facets[d].to_string] od)



set coboundary(SimplicialComplex sc, int k)=
let F=lookup(sc,k) in
if dim(F)=dim(sc) then [] else
##for G@j in sc.facets[dim(F)+1] do if is_subset(F,G) then [sc.facets[dim(F)+1][j]] else [] fi od fi