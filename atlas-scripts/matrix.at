<basic.at { for |sum@[int] }

{ Functions for some non elementary but general matrix operations, like finding
  a left or right inverse of a given matrix, if one exists.
}


set upper_unitriangular_inverse (mat U) = mat:
   let n=#U then Q=id_mat(n) { is made to satisfy $Q*U=I_n$ below }
in for Uj@j in U
   do Q[j] := for i:j do -sum(for k:j-i from i do Q[i,k]*Uj[k] od) od
     ## Q[j][j:] { retain the final $n-j$ rows of column $j$ of $Q$ }
   od; Q

{
  The functino |ech_up| is a complement to the built-in |echelon@mat| (which
  produces an "upper" column echelon form by column operations) that, in case
  some pivots are below the main diagonal, complements this with row operations
  to make the result truly "upper" (meaning all sub-diagonal entries are zero).

  Make (assumed) result of |echelon| upper triangular using row operations,
  possibly with trailing null rows; return the resulting triangular matrix, and
  the row operations matrix (the one left-multiplied by to obtain it)
}
set ech_up (mat M, [int] pivot) = (mat,mat):
{ assumptions: |pivot| is strictly increasing list of pivot row numbers for |M|
  and one has |M[i,j]=0| whenever |i>pivot[j]

  Since |Bezout| thinks of its argument as a row matrix, we transpose internally
}
   let (k,l)=shape(M:=^M)
   then C = id_mat(l) { record column operations on the l-column transposed M }
in for i:k { loop over rows of |M|, which get modified by column operations }
   do let jj=pivot[i]+1 { column of position beyond the pivot in row i }
   in if i<pivot[i] { avoid doing any work when our range is a single column }
      then
         let (d,c_ops) = { gcd of post-diagonal part of row i & colmn ops }
           Bezout(vector(jj-i,(int j):M[i,i+j])) { a short non-empty range }
         then new_M_cols = M[i:jj] * c_ops, new_C_cols = C[i:jj] * c_ops
      in assert(all(jj-i,(int j): new_M_cols[i,j]=if j=0 then d else 0 fi))
      ; for j:jj-i do M[i+j]:=new_M_cols[j]; C[i+j]:=new_C_cols[j] od
      fi
   od; (^M,^C) { transpose back on exit }

set left_inverse(mat A) = mat: { for injective map to saturated sublattice }
(  let (M,C,pivots,)=echelon(A), c=#A
in if #M<c then error("not injective (rank is ",#M,"<",c,")") fi
;  let (Tri,R)= ech_up(M,pivots)
in if let diag=Tri.main_diagonal in diag=ones(#diag)
   then C*upper_unitriangular_inverse(Tri[:c,:])*R[:c,:]
   else error("image is not saturated")
   fi
)

set right_inverse(mat A) = mat: { section of a surjective lattice map A }
(  let (M,C,pivots,)=echelon(^A), c=A.n_rows
in if M.n_rows<c then error("row rank ",M.n_rows," not full (",c,")") fi
;  let (Tri,R)= ech_up(M,pivots)
in if let diag=Tri.main_diagonal in diag=ones(#diag)
   then ^(C*upper_unitriangular_inverse(Tri[:c,:])*R[:c,:])
   else error("matrix is not surjective")
   fi
)

set weak_left_inverse(mat A) = (mat,int): { left inverse after saturation }
(  let (M,C,pivots,)=echelon(A), c=#A
in if #M<c then error("not injective (rank is ",#M,"<",c,")") fi
;  let (Tri,R)= ech_up(M,pivots) then (T1,d)=invert(Tri[:c,:])
in ( C*T1*R[:c,:] , d)
)

set factor_scalar (mat M) = { factor out common divisor } (int,mat):
  let d=gcd(for col in M do gcd(col) od) in (d,if =d then M else M\d fi)


set principal_submatrix(mat M, [int] S)=mat: { choice |S| of rows, columns }
   let m=#S in matrix((m,m), (int i,int j)int: M[S[i],S[j]] )

set main_diagonal_square_block(mat M, int size, int offset) = mat:
  M[ offset:offset+size, offset:offset+size ]
set top_left_square_block(mat M,int size) = mat: M[ :size, :size]
