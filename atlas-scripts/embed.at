{embed_KGB and embed_param}
<param_pair_hash.at
<L_packet.at

set pr([(Param,Param)] pairs)=void:
let (ph,pg)=pairs[0] then
()=prints("H=", ph.real_form, new_line, "G=", pg.real_form) in
tabulate(for (ph,pg) in pairs do [ph.to_string,pg.to_string] od)

set te_verbose=true

set root_map_old(RootDatum H, RootDatum G)=[[int]]: {ordinary endoscopy case: each entry has length 1}
for i:ss_rank(H) do [root_index(G,H.simple_roots[i])] od

set embed_root(RootDatum H, vec alpha, mat M, RootDatum G)=[vec]:[M*alpha]  {ordinary endoscopy case: each entry has length 1}
                                                                       {silly: in this case M=1, but will generalize to twisted case}

set root_map(RootDatum H, mat M, RootDatum G)=[[vec]]: {ordinary endoscopy case: each entry has length 1}
for alpha in H.simple_roots do [M*alpha] od

{need root_map for integrality data for H,G}
set root_map_old(Param p_H, Param p_G)=[[int]]:
 let H_int=integrality_datum(p_H) then
 G_int=integrality_datum(p_G) in
 root_map_old(H_int,G_int)

{lift_KGB_cross(j_H,root_map,x_G):
 lift simple root #j_H to set of simple roots for G, then apply
 corresponding product of cross actions on G
 alpha -> beta: cross action of \beta
 alpha -0> beta_1,beta_2 orthogonal: product of these 2 cross actions
 alpha -0> beta_1,beta_2 not orthogonal: product of these 2 cross actions and reflection in root beta_1+beta_2
}
set lift_KGB_cross(RootDatum H,vec alpha_H,mat M,KGBElt x_G)=KGBElt:
let G=x_G.real_form then
y=x_G then
 roots=embed_root(H,alpha_H,M,G)  in
 if #roots<2 then
    cross(roots[0],y)
 elif is_orthogonal(G,roots[0],roots[1]) then
    for alpha in roots do y:=cross(alpha,y) od;y
 else
    for alpha in roots##[roots[0]+roots[1]] do y:=cross(alpha,y) od;y
 fi

{? this should also have a different formula in case of 2 non-orthogonal roots}
set lift_KGB_Cayley(RootDatum H,vec alpha_H,mat M,KGBElt x_G)=KGBElt:
let y=x_G in
 for alpha in embed_root(H,alpha_H,M,x_G.real_form) do y:=Cayley(alpha,y) od;y

{assuming H,G quasisplit; also rho_G-rho_H \in X^*}
{x_H_0:torus factor 0 on H -> x_G_0: torus factor 0 on G}
{then x_H=w*x_H_0 -> x_G=w*x_G_0}
set embed_KGB(KGBElt x_H, RealForm G, mat M)=KGBElt:
let theta_H=involution(x_H) then
theta_G=left_inverse(M)*theta_H*M then
x_G_0=KGB_elt(G,theta_G,null(rank(G))) {torus factor 0} then
fiber_H=fiber(x_H) then
fiber_G=cross_sub_orbit(simple_imaginary_reflections(x_G_0),x_G_0) then
x_H_0=fiber_H[0] then
{assume fiber_G[0] has torus factor 0: from cross_sub_orbit it has
 the smallest KGB number, so probably true, but this assumption
 should be removed}
w=cross_divide(x_H_0,x_H)  {w*x_H_0=x_H}
in cross(w.matrix,x_G_0)

set embed_KGB(RealForm H,RealForm G, mat M)=[(KGBElt,KGBElt)]:
for x_H in KGB(H) do (x_H, embed_KGB(x_H,G,M)) od







{use Cayleys and crosses to compute map on KGB, given a single x_H->x_G}
set embed_KGB_old(KGBElt x_H,KGBElt x_G,mat M)=[(int,int)]:
let H=x_H.real_form then
G=x_G.real_form then
known_H=[x_H.number] then
known_G=[x_G.number] then
KGB_map=[(x_H.number,x_G.number)] then
done_H=[int]:[]  {x_H's for which we've computed all crosses and Cayleys}
then
in_list([int] L) = (int i)bool:any(L,(int l):l=i)
then is_known_H = in_list(known_H)
then is_known_G = in_list(known_G)
then is_known_H(KGBElt x_H)=bool:is_known_H(x_H.number)
then is_known_G(KGBElt x_G)=bool:is_known_G(x_G.number) then
lookup_G(int i_G)=  {given i_G find i_H which we've already computed which maps to it}
  let index=first(for (,j) in KGB_map do j=i_G od) then (i_H,)=KGB_map[i_G] in i_H in
while #KGB_map<KGB_size(H) do
let ()=if te_verbose then prints("known_H: ", known_H, new_line, "known_G: ", known_G) fi in
let ()=if te_verbose then prints("KGB_map: ", KGB_map) fi in
let ()=if te_verbose then prints("done_H: ", done_H) fi in
 {find (i,j)  so that (i,j) occurs in KGB_map, but i is NOT in done_H}
 let index_in_KGB_map=
    first(for (i,) in KGB_map do not in_list(done_H)(i) od)
 then
    ()=if index_in_KGB_map=-1 then
       prints("failed to compute complete KGB_map");prints("KGB size of H: ", KGB_size(H),new_line, "#KGB_map: ", #KGB_map);return(KGB_map)
    fi then
    (i_H,i_G)=KGB_map[index_in_KGB_map] then
    x_H=KGB(H,i_H) then
    x_G=KGB(G,i_G) in
    let    ()=if te_verbose then prints(new_line,"x_H: ", x_H) fi  then
    ()=if te_verbose then prints("x_G: ", x_G) fi in
    done_H#:=i_H;
 for alpha@i in H.simple_roots do
    let y_H=cross(alpha,x_H) in
    let ()=if te_verbose then prints("i=",i," alpha=",alpha," (cross)y_H=", y_H,new_line,"is_known_H(y_H): ", is_known_H(y_H)) fi in
      let ()=if not is_known_H(y_H) then
              let y_G=lift_KGB_cross(H,alpha,M,x_G) in
              let ()=if te_verbose then prints("y_G=",y_G) fi in
              {map may not be injectived: (i,j) and (k,j) could both occur
               for example on group side: G=GL(4,R), H=SO(3,2)->GL(4,R)}
                if  true then
{               if not is_known_G(y_G) then}
               if te_verbose then prints("adding: ", y_H.number, " ", y_G.number) fi;
               KGB_map#:=(y_H.number, y_G.number);
               known_G#:=y_G.number;
               known_H#:=y_H.number
              fi
             fi
  in  {now try Cayleys}
  if te_verbose then prints("alpha=",alpha,"  x_H=", x_H, " " ,x_H.real_form, " status!: ", status_text(alpha,x_H)) fi;
  if is_noncompact_imaginary(x_H)(alpha) or is_real(alpha, x_H) then
       let ()=if te_verbose then prints("doing Cayley") fi in
       let y_H=Cayley(alpha,x_H) in
       let ()=if te_verbose then prints("i=",i," alpha=",alpha," (Cayley)y_H=", y_H) fi in
       if not is_known_H(y_H) then
               let y_G=lift_KGB_Cayley(H,alpha,M,x_G) in
               if not is_known_G(y_G) then
                 KGB_map#:=(y_H.number, y_G.number);
                 known_G#:=y_G.number;
                 known_H#:=y_H.number
               fi
              fi
     fi
  od{for i}
od{while #KGB_map};prints("KGB size of H: ", KGB_size(H),new_line, "#KGB_map: ", #KGB_map);KGB_map

set in_list([Param] params,Param p)=bool:>=find(params,p)

set *(mat M,Param p)=
assert(M=id_mat(#M),"*@(mat M,Param p) only implement for M=identity");p
{parameter(M*(p.x),M*(p.lambda),M*(p.nu))}

{see lift_KGB_cross above}
{root map must be for the integrality data of H and G}
set lift_parameter_cross(int j_H,[[int]] root_map,Param p_G)=Param:
let G=p_G.real_form then
G_int=integrality_datum(p_G) then
y=p_G then
 roots=root_map[j_H] in
 if #roots<2 then
{    cross(roots[0],y)}
    cross(G_int.posroots[roots[0]],y)
 elif is_orthogonal(G_int,roots[0],roots[1]) then
    for i in roots do y:=cross(G_int.posroots[i],y) od;y
 else
    let j=root_index(G_int,root(G_int,roots[0])+root(G_int,roots[1])) in
    for i in roots#j do y:=cross(G_int.posroots[i],y) od;y
 fi

set lift_parameter_cross(RootDatum H,vec alpha_H,mat M,Param p_G)=Param:
let G=p_G.real_form then
G_int=integrality_datum(p_G) then
y=p_G then
 roots=embed_root(H,alpha_H,M,G) in
 if #roots<2 then
    cross(roots[0],y)
 elif is_orthogonal(G_int,roots[0],roots[1]) then
    for alpha in roots do y:=cross(alpha,y) od;y
 else
    for alpha in roots##[roots[0]+roots[1]] do y:=cross(alpha,y) od;y
 fi

{? this should also have a different formula in case of 2 non-orthogonal roots}
set lift_parameter_Cayley(RootDatum H,vec alpha_H,mat M,Param p_G)=Param:
let G=p_G.real_form then
G_int=integrality_datum(p_G) then
y=p_G then
roots=embed_root(H,alpha_H,M,G) in
for alpha in roots do  y:=Cayley(alpha,y) od; y

{assuming p_H maps to p_G, extend as far as possible by Cayleys and crosses}
{modifying to use integrality datum AND M instead of root_map}
set embed_parameters(Param p_H, Param p_G,mat M)=
let max=100 then  {cutoff loop after max tries}
H=p_H.real_form then
G=p_G.real_form then
H_int=integrality_datum(p_H) then
G_int=integrality_datum(p_G) then
pair_hash=make_Param_pair_hash([(p_H,p_G)]) then
finished_hash=make_Param_hash() then {hash of parameters for which we've computed all Cayleys and crosses}
is_known(Param p_H)=bool:pair_hash.in_hash(p_H) then
is_finished(Param p_H)=bool:finished_hash.lookup(p_H)!=-1 then
target=#block_of(p_H)  {number of final parameters of H we need to hit} then
()=if te_verbose then prints("target: ", target) fi then
counter=1 in
while counter < max and #pair_hash.finalized()<target do let
()=if te_verbose then prints("----------------------------------------------------------------------",new_line) fi then
()=if te_verbose then prints("counter: ", counter) fi then
()=if te_verbose then prints("target: ", target, "  found: ", #pair_hash.finalized()) fi then
()=if te_verbose then prints("pair_hash: ");pr(pair_hash) fi then
()=if te_verbose then prints("finished: ");pr(finished_hash) fi then
()=if te_verbose then prints("finalized terms: ");pr(pair_hash.finalized()) fi then
()=if te_verbose then prints("target block: ");pr(block_of(p_H)) fi then
()=if te_verbose then prints("target block: ");print_block(p_H) fi then
to_do=first(for i:pair_hash.size() do let (p_H,)=pair_hash.index(i) in not is_finished(p_H) od) then
xx=1;counter+:=1 then
()=if to_do=-1 then
   prints("nothing left to do");break
else
  let (p_H,p_G)=pair_hash.index(to_do) then
  ()=if te_verbose then prints("got pair: ", p_H, " ", p_G) fi then
  ()=if te_verbose then prints("running over all simple roots") fi in
  for alpha@i in p_H.integrality_datum.simple_roots do
    let ()=if te_verbose then prints("root number: ", i, " =", alpha) fi then
    ()=if te_verbose then prints("trying cross") fi then
    q_H=cross(alpha,p_H) then
    ()=if te_verbose then prints("cross result: ", q_H) fi then
    () =if not is_known(q_H) then
       let ()=if te_verbose then prints("computing lifted cross of p_G=",p_G) fi in
       let ()=if te_verbose then prints("alpha=", alpha) fi then
       q_G=lift_parameter_cross(H,alpha,M,p_G) then
       ()=if te_verbose then prints("cross value: q_G=",q_G) fi then
       ()=if te_verbose then prints("addding: ", q_H, " ", q_G) fi in
       pair_hash.match(q_H,q_G)
    fi{end not is_known, done with cross, go to Cayley} then
    ()=if is_noncompact(i,p_H.x) or is_real(i,p_H.x) then
        let q_H=Cayley(i,p_H) in
        let ()=if te_verbose then prints("Cayley i=",i," Cayley:p_H->", q_H,new_line,"p_G=", p_G) fi in
        if not is_known(q_H) then
          let ()=if te_verbose then prints("going to compute Cayley for G:") fi in
          let q_G=lift_parameter_Cayley(H,alpha,M,p_G) in
          let ()=if te_verbose then prints("not is_known; alpha=",alpha,"q_G: ", q_G) fi in
          pair_hash.match(q_H,q_G)
        fi{not is_known}
    fi{is nci or real}  in 1
  od{for i};
  finished_hash.match(p_H)
fi{if to_do=-1} in 1
od{while #map};
if te_verbose then prints("finished embed_parameters", new_line, "counter = ", counter, new_line,
"target = ", target,new_line, "found: ", #pair_hash.finalized()) fi;
pair_hash




{assuming p_H maps to p_G, extend as far as possible by Cayleys and crosses}
{modifying to use integrality datum}
{set embed_parameters_slightly_old(Param p_H, Param p_G, [[int]] root_map)=
let H=p_H.real_form then
G=p_G.real_form then
H_int=integrality_datum(p_H) then
G_int=integrality_datum(p_G) then
known_H=1*p_H then
known_G=1*p_G then
map=[(p_H,p_G)] then
done_H=ParamPol:null_module(H) {p_H's for which we've computed all crosses and Cayleys} then
{()=prints("known_H: ", known_H[p_H], " known_G: ", known_G[p_G]) then}
is_known_H(Param p)=bool:known_H[p]!=0 then
is_known_G(Param p)=bool:known_G[p]!=0 in
while #map<#block_of(p_H) do
let ()=if te_verbose then prints("known_H: ", known_H, new_line, "known_G: ", known_G) fi in
let ()=if te_verbose then prints(new_line,"map: ", map,new_line) fi in
let ()=if te_verbose then prints("done_H: ", done_H) fi in
let index_in_map= first(for (p_H,) in map do done_H[p_H]=0 od) then
{()=prints("index_in_map: ", index_in_map) then}
    ()=if index_in_map=-1 then
       prints("failed to compute complete map");return(map)
    fi then
    (p_H,p_G)=map[index_in_map] then
    ()=if te_verbose then prints(new_line,"p_H: ", p_H) fi  then
    ()=if te_verbose then prints("p_G: ", p_G) fi in
    done_H+:=p_H;
 for i:ss_rank(H_int) do
    let q_H=cross(i,p_H) in
    let ()=if te_verbose then prints("i=",i," cross:p_H->", q_H) fi in
      let ()=if not is_known_H(q_H) then
                let ()=if te_verbose then prints(i, " ", root_map, " p_G=", p_G) fi in
              let q_G=lift_parameter_cross(i, root_map,p_G) in
              let ()=if te_verbose then prints("q_G=",q_G) fi in
              {map may not be injectived: (i,j) and (k,j) could both occur
               for example on group side: G=GL(4,R), H=SO(3,2)->GL(4,R)}
                if  true then
{               if not is_known_G(y_G) then}
               if te_verbose then prints("adding: ", p_H, " ", p_G) fi;
               map#:=(q_H,q_G);
               known_G+:=q_G;
               known_H+:=q_H
              fi
             fi
  in
  if is_noncompact(i,p_H.x) or is_real(i,p_H.x) then
       let q_H=Cayley(i,p_H) in
       let ()=if te_verbose then prints("Cayley i=",i," Cayley:p_H->", q_H,new_line,"p_G=", p_G) fi in
       if not is_known_H(q_H) then
               let q_G=lift_parameter_Cayley(i, root_map,p_G) in
               if not is_known_G(q_G) then
                 map#:=(q_H,q_G);
                 known_G+:=q_G;
                 known_H+:=q_H
               fi
              fi
     fi
  od{for i}
od{while #map};map

set embed_parameters_old(Param p_H, Param p_G, [[int]] root_map)=
let H=p_H.real_form then
G=p_G.real_form then
known_H=1*p_H then
known_G=1*p_G then
map=[(p_H,p_G)] then
done_H=ParamPol:null_module(H) {p_H's for which we've computed all crosses and Cayleys} then
{()=prints("known_H: ", known_H[p_H], " known_G: ", known_G[p_G]) then}
is_known_H(Param p)=bool:known_H[p]!=0 then
is_known_G(Param p)=bool:known_G[p]!=0 in
while #map<#block_of(p_H) do
let ()=if te_verbose then prints("known_H: ", known_H, new_line, "known_G: ", known_G) fi in
let ()=if te_verbose then prints(new_line,"map: ", map,new_line) fi in
let ()=if te_verbose then prints("done_H: ", done_H) fi in
let index_in_map= first(for (p_H,) in map do done_H[p_H]=0 od) then
{()=prints("index_in_map: ", index_in_map) then}
    ()=if index_in_map=-1 then
       prints("failed to compute complete map");return(map)
    fi then
    (p_H,p_G)=map[index_in_map] then
    ()=if te_verbose then prints(new_line,"p_H: ", p_H) fi  then
    ()=if te_verbose then prints("p_G: ", p_G) fi in
    done_H+:=p_H;
 for i:ss_rank(H) do
    let q_H=cross(i,p_H) in
    let ()=if te_verbose then prints("i=",i," cross:p_H->", q_H) fi in
      let ()=if not is_known_H(q_H) then
                let ()=if te_verbose then prints(i, " ", root_map, " p_G=", p_G) fi in
              let q_G=lift_parameter_cross(i, root_map,p_G) in
              let ()=if te_verbose then prints("q_G=",q_G) fi in
              {map may not be injectived: (i,j) and (k,j) could both occur
               for example on group side: G=GL(4,R), H=SO(3,2)->GL(4,R)}
                if  true then
{               if not is_known_G(y_G) then}
               if te_verbose then prints("adding: ", p_H, " ", p_G) fi;
               map#:=(q_H,q_G);
               known_G+:=q_G;
               known_H+:=q_H
              fi
             fi
  in
  if is_noncompact(i,p_H.x) or is_real(i,p_H.x) then
       let q_H=Cayley(i,p_H) in
       let ()=if te_verbose then prints("i=",i," Cayley:p_H->", q_H,new_line,"p_G=", p_G) fi in
       if not is_known_H(q_H) then
               let q_G=lift_parameter_Cayley(i, root_map,p_G) in
               if not is_known_G(q_G) then
                 map#:=(q_H,q_G);
                 known_G+:=q_G;
                 known_H+:=q_H
               fi
              fi
     fi
  od{for i}
od{while #map};map
}

{
set embed_parameters_long(Param p_H, Param p_G, [[int]] root_map)=(bool,[(Param,Param)]):
let H=p_H.real_form then
G=p_G.real_form then
known_H=1*p_H then
known_G=1*p_G then
map=[(p_H,p_G)] then
done_H=ParamPol:null_module(H) {p_H's for which we've computed all crosses and Cayleys} then
{()=prints("known_H: ", known_H[p_H], " known_G: ", known_G[p_G]) then}
is_known_H(Param p)=bool:known_H[p]!=0 then
is_known_G(Param p)=bool:known_G[p]!=0 in
while #map<#block_of(p_H) do
let ()=if te_verbose then prints("known_H: ", known_H, new_line, "known_G: ", known_G) fi in
let ()=if te_verbose then prints(new_line,"map: ", map,new_line) fi in
let ()=if te_verbose then prints("done_H: ", done_H) fi in
let index_in_map= first(for (p_H,) in map do done_H[p_H]=0 od) then
{()=prints("index_in_map: ", index_in_map) then}
    ()=if index_in_map=-1 then
       prints("failed to compute complete map");return(false,map)
    fi then
    (p_H,p_G)=map[index_in_map] then
    ()=if te_verbose then prints(new_line,"p_H: ", p_H) fi  then
    ()=if te_verbose then prints("p_G: ", p_G) fi in
    done_H+:=p_H;
 for i:ss_rank(H) do
    let q_H=cross(i,p_H) in
    let ()=if te_verbose then prints("i=",i," cross:p_H->", q_H) fi in
      let ()=if not is_known_H(q_H) then
                let ()=if te_verbose then prints(i, " ", root_map, " p_G=", p_G) fi in
              let q_G=lift_parameter_cross(i, root_map,p_G) in
              let ()=if te_verbose then prints("q_G=",q_G) fi in
              {map may not be injectived: (i,j) and (k,j) could both occur
               for example on group side: G=GL(4,R), H=SO(3,2)->GL(4,R)}
                if  true then
{               if not is_known_G(y_G) then}
               if te_verbose then prints("adding: ", p_H, " ", p_G) fi;
               map#:=(q_H,q_G);
               known_G+:=q_G;
               known_H+:=q_H
              fi
             fi
  in
  if is_noncompact(i,p_H.x) or is_real(i,p_H.x) then
       let q_H=Cayley(i,p_H) in
       let ()=if te_verbose then prints("i=",i," Cayley:p_H->", q_H,new_line,"p_G=", p_G) fi in
       if not is_known_H(q_H) then
               let q_G=lift_parameter_Cayley(i, root_map,p_G) in
               if not is_known_G(q_G) then
                 map#:=(q_H,q_G);
                 known_G+:=q_G;
                 known_H+:=q_H
               fi
              fi
     fi
  od{for i}
od{while #map};(true,map)

set embed_parameters((Param p_H, Param p_G), [[int]] root_map)=[(Param,Param)]:embed_parameters(p_H,p_G,root_map)

}
