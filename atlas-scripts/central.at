{ Central characters (characters of the center Z(R), real group of the center) }
<center.at

{ Central character data type

  It parametrizes characters of Z=Z(R), i.e., (Lie(Z),Z^delta)-characters

  set delta=distinguished_involution(ic)
  (delta,lambda,nu) defines a character of the fundamental torus in precisely
  the same way as (x,lambda,nu) defines a character of rho-cover of the Cartan
  defined by x.

  This restricts to a character of Z(R) in particular lambda defines a
  character of Z^\delta
  equality: lambda=lambda' + [(1-delta)X^*+R]  and (1-delta)nu=(1-delta)nu'
  (just like for Cartan, the addtion of the radical R in the denominator
  accounts for the restriction to the center)
}
set_type CentralCharacter = (InnerClass ic,vec lambda,ratvec nu)

set in_span ((mat,vec) Av) = bool: can(solve(Av))

set change_coordinates_to_subspace ((mat,vec) Av) = vec:
   case solve(Av) | none: error("no solution") | some(x): x esac

set in_span_Q ((mat,ratvec) Av)=bool: can(solve(Av))

set change_coordinates_to_subspace_Q((mat,ratvec)Av) = ratvec:
   case solve(Av) | none: error("no solution") | some(x): x esac

{-----------------------------------------------------}

set central_character (InnerClass ic,vec lambda, ratvec nu) =
  CentralCharacter: (ic,lambda,(1-ic.distinguished_involution)*nu/2)

set delta (CentralCharacter(ic,,)) = mat: ic.distinguished_involution

{ the character group of Z^delta is X^*/M_Z }
set M_Z (InnerClass ic) = mat: { spanning weights of denominator lattice }
   (1-distinguished_involution(ic)) ## ic.simple_roots
set M_Z_reduced (InnerClass ic) = (mat,vec): { subspace basis, scaling factors }
   adapted_basis(M_Z(ic))

{ equality of central characters }
set = (CentralCharacter chi,CentralCharacter tau) = bool:
(   ic(chi)=ic(tau)
and in_lattice(M_Z(ic(chi)), lambda(chi)-lambda(tau))
and = (1-ic(chi).distinguished_involution)*(nu(chi)-nu(tau))
)

{central character of a parameter}
set central_character (Param p) = CentralCharacter:
  let (x,lr,nu) = %p in central_character(x.inner_class,lr,nu)

{from center.at:

3) center Z(R) of RealForm G:
   Z(R)=Z(R)_c x Z(R)_s
   Z(R)_c = maximal compact subgroup of center = Z(R)^delta
   Z(R)_s is isomorphic, via the exponential map, to a vector space
   (which can be thought of a being over over $\C$, $\R$ or $\Q$)

4) dual Z_hat of center of RootDatum:
   Hom_cts(Z(R),C^*) = Hom_cts(Z(R)_c,S^1) x Hom_cts(Z(R)_s,C^*)
   		     = X^*(Z^delta) x Hom_cts(Z(R)_s,C^*)
   X^*(Z^delta):
   finitely generated abelian group, realized as quotient of lattices
               = X^*/[ (1-delta)X^* + R ] (R = root lattice)
   X^*(Z^delta) has a canonical torsion subgroup (characters of
   Z^delta/(Z_delta)^0)
   rational characters of Z(R)_s: a \Q-vector space
}

{ canonical torsion subgroup of X*(Z^delta) is isomorphic to Z/d_1 x ... Z/d_n
  We represents its elements as [(a_0,d_0),...(a_n,d_n)] where each a_i
  give a congruence class modulo d_i
}
set torsion (CentralCharacter (ic,lambda,)) = [int,int]:
   let (A,v) = M_Z_reduced(ic)
   then sol = change_coordinates_to_subspace(A,lambda)
in for vi@i in v if vi>1 do (sol[i] % vi,vi) fi od

{ element of split part of the character of the radical
  (mat A,ratvec v) <->
   columnns of A are basis of [X^*_Q]^{-delta}, and ratvec v
   gives a linear combination of these
}
set split_radical(CentralCharacter cc)=
let sol=change_coordinates_to_subspace_Q(lie_split_radical_hat(cc.ic),nu(cc)) in
(lie_split_radical_hat(cc.ic),sol)

{element of compact part of the character of the radical:
 (mat A,vec v) <->
   columns of A give Z-basis of X^*(radical^delta),
   v gives a linear combination of these
}
set compact_radical (CentralCharacter cc) =
let lambda=cc.lambda then
lambda_T=(1+cc.delta)*lambda then
lambda_T_radical_part=lie_radical_part(cc.ic,lambda_T) then
lie_compact_radical_hat=lie_compact_radical_hat(cc.ic) then
sol=change_coordinates_to_subspace_Q(lie_compact_radical_hat,lambda_T_radical_part) in
(lie_compact_radical_hat,ratvec_as_vec(sol))

{for output}
set torsion_string(CentralCharacter cc)=
let t=torsion(cc) in
 if #t>0 then
  let rv="[" in
  for i:#t-1 do
  let (a,b)=t[i] in  rv+:= a.to_string + "/" + b.to_string + ","  od;
  let (a,b)=t~[0] in rv+:=a.to_string + "/" + b.to_string;
  rv+:="]";rv
 else
  "empty"
 fi

{human readable description of central character}
set show(CentralCharacter cc)=void:
prints(
 if #torsion(cc)>0 then "torsion part: "+ torsion_string(cc) else "no torsion" fi);
prints(
 let (M,v) = compact_radical(cc) in
 if !=M then "character of compact-radical: "+  v.to_string + "=" +sum(for i:#v do v[i]*M[i] od).to_string else "no compact-radical"  fi);
prints(
 let (M,v) = split_radical(cc) in
 if !=M then "character of split-radical: " + v.to_string + "=" +sum(#M[0],for i:#v do v[i]*M[i] od).to_string  else "no split-radical" fi)

set show_long(CentralCharacter cc)=void:
prints("torsion part: ", torsion_string(cc),new_line);
prints(
let (M,v) = compact_radical(cc) in
 if !=M then 
  "basis of X^*(compact-radical)" + (^compact_radical_basis(ic(cc))).to_string+
  "character of compact-radical: " + new_line + v.to_string + "=" + sum(for i:#v do v[i]*M[i] od).to_string 
 else 
  "compact-radical: empty" fi);
prints(
 let (M,v) = split_radical(cc) in
 if !=M then
  new_line + "basis of X^*(split-radical)_Q:"+(^split_radical_basis(ic(cc))).to_string +
  "character of split-radical: "+ new_line + v.to_string + "=" +    sum(#M[0],for i:#v do v[i]*M[i] od).to_string
else
 "split-radical: empty" fi )

set show_torsion(CentralCharacter cc)=void:prints(torsion_string(cc))

set sort_by_central_character ([Param] list) = ([CentralCharacter],[[Param]]):
let central_characters=[CentralCharacter]:[] then
params=[[Param]]:[] in
for p in list do
 let cc_p=central_character(p) then
  i=first(for cc in central_characters do cc_p=cc od) in
  if i=-1 then
   central_characters#:=cc_p;
   params#:=[p]
  else
   params[i]#:=p
  fi
od;
(central_characters,params)



