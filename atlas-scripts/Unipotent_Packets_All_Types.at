{Given a block and a partition of the dual group, find all Unipotent packets corresponding to that orbit in the block}

{note: rv#:=Psi(parameter(b[t]), S) replaced with
rv#:=first_param(Psi(parameter(b[t]), S)) fi od in several places due
to change of syntax}


<basic.at
<sort.at
<W_reps_type_BC.at
<Vogan-dual.at { for |dual_KGB| }
<groups.at { for |GL| }
<finite_dimensional { for |is_finite_dimensional| }
<induction.at { for |induce_irreducible| }
<stable.at { for |print_stable| }
<combinatorics.at
<K_highest_weights.at

{in this file only: rename Psi to Psi_irreducible (forget at end)}
set Psi(Param p,[int] S)=ParamPol:Psi_irr(p,S)

set dual_integral (Param p) = InnerClass:
  dual_integral(p.inner_class,p.infinitesimal_character)

set find (Block B, (KGBElt x, KGBElt y)) = int:
  first(#B,(int i) bool: let (r,s)=element(B,i) in x=r and y=s)

set find_reps_in_Cells ([[int]] W_cells, Param t) = int:
  let y = dual_KGB(t,dual_integral(t))
  then index = find(block(real_form(t),real_form(y)) ,(x(t),y))
  in last(#W_cells,(int i)bool: any(for v in W_cells[i] do v=index od))

{Compute minimal elements of parabolics having equivalent KGB elements in the distinguished fiber}
set x_min_parabolic_in_dis_fiber_Step1 (RealForm G,[int] H)=([KGBElt]):
  for x in distinguished_fiber(G) do x_min(parabolic_by_wt(ratvec:H,x)) od.
  (sort_by(#@KGBElt))

{Step 2 of above}
set x_min_parabolic_in_dis_fiber (RealForm G,[int] H)=([KGBElt]):
let V=x_min_parabolic_in_dis_fiber_Step1(G,H)
then rv=[KGBElt]:[V[0]]
then i=1
in while i<#V do
				if V[i]=V[i-1]
					then i:=i+1
				else
					rv#:=V[i]; i:=i+1
				fi
				od; rv

set closed_real_parabolics_associated_to_a_lambda( RealForm G, [int] H)=[Parabolic]:
let V=x_min_parabolic_in_dis_fiber(G, H)
then rv=[Parabolic]:[]
in for x in V do rv#:=parabolic_by_wt_verbose(H/1, x) od; rv

set H_GL( int n) = [int]:
let v=2*rho(GL(n,R)) in (ratvec_as_vec(v))


set H_Sp(int n) = [int]:
assert(is_even(n), "Need an even input");
let v=2*rho(Sp(n,R)) in (ratvec_as_vec(v))

set H_SO( int n) = [int]:
let rv=[int]:[]
in	if n!=1
	then
	rv:=ratvec_as_vec(2*rho(SO(n,0)))
	fi; rv

{given a pair of odd integers p,q, compute the H(p,q) of type SO(p+q+1)}
set H_SO_pair( int n, int m) = [int]:
let v=2*rho(Sp(n-1,R))
then w=2*rho(Sp(m-1,R))
then rv=ratvec_as_vec(v##w##[0])
in (reverse_sort(rv))



{Compute the one dimensionals on a given Levi}
set one_dimensionals( RealForm G)=([Param]):
let B=block_of(trivial(G))
then rv=[Param]:[]
in for t in B do
				if is_finite_dimensional(t) and dimension(t)=1
					then rv#:=t
				fi
			od;rv

set ind_one_dim_from_parabolic (Parabolic Q) = ([Param]):
let L=Levi(Q)
then B=one_dimensionals(L)
in for t in B do first_param(theta_induce_irreducible(t, real_form(Q))) od

set closed_real_parabolics_associated_to_a_lambda( RealForm G, [int] H)=[Parabolic]:
let V=x_min_parabolic_in_dis_fiber(G, H)
then rv=[Parabolic]:[]
in for x in V do rv#:=parabolic_by_wt_verbose(H/1, x) od; rv


set dual_Cell( Block B, int Cell)= int:
let Bd=dual(B)
then G=real_form(B)
then Gd=real_form(Bd)
then W_Cells_Gd=[[int]]: for (cell,) in W_cells(Bd) do cell od
then W_Cells_G=[[int]]:  for (cell,) in W_cells(B) do cell od
then (x,y)=element(Bd, W_Cells_Gd[Cell][0])
then w=(y,x)
then k=find(B, w)
in last(#W_Cells_G,(int i)bool: find(W_Cells_G[i], k)<0)


set cells_with_given_AV ([int] O, [[int]] AV_Cells)=(int, [int]):
let rv=0
then rv1=[int]:[]
in for i:#AV_Cells do if AV_Cells[i]=O then rv:=rv+1; rv1#:=i fi od; (rv, rv1)


set subset([int] V, [int] W)=bool:
  all(#V,(int i) bool: find(W,V[i])>=0)

set delete_sub_vector( [int] Q, [int] W) = [int]:
  let predicate = is_member(Q) in
  ## for w in W do if predicate(w) then [] else [w] fi od



{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%% For Dual Group of type Bn %%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}

set good_KGB_C (RealForm G) = [KGBElt]:
let rho_GL = rho(GL(rank(G))) in
if G.is_equal_rank
then ##
  for x in distinguished_fiber(G) do if rho_GL=rho_K(x) then [x] else [] fi od
else []
fi


set if_same_len_B([int] R, [int] S)=([int], [int]):
let R=sort(R)
then S=sort(S)
in if #R<=#S then R:=null(#S-#R+1)##R fi; (sort(R),sort(S))


set orbit_from_W_rep_B (Hn_rep W)=[int]:
let (R,S)=W
then (R,S)=if_same_len_B(R,S)
then R1=for i:#R do 2*(R[i]+i)+1 od
then S1=for i:#S do 2*(S[i]+i) od
then rv=sort(R1##S1)
in for i:#rv do rv[i]:=rv[i]-i od; reverse(rv)


set AV_for_given_block_B (Block B)=[[int]]:
let W_Cells=[[int]]:(for (cell,) in W_cells(B) do cell od)
in for i:#W_Cells do orbit_from_W_rep_B (wrep(B, W_Cells[i]))od

{Given a nilpotent orbit of type Bn compute the H(O)}

set orbit_H_Bn_Step1(RealForm G, [int] p)=([int], [int]):
let A=frequencies(p)
then p=rank(G)
then rv=[int]:[]
in for i:#A do
		if is_even(i) and i!=0
			then
				while A[i]>0
				do rv##:=H_GL(i);
				A[i]:=A[i]-2 od
		elif is_odd(i) and i!=1
		    then
			if A[i]>1
				then
				while A[i]>1
				do rv##:=H_GL(i);
					A[i]:=A[i]-2 od
				fi
		fi
		od;(rv,repeat_parts(A))


set orbit_H_Bn (RealForm G, [int] r) = [int]:
let (rv,)=orbit_H_Bn_Step1(G, r)
then (,P)=orbit_H_Bn_Step1(G, r)
then A=frequencies(P)%2 {get rid of all the 1's in the partition}
then P=sort(repeat_parts(A)) {now partition has parts with multiplicity 1}
then p=rank(G)
then i=1
then rv=rv##H_Sp(P[0]-1)
in
while i<#P
	do
	rv##:=H_SO_pair(P[i], P[i+1]);
	 i:=i+2
	od;rv##null(p-#rv)


set induced_from_closed_parabolics_B(RealForm G, [int] P)=[Param]:
let H=dominant(G, orbit_H_Bn(G, P))
then V=closed_real_parabolics_associated_to_a_lambda(G,H)
in for v in V do first_param(real_induce_irreducible(trivial(Levi(v)), G)) od


set real_forms_of_complex_orbit_as_Reps_B (Block B, [int] P)=[Param]:
let Gd=real_form(dual(B))
then T=induced_from_closed_parabolics_B(Gd,P)
then Bd=dual(B)
then W_Cells=[[int]]:(for (cell,) in W_cells(Bd) do cell od)
then AV_Cells=AV_for_given_block_B(Bd)
then rv=[Param]:[]
in for t in T do
				if find_reps_in_Cells(W_Cells, t)!= -1 and AV_Cells[find_reps_in_Cells(W_Cells, t)]=P
				then if find(rv,t)= -1 then rv#:=t fi fi
				od; rv

set real_forms_of_complex_orbit_as_Cells_B (Block B, [int] P)=[int]:
let Bd=dual(B)
then Gd=real_form(Bd)
then T=induced_from_closed_parabolics_B(Gd,P)
then W_Cells=[[int]]:(for (cell,) in W_cells(Bd) do cell od)
then AV_Cells=AV_for_given_block_B(Bd)
then rv=[int]:[]
in for t in T do
				if find_reps_in_Cells(W_Cells, t)!= -1 and AV_Cells[find_reps_in_Cells(W_Cells,t)]=P
				then if find(rv,find_reps_in_Cells(W_Cells, t))=-1 then rv#:=find_reps_in_Cells(W_Cells, t)  fi fi
				od; rv


set all_Cells_with_Aq_Lambda_B(Block B, [int] P)=[int]:
let Bd=dual(B)
then Gd=real_form(Bd)
then W_Cells=[[int]]:(for (cell,) in W_cells(Bd) do cell od)
then T=real_forms_of_complex_orbit_as_Reps_B (B, P)
then H=dominant(Gd, orbit_H_Bn(Gd, P))
then R= for t in T do parabolic_by_wt_verbose(H/1, x(t)) od
then S= for r in R do ind_one_dim_from_parabolic(r) od
then rv=[int]:[]
in for s in S do for i:# s do if find(rv, find_reps_in_Cells(W_Cells, s[i])) = -1 then if find_reps_in_Cells(W_Cells, s[i]) !=-1 then rv#:=find_reps_in_Cells(W_Cells, s[i]) fi fi od od; rv



set all_Cells_with_Aq_Lambda_as_Real_forms_B(Block B, [int] P)=[[int]]:
let Bd=dual(B)
then Gd=real_form(Bd)
then AV_Cells=AV_for_given_block_B(Bd)
then T=real_forms_of_complex_orbit_as_Reps_B (B, P)
then H=dominant(Gd, orbit_H_Bn(Gd, P))
then R= for t in T do parabolic_by_wt_verbose(H/1, x(t)) od
then S= for r in R do ind_one_dim_from_parabolic(r) od
then rv=[int]:[]
then rv1=[[int]]:[]
then W_Cells=[[int]]:(for (cell,) in W_cells(Bd) do cell od)
in for s in S do
				for i:# s do
				if find(rv, find_reps_in_Cells(W_Cells, s[i])) = -1 then if find_reps_in_Cells(W_Cells, s[i]) !=-1 then rv#:=find_reps_in_Cells(W_Cells, s[i]) fi fi
						od; rv1#:=rv; rv:=[]
				od; rv1



set Unipotent_Algo_test_B (Block B, [int] P)=bool:
let Bd=dual(B)
then AV_Cells=AV_for_given_block_B(Bd)
then k=#all_Cells_with_Aq_Lambda_B (B, P)
then (n,)=cells_with_given_AV (P, AV_Cells)
in n=k



set Unipotent_Packet_B(Block B, [int] P)=[[Param]]:
let rv=[Param]:[]
then rv1=[[Param]]:[]
then Bd=dual(B)
then Gd=real_form(Bd)
then G=real_form(B)
then W_Cells_G=[[int]]:(for (cell,) in W_cells(B) do cell od)
then b=for i:#B do element(B,i) od
then H=dominant(Gd, orbit_H_Bn(Gd, P))
then S=singular_simple_indices(G, H)
then V=all_Cells_with_Aq_Lambda_as_Real_forms_B(B, P)
in for v in V do
				for i:#v do
				for t in W_Cells_G[dual_Cell (B, v[i])]
				do if subset(S, tau_complement(parameter(b[t]))) then rv#:=first_param(Psi(parameter(b[t]), S)) fi od
				od; rv1#:=rv; rv:=[]
				od; rv1



set Missing_Parts_of_Uni_Packet_B(Block B, [int] P)=[[Param]]:
let rv=[Param]:[]
then rv1=[[Param]]:[]
then Bd=dual(B)
then Gd=real_form(Bd)
then G=real_form(B)
then W_Cells_G=[[int]]:(for (cell,) in W_cells(B) do cell od)
then b=for i:#B do element(B,i) od
then AV_Cells_Gd=AV_for_given_block_B(Bd)
then H=dominant(Gd, orbit_H_Bn(Gd, P))
then S=singular_simple_indices(G, H)
then (,W)=cells_with_given_AV (P, AV_Cells_Gd)
then Q=sort(all_Cells_with_Aq_Lambda_B (B, P))
then W=delete_sub_vector(Q,W)
in for w in W do
				for t in W_Cells_G[dual_Cell (B, w)]
						do if subset(S,tau_complement(parameter(b[t]))) then rv#:=first_param(Psi(parameter(b[t]), S)) fi
						od; rv1#:=rv; rv:=[]
				od; rv1




set Unipotent_information_B (Block B, [int] P)=
let U=Unipotent_Packet_B(B, P)
then missing=Missing_Parts_of_Uni_Packet_B(B,P)
then all_missing=[Param]:[]
then ()=for params in missing do all_missing##:=params od
then ()=prints("all_missing=",all_missing)
then G=real_form(B)
then ()=prints("There are", " ", #U ," ", " real forms (and hence Unipotent packets) of", " ", P, " ","in this block")
then ()=prints("The packets are")
in for i:#U do prints("Packet" ," ", i);
{print_stable(U[i]);
print_stable(U[i]##all_missing);}
for v in U[i] do prints(v, ",", "The LKT is", " ", highest_weights(LKT(v), good_KGB_C(G)[0]))od od;

if Unipotent_Algo_test_B(B,P) then prints("This is the complete set of Unipotent representations in this block")
								else prints("These packets are not complete, and, the missing representations are");
								for t in Missing_Parts_of_Uni_Packet_B(B,P) do prints(t) od
								fi






{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%% For Dual Group of type Cn %%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}


set if_same_len_C([int] R, [int] S)=([int], [int]):
let R=sort(R)
then S=sort(S)
in if #R<#S then R:=null(#S-#R)##R  elif #R>#S then S:=null(#R-#S)##S fi; (sort(R),sort(S))


set orbit_from_W_rep_C (Hn_rep W)=[int]:
let (R,S)=W
then (R,S)=if_same_len_C(R,S)
then R1=for i:#R do 2*(R[i]+i)+1 od
then S1=for i:#S do 2*(S[i]+i) od
then rv1=sort(R1##S1)
then rv=[int]:[]
in for i:#rv1 do if rv1[i]-i!=0 then rv#:=rv1[i]-i fi od; reverse(rv)


set AV_for_given_block_C (Block B)=[[int]]:
let W_Cells=[[int]]:(for (cell,) in W_cells(B) do cell od)
in for i:#W_Cells do orbit_from_W_rep_C(wrep(B, W_Cells[i]))od



{Compute the H in the Sl2 triple associated to the orbit P}
set orbit_H_Cn( RealForm G, [int] P)=[int]:
let A=frequencies(P)
then p=rank(G)
then rv=[int]:[]
then k=0
then s=0
in for i:#A do
		if is_even(i) and i!=0
			then
				while A[i]>0
				do rv##:=H_SO(i+1);
				A[i]:=A[i]-1 od
		elif is_odd(i) and i!=1
		    then
			while A[i]> 0
			do rv##:=H_GL(i); A[i]:=A[i]-2 od
		fi
		od;rv##null(p-#rv)



set induced_from_closed_parabolics_C(RealForm G, [int] P)=[Param]:
let H=dominant(G, orbit_H_Cn(G, P))
then V=closed_real_parabolics_associated_to_a_lambda(G, H)
in for v in V do first_param(real_induce_irreducible(trivial(Levi(v)), G)) od



set real_forms_of_complex_orbit_as_Reps_C (Block B, [int] P)=[Param]:
let Gd=real_form(dual(B))
then T=induced_from_closed_parabolics_C(Gd,P)
then Bd=dual(B)
then W_Cells=[[int]]:(for (cell,) in W_cells(Bd) do cell od)
then AV_Cells=AV_for_given_block_C(Bd)
then rv=[Param]:[]
in for t in T do
				if find_reps_in_Cells(W_Cells, t)!= -1 and AV_Cells[find_reps_in_Cells(W_Cells, t)]=P
				then if find(rv,t)= -1 then rv#:=t fi fi
				od; rv

set real_forms_of_complex_orbit_as_Cells_C (Block B, [int] P)=[int]:
let Bd=dual(B)
then Gd=real_form(Bd)
then T=induced_from_closed_parabolics_C(Gd,P)
then W_Cells=[[int]]:(for (cell,) in W_cells(Bd) do cell od)
then AV_Cells=AV_for_given_block_C(Bd)
then rv=[int]:[]
in for t in T do
				if find_reps_in_Cells(W_Cells, t)!= -1 and AV_Cells[find_reps_in_Cells(W_Cells,t)]=P
				then if find(rv,find_reps_in_Cells(W_Cells, t))=-1 then rv#:=find_reps_in_Cells(W_Cells, t)  fi fi
				od; rv






set all_Cells_with_Aq_Lambda_C(Block B, [int] P)=[int]:
let Bd=dual(B)
then Gd=real_form(Bd)
then W_Cells=[[int]]:(for (cell,) in W_cells(Bd) do cell od)
then T=real_forms_of_complex_orbit_as_Reps_C (B, P)
then H=dominant(Gd, orbit_H_Cn(Gd, P))
then R= for t in T do parabolic_by_wt_verbose(H/1, x(t)) od
then S= for r in R do ind_one_dim_from_parabolic(r) od
then rv=[int]:[]
in for s in S do for i:# s do if find(rv, find_reps_in_Cells(W_Cells, s[i])) = -1 then if find_reps_in_Cells(W_Cells, s[i]) !=-1 then rv#:=find_reps_in_Cells(W_Cells, s[i]) fi fi od od; rv



set all_Cells_with_Aq_Lambda_as_Real_forms_C(Block B, [int] P)=[[int]]:
let Bd=dual(B)
then Gd=real_form(Bd)
then AV_Cells=AV_for_given_block_C(Bd)
then T=real_forms_of_complex_orbit_as_Reps_C(B, P)
then H=dominant(Gd, orbit_H_Cn(Gd, P))
then R= for t in T do parabolic_by_wt_verbose(H/1, x(t)) od
then S= for r in R do ind_one_dim_from_parabolic(r) od
then rv=[int]:[]
then rv1=[[int]]:[]
then W_Cells=[[int]]:(for (cell,) in W_cells(Bd) do cell od)
in for s in S do
				for i:# s do
				if find(rv, find_reps_in_Cells(W_Cells, s[i])) = -1 then if find_reps_in_Cells(W_Cells, s[i]) !=-1 then rv#:=find_reps_in_Cells(W_Cells, s[i]) fi fi
						od; rv1#:=rv; rv:=[]
				od; rv1



set Unipotent_Algo_test_C (Block B, [int] P)=bool:
let Bd=dual(B)
then AV_Cells=AV_for_given_block_C(Bd)
then k=#all_Cells_with_Aq_Lambda_C (B, P)
then (n,)=cells_with_given_AV (P, AV_Cells)
in n=k



set Unipotent_Packet_C(Block B, [int] P)=[[Param]]:
let rv=[Param]:[]
then rv1=[[Param]]:[]
then Bd=dual(B)
then Gd=real_form(Bd)
then G=real_form(B)
then W_Cells_G=[[int]]:(for (cell,) in W_cells(B) do cell od)
then b=for i:#B do element(B,i) od
then H=dominant(Gd, orbit_H_Cn(Gd, P))
then S=singular_simple_indices(G, H)
then V=all_Cells_with_Aq_Lambda_as_Real_forms_C(B, P)
in for v in V do
				for i:#v do
						for t in W_Cells_G[dual_Cell (B, v[i])]
						do if subset(S, tau_complement(parameter(b[t]))) then rv#:=first_param(Psi(parameter(b[t]), S)) fi od
						od; rv1#:=rv; rv:=[]
				od; rv1



set Missing_Parts_of_Uni_Packet_C(Block B, [int] P)=[[Param]]:
let rv=[Param]:[]
then rv1=[[Param]]:[]
then Bd=dual(B)
then Gd=real_form(Bd)
then G=real_form(B)
then W_Cells_G=[[int]]:(for (cell,) in W_cells(B) do cell od)
then b=for i:#B do element(B,i) od
then AV_Cells_Gd=AV_for_given_block_C(Bd)
then H=dominant(Gd, orbit_H_Cn(Gd, P))
then S=singular_simple_indices(G, H)
then (,W)=cells_with_given_AV (P, AV_Cells_Gd)
then Q=sort(all_Cells_with_Aq_Lambda_C (B, P))
then W=delete_sub_vector(Q,W)
in for w in W do
				for t in W_Cells_G[dual_Cell (B, w)]
						do if subset(S,tau_complement(parameter(b[t]))) then rv#:=first_param(Psi(parameter(b[t]), S)) fi
						od; rv1#:=rv; rv:=[]
				od; rv1




set Unipotent_information_C (Block B, [int] P)=
let U=Unipotent_Packet_C(B, P)
then G=real_form(B)
then ()=prints("There are", " ", #U ," ", " real forms (and hence Unipotent packets) of", " ", P, " ","in this block")
then ()=prints("The packets are")
in for i:#U do prints("Packet" ," ", i); for v in U[i] do prints(v)od od;
if Unipotent_Algo_test_C(B,P) then prints("This is the complete set of Unipotent representations in this block")
								else prints("These packets are not complete, and, the missing representations are");
								for t in Missing_Parts_of_Uni_Packet_C(B,P) do prints(t) od
								fi






{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%% For Dual Group is either of type Bn or Cn %%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}
{%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%}






set is_valid_pair(Block B, [int] P)=bool:
let G=real_form(B)
then k=type_number(G)
then rv=bool:false
in if k=1 then if is_valid("C",P) then rv:=true fi elif k=2 then if is_valid("B",P) then rv:=true fi fi;rv




set Unipotent_Packets(Block B, [int] P)=[[Param]]:
assert(is_valid_pair(B,P),"The block and the complex orbit are not compatible");
let G=real_form(B)
then k=type_number(G)
then rv=[[Param]]:[]
in if k=1 then rv:=Unipotent_Packet_C(B,P) elif k=2 then rv:=Unipotent_Packet_B(B,P) fi;rv


set Unipotent_information (Block B, [int] P)=
assert(is_valid_pair(B,P),"The block and the complex orbit are not compatible");
let G=real_form(B)
then k=type_number(G)
in if k=1 then Unipotent_information_C(B,P) elif k=2 then Unipotent_information_B(B,P) fi

forget Psi@(Param,[int])

