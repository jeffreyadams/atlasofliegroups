< basic {for infinitesimal character}
< aff_cube.at {for local_FPP_extrema}
< FPP_faces_herm.at {for unitarity tests}
< hash.at {for hash tables}
< FPP_localDirac.at { for |unipotents_to_hash| }
{<K_types.at {for branch_std}}
set red_coroots(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then pos_co = G.poscoroots
    then theta = p.x.involution
    in for alphav@j in pos_co
       do let gammaj = gamma*alphav
       	  in if is_integer(gammaj) and gammaj.>
       	     then if alphav*theta = -alphav and Cayley((G.posroots)[j],p) != p
   	     	  then [alphav] {parity real root}
	       	  else []
	       	  fi
	     elif ((theta*(gamma.numer))*alphav).<
	     then [alphav] {complex}
	     else []
	     fi
       od.##

set move_theta(WeylElt w) = ((KGBElt,ratvec) -> (KGBElt,ratvec)):
 (KGBElt x, ratvec lambda) (KGBElt,ratvec):
 let G = w.root_datum, x1 = cross(w,x) {added to next 7.29.25}
 then lambda_shift = rho_C(G,x1.involution) - w*rho_C(G, x.involution)
  then rhow = rho(G) - w*rho(G)
 then p1 = parameter(x1, w*lambda + rhow - lambda_shift, 0*lambda)
 in (p1.x, p1.lambda)


{should require number of -alphav*theta >= number of alphav}
set red_coroots(KGBElt x) = [vec]:
    let G = x.real_form,  theta = x.involution
    then rho = G.rho, pos_co = G.poscoroots
    in for alphav@j in pos_co
       do if (alphav*theta*rho).< and poscoroot_index(G, -alphav*theta) >= j
       	  then [alphav]
	  else []
	  fi
       od.##

{need to study reducibility along av at int values
from int to int inclusive}
set range(KGBElt x, ratvec lambda, vec av) = (int, int):
    let lfe = local_FPP_extrema(x,lambda)
    then vals = for w in lfe do av*w od
    in (floor(min(vals)), ceil(max(vals)))

set ranges(KGBElt x, ratvec lambda) = [(vec, int, int)]:
    let rc = red_coroots(x)
    then lfe = local_FPP_extrema(x,lambda)
    in for av in rc
       do let vals = for w in lfe do av*w od
       	  in (av, floor(min(vals)), ceil(max(vals)))
       od

{root datum from all coroots restricting to A as multiple of av}
set Levix(KGBElt x, vec av) = (RealForm,KGBElt):
    let G = x.real_form, theta = x.involution
    then pos_r = G.posroots, pos_co = G.poscoroots
    then av_min_th = av - av*theta
    then js = for bv@j in pos_co
    	      do if rank([av_min_th,bv-bv*theta]) <=1
	      	 then [j]
		 else []
		 fi
	      od.##
     then two_rho_L = sum(G.rank, for j in js do pos_r[j] od)
     then min_js = for j in js
     	  	   do if pos_co[j]*two_rho_L = 2
		      then [j]
		      else []
		      fi
		   od.##
     then rdL = root_datum(mat: for j in min_js do pos_r[j] od,
     	      		   mat: for j in min_js do pos_co[j] od, true)
     {then tfL = x.torus_factor - G.rho_check + rdL.rho_check}
     then xL = KGB_elt(rdL, theta, x.torus_factor)
    in (real_form(xL),xL)

set simpTimer = int:0

{assume roots for L are rational linearly closed in roots for G, and
L-positive are G-positive; conjugate L to standard Levi}
set simplifier_old(RootDatum L, RootDatum G) = WeylElt:
    if L.semisimple_rank = G.semisimple_rank
    then return W_elt(G,[int]: [])
    fi;
    let start = elapsed_ms(), SLv = L.simple_coroots, SL = L.simple_roots
    then big = G {we'll shrink to smaller and smaller Levis
    	       	 containing a conjugate of L}
    then S = G.simple_roots, M = id_mat(G.rank)
    {then () = prints("original SLv = ",SLv)}
    in while big.semisimple_rank > L.semisimple_rank
       do let k = first(for a in big.simple_roots do find(SL,a).< od)
       	  then xiLs = L.fundamental_weights, SLv = L.simple_coroots
          then PZL(ratvec v) = v - sum(rank(L), for xiL@j in xiLs
	       		       	   		do (SLv[j]*v)*xiL
						od)
       	  then z0 = PZL(dominant(L,big.simple_roots[k]))
	  {necessarily a positive root in big not in L, \pm roots in L.
	   Cuts out a nonstd Levi containing L}
    	  then (w,z1) = from_dominant(big,z0) {wz1 - z0}
	  {z1 cuts out std Levi new in big containing w^{-1}L}
	  in M:=M*matrix(w); {carries new L to original L}
    	     let (,new) = Levi_of_weight(big,z1)
	     in big:=new;
	     {prints("z0 = ",z0, ", z1 = ",z1,", w = ", w,", big simplev = ",big.simple_coroots);}
	     L := matrix(w.inverse)*L;
	     SL := L.simple_roots{;
	     prints("SLv = ",L.simple_coroots)}
       od;
       simpTimer+:= elapsed_ms() - start;
       W_elt(G,M)

{Result (w,y). Assume is L is Levi of nonstandard REAL P at x,
carried by w standard real at y}
set simplifier_theta_old(RootDatum L, KGBElt x) = (WeylElt, KGBElt): {NEED KGBELT??}
    if L.semisimple_rank = x.root_datum.semisimple_rank
    then return (W_elt(x.real_form,[int]: []),x)
    fi;
    let start = elapsed_ms(), G = x.real_form
    then xL = KGB_elt(L, x.involution, x.torus_factor)
    then thetamin = (1 - x.involution), M = id_mat(G.rank)
    then big = G {we'll shrink to smaller and smaller standard real Levis
    	       	 containing a conjugate of L}
    then {S = G.simple_roots,} M = id_mat(G.rank)
   {then () = prints("original SLv = ",SLv)}
    in while big.semisimple_rank > L.semisimple_rank
       do let xiLs = L.fundamental_weights, SLv = L.simple_coroots
       	  then APZL(ratvec v) = thetamin*(v - sum(rank(L), for xiL@j in xiLs
	       		       	   		do (SLv[j]*v)*xiL
						od))
	  then j = first(for a in big.simple_roots do (APZL(a)).!= od)
	  then (w,cent1) = from_dominant(big, APZL(big.simple_roots[j]))
	  {cent1 cuts out std Levi new in big containing w^{-1}L}
	  {then () = prints("(w,cent1) = ", w, "  ",cent1)}
	  then Mwinv = matrix(w.inverse)
	  then () = x:=cross(Mwinv,x)
	  then xbig = KGB_elt(big, x.involution,x.torus_factor)
	  then () = big:= Levi_by_wt(cent1,xbig)
	  in M:=M*matrix(w); {carries new L to original L}
	     L := Mwinv*L;
	     xL := KGB_elt(L,x.involution,x.torus_factor);
	     thetamin := 1-x.involution
	     {prints("x = ",x, ", big simplev = ",
	     		 big.simple_coroots, "SLv = ",L.simple_coroots)}
	     {prints("SLv = ",L.simple_coroots)}
       od;
       simpTimer+:= elapsed_ms() - start;
       (W_elt(G,M),x)

set old_simplifier_theta_flag = false

{Result (w,xi). Assume is L is Levi of nonstandard REAL P at x,
carried by w from standard real at y}
set simplifier_theta(RootDatum L, KGBElt x) = (WeylElt, KGBElt):
    if old_simplifier_theta_flag then return simplifier_theta_old(L,x) fi;
    let start = elapsed_ms(), rd = x.root_datum,  thetamin = (1 - x.involution)
    then S = for a in L.simple_coroots do coroot_index(rd,a) od
    then T = maximize_Levi(rd,S)
    then A = Levi_simple_coroots(rd,T), k = #S
    then wt_theta = thetamin*((A,vector(rd.semisimple_rank,(int i)int:#(i>=k))/1).required_solution.numer)
    {is this really guaranteed to define L?}
    then (w,wt_theta_dom) = from_dominant(rd,wt_theta)
    then x1 = cross(w.inverse,x)
    in simpTimer+:= elapsed_ms() - start;
       (w,x1)

set old_simplifier_flag = true

set simplifier(RootDatum L, RootDatum G) = WeylElt:
    if old_simplifier_flag then return simplifier_old(L, G) fi;
    let start = elapsed_ms(), SL = for alpha in L.simple_roots do root_index(G,alpha) od
    then (w,) = from_standard_Levi(G,SL)
    in simpTimer+:= elapsed_ms() - start;
       w

set standardize(KGBElt x, ratvec lambda, vec av) = (KGBElt, ratvec, vec):
    let (L,) = Levix(x,av), G = x.real_form
    then (y,x1) = simplifier_theta(L,x)
    {then () = prints("y = ",y)}
    in let (x1m,lambda1) = move_theta(y.inverse)(x,lambda)
        {then () = assert(x1m = x1,"problem with move in standardize")
       then () = assert(1*parameter(x,lambda,0*lambda) = 1*parameter(x1,lambda1,0*lambda1),
       	       	 "problem with x1 and lambda1 in standardize")}
       in (x1,lambda1, av*y)

set old_standardize(KGBElt x, ratvec lambda, vec av) = (KGBElt, ratvec, vec):
    let (L,) = Levix(x,av), G = x.real_form
    then y = if old_simplifier_flag
    	     then simplifier_old(L,G)
	     else simplifier(L,G)
	     fi
    {then () = prints("y = ",y)}
    in let (x1,lambda1) = move_theta(y.inverse)(x,lambda)
    in (x1,lambda1, av*y)


{parameter on nonstandard Levi L}
set pL(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    let (L,xL) = Levix(x,av), G = x.real_form, theta = x.involution
    then m = coroot_index(G,av) + #G.posroots, {lambdaL = lambda-rho(G) + rho(L)}
    	 lambda_shift = -rho(G) +rho(L) + rho_C(G,theta) - rho_C(L,theta)
    then a = roots(G)[m], lambdaL = lambda + lambda_shift
    then nu1 = (a-theta*a)
    then wt = av*nu1, shift = av*(lambdaL+theta*lambdaL)/2
    in parameter(xL,lambdaL, ((t-shift)/wt)*nu1)
{inf char = (lambdaL + theta*lambdaL)/2 + (t-shift)/wt)*nu1)}
{value on av is shift + (t-shift)}
{shift adjusts so pairing of av with L infl char is t}

{ rep on minimal real Levi through complex coroot av}
set pL1(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    let (x1,lambda1, av1) = standardize(x,lambda,av)
    in pL(x1,lambda1,av1,t)


set std_quo(Param p) = ParamPol:
    1*p-character_formula(1*p)

set ind_quo(KGBElt x, ratvec lambda, vec av, rat t) = KTypePol:
    let {pL = pL(x,lambda,av,t)
    {then () = assert(av*(pL.infinitesimal_character) = t, "bad pL")}
    then} pL1 = pL1(x,lambda,av,t)
    {then () = assert(dominant(x.real_form,pL.infinitesimal_character) =
    	 dominant(x.real_form, pL1.infinitesimal_character),"bad infl char for pL1")
    then () = assert(#character_formula(1*pL) = (#character_formula(1*pL1)),
    "bad char for pL1")}
    in real_induce_standard(K_type_pol(std_quo(pL1)), x.real_form)

{given a reducibility coroot av, take generic point on hyperplane
av*gamma = t, corresponding Q(t) = std/Langlands quotient, and ask
whether Q(t) has terms of height at most HT}
{works for HT < 0, telling whether Q(t).!=}
set test(KGBElt x, ratvec lambda, vec av, rat t, int HT) = bool:
    let Q = ind_quo(x, lambda, av, t)
    {then QL = std_quo(pL(x,lambda,av,t))
    then () = assert((Q.=) = (QL.=),"bad induction!")}
    in to_ht(Q,HT).!=

{works for HT < 0, giving all reducibility points}
{omitting the singular real roots gives 2 too many unitary in Sp(6,R)}
set red_points(KGBElt x, ratvec lambda, vec av,int HT) = [int]:
    let (m,M) = range(x,lambda,av), thetapl = x.involution+1
    in for j:M-m+1 from m
       do if test(x,lambda,av,j,HT) {or ((av*thetapl).= and j.=)}
       	  then [j]
	  else []
	  fi
       od.##

set red_points(KGBElt x,ratvec lambda, int HT) = [[int]]:
    for av in red_coroots(x)
    do red_points(x,lambda,av,HT)
    od

{record location of rat t with respect to strictly increasing
sequence of M ints red_pts by integer from -1 to 2M.
0 means red_pts is empty; 0 means smaller than any, 2M means larger than any;
2j}
set location_old([int] red_pts, rat t) = int:
    if (#red_pts).= then 0
    else let j0 = first(for red in red_pts do red >= t od)
       	 in if j0 = -1 then 2*(#red_pts)
	    elif t = red_pts[j0] then 2*j0 + 1
	    else 2*j0
	    fi
    fi

{ range [0..2*#a]; a[i]=r -> 2i+1; even number: r absent }
set location([int] a,rat t) = int:
    let loc = locate_sorted(a,ceil(t)) { first with |a[loc]>=t| }
    in if loc=#a
       then 2*loc
       elif a[loc]=t then 2*loc+1
       else 2*loc
       fi

set location_old(KGBElt x, ratvec lambda, vec av,int HT, rat t) = int:
    let rp = red_points(x,lambda,av,HT)
    in if (#rp).= then 0
       else let j0 = first(for red in rp do red >= t od)
       	    in if j0 = -1 then 2*(#rp) {t > all red pts}
	       elif t = rp[j0] then 2*j0 + 1 {t = rep pt j0}
	       else 2*j0 {t between pts j0-1 and j0}
	       fi
        fi

set location(KGBElt x, ratvec lambda, vec av,int HT, rat t) = int:
    let rp = red_points(x,lambda,av,HT)
    in location(rp,t)

set thruple(KGBElt x, ratvec lambda,int HT, ratvec gamma) = vec:
    for av in red_coroots(x)
    do location(x,lambda,av,HT,av*gamma)
    od

set thruple([vec] red_co, [[int]] red_pts, ratvec gamma) = vec:
    for av@j in red_co
    do location(red_pts[j],av*gamma)
    od

set is_def_thr(vec base_thr, vec def_thr) = bool:
    (def_thr != base_thr) and
    all(for x@j in base_thr
        do @bool: (is_odd(x) and def_thr[j] = x)
	   	  or(is_even(x) and abs(def_thr[j] - x) <= 1)
	od)

set is_def_intervals(vec thruple) = [[int]]:
    for x in thruple
    do [int]:
       if is_odd(x) then [x]
       else [x-1,x,x+1]
       fi
    od

set is_def_testers(vec thruple) = [(int -> bool)]:
    for x in thruple
    do (int y) bool:
       if is_odd(x)
       then x=y
       else let d = x-y
       	    in d=1 or d=0 or d=-1
       fi
    od

set is_def_tester(vec thruple) = (vec -> bool):
    (vec v): bool:
    let def_tests = is_def_testers(thruple)
    in all(for y@i in v do @bool: def_tests[i](y) od)

set is_def_testerB(vec thruple) = (vec -> bool):
    (vec v): bool:
    let def_ints = is_def_intervals(thruple)
    in all(for def_int@i in  is_def_intervals(thruple)
       	   do @bool: is_member(def_int)(v[i])
	   od)

set def_thruples_time = int:0
{can replace each even coord 2*m with 2*m\pm 1}
set def_thruples(vec thruple) = [vec]:
    let coord_defs = for x in thruple
    	      	do [int]:
		   if x.=
		   then [0,1]
		   elif is_even(x)
		   then [-1,0,1]
		   else [0]
		   fi
		od
    then defs = all_words(coord_defs) {includes unwanted term [0,...,0]}
    then answer = for def in defs do thruple + def od
    in answer

set taus(KGBElt x, ratvec lambda, int HT) = [KType]:
    monomials(branch(K_type_pol(parameter(x,lambda,0*lambda)),HT))

set pos_tester(KGBElt x, ratvec lambda,int HT,ratvec gamma) = bool:
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE_old(q,HT) od)
       	   {is_unitary_to_ht_big_SIMPLE(q,HT) od)}
    {then Form_p = sum(G, for q in monomials(1*p)
       	      do hermitian_form_irreducible_to_ht_big_SIMPLE(q,HT)
	      {hermitian_form_irreducible_to_ht(q,HT)}
	      od)
    in is_pure(Form_p)}

{compute vectors of size 2 giving [index of K-char, #Langlands quotients]}
set extra_coord_flag = false

{try deforming loc to a known one}
set deform_loc_flag = false

{try deforming loc to a known nonunitary one}
set deform_nonu_flag = true

set use_deform_steve() = void:
    extra_coord_flag:=true;
    deform_loc_flag:=true

set use_deform_nonu_steve() = void:
    extra_coord_flag:=false;
    deform_nonu_flag:=true

{USE Kpol_hash defined in FPP_faces_geom.at}
set pos_tester_Kchar(KGBElt x, ratvec lambda,int HT,ratvec gamma) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in if extra_coord_flag
       then (all (for q in qs do @bool: {is_unitary_to_ht_big_SIMPLE_old(q,HT) od),}
       	    	      	      	 	is_unitary_to_ht_big_SIMPLE(q,HT) od),
       	    [Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT))),#qs])
       else (all (for q in qs do @bool: {is_unitary_to_ht_big_SIMPLE_old(q,HT) od),[])}
       	    	      	      	 	 is_unitary_to_ht_big_SIMPLE(q,HT) od),[])
       fi

set Kchar_vec(KGBElt x, ratvec lambda, int HT, ratvec gamma) = vec:
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in if extra_coord_flag
       then [Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT))),#qs]
       else []
       fi
{
{record values of thruple for (x,lambda,HT}
set xlHT_vecHash = make_vec_hash()

{one answer for each vec in xlHT_vecHash}
set xlHT_bools = [bool]:[]

set xlHT_clear() = void:
    xlHT_vecHash.clear();
    xlHT_bools:=[]
}

{how often deforming location succeeds in proving unitary}
set hash_def_true_count = int: 0

{how often deforming location succeeds in proving nonunitary}
set hash_def_false_count = int: 0

set report_def_thruples() = void:
    prints(print_time_string(def_thruples_time)," to find deformed thruple candidates.");
    prints("Found ",hash_def_true_count," deformations proving unitarity (to height), ",
    	   hash_def_false_count," deformations proving nonunitarity (to height).")

set_type
[steve_hash_table =
( ( -> ) clear {clear the table}
  , ( -> int) real_form_size {number of real forms included}
  , ( -> vec) xlhash_sizes {for every real form, the number of pairs(x,lambda)}
  , ( -> vec) K_type_sizes {number of KTypes for each real form}
  , ((KGBElt, ratvec) -> vec) heights {list of heights to which reducibility has been studied}
  , ((KGBElt, ratvec, int) -> (int, int, int)) indices {rfnum, xlnum, htnum}
  , ((KGBElt, ratvec, int) -> vec_hash) vecHash {hash table of location vecs known}
  , ((KGBElt, ratvec, int) -> [[int]]) red_points {for each reducibility coroot, list of reducibility points}
  , ((KGBElt, ratvec, int) -> [bool]) postests {size vecHash.size(), listing unitarity results}
  , ((KGBElt, ratvec, int) -> [vec]) extra_coords {size vecHash.size():
  [Kchar #, #LQs] if extra_coord_flag, [] else}
  , ((int, int, int, int) -> bool) indexed_postest {known rfnum, xlnum, htnum, vecnum}
  , ((int, int, int, ratvec) -> bool) partly_indexed_postest
  , ((KGBElt, ratvec, int, ratvec) -> bool) postest {test param(x,lambda,last_arg) for unitarity to ht}
  , ((KGBElt, ratvec, int, ratvec) -> vec) extra_coord {test param(x,lambda,last_arg) for unitarity to ht}
  , ((int, int, int, ratvec) -> vec) indexed_thruple {known rfnum, xlnum, htnum}
  , ((KGBElt, ratvec, int, ratvec) -> vec) thruple {loc vec: (x,lambda,gamma) to HT}
)
]

set make_steve_hash() = steve_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then K_type_hashes = [KType_hash] : [] {one for each real form; list of KTs considered}
    then xlhashes = [xlambda_hash]: [] {one for each real form}
    then heights = [[vec]]:[] {one for each entry in each xlhash}
    then vechashes = [[[vec_hash]]]:[] {one for each height for each entry in each xlhash}
    then redpoints = [[[[int]]]]:[] {for each entry in xlhash and height, [int] = bitmap of reducibility
    	 	     		  points for each reducibility coroot}
    then statuses = [[[[bool]]]]:[] {one [bool] for each vechash}
    then charvecs = [[[[vec]]]]: [] {one [vec] for each vechash; possibly [index of K_char, #LQs]}
    then clearSH() = void:
    	 let () = real_form_hash.clear()
	 then () = K_type_hashes:=[]
	 then () = xlhashes:=[]
	 then () = heights:=[]
	 then () = vechashes:=[]
	 then () = statuses:=[]
	 then () = charvecs:=[]
	 then () = redpoints := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then	K_type_hashes #:= make_KType_hash();
		        xlhashes #:= make_xlambda_hash();
			heights   #:= ([vec]:[]);
			vechashes #:= ([[vec_hash]]:[]);
			statuses  #:= ([[[bool]]]:[]);
			redpoints #:= ([[[int]]]:[]);
			charvecs  #:= ([[[vec]]]:[]);
			assert(real_form_hash.size() = #K_type_hashes and #xlhashes = #K_type_hashes and
	       	    	   #heights = #xlhashes and #vechashes = #heights and #statuses = #heights and
			   #redpoints = #heights, "steve_hash damaged on adding real form")
	    	   fi
	  in i
    then add_K_type(KType mu) = (int, int): {real form index, K type index}
   	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf,1*mu))}
	 {then KTYPENUM = K_type_hashes[rfnum].size()}
	 in (rfnum, K_type_hashes[rfnum].match(mu))
    then add_xl(KGBElt x, ratvec lambda) = (int,int): {real form index, xlhash index}
    	 let rfnum = add_real_form(x.real_form)
	 then XLNUM = xlhashes[rfnum].size()
	 then xlnum = xlhashes[rfnum].match(x,lambda)
	 in if xlnum = XLNUM {new (x,lambda)}
	    then heights[rfnum]#:=null(0);
	    { add empty list of lists of reducibility points for the new height}
	    	 redpoints[rfnum] #:= ([[int]]:[]);
		 vechashes[rfnum]#:=([vec_hash]:[]);
		 statuses[rfnum]#:=([[bool]]:[]);
		 charvecs[rfnum]#:=([[vec]]:[])
	    fi;
	    (rfnum,xlnum)
    then add_xlht(KGBElt x, ratvec lambda, int HT) = (int,int,int): {real form index, xlhash index, HT index}
    	 let (rfnum,xlnum) = add_xl(x,lambda)
	 then J = #heights[rfnum][xlnum], htnum = find(heights[rfnum][xlnum],HT)
	 in if htnum.< {new HT}
	    then let hrxl = heights[rfnum][xlnum], {[[int]]}
	    	     hr = heights[rfnum]
	    	 then () = hrxl#:= HT
		 then () = hr[xlnum]:=hrxl
		 then () = heights[rfnum]:=hr
		 then rprxl = redpoints[rfnum][xlnum], rpr = redpoints[rfnum]
		 then () = rprxl #:= for list in red_points(x,lambda,HT) do to_bitset(list) od
		      {add a new [int]}
		 then () = rpr[xlnum]:=rprxl
		 then () = redpoints[rfnum]:=rpr
		 then vhsxl = vechashes[rfnum][xlnum], vhsr = vechashes[rfnum]
		 then () = vhsxl #:= make_vec_hash()
		 		      {add a new vec_hash for new height}
		 then () = vhsr[xlnum]:=vhsxl
		 then () = vechashes[rfnum]:=vhsr
		 then statusxl = statuses[rfnum][xlnum], statusr = statuses[rfnum]
		 then () = statusxl #:= ([bool]:[]) { for this height }
		 then () = statusr[xlnum]:=statusxl
		 then () = statuses[rfnum]:=statusr
		 then charvecxl = charvecs[rfnum][xlnum], charvecr = charvecs[rfnum]
		 then () = charvecxl #:= ([vec]:[]) { for this height }
		 then () = charvecr[xlnum]:=charvecxl
		 then () = charvecs[rfnum]:=charvecr
		 in htnum:= J
	    fi;
	    (rfnum,xlnum,htnum)
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}

    then SHthruple_plain_indexed(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then (boo,v) = pos_tester_Kchar(x, lambda, HT, gamma)
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_plain(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int, int, int, int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
	 in (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_indexed(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then good_def_nums = for defloc@m in vechashes[rfnum][xlnum][htnum].list()[:vecnum]
			     		     do if def_tester(defloc)
					     	then [m]
						else []
						fi
				 	     od.##
			then () = def_thruples_time+:= elapsed_ms() - start
			then Kcv = Kchar_vec(x,lambda,HT,gamma)
			then (boo,v) = if any(for def_num in good_def_nums
			     	       	      do @bool: not statuses[rfnum][xlnum][htnum][def_num]
					      od)
				       then hash_def_false_count+:=1;
				       	    (false, Kcv)
				       elif deform_loc_flag and
				       	    any(for def_num in good_def_nums
			     	       	      	do @bool: statuses[rfnum][xlnum][htnum][def_num]
						   	  and (charvecs[rfnum][xlnum][htnum][def_num] = Kcv)
					      	od)
				       then hash_def_true_count+:=1;
				       	    (true, Kcv)
				       else pos_tester_Kchar(x, lambda, HT, gamma)
				       fi
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum

    then SHthruple(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int,int,int,int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
	 in if (deform_loc_flag or deform_nonu_flag)
	    then (rfnum, xlnum, htnum, SHthruple_indexed(rfnum, xlnum, htnum, gamma))
	    else (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	    fi
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
{      then check() = void:
      	   assert(real_form_hash.size() = xlhashes.size(),"wrong rf/xl hash sizes");
      	   for rf@rfnum in real_form_hash.list()
	   do assert(xlhashes[rfnum].size() = #heights[rfnum], "wrong xl/hts sizes");
	      for xl@xlnum in xlhashes[rfnum]
	      do assert(#heights[rfnum][xlnum] = }
      in
  ( ( -> ): {clear} clearSH
  , ( -> int): {real_form_size} @int: real_form_hash.size()
  , ( -> vec): {xlhash_sizes} @vec: for xlhash in xlhashes do xlhash.size() od
  , ( -> vec): {K_type_sizes} @vec: for Khash in K_type_hashes do Khash.size() od
  , ((KGBElt, ratvec) -> vec): {heights} (KGBElt x, ratvec lambda) vec:
    let (rfnum, xlnum) = add_xl(x,lambda)
    in heights[rfnum][xlnum]
  , ((KGBElt, ratvec, int) -> (int, int, int)): {indices} (KGBElt x, ratvec lambda, int HT) (int, int, int):
    add_xlht(x,lambda,HT)
  , ((KGBElt, ratvec, int) -> vec_hash): {vecHash} (KGBElt x, ratvec lambda, int HT) vec_hash:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in vechashes[rfnum][xlnum][htnum]
  , ((KGBElt, ratvec, int) -> [[int]]): {red_points} (KGBElt x, ratvec lambda, int HT) [[int]]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in for M in redpoints[rfnum][xlnum][htnum]
       do set_bit_positions(M)
       od
  , ((KGBElt, ratvec, int) -> [bool]): {postests} (KGBElt x, ratvec lambda, int HT) [bool]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in statuses[rfnum][xlnum][htnum]
  , ((KGBElt, ratvec, int) -> [vec]): {extra_coords} (KGBElt x, ratvec lambda, int HT) [vec]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in charvecs[rfnum][xlnum][htnum]
  , ((int, int, int, int) -> bool): {indexed_postest} (int rfnum, int xlnum, int htnum, int vecnum) bool:
    statuses[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, ratvec) -> bool): {partly_indexed_postest} (int rfnum, int xlnum, int htnum,
    ratvec gamma) bool:
    let vecnum = SHthruple_indexed(rfnum, xlnum, htnum, gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec) -> bool): {postest} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) bool:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec) -> vec): {extra_coord} (KGBElt x, ratvec lambda,
    int HT, ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in charvecs[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, ratvec) -> vec): {indexed_thruple} (int rfnum, int xlnum, int htnum,
    ratvec gamma) vec:
    let vecnum = SHthruple_indexed(rfnum, xlnum, htnum, gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec) -> vec): {thruple} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  )
)

set steve_hash = make_steve_hash()

{takes local data and low global faces and computes local vertices, imposing
hermitian, pos on LKTs, and pos to HT. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
set localFD_1SteveU\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1SteveU to ht ",HT)
    fi;
    let G = x.real_form, start = elapsed_ms(), (rfnum, xlnum, htnum) = steve_hash.indices(x, lambda, HT)
    then length = #(Lvd.list)
    then freq = max(length\10,1)
    then answer = [vec]:
    	 if steve_tilde_flag
	 then for v@j in Lvd.list
       	      ~do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	     	  fi;
	     	  let p = parameter(x,lambda,v)
	     	  in if not is_hermitian(p)
	     	     then []
	     	     elif steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, v)
	     	     then [[j]]
	     	     else []
	     	     fi
	       od.## {list of j for which vertex j is a candidate}
          else for v@j in Lvd.list
       	       do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	     	  fi;
	     	  let p = parameter(x,lambda,v)
	     	  in if not is_hermitian(p)
	     	     then []
	     	     elif steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, v)
	     	     then [[j]]
	     	     else []
	     	     fi
	       od.## {list of j for which vertex j is a candidate}
	   fi

    then () = answer:= if steve_tilde_flag
    	      	       then for v in answer ~do v od
		       else answer
		       fi
    in if fund_face_verbose
       then prints("Found ",#answer," vertices to ht ",HT," in time ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
       fi;
       answer
)

{takes local data and low global faces and local vertices and computes local edges, imposing
hermitian, pos to HT.}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_2SteveU\
( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_2Steve")
    fi;
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then () = if #LF0 = 0
    	      then return []
	      fi
    then FixedList = [int]: for v in LF0
    	 	     	    do let j = v[0]
			       in if j < #Perm2.fixed
			       	  then [j]
				  else break
				  fi
			    od.##
    then f = #FixedList, f0 = #Perm2.fixed
    then TranList = [int]: for v in LF0[f:] do v[0] od {all entries are f0+ index in Perm2.trans}
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number in Lvd
		      	  of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is Perm2.trans[m + f0]}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0 {midpoint of v[2:] is a local vertex}
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT at [",k,",",n,"]!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	   {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
     then length = #Edges
     then freq = max(length\10,1)
     then (rfnum, xlnum, htnum) = steve_hash.indices(x, lambda, HT)
     then LF1 = [FaceVertsIndex]:
	  if steve_tilde_flag
	  then for v@j in Edges
	       ~do if fund_face_verbose and red_count_flag and (j%freq).=
	       	   then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	     	   fi;
	     let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     in if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       	then []
	       	elif steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,v))
	       	then if extra_coord_flag
		     then [v##steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))]
	       	    	 {then prints("v = ",v, "extras = ", steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v)));}
		     else [v]
		     fi
	        else []
	       	fi
	      od.##
	  else for v@j in Edges
	       do if fund_face_verbose and red_count_flag and (j%freq).=
	       	   then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	     	   fi;
	     let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     in if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       	then []
	       	elif steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,v))
	       	then if extra_coord_flag
		     then [v##steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))]
	       	    	 {then prints("v = ",v, "extras = ", steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v)));}
		     else [v]
		     fi
	        else []
	       	fi
	      od.##
	   fi
    {then () = if time_verbose
    	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    {then () = FD12bzTime +:= elapsed_ms() - start}
    then tail = if (#LF1).=
    	      	then 0
		else {prints("LF1 = ",LF1);}
		     #(LF1[0]) - 2
		fi
    then () = LF1:= if sort_LFD_flag
       	      	    then sort(G, Lvd, [LF1], tail)[0]
       	      	    else LF1
       	      	    fi
    {then LF1 = if steve_tilde_flag
    	       then for v in LF1 ~do v od
	       else LF1
	       fi}
    in if fund_face_verbose
       then prints("After localFD_2Steve, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]");
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
       fi;
       LF1
)


{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces that are unitary to ht HT; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_lookDownSteveU\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t) = [[FaceVertsKHash]]:
(   {if face_verbose
    then prints(new_line,"start localFD_lookDownSteveU, b = ",b,", t = ",t)
    fi;}
    let G = x.real_form, start=elapsed_ms(), (rfnum, xlnum, htnum) = steve_hash.indices(x, lambda, HT)
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2; dim is the new bigger dim}
    	      do LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],0)
	      	    	       	   in [vec]:
				      for (actual,locs) in acts {vec of size dim+1, coords of subs}
	       	    	      	      do if steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,actual))
				      	 then [actual]
					 else []
					 fi

			              od.##);
		if fund_face_verbose
		then prints("After dim ",dim,", found face counts ",for list in LFKH do #list od,
		       " at time ",print_time_string(elapsed_ms() - start))
		fi
	 	od{dim:t-#LFKH}
    then () = LFKH := if sort_LFD_flag
    	      	      then sort(G, Lvd, LFKH)
		      else LFKH
		      fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt_lookDownSteve to dim ",t-1,
			"; face counts = ", for list in LFKH do #list od);
		   prints("vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	      fi
    in LFKH
)

{impose unitary to HT on a collection of faces}
set test_Steve(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH) =
    [[FaceVertsKHash]]:
    let start = elapsed_ms(), (rfnum, xlnum, htnum) = steve_hash.indices(x, lambda, HT)
    in for LF in LFKH
    do let freq = max(#LF\10,1)
       then answerd =
       	   for v@j in LF
       	   do if (j%freq).= and fund_face_verbose
	      then prints("at face #",j," of ",#LF," at time ",print_time_string(elapsed_ms() - start),
	      "; vecHash size = ", steve_hash.vecHash(x,lambda,HT).size())
	      fi;
	      if steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,v))
       	      then if extra_coord_flag
	      	   then [v##steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))]
	      	   else [v]
		   fi
	      else []
	      fi
       	   od.##
	then () = if fund_face_verbose
	     	  then prints("old size = ",#LF,", new size = ",#answerd, ", vecHash size = ",
	     	       steve_hash.vecHash(x,lambda,HT).size())
		  fi
	in answerd
    od

set show_steve_flag = false

{all faces unitary to HT}
set localFD_SteveUtoHT(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    let start = elapsed_ms(), LF0 = localFD_1SteveU(x,lambda,HT, Lvd)
    then LF = [LF0,  localFD_2SteveU(x,lambda,HT,Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("edges and verts to ",HT," = ",LF)
	      fi
    then answer = localFD_lookDownSteveU(x,lambda,HT,Lvd,LF,2,rank(x.involution - 1)+1)
    in if fund_face_verbose
       then prints("For HT = ",HT, ", time for localFD_SteveU: ",
       	    		print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
       fi;
       answer

set localFD_SteveUtoHT(KGBElt x, ratvec lambda, int HT) = [[FaceVertsKHash]]:
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_SteveUtoHT(x, lambda, HT, Lvd, Perm2)

{all faces unitary}
set localFD_SteveUB(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1)
    then one_ht = hts[edge_offset]
    then LF0 = localFD_1SteveU(x,lambda,hts[0], Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height ",hts[0], " = ",LF0)
	      fi
    then () = LF0 := test_Steve(x,lambda,one_ht,Lvd,[LF0])[0]
    then () = if show_steve_flag
    	      then prints("LF0 to height ",one_ht, " = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,one_ht,Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 to height ",one_ht," = ",LF[1])
	      fi
    then () = LF:=test_Steve(x,lambda,-1,Lvd,LF)
   { then hts = if #LF[1].>=3
   then next_heights(p0,rank(x.involution - 1)+1)}
    then () = LF:=localFD_lookDownSteveU(x,lambda,one_ht,Lvd,LF,2,rank(x.involution - 1)+1)
    then answer = test_Steve(x,lambda,-1,Lvd,LF)
    in if fund_face_verbose
       then prints("For unitarity, time for localFD_SteveUB: ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,-1).size());
	    prints("unitary face counts = ",for list in answer do #list od);
	    if show_steve_flag
    	    then prints("unitary LF = ",LF)
	    fi
       fi;
       answer

set localFD_SteveUB(KGBElt x, ratvec lambda) = [[FaceVertsKHash]]:
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_SteveUB(x, lambda, Lvd, Perm2)

set steve_B_flag = true

{all faces unitary}
set localFD_SteveU(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    if steve_B_flag
    then return localFD_SteveUB(x, lambda, Lvd, Perm2)
    fi;
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then h0 = next_height(p0)
    then LF0 = localFD_1SteveU(x,lambda,h0, Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height h0 = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,h0,Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 to height h0 = ",LF[1])
	      fi
    then () = LF:=test_Steve(x,lambda,-1,Lvd,LF)
   { then hts = if #LF[1].>=3
    	       then next_heights(p0,rank(x.involution - 1)+1)}
    then answer = localFD_lookDownSteveU(x,lambda,-1,Lvd,LF,2,rank(x.involution - 1)+1)
    in if fund_face_verbose
       then prints("For unitarity, time for localFD_SteveU: ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,-1).size());
	    if show_steve_flag
    	    then prints("unitary LF = ",LF)
	    fi
       fi;
       answer

set localFD_SteveU(KGBElt x, ratvec lambda) = [[FaceVertsKHash]]:
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_SteveU(x, lambda, Lvd, Perm2)

{all faces up to dim D >=2 unitary; need hts of size at least D +2 }
set localFD_SteveUstep(KGBElt x, ratvec lambda, [int] hts, int D) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), theta = x.involution
    then r = rank(theta-1)
    then (Lvd,Perm2) = LPm_table.LPm_entry(x.inner_class, theta, ratvec_as_vec(lambda+theta*lambda))
    {then hts = next_heights(parameter(x,lambda,0*lambda),r+2)}
    then LF0 = localFD_1SteveU(x,lambda,hts[0], Lvd)
    then () = LF0 := test_Steve(x,lambda,hts[1],Lvd,[LF0])[0]
    then LF = [LF0,localFD_2SteveU(x,lambda,hts[1],Lvd,Perm2,LF0)]
    then () = LF:=test_Steve(x,lambda,hts[2],Lvd,LF)
    then d = int:1
    then () = while (d<=D-1) and #LF~[0] > d+1
    	 do LF := localFD_lookDownSteveU(x,lambda,hts[d+1],Lvd,LF,d+1,d+2);
	    LF := test_Steve(x,lambda,hts[d+2],Lvd,LF);
	    if fund_face_verbose
	    then prints("To dim ",d+1,", ht ",hts[d+2], ", time for localFD_SteveUstep: ",
	    	print_time_string(elapsed_ms() - start));
       	    	prints("face sizes ",for list in LF do #list od,", vecHash size = ",
	    	steve_hash.vecHash(x,lambda,hts[d+2]).size())
	    fi;
	    d +:= 1
	 od
    in LF

{all faces unitary to some pretty big height}
set localFD_SteveUstep(KGBElt x, ratvec lambda) = [[FaceVertsKHash]]:
    let D = rank(x.involution -1)
    then hts = next_heights(parameter(x,lambda,0*lambda),D+2)
    in localFD_SteveUstep(x,lambda,hts,D)

set first_offset = int:0
{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}
set localFD_Steve2(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1), extra_coord_hold = extra_coord_flag
    then () = if edge_offset= first_offset then extra_coord_flag:=true fi
    then LF0 = localFD_1SteveU(x,lambda,hts[first_offset], Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height ",hts[first_offset]," = ",LF0)
	      fi
    then () = extra_coord_flag :=true
    then () = LF0:= test_Steve(x,lambda,hts[edge_offset],Lvd,[LF0])[0]
    then () = if show_steve_flag
    	      then prints("LF0 with extra to height ",hts[edge_offset]," = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,hts[edge_offset],Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 with extra to height ",hts[edge_offset]," = ",LF[1])
	      fi
    then () = if fund_face_verbose
    	      then prints("edge/vert counts to height ",hts[edge_offset], " = ",
	      	   for list in LF do #list od,"; time  = ",print_time_string(elapsed_ms() - start))
	      fi
    in extra_coord_flag:=extra_coord_hold; LF

set localFD_Steve2(KGBElt x, ratvec lambda) = [[FaceVertsKHash]]:
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_Steve2(x, lambda, Lvd, Perm2)

set tester(RealForm G) = void:
let start=elapsed_ms()
then () = test_verbose:=false
then () = test_slightly_verbose:=false
then () = time_verbose:=false
then () = unipotents_to_hash(G,big_unitary_hash.uhash(G))
then () = for x in KGB(G)
     	  do if twist(x)=x
	     then for lambda in FPP_lambdas(x)
   	     	  do let p0 = parameter(x,lambda,0*lambda)
      	     	     in if is_pos_on_LKTs(p0)
      	 	     	then let LF = localFD_Steve2( x, lambda), Lvd = Lvd(x,lambda)
	      		     then () = local_test_GEO_hash_steve_end(x, lambda, Lvd, LF,
	      	 	     	big_unitary_hash.uhash(G))
	      		in ()
	 	   	fi
   	     	   od
	      fi
	 od
in prints("total time = ",print_time_string(elapsed_ms() - start)," to find ",
   		 big_unitary_hash.uhash(G).size()," unitary reps.")

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_steve(KGBElt x, ratvec lambda, LocalVertexData Lvd, Param_hash Uhash,
    (Param->bool) fancy_tester) = [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do Uhash.match(p)
	       	      od;
	       	      return(all)
	       fi
    then () = test_string:= " using local_test_GEO_hash_steve"
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then LF2 = localFD_Steve2(x,lambda)
    in local_test_GEO_hash_steve_end(x,lambda, Lvd, LF2, Uhash)

