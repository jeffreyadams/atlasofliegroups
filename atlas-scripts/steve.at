< basic {for infinitesimal character}
< aff_cube.at {for local_FPP_extrema}
< FPP_faces_herm.at {for unitarity tests}
< hash.at {for hash tables}
< FPP_localDirac.at { for |unipotents_to_hash| }
{<K_types.at {for branch_std}}
set red_coroots(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then pos_co = G.poscoroots
    then theta = p.x.involution
    in for alphav@j in pos_co
       do let gammaj = gamma*alphav
       	  in if is_integer(gammaj) and gammaj.>
       	     then if alphav*theta = -alphav and Cayley((G.posroots)[j],p) != p
   	     	  then [alphav] {parity real root}
	       	  else []
	       	  fi
	     elif ((theta*(gamma.numer))*alphav).<
	     then [alphav] {complex}
	     else []
	     fi
       od.##

set move_theta(WeylElt w) = ((KGBElt,ratvec) -> (KGBElt,ratvec)):
 (KGBElt x, ratvec lambda) (KGBElt,ratvec):
 let G = w.root_datum, x1 = cross(w,x) {added to next 7.29.25}
 then lambda_shift = rho_C(G,x1.involution) - w*rho_C(G, x.involution)
  then rhow = rho(G) - w*rho(G)
 then p1 = parameter(x1, w*lambda + rhow - lambda_shift, 0*lambda)
 in (p1.x, p1.lambda)


{should require number of -alphav*theta >= number of alphav}
set red_coroots(KGBElt x) = [vec]:
    let G = x.real_form,  theta = x.involution
    then rho = G.rho, pos_co = G.poscoroots
    in for alphav@j in pos_co
       do if (alphav*theta*rho).< and poscoroot_index(G, -alphav*theta) >= j
       	  then [alphav]
	  else []
	  fi
       od.##

{need to study reducibility along av at int values
from int to int inclusive}
set range(KGBElt x, ratvec lambda, vec av) = (int, int):
    let lfe = local_FPP_extrema(x,lambda)
    then vals = for w in lfe do av*w od
    in (floor(min(vals)), ceil(max(vals)))

set ranges(KGBElt x, ratvec lambda) = [(vec, int, int)]:
    let rc = red_coroots(x)
    then lfe = local_FPP_extrema(x,lambda)
    in for av in rc
       do let vals = for w in lfe do av*w od
       	  in (av, floor(min(vals)), ceil(max(vals)))
       od

{root datum from all coroots restricting to A as multiple of av}
set Levix(KGBElt x, vec av) = (RealForm,KGBElt):
    let G = x.real_form, theta = x.involution
    then pos_r = G.posroots, pos_co = G.poscoroots
    then av_min_th = av - av*theta
    then js = for bv@j in pos_co
    	      do if rank([av_min_th,bv-bv*theta]) <=1
	      	 then [j]
		 else []
		 fi
	      od.##
     then two_rho_L = sum(G.rank, for j in js do pos_r[j] od)
     then min_js = for j in js
     	  	   do if pos_co[j]*two_rho_L = 2
		      then [j]
		      else []
		      fi
		   od.##
     then rdL = root_datum(mat: for j in min_js do pos_r[j] od,
     	      		   mat: for j in min_js do pos_co[j] od, G.prefers_coroots)
     {then tfL = x.torus_factor - G.rho_check + rdL.rho_check}
     then xL = KGB_elt(rdL, theta, x.torus_factor)
    in (real_form(xL),xL)

{given a matrix of roots and a matrix of coroots, choose a maximal set of orthogonal ones}
set orthogonal(mat roots, mat coroots) = ([vec],[vec]):
    let r = #(roots.^) {number of columns in root matrix}
    then entry(int p, int q) = int: 0
    then oroots = [vec]:[], perproots = [vec]: roots
    then ocoroots = oroots, perpcoroots = [vec]: coroots
    in while (#perproots).>
       do let tester = perproots~[0], cotester = perpcoroots~[0]
       	  {then () = prints("tester = ",tester,", cotester = ",cotester)}
       	  in oroots#:= tester;
       	  ocoroots#:= cotester;
	  perproots := for alpha in perproots do if (alpha*cotester).= then [alpha] else [] fi od.##;
	  perpcoroots := for av in perpcoroots do if (tester*av).= then [av] else [] fi od.##
       od;
       (oroots, ocoroots)

{given a matrix of roots and a matrix of coroots, choose sets of positive ones}
set pos_choice(mat roots, mat coroots) = ([vec],[vec]):
    let (O,cO) = orthogonal(roots,coroots)
    then levels = [int]: for alpha in roots
    	 	  	 do first(for cotester in cO
			    	  do (alpha*cotester).!=
				  od)
			 od
    in (for alpha@j in roots
       do if (alpha*cO[levels[j]]).>
       	  then [alpha]
	  else []
	  fi
       od.##,
       for av@j in coroots
       do if (av*O[levels[j]]).>
       	  then [av]
	  else []
	  fi
       od.##)

{given a matrix of roots and a matrix of coroots, sets of simple ones}
set simp_choice(mat roots, mat coroots) = ([vec],[vec]):
    if #roots = 0 then return ([],[]) fi;
    let (PR,cPR) = pos_choice(roots,coroots)
    then tworhocheck = sum(#cPR[0],cPR)
    then simplejs = for alpha@j in PR
       	 	    do if alpha*tworhocheck = 2
       	  	       then [j]
	  	       else []
	  	       fi
       		    od.##
    in (for j in simplejs
       	do PR[j]
	od,
	for j in simplejs
       	do cPR[j]
	od)



{assume x.involution has maximal -1 eigenspace a; construct restricted root datum on a}
set res_stuff(KGBElt x) = ([vec],[vec]):
    let theta = x.involution, G = x.real_form
    then () = assert(@:rank(1-theta) = split_rank(G), "x was not on max split Cartan")
    then T_lower_star = mat: eigen_lattice(theta.^,-1)
    then res_coroot_hash = make_vec_hash()
    then res_root_hash = make_vec_hash()
    then () = for av@j in G.coroots
    	      do let avres = av - av*theta
		 in if avres = 2*av
		    then let resav= required_solution(T_lower_star,av) {real coroots}
		    	 in res_coroot_hash.match(resav);
		    	    res_root_hash.match(G.roots[j]*T_lower_star)
		    elif avres.= or is_coroot(G,avres) {omit imaginary and half of real}
		    then -1
		    else let resav= required_solution(T_lower_star,avres) {complex coroots}
		    	 in res_coroot_hash.match(resav);
			    res_root_hash.match(G.roots[j]*T_lower_star)
		    fi
	       od
     in (res_root_hash.list(), res_coroot_hash.list())

set res_root_old_flag = false {the hashed version below is just uniformly faster}

set res_root_datum_old(KGBElt x) = RootDatum:
    let (roo,coroo) = res_stuff(x)
    then (sroo,scoroo) = simp_choice(roo,coroo)
    in root_datum(sroo, scoroo, x.real_form.prefers_coroots)

set res_root_datum = (KGBElt -> RootDatum):
    let rfhash = make_RealForm_hash()
    then KGBhashes = [KGBElt_hash]: [] {one hash for each real form}
    then answerhash = make_RootDatum_hash()
    then answer_indices = [vec]: [] {one list of rd indices for each real form,
    	 		  	     size = KGBhash[i].size()}
    in (KGBElt -> RootDatum): (KGBElt x) RootDatum:
       if res_root_old_flag then return res_root_datum_old(x) fi;
       let theta = x.involution, rd = x.root_datum
       in if ((1+theta)*(rd.simple_roots)).=
       {x.real_form.derived.split_rank = x.real_form.semisimple_rank}
       then let T_lower_star = mat: eigen_lattice(theta.^,-1)
       	    in return root_datum(
	       for alpha in rd.simple_roots
       	       do alpha*T_lower_star
	       od,
	       for av in rd.simple_coroots
	       do required_solution(T_lower_star,av)
	       od,
	       rd.prefers_coroots
	       )
       fi;
       let I = rfhash.size()
       then i = rfhash.match(x.real_form)
       then () = if i = I {haven't seen G before}
       	       	 then KGBhashes #:=make_KGBElt_hash();
	       	      answer_indices #:= null(0)
	  	 fi
       then J = KGBhashes[i].size(), K = answerhash.size()
       then j = KGBhashes[i].match(x)
       then () = if j = J {haven't seen x before}
       	       	 then let (roo,coroo) = res_stuff(x)
    		      then (sroo,scoroo) = simp_choice(roo,coroo)
    		      then k = answerhash.match(root_datum(sroo, scoroo, x.real_form.prefers_coroots))
		      in answer_indices[i] #:= k
		 fi
       in answerhash.index(answer_indices[i][j])

set res_root_datum(RealForm G) = RootDatum:
    res_root_datum(x_open(G))

set simpTimer = int:0

{assume roots for L are rational linearly closed in roots for G, and
L-positive are G-positive; conjugate L to standard Levi}

{Result (w,xi). Assume is L is Levi of nonstandard REAL P at x,
carried by w from standard real Levi at z1}
set simplifier_theta(RootDatum L, KGBElt x) = (WeylElt, KGBElt):
    {if old_simplifier_theta_flag then return simplifier_theta_old(L,x) fi;}
    let start = elapsed_ms(), rd = x.root_datum,  thetamin = (1 - x.involution)
    then S = for a in L.simple_coroots do coroot_index(rd,a) od
    then T = maximize_Levi(rd,S)
    then A = (Levi_simple_coroots(rd,T)), k = #S
    then wt_theta = thetamin*((A,vector(rd.semisimple_rank,(int i)int:#(i>=k)*2^i)/1).required_solution.numer)
    {The powers of two are just a garbage way to make it usually work. Don't know how actually to
    fix it.}
    then (w,wt_theta_dom) = from_dominant(rd,wt_theta)
    then x1 = cross(w.inverse,x)
    in simpTimer+:= elapsed_ms() - start;
       (w,x1)

{Result (w,xi). Assume is L is Levi of nonstandard REAL P at x,
carried by w from standard real Levi at z1}
{w needs to account for difference between xL and xLo??}
set simplifier_theta_res(RealForm L, KGBElt x) = (WeylElt, KGBElt):
    {if old_simplifier_theta_flag then return simplifier_theta_old(L,x) fi;}
    let start = elapsed_ms(), rd = x.root_datum,  thetamin = (1 - x.involution), G = x.real_form
    then xL = inverse_embed_KGB(x,L)
    then xLo = x_open(L)
    then xo = embed_KGB(xLo,G)
    then thetao  = xo.involution
    then M = eigen_lattice(thetao.^,-1)
    then rdo = res_root_datum(xo)
    then rdoL = res_root_datum(xLo)
    then S = for a in rdoL.simple_coroots do coroot_index(rdo,a) od
    then T = maximize_Levi(rdo,S)
    then A = (Levi_simple_coroots(rdo,T)), k = #S
    then wt_theta_res = ((A,vector(rdo.semisimple_rank,(int i)int:#(i>=k))/1).required_solution.numer)
    then wt_thetao = (1-thetao)*(required_solution(M.^, wt_theta_res)) {guaranteed to cut out L}
    then (w,) = from_dominant(G,wt_thetao)
    then {x1 = cross(w.inverse,xo),} L1 = (w.inverse)*L
    then xL1 = KGB(L1, xL.number)
    then x1 = embed_KGB(xL1,G)
    in simpTimer+:= elapsed_ms() - start;
       (w,x1)

set simplifier_res_flag = true

set standardize(KGBElt x, ratvec lambda, vec av) = (KGBElt, ratvec, vec):
    let (L,) = Levix(x,av), G = x.real_form
    then (y,x1) = if simplifier_res_flag
    	 	  then simplifier_theta_res(L,x)
		  else simplifier_theta(L,x)
		  fi
    {then () = prints("y = ",y)}
    in let (x1m,lambda1) = move_theta(y.inverse)(x,lambda)
        {then () = assert(x1m = x1,"problem with move in standardize")
       then () = assert(1*parameter(x,lambda,0*lambda) = 1*parameter(x1,lambda1,0*lambda1),
       	       	 "problem with x1 and lambda1 in standardize")}
       in (x1,lambda1, av*y)

{parameter on nonstandard Levi L}
set pL(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    let (L,xL) = Levix(x,av), G = x.real_form, theta = x.involution
    then m = coroot_index(G,av) + #G.posroots, {lambdaL = lambda-rho(G) + rho(L)}
    	 lambda_shift = -rho(G) +rho(L) + rho_C(G,theta) - rho_C(L,theta)
    then a = roots(G)[m], lambdaL = lambda + lambda_shift
    then nu1 = (a-theta*a)
    then wt = av*nu1, shift = av*(lambdaL+theta*lambdaL)/2
    in parameter(xL,lambdaL, ((t-shift)/wt)*nu1)
{inf char = (lambdaL + theta*lambdaL)/2 + (t-shift)/wt)*nu1)}
{value on av is shift + (t-shift)}
{shift adjusts so pairing of av with L infl char is t}

{ rep on minimal real Levi through complex coroot av}
set pL1(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    {if steve_old_flag then return pL1_old(x, lambda, av, t) fi;}
    let (x1,lambda1, av1) = standardize(x,lambda,av)
    in pL(x1,lambda1,av1,t)

set std_quo(Param p) = ParamPol:
    1*p-character_formula(1*p)

set steve_new_flag = true

set ind_quo_new(KGBElt x, ratvec lambda, vec av, rat t) = KTypePol:
    let pL = pL(x,lambda,av,t)
    {then () = assert(dominant(x.real_form,pL.infinitesimal_character) =
    	 dominant(x.real_form, pL1.infinitesimal_character),"bad infl char for pL1")
    then () = assert(#character_formula(1*pL) = (#character_formula(1*pL1)),
    "bad char for pL1")}
    in K_type_pol(std_quo(pL))

set ind_quo(KGBElt x, ratvec lambda, vec av, rat t) = KTypePol:
    if steve_new_flag
    then return ind_quo_new(x,lambda,av,t)
    fi;
    let pL1 = pL1(x,lambda,av,t)
    {then () = assert(dominant(x.real_form,pL.infinitesimal_character) =
    	 dominant(x.real_form, pL1.infinitesimal_character),"bad infl char for pL1")
    then () = assert(#character_formula(1*pL) = (#character_formula(1*pL1)),
    "bad char for pL1")}
    in real_induce_standard(K_type_pol(std_quo(pL1)), x.real_form)


set to_ht_G(RealForm G, KTypePol QL, int HT) = KTypePol:
    if HT.< then return QL fi;
    sum(QL.real_form,
	for c@tauL in QL
    	do if dominant(G,parameter(tauL).d_lambda)*(G.two_rho_check) <= HT
	   then c*tauL
	   else 0*tauL
	   fi
	od)

set test_new(KGBElt x, ratvec lambda, vec av, rat t, int HT) = bool:
    let QL = ind_quo_new(x,lambda,av,t)
    in to_ht_G(x.real_form, QL,HT).!=

{given a reducibility coroot av, take generic point on hyperplane
av*gamma = t, corresponding Q(t) = std/Langlands quotient, and ask
whether Q(t) has terms of height at most HT}
{works for HT < 0, telling whether Q(t).!=}
set test(KGBElt x, ratvec lambda, vec av, rat t, int HT) = bool:
    if steve_new_flag
    then return test_new(x,lambda,av,t,HT)
    fi;
    let Q = ind_quo(x, lambda, av, t)
    {then QL = std_quo(pL(x,lambda,av,t))
    then () = assert((Q.=) = (QL.=),"bad induction!")}
    in to_ht(Q,HT).!=

set red_points_time = int:0

set red_points_new(KGBElt x, ratvec lambda, vec av,int HT) = [int]:
    let start = elapsed_ms(), (m,M) = range(x,lambda,av), thetapl = x.involution+1
    then ans = for j:M-m+1 from m
       	       do if test_new(x,lambda,av,j,HT) {or ((av*thetapl).= and j.=)}
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_time +:= elapsed_ms() - start;
     	ans

{works for HT < 0, giving all reducibility points}
{omitting the singular real roots gives 2 too many unitary in Sp(6,R)}
set red_points(KGBElt x, ratvec lambda, vec av,int HT) = [int]:
    if steve_new_flag
    then return red_points_new(x,lambda,av,HT)
    fi;
    let start = elapsed_ms(), (m,M) = range(x,lambda,av), thetapl = x.involution+1
    then ans = for j:M-m+1 from m
       	       do if test(x,lambda,av,j,HT) {or ((av*thetapl).= and j.=)}
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_time +:= elapsed_ms() - start;
     	ans

set red_points_new(KGBElt x,ratvec lambda, int HT) = [[int]]:
    for av in red_coroots(x)
    do red_points_new(x,lambda,av,HT)
    od

set red_points(KGBElt x,ratvec lambda, int HT) = [[int]]:
    if steve_new_flag
    then return(red_points_new(x,lambda,HT))
    fi;
    for av in red_coroots(x)
    do red_points(x,lambda,av,HT)
    od

{record location of rat t with respect to strictly increasing
sequence of M ints red_pts by integer from -1 to 2M.
0 means red_pts is empty; 0 means smaller than any, 2M means larger than any;
2j}
{ range [0..2*#a]; a[i]=r -> 2i+1; even number: r absent }
set location([int] a,rat t) = int:
    let loc = locate_sorted(a,ceil(t)) { first with |a[loc]>=t| }
    in if loc=#a
       then 2*loc
       elif a[loc]=t then 2*loc+1
       else 2*loc
       fi

set location(KGBElt x, ratvec lambda, vec av,int HT, rat t) = int:
    let rp = red_points(x,lambda,av,HT)
    in location(rp,t)

set thruple(KGBElt x, ratvec lambda,int HT, ratvec gamma) = vec:
    for av in red_coroots(x)
    do location(x,lambda,av,HT,av*gamma)
    od

set thruple([vec] red_co, [[int]] red_pts, ratvec gamma) = vec:
    for av@j in red_co
    do location(red_pts[j],av*gamma)
    od

set is_def_thr(vec base_thr, vec def_thr) = bool:
    (def_thr != base_thr) and
    all(for x@j in base_thr
        do @bool: (is_odd(x) and def_thr[j] = x)
	   	  or(is_even(x) and abs(def_thr[j] - x) <= 1)
	od)

{set is_def_intervals(vec thruple) = [[int]]:
    for x in thruple
    do [int]:
       if is_odd(x) then [x]
       elif x.= then [x,x+1]
       else [x-1,x,x+1]
       fi
    od}

{set is_def_testers(vec thruple) = [(int -> bool)]:
    for x in thruple
    do (int y) bool:
       if is_odd(x)
       then x=y
       else let d = x-y
       	    in d=1 or d=0 or d=-1
       fi
    od}

{set is_def_testers(vec thruple) = [(int -> bool)]:
    for x in thruple
    do (int y) bool:
       if is_odd(x)
       then x=y
       else case x-y+1
       	    in true,true,true
	    else false
	    esac
       fi
    od}

{set is_def_testers(vec thruple) = [(int -> bool)]:
    for x in thruple
    do (int y) bool:
       let d = x-y
       in if is_odd(x)
       	  then d.=
       	  else case d+1
       	       in true,true,true
	       else false
	       esac
       	  fi
    od}

{set is_def_testerA(vec thruple) = (vec -> bool):
    (vec v): bool:
    let def_tests = is_def_testers(thruple)
    in all(for y@i in v do @bool: def_tests[i](y) od)}

{seems to be about half as fast as def_testerA}
{set is_def_testerB(vec thruple) = (vec -> bool):
    (vec v): bool:
    let def_ints = is_def_intervals(thruple)
    in all(for def_int@i in  is_def_intervals(thruple)
       	   do @bool: is_member_sorted(def_int)(v[i])
	   od)}

{This is 30% faster than commented out def_testerA above}
set is_def_tester(vec thruple) = (vec -> bool):
    (vec v): bool:
    all(for x@j in thruple
    	do @bool: (1+x%2)*abs(x-v[j]) <= 1
	od)

set taus(KGBElt x, ratvec lambda, int HT) = [KType]:
    monomials(branch(K_type_pol(parameter(x,lambda,0*lambda)),HT))

set pos_tester(KGBElt x, ratvec lambda,int HT,ratvec gamma) = bool:
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE_old(q,HT) od)

{compute vectors of size 2 giving [index of K-char, #Langlands quotients]}
set extra_coord_flag = true

{try deforming loc to a known one}
set deform_loc_flag = true

{try deforming loc to a known nonunitary one}
set deform_nonu_flag = true

set do_not_use_deform_steve() = void:
    extra_coord_flag:=false;
    deform_loc_flag:=false;
    deform_nonu_flag:=false

set use_deform_nonu_steve() = void:
    extra_coord_flag:=false;
    deform_nonu_flag:=true;
    deform_loc_flag:=false

{USE Kpol_hash defined in FPP_faces_geom.at; assume index od }
set pos_tester_known_Kchar(KGBElt x, ratvec lambda,int HT,ratvec gamma, vec KCv) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in if extra_coord_flag
       then (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),KCv)
       else (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),[])
       fi

{USE Kpol_hash defined in FPP_faces_geom.at}
set pos_tester_Kchar(KGBElt x, ratvec lambda,int HT,ratvec gamma) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in if extra_coord_flag
       then (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),
       	    [Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT))),#qs])
       else (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),[])
       fi

set Kchar_vec_time = int: 0

set Kchar_vec(KGBElt x, ratvec lambda, int HT, ratvec gamma) = vec:
    let start = elapsed_ms(), p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    then answer = if extra_coord_flag
       	 	  then [Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT))),#qs]
       		  else []
       		  fi
    in Kchar_vec_time +:= elapsed_ms() - start;
       answer

set report_def_thruples() = void:
    prints(print_time_string(def_thruples_time)," to find deformed thruple candidates.");
    prints("Found ",hash_def_true_count," deformations proving unitarity (to height), ",
    	   hash_def_false_count," deformations proving nonunitarity (to height).")

set_type
[steve_hash_table =
( ( -> ) clear {clear the table}
  , ( -> int) real_form_size {number of real forms included}
  , ( -> vec) xlhash_sizes {for every real form, the number of pairs(x,lambda)}
  , ( -> vec) K_type_sizes {number of KTypes for each real form}
  , ((KGBElt, ratvec) -> vec) heights {list of heights to which reducibility has been studied}
  , ((KGBElt, ratvec, int) -> (int, int, int)) indices {rfnum, xlnum, htnum}
  {, ((KGBElt, ratvec, vec, int) -> KTypePol) ind_quo} {like function ind_quo, but storing answers}
  {, ((KGBElt, ratvec, vec, int, int) -> bool) test} {like function test}
  , ((KGBElt, ratvec, int) -> vec_hash) vecHash {hash table of location vecs known}
  , ((KGBElt, ratvec, int) -> [[int]]) red_points {for each reducibility coroot, list of reducibility points}
  , ((KGBElt, ratvec, int) -> [bool]) postests {size vecHash.size(), listing unitarity results}
  , ((KGBElt, ratvec, int) -> [vec]) extra_coords {size vecHash.size():
  [Kchar #, #LQs] if extra_coord_flag, [] else}
  , ((int, int, int, ratvec, vec) -> bool) partly_indexed_postest_known_Kchar
  , ((KGBElt, ratvec, int, ratvec, vec) -> bool) postest_known_Kchar {test param(x,lambda,last_arg) for unitarity to ht}
  , ((int, int, int, int) -> bool) indexed_postest {known rfnum, xlnum, htnum, vecnum}
  , ((int, int, int, ratvec) -> bool) partly_indexed_postest
  , ((KGBElt, ratvec, int, ratvec) -> bool) postest {test param(x,lambda,last_arg) for unitarity to ht}
  , ((KGBElt, ratvec, int, ratvec) -> vec) extra_coord {[index of Kchar of param(x,lambda,last_arg) to ht, #LQs}
  , ((int, int, int, ratvec, vec) -> vec) indexed_thruple_known_Kchar {known rfnum, xlnum, htnum}
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec) thruple_known_Kchar {loc vec: (x,lambda,gamma) to HT}
  , ((int, int, int, ratvec) -> vec) indexed_thruple {known rfnum, xlnum, htnum}
  , ((KGBElt, ratvec, int, ratvec) -> vec) thruple {loc vec: (x,lambda,gamma) to HT}
  , ((int, int, int, ratvec, vec) -> vec) indexed_thruple_known_Kchar_no_stat {known rfnum, xlnum, htnum; don't compute status}
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec) thruple_known_Kchar_no_stat {loc vec: (x,lambda,gamma) to HT; don't compute status}
  , ((int, int, int, ratvec) -> vec) indexed_thruple_no_stat {known rfnum, xlnum, htnum; don't compute status}
  , ((KGBElt, ratvec, int, ratvec) -> vec) thruple_no_stat {loc vec: (x,lambda,gamma) to HT; don't compute status}
  , ((Param,int) -> (int, int, int,int)) umatch {(Param p, int HT) -> (rfnum, xlnum, locnum);
    statuses set "true"}
  , ((Param,int) -> (int, int, int, int)) numatch {(Param p, int HT) -> (rfnum, xlnum, locnum);
    statuses set "false"}
)
]

set make_steve_hash() = steve_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then K_type_hashes = [KType_hash] : [] {one for each real form; list of KTs considered}
    then xlhashes = [xlambda_hash]: [] {one for each real form}
    then heights = [[vec]]:[] {one for each entry in each xlhash}
    then vechashes = [[[vec_hash]]]:[] {one for each height for each entry in each xlhash}
    then redpoints = [[[[int]]]]:[] {for each entry in xlhash and height, [int] = bitmap of reducibility
    	 	     		  points for each reducibility coroot}
    then statuses = [[[[bool]]]]:[] {one [bool] for each vechash}
    then charvecs = [[[[vec]]]]: [] {one [vec] for each vechash; possibly [index of K_char, #LQs]}
    then clearSH() = void:
    	 let () = real_form_hash.clear()
	 then () = K_type_hashes:=[]
	 then () = xlhashes:=[]
	 {then () = paramhashes:=[]}
	 {then () = ktps:=[]}
	 then () = heights:=[]
	 then () = vechashes:=[]
	 then () = statuses:=[]
	 then () = charvecs:=[]
	 then () = redpoints := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then	K_type_hashes #:= make_KType_hash();
		        xlhashes #:= make_xlambda_hash();
			{paramhashes #:= ([Param_hash]:[]);}
			{ktps #:= ([[KTypePol]]:[]);}
			heights   #:= ([vec]:[]);
			vechashes #:= ([[vec_hash]]:[]);
			statuses  #:= ([[[bool]]]:[]);
			redpoints #:= ([[[int]]]:[]);
			charvecs  #:= ([[[vec]]]:[]);
			assert(@:real_form_hash.size() = #K_type_hashes and #xlhashes = #K_type_hashes and
	       	    	   #heights = #xlhashes and #vechashes = #heights and #statuses = #heights and
			   #redpoints = #heights, "steve_hash damaged on adding real form")
	    	   fi
	  in i
    then add_K_type(KType mu) = (int, int): {real form index, K type index}
   	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf,1*mu))}
	 {then KTYPENUM = K_type_hashes[rfnum].size()}
	 in (rfnum, K_type_hashes[rfnum].match(mu))
    then add_xl(KGBElt x, ratvec lambda) = (int,int): {real form index, xlhash index}
    	 let rfnum = add_real_form(x.real_form)
	 then XLNUM = xlhashes[rfnum].size()
	 then xlnum = xlhashes[rfnum].match(x,lambda)
	 in if xlnum = XLNUM {new (x,lambda)}
	    then {paramhashes[rfnum] #:= make_Param_hash();}
	    	 {ktps[rfnum] #:= ([KTypePol]:[]);}
		 heights[rfnum]#:=null(0);
	    { add empty list of lists of reducibility points for the new height}
	    	 redpoints[rfnum] #:= ([[int]]:[]);
		 vechashes[rfnum]#:=([vec_hash]:[]);
		 statuses[rfnum]#:=([[bool]]:[]);
		 charvecs[rfnum]#:=([[vec]]:[])
	    fi;
	    (rfnum,xlnum)
    then add_xlht(KGBElt x, ratvec lambda, int HT) = (int,int,int): {real form index, xlhash index, HT index}
    	 let (rfnum,xlnum) = add_xl(x,lambda)
	 then J = #heights[rfnum][xlnum], htnum = find(heights[rfnum][xlnum],HT)
	 in if htnum.< {new HT}
	    then let redpointsrxl = redpoints[rfnum][xlnum], redpointsr = redpoints[rfnum],
	    	 vechashesrxl = vechashes[rfnum][xlnum], vechashesr = vechashes[rfnum],
		 statusesrxl = statuses[rfnum][xlnum], statusesr = statuses[rfnum],
		 charvecsrxl = charvecs[rfnum][xlnum], charvecsr = charvecs[rfnum],
		 heightsrxl = heights[rfnum][xlnum], heightsr = heights[rfnum]
	    	 then () = redpointsrxl #:= ([int]: for list in red_points(x,lambda,HT)
	    	 			     	     do to_bitset(list)
						     od);
		 vechashesrxl #:= make_vec_hash();
		 statusesrxl append:= [];
		 charvecsrxl append:= [];
		 heightsrxl#:=HT
		 then () = redpointsr[xlnum]:=redpointsrxl;
		 vechashesr[xlnum]:=vechashesrxl;
		 statusesr[xlnum]:=statusesrxl;
		 charvecsr[xlnum]:=charvecsrxl;
		 heightsr[xlnum]:=heightsrxl
		 then () = redpoints[rfnum]:=redpointsr;
		 vechashes[rfnum]:=vechashesr;
		 statuses[rfnum]:= statusesr;
		 charvecs[rfnum]:= charvecsr;
		 heights[rfnum]:= heightsr
		 in htnum:= J
	    fi;
	    (rfnum,xlnum,htnum)
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_plain_indexed(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then (boo,v) = pos_tester_Kchar(x, lambda, HT, gamma)
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_plain(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int, int, int, int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
	 in (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_indexed_known_Kchar(int rfnum, int xlnum, int htnum, ratvec gamma, vec Kcv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechashes[rfnum][xlnum][htnum].list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[rfnum][xlnum][htnum][m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[rfnum][xlnum][htnum][m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then () = if (#v).=
			     	  then boo:= pos_tester(x, lambda, HT, gamma);
				       v:=Kcv
				  fi
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl
			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum] := sr;
			   charvecs[rfnum] := charvecr
		   fi
	 in vecnum
    then SHthruple_indexed(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then Kcv = Kchar_vec(x,lambda,HT,gamma)
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechashes[rfnum][xlnum][htnum].list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[rfnum][xlnum][htnum][m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[rfnum][xlnum][htnum][m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then () = if (#v).=
			     	  then boo:= pos_tester(x, lambda, HT, gamma);
				       v:=Kcv
				  fi
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl
			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		    fi
	 in vecnum
    then SHthruple(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int,int,int,int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
	 in if (deform_loc_flag or deform_nonu_flag)
	    then (rfnum, xlnum, htnum, SHthruple_indexed(rfnum, xlnum, htnum, gamma))
	    else (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	    fi
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
{      then check() = void:
      	   assert(real_form_hash.size() = xlhashes.size(),"wrong rf/xl hash sizes");
      	   for rf@rfnum in real_form_hash.list()
	   do assert(xlhashes[rfnum].size() = #heights[rfnum], "wrong xl/hts sizes");
	      for xl@xlnum in xlhashes[rfnum]
	      do assert(#heights[rfnum][xlnum] = }
    then SHthruple_indexed_known_Kchar_no_stat(int rfnum, int xlnum, int htnum, ratvec gamma,
    vec KCv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then () = charvecxlht#:=KCv
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
    then SHthruple_indexed_no_stat(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then KCv = Kchar_vec(x,lambda,HT,gamma)
			then () = charvecxlht#:=KCv
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
    then SHthruple_no_stat(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int,int,int,int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT) {, start_count = unitary_test_counter.use_count()}
	 in if (deform_loc_flag or deform_nonu_flag)
	    then (rfnum, xlnum, htnum, SHthruple_indexed_no_stat(rfnum, xlnum, htnum, gamma))
	    else (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	    fi
	 {in prints("no_stat used ", unitary_test_counter.use_count() - start_count, " unitarity tests.")
	     ;ans}
      in
  ( ( -> ): {clear} clearSH
  , ( -> int): {real_form_size} @int: real_form_hash.size()
  , ( -> vec): {xlhash_sizes} @vec: for xlhash in xlhashes do xlhash.size() od
  , ( -> vec): {K_type_sizes} @vec: for Khash in K_type_hashes do Khash.size() od
  , ((KGBElt, ratvec) -> vec): {heights} (KGBElt x, ratvec lambda) vec:
    let (rfnum, xlnum) = add_xl(x,lambda)
    in heights[rfnum][xlnum]
  , ((KGBElt, ratvec, int) -> (int, int, int)): {indices} (KGBElt x, ratvec lambda, int HT) (int, int, int):
    add_xlht(x,lambda,HT)
  , ((KGBElt, ratvec, int) -> vec_hash): {vecHash} (KGBElt x, ratvec lambda, int HT) vec_hash:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in vechashes[rfnum][xlnum][htnum]
  , ((KGBElt, ratvec, int) -> [[int]]): {red_points} (KGBElt x, ratvec lambda, int HT) [[int]]:
    {SHred_points(x,lambda,HT)}
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in for M in redpoints[rfnum][xlnum][htnum]
       do set_bit_positions(M)
       od
  , ((KGBElt, ratvec, int) -> [bool]): {postests} (KGBElt x, ratvec lambda, int HT) [bool]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in statuses[rfnum][xlnum][htnum]
  , ((KGBElt, ratvec, int) -> [vec]): {extra_coords} (KGBElt x, ratvec lambda, int HT) [vec]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in charvecs[rfnum][xlnum][htnum]
  , ((int, int, int, ratvec, vec) -> bool): {partly_indexed_postest_known_Kchar}
    (int rfnum, int xlnum, int htnum, ratvec gamma, vec KCv) bool:
    let vecnum = SHthruple_indexed_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec, vec) -> bool): {postest_known_Kchar} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma, vec KCv) bool:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, int) -> bool): {indexed_postest} (int rfnum, int xlnum, int htnum, int vecnum) bool:
    statuses[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, ratvec) -> bool): {partly_indexed_postest} (int rfnum, int xlnum, int htnum,
    ratvec gamma) bool:
    let vecnum = SHthruple_indexed(rfnum, xlnum, htnum, gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec) -> bool): {postest} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) bool:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec) -> vec): {extra_coord} (KGBElt x, ratvec lambda,
    int HT, ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in charvecs[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, ratvec, vec) -> vec): {indexed_thruple_known_Kchar} (int rfnum, int xlnum, int htnum,
    ratvec gamma, vec KCv) vec:
    let vecnum = SHthruple_indexed_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec): {thruple_known_Kchar} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma, vec KCv) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec) -> vec): {indexed_thruple} (int rfnum, int xlnum, int htnum,
    ratvec gamma) vec:
    let vecnum = SHthruple_indexed(rfnum, xlnum, htnum, gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec) -> vec): {thruple} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec, vec) -> vec): {indexed_thruple_known_Kchar_no_stat} (int rfnum, int
    xlnum, int htnum, ratvec gamma, vec KCv) vec:
    let vecnum = SHthruple_indexed_known_Kchar_no_stat(rfnum, xlnum, htnum, gamma, KCv)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec): {thruple_known_Kchar_no_stat} (KGBElt x, ratvec
    lambda, int HT, ratvec gamma, vec KCv) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple_no_stat(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec) -> vec): {indexed_thruple_no_stat} (int rfnum, int xlnum, int htnum,
    ratvec gamma) vec:
    let vecnum = SHthruple_indexed_no_stat(rfnum, xlnum, htnum, gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec) -> vec): {thruple_no_stat} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple_no_stat(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((Param,int) -> (int, int, int, int)): {umatch} (Param p, int HT) (int, int, int, int):
    let (rfnum, xlnum, htnum, vecnum) = SHthruple_no_stat(p.x,p.lambda,HT,p.infinitesimal_character)
    then statusrxlh = statuses[rfnum][xlnum][htnum], statusrxl = statuses[rfnum][xlnum],
    	 statusr = statuses[rfnum]
    then () = statusrxlh[vecnum]:=true;
    	      statusrxl[htnum]:=statusrxlh;
	      statusr[xlnum]:=statusrxl;
	      statuses[rfnum]:= statusr
    in (rfnum, xlnum, htnum, vecnum)
  , ((Param,int) -> (int, int, int,int)): {numatch} (Param p, int HT) (int, int, int, int):
    let (rfnum, xlnum, htnum, vecnum) = SHthruple_no_stat(p.x,p.lambda,HT,p.infinitesimal_character)
    then statusrxlh = statuses[rfnum][xlnum][htnum], statusrxl = statuses[rfnum][xlnum],
    	 statusr = statuses[rfnum]
    then () = statusrxlh[vecnum]:=false;
    	      statusrxl[htnum]:=statusrxlh;
	      statusr[xlnum]:=statusrxl;
	      statuses[rfnum]:= statusr
    in (rfnum, xlnum, htnum, vecnum)
  )
)

set steve_hash = make_steve_hash()

{set is_unitary_to_ht_steve(Param p, int H) = bool:}

set location_finder_time = int: 0
set loclist_time = int: 0

{local faces LFKH; determine which are unitary to height HT; each entry size d+3, last two being KCv
PERHAPS FOR LOWER height}
set location_finder(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [FaceVertsKHash] LFKHcat) = (vec_hash, [vec], [int], [[int]]):
    let start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then lochash = steve_hash.vecHash(x, lambda, HT)
    {make_vec_hash()} {list of all locations of faces in LFKH}
    {then loclist = [int]:[] {for each face in LFKHcat, index of location}}
    then KCvlist = [vec]: steve_hash.extra_coords(x, lambda, HT)
    {then () = prints("in location_finder, start with lambda = ",lambda, ", lochash.size() = ",
    lochash.size(), ", KCvlist = ", KCvlist)}
    	{for each location in lochash, vec of size 2 [index of Kchar, #LQ's]}
    then red_co = red_coroots(x)
    then red_pts = steve_hash.red_points(x,lambda,HT)
    then facelist = [[int]]: for j:lochash.size() do [] od
    {entry k is numbers of faces of location #k in lochash}
    then empty = [int]: []
    then startloc = elapsed_ms()
    then loclist = for v@N in LFKHcat
    	      	   do let d = #v-3
	      	      then verts = v[:d+1]
		      then gamma = face_bary(Lvd,verts)
		      then p = parameter(x,lambda,gamma)
		      then LOCNUM = lochash.size()
		      then loc = steve_hash.thruple_no_stat(x, lambda, HT, gamma)
		      then locnum = lochash.match(loc)
		      in if lochash.size() > LOCNUM {haven't seen this location before}
		      	 then facelist #:= empty;
			      let extra = vec: steve_hash.extra_coord(x, lambda, HT, gamma)
			      {[Kpol_hash.match(K_type_pol(
			      character_formula_to_height(1*p,HT))),v[d+2]]}
			      in  assert(@:Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT)))
						= extra[0],"bad extra")
			 fi;
			 facelist[locnum]#:=N;
			 locnum
		   od
   in assert(@:unitary_test_counter.use_count() = start_count, "unitarity testing in location_finder");
      location_finder_time +:= elapsed_ms() - start;
      loclist_time +:= elapsed_ms() - startloc;
   (lochash,  steve_hash.extra_coords(x, lambda, HT), loclist, facelist)

set location_finder(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH) =
(vec_hash, [vec], [int], [[int]]):
location_finder(x, lambda, HT, Lvd, LFKH.##)

set up_graph_gens_time = int: 0

{Describe directed graph with nodes the entries of vec_hash FOR WHICH FACELIST NOT EMPTY.
entry m0 in answer is all m1
so there is a directed node m0 -> m1: nonunitary at m0 implies nonunitary at m1. Equiv,
unitary at m1 implies unitary at m0.}
set up_graph_gens(vec_hash lochash, [vec] KCvs, [int] loclist) = [[int]]:
    let start = elapsed_ms()
    then edge_gens = [[int]]: for m:lochash.size() do [] od
    then () = for loc@m0 in lochash.list()
    	      do let def_tester = is_def_tester(loc)
       	      	 in for locdef@m1 in lochash.list()[:m0]
       	  	    do if def_tester(locdef)
	     	       then edge_gens[m1]#:= m0;
	     	       	    if KCvs[m0] = KCvs[m1]
		       	    then edge_gens[m0] #:= m1; {this says m0 is equiv to m1, so maybe don't need further edges???}
			    break
		  	    fi
	      	       fi
		    od
	       od
    in up_graph_gens_time+:= elapsed_ms() - start;
       edge_gens

{output is what was generally called (eq,gr) in FPP_localDirac.at}
set graph([[int]] edges) = ([[int]],[[int]]):
    strong_components(edges)

set graph_tilde_flag = false {so always run through graph "large" faces (highly deformable) to small}
set steve_graph_test_time = int:0
set local_test_graph_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [FaceVertsKHash] LFKHcat, {don't sort by dim}
    int HT
     ) = [FaceVertsKHash]:
begin
    let (lochash, KCvlist, loclist, facelist) = location_finder(x, lambda, HT,
    	Lvd, LFKHcat), G = x.real_form
    {then () = prints("loclist = ", loclist);
	      prints("facelist = ",facelist);
	      prints("KCvlist = ", KCvlist)
	      fi}
    then start = elapsed_ms()
    then inv_is = [int]: for j:#facelist do -1 od {if j is ith good, then  jth entry is i}
    then good_js = [int]:
    	 let i = 0
	 in for list@j in facelist
    	    do if #list>0
	       then inv_is[j] := i;
		    i+:=1;
		    [j]
	       else []
	       fi
	    od.##
    {then precheck = [bool]: for v in LFKHcat
    	 	    	    do let p = parameter(x,lambda, face_bary(Lvd,v[:#v-2]))
			       then ps = monomials(1*p)
			       in all(for q in ps
			       	      do is_unitary_to_ht(q,HT)
				      od)
			     od}
    then short_facelist = for j in good_js do facelist[j] od
    then () = assert(@:sum(for list in short_facelist do #list od) = #LFKHcat)
    then short_KCvlist = for j in good_js do KCvlist[j] od
    then short_loclist = for j in loclist do inv_is[j] od
    then short_lochash = make_vec_hash()
    then () = for j in good_js do short_lochash.match(lochash.index(j)) od
    {then () = if x = x_open(G)
    	      then prints("LFKHcat = ",LFKHcat);
		   prints("short_loclist = ", loclist);
	      	   prints("short_facelist = ",facelist);
		   prints("short_KCvlist = ", KCvlist)
	      fi}
    then tester(Param p) = is_unitary_to_ht_big_SIMPLE(p,HT)
    then up_gens = up_graph_gens(short_lochash, short_KCvlist, short_loclist)
    then (eq,gr) = graph(up_gens)
    {then () = if x = x_open(G)
    	      then prints("eq = ",eq);
		   prints("gr = ",gr)
	      fi}
    then NumClasses = #eq, printInterval = int: 1, start_count = unitary_test_counter.use_count()
    then statuses = [string]: for j:#eq do "?" od
    then () = if test_verbose
	      then prints("Examining ",NumClasses," classes in local_test_graph_steve to ht ",
	      	   	   HT)
	      fi
    then nums = #NumClasses
    then () = if graph_tilde_flag then nums:=~nums fi
    then () = for k in nums
    	      do if statuses[k] = "?"
	      	 then let C = eq[k] {list of locs}
		 then N = if graph_tilde_flag
		      	  then short_facelist[C~[0]]~[0] {last face for last loc in C}
			  else short_facelist[C[0]][0] {first face for first loc in C}
			  fi
		 then v = LFKHcat[N]
		 then d = #v-3
		 then verts = v[:d+1]
		 then gamma = face_bary(Lvd,verts)
		 then p = parameter(x,lambda,gamma)
    		 in statuses[k]:=
		    if all(for q in monomials(1*p)
		      	   do @bool: tester(q)
			   od)
		    then if not graph_tilde_flag
		    	 then downdateUclassesB(statuses, gr, k, "T") {needed only in forward eq}
			 fi;
		      	 "T"
		    else if graph_tilde_flag
		    	 then updateNUclassesB(statuses, gr, k, "F") {needed only in backward eq}
			 fi;
		      	   "F"
		    fi
		 fi
	       od

     {then () = prints("statuses = ",statuses)}
     {make new local face list using only faces not already proven nonunitary}
     then LFKHnew = [FaceVertsKHash]:
	  for C@m in eq {C is a list of locs}
	  do if statuses[m][0] = "T"
	     then for k in C 
		  do let js = short_facelist[k]
		     in for j in js
		     	do {assert(precheck[j],"bad true with local_test_graph");}
		     	   LFKHcat[j]
			od {[FaceVertsKHash]}
		  od.## {still [FaceVertsKHash]}
	     else {for k in C 
		  do let js = short_facelist[k]
		     in for j in js do assert(not(precheck[j]),"bad false with local_test_graph") od
		  od;}
	     	  []
	     fi
	  od.##
     then () = if test_verbose
	       then prints("Total of ", count(for ans in statuses do ans[0] = "T" od),
				 " classes are unitary candidates, giving ", #LFKHnew,
			   " unitary_to_ht faces")
	       fi

     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
			       " for local_test_graph_steve; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  steve_graph_test_time+:= elapsed_ms() - start;
     	 LFKHnew
{if sort_LFD_flag
	 then sort(x.real_form, Lvd, FVKHnew)
	 else FVKHnew
	 fi}
end

set report_steve_graph() = void:
     prints(print_time_string(location_finder_time), " for location_finder, incl ",
     		print_time_string(red_points_time), " for red_points, and ",
     		print_time_string(loclist_time)," for listloc, incl ",
		print_time_string(Kchar_vec_time)," for Kchar_vec.");
     prints(print_time_string(up_graph_gens_time), " for steve_graph construction; ",
     		print_time_string(steve_graph_test_time), " for testing with steve_graph.")

set report_steve_clear() = void:
    location_finder_time:=0;
    loclist_time:=0;
    steve_graph_test_time:=0;
    up_graph_gens_time:=0

{takes local data and low global faces and computes local vertices, imposing
hermitian, pos on LKTs, and pos to HT. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
set localFD_1SteveU\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1SteveU to ht ",HT)
    fi;
    let G = x.real_form, start = elapsed_ms(), (rfnum, xlnum, htnum) = steve_hash.indices(x, lambda, HT)
    then length = #(Lvd.list)
    then freq = max(length\10,1)
    then answer = [vec]:
    	 if steve_tilde_flag
	 then for v@j in Lvd.list
       	      ~do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	     	  fi;
	     	  let p = parameter(x,lambda,v)
	     	  in if not is_hermitian(p)
	     	     then []
	     	     elif steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, v)
	     	     then if extra_coord_flag
		     	  then [[j]##steve_hash.extra_coord(x,lambda,HT,v)]
			  else [[j]]
			  fi
	     	     else []
	     	     fi
	       od.## {list of j for which vertex j is a candidate}
          else for v@j in Lvd.list
       	       do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	     	  fi;
	     	  let p = parameter(x,lambda,v)
	     	  in if not is_hermitian(p)
	     	     then []
	     	     elif steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, v)
		     then if extra_coord_flag
		     	  then [[j]##steve_hash.extra_coord(x,lambda,HT,v)]
			  else [[j]]
			  fi
	     	     else []
	     	     fi
	       od.## {list of j for which vertex j is a candidate}
	   fi
    then () = answer:= if steve_tilde_flag
    	      	       then for v in answer ~do v od
		       else answer
		       fi
    in if fund_face_verbose
       then prints("Found ",#answer," vertices to ht ",HT," in time ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
       fi;
       answer
)

{output is unitary-to-HT verts, with perhaps two extra coords: Kchar and #LQs}
set localFD_1SteveU_graph\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1SteveUgraph to ht ",HT)
    fi;
    if not is_pos_on_LKTs(parameter(x,lambda,0*lambda)) then return [] fi;
    let G = x.real_form, start = elapsed_ms()
    then LF0 = for v@j in Lvd.list
    	       do let p = parameter(x,lambda,v)
	       	  in if not is_hermitian(p)
		     then []
		     elif extra_coord_flag
		     then [[j,0,#monomials(1*p)]]
		     else [[j]]
		     fi
	       od.##
    in local_test_graph_steve(x,lambda,Lvd,LF0,HT)
)



{takes local data and low global faces and local vertices and computes local edges, imposing
hermitian, pos to HT.}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_2SteveU\
( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_2Steve")
    fi;
    {prints("in localFD_2SteveU, LF0 = ",LF0);}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then () = if #LF0 = 0
    	      then return []
	      fi
    then FixedList = [int]: for v in LF0
    	 	     	    do let j = v[0]
			       in if j < #Perm2.fixed
			       	  then [j]
				  else break
				  fi
			    od.##
    then f = #FixedList, f0 = #Perm2.fixed
    then TranList = [int]: for v in LF0[f:] do v[0] od {all entries are f0+ index in Perm2.trans}
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number in Lvd
		      	  of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is Perm2.trans[m + f0]}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0 {midpoint of v[2:] is a local vertex}
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT at [",k,",",n,"]!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	   {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in  {prints("FF, FT, TT = ",[#EdgesFixFix,#EdgesFixTrans,#EdgesTransTrans]);}
	       EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
     {then () = prints("#Edges in localFD_2SteveU = ",#Edges)}
     then length = #Edges
     then freq = max(length\10,1)
     then (rfnum, xlnum, htnum) = steve_hash.indices(x, lambda, HT)
     then LF1 = [FaceVertsIndex]:
	  if steve_tilde_flag
	  then for v@j in Edges
	       ~do if fund_face_verbose and red_count_flag and (j%freq).=
	       	   then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	     	   fi;
	     let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     in if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       	then []
	       	elif steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,v))
	       	then if extra_coord_flag
		     then [v##steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))]
	       	    	 {then prints("v = ",v, "extras = ", steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v)));}
		     else [v]
		     fi
	        else []
	       	fi
	      od.##
	  else for v@j in Edges
	       do if fund_face_verbose and red_count_flag and (j%freq).=
	       	   then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	     	   fi;
	     let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     in if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       	then []
	       	elif steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,v))
	       	then if extra_coord_flag
		     then [v##steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))]
	       	    	 {then prints("v = ",v, "extras = ", steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v)));}
		     else [v]
		     fi
	        else []
	       	fi
	      od.##
	   fi
    {then () = if time_verbose
    	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    {then () = FD12bzTime +:= elapsed_ms() - start}
    then tail = if (#LF1).=
    	      	then 0
		else {prints("LF1 = ",LF1);}
		     #(LF1[0]) - 2
		fi
    then () = LF1:= if sort_LFD_flag
       	      	    then sort(G, Lvd, [LF1], tail)[0]
       	      	    else LF1
       	      	    fi
    {then LF1 = if steve_tilde_flag
    	       then for v in LF1 ~do v od
	       else LF1
	       fi}
    in if fund_face_verbose
       then prints("After localFD_2SteveU, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]");
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
       fi;
       LF1
)

{LF0 is meant to be unitary-to-ht HT vertices, with Kchar and #LQs extra coords. Output is [LF0,LF1],
same list for vertices and edges}
{LF0 may be out of order, and this breaks edge hunt}
set localFD_2SteveUgraph\
( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
 [[FaceVertsKHash]]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_2SteveUgraph")
    fi;
    {prints("in localFD_2SteveUgraph, LF0 = ",LF0);}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then () = if #LF0 = 0
    	      then return []
	      fi
    then FixedList = [int]:[], TranList = [int]:[]
    then () = for v in LF0
    	      do let j = v[0]
	      	 in if j < #Perm2.fixed
	       	    then FixedList #:=j
	       	    else TranList #:=j
	       	    fi
	      od
    then () = FixedList := FixedList.sort
    then () = TranList := TranList.sort
    then f = #FixedList, f0 = #Perm2.fixed
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number in Lvd
		      	  of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is Perm2.trans[m + f0]}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0 {midpoint of v[2:] is a local vertex}
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT at [",k,",",n,"]!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	   {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in {prints("FF, FT, TT = ",[#EdgesFixFix,#EdgesFixTrans,#EdgesTransTrans]);}
	   EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
   then () = Edges := if steve_tilde_flag
   	      	 then for v in Edges
		      ~do v
		      od
		 else Edges
		 fi
   {then () = prints("#Edges in localFD_2SteveUgraph = ",#Edges)}
   then LF1cand = [LocalFaceVertsKHash]:
        for v@j in Edges
	do let gamma = face_bary(Lvd,v)
	   then p = parameter(x,lambda,gamma)
	   in v##[0,#monomials(1*p)]
	od
   {then () = prints("LF1cand = ",LF1cand)}
   then answer = local_test_graph_steve(x, lambda, Lvd, LF0##LF1cand, HT)
   then LF1 = [LocalFaceVertsKHash]:
   	    for v in answer
	    do if #v=4
	       then [v]
	       else []
	       fi
	    od.##
in if fund_face_verbose
   then prints("After localFD_2SteveUgraph, face counts are [", #LF0,",",#LF1,"]");
       	prints("vecHash size = ",steve_hash.vecHash(x, lambda, HT).size())
   fi;
   [LF0,LF1]
)

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces that are unitary to ht HT; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_lookDownSteveU\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t) = [[FaceVertsKHash]]:
(   {if face_verbose
    then prints(new_line,"start localFD_lookDownSteveU, b = ",b,", t = ",t)
    fi;}
    let G = x.real_form, start=elapsed_ms(), (rfnum, xlnum, htnum) = steve_hash.indices(x, lambda, HT)
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2; dim is the new bigger dim}
    	      do LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],0)
	      	    	       	   in [vec]:
				      for (actual,locs) in acts {vec of size dim+1, coords of subs}
	       	    	      	      do if steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,actual))
				      	 then [actual]
					 else []
					 fi

			              od.##);
		if fund_face_verbose
		then prints("After dim ",dim,", found face counts ",for list in LFKH do #list od,
		       " at time ",print_time_string(elapsed_ms() - start))
		fi
	 	od{dim:t-#LFKH}
    then () = LFKH := if sort_LFD_flag
    	      	      then sort(G, Lvd, LFKH)
		      else LFKH
		      fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt_lookDownSteveU to dim ",t-1,
			"; face counts = ", for list in LFKH do #list od);
		   prints("vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
	      fi
    in LFKH
)

{impose unitary to HT on a collection of faces}
set test_Steve(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH) =
    [[FaceVertsKHash]]:
    if #LFKH[0] = 0 then return LFKH fi;
    let start = elapsed_ms(), (rfnum, xlnum, htnum) = steve_hash.indices(x, lambda, HT)
    then local_extra_coord_flag = extra_coord_flag and #LFKH[0][0] = 1
    in for LF@d in LFKH
    do let freq = max(#LF\10,1)
       then answerd =
       	   for v@j in LF
       	   do if (j%freq).= and fund_face_verbose
	      then prints("at face #",j," of ",#LF," at time ",print_time_string(elapsed_ms() - start),
	      "; vecHash size = ", steve_hash.vecHash(x,lambda,HT).size())
	      fi;
	      let gamma = face_bary(Lvd, v[:d+1])
	      in if steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, gamma)
       	      then if local_extra_coord_flag
	      	   then [v##steve_hash.extra_coord(x,lambda,HT,gamma)]
	      	   else [v]
		   fi
	      else []
	      fi
       	   od.##
	then () = if fund_face_verbose
	     	  then prints("old size = ",#LF,", new size = ",#answerd, ", vecHash size = ",
	     	       steve_hash.vecHash(x,lambda,HT).size())
		  fi
	in answerd
    od

set show_steve_flag = false

{all faces unitary to HT}
set localFD_SteveUtoHT(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    let start = elapsed_ms(), LF0 = localFD_1SteveU(x,lambda,HT, Lvd)
    then LF = [LF0,  localFD_2SteveU(x,lambda,HT,Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("edges and verts to ",HT," = ",LF)
	      fi
    then answer = localFD_lookDownSteveU(x,lambda,HT,Lvd,LF,2,rank(x.involution - 1)+1)
    in if fund_face_verbose
       then prints("For HT = ",HT, ", time for localFD_SteveU: ",
       	    		print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,HT).size())
       fi;
       answer

set localFD_SteveUtoHT(KGBElt x, ratvec lambda, int HT) = [[FaceVertsKHash]]:
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_SteveUtoHT(x, lambda, HT, Lvd, Perm2)

{all faces unitary}
set localFD_SteveUB(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1)
    then one_ht = hts[edge_offset]
    then LF0 = localFD_1SteveU(x,lambda,hts[0], Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height ",hts[0], " = ",LF0)
	      fi
    then () = LF0 := test_Steve(x,lambda,one_ht,Lvd,[LF0])[0]
    then () = if show_steve_flag
    	      then prints("LF0 to height ",one_ht, " = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,one_ht,Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 to height ",one_ht," = ",LF[1])
	      fi
    then () = LF:=test_Steve(x,lambda,-1,Lvd,LF)
   { then hts = if #LF[1].>=3
   then next_heights(p0,rank(x.involution - 1)+1)}
    then () = LF:=localFD_lookDownSteveU(x,lambda,one_ht,Lvd,LF,2,rank(x.involution - 1)+1)
    then answer = test_Steve(x,lambda,-1,Lvd,LF)
    in if fund_face_verbose
       then prints("For unitarity, time for localFD_SteveUB: ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,-1).size());
	    prints("unitary face counts = ",for list in answer do #list od);
	    if show_steve_flag
    	    then prints("unitary LF = ",LF)
	    fi
       fi;
       answer

set localFD_SteveUB(KGBElt x, ratvec lambda) = [[FaceVertsKHash]]:
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_SteveUB(x, lambda, Lvd, Perm2)

set steve_B_flag = true

{all faces unitary}
set localFD_SteveU(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    if steve_B_flag
    then return localFD_SteveUB(x, lambda, Lvd, Perm2)
    fi;
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then h0 = next_height(p0)
    then LF0 = localFD_1SteveU(x,lambda,h0, Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height h0 = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,h0,Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 to height h0 = ",LF[1])
	      fi
    then () = LF:=test_Steve(x,lambda,-1,Lvd,LF)
   { then hts = if #LF[1].>=3
    	       then next_heights(p0,rank(x.involution - 1)+1)}
    then answer = localFD_lookDownSteveU(x,lambda,-1,Lvd,LF,2,rank(x.involution - 1)+1)
    in if fund_face_verbose
       then prints("For unitarity, time for localFD_SteveU: ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ",steve_hash.vecHash(x,lambda,-1).size());
	    if show_steve_flag
    	    then prints("unitary LF = ",LF)
	    fi
       fi;
       answer

set localFD_SteveU(KGBElt x, ratvec lambda) = [[FaceVertsKHash]]:
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_SteveU(x, lambda, Lvd, Perm2)

{all faces up to dim D >=2 unitary; need hts of size at least D +2 }
set localFD_SteveUstep(KGBElt x, ratvec lambda, [int] hts, int D) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), theta = x.involution
    then r = rank(theta-1)
    then (Lvd,Perm2) = LPm_table.LPm_entry(x.inner_class, theta, ratvec_as_vec(lambda+theta*lambda))
    {then hts = next_heights(parameter(x,lambda,0*lambda),r+2)}
    then LF0 = localFD_1SteveU(x,lambda,hts[0], Lvd)
    then () = LF0 := test_Steve(x,lambda,hts[1],Lvd,[LF0])[0]
    then LF = [LF0,localFD_2SteveU(x,lambda,hts[1],Lvd,Perm2,LF0)]
    then () = LF:=test_Steve(x,lambda,hts[2],Lvd,LF)
    then d = int:1
    then () = while (d<=D-1) and #LF~[0] > d+1
    	 do LF := localFD_lookDownSteveU(x,lambda,hts[d+1],Lvd,LF,d+1,d+2);
	    LF := test_Steve(x,lambda,hts[d+2],Lvd,LF);
	    if fund_face_verbose
	    then prints("To dim ",d+1,", ht ",hts[d+2], ", time for localFD_SteveUstep: ",
	    	print_time_string(elapsed_ms() - start));
       	    	prints("face sizes ",for list in LF do #list od,", vecHash size = ",
	    	steve_hash.vecHash(x,lambda,hts[d+2]).size())
	    fi;
	    d +:= 1
	 od
    in LF

{all faces unitary to some pretty big height}
set localFD_SteveUstep(KGBElt x, ratvec lambda) = [[FaceVertsKHash]]:
    let D = rank(x.involution -1)
    then hts = next_heights(parameter(x,lambda,0*lambda),D+2)
    in localFD_SteveUstep(x,lambda,hts,D)

set first_offset = int:0
{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}
set localFD_Steve2(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1), extra_coord_hold = extra_coord_flag
    then () = if edge_offset= first_offset then extra_coord_flag:=true fi
    then LF0 = localFD_1SteveU(x,lambda,hts[first_offset], Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height ",hts[first_offset]," = ",LF0)
	      fi
    then () = extra_coord_flag :=true
    then () = if edge_offset > first_offset
    	      then LF0:= test_Steve(x,lambda,hts[edge_offset],Lvd,[LF0])[0]
	      fi
    then () = if show_steve_flag
    	      then prints("LF0 with extra to height ",hts[edge_offset]," = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,hts[edge_offset],Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 with extra to height ",hts[edge_offset]," = ",LF[1])
	      fi
    then () = if fund_face_verbose
    	      then prints("edge/vert counts to height ",hts[edge_offset], " = ",
	      	   for list in LF do #list od,"; time  = ",print_time_string(elapsed_ms() - start))
	      fi
    in extra_coord_flag:=extra_coord_hold; LF

set localFD_Steve2(KGBElt x, ratvec lambda) = [[FaceVertsKHash]]:
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_Steve2(x, lambda, Lvd, Perm2)

{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}
set localFD_Steve2_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsKHash]]:
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1), extra_coord_hold = extra_coord_flag
    then () = if edge_offset= first_offset then extra_coord_flag:=true fi
    then LF0 = localFD_1SteveU(x,lambda,hts[first_offset], Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height ",hts[first_offset]," = ",LF0)
	      fi
    then () = extra_coord_flag :=true
    then () = if edge_offset > first_offset
    	      then LF0:= test_Steve(x,lambda,hts[edge_offset],Lvd,[LF0])[0]
	      fi
    then () = if show_steve_flag
    	      then prints("LF0 with extra to height ",hts[edge_offset]," = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,hts[edge_offset],Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 with extra to height ",hts[edge_offset]," = ",LF[1])
	      fi
    then () = if fund_face_verbose
    	      then prints("edge/vert counts to height ",hts[edge_offset], " = ",
	      	   for list in LF do #list od,"; time  = ",print_time_string(elapsed_ms() - start))
	      fi
    in extra_coord_flag:=extra_coord_hold; LF

set tester(RealForm G) = void:
let start=elapsed_ms()
then () = test_verbose:=false
then () = test_slightly_verbose:=false
then () = time_verbose:=false
then () = unipotents_to_hash(G{,big_unitary_hash.uhash(G)})
then () = for x in KGB(G)
     	  do if twist(x)=x
	     then for lambda in FPP_lambdas(x)
   	     	  do let p0 = parameter(x,lambda,0*lambda)
      	     	     in if is_pos_on_LKTs(p0)
      	 	     	then let LF = localFD_Steve2( x, lambda), Lvd = Lvd(x,lambda)
	      		     then () = local_test_GEO_hash_steve_end(x, lambda, Lvd, LF{,
	      	 	     	big_unitary_hash.uhash(G)})
	      		in ()
	 	   	fi
   	     	   od
	      fi
	 od
in prints("total time = ",print_time_string(elapsed_ms() - start)," to find ",
   		 big_unitary_hash.u_size(G)," unitary reps.")

{ Input is candidate faces; assume Kchar to HT is recorded in LFVH, as index in Kpol_hash.
Output is the unitary_to_HT ones, found by steve_hash.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use steve partial order on working from vertices up}
set local_test_hash_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH,
    int HT
     ) = [[LocalFaceVertsKHash]]:
begin
    let LFVHcat = LFVH.##, G = x.real_form
    then NumFaces = #LFVHcat,  printInterval = int: 1, start = elapsed_ms()
    then start_count = unitary_test_counter.use_count()
    then (rfnum, xlnum, htnum) = steve_hash.indices(x,lambda,HT)
    in  if test_verbose
    	then prints("     Examining ",for list in LFVH do #list od,
	" faces in local_test_hash_steve, to ht ",HT)
    	fi;
    	let answer = [[LocalFaceVertsKHash]]:
	    for list@d in LFVH
	    do for v@j in list {work from small faces toward big}
    	       do if fund_face_verbose and (j%printInterval) = 0
       	       	  then prints("testing ",j,"th face; so far ",unitary_test_counter.use_count() - start_count
			," is_unitary' tests at ", print_time_string(elapsed_ms() - start))
			; printInterval := (3*printInterval)\2 + 1
       	           fi {fund_face_verbose}
       	         ; let verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
       	       	   then gamma = face_bary(Lvd,verts)
       	       	   then pC = parameter(x, lambda, gamma)
       	       	   then ps = [Param]: monomials(pC)
       	       	   in if steve_hash.partly_indexed_postest(rfnum, xlnum, htnum,gamma)
       	       	      then [v]
       	  	      else []
       	  	      fi
    	        od.##
	    od
       in if test_verbose
       	  then prints("     Total of ",for list in answer do #list od, " faces are unitary to ",HT,".")
    	  fi
	  ;   if test_verbose or test_slightly_verbose
    	      then prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	      	   print_time_string(elapsed_ms() - start))
    	      fi
;   answer
end

{whether to finish local_test_GEO_hash_steve with steve_closer}
set steve_closer_flag = false

{whether to use steve at every dimension}
set all_steve_flag = false

{ Input is candidate faces; assume Kchar to HT is recorded in LFVH, as index in Kpol_hash.
Output is the unitary_to_HT ones, found by steve_hash.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use steve partial order on working from vertices up}
{DON'T use after local_test_graph_steve: steve_hash.statuses isn't updated}
set local_test_closer_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [LocalFaceVertsKHash] LFVHcat
     ) = [Param]:
begin
    let G = x.real_form
    then NumFaces = #LFVHcat,  printInterval = int: 1, start = elapsed_ms()
    then start_count = unitary_test_counter.use_count()
    then (rfnum, xlnum, htnum) = steve_hash.indices(x,lambda,-1)
    then unitary_by_dim = vec: null(rank(x.involution - 1)+1)
    in  if test_verbose
    	then prints("     Examining ",NumFaces," faces in local_test_closer_steve.")
    	fi;
    	let UParams = [Param]:
    	    for v@j in LFVHcat {work from small faces toward big}
	    {no tilde finds lots more unitary reps by deformation; not clear whether faster}
    	    do if fund_face_verbose and (j%printInterval) = 0
       	       then prints("testing ",j,"th face; so far ",unitary_test_counter.use_count() - start_count
			," is_unitary' tests at ", print_time_string(elapsed_ms() - start))
			; printInterval := (3*printInterval)\2 + 1
       	       fi {fund_face_verbose};
       	       let d = #v - 3
       	       then verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
	       then KCv = vec: v[d+1:]
       	       then gamma = face_bary(Lvd,verts)
       	       then pC = parameter(x, lambda, gamma)
       	       then ps = [Param]: monomials(pC)
       	       in if steve_hash.partly_indexed_postest_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
       	       	  then for p in ps
		       do if deform_flag
		  	  then for q1d in local_face_defs(p).## {facet_deformed_new(q1)}
		       	       do big_unitary_hash.umatch(q1d)
		       	       od
		  	   else big_unitary_hash.umatch(p)
		  	   fi
	       	       od;
		       unitary_by_dim[d]+:=1;
	       	       [pC]
       	  	  else []
       	  	  fi
    	    od.##
       in if test_verbose
       	  then prints("     Total of ", #UParams, " out of ",NumFaces, " faces are unitary.")
    	  fi
	  ;   if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",unitary_by_dim, test_string);
	      	   prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	      	   print_time_string(elapsed_ms() - start))
    	       fi
;   UParams
end

set local_test_closer_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH
     ) = [Param]:
local_test_closer_steve(x, lambda, Lvd, LFVH.##)

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_all_steve(KGBElt x, ratvec lambda, LocalVertexData Lvd{, Param_hash Uhash}) = [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do big_unitary_hash.umatch(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, r = rank(x.involution -1), p0 = parameter(x,lambda,0*lambda)
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do big_unitary_hash.umatch(p)
	       	      od;
	       	      return(all)
	       fi
    then hts = next_heights(p0,edge_offset+1)
    then one_ht = hts[edge_offset]
    then () = test_string:= " using local_test_GEO_hash_all_steve"
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then LF2 = localFD_Steve2(x,lambda)
    then LFall = localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LF2, 2, r + 1, one_ht, Kpol_hash)
    then () = if one_two_reverse_flag
    	      then LFall := for list in LFall do [vec]: for v in list ~do v od od
	      fi
    then LFlast =  local_test_hash_steve(x, lambda, Lvd, LFall, one_ht)
    then () = if test_verbose
	      then prints("unitary to ht ",one_ht," face counts to dim ",r,
				": ", for list in LFlast do #list od)
	      fi
    then LFlastchars = extend_K_characters(x,lambda,Lvd,LFlast, Kpol_hash)
    in local_test_closer_steve(x, lambda, Lvd, LFlastchars)

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_steve_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd{, Param_hash Uhash}) =
    [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do big_unitary_hash.umatch(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do big_unitary_hash.umatch(p)
	       	      od;
	       	      return(all)
	       fi
    then () = test_string:= " using local_test_GEO_hash_steve_graph"
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then theta = x.involution, p0 = parameter(x,lambda,0*lambda)
    then (,Perm2) = LPm_table.LPm_entry(G, theta, ratvec_as_vec(lambda+theta*lambda))
    then hts = next_heights(p0,edge_offset+1)
    then FIRST_HT = hts[first_offset], ONE_HT = hts[edge_offset], r = rank(theta-1)
    then LF_first = localFD_1SteveU_graph(x, lambda, FIRST_HT, Lvd)
    then LF_one = if FIRST_HT = ONE_HT
    	 	  then LF_first
		  else local_test_graph_steve(x,lambda,Lvd, LF_first, ONE_HT)
		  fi
    {then () = prints(new_line, "LF_one = ",LF_one)}
    then LF01 = localFD_2SteveUgraph(x,lambda, ONE_HT, Lvd, Perm2, LF_one)
    {then () = prints("LF01 = ",LF01,new_line)}
    then LFcands = localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LF01, 2, r + 1, ONE_HT, Kpol_hash)
    then LFUcands = local_test_graph_steve(x, lambda, Lvd, LFcands.##, ONE_HT) {unitary to HT}
    {then () = prints("LFUcands = ",LFUcands)
    {then () = prints("at ",lambda,", #LFUcands = ",#LFUcands)}
    then () = prints(LFUcands)}
    then LFU = local_test_graph_steve(x,lambda,Lvd, LFUcands,-1)
    then unitary_by_dim = vec: null(rank(x.involution - 1)+1)
    then UParams = for v@j in LFU 
       	 	   do let d = #v - 3
       	  	      then verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
  	  	      then gamma = face_bary(Lvd,verts)
       	  	      then pC = parameter(x, lambda, gamma)
       	  	      then ps = [Param]: monomials(pC)
       	  	      in for p in ps
       	     	      	 do if deform_flag
		  	    then for q1d in local_face_defs(p).##
		       	     	 do big_unitary_hash.umatch(q1d)
		       		 od
		  	    else big_unitary_hash.umatch(p)
		  	    fi {deform_flag}
	     		 od;
	     		 unitary_by_dim[d]+:=1;
	     		 [pC]
    	     	   od.##
    in if test_verbose
       then prints("     Total of ", #LFU, " out of ", #LFUcands, " faces are unitary.")
       fi;
       if test_verbose or test_slightly_verbose
       then prints("unitary faces by dim = ",unitary_by_dim, test_string);
	    prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	    print_time_string(elapsed_ms() - start))
       fi;
       {report_steve_graph();}
       UParams
    {local_test_closer_steve(x, lambda, Lvd, LFUcands)}
    {closer_steve fails because steve_hash statuses haven't been updated properly}

set steve_graph_flag = false

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_steve(KGBElt x, ratvec lambda, LocalVertexData Lvd{, Param_hash Uhash},
    (Param -> bool) fancy_tester) = [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do big_unitary_hash.umatch(q)
		   od
	 in return [p]
    fi;
    if all_steve_flag
    then return local_test_GEO_hash_all_steve(x, lambda, Lvd{, Uhash})
    elif steve_graph_flag
    then return local_test_GEO_hash_steve_graph(x, lambda, Lvd{, Uhash})
    fi;
    let G = x.real_form
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do big_unitary_hash.umatch(p)
	       	      od;
	       	      return(all)
	       fi
    then () = test_string:= " using local_test_GEO_hash_steve"
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then LF2 = localFD_Steve2(x,lambda)
    in if steve_closer_flag
       then local_test_GEO_hash_steve_steve_end(x, lambda, Lvd, LF2, {Uhash,}
       (([[LocalFaceVertsKHash]])->[Param]): ([[LocalFaceVertsKHash]] LFlast): local_test_closer_steve(
       x,lambda, Lvd, LFlast))
       else local_test_GEO_hash_steve_end(x,lambda, Lvd, LF2{, Uhash})
       fi
