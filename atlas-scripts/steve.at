< basic {for infinitesimal character}
< aff_cube.at {for local_FPP_extrema}
< FPP_faces_herm.at {for unitarity tests}
< hash.at {for hash tables}
< FPP_localDirac.at { for |unipotents_to_hash| }
{<K_types.at {for branch_std}}
set red_coroots(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then pos_co = G.poscoroots
    then theta = p.x.involution
    in for alphav@j in pos_co
       do let gammaj = gamma*alphav
       	  in if is_integer(gammaj) and gammaj.>
       	     then if alphav*theta = -alphav and Cayley((G.posroots)[j],p) != p
   	     	  then [alphav] {parity real root}
	       	  else []
	       	  fi
	     elif ((theta*(gamma.numer))*alphav).<
	     then [alphav] {complex}
	     else []
	     fi
       od.##

set move_theta(WeylElt w) = ((KGBElt,ratvec) -> (KGBElt,ratvec)):
 (KGBElt x, ratvec lambda) (KGBElt,ratvec):
 let G = w.root_datum, x1 = cross(w,x) {added to next 7.29.25}
 then lambda_shift = rho_C(G,x1.involution) - w*rho_C(G, x.involution)
  then rhow = rho(G) - w*rho(G)
 then p1 = parameter(x1, w*lambda + rhow - lambda_shift, 0*lambda)
 in (p1.x, p1.lambda)


{should require number of -alphav*theta >= number of alphav}
set red_coroots(KGBElt x) = [vec]:
    let G = x.real_form,  theta = x.involution
    then rho = G.rho, pos_co = G.poscoroots
    in for alphav@j in pos_co
       do if (alphav*theta*rho).< and poscoroot_index(G, -alphav*theta) >= j
       	  then [alphav]
	  else []
	  fi
       od.##

{need to study reducibility along av at int values
from int to int inclusive}
set range(KGBElt x, ratvec lambda, vec av) = (int, int):
    let lfe = local_FPP_extrema(x,lambda)
    then vals = for w in lfe do av*w od
    in (floor(min(vals)), ceil(max(vals)))

{avL is meant to be a coroot in Lmin}
set rangeL(KGBElt x, ratvec lambda, vec avL) = (int, int):
    let (,pL0) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
    then lfe = local_FPP_extrema(x,lambda)
    then valsL = for w in lfe
    	       	 do let (,pwL) = theta_stable_quasi_data(parameter(x,lambda,w))
		    in avL*(pwL.infinitesimal_character)
		 od
    in (floor(min(valsL)), ceil(max(valsL)))

set ranges(KGBElt x, ratvec lambda) = [(vec, int, int)]:
    let rc = red_coroots(x)
    then lfe = local_FPP_extrema(x,lambda)
    in for av in rc
       do let vals = for w in lfe do av*w od
       	  in (av, floor(min(vals)), ceil(max(vals)))
       od

set rangesL(KGBElt x, ratvec lambda) = [(vec, int, int)]:
    let (,pL0) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
    then rcL = red_coroots(pL0.x)
    then lfe = local_FPP_extrema(x,lambda)
    in for avL in rcL
       do let (lowL,highL) = rangeL(x,lambda,avL)
       	  in (avL,lowL,highL)
       od

{root datum from all coroots restricting to A as multiple of av}
set Levix(KGBElt x, vec av) = (RealForm,KGBElt):
    let G = x.real_form, theta = x.involution
    then pos_r = G.posroots, pos_co = G.poscoroots
    then av_min_th = av - av*theta
    then js = for bv@j in pos_co
    	      do if rank([av_min_th,bv-bv*theta]) <=1
	      	 then [j]
		 else []
		 fi
	      od.##
     then two_rho_L = sum(G.rank, for j in js do pos_r[j] od)
     then min_js = for j in js
     	  	   do if pos_co[j]*two_rho_L = 2
		      then [j]
		      else []
		      fi
		   od.##
     then rdL = root_datum(mat: for j in min_js do pos_r[j] od,
     	      		   mat: for j in min_js do pos_co[j] od, G.prefers_coroots)
     {then tfL = x.torus_factor - G.rho_check + rdL.rho_check}
     then xL = KGB_elt(rdL, theta, x.torus_factor)
    in (real_form(xL),xL)

{given a matrix of roots and a matrix of coroots, choose a maximal set of orthogonal ones}
set orthogonal(mat roots, mat coroots) = ([vec],[vec]):
    let r = #(roots.^) {number of columns in root matrix}
    then entry(int p, int q) = int: 0
    then oroots = [vec]:[], perproots = [vec]: roots
    then ocoroots = oroots, perpcoroots = [vec]: coroots
    in while (#perproots).>
       do let tester = perproots~[0], cotester = perpcoroots~[0]
       	  {then () = prints("tester = ",tester,", cotester = ",cotester)}
       	  in oroots#:= tester;
       	  ocoroots#:= cotester;
	  perproots := for alpha in perproots do if (alpha*cotester).= then [alpha] else [] fi od.##;
	  perpcoroots := for av in perpcoroots do if (tester*av).= then [av] else [] fi od.##
       od;
       (oroots, ocoroots)

{given a matrix of roots and a matrix of coroots, choose sets of positive ones}
set pos_choice(mat roots, mat coroots) = ([vec],[vec]):
    let (O,cO) = orthogonal(roots,coroots)
    then levels = [int]: for alpha in roots
    	 	  	 do first(for cotester in cO
			    	  do (alpha*cotester).!=
				  od)
			 od
    in (for alpha@j in roots
       do if (alpha*cO[levels[j]]).>
       	  then [alpha]
	  else []
	  fi
       od.##,
       for av@j in coroots
       do if (av*O[levels[j]]).>
       	  then [av]
	  else []
	  fi
       od.##)

{given a matrix of roots and a matrix of coroots, sets of simple ones}
set simp_choice(mat roots, mat coroots) = ([vec],[vec]):
    if #roots = 0 then return ([],[]) fi;
    let (PR,cPR) = pos_choice(roots,coroots)
    then tworhocheck = sum(#cPR[0],cPR)
    then simplejs = for alpha@j in PR
       	 	    do if alpha*tworhocheck = 2
       	  	       then [j]
	  	       else []
	  	       fi
       		    od.##
    in (for j in simplejs
       	do PR[j]
	od,
	for j in simplejs
       	do cPR[j]
	od)



{assume x.involution has maximal -1 eigenspace a; construct restricted root datum on a}
set res_stuff(KGBElt x) = ([vec],[vec]):
    let theta = x.involution, G = x.real_form
    then () = assert(@:rank(1-theta) = split_rank(G), "x was not on max split Cartan")
    then T_lower_star = mat: eigen_lattice(theta.^,-1)
    then res_coroot_hash = make_vec_hash()
    then res_root_hash = make_vec_hash()
    then () = for av@j in G.coroots
    	      do let avres = av - av*theta
		 in if avres = 2*av
		    then let resav= required_solution(T_lower_star,av) {real coroots}
		    	 in res_coroot_hash.match(resav);
		    	    res_root_hash.match(G.roots[j]*T_lower_star)
		    elif avres.= or is_coroot(G,avres) {omit imaginary and half of real}
		    then -1
		    else let resav= required_solution(T_lower_star,avres) {complex coroots}
		    	 in res_coroot_hash.match(resav);
			    res_root_hash.match(G.roots[j]*T_lower_star)
		    fi
	       od
     in (res_root_hash.list(), res_coroot_hash.list())

set res_root_old_flag = false {the hashed version below is just uniformly faster}

set res_root_datum_old(KGBElt x) = RootDatum:
    let (roo,coroo) = res_stuff(x)
    then (sroo,scoroo) = simp_choice(roo,coroo)
    in root_datum(sroo, scoroo, x.real_form.prefers_coroots)

set res_root_datum = (KGBElt -> RootDatum):
    let rfhash = make_RealForm_hash()
    then KGBhashes = [KGBElt_hash]: [] {one hash for each real form}
    then answerhash = make_RootDatum_hash()
    then answer_indices = [vec]: [] {one list of rd indices for each real form,
    	 		  	     size = KGBhash[i].size()}
    in (KGBElt -> RootDatum): (KGBElt x) RootDatum:
       if res_root_old_flag then return res_root_datum_old(x) fi;
       let I = rfhash.size()
       then i = rfhash.match(x.real_form)
       then () = if i = I {haven't seen G before}
       	       	 then KGBhashes #:=make_KGBElt_hash();
	       	      answer_indices #:= null(0)
	  	 fi
       then J = KGBhashes[i].size(), K = answerhash.size()
       then j = KGBhashes[i].match(x)
       then () = if j = J {haven't seen x before}
       	       	 then let (roo,coroo) = res_stuff(x)
    		      then (sroo,scoroo) = simp_choice(roo,coroo)
    		      then k = answerhash.match(root_datum(sroo, scoroo, x.real_form.prefers_coroots))
		      in answer_indices[i] #:= k
		 fi
       in answerhash.index(answer_indices[i][j])

set res_root_datum(RealForm G) = RootDatum:
    res_root_datum(x_open(G))

set simpTimer = int:0

{assume roots for L are rational linearly closed in roots for G, and
L-positive are G-positive; conjugate L to standard Levi}

{Result (w,xi). Assume is L is Levi of nonstandard REAL P at x,
carried by w from standard real Levi at z1}
set simplifier_theta(RootDatum L, KGBElt x) = (WeylElt, KGBElt):
    {if old_simplifier_theta_flag then return simplifier_theta_old(L,x) fi;}
    let start = elapsed_ms(), rd = x.root_datum,  thetamin = (1 - x.involution)
    then S = for a in L.simple_coroots do coroot_index(rd,a) od
    then T = maximize_Levi(rd,S)
    then A = (Levi_simple_coroots(rd,T)), k = #S
    then wt_theta = thetamin*((A,vector(rd.semisimple_rank,(int i)int:#(i>=k)*2^i)/1).required_solution.numer)
    {The powers of two are just a garbage way to make it usually work. Don't know how actually to
    fix it.}
    then (w,wt_theta_dom) = from_dominant(rd,wt_theta)
    then x1 = cross(w.inverse,x)
    in simpTimer+:= elapsed_ms() - start;
       (w,x1)

{Result (w,xi). Assume is L is Levi of nonstandard REAL P at x,
carried by w from standard real Levi at z1}
{w needs to account for difference between xL and xLo??}
set simplifier_theta_res(RealForm L, KGBElt x) = (WeylElt, KGBElt):
    {if old_simplifier_theta_flag then return simplifier_theta_old(L,x) fi;}
    let start = elapsed_ms(), rd = x.root_datum,  thetamin = (1 - x.involution), G = x.real_form
    then xL = inverse_embed_KGB(x,L)
    then xLo = x_open(L)
    then xo = embed_KGB(xLo,G)
    then thetao  = xo.involution
    then M = eigen_lattice(thetao.^,-1)
    then rdo = res_root_datum(xo)
    then rdoL = res_root_datum(xLo)
    then S = for a in rdoL.simple_coroots do coroot_index(rdo,a) od
    then T = maximize_Levi(rdo,S)
    then A = (Levi_simple_coroots(rdo,T)), k = #S
    then wt_theta_res = ((A,vector(rdo.semisimple_rank,(int i)int:#(i>=k))/1).required_solution.numer)
    then wt_thetao = (1-thetao)*(required_solution(M.^, wt_theta_res)) {guaranteed to cut out L}
    then (w,) = from_dominant(G,wt_thetao)
    then {x1 = cross(w.inverse,xo),} L1 = (w.inverse)*L
    then xL1 = KGB(L1, xL.number)
    then x1 = embed_KGB(xL1,G)
    in simpTimer+:= elapsed_ms() - start;
       (w,x1)

set simplifier_res_flag = true

set standardize(KGBElt x, ratvec lambda, vec av) = (KGBElt, ratvec, vec):
    let (L,) = Levix(x,av), G = x.real_form
    then (y,x1) = if simplifier_res_flag
    	 	  then simplifier_theta_res(L,x)
		  else simplifier_theta(L,x)
		  fi
    {then () = prints("y = ",y)}
    in let (x1m,lambda1) = move_theta(y.inverse)(x,lambda)
        {then () = assert(x1m = x1,"problem with move in standardize")
       then () = assert(1*parameter(x,lambda,0*lambda) = 1*parameter(x1,lambda1,0*lambda1),
       	       	 "problem with x1 and lambda1 in standardize")}
       in (x1,lambda1, av*y)

{parameter on nonstandard Levi L}
set pL(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    let (L,xL) = Levix(x,av), G = x.real_form, theta = x.involution
    then m = coroot_index(G,av) + #G.posroots, {lambdaL = lambda-rho(G) + rho(L)}
    	 lambda_shift = -rho(G) +rho(L) + rho_C(G,theta) - rho_C(L,theta)
    then a = roots(G)[m], lambdaL = lambda + lambda_shift
    then nu1 = (a-theta*a)
    then wt = av*nu1, shift = av*(lambdaL+theta*lambdaL)/2
    in parameter(xL,lambdaL, ((t-shift)/wt)*nu1)
{inf char = (lambdaL + theta*lambdaL)/2 + (t-shift)/wt)*nu1)}
{value on av is shift + (t-shift)}
{shift adjusts so pairing of av with L infl char is t}

{ rep on minimal real Levi through complex coroot av}
set pL1(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    {if steve_old_flag then return pL1_old(x, lambda, av, t) fi;}
    let (x1,lambda1, av1) = standardize(x,lambda,av)
    in pL(x1,lambda1,av1,t)

set std_quo(Param p) = ParamPol:
    1*p-character_formula(1*p)

set steve_new_flag = true

set ind_quo_new(KGBElt x, ratvec lambda, vec av, rat t) = KTypePol:
    let pL = pL(x,lambda,av,t)
    in K_type_pol(std_quo(pL))

set ind_quo(KGBElt x, ratvec lambda, vec av, rat t) = KTypePol:
    if steve_new_flag
    then return ind_quo_new(x,lambda,av,t)
    fi;
    let pL1 = pL1(x,lambda,av,t)
    {then () = assert(dominant(x.real_form,pL.infinitesimal_character) =
    	 dominant(x.real_form, pL1.infinitesimal_character),"bad infl char for pL1")
    then () = assert(#character_formula(1*pL) = (#character_formula(1*pL1)),
    "bad char for pL1")}
    in real_induce_standard(K_type_pol(std_quo(pL1)), x.real_form)

set to_ht_G(RealForm G, KTypePol QL, int HT) = KTypePol:
    if HT.< then return QL fi;
    sum(QL.real_form,
	for c@tauL in QL
    	do if dominant(G,parameter(tauL).d_lambda)*(G.two_rho_check) <= HT
	   then c*tauL
	   else 0*tauL
	   fi
	od)

set to_ht_G(RealForm G, KTypePol QL, int HT) = KTypePol:
    if HT.< then return QL fi;
    sum(QL.real_form,
	for c@tauL in QL
    	do if dominant(G,parameter(tauL).d_lambda)*(G.two_rho_check) <= HT
	   then c*tauL
	   else 0*tauL
	   fi
	od)

set test_new(KGBElt x, ratvec lambda, vec av, rat t, int HT) = bool:
    let QL = ind_quo_new(x,lambda,av,t)
    in to_ht_G(x.real_form, QL,HT).!=

{given a reducibility coroot av, take generic point on hyperplane
av*gamma = t, corresponding Q(t) = std/Langlands quotient, and ask
whether Q(t) has terms of height at most HT}
{works for HT < 0, telling whether Q(t).!=}
set test(KGBElt x, ratvec lambda, vec av, rat t, int HT) = bool:
    if steve_new_flag
    then return test_new(x,lambda,av,t,HT)
    fi;
    let Q = ind_quo(x, lambda, av, t) {probably on L1}
    {then QL = std_quo(pL(x,lambda,av,t))
    then () = assert((Q.=) = (QL.=),"bad induction!")}
    in to_ht(Q,HT).!=

set red_points_time = int:0

{works for HT < 0, giving all reducibility points}
{omitting the singular real roots gives 2 too many unitary in Sp(6,R)}
set red_points(KGBElt x, ratvec lambda, vec av, int HT) = [int]:
    let start = elapsed_ms(), (m,M) = range(x,lambda,av), thetapl = x.involution+1
    then ans = for j:M-m+1 from m
       	       do if test(x,lambda,av,j,HT) {or ((av*thetapl).= and j.=)}
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_time +:= elapsed_ms() - start;
     	ans

set red_points(KGBElt x,ratvec lambda, int HT) = [[int]]:
    for av in red_coroots(x)
    do red_points(x,lambda,av,HT)
    od

set red_pointsL(KGBElt x, ratvec lambda, vec avL, int HTL) = [int]:
    let (,pL0) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
    then start = elapsed_ms(), (mL,ML) = rangeL(x,lambda,avL){, thetapl = x.involution+1}
    then ans = for j:ML-mL+1 from mL
       	       do if test(pL0.x, pL0.lambda, avL, j, HTL) {or ((av*thetapl).= and j.=)}
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_time +:= elapsed_ms() - start;
     	ans

set red_pointsL(KGBElt x,ratvec lambda, int HTL) = [[int]]:
    let (,pL0) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
    in for avL in red_coroots(pL0.x)
    do red_pointsL(x,lambda,avL,HTL)
    od

{record location of rat t with respect to strictly increasing
sequence of M ints red_pts by integer from -1 to 2M.
0 means red_pts is empty; 0 means smaller than any, 2M means larger than any;
2j}
{ range [0..2*#a]; a[i]=r -> 2i+1; even number: r absent }
set location([int] a,rat t) = int:
    let loc = locate_sorted(a,ceil(t)) { first with |a[loc]>=t| }
    in if loc=#a
       then 2*loc
       elif a[loc]=t then 2*loc+1
       else 2*loc
       fi

set location(KGBElt x, ratvec lambda, vec av,int HT, rat t) = int:
    let rp = red_points(x,lambda,av,HT)
    in location(rp,t)

set thruple(KGBElt x, ratvec lambda,int HT, ratvec gamma) = vec:
    for av in red_coroots(x)
    do location(x,lambda,av,HT,av*gamma)
    od

set thruple([vec] red_co, [[int]] red_pts, ratvec gamma) = vec:
    for av@j in red_co
    do location(red_pts[j],av*gamma)
    od

set is_def_thr(vec base_thr, vec def_thr) = bool:
    (def_thr != base_thr) and
    all(for x@j in base_thr
        do @bool: (is_odd(x) and def_thr[j] = x)
	   	  or(is_even(x) and abs(def_thr[j] - x) <= 1)
	od)

{set is_def_intervals(vec thruple) = [[int]]:
    for x in thruple
    do [int]:
       if is_odd(x) then [x]
       elif x.= then [x,x+1]
       else [x-1,x,x+1]
       fi
    od}

{set is_def_testers(vec thruple) = [(int -> bool)]:
    for x in thruple
    do (int y) bool:
       if is_odd(x)
       then x=y
       else let d = x-y
       	    in d=1 or d=0 or d=-1
       fi
    od}

{set is_def_testers(vec thruple) = [(int -> bool)]:
    for x in thruple
    do (int y) bool:
       if is_odd(x)
       then x=y
       else case x-y+1
       	    in true,true,true
	    else false
	    esac
       fi
    od}

{set is_def_testers(vec thruple) = [(int -> bool)]:
    for x in thruple
    do (int y) bool:
       let d = x-y
       in if is_odd(x)
       	  then d.=
       	  else case d+1
       	       in true,true,true
	       else false
	       esac
       	  fi
    od}

{set is_def_testerA(vec thruple) = (vec -> bool):
    (vec v): bool:
    let def_tests = is_def_testers(thruple)
    in all(for y@i in v do @bool: def_tests[i](y) od)}

{seems to be about half as fast as def_testerA}
{set is_def_testerB(vec thruple) = (vec -> bool):
    (vec v): bool:
    let def_ints = is_def_intervals(thruple)
    in all(for def_int@i in  is_def_intervals(thruple)
       	   do @bool: is_member_sorted(def_int)(v[i])
	   od)}

{This is 30% faster than commented out def_testerA above}
set is_def_tester(vec thruple) = (vec -> bool):
    (vec v): bool:
    all(for x@j in thruple
    	do @bool: (1+x%2)*abs(x-v[j]) <= 1
	od)

set taus(KGBElt x, ratvec lambda, int HT) = [KType]:
    monomials(branch(K_type_pol(parameter(x,lambda,0*lambda)),HT))

set pos_tester(KGBElt x, ratvec lambda,int HT,ratvec gamma) = bool:
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in all(for q in qs do @bool: is_unitary_to_ht_big_SIMPLE_old(q,HT) od)

{should be called only if height(x,lambda,0) > 0 and HT >= minBottomData.G_min_height(x,lambda)}
set pos_tester_min(KGBElt x, ratvec lambda,int HT,ratvec gamma) = bool:
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in {prints("got to pos_tester_min at ",p);}
       if not all(for q in qs do @bool: min_bottom_elim_factors(q,p,HT) od)
       then {prints("got to pos_tester_min at ",p," and bottom worked!");}
       	    return false
       fi;
       all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE_old(q,HT) od)


{compute vectors of size 2 giving [index of K-char, #Langlands quotients]}
set extra_coord_flag = true

{try deforming loc to a known one}
set deform_loc_flag = true

{try deforming loc to a known nonunitary one}
set deform_nonu_flag = true

set do_not_use_deform_steve() = void:
    extra_coord_flag:=false;
    deform_loc_flag:=false;
    deform_nonu_flag:=false

set use_deform_nonu_steve() = void:
    extra_coord_flag:=false;
    deform_nonu_flag:=true;
    deform_loc_flag:=false

{USE Kpol_hash defined in FPP_faces_geom.at; assume index od }
set pos_tester_known_Kchar(KGBElt x, ratvec lambda,int HT,ratvec gamma, vec KCv) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in if extra_coord_flag
       then (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),KCv)
       else (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),[])
       fi

{USE Kpol_hash defined in FPP_faces_geom.at}
set pos_tester_Kchar(KGBElt x, ratvec lambda,int HT,ratvec gamma) = (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in if extra_coord_flag
       then (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),
       	    [Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT))),#qs])
       else (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),[])
       fi

{should only be invoked if height(x,lambda)>0 and HT >= minBottomData.G_min_height(x,lambda)}
{SHOULD USE KNOWN Kchar KCv[0] if possible}
{USE Kpol_hash defined in FPP_faces_geom.at; assume index od }
set pos_tester_known_Kchar_min(KGBElt x, ratvec lambda,int HT,ratvec gamma, vec KCv) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in {prints("got to pos_tester_known_Kchar_min");}
       if not all(for q in qs do @bool: min_bottom_elim_factors(q,p,HT) od)
       then {prints("got to pos_tester_known_Kchar_min at ",p," and bottom worked!");}
       	    return if extra_coord_flag
       	    	   then (false,KCv)
		   else (false,[])
		   fi
       fi;
       if extra_coord_flag
       then (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),KCv)
       else (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),[])
       fi

{USE Kpol_hash defined in FPP_faces_geom.at}
set pos_tester_Kchar_min(KGBElt x, ratvec lambda,int HT,ratvec gamma) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in {prints("got to pos_tester_Kchar_min at ",p,"...");}
       if not all(for q in qs do @bool: min_bottom_elim_factors(q,p,HT) od)
       then {prints("...and bottom worked!");}
       	    return if extra_coord_flag
       	    	   then (false,[Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT))),#qs])
		   else (false,[])
		   fi
       fi;
       if extra_coord_flag
       then (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),
       	    [Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT))),#qs])
       else (all (for q in qs do @bool: is_unitary_to_ht_big_SIMPLE(q,HT) od),[])
       fi

set Kchar_vec_time = int: 0

set Kchar_vec(KGBElt x, ratvec lambda, int HT, ratvec gamma) = vec:
    let start = elapsed_ms(), p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    then answer = if extra_coord_flag
       	 	  then [Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT))),#qs]
       		  else []
       		  fi
    in Kchar_vec_time +:= elapsed_ms() - start;
       answer

set report_def_thruples() = void:
    prints(print_time_string(def_thruples_time)," to find deformed thruple candidates.");
    prints("Found ",hash_def_true_count," deformations proving unitarity (to height), ",
    	   hash_def_false_count," deformations proving nonunitarity (to height).")

set_type
[steve_hash_table =
( ( -> ) clear {clear the table}
  , ((KGBElt, ratvec) ->) clear_xl {clear the tsbles for (x,lambda)}
  , ( -> int) real_form_size {number of real forms included}
  , ( -> vec) xlhash_sizes {for every real form, the number of pairs(x,lambda)}
{  , ( -> vec) K_type_sizes {number of KTypes for each real form}}
  , ((KGBElt, ratvec) -> vec) heights {list of heights to which reducibility has been studied}
  , ((KGBElt, ratvec, int) -> (int, int, int)) indices {rfnum, xlnum, htnum}
  {, ((KGBElt, ratvec, vec, int) -> KTypePol) ind_quo} {like function ind_quo, but storing answers}
  {, ((KGBElt, ratvec, vec, int, int) -> bool) test} {like function test}
  , ((KGBElt, ratvec, int) -> vec_hash) vecHash {hash table of location vecs known}
  , ((KGBElt, ratvec, int) -> [[int]]) red_points {for each reducibility coroot, list of reducibility points}
  , ((KGBElt, ratvec, int) -> [bool]) postests {size vecHash.size(), listing unitarity results}
  , ((KGBElt, ratvec, int) -> [vec]) extra_coords {size vecHash.size():
  [Kchar #, #LQs] if extra_coord_flag, [] else}
  , ((int, int, int, ratvec, vec) -> bool) partly_indexed_postest_known_Kchar
  , ((KGBElt, ratvec, int, ratvec, vec) -> bool) postest_known_Kchar {test param(x,lambda,last_arg) for unitarity to ht}
  , ((int, int, int, int) -> bool) indexed_postest {known rfnum, xlnum, htnum, vecnum}
  , ((int, int, int, ratvec) -> bool) partly_indexed_postest
  , ((KGBElt, ratvec, int, ratvec) -> bool) postest {test param(x,lambda,last_arg) for unitarity to ht}
  , ((KGBElt, ratvec, int, ratvec) -> vec) extra_coord {index of Kchar of param(x,lambda,last_arg) to ht, #LQs}
  , ((int, int, int, ratvec, vec) -> vec) indexed_thruple_known_Kchar {known rfnum, xlnum, htnum}
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec) thruple_known_Kchar {loc vec: (x,lambda,gamma) to HT}
  , ((int, int, int, ratvec) -> vec) indexed_thruple {known rfnum, xlnum, htnum}
  , ((KGBElt, ratvec, int, ratvec) -> vec) thruple {loc vec: (x,lambda,gamma) to HT}
  , ((int, int, int, ratvec, vec) -> vec) indexed_thruple_known_Kchar_no_stat {known rfnum, xlnum, htnum; don't compute status}
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec) thruple_known_Kchar_no_stat {loc vec: (x,lambda,gamma) to HT; don't compute status}
  , ((int, int, int, ratvec) -> vec) indexed_thruple_no_stat {known rfnum, xlnum, htnum; don't compute status}
  , ((KGBElt, ratvec, int, ratvec) -> vec) thruple_no_stat {loc vec: (x,lambda,gamma) to HT; don't compute status}
)
]

set make_steve_hash() = steve_hash_table:
(   let real_form_hash = make_RealForm_hash()
    {then K_type_hashes = [KType_hash] : [] {one for each real form; list of KTs considered}}
    then xlhashes = [xlambda_hash]: [] {one for each real form}
    {then paramhashes = [[Param_hash]]: []} {one for each entry in each xlhash}
    {then ktps = [[[KTypePol]]]: []} {one for each entry in each paramhash: ind_quo?}
    then heights = [[vec]]:[] {one for each entry in each xlhash}
    then vechashes = [[[vec_hash]]]:[] {one for each height for each entry in each xlhash}
    then redpoints = [[[[int]]]]:[] {for each entry in xlhash and height, [int] = bitmap of reducibility
    	 	     		  points for each reducibility coroot}
    then statuses = [[[[bool]]]]:[] {one [bool] for each vechash}
    then charvecs = [[[[vec]]]]: [] {one [vec] for each vechash; possibly [index of K_char, #LQs]}
    then clearSH() = void:
    	 let () = real_form_hash.clear()
	 {then () = K_type_hashes:=[]}
	 then () = xlhashes:=[]
	 {then () = paramhashes:=[]}
	 {then () = ktps:=[]}
	 then () = heights:=[]
	 then () = vechashes:=[]
	 then () = statuses:=[]
	 then () = charvecs:=[]
	 then () = redpoints := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then	{K_type_hashes #:= make_KType_hash();}
		        xlhashes #:= make_xlambda_hash();
			{paramhashes #:= ([Param_hash]:[]);}
			{ktps #:= ([[KTypePol]]:[]);}
			heights   #:= ([vec]:[]);
			vechashes #:= ([[vec_hash]]:[]);
			statuses  #:= ([[[bool]]]:[]);
			redpoints #:= ([[[int]]]:[]);
			charvecs  #:= ([[[vec]]]:[]);
			assert(@:real_form_hash.size() = {#K_type_hashes and} #xlhashes {= #K_type_hashes} and
	       	    	   #heights = #xlhashes and #vechashes = #heights and #statuses = #heights and
			   #redpoints = #heights, "steve_hash damaged on adding real form")
	    	   fi
	  in i
    {then add_K_type(KType mu) = (int, int): {real form index, K type index}
   	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf,1*mu))}
	 {then KTYPENUM = K_type_hashes[rfnum].size()}
	 in (rfnum, K_type_hashes[rfnum].match(mu))}
    then add_xl(KGBElt x, ratvec lambda) = (int,int): {real form index, xlhash index}
    	 let rfnum = add_real_form(x.real_form)
	 then XLNUM = xlhashes[rfnum].size()
	 then xlnum = xlhashes[rfnum].match(x,lambda)
	 in if xlnum = XLNUM {new (x,lambda)}
	    then {paramhashes[rfnum] #:= make_Param_hash();}
	    	 {ktps[rfnum] #:= ([KTypePol]:[]);}
		 heights[rfnum]#:=null(0);
	    { add empty list of lists of reducibility points for the new height}
	    	 redpoints[rfnum] #:= ([[int]]:[]);
		 vechashes[rfnum]#:=([vec_hash]:[]);
		 statuses[rfnum]#:=([[bool]]:[]);
		 charvecs[rfnum]#:=([[vec]]:[])
	    fi;
	    (rfnum,xlnum)
    {then add_xlp(Param qL, RealForm G) = (int,int,int): {real form index, xlhash index, param index}
    	 let (rfnum,xlnum) = add_xl(qL.x, qL.lambda)
	 then PLNUM = paramhashes[rfnum][xlnum].size()
	 then pLnum = paramhashes[rfnum][xlnum].match(qL)
	 in if pLnum = PLNUM {new pL}
	    then let ktpsr = ktps[rfnum] {[[KTypePol]]},
	    	     ktpsrxl = ktps[rfnum][xlnum] {[KTypePol]}
	    	 then () = ktpsrxl#:= real_induce_standard(K_type_pol(std_quo(qL)), G)
		 then () = ktpsr[xlnum]:=ktpsrxl
		 then () = ktps[rfnum]:=ktpsr
		 in ()
	     fi;
	     (rfnum, xlnum, pLnum)}
    {then SHind_quo(KGBElt x, ratvec lambda, vec av, int m) = KTypePol:
    	let qL1 = pL1(x,lambda,av, m)
    	then (rfnum, xlnum, pLnum) = add_xlp(qL1, x.real_form)
	in ktps[rfnum][xlnum][pLnum]}
    {then SHtest(KGBElt x, ratvec lambda, vec av, int m, int HT) = bool:
    	 let SHIQ = SHind_quo(x,lambda,av,m)
	 in to_ht(SHIQ,HT).!=}
    {then SHred_points(KGBElt x, ratvec lambda, vec av,int HT) = [int]:
    	 let (m,M) = range(x,lambda,av), thetapl = x.involution+1
    	 in for j:M-m+1 from m
       	    do if SHtest(x,lambda,av,j,HT)
       	       then [j]
	       else []
	       fi
       	    od.##}
    {then SHred_points_list(KGBElt x,ratvec lambda, int HT) = [[int]]:
    	 let start = elapsed_ms()
    	 then ans = for av in red_coroots(x)
    	      	    do SHred_points(x,lambda,av,HT)
    	 	    od
	 in red_points_time +:= elapsed_ms() - start;
	    ans}
    then add_xlht(KGBElt x, ratvec lambda, int HT) = (int,int,int): {real form index, xlhash index, HT index}
    	 let (rfnum,xlnum) = add_xl(x,lambda)
	 then J = #heights[rfnum][xlnum], htnum = find(heights[rfnum][xlnum],HT)
	 in if htnum.< {new HT}
	    then let hrxl = heights[rfnum][xlnum], {[[int]]}
	    	     hr = heights[rfnum]
	    	 then () = hrxl#:= HT
		 then () = hr[xlnum]:=hrxl
		 then () = heights[rfnum]:=hr
		 then rprxl = redpoints[rfnum][xlnum], rpr = redpoints[rfnum]
		 then () = rprxl #:= for list in red_points(x,lambda,HT) do to_bitset(list) od
		      {add a new [int]}
		 then () = rpr[xlnum]:=rprxl
		 then () = redpoints[rfnum]:=rpr
		 then vhsxl = vechashes[rfnum][xlnum], vhsr = vechashes[rfnum]
		 then () = vhsxl #:= make_vec_hash()
		 		      {add a new vec_hash for new height}
		 then () = vhsr[xlnum]:=vhsxl
		 then () = vechashes[rfnum]:=vhsr
		 then statusxl = statuses[rfnum][xlnum], statusr = statuses[rfnum]
		 then () = statusxl #:= ([bool]:[]) { for this height }
		 then () = statusr[xlnum]:=statusxl
		 then () = statuses[rfnum]:=statusr
		 then charvecxl = charvecs[rfnum][xlnum], charvecr = charvecs[rfnum]
		 then () = charvecxl #:= ([vec]:[]) { for this height }
		 then () = charvecr[xlnum]:=charvecxl
		 then () = charvecs[rfnum]:=charvecr
		 in htnum:= J
	    fi;
	    (rfnum,xlnum,htnum)
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_plain_indexed(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then (boo,v) = pos_tester_Kchar(x, lambda, HT, gamma)
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_plain(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int, int, int, int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
	 in (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
	 {Following version checks deformations}
    then SHthruple_indexed_known_Kchar(int rfnum, int xlnum, int htnum, ratvec gamma, vec Kcv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechashes[rfnum][xlnum][htnum].list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[rfnum][xlnum][htnum][m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[rfnum][xlnum][htnum][m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then () = if (#v).=
			     	  then boo:= pos_tester(x, lambda, HT, gamma);
				       v:=Kcv
				  fi
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
    then SHthruple_indexed(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then Kcv = Kchar_vec(x,lambda,HT,gamma)
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechashes[rfnum][xlnum][htnum].list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[rfnum][xlnum][htnum][m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[rfnum][xlnum][htnum][m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then () = if (#v).=
			     	  then boo:= pos_tester(x, lambda, HT, gamma);
				       v:=Kcv
				  fi
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum

    then SHthruple(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int,int,int,int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
	 in if (deform_loc_flag or deform_nonu_flag)
	    then (rfnum, xlnum, htnum, SHthruple_indexed(rfnum, xlnum, htnum, gamma))
	    else (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	    fi
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
{      then check() = void:
      	   assert(real_form_hash.size() = xlhashes.size(),"wrong rf/xl hash sizes");
      	   for rf@rfnum in real_form_hash.list()
	   do assert(xlhashes[rfnum].size() = #heights[rfnum], "wrong xl/hts sizes");
	      for xl@xlnum in xlhashes[rfnum]
	      do assert(#heights[rfnum][xlnum] = }
    then SHthruple_indexed_known_Kchar_no_stat(int rfnum, int xlnum, int htnum, ratvec gamma,
    vec KCv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then () = charvecxlht#:=KCv
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
    then SHthruple_indexed_no_stat(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots(x)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then KCv = Kchar_vec(x,lambda,HT,gamma)
			then () = charvecxlht#:=KCv
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
    then SHthruple_no_stat(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int,int,int,int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT) {, start_count = unitary_test_counter.use_count()}
	 in if (deform_loc_flag or deform_nonu_flag)
	    then (rfnum, xlnum, htnum, SHthruple_indexed_no_stat(rfnum, xlnum, htnum, gamma))
	    else (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	    fi
	 {in prints("no_stat used ", unitary_test_counter.use_count() - start_count, " unitarity tests.")
	     ;ans}
      in
  ( ( -> ): {clear} clearSH
  , ((KGBElt, ratvec) ->): {clear_xl} (KGBElt x, ratvec lambda) void:
    let rfnum = real_form_hash.lookup(x.real_form)
    then () = if rfnum.< then return () fi
    then xlnum = xlhashes[rfnum].lookup(x,lambda)
    then () = if xlnum.< then return () fi
    then heightsrf = heights[rfnum], vechsrf = vechashes[rfnum], redptsrf = redpoints[rfnum],
    	 statrf = statuses[rfnum], charvecsrf = charvecs[rfnum]
    in heightsrf[xlnum]:=[];
       vechsrf[xlnum]:=[];
       redptsrf[xlnum]:=[];
       statrf[xlnum]:=[];
       charvecsrf[xlnum]:=[];
       heights[rfnum]:=heightsrf;
       vechashes[rfnum]:=vechsrf;
       redpoints[rfnum]:=redptsrf;
       statuses[rfnum]:= statrf;
       charvecs[rfnum]:=charvecsrf
  , ( -> int): {real_form_size} @int: real_form_hash.size()
  , ( -> vec): {xlhash_sizes} @vec: for xlhash in xlhashes do xlhash.size() od
  {, ( -> vec): {K_type_sizes} @vec: for Khash in K_type_hashes do Khash.size() od}
  , ((KGBElt, ratvec) -> vec): {heights} (KGBElt x, ratvec lambda) vec:
    let (rfnum, xlnum) = add_xl(x,lambda)
    in heights[rfnum][xlnum]
  , ((KGBElt, ratvec, int) -> (int, int, int)): {indices} (KGBElt x, ratvec lambda, int HT) (int, int, int):
    add_xlht(x,lambda,HT)
  {, ((KGBElt, ratvec, vec, int) -> KTypePol): {ind_quo} (KGBElt x, ratvec lambda, vec av, int m) KTypePol:
    let qL = pL1(x,lambda,av,m/1)
    then (rfnum, xlnum, paramnum) = add_xlp(qL, x.real_form)
    in ktps[rfnum][xlnum][paramnum]}
  {, ((KGBElt, ratvec, vec, int, int) -> bool): {test} (KGBElt x, ratvec lambda, vec av, int m, int HT) bool:
    let Q = SHind_quo(x, lambda, av, m)
    in to_ht(Q,HT).!=}
  , ((KGBElt, ratvec, int) -> vec_hash): {vecHash} (KGBElt x, ratvec lambda, int HT) vec_hash:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in vechashes[rfnum][xlnum][htnum]
  , ((KGBElt, ratvec, int) -> [[int]]): {red_points} (KGBElt x, ratvec lambda, int HT) [[int]]:
    {SHred_points(x,lambda,HT)}
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in for M in redpoints[rfnum][xlnum][htnum]
       do set_bit_positions(M)
       od
  , ((KGBElt, ratvec, int) -> [bool]): {postests} (KGBElt x, ratvec lambda, int HT) [bool]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in statuses[rfnum][xlnum][htnum]
  , ((KGBElt, ratvec, int) -> [vec]): {extra_coords} (KGBElt x, ratvec lambda, int HT) [vec]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in charvecs[rfnum][xlnum][htnum]
  , ((int, int, int, ratvec, vec) -> bool): {partly_indexed_postest_known_Kchar}
    (int rfnum, int xlnum, int htnum, ratvec gamma, vec KCv) bool:
    let vecnum = SHthruple_indexed_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec, vec) -> bool): {postest_known_Kchar} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma, vec KCv) bool:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, int) -> bool): {indexed_postest} (int rfnum, int xlnum, int htnum, int vecnum) bool:
    statuses[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, ratvec) -> bool): {partly_indexed_postest} (int rfnum, int xlnum, int htnum,
    ratvec gamma) bool:
    let vecnum = SHthruple_indexed(rfnum, xlnum, htnum, gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec) -> bool): {postest} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) bool:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec) -> vec): {extra_coord} (KGBElt x, ratvec lambda,
    int HT, ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in charvecs[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, ratvec, vec) -> vec): {indexed_thruple_known_Kchar} (int rfnum, int xlnum, int htnum,
    ratvec gamma, vec KCv) vec:
    let vecnum = SHthruple_indexed_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec): {thruple_known_Kchar} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma, vec KCv) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec) -> vec): {indexed_thruple} (int rfnum, int xlnum, int htnum,
    ratvec gamma) vec:
    let vecnum = SHthruple_indexed(rfnum, xlnum, htnum, gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec) -> vec): {thruple} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec, vec) -> vec): {indexed_thruple_known_Kchar_no_stat} (int rfnum, int
    xlnum, int htnum, ratvec gamma, vec KCv) vec:
    let vecnum = SHthruple_indexed_known_Kchar_no_stat(rfnum, xlnum, htnum, gamma, KCv)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec): {thruple_known_Kchar_no_stat} (KGBElt x, ratvec
    lambda, int HT, ratvec gamma, vec KCv) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple_no_stat(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec) -> vec): {indexed_thruple_no_stat} (int rfnum, int xlnum, int htnum,
    ratvec gamma) vec:
    let vecnum = SHthruple_indexed_no_stat(rfnum, xlnum, htnum, gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec) -> vec): {thruple_no_stat} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple_no_stat(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  )
)

set steve_hash = make_steve_hash()

{meant to hold data for one (x,lambda,HT)}
set_type
[steve_hash_small_table =
( ( -> ) clear {clear the table}
  , ((KGBElt, ratvec, int) ->) reset_with_ht {change to new (x,lambda,HT)}
  , ((KGBElt, ratvec) ->) reset {erase old}
  {, ( -> vec) heights {list of heights to which reducibility has been studied}}
  {, (int -> int) ht_index {location of ht in list}}
  , ( -> vec_hash) vecHash {hash table of location vecs known for HT}
  , ( -> [[int]]) red_points {for each reducibility coroot, list of reducibility points to HT}
  , ( -> [bool]) postests {size vecHash.size(), listing unitarity results}
  , ( -> bool) min_flag {whether we're using bottom layer stuff here}
  , ( -> vec_hash) vecHashL {hash table of location vecs on L}
  , ( -> [[int]]) red_pointsL {for each reducibility coroot on L, list of reducibility points on L}
  , ( -> [bool]) postestsL {size vecHashL.size(), listing unitarity results}
  , ( -> KTypePol) sigL0 {sum of min-bottom K-types to HT}
  , ( -> [KTypePol]) sigsL {size vecHashL.size(), listing bl sigs to HT}
  , ( -> [vec]) extra_coords {size vecHash.size(): [Kchar #, #LQs] if extra_coord_flag, [] else}
  , ((ratvec,vec) -> bool) postest_known_Kchar {gamma, Kcv}
  , (int -> bool) indexed_postest {vecnum}
  , (ratvec -> bool) postest {test param(x,lambda,ratvec) for unitarity to int}
  , (ratvec -> bool) postestL {test (param(x,lambda,ratvec))_L for unitarity on bot layer}
  , (int -> bool) indexed_postestL {test L-location at vecnumL for unitarity on bot layer}
  , (ratvec -> KTypePol) sigL {bl sig for (param(x,lambda,ratvec))}
  , (ratvec -> vec) extra_coord {index of Kchar of param(x,lambda,last_arg) to ht, #LQs}
  , ((ratvec, vec) -> vec) thruple_known_Kchar {gamma and Kcv to HT; return locvec}
  , (int -> vec) indexed_thruple {locnum to HT; return locvec}
  , (ratvec -> vec) thruple {gamma to HT; return locvec}
  , ((ratvec, vec) -> vec) thruple_known_Kchar_no_stat {gamma and Kcv to HT; return locvec, don't compute status}
  , (ratvec -> vec) thruple_no_stat {locnum and Kcv to HT; return locvec,
    	   	   	   					    don't compute status}
  , (ratvec -> vec) Lthruple {loc vec on Lmin}
  , ( -> Param) pzero {parameter(xSHS,lambdaSHS,0)}
)
]

{whether to try min_bottom_elim in the middle of pos_tests}
set steve_min_flag = false

set make_steve_hash_small() = steve_hash_small_table:
(   let rfSHS = RealForm: GL(1,R)
    then xSHS = KGBElt: KGB(rfSHS,0)
    then lambdaSHS = ratvec: rfSHS.rho
    then p0 = parameter(xSHS,lambdaSHS,0*lambdaSHS)
    then (,p0L) = theta_stable_quasi_data(p0)
    then dlSHS = vec: p0.d_lambda.numer {(1+xSHS.involution)*(lambdaSHS.numer)}
    then rcor = [vec]: [] {reducibility coroots for xSHS}
    then SL = int: 0 {bitmap or rcorL as subset of rcor}
    then rcorL = [vec]: [] {reducibility coroots for xSHSL}
    then htSHS = int: 0
    then min_flag = bool: false {whether to try min_bottom}
    then wmin = WeylElt: W_elt(rfSHS,([int]:[])) {carrying d_lambdaSHS to dominant}
    then vechash = vec_hash: make_vec_hash() {list of known location vectors}
    then redpoints = [int]:[] {bitmap of reducibility
    	 	     		  points for each reducibility coroot}
    then statuses = [bool]:[] {one unitarity to htSHS for each loc in vechash}
    then statusesL = [bool]: [] {bottom layer unitarity}
    then sigsL = [KTypePol]: [] {signature on min bottom K-types at each L-loc in vechashL}
    then vechashL = vec_hash: make_vec_hash()
    then redpointsL = [int]: [] {bitmap of reducibility points for each reducibility coroot in L}
    then charvecs = [vec]: [] {size vechash.size() [index of K_char, #LQs], or []}
    then charvecsL = [vec]: [] {same for L [index of K_char,#LQs]}
    then clear_SHS() = void:
    	 let () = rfSHS := GL(1,R)
	 then () = xSHS:=KGB(rfSHS,0)
	 then () = lambdaSHS:=[0]/1
	 then () = p0:= parameter(xSHS,lambdaSHS,0*lambdaSHS)
	 then (,pL) = theta_stable_quasi_data(p0)
	 then () = p0L := pL
	 then () = rcor := []
	 then () = SL := 0
	 then () = rcorL := []
	 then () = min_flag:=false
	 then () = wmin:=W_elt(rfSHS,([int]:[]))
	 then () = vechash.clear()
	 then () = redpoints := []
	 then () = statuses:=[]
	 then () = statusesL:=[]
	 then () = vechashL.clear()
	 then () = redpointsL := []
	 then () = sigsL :=[]
	 then () = charvecs:=[]
	 then () = charvecsL:=[]
	 in ()
    then SHSnew_ht(int HT) = void: {switch to a new HT}
	 htSHS := HT;
	 redpoints := for list in red_points(xSHS,lambdaSHS,HT)
		 	       do to_bitset(list)
		 	       od;
	 vechash.clear();
  	 statuses := [];
	 statusesL:=[];
	 vechashL.clear();
	 redpointsL := for j in set_bit_positions(SL)
	 	       do redpoints[j]
		       od;
	 sigsL :=[];
	 charvecs:=[];
	 charvecsL:=[]
    then SHthruple_plain(ratvec gamma) = int:
	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[htnum] = ",vechashes[htnum].list())
	 then () = prints("loc = ",loc, ", min_flag = ",min_flag)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let (boo,v) = if min_flag
		   	    	      then pos_tester_Kchar_min(xSHS, lambdaSHS, htSHS, gamma)
		   	    	      else pos_tester_Kchar(xSHS, lambdaSHS, htSHS, gamma)
				      fi
			in statuses #:=boo;
			   charvecs #:=v
		   fi
	 in vecnum
    then SHthrupleL(ratvec gamma) = int:
    	 let vecnum = SHthruple_plain(gamma)
	 then loc = vechash.index(vecnum)
	 then locL = for j in set_bit_positions(SL)
	      	     do loc[j]
		     od
	 then VECNUML = vechashL.size()
	 then vecnumL = vechashL.match(locL)
	 then p = parameter(xSHS,lambdaSHS,gamma)
	 then () = if vecnumL = VECNUML {new location rel hyperplanes}
	      	   then let pL = parameter(p0L.x, p0L.lambda,wmin*gamma)
		   	then KcvL = Kchar_vec(p0L.x, p0L.lambda, -1, wmin*gamma) {change -1 to...?}
		   	then sigL = null_K_module(rfSHS)
		   	then def_tester = is_def_tester(locL)
			then (booL,vL) = (bool,vec): (false,[])
			then () = for defloc@m in vechashL.list()[:vecnumL]
			     	  do if def_tester(defloc)
				     then if not statusesL[m] {some nonunitary is deformation of locL}
				     	  then hash_def_false_count+:=1;
					       vL:=KcvL;
					       sigL := sum(rfSHS,for q in monomials(p)
			     	    	       	      	  do min_bottom_sig(q,htSHS)
							  od); {pos on one LKT of each q}
					       break
					  elif deform_loc_flag and
					       charvecsL[m] = KcvL
					  then hash_def_true_count+:=1;
					       booL:=true;
					       vL:=KcvL;
					       sigL := sigsL[m];
					       break
					  fi
				      fi
				   od
			 in if (#vL).= {didn't resolve by deformation}
			    then let qs = monomials(1*p)
			    	 in sigL := sum(rfSHS,for q in monomials(p)
			     	    	      	  do min_bottom_sig(q, htSHS)
						  od);
				    booL:=is_pure(sigL)
			     fi;
			     statusesL #:=booL;
			     sigsL #:=sigL;
			     charvecsL#:=KcvL
		    fi
	 in vecnumL
    then SHthruple_known_Kchar(ratvec gamma, vec Kcv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain(gamma)
	 fi;
    	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechash = ",vechash.list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then	let start = elapsed_ms() {if min_flag, check on L}
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechash.list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then booL = true
			then () = if (#v).= and min_flag
			     	  then let vecnumL = SHthrupleL(gamma)
		   		       then sigL = sigsL[vecnumL]
				       then taus = monomials(sigL)
				       {signature to HT on all bl K_types}
				       in booL:= if is_pure(sigL)
				       	  	 then true
				       	  	 else all(for q in monomials(1*parameter(xSHS,lambdaSHS,gamma))
				       	    	      	  do let mult = big_unitary_hash.branch(K_type_pol(
						       	     	      character_formula(q)),htSHS)
						   	     in @bool: all(for tau in taus
						   	     	 do @bool: int_part(sigL[tau]) >=
								    int_part(mult[tau])
							  	 od)
							  od)
					   	  fi
				    fi
			in boo:= if not booL
			     	   then false
			     	   else pos_tester(xSHS, lambdaSHS, htSHS, gamma)
				   fi;
			   v:=Kcv;
			   statuses#:=boo;
			   charvecs#:=v
		   fi
	 in vecnum
    then SHthruple(ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain(gamma)
	 fi;
	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let Kcv = Kchar_vec(xSHS,lambdaSHS,htSHS,gamma)
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechash.list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then booL = true
			then () = if (#v).= and min_flag
			     	  then let vecnumL = SHthrupleL(gamma)
		   		       then sigL_HT = to_ht(sigsL[vecnumL], htSHS)
				       {then taus_HT = monomials(sigL_HT)}
				       {signature to htSHS on all bl K_types}
				       in booL:= is_pure(sigL_HT)
				       {if is_pure(sigL_HT)
				       	  	 then true
				       	  	 else all(for q in monomials(1*parameter(xSHS,lambdaSHS,gamma))
				       	    	      	  do let mult = big_unitary_hash.branch(K_type_pol(
						       	     	      character_formula(q)),HT)
						   	     in @bool: all(for tau in taus_HT
						   	     	 do @bool: int_part(sigL_HT[tau]) >=
								    int_part(mult[tau])
							  	 od)
							  od)
					   	  fi}
				    fi
			in boo:= if not booL
			     	   then false
			     	   else pos_tester(xSHS, lambdaSHS, htSHS, gamma)
				   fi;
			   v:=Kcv;
			   statuses#:=boo;
			   charvecs#:=v
		   fi
	 in vecnum
    then SHthruple_known_Kchar_no_stat(ratvec gamma, vec KCv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain(gamma)
	 fi;
    	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then charvecs #:= KCv
		   fi
	 in vecnum
    then SHthruple_no_stat(ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain(gamma)
	 fi;
    	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let KCv = Kchar_vec(xSHS,lambdaSHS,htSHS,gamma)
			in charvecs #:= KCv
		   fi
	 in vecnum
      in
  ( ( -> ): {clear} clear_SHS
  , ((KGBElt, ratvec, int) ->): {reset_with_ht} (KGBElt x, ratvec lambda, int HT) void:
    if xSHS = x and lambdaSHS = lambda
    then if htSHS = HT
    	 then return ()
	 else SHSnew_ht(HT);
	      return()
	 fi
    fi;
    rfSHS := x.real_form;
    xSHS := x;
    lambdaSHS := lambda;
    p0 := parameter(xSHS,lambdaSHS,0*lambdaSHS);
    let (,pL) = theta_stable_quasi_data(p0)
    then () = p0L:= pL
    then min_ht_max = max(for mu in LKTs(p0) do minBottomData.G_min_height(mu) od)
    in dlSHS := (1+xSHS.involution)*(lambdaSHS.numer);
       let (wm,) = from_dominant(rfSHS, dlSHS)
       in wmin:=wm.inverse;
       min_flag := steve_min_flag and
       		   x.number > (#KGB(rfSHS))/3 and
		   (height(p0) > 0) and (min_ht_max > height(p0));
       {min_height := min_ht_max;}
       rcor := red_coroots(x);
       SL := to_bitset(for av@j in rcor do if (av*dlSHS).= then [j] else [] fi od.##);
       rcorL := (for j in set_bit_positions(SL) do rcor[j]*wmin od){*wmin}; {outside fails?}
       htSHS := HT;
       vechash.clear();
       redpoints := for list in red_points(x,lambda,HT)
		  do to_bitset(list)
		  od;
       redpointsL := for j in set_bit_positions(SL)
       		     do redpoints[j]
		     od;
       statuses := [];
       vechashL.clear();
       statusesL := [];
       sigsL := [];
       charvecs := [];
       charvecsL := []
  , ((KGBElt, ratvec) ->): {reset} (KGBElt x, ratvec lambda) void:
    rfSHS := x.real_form;
    xSHS := x;
    lambdaSHS := lambda;
    p0 := parameter(xSHS,lambdaSHS,0*lambdaSHS);
    let (,pL) = theta_stable_quasi_data(p0)
    then () = p0L := pL
    then min_ht_max = max(for mu in LKTs(p0) do minBottomData.G_min_height(mu) od)
    in dlSHS := (1+xSHS.involution)*(lambdaSHS.numer);
       let (wm,) = from_dominant(rfSHS, dlSHS)
       in wmin:=wm.inverse;
       min_flag := (height(p0) > 0) and (min_ht_max > height(p0));
       {min_height := min_ht_max;}
       rcor := red_coroots(x);
       SL := to_bitset(for av@j in rcor do if (av*dlSHS).= then [j] else [] fi od.##);
       rcorL := (for j in set_bit_positions(SL) do rcor[j]*wmin od){*wmin};
       {rcorL := red_coroots(p0L.x);}
       vechash.clear();
       redpoints := [];
       statuses := [];
       vechashL.clear();
       statusesL := [];
       sigsL := [];
       charvecs := [[]];
       charvecsL:=[];
       redpointsL := []
       		  {for j in set_bit_positions(SL)
    	       	  do to_bitset(red_points(xSHS, lambdaSHS, rcor[j], -1))
		  od}
  , (-> vec_hash): {vecHash} @vec_hash: vechash
  , ( -> [[int]]): {red_points} @[[int]]:
    	 for M in redpoints do set_bit_positions(M) od
  , ( -> [bool]): {postests} @[bool]: statuses
  , ( -> bool): {min_flag} @bool: min_flag
  , ( -> vec_hash): {vecHashL} @vec_hash: vechashL
  , ( -> [[int]]): {red_pointsL} @[[int]]: for M in redpointsL do set_bit_positions(M) od
  , ( -> [bool]): {postestsL} @[bool]: statusesL
  , ( -> KTypePol): {sigL0} @KTypePol:
    sum(rfSHS, for q in monomials(parameter(xSHS, lambdaSHS, 0*lambdaSHS))
    	       do min_bottom_sig(q)
	       od)
  , ( -> [KTypePol]): {sigsL} @[KTypePol]: sigsL
  , ( -> [vec]): {extra_coords} @[vec]: charvecs
  , ((ratvec, vec) -> bool): {postest_known_Kchar} (ratvec gamma, vec KCv) bool:
    statuses[SHthruple_known_Kchar(gamma,KCv)]
  , (int -> bool): {indexed_postest} (int vecnum) bool:
    statuses[vecnum]
  , ((ratvec) -> bool): {postest} (ratvec gamma) bool:
    statuses[SHthruple(gamma)]
  , (ratvec -> bool): {postestL} (ratvec gamma) bool:
    statusesL[SHthrupleL(gamma)]
  , (int -> bool): {indexed_postestL} (int vecnumL) bool:
    statusesL[vecnumL]
  , (ratvec -> KTypePol): {sigL} (ratvec gamma) KTypePol:
    sigsL[SHthrupleL(gamma)]
  , (ratvec -> vec): {extra_coord} (ratvec gamma) vec:
    let vecnum = SHthruple(gamma)
    in charvecs[vecnum]
  , ((ratvec, vec) -> vec): {thruple_known_Kchar} (ratvec gamma, vec KCv) vec:
    vechash.index(SHthruple_known_Kchar(gamma,KCv))
  , (int -> vec): {indexed_thruple} (int vecnum) vec:
    vechash.index(vecnum)
  , (ratvec -> vec): {thruple} (ratvec gamma) vec:
    vechash.index(SHthruple(gamma))
  , ((ratvec, vec) -> vec): {thruple_known_Kchar_no_stat} (ratvec gamma, vec KCv) vec:
    vechash.index(SHthruple_known_Kchar_no_stat(gamma,KCv))
  , (ratvec -> vec): {thruple_no_stat} (ratvec gamma) vec:
    vechash.index(SHthruple_no_stat(gamma))
  , (ratvec -> vec): {Lthruple} (ratvec gamma) vec:
    vechashL.index(SHthrupleL(gamma))
  , ( -> Param): {pzero} @Param: p0
)
)

set steve_hash_small = make_steve_hash_small()
set steve_small_flag = true

set location_finder_time = int: 0
set loclist_time = int: 0

{local faces LFKH; determine which are unitary to height HT; each entry size d+3, last two being KCv
PERHAPS FOR LOWER height}
set location_finder(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [FaceVertsKHash] LFKHcat) = (vec_hash, [vec], [int], [[int]]):
    let start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then lochash = if steve_small_flag
    	 	   then steve_hash_small.reset_with_ht(x,lambda,HT);
		   	steve_hash_small.vecHash(HT)
		   else steve_hash.vecHash(x, lambda, HT)
		   fi
    {make_vec_hash()} {list of all locations of faces in LFKH}
    {then loclist = [int]:[] {for each face in LFKHcat, index of location}}
    then KCvlist = [vec]:
    	 if steve_small_flag
	 then steve_hash_small.extra_coords(HT)
	 else steve_hash.extra_coords(x, lambda, HT)
	 fi
    {then () = prints("in location_finder, start with lambda = ",lambda, ", lochash.size() = ",
    lochash.size(), ", KCvlist = ", KCvlist)}
    	{for each location in lochash, vec of size 2 [index of Kchar, #LQ's]}
    then red_co = red_coroots(x)
    then red_pts = if steve_small_flag
	 	   then steve_hash_small.red_points(HT)
	 	   else steve_hash.red_points(x, lambda, HT)
	 	   fi
    then facelist = [[int]]: for j:lochash.size() do [] od
    {entry k is numbers of faces of location #k in lochash}
    then empty = [int]: []
    then startloc = elapsed_ms()
    then loclist = for v@N in LFKHcat
    	      	   do let d = #v-3
	      	      then verts = v[:d+1]
		      then gamma = face_bary(Lvd,verts)
		      then p = parameter(x,lambda,gamma)
		      then LOCNUM = lochash.size()
		      then loc = if steve_small_flag
	 	      	       	 then steve_hash_small.thruple_no_stat(gamma)
	 	   		 else steve_hash.thruple_no_stat(x, lambda, HT, gamma)
	 	   		 fi
		      then locnum = lochash.match(loc)
		      in if lochash.size() > LOCNUM {haven't seen this location before}
		      	 then facelist #:= empty;
			      let extra = vec:
			      	 if steve_small_flag
	 	      	       	 then steve_hash_small.extra_coord(gamma)
	 	   		 else steve_hash.extra_coord(x, lambda, HT, gamma)
	 	   		 fi
			      {[Kpol_hash.match(K_type_pol(
			      character_formula_to_height(1*p,HT))),v[d+2]]}
			      in  assert(@:Kpol_hash.match(K_type_pol(character_formula_to_height(1*p,HT)))
						= extra[0],"bad extra")
			 fi;
			 facelist[locnum]#:=N;
			 locnum
		   od
   in assert(@:unitary_test_counter.use_count() = start_count, "unitarity testing in location_finder");
      location_finder_time +:= elapsed_ms() - start;
      loclist_time +:= elapsed_ms() - startloc;
   (lochash,  if steve_small_flag
   	      then steve_hash_small.extra_coords(HT)
	      else steve_hash.extra_coords(x, lambda, HT)
	      fi , loclist, facelist)

set location_finder(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH) =
(vec_hash, [vec], [int], [[int]]):
location_finder(x, lambda, HT, Lvd, LFKH.##)

set up_graph_gens_time = int: 0

{Describe directed graph with nodes the entries of vec_hash FOR WHICH FACELIST NOT EMPTY.
entry m0 in answer is all m1
so there is a directed node m0 -> m1: nonunitary at m0 implies nonunitary at m1. Equiv,
unitary at m1 implies unitary at m0.}
set up_graph_gens(vec_hash lochash, [vec] KCvs, [int] loclist) = [[int]]:
    let start = elapsed_ms()
    then edge_gens = [[int]]: for m:lochash.size() do [] od
    then () = for loc@m0 in lochash.list()
    	      do let def_tester = is_def_tester(loc)
       	      	 in for locdef@m1 in lochash.list()[:m0]
       	  	    do if def_tester(locdef)
	     	       then edge_gens[m1]#:= m0;
	     	       	    if KCvs[m0] = KCvs[m1]
		       	    then edge_gens[m0] #:= m1; {this says m0 is equiv to m1, so maybe don't need further edges???}
			    break
		  	    fi
	      	       fi
		    od
	       od
    in up_graph_gens_time+:= elapsed_ms() - start;
       edge_gens

{output is what was generally called (eq,gr) in FPP_localDirac.at}
set graph([[int]] edges) = ([[int]],[[int]]):
    strong_components(edges)

set graph_tilde_flag = false {so always run through graph "large" faces (highly deformable) to small}
set steve_graph_test_time = int:0
set local_test_graph_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [FaceVertsKHash] LFKHcat, {don't sort by dim}
    int HT
     ) = [FaceVertsKHash]:
begin
    let (lochash, KCvlist, loclist, facelist) = location_finder(x, lambda, HT,
    	Lvd, LFKHcat), G = x.real_form
    {then () = prints("loclist = ", loclist);
	      prints("facelist = ",facelist);
	      prints("KCvlist = ", KCvlist)
	      fi}
    then start = elapsed_ms()
    then inv_is = [int]: for j:#facelist do -1 od {if j is ith good, then  jth entry is i}
    then good_js = [int]:
    	 let i = 0
	 in for list@j in facelist
    	    do if #list>0
	       then inv_is[j] := i;
		    i+:=1;
		    [j]
	       else []
	       fi
	    od.##
    {then precheck = [bool]: for v in LFKHcat
    	 	    	    do let p = parameter(x,lambda, face_bary(Lvd,v[:#v-2]))
			       then ps = monomials(1*p)
			       in all(for q in ps
			       	      do is_unitary_to_ht(q,HT)
				      od)
			     od}
    then short_facelist = for j in good_js do facelist[j] od
    then () = assert(@:sum(for list in short_facelist do #list od) = #LFKHcat)
    then short_KCvlist = for j in good_js do KCvlist[j] od
    then short_loclist = for j in loclist do inv_is[j] od
    then short_lochash = make_vec_hash()
    then () = for j in good_js do short_lochash.match(lochash.index(j)) od
    {then () = if x = x_open(G)
    	      then prints("LFKHcat = ",LFKHcat);
		   prints("short_loclist = ", loclist);
	      	   prints("short_facelist = ",facelist);
		   prints("short_KCvlist = ", KCvlist)
	      fi}
    then tester(Param p) = is_unitary_to_ht_big_SIMPLE(p,HT)
    then up_gens = up_graph_gens(short_lochash, short_KCvlist, short_loclist)
    then (eq,gr) = graph(up_gens)
    {then () = if x = x_open(G)
    	      then prints("eq = ",eq);
		   prints("gr = ",gr)
	      fi}
    then NumClasses = #eq, printInterval = int: 1, start_count = unitary_test_counter.use_count()
    then statuses = [string]: for j:#eq do "?" od
    then () = if test_verbose
	      then prints("Examining ",NumClasses," classes in local_test_graph_steve to ht ",
	      	   	   HT)
	      fi
    then nums = #NumClasses
    then () = if graph_tilde_flag then nums:=~nums fi
    then () = for k in nums
    	      do if statuses[k] = "?"
	      	 then let C = eq[k] {list of locs}
		 then N = if graph_tilde_flag
		      	  then short_facelist[C~[0]]~[0] {last face for last loc in C}
			  else short_facelist[C[0]][0] {first face for first loc in C}
			  fi
		 then v = LFKHcat[N]
		 then d = #v-3
		 then verts = v[:d+1]
		 then gamma = face_bary(Lvd,verts)
		 then p = parameter(x,lambda,gamma)
    		 in statuses[k]:=
		    if all(for q in monomials(1*p)
		      	   do @bool: tester(q)
			   od)
		    then if not graph_tilde_flag
		    	 then downdateUclassesB(statuses, gr, k, "T") {needed only in forward eq}
			 fi;
		      	 "T"
		    else if graph_tilde_flag
		    	 then updateNUclassesB(statuses, gr, k, "F") {needed only in backward eq}
			 fi;
		      	   "F"
		    fi
		 fi
	       od

     {then () = prints("statuses = ",statuses)}
     {make new local face list using only faces not already proven nonunitary}
     then LFKHnew = [FaceVertsKHash]:
	  for C@m in eq {C is a list of locs}
	  do if statuses[m][0] = "T"
	     then for k in C 
		  do let js = short_facelist[k]
		     in for j in js
		     	do {assert(precheck[j],"bad true with local_test_graph");}
		     	   LFKHcat[j]
			od {[FaceVertsKHash]}
		  od.## {still [FaceVertsKHash]}
	     else {for k in C 
		  do let js = short_facelist[k]
		     in for j in js do assert(not(precheck[j]),"bad false with local_test_graph") od
		  od;}
	     	  []
	     fi
	  od.##
     then () = if test_verbose
	       then prints("Total of ", count(for ans in statuses do ans[0] = "T" od),
				 " classes are unitary candidates, giving ", #LFKHnew,
			   " unitary_to_ht faces")
	       fi

     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
			       " for local_test_graph_steve; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  steve_graph_test_time+:= elapsed_ms() - start;
     	 LFKHnew
{if sort_LFD_flag
	 then sort(x.real_form, Lvd, FVKHnew)
	 else FVKHnew
	 fi}
end

set report_steve_graph() = void:
     prints(print_time_string(location_finder_time), " for location_finder, incl ",
     		print_time_string(red_points_time), " for red_points, and ",
     		print_time_string(loclist_time)," for listloc, incl ",
		print_time_string(Kchar_vec_time)," for Kchar_vec.");
     prints(print_time_string(up_graph_gens_time), " for steve_graph construction; ",
     		print_time_string(steve_graph_test_time), " for testing with steve_graph.")

set report_steve_clear() = void:
    location_finder_time:=0;
    loclist_time:=0;
    steve_graph_test_time:=0;
    up_graph_gens_time:=0

{takes x, lambda, HT, Lvd and computes local vertices, imposing
hermitian, pos on LKTs, and pos to HT.}
set localFD_1SteveU\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1SteveU to ht ",HT)
    fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    {if fund_face_verbose then prints("looks like p0 = ",steve_hash_small.pzero()) fi;}
    let G = x.real_form, start = elapsed_ms(), (rfnum, xlnum, htnum) =
    	if steve_small_flag
	then (0,0,0)
	else steve_hash.indices(x, lambda, HT)
	fi
    then length = #(Lvd.list)
    then freq = max(length\100,1)
    then count = int:0
    then answer = [vec]:
    	 if steve_tilde_flag
	 then for v@j in Lvd.list
       	 ~do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",if steve_small_flag
		       	  	       	   then steve_hash_small.vecHash().size()
					   else steve_hash.vecHash(x,lambda,HT).size()
					   fi);
			if steve_small_flag
			then prints("So far ",count," verts unitary to ",HT,"; vecLHash size = ",
			     steve_hash_small.vecHashL().size())
			fi
	     	  fi;
	     	  let p = parameter(x,lambda,v)
	     	  in if not is_hermitian(p)
	     	     then []
	     	     elif if steve_small_flag
		     	  then steve_hash_small.postest(v)
			  else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, v)
			  fi
	     	     then let extra = if extra_coord_flag
		     	      	      then if steve_small_flag
				      	   then steve_hash_small.extra_coord(v)
				      	   else steve_hash.extra_coord(x,lambda,HT,v)
					   fi
				       else null(0)
				       fi
		     	   in count+:=1;
			      [[j]##extra]
	     	     else [] {pos test failed}
	     	     fi
	       od.## {list of candidate vertices}
       	 else  for v@j in Lvd.list
	       do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",if steve_small_flag
		       	  	       	   then steve_hash_small.vecHash(HT).size()
					   else steve_hash.vecHash(x,lambda,HT).size()
					   fi);
			if steve_small_flag
			then prints("So far ",count," verts unitary to ",HT,"; vecLHash size = ",
			     steve_hash_small.vecHashL().size())
			fi
	     	  fi;
	     	  let p = parameter(x,lambda,v)
	     	  in if not is_hermitian(p)
	     	     then []
	     	     elif if steve_small_flag
		     	  then steve_hash_small.postest(v)
			  else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, v)
			  fi
	     	     then let extra = if extra_coord_flag
		     	      	      then if steve_small_flag
				      	   then steve_hash_small.extra_coord(v)
				      	   else steve_hash.extra_coord(x,lambda,HT,v)
					   fi
				       else null(0)
				       fi
		     	   in count +:=1;
			      [[j]##extra]
	     	     else [] {pos test failed}
	     	     fi
	         od.## {list candidate vertices}
	    fi
{next step is needed because of comment before localFD_2SteveU}
    then () = answer:= if steve_tilde_flag
    	      	       then for v in answer ~do v od
		       else answer
		       fi
    in if fund_face_verbose
       then prints("Found ",#answer," vertices to ht ",HT," in time ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ", if steve_small_flag
	    		    	      then steve_hash_small.vecHash(HT).size()
				      else steve_hash.vecHash(x,lambda,HT).size()
				      fi){;
	    prints("LF0 = ",answer)}
       fi;
       {if fund_face_verbose then prints("result for localFD_1SteveU to ht = ", answer) fi;}
       answer
)



{takes x, lambda, HT, Lvd and computes local vertices, imposing
hermitian, pos on LKTs, and pos to min-lowest K-types to HT.}
set localFD_1SteveUmin\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1SteveUmin to ht ",HT)
    fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    {if fund_face_verbose then prints("looks like p0 = ",steve_hash_small.pzero()) fi;}
    let G = x.real_form, start = elapsed_ms(), (rfnum, xlnum, htnum) =
    	if steve_small_flag
	then (0,0,0)
	else steve_hash.indices(x, lambda, HT)
	fi
    then length = #(Lvd.list)
    then freq = max(length\100,1)
    then count = int:0
    then answer = [vec]:
    	 if steve_tilde_flag
	 then for v@j in Lvd.list
       	 ~do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",if steve_small_flag
		       	  	       	   then steve_hash_small.vecHash().size()
					   else steve_hash.vecHash(x,lambda,HT).size()
					   fi);
			if steve_small_flag
			then prints("So far ",count," verts min-unitary to ",HT,"; vecLHash size = ",
			     steve_hash_small.vecHashL().size())
			fi
	     	  fi;
	     	  let p = parameter(x,lambda,v)
	     	  in if not is_hermitian(p)
	     	     then []
		     elif is_pure(to_ht(steve_hash_small.sigL(v),HT))
		     then count +:=1;
		     	  [[j]]
	     	     else [] {min pos test failed}
	     	     fi
	       od.## {list of j for which vertex j is a min-unitary candidate}
       	 else  for v@j in Lvd.list
	       do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",if steve_small_flag
		       	  	       	   then steve_hash_small.vecHash().size()
					   else steve_hash.vecHash(x,lambda,HT).size()
					   fi);
			if steve_small_flag
			then prints("So far ",count," verts min-unitary to ",HT,"; vecLHash size = ",
			     steve_hash_small.vecHashL().size())
			fi
	     	  fi;
	     	  let p = parameter(x,lambda,v)
		  then () = if fund_face_verbose
		       	    then prints("p = ",p,", sigL(v) = ", steve_hash_small.sigL(v))
			    fi
	     	  in if not is_hermitian(p)
	     	     then []
		     elif is_pure(to_ht(steve_hash_small.sigL(v),HT))
		     then count +:=1;
		     	  [[j]]
	     	     else [] {min pos test failed}
	     	     fi
	       od.## {list of candidate vertices}
	    fi
{next step is needed because of comment before localFD_2SteveU}
    then () = answer:= if steve_tilde_flag
    	      	       then for v in answer ~do v od
		       else answer
		       fi
    in if fund_face_verbose
       then prints("Found ",#answer," vertices to min-unitary to ht ",HT," in time ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ", if steve_small_flag
	    		    	      then steve_hash_small.vecHash(HT).size()
				      else steve_hash.vecHash(x,lambda,HT).size()
				      fi){;
	    prints("LF0 = ",answer)}
       fi;
       answer
)


{Same using graph of vertices. Output is unitary-to-HT verts, with perhaps two extra coords: Kchar and #LQs}
set localFD_1SteveU_graph\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1SteveUgraph to ht ",HT)
    fi;
    if not is_pos_on_LKTs(parameter(x,lambda,0*lambda)) then return [] fi;
    let G = x.real_form, start = elapsed_ms()
    then LF0 = for v@j in Lvd.list
    	       do let p = parameter(x,lambda,v)
	       	  in if not is_hermitian(p)
		     then []
		     elif extra_coord_flag
		     then [[j,0,#monomials(1*p)]]
		     else [[j]]
		     fi
	       od.##
    in local_test_graph_steve(x,lambda,Lvd,LF0,HT)
)


{LF0 is meant to be unitary-to-ht HT vertices, maybe with Kchar and #LQs extra coords. Output is LF1,
same list for edges. LF0 MUST be ordered by first coordinate in order for the edge construction to work.
(Of course that could be fixed, but I haven't bothered.)}
set localFD_2SteveU\
( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_2Steve")
    fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    {prints("in localFD_2SteveU, LF0 = ",LF0);}  {COMMENT OUT!}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then () = if #LF0 = 0
    	      then return []
	      fi
    then FixedList = [int]: for v in LF0
    	 	     	    do let j = v[0]
			       in if j < #Perm2.fixed
			       	  then [j]
				  else break
				  fi
			    od.##
    then f = #FixedList, f0 = #Perm2.fixed
    then TranList = [int]: for v in LF0[f:] do v[0] od {all entries are f0+ index in Perm2.trans}
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number in Lvd
		      	  of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is Perm2.trans[m + f0]}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0 {midpoint of v[2:] is a local vertex}
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT at [",k,",",n,"]!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	   {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in  {prints("FF, FT, TT = ",[#EdgesFixFix,#EdgesFixTrans,#EdgesTransTrans]);}
	       EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
     {then () = prints("#Edges in localFD_2SteveU = ",#Edges)} {COMMENT THIS OUT!}
     then length = #Edges
     then freq = max(length\10,1)
     then (rfnum, xlnum, htnum) = if steve_small_flag
     	  	  	 	  then (0,0,0)
				  else steve_hash.indices(x, lambda, HT)
				  fi
     then LF1 = [FaceVertsIndex]:
          if steve_tilde_flag
	  then for v@j in Edges
	       ~do if fund_face_verbose and red_count_flag and (j%freq).=
	       	   then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",if steve_small_flag
		       	  	       	   then steve_hash_small.vecHash().size()
					   else steve_hash.vecHash(x,lambda,HT).size()
					   fi)
	     	   fi;
	     let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     in if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       	then []
	       	elif if steve_small_flag
		     then steve_hash_small.postest(face_bary(Lvd,v))
		     else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,v))
		     fi
	       	then let extra = if extra_coord_flag {pos test passes}
		     	       	 then if steve_small_flag
				      then steve_hash_small.extra_coord(face_bary(Lvd,v))
				      else steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))
				      fi
				  else null(0)
				  fi
		     in [v##extra]
	       	    {then prints("v = ",v, "extras = ", steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v)));}
		  else [] {pos test fails}
		  fi {not fewer}
	      od.## {v in Edges}
	      else for v@j in Edges
	       	   do if fund_face_verbose and red_count_flag and (j%freq).=
	       	   then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",if steve_small_flag
		       	  	       	   then steve_hash_small.vecHash().size()
					   else steve_hash.vecHash(x,lambda,HT).size()
					   fi)
	     	   fi;
	     let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     in if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       	then []
	       	elif if steve_small_flag
		     then steve_hash_small.postest(face_bary(Lvd,v))
		     else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,v))
		     fi
	       	then let extra = if extra_coord_flag {pos test passes}
		     	       	 then if steve_small_flag
				      then steve_hash_small.extra_coord(face_bary(Lvd,v))
				      else steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))
				      fi
				  else null(0)
				  fi
		     in [v##extra]
	       	    {then prints("v = ",v, "extras = ", steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v)));}
		  else [] {pos test fails}
		  fi {not fewer}
	      od.## {v in Edges}
	      fi {steve_tilde_flag}
	{then () = if steve_tilde_flag
	     	  then LF1 := for v in LF1 ~do v od
		  fi}
    {then () = if time_verbose
    	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    {then () = FD12bzTime +:= elapsed_ms() - start}
    then tail = if (#LF1).=
    	      	then 0
		else {prints("LF1 = ",LF1);}
		     #(LF1[0]) - 2
		fi
    then () = if sort_LFD_flag
       	      then LF1 := sort(G, Lvd, [LF1], tail)[0]
       	      else LF1
       	      fi
    {then () = if steve_tilde_flag
	      then LF1 := for v in LF1 ~do v od
	      fi}
    in if fund_face_verbose
       then prints("After localFD_2SteveU, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]");
       	    prints("vecHash size = ",if steve_small_flag
	    		    	     then steve_hash_small.vecHash(HT).size()
				     else steve_hash.vecHash(x,lambda,HT).size()
				     fi)
       fi;
       LF1
)

{LF0 is meant to be unitary-to-ht HT vertices, with Kchar and #LQs extra coords. Output is [LF0,LF1],
same list for vertices and edges}
{LF0 may be out of order, and this breaks edge hunt}
set localFD_2SteveUgraph\
( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
 [[FaceVertsKHash]]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_2SteveUgraph")
    fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    {prints("in localFD_2SteveUgraph, LF0 = ",LF0);}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then () = if #LF0 = 0
    	      then return []
	      fi
    then FixedList = [int]:[], TranList = [int]:[]
    then () = for v in LF0
    	      do let j = v[0]
	      	 in if j < #Perm2.fixed
	       	    then FixedList #:=j
	       	    else TranList #:=j
	       	    fi
	      od
    then () = FixedList := FixedList.sort
    then () = TranList := TranList.sort
    then f = #FixedList, f0 = #Perm2.fixed
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number in Lvd
		      	  of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is Perm2.trans[m + f0]}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0 {midpoint of v[2:] is a local vertex}
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT at [",k,",",n,"]!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	   {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in {prints("FF, FT, TT = ",[#EdgesFixFix,#EdgesFixTrans,#EdgesTransTrans]);}
	   EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
   {then () = Edges := if steve_tilde_flag
   	      	 then for v in Edges
		      ~do v
		      od
		 else Edges
		 fi}
   {then () = prints("#Edges in localFD_2SteveUgraph = ",#Edges)}
   then LF1cand = [LocalFaceVertsKHash]:
        for v@j in Edges
	do let gamma = face_bary(Lvd,v)
	   then p = parameter(x,lambda,gamma)
	   in v##[0,#monomials(1*p)]
	od
   {then () = prints("LF1cand = ",LF1cand)}
   then answer = local_test_graph_steve(x, lambda, Lvd, LF0##LF1cand, HT)
   then LF1 = [LocalFaceVertsKHash]:
   	    for v in answer
	    do if #v=4
	       then [v]
	       else []
	       fi
	    od.##
in if fund_face_verbose
   then prints("After localFD_2SteveUgraph, face counts are [", #LF0,",",#LF1,"]");
       	prints("vecHash size = ", if steve_small_flag
			       	  then steve_hash_small.vecHash(HT).size()
				  else steve_hash.vecHash(x, lambda, HT).size()
				  fi)
   fi;
   [LF0,LF1]
)

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces that are unitary to ht HT; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_lookDownSteveU\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t) = [[FaceVertsKHash]]:
(   {if face_verbose
    then prints(new_line,"start localFD_lookDownSteveU, b = ",b,", t = ",t)
    fi;}
    steve_hash_small.reset_with_ht(x,lambda,HT);
    let G = x.real_form, start=elapsed_ms(), (rfnum, xlnum, htnum) = if steve_small_flag
    	    		 		     	     	    	     then (0,0,0)
								     else steve_hash.indices(x, lambda, HT)
								     fi
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2; dim is the new bigger dim}
    	      do LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],0)
	      	    	       	   in [vec]:
				      for (actual,locs) in acts {vec of size dim+1, coords of subs}
	       	    	      	      do if if steve_small_flag
				      	    then steve_hash_small.postest(face_bary(Lvd,actual))
					    else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,actual))
					    fi
				      	 then [actual]
					 else []
					 fi

			              od.##);
		if fund_face_verbose
		then prints("After dim ",dim,", found face counts ",for list in LFKH do #list od,
		       " at time ",print_time_string(elapsed_ms() - start))
		fi
	 	od{dim:t-#LFKH}
    then () = LFKH := if sort_LFD_flag
    	      	      then sort(G, Lvd, LFKH)
		      else LFKH
		      fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt_lookDownSteveU to dim ",t-1,
			"; face counts = ", for list in LFKH do #list od);
		   prints("vecHash size = ",if steve_small_flag
			       	   	    then steve_hash_small.vecHash().size()
				  	    else steve_hash.vecHash(x, lambda, HT).size()
				  	    fi)
	      fi
    in LFKH
)


{impose unitary to HT on a collection of faces, sorted by dimension}
set test_Steve(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH) =
    [[FaceVertsKHash]]:
    if #LFKH[0] = 0 then return LFKH fi;
    if fund_face_verbose then prints("start test_steve to height ",HT) fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    let start = elapsed_ms(), (rfnum, xlnum, htnum) = if steve_small_flag
    	      		      	      	     	      then (0,0,0)
						      else steve_hash.indices(x, lambda, HT)
						      fi
		{may need to adjust extra coords to reflect K-char to larger height}
    then local_extra_coord_flag = extra_coord_flag {and #LFKH[0][0] = 1}
    in for LF@d in LFKH
    do let freq = max(#LF\10,1)
       then answerd =
       	   for v@j in LF
       	   do if (j%freq).= and fund_face_verbose
	      then prints("at face #",j," of ",#LF," at time ",print_time_string(elapsed_ms() - start),
	      "; vecHash size = ",if steve_small_flag
			       	  then steve_hash_small.vecHash().size()
				  else steve_hash.vecHash(x, lambda, HT).size()
				  fi);
		   prints(steve_hash_small.sigsL())
	      fi;
	      v:=v[:d+1];
	      let gamma = face_bary(Lvd, v{[:d+1]})
	      in if if steve_small_flag
	      	    then steve_hash_small.postest(gamma)
		    else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, gamma)
		    fi
       	      	 then let extra = if local_extra_coord_flag {pos test passes}
	      	      	  	  then if steve_small_flag
		      	   	       then steve_hash_small.extra_coord(gamma)
			   	       else steve_hash.extra_coord(x,lambda,HT,gamma)
				       fi
				  else null(0)
			   	  fi
		       in [v##extra]
	      	   else [] {pos test fails}
		   fi
       	     od.##
	then () = if fund_face_verbose
	     	  then prints("old size = ",#LF,", new size = ",#answerd, ", vecHash size = ",
		       if steve_small_flag
		       then steve_hash_small.vecHash().size()
		       else steve_hash.vecHash(x, lambda, HT).size()
		       fi)
		  fi
	in {if fund_face_verbose then prints("result for test to ht ",HT," is ", answerd) fi;}
	   answerd
    od

set show_steve_flag = false

set first_offset = int:0

{now that steve_min_flag works with smaller H, don't need?}
{set H1_min_factor = rat:2/1}

{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}
set localFD_Steve2(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    ([[FaceVertsKHash]],int):
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1), extra_coord_hold = extra_coord_flag
    then H0 = hts[first_offset]
    {then () = steve_hash_small.reset_with_ht(x,lambda,H0)}
    then () = if (edge_offset= first_offset)
    	      then extra_coord_flag := true
	      else extra_coord_flag := false
	      fi
    then () = if fund_face_verbose
    	      then prints("orig vert count = ", #(Lvd.list))
	      fi
    then LF0 = if steve_min_flag and to_ht(steve_hash_small.sigL0(),H0).!=
    	       then localFD_1SteveUmin(x,lambda, H0, Lvd)
	       else localFD_1SteveU(x,lambda,H0,Lvd)
	       fi
    then () = if (#LF0).=
    	      then return ([[],[]],H0)
	      fi
    then () = if fund_face_verbose
    	      then prints("LF0 min-unitary to height ",H0," = ",#LF0)
	      fi
    then () = extra_coord_flag :=true
    {then min_ht_max = max(for mu in LKTs(p0) do minBottomData.G_min_height(mu) od)}
    then H1 = {if steve_min_flag and height(p0) > 0
    	      	 and x.number > (#KGB(x.real_form))/3 and min_ht_max > height(p0)
		 {and (min_ht_max-height(p0)) <= H1_min_factor*(hts[edge_offset]-height(p0))}
    	      then min_ht_max
    	      else} hts[edge_offset]
	      {fi}
    then () = if H1 > H0 {first_offset}
    	      then LF0:= test_Steve(x,lambda,H1,Lvd,[LF0])[0]
	      fi
    then () = if fund_face_verbose
    	      then prints("LF0 to height ",H1," = ",#LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,H1,Lvd,Perm2,LF0)]
    {then () = if fund_face_verbose
    	      then prints("LF1 with extra to height ",hts[edge_offset]," = ",LF[1])
	      fi}
    then () = if fund_face_verbose
    	      then prints("edge/vert counts to height ",H1, " = ",
	      	   for list in LF do #list od,"; time  = ",print_time_string(elapsed_ms() - start))
	      fi
    in extra_coord_flag:=extra_coord_hold; (LF,H1)

set localFD_Steve2(KGBElt x, ratvec lambda) = ([[FaceVertsKHash]], int):
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_Steve2(x, lambda, Lvd, Perm2)

{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}
set localFD_Steve2_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    ([[FaceVertsKHash]],int):
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1), extra_coord_hold = extra_coord_flag
    then () = if edge_offset= first_offset then extra_coord_flag:=true fi
    then LF0 = localFD_1SteveU(x,lambda,hts[first_offset], Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height ",hts[first_offset]," = ",LF0)
	      fi
    then () = extra_coord_flag :=true
    then () = if edge_offset > first_offset
    	      then LF0:= test_Steve(x,lambda,hts[edge_offset],Lvd,[LF0])[0]
	      fi
    then () = if show_steve_flag
    	      then prints("LF0 with extra to height ",hts[edge_offset]," = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,hts[edge_offset],Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 with extra to height ",hts[edge_offset]," = ",LF[1])
	      fi
    then () = if fund_face_verbose
    	      then prints("edge/vert counts to height ",hts[edge_offset], " = ",
	      	   for list in LF do #list od,"; time  = ",print_time_string(elapsed_ms() - start))
	      fi
    in extra_coord_flag:=extra_coord_hold; (LF,hts[edge_offset])

{ Input is candidate faces; assume Kchar to HT is recorded in LFVH, as index in Kpol_hash.
Output is the unitary_to_HT ones, found by steve_hash.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use steve partial order on working from vertices up}
set local_test_hash_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH,
    int HT
     ) = [[LocalFaceVertsKHash]]:
begin
    steve_hash_small.reset_with_ht(x,lambda,HT);
    let LFVHcat = LFVH.##, G = x.real_form
    then NumFaces = #LFVHcat,  printInterval = int: 1, start = elapsed_ms()
    then start_count = unitary_test_counter.use_count()
    then (rfnum, xlnum, htnum) = if steve_small_flag
    	 	 	       	 then (0,0,0)
				 else steve_hash.indices(x,lambda,HT)
				 fi
    in if test_verbose
    	then prints("     Examining ",for list in LFVH do #list od,
	" faces in local_test_hash_steve, to ht ",HT)
    	fi;
    	let answer = [[LocalFaceVertsKHash]]:
	    for list@d in LFVH
	    do for v@j in list {work from small faces toward big}
    	       do if fund_face_verbose and (j%printInterval) = 0
       	       	  then prints("testing ",j,"th face; so far ",unitary_test_counter.use_count() - start_count
			," is_unitary' tests at ", print_time_string(elapsed_ms() - start))
			; printInterval := (3*printInterval)\2 + 1
       	           fi {fund_face_verbose}
       	         ; let verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
       	       	   then gamma = face_bary(Lvd,verts)
       	       	   then pC = parameter(x, lambda, gamma)
       	       	   then ps = [Param]: monomials(pC)
       	       	   in if if steve_small_flag
		      	 then steve_hash_small.postest(gamma)
			 else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum,gamma)
			 fi
       	       	      then [v]
       	  	      else []
       	  	      fi
    	        od.##
	    od
       in if test_verbose
       	  then prints("     Total of ",for list in answer do #list od, " faces are unitary to ",HT,".")
    	  fi
	  ;   if test_verbose or test_slightly_verbose
    	      then prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	      	   print_time_string(elapsed_ms() - start))
    	      fi
;   answer
end

{whether to finish local_test_GEO_hash_steve with steve_closer}
set steve_closer_flag = false

{whether to use steve at every dimension}
set all_steve_flag = false

{ Input is candidate faces; assume Kchar to HT is recorded in LFVH, as index in Kpol_hash.
Output is the unitary_to_HT ones, found by steve_hash.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use steve partial order on working from vertices up}
{DON'T use after local_test_graph_steve: steve_hash.statuses isn't updated}
set local_test_closer_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [LocalFaceVertsKHash] LFVHcat
     ) = [Param]:
begin
    steve_hash_small.reset_with_ht(x,lambda, -1);
    let G = x.real_form
    then NumFaces = #LFVHcat,  printInterval = int: 1, start = elapsed_ms()
    then start_count = unitary_test_counter.use_count()
    then (rfnum, xlnum, htnum) = if steve_small_flag
    	 	 	       	 then (0,0,0)
				 else steve_hash.indices(x,lambda,-1)
				 fi
    then unitary_by_dim = vec: null(rank(x.involution - 1)+1)
    in  if test_verbose
    	then prints("     Examining ",NumFaces," faces in local_test_closer_steve.")
    	fi;
    	let UParams = [Param]:
    	    for v@j in LFVHcat {work from small faces toward big}
	    {no tilde finds lots more unitary reps by deformation; not clear whether faster}
    	    do if fund_face_verbose and (j%printInterval) = 0
       	       then prints("testing ",j,"th face; so far ",unitary_test_counter.use_count() - start_count
			," is_unitary' tests at ", print_time_string(elapsed_ms() - start))
			; printInterval := (3*printInterval)\2 + 1
       	       fi {fund_face_verbose};
       	       let d = #v - 3
       	       then verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
	       then KCv = vec: v[d+1:]
       	       then gamma = face_bary(Lvd,verts)
       	       then pC = parameter(x, lambda, gamma)
       	       then ps = [Param]: monomials(pC)
       	       in if if steve_small_flag
	       	     then steve_hash_small.postest_known_Kchar(gamma, KCv)
		     else steve_hash.partly_indexed_postest_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
		     fi
       	       	  then for p in ps
       	       	       do big_unitary_hash.uhash(G).match(p)
	       	       od;
		       unitary_by_dim[d]+:=1;
	       	       [pC]
       	  	  else []
       	  	  fi
    	    od.##
       in if test_verbose
       	  then prints("     Total of ", #UParams, " out of ",NumFaces, " faces are unitary.")
    	  fi
	  ;   if test_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",unitary_by_dim, test_string);
	      	   prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	      	   print_time_string(elapsed_ms() - start))
    	       fi
;   UParams
end

set local_test_closer_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH
     ) = [Param]:
local_test_closer_steve(x, lambda, Lvd, LFVH.##)

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_all_steve(KGBElt x, ratvec lambda, LocalVertexData Lvd, Param_hash Uhash) = [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, r = rank(x.involution -1), p0 = parameter(x,lambda,0*lambda)
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do Uhash.match(p)
	       	      od;
	       	      return(all)
	       fi
    then hts = next_heights(p0,edge_offset+1)
    then one_ht = hts[edge_offset]
    then () = test_string:= " using local_test_GEO_hash_all_steve"
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then (LF2,H1) = localFD_Steve2(x,lambda)
    then LFall = localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LF2, 2, r + 1, one_ht, Kpol_hash)
    then () = if one_two_reverse_flag
    	      then LFall := for list in LFall do [vec]: for v in list ~do v od od
	      fi
    then LFlast =  local_test_hash_steve(x, lambda, Lvd, LFall, one_ht)
    then () = if test_verbose
	      then prints("unitary to ht ",one_ht," face counts to dim ",r,
				": ", for list in LFlast do #list od)
	      fi
    then LFlastchars = extend_K_characters(x,lambda,Lvd,LFlast, Kpol_hash)
    in local_test_closer_steve(x, lambda, Lvd, LFlastchars)


{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_steve_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd, Param_hash Uhash) =
    [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    let G = x.real_form, start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do Uhash.match(p)
	       	      od;
	       	      return(all)
	       fi
    then () = test_string:= " using local_test_GEO_hash_steve_graph"
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then theta = x.involution, p0 = parameter(x,lambda,0*lambda)
    then (,Perm2) = LPm_table.LPm_entry(G, theta, ratvec_as_vec(lambda+theta*lambda))
    then hts = next_heights(p0,edge_offset+1)
    then FIRST_HT = hts[first_offset], ONE_HT = hts[edge_offset], r = rank(theta-1)
    then LF_first = localFD_1SteveU_graph(x, lambda, FIRST_HT, Lvd)
    then LF_one = if FIRST_HT = ONE_HT
    	 	  then LF_first
		  else local_test_graph_steve(x,lambda,Lvd, LF_first, ONE_HT)
		  fi
    {then () = prints(new_line, "LF_one = ",LF_one)}
    then LF01 = localFD_2SteveUgraph(x,lambda, ONE_HT, Lvd, Perm2, LF_one)
    {then () = prints("LF01 = ",LF01,new_line)}
    then LFcands = localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LF01, 2, r + 1, ONE_HT, Kpol_hash)
    then LFUcands = local_test_graph_steve(x, lambda, Lvd, LFcands.##, ONE_HT) {unitary to HT}
    {then () = prints("LFUcands = ",LFUcands)
    {then () = prints("at ",lambda,", #LFUcands = ",#LFUcands)}
    then () = prints(LFUcands)}
    then LFU = local_test_graph_steve(x,lambda,Lvd, LFUcands,-1)
    then unitary_by_dim = vec: null(rank(x.involution - 1)+1)
    then UParams = for v@j in LFU 
       	 	   do let d = #v - 3
       	  	      then verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
  	  	      then gamma = face_bary(Lvd,verts)
       	  	      then pC = parameter(x, lambda, gamma)
       	  	      then ps = [Param]: monomials(pC)
       	  	      in for p in ps
       	     	      	 do big_unitary_hash.uhash(G).match(p)
	     		 od;
	     		 unitary_by_dim[d]+:=1;
	     		 [pC]
    	     	   od.##
    in if test_verbose
       then prints("     Total of ", #LFU, " out of ", #LFUcands, " faces are unitary.")
       fi;
       if test_verbose or test_slightly_verbose
       then prints("unitary faces by dim = ",unitary_by_dim, test_string);
	    prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	    print_time_string(elapsed_ms() - start))
       fi;
       {report_steve_graph();}
       UParams
    {local_test_closer_steve(x, lambda, Lvd, LFUcands)}
    {closer_steve fails because steve_hash statuses haven't been updated properly}

set steve_graph_flag = false

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_steve(KGBElt x, ratvec lambda, LocalVertexData Lvd, Param_hash Uhash,
    (Param -> bool) fancy_tester) = [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    if all_steve_flag
    then return local_test_GEO_hash_all_steve(x, lambda, Lvd, Uhash)
    elif steve_graph_flag
    then return local_test_GEO_hash_steve_graph(x, lambda, Lvd, Uhash)
    fi;
    let G = x.real_form
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do Uhash.match(p)
	       	      od;
	       	      return(all)
	       fi
    then () = test_string:= " using local_test_GEO_hash_steve"
    then () = if test_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then (LF2,H1) = localFD_Steve2 (x,lambda)
    then () = if (#LF2).= or (#LF2[0]).=
    	      then {if steve_small_flag
       	      	   then steve_hash_small.clear()
       		   else steve_hash.clear_xl(x,lambda)
       		   fi;}
		   return []
	      fi
    then answer = if steve_closer_flag
       	 	  then local_test_GEO_hash_steve_steve_end(x, lambda, Lvd, LF2, Uhash,
       		  (([[LocalFaceVertsKHash]])->[Param]): ([[LocalFaceVertsKHash]] LFlast):
		  local_test_closer_steve(x,lambda, Lvd, LFlast))
       		  else local_test_GEO_hash_steve_end(x,lambda, Lvd, LF2, H1, Uhash)
       		  fi
    in if steve_small_flag
       then steve_hash_small.clear()
       else steve_hash.clear_xl(x,lambda)
       fi;
       answer
