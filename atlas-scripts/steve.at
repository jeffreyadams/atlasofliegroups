< basic {for infinitesimal character}
< aff_cube.at {for local_FPP_extrema}
< FPP_faces_herm.at {for unitarity tests}
< hash.at {for hash tables}
< FPP_localDirac.at { for |unipotents_to_hash| }
< red_points.at {for red_points}
{still need to fix this to allow deformed parameters NOT in FPP!}

{NOW VALID ONLY IF deformation in nu stays in FPP}
{need to study reducibility along av at int values
from int to int inclusive}
set range(KGBElt x, ratvec lambda, vec av) = (int, int):
    let lfe = local_FPP_extrema(x,lambda)
    then vals = for w in lfe do av*w od
    in (floor(av*(1+x.involution)*lambda), ceil(max(vals)))

{avL is meant to be a coroot in Lmin}
{set rangeL(KGBElt x, ratvec lambda, vec avL) = (int, int):
    let (,pL0) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
    then lfe = local_FPP_extrema(x,lambda)
    then pwLs = for w in lfe
    	      	do let (,pwL) = theta_stable_quasi_data(parameter(x,lambda,w))
    	      	   in pwL
		od
    then valsL = for pwL in pwLs
    	       	 do avL*(pwL.infinitesimal_character)
		 od
    in (floor(avL*pwLs[0].d_lambda), ceil(max(valsL)))}

set ranges(KGBElt x, ratvec lambda) = [(vec, (int, int))]:
    let rc = red_coroots_DV(x,lambda)
    in for av in rc
       do (av,range(x, lambda, av))
       od

{set rangesL(KGBElt x, ratvec lambda) = [(vec, (int, int))]:
    let (,pL0) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
    then rcL = red_coroots_DV(pL0.x,pL0.lambda)
    in for avL in rcL
       do (avL,rangeL(x, lambda, avL))
       od}

{root datum from all coroots restricting to A as multiple of av}
set Levix(KGBElt x, vec av) = (RealForm,KGBElt):
    let G = x.real_form, theta = x.involution
    then pos_r = G.posroots, pos_co = G.poscoroots
    then av_min_th = av - av*theta
    then js = for bv@j in pos_co
    	      do if rank([av_min_th,bv-bv*theta]) <=1
	      	 then [j]
		 else []
		 fi
	      od.##
     then two_rho_L = sum(G.rank, for j in js do pos_r[j] od)
     then min_js = for j in js
     	  	   do if pos_co[j]*two_rho_L = 2
		      then [j]
		      else []
		      fi
		   od.##
     then rdL = root_datum(mat: for j in min_js do pos_r[j] od,
     	      		   mat: for j in min_js do pos_co[j] od, G.prefers_coroots)
     {then tfL = x.torus_factor - G.rho_check + rdL.rho_check}
     then xL = KGB_elt(rdL, theta, x.torus_factor)
    in (real_form(xL),xL)

{parameter on nonstandard Levi L}
set pL(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    let (L,xL) = Levix(x,av), G = x.real_form, theta = x.involution
    then m = coroot_index(G,av) + #G.posroots, {lambdaL = lambda-rho(G) + rho(L)}
    	 lambda_shift = -rho(G) +rho(L) + rho_C(G,theta) - rho_C(L,theta)
    then a = roots(G)[m], lambdaL = lambda + lambda_shift
    then nu1 = (a-theta*a)
    then wt = av*nu1, shift = av*(lambdaL+theta*lambdaL)/2
    in parameter(xL,lambdaL, ((t-shift)/wt)*nu1)

set std_quo(Param p) = ParamPol:
    1*p-character_formula(1*p)

set ind_quo(KGBElt x, ratvec lambda, vec av, rat t) = KTypePol:
    let pL = pL(x,lambda,av,t)
    in K_type_pol(std_quo(pL))

set to_ht_G(RealForm G, KTypePol QL, int HT) = KTypePol:
    if HT.< then return QL fi;
    sum(QL.real_form,
	for c@tauL in QL
    	do if dominant(G,parameter(tauL).d_lambda)*(G.two_rho_check) <= HT
	   then c*tauL
	   else 0*tauL
	   fi
	od)

set test(KGBElt x, ratvec lambda, vec av, rat t, int HT) = bool:
    let QL = ind_quo(x,lambda,av,t)
    in to_ht_G(x.real_form, QL,HT).!=

{set red_points_time = int:0}

{works for HT < 0, giving all reducibility points}
{omitting the singular real roots gives 2 too many unitary in Sp(6,R)}
{set red_points(KGBElt x, ratvec lambda, vec av, int HT) = [int]:
    let start = elapsed_ms(), (m,M) = range(x,lambda,av)
    then ans = for j:M-m+1 from m
       	       do if test_scr(x,lambda,av,j,HT)
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_time +:= elapsed_ms() - start;
     	ans}

{set red_points(KGBElt x,ratvec lambda, int HT) = [[int]]:
    for av in red_coroots_DV(x,lambda)
    do red_points_rp_abvd(x,lambda,av,HT, (x.root_datum).rho*av)
    od}

{set red_pointsL(KGBElt x, ratvec lambda, vec avL, int HTL) = [int]:
    let (,pL0) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
    then start = elapsed_ms(), (mL,ML) = rangeL(x,lambda,avL)
    then ans = for j:ML-mL+1 from mL
       	       do if test_scr(pL0.x, pL0.lambda, avL, j, HTL)
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_time +:= elapsed_ms() - start;
     	ans}

{set red_pointsL(KGBElt x,ratvec lambda, int HTL) = [[int]]:
    let (,pL0) = theta_stable_quasi_data(parameter(x,lambda,0*lambda))
    in for avL in red_coroots_DV(pL0.x, pL0.lambda)
    do red_pointsL(x,lambda,avL,HTL)
    od}

{record location of rat t with respect to strictly increasing
sequence of M ints red_pts by integer from 0 to 2M.
0 means red_pts is empty; 0 means smaller than any, 2M means larger than any;
2j}
{ range [0..2*#a]; a[i]=r -> 2i+1; even number: r absent }
set location([int] a,rat t) = int:
    let loc = locate_sorted(a,ceil(t)) { first with |a[loc]>=t| }
    in if loc=#a
       then 2*loc
       elif a[loc]=t then 2*loc+1
       else 2*loc
       fi

set location(KGBElt x, ratvec lambda, vec av,int HT, rat t) = int:
    let rp = red_points_scr(x,lambda,av,HT)
    in location(rp,t)

set thruple(KGBElt x, ratvec lambda,int HT, ratvec gamma) = vec:
    for av in red_coroots_DV(x,lambda)
    do location(x,lambda,av,HT,av*gamma)
    od

set thruple([vec] red_co, [[int]] red_pts, ratvec gamma) = vec:
    for av@j in red_co
    do location(red_pts[j],av*gamma)
    od

set is_def_thr(vec base_thr, vec def_thr) = bool:
    (def_thr != base_thr) and
    all(for x@j in base_thr
        do @bool: (is_odd(x) and def_thr[j] = x)
	   	  or(is_even(x) and abs(def_thr[j] - x) <= 1)
	od)

{This is 30% faster than commented out def_testerA above}
set is_def_tester(vec thruple) = (vec -> bool):
    (vec v): bool:
    all(for x@j in thruple
    	do @bool: (1+x%2)*abs(x-v[j]) <= 1
	od)

set taus(KGBElt x, ratvec lambda, int HT) = [KType]:
    monomials(branch(K_type_pol(parameter(x,lambda,0*lambda)),HT))

set pos_tester(KGBElt x, ratvec lambda,int HT,ratvec gamma) = bool:
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in all(for q in qs do @bool:
       	       if HT >= 0
       	       then  is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       else is_unitary_test_big_SIMPLE_interrupt(q)
	       fi od)

{should be called only if height(x,lambda,0) > 0 and HT >= minBottomData.G_min_height(x,lambda)}
set pos_tester_min(KGBElt x, ratvec lambda,int HT,ratvec gamma) = bool:
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in {prints("got to pos_tester_min at ",p);}
       if not all(for q in qs do @bool: min_bottom_elim_factors(q,p,HT) od)
       then {prints("got to pos_tester_min at ",p," and bottom worked!");}
       	    return false
       fi;
       all (for q in qs do @bool:
       if HT >= 0
       	       then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       else is_unitary_test_big_SIMPLE_interrupt(q)
	       fi od)

{compute vectors of size 2 giving [index of K-char, #Langlands quotients]}
set extra_coord_flag = true

{try deforming loc to a known one}
set deform_loc_flag = true

{try deforming loc to a known nonunitary one}
set deform_nonu_flag = true

set do_not_use_deform_steve() = void:
    extra_coord_flag:=false;
    deform_loc_flag:=false;
    deform_nonu_flag:=false

set use_deform_nonu_steve() = void:
    extra_coord_flag:=false;
    deform_nonu_flag:=true;
    deform_loc_flag:=false

{USE Kpol_hash defined in FPP_faces_geom.at; assume index od }
set pos_tester_known_Kchar(KGBElt x, ratvec lambda,int HT,ratvec gamma, vec KCv) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in if extra_coord_flag
       then (all (for q in qs do @bool:
       	    	 if HT >= 0
       	       	 then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       	 else is_unitary_test_big_SIMPLE_interrupt(q)
	       	 fi od),KCv)
       else (all (for q in qs do @bool:
       	       if HT >= 0
       	       then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       else is_unitary_test_big_SIMPLE_interrupt(q)
	       fi od),[])
       fi

{USE Kpol_hash defined in FPP_faces_geom.at}
set pos_tester_Kchar(KGBElt x, ratvec lambda,int HT,ratvec gamma) = (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in if extra_coord_flag
       then (all (for q in qs do @bool:
       	    	 if HT >= 0
       	       	 then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       	 else is_unitary_test_big_SIMPLE_interrupt(q)
	       	 fi od),
       	    [Kpol_hash.match(K_type_pol(character_formula_to_ht(1*p,HT))),#qs])
       else (all (for q in qs do @bool:
       	    	 if HT >= 0
       	       	 then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       	 else is_unitary_test_big_SIMPLE_interrupt(q)
	       	 fi od),[])
       fi

{should only be invoked if height(x,lambda)>0 and HT >= minBottomData.G_min_height(x,lambda)}
{SHOULD USE KNOWN Kchar KCv[0] if possible}
{USE Kpol_hash defined in FPP_faces_geom.at; assume index od }
set pos_tester_known_Kchar_min(KGBElt x, ratvec lambda,int HT,ratvec gamma, vec KCv) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    in {prints("got to pos_tester_known_Kchar_min");}
       if not all(for q in qs do @bool: min_bottom_elim_factors(q,p,HT) od)
       then {prints("got to pos_tester_known_Kchar_min at ",p," and bottom worked!");}
       	    return if extra_coord_flag
       	    	   then (false,KCv)
		   else (false,[])
		   fi
       fi;
       if extra_coord_flag
       then (all (for q in qs do @bool:
       	    	 if HT >= 0
       	       	 then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       	 else is_unitary_test_big_SIMPLE_interrupt(q)
	       	 fi od),KCv)
       else (all (for q in qs do @bool:
       	    	 if HT >= 0
       	       	 then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       	 else is_unitary_test_big_SIMPLE_interrupt(q)
	       	 fi od),[])
       fi

{USE Kpol_hash defined in FPP_faces_geom.at}
set pos_tester_Kchar_min(KGBElt x, ratvec lambda,int HT,ratvec gamma) =
    (bool, vec):
    let p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    {then stats = for q in qs do status(q,HT) od} {nothing for Spin(4,4)}
    in 	{prints("got to pos_tester_Kchar_min at ",p,"...");}
       if all(for q in qs
       	      do big_unitary_hash.uhash(G).lookup(q) >= 0
       {stat in stats do stat > 0}
       od)
       then return (true, if extra_coord_flag
       	    	   	  then [Kpol_hash.match(K_type_pol(character_formula_to_ht(1*p,HT))),#qs]
			  else []
			  fi)
       elif any(for q in qs
       	    	do @bool: not big_unitary_hash.nu_height_lookup_bool(q,HT)
		{stat in stats do stat < 0}
       	    	od)
       then return (false, if extra_coord_flag
       	    	   	   then [Kpol_hash.match(K_type_pol(character_formula_to_ht(1*p,HT))),#qs]
			   else []
			   fi)
       fi;
       if not all(for q in qs do @bool: min_bottom_elim_factors(q,p,HT) od)
       then {prints("...and bottom worked!");}
       	    return if extra_coord_flag
       	    	   then (false,[Kpol_hash.match(K_type_pol(character_formula_to_ht(1*p,HT))),#qs])
		   else (false,[])
		   fi
       fi;
       if extra_coord_flag
       then (all (for q in qs do @bool:
       	    	 if HT >= 0
       	       	 then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       	 else is_unitary_test_big_SIMPLE_interrupt(q)
	       	 fi od),
       	    [Kpol_hash.match(K_type_pol(character_formula_to_ht(1*p,HT))),#qs])
       else (all (for q in qs do @bool:
       	    	 if HT >= 0
       	       	 then is_unitary_to_ht_big_SIMPLE_interrupt_pick(q,HT)
	       	 else is_unitary_test_big_SIMPLE_interrupt(q)
	       	 fi od),[])
       fi

set Kchar_vec_time = int: 0

set Kchar_vec(KGBElt x, ratvec lambda, int HT, ratvec gamma) = vec:
    let start = elapsed_ms(), p = parameter(x,lambda,gamma), G = x.real_form
    then qs = monomials(1*p)
    then answer = if extra_coord_flag
       	 	  then [Kpol_hash.match(K_type_pol(character_formula_to_ht(1*p,HT))),#qs]
       		  else []
       		  fi
    in Kchar_vec_time +:= elapsed_ms() - start;
       answer

set report_def_thruples() = void:
    prints(print_time_string(def_thruples_time)," to find deformed thruple candidates.");
    prints("Found ",hash_def_true_count," deformations proving unitarity (to height), ",
    	   hash_def_false_count," deformations proving nonunitarity (to height).")

{
set_type
[steve_hash_table =
( ( -> ) clear {clear the table}
  , ((KGBElt, ratvec) ->) clear_xl {clear the tsbles for (x,lambda)}
  , ( -> int) real_form_size {number of real forms included}
  , ( -> vec) xlhash_sizes {for every real form, the number of pairs(x,lambda)}
{  , ( -> vec) K_type_sizes {number of KTypes for each real form}}
  , ((KGBElt, ratvec) -> vec) heights {list of heights to which reducibility has been studied}
  , ((KGBElt, ratvec, int) -> (int, int, int)) indices {rfnum, xlnum, htnum}
  {, ((KGBElt, ratvec, vec, int) -> KTypePol) ind_quo} {like function ind_quo, but storing answers}
  {, ((KGBElt, ratvec, vec, int, int) -> bool) test} {like function test}
  , ((KGBElt, ratvec, int) -> vec_hash) vecHash {hash table of location vecs known}
  , ((KGBElt, ratvec, int) -> [[int]]) red_points {for each reducibility coroot, list of reducibility points}
  , ((KGBElt, ratvec, int) -> [bool]) postests {size vecHash.size(), listing unitarity results}
  , ((KGBElt, ratvec, int) -> [vec]) extra_coords {size vecHash.size():
  [Kchar #, #LQs] if extra_coord_flag, [] else}
  , ((int, int, int, ratvec, vec) -> bool) partly_indexed_postest_known_Kchar
  , ((KGBElt, ratvec, int, ratvec, vec) -> bool) postest_known_Kchar {test param(x,lambda,last_arg) for unitarity to ht}
  , ((int, int, int, int) -> bool) indexed_postest {known rfnum, xlnum, htnum, vecnum}
  , ((int, int, int, ratvec) -> bool) partly_indexed_postest
  , ((KGBElt, ratvec, int, ratvec) -> bool) postest {test param(x,lambda,last_arg) for unitarity to ht}
  , ((KGBElt, ratvec, int, ratvec) -> vec) extra_coord {index of Kchar of param(x,lambda,last_arg) to ht, #LQs}
  , ((int, int, int, ratvec, vec) -> vec) indexed_thruple_known_Kchar {known rfnum, xlnum, htnum}
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec) thruple_known_Kchar {loc vec: (x,lambda,gamma) to HT}
  , ((int, int, int, ratvec) -> vec) indexed_thruple {known rfnum, xlnum, htnum}
  , ((KGBElt, ratvec, int, ratvec) -> vec) thruple {loc vec: (x,lambda,gamma) to HT}
  , ((int, int, int, ratvec, vec) -> vec) indexed_thruple_known_Kchar_no_stat {known rfnum, xlnum, htnum; don't compute status}
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec) thruple_known_Kchar_no_stat {loc vec: (x,lambda,gamma) to HT; don't compute status}
  , ((int, int, int, ratvec) -> vec) indexed_thruple_no_stat {known rfnum, xlnum, htnum; don't compute status}
  , ((KGBElt, ratvec, int, ratvec) -> vec) thruple_no_stat {loc vec: (x,lambda,gamma) to HT; don't compute status}
)
]
}

{
set make_steve_hash() = steve_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then xlhashes = [xlambda_hash]: [] {one for each real form}
    then heights = [[vec]]:[] {one for each entry in each xlhash}
    then vechashes = [[[vec_hash]]]:[] {one for each height for each entry in each xlhash}
    then redpoints = [[[[int]]]]:[] {for each entry in xlhash and height, [int] = bitmap of reducibility
    	 	     		  points for each reducibility coroot}
    then statuses = [[[[bool]]]]:[] {one [bool] for each vechash}
    then charvecs = [[[[vec]]]]: [] {one [vec] for each vechash; possibly [index of K_char, #LQs]}
    then clearSH() = void:
    	 let () = real_form_hash.clear()
	 {then () = K_type_hashes:=[]}
	 then () = xlhashes:=[]
	 {then () = paramhashes:=[]}
	 {then () = ktps:=[]}
	 then () = heights:=[]
	 then () = vechashes:=[]
	 then () = statuses:=[]
	 then () = charvecs:=[]
	 then () = redpoints := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then	{K_type_hashes #:= make_KType_hash();}
		        xlhashes #:= make_xlambda_hash();
			{paramhashes #:= ([Param_hash]:[]);}
			{ktps #:= ([[KTypePol]]:[]);}
			heights   #:= ([vec]:[]);
			vechashes #:= ([[vec_hash]]:[]);
			statuses  #:= ([[[bool]]]:[]);
			redpoints #:= ([[[int]]]:[]);
			charvecs  #:= ([[[vec]]]:[]);
			assert(@:real_form_hash.size() = {#K_type_hashes and} #xlhashes {= #K_type_hashes} and
	       	    	   #heights = #xlhashes and #vechashes = #heights and #statuses = #heights and
			   #redpoints = #heights, "steve_hash damaged on adding real form")
	    	   fi
	  in i
    then add_xl(KGBElt x, ratvec lambda) = (int,int): {real form index, xlhash index}
    	 let rfnum = add_real_form(x.real_form)
	 then XLNUM = xlhashes[rfnum].size()
	 then xlnum = xlhashes[rfnum].match(x,lambda)
	 in if xlnum = XLNUM {new (x,lambda)}
	    then {paramhashes[rfnum] #:= make_Param_hash();}
	    	 {ktps[rfnum] #:= ([KTypePol]:[]);}
		 heights[rfnum]#:=null(0);
	    { add empty list of lists of reducibility points for the new height}
	    	 redpoints[rfnum] #:= ([[int]]:[]);
		 vechashes[rfnum]#:=([vec_hash]:[]);
		 statuses[rfnum]#:=([[bool]]:[]);
		 charvecs[rfnum]#:=([[vec]]:[])
	    fi;
	    (rfnum,xlnum)
    then add_xlht(KGBElt x, ratvec lambda, int HT) = (int,int,int): {real form index, xlhash index, HT index}
    	 let (rfnum,xlnum) = add_xl(x,lambda)
	 then J = #heights[rfnum][xlnum], htnum = find(heights[rfnum][xlnum],HT)
	 in if htnum.< {new HT}
	    then let hrxl = heights[rfnum][xlnum], {[[int]]}
	    	     hr = heights[rfnum]
	    	 then () = hrxl#:= HT
		 then () = hr[xlnum]:=hrxl
		 then () = heights[rfnum]:=hr
		 then rprxl = redpoints[rfnum][xlnum], rpr = redpoints[rfnum]
		 then () = rprxl #:= for list in red_points(x,lambda,HT) do to_bitset(list) od
		      {add a new [int]}
		      {red_points can include NEGATIVE ints; bitset won't do}
		 then () = rpr[xlnum]:=rprxl
		 then () = redpoints[rfnum]:=rpr
		 then vhsxl = vechashes[rfnum][xlnum], vhsr = vechashes[rfnum]
		 then () = vhsxl #:= make_vec_hash()
		 		      {add a new vec_hash for new height}
		 then () = vhsr[xlnum]:=vhsxl
		 then () = vechashes[rfnum]:=vhsr
		 then statusxl = statuses[rfnum][xlnum], statusr = statuses[rfnum]
		 then () = statusxl #:= ([bool]:[]) { for this height }
		 then () = statusr[xlnum]:=statusxl
		 then () = statuses[rfnum]:=statusr
		 then charvecxl = charvecs[rfnum][xlnum], charvecr = charvecs[rfnum]
		 then () = charvecxl #:= ([vec]:[]) { for this height }
		 then () = charvecr[xlnum]:=charvecxl
		 then () = charvecs[rfnum]:=charvecr
		 in htnum:= J
	    fi;
	    (rfnum,xlnum,htnum)
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_plain_indexed(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots_DV(x,lambda)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then (boo,v) = pos_tester_Kchar(x, lambda, HT, gamma)
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
    then SHthruple_plain(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int, int, int, int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
	 in (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
	 {Following version checks deformations}
    then SHthruple_indexed_known_Kchar(int rfnum, int xlnum, int htnum, ratvec gamma, vec Kcv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots_DV(x,lambda)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechashes[rfnum][xlnum][htnum].list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[rfnum][xlnum][htnum][m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[rfnum][xlnum][htnum][m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then () = if (#v).=
			     	  then boo:= pos_tester(x, lambda, HT, gamma);
				       v:=Kcv
				  fi
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
    then SHthruple_indexed(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots_DV(x,lambda)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let srxlht = statuses[rfnum][xlnum][htnum], {[bool]}
		   	    srxl = statuses[rfnum][xlnum],
			    sr = statuses[rfnum],
			    charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then Kcv = Kchar_vec(x,lambda,HT,gamma)
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechashes[rfnum][xlnum][htnum].list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[rfnum][xlnum][htnum][m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[rfnum][xlnum][htnum][m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then () = if (#v).=
			     	  then boo:= pos_tester(x, lambda, HT, gamma);
				       v:=Kcv
				  fi
			then () = srxlht#:=boo
			then () = srxl[htnum]:=srxlht
			then () = sr[xlnum]:=srxl

			then () = charvecxlht#:=v
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in statuses[rfnum]:=sr;
			   charvecs[rfnum]:=charvecr
		   fi
	 in vecnum

    then SHthruple(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int,int,int,int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
	 in if (deform_loc_flag or deform_nonu_flag)
	    then (rfnum, xlnum, htnum, SHthruple_indexed(rfnum, xlnum, htnum, gamma))
	    else (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	    fi
	 {rfnum, xlnum, htnum, vecnum; statuses[rfnum][xlnum][htnum][vecnum] is the result}
{      then check() = void:
      	   assert(real_form_hash.size() = xlhashes.size(),"wrong rf/xl hash sizes");
      	   for rf@rfnum in real_form_hash.list()
	   do assert(xlhashes[rfnum].size() = #heights[rfnum], "wrong xl/hts sizes");
	      for xl@xlnum in xlhashes[rfnum]
	      do assert(#heights[rfnum][xlnum] = }
    then SHthruple_indexed_known_Kchar_no_stat(int rfnum, int xlnum, int htnum, ratvec gamma,
    vec KCv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots_DV(x,lambda)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then () = charvecxlht#:=KCv
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
    then SHthruple_indexed_no_stat(int rfnum, int xlnum, int htnum, ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma)
	 fi;
	 let (x,lambda) = xlhashes[rfnum].index(xlnum), HT = heights[rfnum][xlnum][htnum]
	 then rcor = red_coroots_DV(x,lambda)
    	 then rp = for M in redpoints[rfnum][xlnum][htnum]
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechashes[rfnum][xlnum][htnum].size()
	 then vecnum = vechashes[rfnum][xlnum][htnum].match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let charvecxlht = charvecs[rfnum][xlnum][htnum], {[vec]}
		   	    charvecxl = charvecs[rfnum][xlnum],
			    charvecr = charvecs[rfnum]
			then KCv = Kchar_vec(x,lambda,HT,gamma)
			then () = charvecxlht#:=KCv
			then () = charvecxl[htnum]:=charvecxlht
			then () = charvecr[xlnum]:=charvecxl
			in charvecs[rfnum]:=charvecr
		   fi
	 in vecnum
    then SHthruple_no_stat(KGBElt x, ratvec lambda, int HT, ratvec gamma) = (int,int,int,int):
    	 let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT) {, start_count = unitary_test_counter.use_count()}
	 in if (deform_loc_flag or deform_nonu_flag)
	    then (rfnum, xlnum, htnum, SHthruple_indexed_no_stat(rfnum, xlnum, htnum, gamma))
	    else (rfnum, xlnum, htnum, SHthruple_plain_indexed(rfnum, xlnum, htnum, gamma))
	    fi
	 {in prints("no_stat used ", unitary_test_counter.use_count() - start_count, " unitarity tests.")
	     ;ans}
      in
  ( ( -> ): {clear} clearSH
  , ((KGBElt, ratvec) ->): {clear_xl} (KGBElt x, ratvec lambda) void:
    let rfnum = real_form_hash.lookup(x.real_form)
    then () = if rfnum.< then return () fi
    then xlnum = xlhashes[rfnum].lookup(x,lambda)
    then () = if xlnum.< then return () fi
    then heightsrf = heights[rfnum], vechsrf = vechashes[rfnum], redptsrf = redpoints[rfnum],
    	 statrf = statuses[rfnum], charvecsrf = charvecs[rfnum]
    in heightsrf[xlnum]:=[];
       vechsrf[xlnum]:=[];
       redptsrf[xlnum]:=[];
       statrf[xlnum]:=[];
       charvecsrf[xlnum]:=[];
       heights[rfnum]:=heightsrf;
       vechashes[rfnum]:=vechsrf;
       redpoints[rfnum]:=redptsrf;
       statuses[rfnum]:= statrf;
       charvecs[rfnum]:=charvecsrf
  , ( -> int): {real_form_size} @int: real_form_hash.size()
  , ( -> vec): {xlhash_sizes} @vec: for xlhash in xlhashes do xlhash.size() od
  {, ( -> vec): {K_type_sizes} @vec: for Khash in K_type_hashes do Khash.size() od}
  , ((KGBElt, ratvec) -> vec): {heights} (KGBElt x, ratvec lambda) vec:
    let (rfnum, xlnum) = add_xl(x,lambda)
    in heights[rfnum][xlnum]
  , ((KGBElt, ratvec, int) -> (int, int, int)): {indices} (KGBElt x, ratvec lambda, int HT) (int, int, int):
    add_xlht(x,lambda,HT)
  {, ((KGBElt, ratvec, vec, int) -> KTypePol): {ind_quo} (KGBElt x, ratvec lambda, vec av, int m) KTypePol:
    let qL = pL1(x,lambda,av,m/1)
    then (rfnum, xlnum, paramnum) = add_xlp(qL, x.real_form)
    in ktps[rfnum][xlnum][paramnum]}
  {, ((KGBElt, ratvec, vec, int, int) -> bool): {test} (KGBElt x, ratvec lambda, vec av, int m, int HT) bool:
    let Q = SHind_quo(x, lambda, av, m)
    in to_ht(Q,HT).!=}
  , ((KGBElt, ratvec, int) -> vec_hash): {vecHash} (KGBElt x, ratvec lambda, int HT) vec_hash:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in vechashes[rfnum][xlnum][htnum]
  , ((KGBElt, ratvec, int) -> [[int]]): {red_points} (KGBElt x, ratvec lambda, int HT) [[int]]:
    {SHred_points(x,lambda,HT)}
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in for M in redpoints[rfnum][xlnum][htnum]
       do set_bit_positions(M)
       od
  , ((KGBElt, ratvec, int) -> [bool]): {postests} (KGBElt x, ratvec lambda, int HT) [bool]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in statuses[rfnum][xlnum][htnum]
  , ((KGBElt, ratvec, int) -> [vec]): {extra_coords} (KGBElt x, ratvec lambda, int HT) [vec]:
    let (rfnum, xlnum, htnum) = add_xlht(x,lambda,HT)
    in charvecs[rfnum][xlnum][htnum]
  , ((int, int, int, ratvec, vec) -> bool): {partly_indexed_postest_known_Kchar}
    (int rfnum, int xlnum, int htnum, ratvec gamma, vec KCv) bool:
    let vecnum = SHthruple_indexed_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec, vec) -> bool): {postest_known_Kchar} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma, vec KCv) bool:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, int) -> bool): {indexed_postest} (int rfnum, int xlnum, int htnum, int vecnum) bool:
    statuses[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, ratvec) -> bool): {partly_indexed_postest} (int rfnum, int xlnum, int htnum,
    ratvec gamma) bool:
    let vecnum = SHthruple_indexed(rfnum, xlnum, htnum, gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec) -> bool): {postest} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) bool:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in statuses[rfnum][xlnum][htnum][vecnum]
  , ((KGBElt, ratvec, int, ratvec) -> vec): {extra_coord} (KGBElt x, ratvec lambda,
    int HT, ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in charvecs[rfnum][xlnum][htnum][vecnum]
  , ((int, int, int, ratvec, vec) -> vec): {indexed_thruple_known_Kchar} (int rfnum, int xlnum, int htnum,
    ratvec gamma, vec KCv) vec:
    let vecnum = SHthruple_indexed_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec): {thruple_known_Kchar} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma, vec KCv) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec) -> vec): {indexed_thruple} (int rfnum, int xlnum, int htnum,
    ratvec gamma) vec:
    let vecnum = SHthruple_indexed(rfnum, xlnum, htnum, gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec) -> vec): {thruple} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec, vec) -> vec): {indexed_thruple_known_Kchar_no_stat} (int rfnum, int
    xlnum, int htnum, ratvec gamma, vec KCv) vec:
    let vecnum = SHthruple_indexed_known_Kchar_no_stat(rfnum, xlnum, htnum, gamma, KCv)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec, vec) -> vec): {thruple_known_Kchar_no_stat} (KGBElt x, ratvec
    lambda, int HT, ratvec gamma, vec KCv) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple_no_stat(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((int, int, int, ratvec) -> vec): {indexed_thruple_no_stat} (int rfnum, int xlnum, int htnum,
    ratvec gamma) vec:
    let vecnum = SHthruple_indexed_no_stat(rfnum, xlnum, htnum, gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  , ((KGBElt, ratvec, int, ratvec) -> vec): {thruple_no_stat} (KGBElt x, ratvec lambda, int HT,
    ratvec gamma) vec:
    let (rfnum, xlnum, htnum, vecnum) = SHthruple_no_stat(x,lambda,HT,gamma)
    in vechashes[rfnum][xlnum][htnum].index(vecnum)
  )
)
}

{
set steve_hash = make_steve_hash()
}

{meant to hold data for one (x,lambda,HT)}
set_type
[steve_hash_small_table =
( ( -> ) clear {clear the table}
  , ((KGBElt, ratvec, int, bool) ->) reset_with_ht_min {change to new (x,lambda,HT)), set min_flag}
  , ((KGBElt, ratvec, int) ->) reset_with_ht {change to new (x,lambda,HT)}
  , ((KGBElt, ratvec) ->) reset {erase old}
  {, ( -> vec) heights {list of heights to which reducibility has been studied}}
  {, (int -> int) ht_index {location of ht in list}}
  , ( -> vec_hash) vecHash {hash table of location vecs known for HT}
  , ( -> [[int]]) red_points {for each reducibility coroot, list of reducibility points to HT}
  , ( -> [bool]) postests {size vecHash.size(), listing unitarity results}
  , ( -> bool) min_flag {whether we're using bottom layer stuff here}
{  , ( -> vec_hash) vecHashL} {hash table of location vecs on L}
{  , ( -> [[int]]) red_pointsL }{for each reducibility coroot on L, list of reducibility points on L}
{  , ( -> [bool]) postestsL} {size vecHashL.size(), listing unitarity results}
{  , ( -> KTypePol) sigL0} {sum of min-bottom K-types to HT}
{  , ( -> [KTypePol]) sigsL} {size vecHashL.size(), listing bl sigs to HT}
  , ( -> [vec]) extra_coords {size vecHash.size(): [Kchar #, #LQs] if extra_coord_flag, [] else}
  , ((ratvec,vec) -> bool) postest_known_Kchar {gamma, Kcv}
  , (int -> bool) indexed_postest {vecnum}
  , (ratvec -> bool) postest {test param(x,lambda,ratvec) for unitarity to ht}
  , (vec -> int) lookup {see whether location vec is already known unitary (1) or
    	       	    	    known nonunitary (-1) or unknown (0)}
  , (ratvec -> vec) umatch {declare that a certain gamma is unitary to ht; return extra}
  , (ratvec -> vec) numatch {declare that a certain gamma is nonunitary to ht; return extra}
 { , (ratvec -> bool) postestL} {test (param(x,lambda,ratvec))_L for unitarity on bot layer}
 { , (int -> bool) indexed_postestL} {test L-location at vecnumL for unitarity on bot layer}
 { , (ratvec -> KTypePol) sigL} {bl sig for (param(x,lambda,ratvec))}
  , (ratvec -> vec) extra_coord {index of Kchar of param(x,lambda,last_arg) to ht, #LQs}
  , ((ratvec, vec) -> vec) thruple_known_Kchar {gamma and Kcv to HT; return locvec}
  , (int -> vec) indexed_thruple {locnum to HT; return locvec}
  , (ratvec -> vec) thruple {gamma to HT; return locvec}
  , ((ratvec, vec) -> vec) thruple_known_Kchar_no_stat {gamma and Kcv to HT; return locvec, don't compute status}
  , (ratvec -> vec) thruple_no_stat {locnum and Kcv to HT; return locvec,
    	   	   	   					    don't compute status}
 { , (ratvec -> vec) Lthruple} {loc vec on Lmin}
  , ( -> Param) pzero {parameter(xSHS,lambdaSHS,0)}
)
]

{whether to try min_bottom_elim in the middle of pos_tests}
set steve_min_flag = false

set make_steve_hash_small() = steve_hash_small_table:
(   let rfSHS = RealForm: GL(1,R)
    then xSHS = KGBElt: KGB(rfSHS,0)
    then lambdaSHS = ratvec: rfSHS.rho
    then p0 = parameter(xSHS,lambdaSHS,0*lambdaSHS)
    then (,p0L) = theta_stable_quasi_data(p0)
    then dlSHS = vec: p0.d_lambda.numer {(1+xSHS.involution)*(lambdaSHS.numer)}
    then rcor = [vec]: [] {reducibility coroots for xSHS}
    then SL = int: 0 {bitmap or rcorL as subset of rcor}
    then rcorL = [vec]: [] {reducibility coroots for xSHSL}
    then htSHS = int: 0
    then min_flag = bool: false {whether to try min_bottom}
    then wmin = WeylElt: W_elt(rfSHS,([int]:[])) {carrying d_lambdaSHS to dominant}
    then vechash = vec_hash: make_vec_hash() {list of known location vectors}
    then redpoints = [int]:[] {bitmap of reducibility
    	 	     		  points for each reducibility coroot}
    then statuses = [bool]:[] {one unitarity to htSHS for each loc in vechash}
    then statusesL = [bool]: [] {bottom layer unitarity}
    then sigsL = [KTypePol]: [] {signature on min bottom K-types at each L-loc in vechashL}
    then vechashL = vec_hash: make_vec_hash()
    then redpointsL = [int]: [] {bitmap of reducibility points for each reducibility coroot in L}
    then charvecs = [vec]: [] {size vechash.size() [index of K_char, #LQs], or []}
    then charvecsL = [vec]: [] {same for L [index of K_char,#LQs]}
    then clear_SHS() = void:
    	 let () = rfSHS := GL(1,R)
	 then () = xSHS:=KGB(rfSHS,0)
	 then () = lambdaSHS:=[0]/1
	 then () = p0:= parameter(xSHS,lambdaSHS,0*lambdaSHS)
	 then (,pL) = theta_stable_quasi_data(p0)
	 then () = p0L := pL
	 then () = rcor := []
	 then () = SL := 0
	 then () = rcorL := []
	 then () = min_flag:=false
	 then () = wmin:=W_elt(rfSHS,([int]:[]))
	 then () = vechash.clear()
	 then () = redpoints := []
	 then () = statuses:=[]
	 then () = statusesL:=[]
	 then () = vechashL.clear()
	 then () = redpointsL := []
	 then () = sigsL :=[]
	 then () = charvecs:=[]
	 then () = charvecsL:=[]
	 in ()
    then SHSnew_ht(int HT) = void: {switch to a new HT}
	 htSHS := HT;
	 redpoints := for list in red_points_scr(xSHS,lambdaSHS,HT)
		 	       do to_bitset(list)
		 	       od;
	 vechash.clear();
  	 statuses := [];
	 statusesL:=[];
	 vechashL.clear();
	 redpointsL := for j in set_bit_positions(SL)
	 	       do redpoints[j]
		       od;
	 sigsL :=[];
	 charvecs:=[];
	 charvecsL:=[]
    {plain means do not use deformation testing}
    then SHthruple_plain(ratvec gamma) = int:
	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[htnum] = ",vechashes[htnum].list())
	 then () = prints("loc = ",loc, ", min_flag = ",min_flag)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let (boo,v) = if min_flag
		   	    	      then pos_tester_Kchar_min(xSHS, lambdaSHS, htSHS, gamma)
		   	    	      else pos_tester_Kchar(xSHS, lambdaSHS, htSHS, gamma)
				      fi
			in statuses #:=boo;
			   charvecs #:=v
		   fi
	 in vecnum
{if we know unitarity status from elsewhere...}
   then SHthruple_known_stat(ratvec gamma, bool boo) = int:
	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[htnum] = ",vechashes[htnum].list())
	 then () = prints("loc = ",loc, ", min_flag = ",min_flag)}
	 in if vecnum = VECNUM {new location rel hyperplanes}
	    then statuses #:=boo;
		 charvecs #:= Kchar_vec(xSHS,lambdaSHS,htSHS,gamma)
	    fi;
	    vecnum
    then SHthrupleL(ratvec gamma) = int:
    	 let vecnum = SHthruple_plain(gamma)
	 then loc = vechash.index(vecnum)
	 then locL = for j in set_bit_positions(SL)
	      	     do loc[j]
		     od
	 then VECNUML = vechashL.size()
	 then vecnumL = vechashL.match(locL)
	 then p = parameter(xSHS,lambdaSHS,gamma)
	 then () = if vecnumL = VECNUML {new location rel hyperplanes}
	      	   then let pL = parameter(p0L.x, p0L.lambda,wmin*gamma)
		   	then KcvL = Kchar_vec(p0L.x, p0L.lambda, -1, wmin*gamma) {change -1 to...?}
		   	then sigL = null_K_module(rfSHS)
		   	then def_tester = is_def_tester(locL)
			then (booL,vL) = (bool,vec): (false,[])
			then () = for defloc@m in vechashL.list()[:vecnumL]
			     	  do if def_tester(defloc)
				     then if not statusesL[m] {some nonunitary is deformation of locL}
				     	  then hash_def_false_count+:=1;
					       vL:=KcvL;
					       sigL := sum(rfSHS,for q in monomials(p)
			     	    	       	      	  do min_bottom_sig(q,htSHS)
							  od); {pos on one LKT of each q}
					       break
					  elif deform_loc_flag and
					       charvecsL[m] = KcvL
					  then hash_def_true_count+:=1;
					       booL:=true;
					       vL:=KcvL;
					       sigL := sigsL[m];
					       break
					  fi
				      fi
				   od
			 in if (#vL).= {didn't resolve by deformation}
			    then let qs = monomials(1*p)
			    	 in sigL := sum(rfSHS,for q in monomials(p)
			     	    	      	  do min_bottom_sig(q, htSHS)
						  od);
				    booL:=is_pure(sigL)
			     fi;
			     statusesL #:=booL;
			     sigsL #:=sigL;
			     charvecsL#:=KcvL
		    fi
	 in vecnumL
    then SHthruple_known_Kchar(ratvec gamma, vec Kcv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain(gamma)
	 fi;
    	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechash = ",vechash.list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then	let start = elapsed_ms() {if min_flag, check on L}
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechash.list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then booL = true
			then () = if (#v).= and min_flag
			     	  then let vecnumL = SHthrupleL(gamma)
		   		       then sigL = sigsL[vecnumL]
				       then taus = monomials(sigL)
				       {signature to HT on all bl K_types}
				       in booL:= if is_pure(sigL)
				       	  	 then true
				       	  	 else all(for q in monomials(1*parameter(xSHS,lambdaSHS,gamma))
				       	    	      	  do let mult = big_unitary_hash.branch(K_type_pol(
						       	     	      character_formula(q)),htSHS)
						   	     in @bool: all(for tau in taus
						   	     	 do @bool: int_part(sigL[tau]) >=
								    int_part(mult[tau])
							  	 od)
							  od)
					   	  fi
				    fi
			in boo:= if not booL
			     	   then false
			     	   else pos_tester(xSHS, lambdaSHS, htSHS, gamma)
				   fi;
			   v:=Kcv;
			   statuses#:=boo;
			   charvecs#:=v
		   fi
	 in vecnum
    then SHthruple(ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain(gamma)
	 fi;
	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let Kcv = Kchar_vec(xSHS,lambdaSHS,htSHS,gamma)
			then start = elapsed_ms()
			then def_tester = is_def_tester(loc)
			then (boo,v) = (bool,vec): (false,[])
			then () = for defloc@m in vechash.list()[:vecnum]
			     	  do if def_tester(defloc)
				     then if not statuses[m]
				     	  then hash_def_false_count+:=1;
					       v:=Kcv;
					       break
					  elif deform_loc_flag and
					       charvecs[m] = Kcv
					  then hash_def_true_count+:=1;
					       boo:=true;
					       v:=Kcv;
					       break
					  fi
				      fi
				   od
		        then () = def_thruples_time+:= elapsed_ms() - start
			then booL = true
			then () = if (#v).= and min_flag
			     	  then let vecnumL = SHthrupleL(gamma)
		   		       then sigL_HT = to_ht(sigsL[vecnumL], htSHS)
				       {then taus_HT = monomials(sigL_HT)}
				       {signature to htSHS on all bl K_types}
				       in booL:= is_pure(sigL_HT)
				   fi
			then qs = monomials(parameter(xSHS, lambdaSHS, gamma))
			{then stats = for q in qs do status(q,htSHS) od}
			{save 24/422 for Spin(4,4)}
			in boo:= if not booL
			     	   then false
			     	   elif all(for q in qs
			do big_unitary_hash.uhash(rfSHS).lookup(q) >= 0
					    od)
				   {for stat in stats do stat > 0 od)}
				   then true
				   elif any(for q in qs
				   	    do @bool:
					    not big_unitary_hash.nu_height_lookup_bool(q,htSHS)
					    od)
				   {for stat in stats do stat < 0 od)}
				   then false {some q fails unitary to ht}
				   else pos_tester(xSHS, lambdaSHS, htSHS, gamma)
				   fi;
			   v:=Kcv;
			   statuses#:=boo;
			   charvecs#:=v
		   fi
	 in vecnum
    then SHthruple_known_Kchar_no_stat(ratvec gamma, vec KCv) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain(gamma)
	 fi;
    	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then charvecs #:= KCv
		   fi
	 in vecnum
    then SHthruple_no_stat(ratvec gamma) = int:
    	 if not (deform_loc_flag or deform_nonu_flag)
	 then return SHthruple_plain(gamma)
	 fi;
    	 let rp = for M in redpoints
		   do set_bit_positions(M) {this is [int]}
		   od {this is [[int]]}
	 then loc = for av@j in rcor
	      	    do location(rp[j],av*gamma)
	    	    od
	 then VECNUM = vechash.size()
	 then vecnum = vechash.match(loc)
	 {then () = prints("vechashes[rfnum][htnum] = ",vechashes[rfnum][xlnum][htnum].list())
	 then () = prints("loc = ",loc)}
	 then () = if vecnum = VECNUM {new location rel hyperplanes}
	      	   then let KCv = Kchar_vec(xSHS,lambdaSHS,htSHS,gamma)
			in charvecs #:= KCv
		   fi
	 in vecnum
      in
  ( ( -> ): {clear} clear_SHS
  , ((KGBElt, ratvec, int, bool) ->): {reset_with_ht_min} (KGBElt x, ratvec lambda, int HT, bool minBool) void:
    min_flag:=minBool;
    if xSHS = x and lambdaSHS = lambda
    then if htSHS = HT
    	 then return ()
	 else SHSnew_ht(HT);
	      return()
	 fi
    fi;
    rfSHS := x.real_form;
    xSHS := x;
    lambdaSHS := lambda;
    p0 := parameter(xSHS,lambdaSHS,0*lambdaSHS);
    let (,pL) = theta_stable_quasi_data(p0)
    then () = p0L:= pL
    then min_ht_max = max(for mu in LKTs(p0) do minBottomData.G_min_height(mu) od)
    in dlSHS := (1+xSHS.involution)*(lambdaSHS.numer);
       let (wm,) = from_dominant(rfSHS, dlSHS)
       in wmin:=wm.inverse;
       rcor := red_coroots_rp(x,lambda);
       SL := to_bitset(for av@j in rcor do if (av*dlSHS).= then [j] else [] fi od.##);
       rcorL := (for j in set_bit_positions(SL) do rcor[j]*wmin od){*wmin}; {outside fails?}
       htSHS := HT;
       vechash.clear();
       redpoints := for list in red_points_scr(x,lambda,HT)
		  do to_bitset(list)
		  od;
       redpointsL := for j in set_bit_positions(SL)
       		     do redpoints[j]
		     od;
       statuses := [];
       vechashL.clear();
       statusesL := [];
       sigsL := [];
       charvecs := [];
       charvecsL := []
  , ((KGBElt, ratvec, int) ->): {reset_with_ht} (KGBElt x, ratvec lambda, int HT) void:
    if xSHS = x and lambdaSHS = lambda
    then if htSHS = HT
    	 then return ()
	 else SHSnew_ht(HT);
	      return()
	 fi
    fi;
    rfSHS := x.real_form;
    xSHS := x;
    lambdaSHS := lambda;
    p0 := parameter(x,lambda,0*lambda);
    let (,pL) = theta_stable_quasi_data(p0)
    then () = p0L:= pL
    then min_ht_max = max(for mu in LKTs(p0) do minBottomData.G_min_height(mu) od)
    in dlSHS := (1+x.involution)*(lambda.numer);
       let (wm,) = from_dominant(rfSHS, dlSHS)
       in wmin:=wm.inverse;
       min_flag:= steve_min_flag and
       		   x.number > (#KGB(rfSHS))/3 and
		   (height(p0) > 0) and (min_ht_max > height(p0));
       rcor := red_coroots_rp(x,lambda);
       SL := to_bitset(for av@j in rcor do if (av*dlSHS).= then [j] else [] fi od.##);
       rcorL := (for j in set_bit_positions(SL) do rcor[j]*wmin od){*wmin}; {outside fails?}
       htSHS := HT;
       vechash.clear();
       redpoints := for list in red_points_scr(x,lambda,HT)
		  do to_bitset(list)
		  od;
       redpointsL := for j in set_bit_positions(SL)
       		     do redpoints[j]
		     od;
       statuses := [];
       vechashL.clear();
       statusesL := [];
       sigsL := [];
       charvecs := [];
       charvecsL := []
  , ((KGBElt, ratvec) ->): {reset} (KGBElt x, ratvec lambda) void:
    rfSHS := x.real_form;
    xSHS := x;
    lambdaSHS := lambda;
    p0 := parameter(xSHS,lambdaSHS,0*lambdaSHS);
    let (,pL) = theta_stable_quasi_data(p0)
    then () = p0L := pL
    then min_ht_max = max(for mu in LKTs(p0) do minBottomData.G_min_height(mu) od)
    in dlSHS := (1+xSHS.involution)*(lambdaSHS.numer);
       let (wm,) = from_dominant(rfSHS, dlSHS)
       in wmin:=wm.inverse;
       min_flag := (height(p0) > 0) and (min_ht_max > height(p0));
       {min_height := min_ht_max;}
       rcor := red_coroots_rp(x,lambda);
       SL := to_bitset(for av@j in rcor do if (av*dlSHS).= then [j] else [] fi od.##);
       rcorL := (for j in set_bit_positions(SL) do rcor[j]*wmin od){*wmin};
       {rcorL := red_coroots(p0L.x);}
       vechash.clear();
       redpoints := [];
       statuses := [];
       vechashL.clear();
       statusesL := [];
       sigsL := [];
       charvecs := [[]];
       charvecsL:=[];
       redpointsL := []
       		  {for j in set_bit_positions(SL)
    	       	  do to_bitset(red_points(xSHS, lambdaSHS, rcor[j], -1))
		  od}
  , (-> vec_hash): {vecHash} @vec_hash: vechash
  , ( -> [[int]]): {red_points} @[[int]]:
    	 for M in redpoints do set_bit_positions(M) od
  , ( -> [bool]): {postests} @[bool]: statuses
  , ( -> bool): {min_flag} @bool: min_flag
 { , ( -> vec_hash): {vecHashL} @vec_hash: vechashL
  , ( -> [[int]]): {red_pointsL} @[[int]]: for M in redpointsL do set_bit_positions(M) od
  , ( -> [bool]): {postestsL} @[bool]: statusesL
  , ( -> KTypePol): {sigL0} @KTypePol:
    sum(rfSHS, for q in monomials(parameter(xSHS, lambdaSHS, 0*lambdaSHS))
    	       do min_bottom_sig(q)
	       od)
  , ( -> [KTypePol]): {sigsL} @[KTypePol]: sigsL}
  , ( -> [vec]): {extra_coords} @[vec]: charvecs
  , ((ratvec, vec) -> bool): {postest_known_Kchar} (ratvec gamma, vec KCv) bool:
    statuses[SHthruple_known_Kchar(gamma,KCv)]
  , (int -> bool): {indexed_postest} (int vecnum) bool:
    statuses[vecnum]
  , ((ratvec) -> bool): {postest} (ratvec gamma) bool:
    statuses[SHthruple(gamma)]
  , (vec -> int): {lookup} (vec loc) int:
    let ell = vechash.lookup(loc)
    in if ell < 0 then 0
       elif statuses[ell] then 1
       else -1
       fi
  , (ratvec -> vec): {umatch} (ratvec gamma) vec: charvecs[SHthruple_known_stat(gamma,true)]
  , (ratvec -> vec): {numatch} (ratvec gamma) vec: charvecs[SHthruple_known_stat(gamma,false)]
{  , (ratvec -> bool): {postestL} (ratvec gamma) bool:
    statusesL[SHthrupleL(gamma)]}
{  , (int -> bool): {indexed_postestL} (int vecnumL) bool:
    statusesL[vecnumL]}
{  , (ratvec -> KTypePol): {sigL} (ratvec gamma) KTypePol:
    sigsL[SHthrupleL(gamma)]}
  , (ratvec -> vec): {extra_coord} (ratvec gamma) vec:
    let vecnum = SHthruple(gamma)
    in charvecs[vecnum]
  , ((ratvec, vec) -> vec): {thruple_known_Kchar} (ratvec gamma, vec KCv) vec:
    vechash.index(SHthruple_known_Kchar(gamma,KCv))
  , (int -> vec): {indexed_thruple} (int vecnum) vec:
    vechash.index(vecnum)
  , (ratvec -> vec): {thruple} (ratvec gamma) vec:
    vechash.index(SHthruple(gamma))
  , ((ratvec, vec) -> vec): {thruple_known_Kchar_no_stat} (ratvec gamma, vec KCv) vec:
    vechash.index(SHthruple_known_Kchar_no_stat(gamma,KCv))
  , (ratvec -> vec): {thruple_no_stat} (ratvec gamma) vec:
    vechash.index(SHthruple_no_stat(gamma))
{  , (ratvec -> vec): {Lthruple} (ratvec gamma) vec:
    vechashL.index(SHthrupleL(gamma))}
  , ( -> Param): {pzero} @Param: p0
)
)

set steve_hash_small = make_steve_hash_small()
set steve_small_flag = true

set location_finder_time = int: 0
set loclist_time = int: 0

{local faces LFKH; determine which are unitary to height HT; each entry size d+3, last two being KCv
PERHAPS FOR LOWER height}
set location_finder_add_Kchar(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [FaceVertsIndex] LFcat) = (vec_hash, [vec], [int], [[int]]):
    let start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then extra_coord_flag_hold = extra_coord_flag
    then () = extra_coord_flag:=true
    then lochash = {if steve_small_flag
    	 	   then} steve_hash_small.reset_with_ht(x,lambda,HT);
		   	steve_hash_small.vecHash(HT)
		   {else steve_hash.vecHash(x, lambda, HT)
		   fi}
    {make_vec_hash()} {list of all locations of faces in LFKH}
    {then loclist = [int]:[] {for each face in LFKHcat, index of location}}
    {then KCvlist = [vec]:
    	 if steve_small_flag
	 then steve_hash_small.extra_coords(HT)
	 else steve_hash.extra_coords(x, lambda, HT)
	 fi}
    {then () = prints("in location_finder, start with lambda = ",lambda, ", lochash.size() = ",
    lochash.size(), ", KCvlist = ", KCvlist)}
    	{for each location in lochash, vec of size 2 [index of Kchar, #LQ's]}
    then red_co = red_coroots_rp(x,lambda)
    then red_pts = {if steve_small_flag
	 	   then} steve_hash_small.red_points(HT)
	 	   {else steve_hash.red_points(x, lambda, HT)
	 	   fi}
    then facelist = [[int]]: for j:lochash.size() do [] od
    {entry k is numbers of faces of location #k in lochash}
    then empty = [int]: []
    then startloc = elapsed_ms()
    then loclist = for verts@N in LFcat
    	      	   do let {d = #v-3 {dimension of face}
	      	      then verts = v[:d+1]
		      then} gamma = face_bary(Lvd,verts)
		      then p = parameter(x,lambda,gamma)
		      then LOCNUM = lochash.size()
		      then loc = {if steve_small_flag
	 	      	       	 then} steve_hash_small.thruple_no_stat(gamma)
	 	   		 {else steve_hash.thruple_no_stat(x, lambda, HT, gamma)
	 	   		 fi}
		      then locnum = lochash.match(loc)
		      in if lochash.size() > LOCNUM {haven't seen this location before}
		      	 then facelist #:= empty;
			      let extra = vec:
			      	 {if steve_small_flag
	 	      	       	 then} steve_hash_small.extra_coord(gamma)
	 	   		 {else steve_hash.extra_coord(x, lambda, HT, gamma)
	 	   		 fi}
			      {[Kpol_hash.match(K_type_pol(
			      character_formula_to_ht(1*p,HT))),v[d+2]]}
			      in  assert(@:Kpol_hash.match(K_type_pol(character_formula_to_ht(1*p,HT)))
						= extra[0],"bad extra")
			 fi;
			 facelist[locnum]#:=N;
			 locnum
		   od
   in assert(@:unitary_test_counter.use_count() = start_count, "unitarity testing in location_finder_add_K_char");
      location_finder_time +:= elapsed_ms() - start;
      loclist_time +:= elapsed_ms() - startloc;
      extra_coord_flag:=extra_coord_flag_hold;
   (lochash,  {if steve_small_flag
   	      then} steve_hash_small.extra_coords(HT), loclist,facelist)
	      {else steve_hash.extra_coords(x, lambda, HT)
	      fi , loclist, facelist)}


{local faces LFKH; determine which are unitary to height HT; each entry size d+3, last two being KCv
PERHAPS FOR LOWER height}
set location_finder(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [FaceVertsKHash] LFKHcat) = (vec_hash, [vec], [int], [[int]]):
    let start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then lochash = {if steve_small_flag
    	 	   then} steve_hash_small.reset_with_ht(x,lambda,HT);
		   	steve_hash_small.vecHash(HT)
		   {else steve_hash.vecHash(x, lambda, HT)
		   fi}
    {make_vec_hash()} {list of all locations of faces in LFKH}
    {then loclist = [int]:[] {for each face in LFKHcat, index of location}}
    then KCvlist = [vec]:
    	 {if steve_small_flag
	 then} steve_hash_small.extra_coords(HT)
	 {else steve_hash.extra_coords(x, lambda, HT)
	 fi}
    {then () = prints("in location_finder, start with lambda = ",lambda, ", lochash.size() = ",
    lochash.size(), ", KCvlist = ", KCvlist)}
    	{for each location in lochash, vec of size 2 [index of Kchar, #LQ's]}
    then red_co = red_coroots_rp(x,lambda)
    then red_pts = {if steve_small_flag
	 	   then} steve_hash_small.red_points(HT)
	 	   {else steve_hash.red_points(x, lambda, HT)
	 	   fi}
    then facelist = [[int]]: for j:lochash.size() do [] od
    {entry k is numbers of faces of location #k in lochash}
    then empty = [int]: []
    then startloc = elapsed_ms()
    then loclist = for v@N in LFKHcat
    	      	   do let d = #v-3 {dimension of face}
	      	      then verts = v[:d+1]
		      then gamma = face_bary(Lvd,verts)
		      then p = parameter(x,lambda,gamma)
		      then LOCNUM = lochash.size()
		      then loc = {if steve_small_flag
	 	      	       	 then} steve_hash_small.thruple_no_stat(gamma)
	 	   		 {else steve_hash.thruple_no_stat(x, lambda, HT, gamma)
	 	   		 fi}
		      then locnum = lochash.match(loc)
		      in if lochash.size() > LOCNUM {haven't seen this location before}
		      	 then facelist #:= empty;
			      let extra = vec:
			      	 {if steve_small_flag
	 	      	       	 then} steve_hash_small.extra_coord(gamma)
	 	   		 {else steve_hash.extra_coord(x, lambda, HT, gamma)
	 	   		 fi}
			      {[Kpol_hash.match(K_type_pol(
			      character_formula_to_ht(1*p,HT))),v[d+2]]}
			      in  assert(@:Kpol_hash.match(K_type_pol(character_formula_to_ht(1*p,HT)))
						= extra[0],"bad extra")
			 fi;
			 facelist[locnum]#:=N;
			 locnum
		   od
   in assert(@:unitary_test_counter.use_count() = start_count, "unitarity testing in location_finder");
      location_finder_time +:= elapsed_ms() - start;
      loclist_time +:= elapsed_ms() - startloc;
   (lochash,  {if steve_small_flag
   	      then} steve_hash_small.extra_coords(HT)
	      {else steve_hash.extra_coords(x, lambda, HT)
	      fi} , loclist, facelist)

set location_finder(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH) =
(vec_hash, [vec], [int], [[int]]):
location_finder(x, lambda, HT, Lvd, LFKH.##)

set up_graph_gens_time = int: 0

{Describe directed graph with nodes the entries of vec_hash FOR WHICH FACELIST NOT EMPTY.
entry m0 in answer is all m1
so there is a directed node m0 -> m1: nonunitary at m0 implies nonunitary at m1. Equiv,
unitary at m1 implies unitary at m0.}
set up_graph_gens(vec_hash lochash, [vec] KCvs, [int] loclist) = [[int]]:
    let start = elapsed_ms()
    then edge_gens = [[int]]: for m:lochash.size() do [] od
    then () = for loc@m0 in lochash.list()
    	      do let def_tester = is_def_tester(loc)
       	      	 in for locdef@m1 in lochash.list()[:m0]
       	  	    do if def_tester(locdef)
	     	       then edge_gens[m1]#:= m0;
	     	       	    if KCvs[m0] = KCvs[m1]
		       	    then edge_gens[m0] #:= m1; {this says m0 is equiv to m1, so maybe don't need further edges???}
			    break
		  	    fi
	      	       fi
		    od
	       od
    in up_graph_gens_time+:= elapsed_ms() - start;
       edge_gens

{output is what was generally called (eq,gr) in FPP_localDirac.at}
{USE strong_components!}
{set graph([[int]] edges) = ([[int]],[[int]]):
    strong_components(edges)}

set graph_tilde_flag = false {so always run through graph "large" faces (highly deformable) to small}
set steve_graph_test_time = int:0
set local_test_graph_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [FaceVertsKHash] LFKHcat, {don't sort by dim; may or may not have Kcharvec, according to flag K_chars_yet}
    int HT, bool K_chars_yet
     ) = [FaceVertsKHash]:
begin
    let (lochash, KCvlist, loclist, facelist) =
    	if not K_chars_yet
	then location_finder_add_Kchar(x, lambda, HT, Lvd, LFKHcat)
	else location_finder(x, lambda, HT, Lvd, LFKHcat)
	fi, G = x.real_form
    then start = elapsed_ms()
    then inv_is = [int]: for j:#facelist do -1 od {if j is ith good, then  jth entry is i}
    then good_js = [int]:
    	 let i = 0
	 in for list@j in facelist
    	    do if #list>0
	       then inv_is[j] := i;
		    i+:=1;
		    [j]
	       else []
	       fi
	    od.##
    then short_facelist = for j in good_js do facelist[j] od
    then () = assert(@:sum(for list in short_facelist do #list od) = #LFKHcat)
    then short_KCvlist = for j in good_js do KCvlist[j] od
    then short_loclist = for j in loclist do inv_is[j] od
    then short_lochash = make_vec_hash()
    then () = for j in good_js do short_lochash.match(lochash.index(j)) od
    then tester(Param p) =
    	 if HT >= 0
	 then is_unitary_to_ht_big_SIMPLE_interrupt_pick(p,HT)
	 else is_unitary_test_big_SIMPLE_interrupt(p)
	 fi
    then up_gens = up_graph_gens(short_lochash, short_KCvlist, short_loclist)
    then (eq,gr) = strong_components{graph}(up_gens)
    then NumClasses = #eq, printInterval = int: 1, start_count = unitary_test_counter.use_count()
    then statuses = [string]: for j:#eq do "?" od
    {then () = for k:#eq
    	      do let C = eq[k]
	      	 then Ns = for j in C
		      	   do short_face_list[j]}
    {would like to list faces in C and see whether any is marked (from warmup) in steve_hash_small}
    then () = if fund_face_verbose
	      then prints("Examining ",NumClasses," classes in local_test_graph_steve to ht ",
	      	   	   HT)
	      fi
    then nums = #NumClasses {[0,1,2..NumClasses-1]}
    then freq = max(NumClasses\20,1)
    then count = int:0
    then end_shift = int: if K_chars_yet then 3 else 1 fi
    then () = if graph_tilde_flag then nums:=~nums fi
    then () = for k in nums
    	      do if fund_face_verbose and (k%freq).=
	      	 then prints("at class ",k," of ",NumClasses, " at time ",
		      		 print_time_string(elapsed_ms() - start))
		 fi;
	      if statuses[k] = "?"
	      	 then let C = eq[k] {list of locs}
		 {then loc = steve_hash_small.vecHash().index(loclist[C[0]]) {location vector for C}
		 then known = steve_hash_small.lookup(loc)
		 then () = if known != 0
		      	   then prints("Class ",k," already had status ",known)
			   fi
		 then () = statuses[k] :=
		      	 if known > 0
 		      	 then if not graph_tilde_flag
		    	      then downdateUclassesB(statuses, gr, k, "T") {needed only in forward eq}
			      fi;
		      	      "T"
		      	 elif known < 0
			 then if graph_tilde_flag
		    	      then updateNUclassesB(statuses, gr, k, "F") {needed only in backward eq}
			      fi;
		      	      "F"
			 else "$"
		      	 fi}
		 {in if statuses[k] = "?"}
		    then {let} N = if graph_tilde_flag
		      	       	 then short_facelist[C~[0]]~[0] {last face for last loc in C}
			      	 else short_facelist[C[0]][0] {first face for first loc in C}
			      	 fi
		      then v = LFKHcat[N]
		      then d = #v-end_shift
		      then verts = v[:d+1]
		      then gamma = face_bary(Lvd,verts)
		      then p = parameter(x,lambda,gamma)
    		      in statuses[k]:=
		      	 if all(for q in monomials(1*p)
		      	    	do @bool: tester(q)
			   	od)
		    	 then if not graph_tilde_flag
		    	      then downdateUclassesB(statuses, gr, k, "T") {needed only in forward eq}
			      fi;
		      	      "T"
		    	 else if graph_tilde_flag
		    	      then updateNUclassesB(statuses, gr, k, "F") {needed only in backward eq}
			      fi;
		      	      "F"
		    	 fi {all(q in monomials}
		    fi {statuses[k] = "?"}
	       od

     {then () = prints("statuses = ",statuses)}
     {make new local face list using only faces not already proven nonunitary}
     then LFKHnew = [FaceVertsKHash]:
	  for C@m in eq {C is a list of locs}
	  do if statuses[m][0] = "T"
	     then for k in C 
		  do let js = short_facelist[k]
		     in for j in js
		     	do {assert(precheck[j],"bad true with local_test_graph");}
		     	   LFKHcat[j]
			od {[FaceVertsKHash]}
		  od.## {still [FaceVertsKHash]}
	     else []
	     fi
	  od.##
     then () = if fund_face_verbose
	       then prints("Total of ", count(for ans in statuses do ans[0] = "T" od),
				 " classes are unitary candidates, giving ", #LFKHnew,
			   " unitary_to_ht faces")
	       fi

     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
			       " for local_test_graph_steve; number of tests = ",
			       unitary_test_counter.use_count() - start_count) fi
     in  steve_graph_test_time+:= elapsed_ms() - start;
     	 LFKHnew
{if sort_LFD_flag
	 then sort(x.real_form, Lvd, LFKHnew)
	 else LFKHnew
	 fi}
end

set report_steve_graph() = void:
     prints(print_time_string(location_finder_time), " for location_finder, incl ",
     		print_time_string(rp_time), " for red_points, and ",
     		print_time_string(loclist_time)," for listloc, incl ",
		print_time_string(Kchar_vec_time)," for Kchar_vec.");
     prints(print_time_string(up_graph_gens_time), " for steve_graph construction; ",
     		print_time_string(steve_graph_test_time), " for testing with steve_graph.")

set report_steve_clear() = void:
    location_finder_time:=0;
    loclist_time:=0;
    steve_graph_test_time:=0;
    up_graph_gens_time:=0

set warmup_time = int: 0
set warmup_flag = true

{put known statuses into steve_hash_small}
set warmup(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsIndex]] FVIs) = [[FaceVertsIndex]]:
    if warmup_flag = false then return FVIs fi;
    {skipping saves 122/446 in Spin(4,4); 122/221 in steve}
    let start= elapsed_ms()
    then answer =
    for FVI@d in FVIs
    do for v in FVI
       do let gamma = face_bary(Lvd, v[:d+1])
       	  then qs = monomials(finalize(parameter(x,lambda,gamma)))
	  {then stats = for q in qs do status(q,HT) od}
       	  in if any({for stat in stats do stat < 0}
	            for q in qs do not big_unitary_hash.nu_height_lookup_bool(q,HT)
	     	    od)
       	     then steve_hash_small.numatch(gamma);
	     []
	     elif all(for {stat in stats do stat > 0}
	     	  	  q in qs do big_unitary_hash.ulookup(q).>=
	     	      od) 
	     	     {or (let m = u_to_ht_hash.lookup(q)
		     	 in m.>= and u_to_ht_hts[m] >= HT) od)}
       	     then steve_hash_small.umatch(gamma);
	     [v]
	     else [v]
	     fi
       od.##
    od
    in warmup_time +:= elapsed_ms() - start;
       answer

{takes x, lambda, HT, Lvd and computes local vertices, imposing
hermitian, pos on LKTs, pos to HT, and Dirac.}
set localFD_1SteveU\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if not is_pos_on_LKTs(parameter(x,lambda,0*lambda))
    then return []
    fi;
    if fund_face_verbose
    then prints(new_line,"start localFD_1SteveU to ht ",HT)
    fi;
    steve_hash_small.reset_with_ht_min(x,lambda,HT, false); {don't do min_bottom}
    {if fund_face_verbose then prints("looks like p0 = ",steve_hash_small.pzero()) fi;}
    let G = x.real_form, start = elapsed_ms(), (rfnum, xlnum, htnum) =
    	{if steve_small_flag
	then} (0,0,0)
	{else steve_hash.indices(x, lambda, HT)
	fi}
    then LF00 = [FaceVertsIndex]: for j:#Lvd.list do [j] od
    then LF01 = warmup(x,lambda,HT,Lvd,[LF00])[0]
    then Q = (ratvec,ratvec ->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not (Dirac_best_flag and extra_coord_flag) then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = invariant_form(x.real_form)
	      then best_bounds = for mu in mus
	      	   	       	 do let (taus,hs,bs) = truncate(best_Dirac_bound(mu),HT)
				    in if #bs > 0
				       then [(taus,hs,bs)]
				       else []
				       fi
				  od.##
	      then bestbd = if #best_bounds = 0
	      	   	    then 0/1
			    else min(for (,hs,bs) in best_bounds
				do bs~[0]
				od)
			    fi
	     {then () = prints("best_bounds = ",best_bounds)}
	     then index = if bestbd.=
	     	  	  then -1
			  else first(for v in LF01
				     do let gamma = Lvd.list[v[0]]
				     	in @bool: QG(gamma,gamma) > bestbd
				     od)
			  fi
	     in if index.>=
		then DiracBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
	 {don't need this next test; we are just throwing out nonunitary singletons}
    then temp_Dirac_flag =
    	 if Dirac_flag and not(temp_Dirac_best_flag) {and
    	 		       max(for mu in LKTs(parameter(x,lambda,0*lambda)) do tensor_p_hts(mu) od) <=HT}
	 then let bd = DiracBD(x,lambda)
	      then QG = invariant_form(G)
	      then index = first(for v in LF01
				 do let gamma = Lvd.list[v[0]]
				    in @bool: QG(gamma,gamma) > bd
				 od)
	      in if index.>=
		 then Q:=QG; DiracBD:=bd; true
		 else false
		 fi
	  else false
	  fi {these two flags best_Dirac and _Dirac are either FF, FT, or TF}
    then extra = vec:[]
    then length = #LF01  {(Lvd.list)}
    then freq = max(length\20,1)
    then count = int:0
    then answer = [vec]:
    	 if steve_tilde_flag
	 then for v@k in LF01
       	 ~do if fund_face_verbose and (k<=20 or (k%freq).=)
	      	  then prints("at vertex ",k," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",{if steve_small_flag
		       	  	       	   then} steve_hash_small.vecHash().size()
					   {else steve_hash.vecHash(x,lambda,HT).size()
					   fi});
			{if steve_small_flag
			then} prints("So far ",count," verts unitary to ",HT{,"; vecLHash size = ",
			     steve_hash_small.vecHashL().size()})
			{fi}
	     fi;
	     	  let gamma = Lvd.list[v[0]]
		  then p = parameter(x,lambda,gamma)
		  in if not is_hermitian(p)
		     then []
		     elif temp_Dirac_best_flag and Q(gamma,gamma) > DiracBD
		     	  and (let () = extra:=Kchar_vec(x,lambda,HT,gamma)
		     	       in not DiracBestTest(p,HT,Kpol_hash.index(extra[0])))
		     then DBTcount +:=1;
		     	  if steve_small_flag
			  then steve_hash_small.numatch(gamma)
			  fi;
			  [] {DiracBest says nonunitary}
		     elif temp_Dirac_flag and Q(gamma,gamma) > DiracBD
		     then DTcount +:= 1;
		     	  if steve_small_flag
			  then steve_hash_small.numatch(gamma)
			  fi;
			  [] {Dirac says nonunitary}
	     	     elif if #extra = 0 and extra_coord_flag
		     	  then extra:=Kchar_vec(x,lambda,HT,gamma)
			  fi;
		     	  {if steve_small_flag
		     	  then} steve_hash_small.postest_known_Kchar(gamma,extra)
			  {else steve_hash.partly_indexed_postest_known_Kchar(rfnum, xlnum, htnum, gamma,extra)
			  fi}
	     	     then count+:=1;
			  [v##extra] {unitary to HT!}
	     	     else [] {pos test failed}
	     	     fi
	       od.## {list of candidate vertices}
       	 else  for v@k in LF01
	       do if fund_face_verbose and (k<=20 or (k%freq).=)
	      	  then prints("at vertex ",k," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",{if steve_small_flag
		       	  	       	   then} steve_hash_small.vecHash(HT).size()
					   {else steve_hash.vecHash(x,lambda,HT).size()
					   fi});
			{if steve_small_flag
			then} prints("So far ",count," verts unitary to ",HT{,"; vecLHash size = ",
			     steve_hash_small.vecHashL().size()})
			{fi}
	     	  fi;
	     	  let gamma = Lvd.list[v[0]]
		  then p = parameter(x,lambda,gamma)
	     	  in if not is_hermitian(p)
	     	     then []
		     elif temp_Dirac_best_flag and Q(gamma,gamma) > DiracBD
		     	  and (let () = extra:=Kchar_vec(x,lambda,HT,gamma)
		     	       in not DiracBestTest(p,HT,Kpol_hash.index(extra[0])))
		     then DBTcount +:=1;
		     	  if steve_small_flag
			  then steve_hash_small.numatch(gamma)
			  fi;
			  [] {DiracBest says nonunitary}
		     elif temp_Dirac_flag and Q(gamma,gamma) > DiracBD
		     then DTcount +:= 1;
		     	  if steve_small_flag
			  then steve_hash_small.numatch(gamma)
			  fi;
			  [] {Dirac says nonunitary}
	     	     elif if #extra = 0 and extra_coord_flag
		     	  then extra:=Kchar_vec(x,lambda,HT,gamma)
			  fi;
			  {if steve_small_flag
		     	  then} if extra_coord_flag
			       then steve_hash_small.postest_known_Kchar(gamma,extra)
			       else steve_hash_small.postest(gamma)
			       fi
			  {else if extra_coord_flag
			       then steve_hash.partly_indexed_postest_known_Kchar(rfnum, xlnum, htnum, gamma, extra)
			       else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, gamma)
			       fi
			  fi}
		     then count+:=1;
			 [v##extra] {unitary to HT!}
	     	     else [] {pos test failed}
	     	     fi
	       od.## {list of candidate vertices}
	    fi
{next step is needed because of comment before localFD_2SteveU}
    then () = answer:= if steve_tilde_flag
    	      	       then for v in answer ~do v od
		       else answer
		       fi
    in if fund_face_verbose
       then prints("Found ",#answer," vertices to ht ",HT," in time ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ", {if steve_small_flag
	    		    	      then} steve_hash_small.vecHash(HT).size()
				      {else steve_hash.vecHash(x,lambda,HT).size()
				      fi}){;
	    prints("LF0 = ",answer)}
       fi;
       {if fund_face_verbose then prints("result for localFD_1SteveU to ht = ", answer) fi;}
       answer
)


{takes x, lambda, HT, Lvd and computes local vertices, imposing Dirac,
hermitian, pos on LKTs, and pos to min-lowest K-types to HT.}
set localFD_1SteveUmin\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if not is_pos_on_LKTs(parameter(x,lambda,0*lambda))
    then return []
    fi;
    if fund_face_verbose
    then prints(new_line,"start localFD_1SteveUmin to ht ",HT)
    fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    {if fund_face_verbose then prints("looks like p0 = ",steve_hash_small.pzero()) fi;}
    let G = x.real_form, start = elapsed_ms(), (rfnum, xlnum, htnum) =
    	{if steve_small_flag
	then} (0,0,0)
	{else steve_hash.indices(x, lambda, HT)
	fi}
    then LF00 = [FaceVertsIndex]: for j:#Lvd.list do [j] od
    then LF01 = warmup(x,lambda,HT,Lvd,[LF00])[0]
    then Q = ((ratvec,ratvec)->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag {and max(for mu in LKTs(parameter(x,lambda,0*lambda)) do tensor_p_hts(mu) od) <=HT}
	      then let bd = DiracBD(x,lambda)
		   then QG = invariant_form(G)
		   then index = first(for v in LF01
				      do let gamma = Lvd.list[v[0]]
				      	 in @bool: QG(gamma,gamma) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then length = #(Lvd.list)
    then freq = max(length\100,1)
    then count = int:0
    then answer = [vec]:
    	 if steve_tilde_flag
	 then for v@j in Lvd.list
       	 ~do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",{if steve_small_flag
		       	  	       	   then} steve_hash_small.vecHash().size()
					   {else steve_hash.vecHash(x,lambda,HT).size()
					   fi});
			{if steve_small_flag
			then} prints("So far ",count," verts min-unitary to ",HT{,"; vecLHash size = ",
			     steve_hash_small.vecHashL().size()})
			{fi}
	     	  fi;
	     	  let p = parameter(x,lambda,v)
	     	  in if not is_hermitian(p)
	     	     then []
		     elif Q(v,v) > DiracBD
		     then DTcount +:= 1;
		     	  {if steve_small_flag
			  then} steve_hash_small.numatch(v)
			  {fi};
			  []
		     else {is_pure(to_ht(steve_hash_small.sigL(v),HT))}
	     	     {then} let extra = if extra_coord_flag
		     	      	      then {if steve_small_flag
				      	   then} steve_hash_small.extra_coord(v)
				      	   {else steve_hash.extra_coord(x,lambda,HT,v)
					   fi}
				       else null(0)
				       fi
		     	   in count+:=1;
			      [[j]##extra]
	     	     {else [] {min pos test failed}}
	     	     fi
	       od.## {list of j for which vertex j is a min-unitary candidate}
       	 else  for v@j in Lvd.list
	       do if fund_face_verbose and (j%freq).=
	      	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",{if steve_small_flag
		       	  	       	   then} steve_hash_small.vecHash().size()
					   {else steve_hash.vecHash(x,lambda,HT).size()
					   fi});
			{if steve_small_flag
			then} prints("So far ",count," verts min-unitary to ",HT{,"; vecLHash size = ",
			     steve_hash_small.vecHashL().size()})
			{fi}
	     	  fi;
	     	  let p = parameter(x,lambda,v)
		  {then () = if fund_face_verbose
		       	    then prints("p = ",p,", sigL(v) = ", steve_hash_small.sigL(v))
			    fi}
	     	  in if not is_hermitian(p)
	     	     then []
		     elif Q(v,v) > DiracBD
		     then DTcount +:= 1; []
		     {elif is_pure(to_ht(steve_hash_small.sigL(v),HT))}
	     	     else let extra = if extra_coord_flag
		     	      	      then {if steve_small_flag
				      	   then} steve_hash_small.extra_coord(v)
				      	   {else steve_hash.extra_coord(x,lambda,HT,v)
					   fi}
				       else null(0)
				       fi
		     	   in count+:=1;
			      [[j]##extra]
	     	     {else [] {min pos test failed}}
	     	     fi
	       od.## {list of candidate vertices}
	    fi
{next step is needed because of comment before localFD_2SteveU}
    then () = answer:= if steve_tilde_flag
    	      	       then for v in answer ~do v od
		       else answer
		       fi
    in if fund_face_verbose
       then prints("Found ",#answer," vertices to min-unitary to ht ",HT," in time ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ", {if steve_small_flag
	    		    	      then} steve_hash_small.vecHash(HT).size()
				      {else steve_hash.vecHash(x,lambda,HT).size()
				      fi}){;
	    prints("LF0 = ",answer)}
       fi;
       answer
)


{Same using graph of vertices. Output is unitary-to-HT verts, with perhaps two extra coords: Kchar and #LQs}
set localFD_1SteveU_graph\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd) =
    [FaceVertsIndex]:
(   if not is_pos_on_LKTs(parameter(x,lambda,0*lambda))
    then return []
    fi;
    if fund_face_verbose
    then prints(new_line,"start localFD_1SteveUgraph to ht ",HT)
    fi;
    if not is_pos_on_LKTs(parameter(x,lambda,0*lambda)) then return [] fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    let G = x.real_form, start = elapsed_ms(), (rfnum, xlnum, htnum) =
    	{if steve_small_flag
	then} (0,0,0)
	{else steve_hash.indices(x, lambda, HT)
	fi}
    then LF00 = [FaceVertsIndex]: for j:#Lvd.list do [j] od
    then LF01 = warmup(x,lambda,HT,Lvd,[LF00])[0]
    then Q = ((ratvec,ratvec)->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not (Dirac_best_flag and extra_coord_flag) then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = invariant_form(x.real_form)
	      then best_bounds = for mu in mus
	      	   	       	 do let (taus,hs,bs) = truncate(best_Dirac_bound(mu),HT)
				    in if #bs > 0
				       then [(taus,hs,bs)]
				       else []
				       fi
				  od.##
	      then bestbd = if #best_bounds = 0
	      	   	    then 0/1
			    else min(for (,hs,bs) in best_bounds
				do bs~[0]
				od)
			    fi
	     {then () = prints("best_bounds = ",best_bounds)}
	     then index = if bestbd.=
	     	  	  then -1
			  else first(for v in LF01
				     do let gamma = Lvd.list[v[0]]
				     	in @bool: QG(gamma,gamma) > bestbd
				     od)
			  fi
	     in if index.>=
		then DiracBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    then temp_Dirac_flag =
    	 if Dirac_flag and not(temp_Dirac_best_flag) {and
    	 		       max(for mu in LKTs(parameter(x,lambda,0*lambda)) do tensor_p_hts(mu) od) <=HT}
	 then let bd = DiracBD(x,lambda)
	      then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
	      then index = first(for v in LF01
				 do let gamma = Lvd.list[v[0]]
				    in @bool: QG(gamma,gamma) > bd
				 od)
	      in if index.>=
		 then Q:=QG; DiracBD:=bd; true
		 else false
		 fi
	  else false
	  fi {these two flags best_Dirac and _Dirac are either FF, FT, or TF}
    then extra = vec:[]
    then answer = for v@k in LF01
    	       do let gamma = Lvd.list[v[0]]
	       	  then p = parameter(x,lambda,gamma)
	       	  in if not is_hermitian(p)
		     then []
		     elif temp_Dirac_best_flag and Q(gamma,gamma) > DiracBD
		     	  and (let () = extra:=Kchar_vec(x,lambda,HT,gamma)
		     	       in not DiracBestTest(p,HT,Kpol_hash.index(extra[0])))
		     then DBTcount +:=1;
		     	  if steve_small_flag
			  then steve_hash_small.numatch(gamma)
			  fi;
			  [] {DiracBest says nonunitary}
		     elif temp_Dirac_flag and Q(gamma,gamma) > DiracBD
		     then DTcount +:= 1;
		     	  if steve_small_flag
			  then steve_hash_small.numatch(gamma)
			  fi;
			  [] {Dirac says nonunitary}
	     	     else if #extra = 0 and extra_coord_flag
		     	  then extra:=Kchar_vec(x,lambda,HT,gamma)
			  fi;
			  [v##extra] {candidate for testing in graph}
	     	     fi
	       od.## {list of candidate vertices}
    in if fund_face_verbose
       then prints("Found ",#answer," vertices to ht ",HT," in time ",
       	    print_time_string(elapsed_ms() - start));
       	    prints("vecHash size = ", {if steve_small_flag
	    		    	      then} steve_hash_small.vecHash(HT).size()
				      {else steve_hash.vecHash(x,lambda,HT).size()
				      fi}){;
	    prints("LF0 = ",answer)}
       fi; local_test_graph_steve(x,lambda,Lvd,answer,HT,extra_coord_flag)
)


{LF0 is meant to be unitary-to-ht HT vertices, maybe with Kchar and #LQs extra coords. Output is LF1,
same list for edges. LF0 MUST be ordered by first coordinate in order for the edge construction to work.
(Of course that could be fixed, but I haven't bothered.)}
set localFD_2SteveU\
( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
    [FaceVertsIndex]:
(   if #LF0 = 0
    then return []
    fi;
    if fund_face_verbose
    then prints(new_line,"start localFD_2SteveU to height ",HT){;
    	 prints("LF0 = ",LF0)}
    fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    {prints("in localFD_2SteveU, LF0 = ",LF0);}  {COMMENT OUT!}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then ucand_list = big_unitary_hash.uhash(G).list(), nucand_list = big_unitary_hash.nuhash(G).list()
    	 {DUPLICATE ELSEWHERE?}
    then () = for p in ucand_list
    	      do if p.x = x and p.lambda = lambda
		 then steve_hash_small.umatch(p.infinitesimal_character)
		 fi
	      od
    then () = for p in nucand_list
    	      do if p.x = x and p.lambda = lambda
		 then steve_hash_small.numatch(p.infinitesimal_character)
		 fi
	      od
    then Q = ((ratvec,ratvec)->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then FixedList = [int]: for v in LF0
    	 	     	    do let j = v[0]
			       in if j < #Perm2.fixed
			       	  then [j]
				  else break
				  fi
			    od.##
    then f = #FixedList, f0 = #Perm2.fixed
    then TranList = [int]: for v in LF0[f:] do v[0] od {all entries are f0+ index in Perm2.trans}
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number in Lvd
		      	  of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is Perm2.trans[m + f0]}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0 {midpoint of v[2:] is a local vertex}
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT at [",k,",",n,"]!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	   {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in  {prints("FF, FT, TT = ",[#EdgesFixFix,#EdgesFixTrans,#EdgesTransTrans]);}
	       EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
     {then () = prints("#Edges in localFD_2SteveU = ",#Edges)} {COMMENT THIS OUT!}
     then length = #Edges, extra = vec:[]
     then freq = max(length\10,1)
     then (rfnum, xlnum, htnum) = {if steve_small_flag
     	  	  	 	  then} (0,0,0)
				  {else steve_hash.indices(x, lambda, HT)
				  fi}
     then ()= if fund_face_verbose then prints("found ",#Edges," edges.") fi
     then LF1 = [FaceVertsIndex]:
          if steve_tilde_flag {BACKWARD through Edges}
	  then for v@j in Edges
	       ~do if fund_face_verbose and red_count_flag and (j%freq).=
	       	   then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",{if steve_small_flag
		       	  	       	   then} steve_hash_small.vecHash().size()
					   {else steve_hash.vecHash(x,lambda,HT).size()
					   fi})
	     	   fi;
	     let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     in {if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       	then []}
		if Q(nu,nu) > DiracBD
		then DTcount +:=1;
		{if steve_small_flag
		then} steve_hash_small.numatch(nu)
		{fi}; []
	       	elif let () = extra := {if steve_small_flag
		     	      	       then} steve_hash_small.extra_coord(face_bary(Lvd,v))
			 	       {else steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))
			 	       fi}
		     in {if steve_small_flag
		     	then} steve_hash_small.postest_known_Kchar(face_bary(Lvd,v),extra)
		     	{else steve_hash.partly_indexed_postest_known_Kchar(rfnum, xlnum, htnum,
			      face_bary(Lvd,v),extra)
		     	fi}
	       	then [v## if extra_coord_flag then extra else null(0) fi] {pos test passes}
		{then prints("v = ",v, "extras = ", steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v)));}
		else [] {pos test fails}
		  fi {not fewer}
	      od.## {v in Edges}
	      else for v@j in Edges {now FORWARD through Edges}
	       	   do if fund_face_verbose and red_count_flag and (j%freq).=
	       	   then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start),
		       "; vecHash size = ",{if steve_small_flag
		       	  	       	   then} steve_hash_small.vecHash().size()
					   {else steve_hash.vecHash(x,lambda,HT).size()
					   fi})
	     	   fi;
	     let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     in {if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))}
	        if Q(nu,nu) > DiracBD
	       	then DTcount +:=1;
		     {if steve_small_flag
		     then} steve_hash_small.numatch(nu)
		     {fi};
		     []
		 elif let () = extra := {if steve_small_flag
				 then} steve_hash_small.extra_coord(face_bary(Lvd,v))
				 {else steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v))
				 fi}
		      {then real_ans = is_unitary_to_ht(Finalize(p),HT)}
	       	      in {if steve_small_flag
		      	 then} {let steve_ans =} steve_hash_small.postest_known_Kchar(face_bary(Lvd,v),extra)
			      {in assert(@:steve_ans = real_ans,"steve postest problem");
			      	 real_ans}
		     	 {else steve_hash.partly_indexed_postest_known_Kchar(rfnum, xlnum, htnum,
			      face_bary(Lvd,v),extra)
		     	 fi}
		 then [v##if extra_coord_flag then extra else null(0) fi] {pos test passes}
	       	    {then prints("v = ",v, "extras = ", steve_hash.extra_coord(x,lambda,HT,face_bary(Lvd,v)));}
		 else [] {pos test fails}
		 fi {not fewer}
	      od.## {v in Edges}
	      fi {steve_tilde_flag}
	{then () = if steve_tilde_flag
	     	  then LF1 := for v in LF1 ~do v od
		  fi}
    {then () = if time_verbose
    	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    {then () = FD12bzTime +:= elapsed_ms() - start}
    then tail = if (#LF1).=
    	      	then 0
		else {prints("LF1 = ",LF1);}
		     #(LF1[0]) - 2
		fi
    then () = if sort_LFD_flag
       	      then LF1 := sort(G, Lvd, [LF1], tail)[0]
       	      else LF1
       	      fi
    {then () = if steve_tilde_flag
	      then LF1 := for v in LF1 ~do v od
	      fi}
    in if fund_face_verbose
       then prints("After localFD_2SteveU, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]");
       	    prints("vecHash size = ",{if steve_small_flag
	    		    	     then} steve_hash_small.vecHash(HT).size()
				     {else steve_hash.vecHash(x,lambda,HT).size()
				     fi})
       fi;
       LF1
)

{LF0 is meant to be unitary-to-ht HT vertices, with Kchar and #LQs extra coords. Output is [LF0,LF1],
same list for vertices and edges}
{LF0 may be out of order, and this breaks edge hunt}
set localFD_2SteveUgraph\
( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
 [[FaceVertsKHash]]:
(   if #LF0 = 0
    then return []
    fi;
    if fund_face_verbose
    then prints(new_line,"start localFD_2SteveUgraph")
    fi;
    steve_hash_small.reset_with_ht(x,lambda,HT);
    {prints("in localFD_2SteveUgraph, LF0 = ",LF0);}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then () = if #LF0 = 0
    	      then return []
	      fi
    then ucand_list = big_unitary_hash.uhash(G).list(), nucand_list = big_unitary_hash.nuhash(G).list()
    	 {DUPLICATE ELSEWHERE?}
    then () = for p in ucand_list
    	      do if p.x = x and p.lambda = lambda
		 then steve_hash_small.umatch(p.infinitesimal_character)
		 fi
	      od
    then () = for p in nucand_list
    	      do if p.x = x and p.lambda = lambda
		 then steve_hash_small.numatch(p.infinitesimal_character)
		 fi
	      od
    then Q = ((ratvec,ratvec)->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then FixedList = [int]:[], TranList = [int]:[]
    then () = for v in LF0
    	      do let j = v[0]
	      	 in if j < #Perm2.fixed
	       	    then FixedList #:=j
	       	    else TranList #:=j
	       	    fi
	      od
    then () = FixedList := FixedList.sort
    then () = TranList := TranList.sort
    then f = #FixedList, f0 = #Perm2.fixed
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number in Lvd
		      	  of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is Perm2.trans[m + f0]}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0 {midpoint of v[2:] is a local vertex}
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT at [",k,",",n,"]!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	   {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in {prints("FF, FT, TT = ",[#EdgesFixFix,#EdgesFixTrans,#EdgesTransTrans]);}
	   EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
   {then () = Edges := if steve_tilde_flag
   	      	 then for v in Edges
		      ~do v
		      od
		 else Edges
		 fi}
   {then () = prints("#Edges in localFD_2SteveUgraph = ",#Edges)}
   then LF1cand = [LocalFaceVertsKHash]:
        for v@j in Edges
	do let gamma = face_bary(Lvd,v)
	   then p = parameter(x,lambda,gamma)
	   in v##[0,#monomials(1*p)]
	od
   {then () = prints("LF1cand = ",LF1cand)}
   then answer = local_test_graph_steve(x, lambda, Lvd, LF0##LF1cand, HT, true)
   then LF1 = [LocalFaceVertsKHash]:
   	    for v in answer
	    do if #v=4
	       then [v]
	       else []
	       fi
	    od.##
in if fund_face_verbose
   then prints("After localFD_2SteveUgraph, face counts are [", #LF0,",",#LF1,"]");
       	prints("vecHash size = ", {if steve_small_flag
			       	  then} steve_hash_small.vecHash(HT).size()
				  {else steve_hash.vecHash(x, lambda, HT).size()
				  fi})
   fi;
   [LF0,LF1]
)

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces that are unitary to ht HT; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_lookDownSteveU\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t) = [[FaceVertsKHash]]:
(   {if face_verbose
    then prints(new_line,"start localFD_lookDownSteveU, b = ",b,", t = ",t)
    fi;}
    steve_hash_small.reset_with_ht(x,lambda,HT);
    let G = x.real_form, start=elapsed_ms(), (rfnum, xlnum, htnum) = {if steve_small_flag
    	    		 		     	     	    	     then} (0,0,0)
								     {else steve_hash.indices(x, lambda, HT)
								     fi}
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2; dim is the new bigger dim}
    	      do LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],0)
	      	    	       	   in [vec]:
				      for (actual,locs) in acts {vec of size dim+1, coords of subs}
	       	    	      	      do if {if steve_small_flag
				      	    then} steve_hash_small.postest(face_bary(Lvd,actual))
					    {else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum, face_bary(Lvd,actual))
					    fi}
				      	 then [actual]
					 else []
					 fi

			              od.##);
		if fund_face_verbose
		then prints("After dim ",dim,", found face counts ",for list in LFKH do #list od,
		       " at time ",print_time_string(elapsed_ms() - start))
		fi
	 	od{dim:t-#LFKH}
    then () = LFKH := if sort_LFD_flag
    	      	      then sort(G, Lvd, LFKH)
		      else LFKH
		      fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt_lookDownSteveU to dim ",t-1,
			"; face counts = ", for list in LFKH do #list od);
		   prints("vecHash size = ",{if steve_small_flag
			       	   	    then} steve_hash_small.vecHash().size()
				  	    {else steve_hash.vecHash(x, lambda, HT).size()
				  	    fi})
	      fi
    in LFKH
)

{impose unitary to HT on a collection of faces, sorted by dimension}
set test_Steve(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH) =
    [[FaceVertsKHash]]:
    if #LFKH[0] = 0 then return LFKH fi;
    if fund_face_verbose then prints("start test_steve to height ",HT) fi;
    steve_hash_small.reset_with_ht_min(x,lambda,HT,false);
    let start = elapsed_ms(), G = x.real_form, (rfnum, xlnum, htnum) = {if steve_small_flag
    	      		      	      	     	      then} (0,0,0)
						      {else steve_hash.indices(x, lambda, HT)
						      fi}
		{may need to adjust extra coords to reflect K-char to larger height}
    then local_extra_coord_flag = extra_coord_flag {and #LFKH[0][0] = 1}
    then ucand_list = big_unitary_hash.uhash(G).list(), nucand_list = big_unitary_hash.nuhash(G).list()
    	 {DUPLICATE ELSEWHERE?}
    then () = for p in ucand_list
    	      do if p.x = x and p.lambda = lambda
		 then steve_hash_small.umatch(p.infinitesimal_character)
		 fi
	      od
    then () = for p in nucand_list
    	      do if p.x = x and p.lambda = lambda
		 then steve_hash_small.numatch(p.infinitesimal_character)
		 fi
	      od
    then Q = (ratvec,ratvec ->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not (Dirac_best_flag and extra_coord_flag) then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = invariant_form(G)
	      then best_bounds = for mu in mus
	      	   	       	 do let (taus,hs,bs) = truncate(best_Dirac_bound(mu),HT)
				    in if #bs > 0
				       then [(taus,hs,bs)]
				       else []
				       fi
				  od.##
	      then bestbd = if #best_bounds = 0
	      	   	    then 0/1
			    else min(for (,hs,bs) in best_bounds
				do bs~[0]
				od)
			    fi
	     {then () = prints("best_bounds = ",best_bounds)}
	     then index = if bestbd.=
	     	  	  then -1
			  else first(for v in Lvd.list
			       	     do @bool: QG(v,v) > bestbd
				     od)
			  fi
	     in if index.>=
		then DiracBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    then temp_Dirac_flag =
    	 if Dirac_flag and not(temp_Dirac_best_flag) {and
    	 		       max(for mu in LKTs(parameter(x,lambda,0*lambda)) do tensor_p_hts(mu) od) <=HT}
	 then let bd = DiracBD(x,lambda)
	      then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
	      then index = first(for v in Lvd.list
				 do @bool: QG(v,v) > bd
				 od)
	      in if index.>=
		 then Q:=QG; DiracBD:=bd; true
		 else false
		 fi
	  else false
	  fi {these two flags best_Dirac and _Dirac are either FF, FT, or TF}
    then extra = vec:[]
    in for LF@d in LFKH
    do let freq = max(#LF\10,1)
       then answerd =
       	   for v@j in LF
       	   do if (j%freq).= and fund_face_verbose
	      then prints("at face #",j," of ",#LF," at time ",print_time_string(elapsed_ms() - start),
	      "; vecHash size = ",{if steve_small_flag
			       	  then} steve_hash_small.vecHash().size()
				  {else steve_hash.vecHash(x, lambda, HT).size()
				  fi}){;
		   prints(steve_hash_small.sigsL())}
	      fi;
	      v:=v[:d+1];
	      let gamma = face_bary(Lvd, v)
	      in if temp_Dirac_best_flag and Q(gamma,gamma) > DiracBD
		     	  and (let () = extra:=Kchar_vec(x,lambda,HT,gamma)
		     	       in not DiracBestTest(parameter(x,lambda,gamma),HT,Kpol_hash.index(extra[0])))
		 then DBTcount +:=1;
		      {if steve_small_flag
		      then} steve_hash_small.numatch(gamma)
		      {fi};
		      [] {DiracBest says nonunitary}
		 elif temp_Dirac_flag and Q(gamma,gamma) > DiracBD
		 then DTcount +:= 1;
		      {if steve_small_flag
		      then} steve_hash_small.numatch(gamma)
		      {fi};
		      [] {Dirac says nonunitary}
		 elif if #extra = 0 and extra_coord_flag
		      then extra:=Kchar_vec(x,lambda,HT,gamma)
		      fi;
		      {if steve_small_flag
		      then} steve_hash_small.postest_known_Kchar(gamma,extra)
		      {else steve_hash.partly_indexed_postest_known_Kchar(rfnum, xlnum, htnum, gamma,extra)
		      fi}
       	      	 then [v##extra]
	      	 else [] {pos test fails}
		 fi
       	     od.##
	then () = if fund_face_verbose
	     	  then prints("old size = ",#LF,", new size = ",#answerd, ", vecHash size = ",
		       {if steve_small_flag
		       then} steve_hash_small.vecHash().size()
		       {else steve_hash.vecHash(x, lambda, HT).size()
		       fi})
		  fi
	in {if fund_face_verbose then prints("result for test to ht ",HT," is ", answerd) fi;}
	   answerd
    od

set show_steve_flag = false

set first_offset = int:0

{now that steve_min_flag works with smaller H, don't need?}
{set H1_min_factor = rat:2/1}

{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}
set localFD_Steve2(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    ([[FaceVertsKHash]],int):
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1), extra_coord_hold = extra_coord_flag
    then H0 = hts[first_offset]
    then () = if (edge_offset= first_offset)
    	      then extra_coord_flag := true
	      else extra_coord_flag := false
	      fi
    then () = if fund_face_verbose
    	      then prints("orig vert count = ", #(Lvd.list))
	      fi
    then LF0 = {if steve_min_flag and to_ht(steve_hash_small.sigL0(),H0).!=
    	       then localFD_1SteveUmin(x,lambda, H0, Lvd)
	       else} localFD_1SteveU(x,lambda,H0,Lvd)
	       {fi}
    then () = if (#LF0).=
    	      then return ([[],[]],H0)
	      fi
    then () = if fund_face_verbose
    	      then prints("LF0 min-unitary to height ",H0," = ",#LF0)
	      fi
    then () = extra_coord_flag :=true
    {then min_ht_max = max(for mu in LKTs(p0) do minBottomData.G_min_height(mu) od)}
    then H1 = {if steve_min_flag and height(p0) > 0
    	      	 and x.number > (#KGB(x.real_form))/3 and min_ht_max > height(p0)
		 {and (min_ht_max-height(p0)) <= H1_min_factor*(hts[edge_offset]-height(p0))}
    	      then min_ht_max
    	      else} hts[edge_offset]
	      {fi}
    then () = if H1 > H0 {first_offset}
    	      then LF0:= test_Steve(x,lambda,H1,Lvd,[LF0])[0]
	      fi
    then () = if fund_face_verbose
    	      then prints("LF0 to height ",H1," = ",#LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,H1,Lvd,Perm2,LF0)]
    {then () = if fund_face_verbose
    	      then prints("LF1 with extra to height ",hts[edge_offset]," = ",LF[1])
	      fi}
    then () = if fund_face_verbose
    	      then prints("edge/vert counts to height ",H1, " = ",
	      	   for list in LF do #list od,"; time  = ",print_time_string(elapsed_ms() - start))
	      fi
    in extra_coord_flag:=extra_coord_hold; (LF,H1)

set localFD_Steve2(KGBElt x, ratvec lambda) = ([[FaceVertsKHash]], int):
    let ic = x.inner_class, theta = x.involution
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic, theta, ratvec_as_vec(lambda+theta*lambda))
    in localFD_Steve2(x, lambda, Lvd, Perm2)

{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}{FIRST}
set localFD_Steve2_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    ([[FaceVertsKHash]],int):
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1), extra_coord_hold = extra_coord_flag
    then () = if edge_offset= first_offset then extra_coord_flag:=true fi
    then LF0 = localFD_1SteveU(x,lambda,hts[first_offset], Lvd)
    then () = if show_steve_flag
    	      then prints("LF0 to height ",hts[first_offset]," = ",LF0)
	      fi
    then () = extra_coord_flag :=true
    then () = if edge_offset > first_offset
    	      then LF0:= test_Steve(x,lambda,hts[edge_offset],Lvd,[LF0])[0]
	      fi
    then () = if show_steve_flag
    	      then prints("LF0 with extra to height ",hts[edge_offset]," = ",LF0)
	      fi
    then LF = [LF0,  localFD_2SteveU(x,lambda,hts[edge_offset],Lvd,Perm2,LF0)]
    then () = if show_steve_flag
    	      then prints("LF1 with extra to height ",hts[edge_offset]," = ",LF[1])
	      fi
    then () = if fund_face_verbose
    	      then prints("edge/vert counts to height ",hts[edge_offset], " = ",
	      	   for list in LF do #list od,"; time  = ",print_time_string(elapsed_ms() - start))
	      fi
    in extra_coord_flag:=extra_coord_hold; (LF,hts[edge_offset])

{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}

{get verts, edges to hts[edge_offset] to feed one_level_end, with Kchar and #LQs}
set localFD_Steve12_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    ([[FaceVertsKHash]],int):
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda)
    then hts = next_heights(p0,edge_offset+1)
    then LF01 = localFD_1Dirac2_by_zero(x,lambda).##
    then LF01_tested = local_test_graph_steve(x,lambda,Lvd, LF01, hts[first_offset],false)
    then () = if show_steve_flag
    	      then prints("LF01 to height ",hts[first_offset]," = ",LF01_tested)
	      fi
    then () = if edge_offset > first_offset
    	      then LF01_tested := local_test_graph_steve(x, lambda, Lvd,LF01_tested, hts[edge_offset],
	      	   false)
	      fi
    then () = if show_steve_flag
    	      then prints("LF01 with extra to height ",hts[edge_offset]," = ",LF01_tested)
	      fi
    then () = if fund_face_verbose
    	      then prints("edge/vert counts to height ",hts[edge_offset], " = ", #LF01_tested,
	      	   {for list in LF do #list od,}"; time  = ",print_time_string(elapsed_ms() - start))
	      fi
    then LF_tested0 = [FaceVertsKHash]: [], LF_tested1 = [FaceVertsKHash]: []
    in  for v in LF01_tested
    	do if #v = 1
	   then LF_tested0 #:= v
	   else LF_tested1 #:= v
	   fi
	od;
    	(localFD_KHash_01(x, lambda, Lvd, hts[edge_offset], Kpol_hash, [LF_tested0, LF_tested1])
			     ,hts[edge_offset])

{ Input is candidate faces; assume Kchar to HT is recorded in LFVH, as index in Kpol_hash.
Output is the unitary_to_HT ones, found by steve_hash.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use steve partial order on working from vertices up}
set local_test_hash_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH,
    int HT
     ) = [[LocalFaceVertsKHash]]:
begin
    steve_hash_small.reset_with_ht(x,lambda,HT);
    let LFVHcat = LFVH.##, G = x.real_form
    then NumFaces = #LFVHcat,  printInterval = int: 1, start = elapsed_ms()
    then start_count = unitary_test_counter.use_count()
    then (rfnum, xlnum, htnum) = {if steve_small_flag
    	 	 	       	 then} (0,0,0)
				 {else steve_hash.indices(x,lambda,HT)
				 fi}
    in if fund_face_verbose
    	then prints("     Examining ",for list in LFVH do #list od,
	" faces in local_test_hash_steve, to ht ",HT)
    	fi;
    	let answer = [[LocalFaceVertsKHash]]:
	    for list@d in LFVH
	    do for v@j in list {work from small faces toward big}
    	       do if fund_face_verbose and (j%printInterval) = 0
       	       	  then prints("testing ",j,"th face; so far ",unitary_test_counter.use_count() - start_count
			," is_unitary' tests at ", print_time_string(elapsed_ms() - start))
			; printInterval := (3*printInterval)\2 + 1
       	           fi {fund_face_verbose}
       	         ; let verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
       	       	   then gamma = face_bary(Lvd,verts)
       	       	   then pC = parameter(x, lambda, gamma)
       	       	   then ps = [Param]: monomials(pC)
       	       	   in if {if steve_small_flag
		      	 then} steve_hash_small.postest(gamma)
			 {else steve_hash.partly_indexed_postest(rfnum, xlnum, htnum,gamma)
			 fi}
       	       	      then [v]
       	  	      else []
       	  	      fi
    	        od.##
	    od
       in if fund_face_verbose
       	  then prints("     Total of ",for list in answer do #list od, " faces are unitary to ",HT,".")
    	  fi
	  ;   if fund_face_verbose or test_slightly_verbose
    	      then prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	      	   print_time_string(elapsed_ms() - start))
    	      fi
;   answer
end

{whether to finish local_test_GEO_hash_steve with steve_closer}
set steve_closer_flag = false

{whether to use steve at every dimension}
set all_steve_flag = false

{ Input is candidate faces; assume Kchar to HT is recorded in LFVH, as index in Kpol_hash.
Output is the unitary_to_HT ones, found by steve_hash.
 use and update a complete list Uhash of known unitary faces.
 try to compute and systematically use steve partial order on working from vertices up}
{DON'T use after local_test_graph_steve: steve_hash.statuses isn't updated}
set local_test_closer_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [LocalFaceVertsKHash] LFVHcat
     ) = [Param]:
begin
    steve_hash_small.reset_with_ht(x,lambda, -1);
    let G = x.real_form
    then NumFaces = #LFVHcat,  printInterval = int: 1, start = elapsed_ms()
    then start_count = unitary_test_counter.use_count()
    then (rfnum, xlnum, htnum) = {if steve_small_flag
    	 	 	       	 then} (0,0,0)
				 {else steve_hash.indices(x,lambda,-1)
				 fi}
    then unitary_by_dim = vec: null(rank(x.involution - 1)+1)
    in  if fund_face_verbose
    	then prints("     Examining ",NumFaces," faces in local_test_closer_steve.")
    	fi;
    	let UParams = [Param]:
    	    for v@j in LFVHcat {work from small faces toward big}
	    {no tilde finds lots more unitary reps by deformation; not clear whether faster}
    	    do if fund_face_verbose and (j%printInterval) = 0
       	       then prints("testing ",j,"th face; so far ",unitary_test_counter.use_count() - start_count
			," is_unitary' tests at ", print_time_string(elapsed_ms() - start))
			; printInterval := (3*printInterval)\2 + 1
       	       fi {fund_face_verbose};
       	       let d = #v - 3
       	       then verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
	       then KCv = vec: v[d+1:]
       	       then gamma = face_bary(Lvd,verts)
       	       then pC = parameter(x, lambda, gamma)
       	       then ps = [Param]: monomials(pC)
       	       in if {if steve_small_flag
	       	     then} steve_hash_small.postest_known_Kchar(gamma, KCv)
		     {else steve_hash.partly_indexed_postest_known_Kchar(rfnum, xlnum, htnum, gamma, KCv)
		     fi}
       	       	  then for p in ps
       	       	       do big_unitary_hash.uhash(G).match(p)
	       	       od;
		       unitary_by_dim[d]+:=1;
	       	       [pC]
       	  	  else []
       	  	  fi
    	    od.##
       in if fund_face_verbose
       	  then prints("     Total of ", #UParams, " out of ",NumFaces, " faces are unitary.")
    	  fi
	  ;   if fund_face_verbose or test_slightly_verbose
    	      then prints("unitary faces by dim = ",unitary_by_dim, test_string);
	      	   prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	      	   print_time_string(elapsed_ms() - start))
    	       fi
;   UParams
end

set local_test_closer_steve(
    KGBElt x,
    ratvec lambda,
    LocalVertexData Lvd,
    [[LocalFaceVertsKHash]] LFVH
     ) = [Param]:
local_test_closer_steve(x, lambda, Lvd, LFVH.##)

set steve_xl_hash = make_xlambda_hash()

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_all_steve(KGBElt x, ratvec lambda, LocalVertexData Lvd, Param_hash Uhash) = [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    if {tiny case} #Lvd.list = 1
    then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[0]), Uhash)
    fi;
    if fund_face_verbose then prints("starting local_test_GEO_hash_all_steve with ",#Lvd.list," local vertices") fi;
    let G = x.real_form, r = rank(x.involution -1), p0 = parameter(x,lambda,0*lambda)
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do Uhash.match(p)
	       	      od;
	       	      return(all)
	       fi
    then hts = next_heights(p0,edge_offset+1)
    then one_ht = hts[edge_offset]
    then () = test_string:= " using local_test_GEO_hash_all_steve"
    then () = if fund_face_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then () = steve_xl_hash.match(x,lambda)
    then (LF2,H1) = localFD_Steve2(x,lambda)
    then LFall = localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LF2, 2, r + 1, one_ht, Kpol_hash)
    then () = if one_two_reverse_flag
    	      then LFall := for list in LFall do [vec]: for v in list ~do v od od
	      fi
    then LFlast =  local_test_hash_steve(x, lambda, Lvd, LFall, one_ht)
    then () = if fund_face_verbose
	      then prints("unitary to ht ",one_ht," face counts to dim ",r,
				": ", for list in LFlast do #list od)
	      fi
    then LFlastchars = extend_K_characters(x,lambda,Lvd,LFlast, Kpol_hash)
    in local_test_closer_steve(x, lambda, Lvd, LFlastchars)

{whether to make graph of vertices and edges together}
{cost of doing is_unitary on all the edges seems to outweigh any advantage of small graph}
set steve_one_two_flag = false

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_steve_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd, Param_hash Uhash) =
    [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    if {tiny case} #Lvd.list = 1
    then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[0]), Uhash)
    fi;
    if fund_face_verbose then prints("starting local_test_GEO_hash_steve_graph with ",#Lvd.list," local vertices") fi;
    let G = x.real_form, start = elapsed_ms(), start_count = unitary_test_counter.use_count()
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do Uhash.match(p)
	       	      od;
	       	      return(all)
	       fi
    then () = test_string:= " using local_test_GEO_hash_steve_graph"
    then () = if fund_face_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then () = steve_xl_hash.match(x,lambda)
    then theta = x.involution, p0 = parameter(x,lambda,0*lambda)
    then (,Perm2) = LPm_table.LPm_entry(G, theta, ratvec_as_vec(lambda+theta*lambda))
    then (LFKH,HT) =
    	 if steve_one_two_flag
	    then localFD_Steve12_graph(x,lambda,Lvd,Perm2)
	    else localFD_Steve2_graph(x,lambda,Lvd,Perm2)
	    fi
    in local_test_GEO_hash_one_level_end(x,lambda,Lvd,LFKH,Kpol_hash,HT, Uhash, is_unitary@Param)
{at FPP_local line 4488; }

 {   then hts = next_heights(p0,edge_offset+1)
    then FIRST_HT = hts[first_offset], ONE_HT = hts[edge_offset], r = rank(theta-1)
    then LF_first = localFD_1SteveU_graph(x, lambda, FIRST_HT, Lvd)
    then LF_one = if FIRST_HT = ONE_HT
    	 	  then LF_first
		  else local_test_graph_steve(x,lambda,Lvd, LF_first, ONE_HT, extra_coord_flag)
		  fi
    {then () = prints(new_line, "LF_one = ",LF_one)}
    then LF01 = localFD_2SteveUgraph(x,lambda, ONE_HT, Lvd, Perm2, LF_one)
    then () = if not all_steve_flag
    	      then return local_test_GEO_hash_steve_end(x, lambda, Lvd, LF01, ONE_HT, Uhash)
	      fi
    {then () = prints("LF01 = ",LF01,new_line)}
    then LFcands = localFD_KHashbt_lookDownGEO(x,lambda, Lvd, LF01, 2, r + 1, ONE_HT, Kpol_hash)
    then LFUcands = local_test_graph_steve(x, lambda, Lvd, LFcands.##, ONE_HT) {unitary to HT}
    {then () = prints("LFUcands = ",LFUcands)
    {then () = prints("at ",lambda,", #LFUcands = ",#LFUcands)}
    then () = prints(LFUcands)}
    then LFU = local_test_graph_steve(x,lambda,Lvd, LFUcands,-1,true)
    then unitary_by_dim = vec: null(rank(x.involution - 1)+1)
    then UParams = for v@j in LFU 
       	 	   do let d = #v - 3
       	  	      then verts = vec: v[:d+1] { extract the "vertices" part of the |vec| }
  	  	      then gamma = face_bary(Lvd,verts)
       	  	      then pC = parameter(x, lambda, gamma)
       	  	      then ps = [Param]: monomials(pC)
       	  	      in for p in ps
       	     	      	 do big_unitary_hash.uhash(G).match(p)
	     		 od;
	     		 unitary_by_dim[d]+:=1;
	     		 [pC]
    	     	   od.##
    in if fund_face_verbose
       then prints("     Total of ", #LFU, " out of ", #LFUcands, " faces are unitary.")
       fi;
       if fund_face_verbose or test_slightly_verbose
       then prints("unitary faces by dim = ",unitary_by_dim, test_string);
	    prints("number of tests = ",unitary_test_counter.use_count() - start_count, ", in ",
	    print_time_string(elapsed_ms() - start))
       fi;
       {report_steve_graph();}
       UParams}
    {local_test_closer_steve(x, lambda, Lvd, LFUcands)}
    {closer_steve fails because steve_hash statuses haven't been updated properly}

set steve_graph_flag = false

{here LF has only vertices at (x,lambda)}
{MUST use Kpol_hash!}
set local_test_GEO_hash_steve(KGBElt x, ratvec lambda, LocalVertexData Lvd, Param_hash Uhash,
    (Param -> bool) fancy_tester) = [Param]:
    if {tempered case} #Lvd.list = 1 and ((1-x.involution)*(Lvd.list[0])).=
    then let p = parameter(x,lambda,0*lambda)
    	 then () = for q in monomials(finalize(p))
    	       	   do Uhash.match(q)
		   od
	 in return [p]
    fi;
    if {tiny case} #Lvd.list = 1
    then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[0]), Uhash)
    fi;
    if all_steve_flag
    then return local_test_GEO_hash_all_steve(x, lambda, Lvd, Uhash)
    elif steve_graph_flag
    then return local_test_GEO_hash_steve_graph(x, lambda, Lvd, Uhash)
    fi;
    if fund_face_verbose then prints("starting local_test_GEO_hash_steve with ",#Lvd.list," local vertices") fi;
    let G = x.real_form
    then () = if is_compact(G)
       	      then let all = all_parameters_gamma(G,lambda)
       	      	   in for p in all
	       	      do Uhash.match(p)
	       	      od;
	       	      return(all)
	       fi
    then () = test_string:= " using local_test_GEO_hash_steve"
    then () = if fund_face_verbose then prints("Chose",test_string) fi
    then start_count = unitary_test_counter.use_count()
    then () = hash_steveCounter.use()
    then () = steve_xl_hash.match(x,lambda)
    then (LF2,H1) = localFD_Steve2 (x,lambda)
    then () = if (#LF2).= or (#LF2[0]).=
    	      then {if steve_small_flag
       	      	   then steve_hash_small.clear()
       		   else steve_hash.clear_xl(x,lambda)
       		   fi;}
		   return []
	      fi
    then () = if #LF2[0] = 1
    	      then return one_param_test_min_bottom(parameter(x,lambda,Lvd.list[LF2[0][0][0]]), Uhash)
	      fi
    then answer = if steve_closer_flag
       	 	  then local_test_GEO_hash_steve_steve_end(x, lambda, Lvd, LF2, Uhash,
       		  (([[LocalFaceVertsKHash]])->[Param]): ([[LocalFaceVertsKHash]] LFlast):
		  local_test_closer_steve(x,lambda, Lvd, LFlast))
       		  else local_test_GEO_hash_steve_end(x,lambda, Lvd, LF2, H1, Uhash)
       		  fi
    in {if steve_small_flag
       then} steve_hash_small.clear();
       {else steve_hash.clear_xl(x,lambda)
       fi}
       answer
