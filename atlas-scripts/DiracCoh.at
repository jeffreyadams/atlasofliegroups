<Dirac
<dirac_index
<finite_dimensional
<basic {for is_equal_rank}

{Aim in equal rank case to tell whether a unitary rep has
nonzero Dirac cohomology, and what it is??}

set gammaKs(RealForm G, RealForm K0, ratvec gamma) = [ratvec]:
    let () = assert(is_equal_rank(G),"gammaKs works only for G equal rank")
    in for w in W(G)
       do if not (is_dominant(K0, w*gamma - K0.rho))
       	  then []
	  else [w*gamma - K0.rho]
	  fi
       od.##.sort_u

{list of all KType's (representations of K_0) contributing to a
given infinitesimal character. The KGBElt has to be in the fundamental
fiber; it fixes the coords used for K0. (So for human coords on Sp(2n,R),
use KGB(G, 2^n - 1).)}

set DiracCohContributions(ratvec gamma, KGBElt x) = [[(int,KType)]]:
    let K0 = K_0(x) {identity component of K}, G = x.real_form
    then () = assert(is_equal_rank(G),
    	"DiracCohContributions works only for G equal rank")
    then () = if not is_integer(gamma - G.rho)
    	      then return []
	      fi
    then gammaKs = gammaKs(G,K0,gamma)
    then () = if #gammaKs = 0
    	      then return []
	      fi
    then rho_ns = gammaKs(G,K0,G.rho)
    {Need to tensor each gammaK with each rho_n}
    {need cover of K_0 where rho_n is integral}
     then (K0tilde,M) = cover(K0,rho_ns[0])
     then K0tilde = compact_form(K0tilde)
     then Minv = inverse ((1/1)*M)
     then rho_ntildes = for rho_n in rho_ns do ratvec_as_vec(M*rho_n) od
     then gammaKtildes = for gammaK in gammaKs do
     ratvec_as_vec(M*gammaK) od
     then tensortildes = for gammaKtilde in gammaKtildes
     	  	       	 do for rho_ntilde in rho_ntildes
			    do tensor_product_weights(K0tilde,gammaKtilde, rho_ntilde)
			    od.## {these are terms hitting one K0tilde type gammaKtilde}
			 od
     {tensortildes is a list of lists of pairs (multiplicity, K0tilde highest weight)}
     then down_on_K_0 = for mutildes in tensortildes
     	  	      	do for (m,mutilde) in mutildes
     	  	      	   do (m, ratvec_as_vec(Minv*mutilde))
			   od
			od
     {list lists of pairs (multiplicity, K0 highest weight}
     then longanswer = for mus in down_on_K_0
     	  	   do for (m, mu) in mus
     	  	      do let mu1 = K_type(x,mu -ratvec_as_vec(2*(G.rho - rho_c(x))))
		      {preceding is a KType, but not yet in the needed "final form"}
		      	 in (m,K_types(highest_weights(mu1)[0])[0]) {this converts to final form; thanks, Jeff!}
		      od
		   od
     {longanswer is all mus with mu \otimes spin hitting one of the magic K~ types. BUT not all of
     these can actually occur in unitary of infl char gamma...}
     then answer = for longmus in longanswer
     	  	   do for (m,mu) in longmus
		      do if DiracIC(mu) = gamma
		      	 then [(m,mu)]
			 else []
			 fi
		      od.##
		   od
     in answer

set DiracCohContributions(ratvec gamma, RealForm G) = [[(int,KType)]]:
    DiracCohContributions(gamma, KGB(G,0))

{ratvec's are highest weights of K0tilde types; ints are multiplicities}
set dirac_cohomology(Param p, KGBElt x) = [(int, ratvec)]:
    let gamma = p.infinitesimal_character, G = p.real_form
    then () = assert(is_equal_rank(G),"dirac_cohomology works only for G equal rank")
    then K0 = K_0(x)
    then gammaKtildes = gammaKs(G,K0,gamma)
    then mulists = DiracCohContributions(gamma,G)
    then () = if #mulists = 0
    	      then return []
	      fi
    then M = max(for list in mulists
    	     	 do if #list = 0
		    then -1
		    else max(for (,mu) in list do height(mu) od)
		    fi
                 od) {biggest height of a K-type we'll look for}
    then P = branch_irr(p,M) {all K-types of p to height M}
    then longanswer = {this version includes the terms with multiplicity zero}
       for gammatilde@j in gammaKtildes
       do (sum(for (m,mu) in  mulists[j] do m*split_as_int(P[mu]) od), gammatilde)
       od
    in for (m,gammatilde) in longanswer do if m = 0 then [] else [(m,gammatilde)] fi od.##

set dirac_cohomology(Param p) = [(int, ratvec)]:
    dirac_cohomology(p, KGB(p.real_form,0))
