<nilpotent_orbits_bmsz.at
<bmsz_descent.at

set theta_verbose=true
set_type ClassicalSignature=(string label, Split z)
set p(ClassicalSignature S)=int: int_part(S.z)
set q(ClassicalSignature S)=int: s_part(S.z)
set size(ClassicalSignature S)=int:p(S)+q(S)

set p(Split z)=int:int_part(z)
set q(Split z)=int:s_part(z)

{Section 4.1 classical signatures}
set is_valid(ClassicalSignature S)=bool:
let p=S.p, q=S.q, label=S.label in 
if label="B" then is_odd(p+q)
elif label="D" then is_even(p+q)
elif is_in(label,["C","C~","D*"]) then p=q
elif label="C*" then is_even(p) and is_even(q)
else error("missing case in is_classical_signature")
fi

set_type SignedYoungDiagram=([Split] signs,string label)
{the integers (p,q) are required to be non-negative
to avoid headaches: the first entry is always (0,0) and is ignored.
 Y=[(0,0),(p_1,q_1),(p_2,q_2),...]
 corresponds to a Young diagram with p_i + q_i rows of length i
 each row has alternating signs in its boxes
   p_i of the rows start with +, q_i start with -
Example:
 Y=[(0,0),(1,1),(2,0),(2,1)] ->
 +-+
 +-+
 -+-
 +-
 +-
 +
 -

Note: starting with (0,0) gives:
the rows of even length are those Y[i] with i even
rather than vice-versa
}
set p(SignedYoungDiagram (signs,label))=(int->int):(int i):int_part(signs[i])
set q(SignedYoungDiagram (signs,label))=(int->int):(int i):s_part(signs[i])
set size(SignedYoungDiagram Y)=int:sum(for z@i in signs(Y) do (p(z)+q(z))*i  od)
set partition(SignedYoungDiagram (signs,))=
let rv=[[int]]:[] in 
 for z@i in signs do
   if !=z then
     rv#:=for j:p(z)+q(z) do i od
   fi
 od;reverse(##rv)

set =(SignedYoungDiagram A,SignedYoungDiagram B)=A.label=B.label and
#A.signs=#B.signs and
all(for i:#A.signs do A.signs[i]=B.signs[i] od)

set null_signed_young_diagram(string label)=SignedYoungDiagram:([],label)

set even_integers([int] list)=[int]: ##for i:#list-1 from 1 do if is_even(i) then [i] else [] fi od
set odd_integers([int] list)=[int]: ##for i:#list-1 from 1  do if is_odd(i) then [i] else [] fi od

{array v=[a,b,c,d,...] of any type, we ignore the first entry and write it
       v=[*,a,b,c,d,...]
 the even indices are 2,4,6,... the odd indices are 1,3,5,...
} 
any_type S,T begin
set even_indices([T]a) = even_integers(#(#a))  
set odd_indices([T]a) =  odd_integers(#(#a))
set even_entries([T]a) = for i in even_indices(a) do a[i] od
set odd_entries([T]a) = for i in odd_indices(a) do a[i] od
end

set is_valid(SignedYoungDiagram Y)=bool:
all (for z in Y.signs do int_part(z)>=0 and s_part(z)>=0 od) and
if is_in(Y.label,["B","D"]) then
 all(for z in even_entries(Y.signs) do int_part(z)=s_part(z) od)
elif is_in(Y.label,["C","C~"]) then
 all(for z in odd_entries(Y.signs) do int_part(z)=s_part(z) od)
elif Y.label="C*" then
 all(for z in odd_entries(Y.signs) do is_even(int_part(z)) and is_even(s_part(z)) od) and
 all(for z in even_entries(Y.signs) do int_part(z)=s_part(z) od)
elif Y.label="D*" then
 all(for z in odd_entries(Y.signs) do int_part(z)=s_part(z) od) and
 all(for z in even_entries(Y.signs) do is_even(int_part(z)) and is_even(s_part(z)) od)
else
 error("missing case")
fi

{(9.10)}
{set signature_old(SignedYoungDiagram Y)=
let
P=sum(for i in even_indices(Y.signs) do let (p,q)=Y.signs[i] in i\2*(p+q) od)
 +sum(for i in odd_indices(Y.signs) do let (p,q)=Y.signs[i] in ((i+1)\2)*p + ((i-1)\2)*q od)
then
Q=sum(for i in even_indices(Y.signs) do let (p,q)=Y.signs[i] in i\2*(p+q) od)
 +sum (for i in odd_indices(Y.signs) do let (p,q)=Y.signs[i] in ((i-1)\2)*p + ((i+1)\2)*q od)
in (P,Q)}

{(9.10) converted to use Splits}
{ 1) term z_2k=p_2k+2_2ks -> (kp_2k + q_2k) + s(kp_2k + 2kp_2k) = (1+s)kz_2k
  or z_j -> (1+s)(j/2)z_l  if j is even
  2) term z_{2k-1}=(p_{2k-1}+sq_{2k-1})-> (kp_{2k-1}+(k-1)q_{2k-1}) + s((k-1)p_{2k-1}+kq_{2k-1})
                  = k(p_{2k-1}+sq_{2k-1}) + (k-1)(q_{2k-1}+sp_{2k-1})
                  = k(p_{2k-1}+sq_{2k-1}) + (k-1)s(p_{2k-1}+sq_{2k-1})
                  = kz_{2k-1}+s(k-1)z_{2k-1}
    or j=2k-1, k=(j+1)/2
    z_j -> ((j+1)/2+ s(j-1)/2) z_j
conclusion:  z_j -> j/2(1+s)z_j (j even) or ((j+1)/2 + s(j-1)/2)z_j  (j odd)
}  
set signature(SignedYoungDiagram Y)=Split:
sum(for j in even_indices(Y.signs) do (j\2)*(1+s)*Y.signs[j] od) +
sum(for j in odd_indices(Y.signs) do ((j+1)\2 + s*((j-1)\2))*Y.signs[j] od)

{remove first column, i.e. remove first pair (p_1,q_1) not including (0,0):
 so remove first two entries, and tack (0,0) back on}
set descent_naive(SignedYoungDiagram Y)=SignedYoungDiagram:
let signs=Y.signs in ((0*s)#signs[2:],Y.label)

{Lemma 9.2
 Y=(signs,label)
 theta(p',q',Y) =  (new_signs,howe_dual(label))  if (p_prime,q_prime)=signature(descent_naive(Y))>=(0,0)
                   undefined otherwise
}
set theta_non_zero(SignedYoungDiagram Y,ClassicalSignature S_prime)=bool:
let Y_naive=descent_naive(Y) then
()=assert(S_prime.label=dual_howe_label(Y.label), "Wrong classical signature in Delta") then
z_prime=S_prime.z then
sig_naive=signature(Y_naive) then
sig_0=z_prime-sig_naive in
if int_part(sig_0)>=0 and s_part(sig_0)>=0 then true else false fi

{Lemma 9.2}
set Delta(SignedYoungDiagram Y, ClassicalSignature S_prime)=SignedYoungDiagram:
let ()=assert(theta_non_zero(Y,S_prime), "theta lift of orbit is 0");
assert(S_prime.label=dual_howe_label(Y.label), "Wrong classical signature in Delta") then
z_0=S_prime.z-signature(descent_naive(Y)) in
if int_part(z_0)>=0 and s_part(z_0)>=0
 then
  let signs=Y.signs then
  signs_new=
  if #signs=2 {single column}
    then [0*s,z_0]
  else
    [0*s,signs[2]+z_0]##for i:#signs-3 from 3 do signs[i] od
  fi
 in (signs_new,S_prime.label)
else null_signed_young_diagram(S_prime.label)
fi

set plus(int parity)=string:if is_even(parity) then "+" else "-" fi
set minus(int parity)=string:if is_odd(parity) then "+" else "-" fi

{alt_string(0,n)="+-+-..." (n terms)
 alt_string(1,n)="-+-+..." (n terms)
} 
set alt_string(int starting_plus_minus, int length)=
let rv="" in 
 if is_even(starting_plus_minus)
   then
     for i:length do rv+:=plus(i) od;rv
    else
     for i:length do rv+:=minus(i) od;rv
 fi

set show(SignedYoungDiagram Y)=void:
prints(new_line,partition(Y));
let signs=Y.signs in
for i:#signs-1 downto 1 do
 for j:int_part(signs[i]) do prints(alt_string(0,i)) od;
 for j:s_part(signs[i]) do prints(alt_string(1,i)) od
 od

{-------------------------marked young diagrams--------------------}

{same as Signed except values in ZxZ not NxN
set_type MarkedYoungDiagram=([Split] signs,string label)

some functions apply to both 
}

set_type MarkedYoungDiagram=([Split] signs,string label)     

set signed_young_diagram(MarkedYoungDiagram M)=SignedYoungDiagram:
(for z in M.signs do abs(int_part(z)) + abs(s_part(z))*2 od,M.label)

{same as for SignedYoungDiagram except for positivity condition}

set is_valid_marked(MarkedYoungDiagram M)=bool:
is_valid(signed_young_diagram(M))

set null_marked_young_diagram(string label)=MarkedYoungDiagram:([],label)


{(9.19)}
set box_contained(int p_0, int q_0, MarkedYoungDiagram M)=bool:
( (p(M)(1)>=p_0 and p_0>=0) or (p(M)(1)<=p_0 and p_0 <=0)) and
( (q(M)(1)>=q_0 and q_0>=0) or (q(M)(1)<=q_0 and q_0 <=0))
set box_contained(Split z,MarkedYoungDiagram M)=bool:box_contained(int_part(z), s_part(z),M)

{(9.19)}
set truncation(MarkedYoungDiagram M,Split w)=MarkedYoungDiagram:
let ()=if  theta_verbose then prints("truncation: ", new_line, "M=", M,new_line, "w=", w) fi in
assert((is_in(M.label,["B","D"]) or is_valid(M.label,w)) and (box_contained(w,M)), "truncation not defined in this case");
((0*s)#(for i:#M.signs from 1 do
 if i=1 then M.signs[i] - w
        else M.signs[i]
 fi
od),M.label)


{Definition 9.4(i)}
set sign_twist(MarkedYoungDiagram (signs,label), Split w)=MarkedYoungDiagram:
assert(is_in(label,["B","D"]), "sign twist only defined in types B,D");
{  if is_odd(i) then ((-1)^( (i+1)\2*eplus+(i-1)\2*eminus)*p,(-1)^( (i-1)\2*eplus+(i+1)\2*eminus)*q) else}
(for z@i in signs do
 if is_odd(i) then 
  (-1)^( (i+1)\2*int_part(w)+(i-1)\2*s_part(w))*int_part(z) + s*(-1)^( (i-1)\2*int_part(w)+(i+1)\2*s_part(w))*s_part(z)
 else z fi od,label)

{Definition 9.4(ii)}
set involution(MarkedYoungDiagram (signs,label))=MarkedYoungDiagram:
assert(is_in(label,["C","C~"]), "involution only defined in types C,C~");
(for z@i in signs do if i%4=2 then z else z fi od,label)

set involution_power(MarkedYoungDiagram M,int n)=MarkedYoungDiagram:
if is_even(n) then involution(M) else M fi

{Definition 9.4(iii) AND 9.23
p_0,q_0\in \frac 12\Z}
set augmentation(MarkedYoungDiagram (signs,label),rat p_0,rat q_0)=MarkedYoungDiagram:
if is_in(label,["B","D"]) or
 is_integer(p_0) and is_integer(q_0) and is_valid(label,rat_as_int(p_0)+s*rat_as_int(q_0))
 then
 ((0*s)#(for i:#signs from 1 do
 if i=1 then rat_as_int(p_0)+s*rat_as_int(q_0)
   else signs[i-1]
  fi od),label)
else
  null_signed_young_diagram(label)
fi

set_type ZMYD=[(int,MarkedYoungDiagram)]

set prune(ZMYD A)=ZMYD: ##for (mult,M) in A do if mult=0 then [] else [(mult,M)] fi od

set mult(MarkedYoungDiagram M,ZMYD A)=int:
let i=first(for i:#A do let (,N)=A[i] in M=N od) in
if i=-1 then 0 else let (mult,)=A[i] in mult fi

set index(MarkedYoungDiagram M,ZMYD A)=int:
let i=first(for i:#A do let (,N)=A[i] in M=N od) in i 

set monomials(ZMYD A)=[MarkedYoungDiagram]:
for (,M) in A do M od

set =(ZMYD A,ZMYD B)=bool:
#A=#B and
all(for (mult_A,M_A) in A do mult(M_A,B)=mult_A od)

set *(int n,ZMYD A)=ZMYD:prune(for (mult,M) in A do (n*mult,M) od)
set +(ZMYD A,ZMYD B)=ZMYD:
for (mult_B,M_B) in B do
 if mult(M_B,A)=0 then A#:=(mult_B,M_B)
 else let ()=prints(mult(M_B,A), "and ", mult_B) in A[index(M_B,A)]:=(mult(M_B,A) + mult_B,M_B)
 fi
od;prune(A)
set -(ZMYD A)=ZMYD: (-1)*A
set -(ZMYD A, ZMYD B)=ZMYD:prune(A + (-B))



{------------- sign twist/involution/augmentation/truncation on ZMYD----}

set sign_twist(ZMYD A, Split w)=ZMYD:
for (mult,M) in A do (mult,sign_twist(M,w)) od

set involution(ZMYD A)=ZMYD:
for (mult,M) in A do (mult,involution(M)) od

set truncation(ZMYD A,Split w)=ZMYD:
for (mult,M) in A do (mult,truncation(M,w)) od

{Section 9.5}
{Recall (Lemma 9.2) Theta lifting takes a K-orbit for G to one for G'
 G <-> ClassicalSignature S -> ClassicalSignature S' <-> G'
 O <-> SignedYoungDiagram M -> SignedYoungDiagram M' -> O'
Section 9.5: enhance this to a map
      Z[SignedYoungDiagram] for G -> Z[SignedYoungDiagram] for G'

The notation in Section 9.5 goes from G' -> G, but we'll turn this around}

set l_sign(MarkedYoungDiagram (signs,))=Split:
sum(for i:#signs do s^(i+1)*signs[i] od)

set theta(MarkedYoungDiagram M, ClassicalSignature S_prime)=
assert(theta_non_zero(signed_young_diagram(M),S_prime), "theta lift of underlying orbit is 0");
let Y=signed_young_diagram(M) then
Y_prime=Delta(Y,S_prime) then
z=signature(M) then
z_prime=S_prime.z then
delta=size(Y_prime) - size(Y) then
()=if theta_verbose then prints("S'=",S_prime,new_line,"M=",M,new_line,"Y_prime=",Y_prime,new_line,"z=",z,new_line,"z'=",z_prime,new_line,"delta=",delta) fi then
()=assert(delta>=0,"delta <0") in
if S_prime.label="B"then
      {(p',q')-(p,q) - l_sign(O) + (delta/2,delta/2)}
 let z_0=z_prime-z -l_sign(M) + h(delta)*(1+s) then
 truncation=truncation(M,h(delta)*(1+s)) then
 involution=involution_power(truncation,h(p(z)-q(z)+1)) then
 twisted=sign_twist(involution,z_0) in
 twisted
elif S_prime.label="D" then
      {(p',q')-(p,q) - l_sign(O) + (delta/2,delta/2)}
 let z_0=z_prime-z -l_sign(M) + h(delta)*(1+s) then
 truncation=truncation(M,h(delta)*(1+s)) then
 involution=involution_power(truncation,h(p(z)-q(z))) then
 twisted=sign_twist(involution,z_0) in
 twisted
elif S_prime.label="C*" then {delta might be odd}
 if is_odd(delta) then null_signed_young_diagram(S_prime.label)
 else
  let truncation=truncation(M,h(delta)*(1+s)) then  {this will fail if delta \not\in Z}
  z_0=z_prime-z -l_sign(M) + h(delta)*(1+s) then
  twisted=sign_twist(truncation,z_0)
  in twisted
 fi
fi


{----------generating orbits-------------}

set join([[Split]] list)=[[Split]]:
let rv=[list[0]] in
for i:#list-1 from 1 do
 let row=list[i] in
  rv:=##for a in rv do for b in row do a#b od od od;
 rv
 
set rows_by_length(Partition P)=[int]:
for i:max(P)+1 do count(P,i) od

set K_orbits(Orbit O, string label)=[SignedYoungDiagram]:
let possible_signs_by_row_length=
for mult@i in rows_by_length(O) do
   if is_odd(i) 
     then [h(mult)*(1+s)]
   else  {is_even(i)}
     for i:mult+1 do  i+s*(mult-i) od
   fi
od in
for signs in join(possible_signs_by_row_length) do (signs,label) od

set K_orbits(int rank, string label)=
for orbit in all_partitions(rank,label) do K_orbits(orbit,label) od

 