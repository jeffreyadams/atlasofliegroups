<basic.at

any_type T begin

{ merge weakly increasing lists }
set merge ((T,T->bool)leq) = ([T] a, [T] b) [T]:
  let na=#a in
  if na=0 then b
  else let nb=#b, i=0, j=0 in b #:=a~[0] { place sentinel }
  ; while
      if i<na
      then do { certainly not finished here; we always have |j<#b| }
	if leq(a[i],b[j]) then a[i] next i+:=1 else b[j] next j+:=1 fi
      else j<nb { condition to continue now } do b[j] next j+:=1
      fi
    od
  fi

{ merge sort }
set sort ((T,T->bool)leq) = ([T]->[T]):
  let rec_fun ms ([T] v, int l) = [T]: { invariant includes l=#v }
    if l<3 then if l=2 and not leq(v[0],v[1]) then v~[:] { swap } else v fi
    else let half=l\2 in leq.merge( ms(v[:half],half), ms(v[half:],l-half) )
    fi
  in { sort = } ([T] v) [T]: ms(v,#v)

set reverse_sort ((T,T->bool)leq) = ([T]->[T]): sort((T x,T y)bool:leq(y,x))


{ merge unique weakly increasing lists }
set merge_u ((T,T->bool)leq) = ([T] a, [T] b) [T]:
  let na=#a in
  if na=0 then b
  else let nb=#b, i=0, j=0 in b #:=a~[0] { place sentinel }
  ; while { run until i=na and j=nb }
      if i<na
      then do { certainly not finished here; we always have |j<#b| }
        if not leq(a[i],b[j]) then b[j] next j+:=1
	elif not leq(b[j],a[i]) then a[i] next i+:=1
	else a[i] next i+:=1; j+:=1 { equality: take one, skip both }
	fi
      else j<nb do b[j] next j+:=1
      fi
    od
  fi

{ sort, keeping unique copy of duplicates }
set sort_u ((T,T->bool)leq) = ([T]->[T]):
  let rec_fun ms ([T] v, int l) = [T]: { invariant includes l=#v }
    if l<2 then v { for l=2 let |merge_u| do the three way choice }
    else let half=l\2 in leq.merge_u( ms(v[:half],half), ms(v[half:],l-half) )
    fi
  in { sort_u = } ([T] v) [T]: ms(v,#v)

end

set sort = sort(<=@(int,int))
set merge = merge(<=@(int,int)) { used separately in combinatorics.at }
set reverse_sort = sort(>=@(int,int))
set sort_u = sort_u(<=@(int,int))

{ auxiliary for sorting of general types, using provided comparison }
set merge_indices ((int,int->bool) leq) = ([int] a,[int] b) [int]:
   let na=#a, nb=#b, i=0, j=0 in
   for :na + nb
   do if i<na and (j=nb or leq(a[i],b[j]))
      then a[i] next i+:=1
      else b[j] next j+:=1
      fi
   od

{ sort for a general type: in order to remain type agnostic here, we have the
  caller pass just the array size and comparison function. For |a| of type
  [string] (so <=@(string,string) is lexicographic comparison), sort it using:
  |a:=for i in sort(#a,(int i,int j)bool: a[i]<=a[j]) do a[i] od|
}
set sort_indices((int,int->bool)leq) = (int->[int]):
   let combine = merge_indices(leq)
in (int n) [int]:
   (0,n). { describes range of consecutive numbers to sort via |leq| }
   (rec_fun ms(int b,int size) [int]:
      case size-1
      then [] { ensure termination for empty list }
      in [b], let e=b+1 in if leq(b,e) then [b,e] else [e,b] fi
      else let half=size\2 then chalf=size-half in
         combine( ms(b,half), ms(b+half,chalf) )
      esac
   )

{ uncurried version for everyday use }
set sort_indices(int n,(int,int->bool)leq) = [int]: sort_indices(leq)(n)

{ auxiliary for sort-unique of general types, using provided comparison }
set merge_u_indices ((int,int->bool) leq) = ([int] a,[int] b) [int]:
   let na=#a, nb=#b, i=0, j=0 in
   if =na then b elif=nb then a
   else
      while { run until i=na and j=nb }
      if i=na then j<nb do b[j] next j+:=1
      else { loop certainly not terminated }
      do if j=nb or not leq(b[j],a[i]) then a[i] next i+:=1
	 elif leq(a[i],b[j])
	 then a[i] next i+:=1; j+:=1 { take one, skip both }
	 else b[j] next j+:=1
	 fi
      fi
      od
    fi

{ sort-unique for a general type: as for cooresponding |sort|, we have the
  caller pass just the array size and comparison function. For |a| of type
  [(string,T)], select elements sorted by |string| component, keeping only the
  first pair with a given string as
  |a:=for i in sort_u(#a,(int i,int j)bool: let(x,)=a[i],(y,)=a[j]) in x<=y)
      do a[i] od|
}
set sort_u_indices ((int,int->bool)leq) = (int->[int]):
   let merge = merge_u_indices(leq)
in (int n) [int]:
   (0,n). { describes range of consecutive numbers to sort via |leq| }
   (rec_fun ms(int b,int size) [int]: { range from |b| with |size| elements }
      case size-1
      in [b]
      , let e=b+1 in
        if not leq(b,e) then [e,b] elif leq(e,b) then [e] else [b,e] fi
      else let half=size\2 then chalf=size-half in
         merge( ms(b,half), ms(b+half,chalf) )
      esac
   )

{ uncurried version for everyday use }
set sort_u_indices (int n, (int,int->bool)leq) = [int]: leq.sort_u_indices(n)


{ the following helps stable-sorting of anything according to a statistic }

any_type T begin

{ Inverse (since used for permuting) of the permutation that stable-sorts a list
  $a$ of values into increasing order: at $i$, it has the index of the
  value ranked $i$ in $v$, where equal values are ranked from left to right.
  That permutation itself is just the standardisation (stable ranking) of $v$.
}
set inv_standardisation ((T,T->bool)leq) = ([T] a) [int]:
{ since |sort@(int,(int,int->bool)| is a stable sort, we can just use it: }
  sort_indices(#a,(int i,int j)bool: leq(a[i],a[j]))

set inv_standardisation = inv_standardisation(<=@(int,int))
set inv_standardisation = inv_standardisation(<=@(rat,rat))

set sort_by ((T->int)f) = ([T] v) [T]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od
set sort_by ((T->rat)f) = ([T] v) [T]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od

set lexicographic  ((T,T->bool)leq) = ([T] a,[T] b) bool:
  for i:min(#a,#b)
  do if not leq(a[i],b[i]) then return false
     elif not leq(b[i],a[i]) then return true
     fi
  od
; #a<=#b { let length difference decide if one is prefix ot the other }

end

{ the same for a list of rationals; the result is still a list of integers }
set inv_standardisation = inv_standardisation(<=@(rat,rat))


{ also need sorting by rationals; take easily written but roundabout approach }
set sort ([rat] v) = [rat]: for index in inv_standardisation(v) do v[index] od

{ Here are example calls of the model functions above. They can be defined here
  because reducibility_points and height are built-in functions (those defined
  in basic.at could also be used). If however you need to sort on a custom
  attribute defined elsewhere, DON'T do so here (and don't include modules to
  make that possible); rather call sort_by in the script where that custom
  attribute is defined.

  For instance LKT.at defines the |attribute LKT_dimensions|, and then defines
  sort_by_dimension in a call of sort_by, whose argument uses that attribute.
}

{ sort list of pairs [(Param,bool)] by #reducibility_points of Param }
set sort_by_reducibility_points = ([(Param,bool)]->[(Param,bool)]):
  sort_by((Param p,bool x) int: #reducibility_points(p) )

{ sort list [Param] by #reducibility_points of Param }
set sort_by_reducibility = ([Param]->[Param]):
  sort_by((Param p) int: #reducibility_points(p) )

{ Sort list of parameters by height }
set sort_by_height = ([Param] -> [Param]): sort_by( height@Param )

{ Same for a list of parameters with a Split attached (ignored for sorting) }
set sort_by_height = ([(Split,Param)] -> [(Split,Param)]):
 sort_by( (Split s,Param p) int: height(p) )

{ sorting fixed size vectors lexicographically }
set lex_leq (vec v,vec w) = bool: { assert(#v=#w); }
   for x@i in v do if x!=w[i] then return x<w[i] fi od; true

set sort_lex = sort(lex_leq@(vec,vec))
set sort_u_lex = sort_u(lex_leq@(vec,vec))

{ sorting rational ratvectors lexicographically }
set lex_leq (ratvec v,ratvec w) = bool: { assert(#v=#w); }
   for x@i in v do if x!=w[i] then return x<w[i] fi od; true

set sort_lex = sort(lex_leq@(ratvec,ratvec))
set sort_u_lex = sort_u(lex_leq@(ratvec,ratvec))