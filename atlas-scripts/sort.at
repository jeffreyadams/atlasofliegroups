<basic.at

any_type T begin

{ merge weakly increasing lists }
set merge ((T,T->bool)leq) = ([T] a, [T] b) [T]:
  let na=#a in
  if na=0 then b
  else let nb=#b, i=0, j=0 in b #:=a~[0] { place sentinel }
  ; while
      if i<na
      then do { certainly not finished here; we always have |j<#b| }
	if leq(a[i],b[j]) then a[i] next i+:=1 else b[j] next j+:=1 fi
      else j<nb { condition to continue now } do b[j] next j+:=1
      fi
    od
  fi

{ merge sort }
set sort ((T,T->bool)leq) = ([T]->[T]):
  let rec_fun ms ([T] v, int l) = [T]: { invariant includes l=#v }
    if l<3 then if l=2 and not leq(v[0],v[1]) then v~[:] { swap } else v fi
    else let half=l\2 in leq.merge( ms(v[:half],half), ms(v[half:],l-half) )
    fi
  in { sort = } ([T] v) [T]: ms(v,#v)

{ merge unique weakly increasing lists }
set merge_u ((T,T->bool)leq) = ([T] a, [T] b) [T]:
  let na=#a in
  if na=0 then b
  else let nb=#b, i=0, j=0 in b #:=a~[0] { place sentinel }
  ; while { run until i=na and j=nb }
      if i<na
      then do { certainly not finished here; we always have |j<#b| }
        if not leq(a[i],b[j]) then b[j] next j+:=1
	elif not leq(b[j],a[i]) then a[i] next i+:=1
	else a[i] next i+:=1; j+:=1 { equality: take one, skip both }
	fi
      else j<nb do b[j] next j+:=1
      fi
    od
  fi

{ sort, keeping unique copy of duplicates }
set sort_u ((T,T->bool)leq) = ([T]->[T]):
  let rec_fun ms ([T] v, int l) = [T]: { invariant includes l=#v }
    if l<2 then v { for l=2 let |merge_u| do the three way choice }
    else let half=l\2 in leq.merge_u( ms(v[:half],half), ms(v[half:],l-half) )
    fi
  in { sort_u = } ([T] v) [T]: ms(v,#v)

end

set sort = sort(<=@(int,int))
set sort = sort(<=@(rat,rat))
set sort = sort(<=@(string,string))
set merge = merge(<=@(int,int)) { used separately in combinatorics.at }
set reverse_sort = sort(>=@(int,int))
set reverse_sort = sort(>=@(rat,rat))
set reverse_sort = sort(>=@(string,string))
set sort_u = sort_u(<=@(int,int))
set sort_u = sort_u(<=@(rat,rat))
set sort_u = sort_u(<=@(string,string))

{ the following helps stable-sorting of anything according to a statistic }

any_type S,T begin

{ Compute list |R| such that |R[i]| is index of element ranked |i| for |leq|.
  For $i<j$ one will have |leq(a[R[i]],a[R[j]])|, and in case of equality
  (the comparison also holds in the opposite order) one also has |R[i]<R[j]|.
  This is the inverse of the permutation that stable-sorts the list |a| into
  into order for |leq|, the latter being called the standardisation of |a|.
  Therfore this function used to be called |inv_standardisation|.
}
set ranking ((T,T->bool)leq) = ([T] a) [int]:
  sort((int i,int j)bool:leq(a[i],a[j]))(# #a)

set sort_by ((T->S)f,(S,S->bool)leq) = ([T]->[T]):
   sort((T x,T y)bool:leq(f(x),f(y)))
set merge_by ((T->S)f,(S,S->bool)leq) = ([T],[T]->[T]):
   merge((T x,T y)bool:leq(f(x),f(y)))
{ when sorting by integer or rational value, default to increasing sort }
set sort_by ((T->int) f) = ([T]->[T]): sort_by(f,<=@(int,int))
set sort_by ((T->rat) f) = ([T]->[T]): sort_by(f,<=@(rat,rat))

set lookup_in ([S]a,(S->T)f,(T,T->bool) leq) = (T->Maybe<S>):
  binary_search_get(sort_by(f,leq)(a),f,leq)

{ group together elements with the same value under |f|, ordered by that value }
set partition_by ((T->S)f,(S,S->bool)leq) = ([T] a) [[T]]:
  let vals = map(f)(a) then rank = ranking(leq)(vals), i=0, n=#a in
  while i<n
  do let v = S: vals[rank[i]] in
     while i<n and leq(vals[rank[i]],v) do a[rank[i]] next i+:=1 od
  od

{ similar, but keep only one (the first) element for each value of |f| }
set representatives_by ((T->S)f,(S,S->bool)leq) = ([T] a) [T]:
  let vals = map(f)(a) then rank = ranking(leq)(vals), i=0, n=#a in
  while i<n
  do let j=rank[i] then v = S: vals[j] in a[j] next
     while (i+:=1)<n and leq(vals[rank[i]],v) do () od
  od

set lexicographic  ((T,T->bool)leq) = ([T] a,[T] b) bool:
  for i:min(#a,#b)
  do if not leq(a[i],b[i]) then return false
     elif not leq(b[i],a[i]) then return true
     fi
  od
; #a<=#b { let length difference decide if one is prefix ot the other }

end

set ranking = ranking(<=@(int,int))
set ranking = ranking(<=@(rat,rat))
set ranking = ranking(<=@(string,string))

{ Here are example calls of the model functions above. They can be defined here
  because reducibility_points and height are built-in functions (those defined
  in basic.at could also be used). If however you need to sort on a custom
  attribute defined elsewhere, DON'T do so here (and don't include modules to
  make that possible); rather call sort_by in the script where that custom
  attribute is defined.

  For instance LKT.at defines the |attribute LKT_dimensions|, and then defines
  sort_by_dimension in a call of sort_by, whose argument uses that attribute.
}

{ sort list of pairs [(Param,bool)] by #reducibility_points of Param }
set sort_by_reducibility_points = ([(Param,bool)]->[(Param,bool)]):
  sort_by((Param p,bool .) int: #reducibility_points(p), <=@(int,int) )

{ sort list [Param] by #reducibility_points of Param }
set sort_by_reducibility = ([Param]->[Param]):
  sort_by((Param p) int: #reducibility_points(p), <=@(int,int) )

{ Sort list of parameters by height }
set sort_by_height = ([KType] -> [KType]): sort_by( height@KType, <=@(int,int) )
set sort_by_height = ([Param] -> [Param]): sort_by( height@Param, <=@(int,int) )

{ Same for a list of parameters with a Split attached (ignored for sorting) }
set sort_by_height = ([(Split,Param)] -> [(Split,Param)]):
 sort_by( (Split s,Param p) int: height(p), <=@(int,int) )

{ comparing vectors lexicographically }
set lex_leq (vec v,vec w) = bool: { assert(#v=#w); }
( let lv=#v,lw=#w in
  for i:min(lv,lw) do if v[i]!=w[i] then return v[i]<w[i] fi od
; lv<=lw { break tie using length }
)

{ compariung fixed size vectors lexicographically (restricted lex ordering) }
set rlex_leq (vec v,vec w) = bool: { assert(#v=#w); }
   for x@i in v do if x!=w[i] then return x<w[i] fi od; true

{ short lex ordering }
set slex_leq (vec v,vec w) = bool:
  let lv=#v,lw=#w in
  if lv=lw else lv<lw
  then for i:min(lv,lw) do if v[i]!=w[i] then return v[i]<w[i] fi od; true
  fi

{ for types [T], including [int], one can also use |lexicographic(leq@(T,T))| }


set ranking = ranking(lex_leq@(vec,vec))
set sort_lex = sort(lex_leq@(vec,vec))
set sort_u_lex = sort_u(lex_leq@(vec,vec))
set sort_rlex = sort(rlex_leq@(vec,vec))
set sort_u_rlex = sort_u(rlex_leq@(vec,vec))
set sort_slex = sort(slex_leq@(vec,vec))
set sort_u_slex = sort_u(slex_leq@(vec,vec))

{ comparing rational vectors }
set (lex_leq,rlex_leq,slex_leq) =
   let same_denom (ratvec v,ratvec w) = (vec,vec):
      let (vn,vd)=%v, (wn,wd)=%w in (vn*wd,wn*vd)
in ( ((ratvec,ratvec)args)bool:args.same_denom.lex_leq
   , ((ratvec,ratvec)args)bool:args.same_denom.rlex_leq
   , ((ratvec,ratvec)args)bool:args.same_denom.slex_leq
   )

set ranking = ranking(lex_leq@(ratvec,ratvec))
set sort_lex = sort(lex_leq@(ratvec,ratvec))
set sort_u_lex = sort_u(lex_leq@(ratvec,ratvec))
set sort_rlex = sort(rlex_leq@(ratvec,ratvec))
set sort_u_rlex = sort_u(rlex_leq@(ratvec,ratvec))
set sort_slex = sort(slex_leq@(ratvec,ratvec))
set sort_u_slex = sort_u(slex_leq@(ratvec,ratvec))
