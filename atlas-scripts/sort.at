<basic.at

any_type T begin

{ merge weakly increasing lists }
set merge ((T,T->bool)leq) = ([T] a, [T] b) [T]:
  let na=#a in
  if na=0 then b
  else let nb=#b, i=0, j=0 in b #:=a~[0] { place sentinel }
  ; while
      if i<na
      then do { certainly not finished here; we always have |j<#b| }
	if leq(a[i],b[j]) then a[i] next i+:=1 else b[j] next j+:=1 fi
      else j<nb { condition to continue now } do b[j] next j+:=1
      fi
    od
  fi

{ merge sort }
set sort ((T,T->bool)leq) = ([T]->[T]):
  let rec_fun ms ([T] v, int l) = [T]: { invariant includes l=#v }
    if l<3 then if l=2 and not leq(v[0],v[1]) then v~[:] { swap } else v fi
    else let half=l\2 in leq.merge( ms(v[:half],half), ms(v[half:],l-half) )
    fi
  in { sort = } ([T] v) [T]: ms(v,#v)

{ merge unique weakly increasing lists }
set merge_u ((T,T->bool)leq) = ([T] a, [T] b) [T]:
  let na=#a in
  if na=0 then b
  else let nb=#b, i=0, j=0 in b #:=a~[0] { place sentinel }
  ; while { run until i=na and j=nb }
      if i<na
      then do { certainly not finished here; we always have |j<#b| }
        if not leq(a[i],b[j]) then b[j] next j+:=1
	elif not leq(b[j],a[i]) then a[i] next i+:=1
	else a[i] next i+:=1; j+:=1 { equality: take one, skip both }
	fi
      else j<nb do b[j] next j+:=1
      fi
    od
  fi

{ sort, keeping unique copy of duplicates }
set sort_u ((T,T->bool)leq) = ([T]->[T]):
  let rec_fun ms ([T] v, int l) = [T]: { invariant includes l=#v }
    if l<2 then v { for l=2 let |merge_u| do the three way choice }
    else let half=l\2 in leq.merge_u( ms(v[:half],half), ms(v[half:],l-half) )
    fi
  in { sort_u = } ([T] v) [T]: ms(v,#v)

end

set sort = sort(<=@(int,int))
set sort = sort(<=@(rat,rat))
set sort = sort(<=@(string,string))
set merge = merge(<=@(int,int)) { used separately in combinatorics.at }
set reverse_sort = sort(>=@(int,int))
set reverse_sort = sort(>=@(rat,rat))
set reverse_sort = sort(>=@(string,string))
set sort_u = sort_u(<=@(int,int))
set sort_u = sort_u(<=@(rat,rat))
set sort_u = sort_u(<=@(string,string))

{ the following helps stable-sorting of anything according to a statistic }

any_type S,T begin

{ Compute list |R| such that |R[i]| is index of element ranked |i| for |leq|.
  For $i<j$ one will have |leq(a[R[i]],a[R[j]])|, and in case of equality
  (the comparison also holds in the opposite order) one also has |R[i]<R[j]|.
  This is the inverse of the permutation that stable-sorts the list |a| into
  into order for |leq|, the latter being called the standardisation of |a|.
  Therfore this function used to be called |inv_standardisation|.
}
set ranking ((T,T->bool)leq) = ([T] a) [int]:
  sort((int i,int j)bool:leq(a[i],a[j]))(# #a)

set sort_by ((T->S)f,(S,S->bool)leq) = ([T]->[T]):
   sort((T x,T y)bool:leq(f(x),f(y)))
{ when sorting by integer or rational value, default to increasing sort }
set sort_by ((T->int) f) = ([T]->[T]): sort_by(f,<=@(int,int))
set sort_by ((T->rat) f) = ([T]->[T]): sort_by(f,<=@(rat,rat))

set partition_by ((T->S)f,(S,S->bool)leq) = ([T] a) [[T]]:
  let vals = map(f)(a) then rank = ranking(leq)(vals), i=0, n=#a in
  while i<n
  do let v = S: vals[rank[i]] in
     while i<n and leq(vals[rank[i]],v) do a[i] next i+:=1 od
  od

set lexicographic  ((T,T->bool)leq) = ([T] a,[T] b) bool:
  for i:min(#a,#b)
  do if not leq(a[i],b[i]) then return false
     elif not leq(b[i],a[i]) then return true
     fi
  od
; #a<=#b { let length difference decide if one is prefix ot the other }

end

set ranking = ranking(<=@(int,int))
set ranking = ranking(<=@(rat,rat))
set ranking = ranking(<=@(string,string))

{ Here are example calls of the model functions above. They can be defined here
  because reducibility_points and height are built-in functions (those defined
  in basic.at could also be used). If however you need to sort on a custom
  attribute defined elsewhere, DON'T do so here (and don't include modules to
  make that possible); rather call sort_by in the script where that custom
  attribute is defined.

  For instance LKT.at defines the |attribute LKT_dimensions|, and then defines
  sort_by_dimension in a call of sort_by, whose argument uses that attribute.
}

{ sort list of pairs [(Param,bool)] by #reducibility_points of Param }
set sort_by_reducibility_points = ([(Param,bool)]->[(Param,bool)]):
  sort_by((Param p,bool .) int: #reducibility_points(p), <=@(int,int) )

{ sort list [Param] by #reducibility_points of Param }
set sort_by_reducibility = ([Param]->[Param]):
  sort_by((Param p) int: #reducibility_points(p), <=@(int,int) )

{ Sort list of parameters by height }
set sort_by_height = ([KType] -> [KType]): sort_by( height@KType, <=@(int,int) )
set sort_by_height = ([Param] -> [Param]): sort_by( height@Param, <=@(int,int) )

{ Same for a list of parameters with a Split attached (ignored for sorting) }
set sort_by_height = ([(Split,Param)] -> [(Split,Param)]):
 sort_by( (Split s,Param p) int: height(p), <=@(int,int) )

{ sorting fixed size vectors lexicographically }
set lex_leq (vec v,vec w) = bool: { assert(#v=#w); }
   for x@i in v do if x!=w[i] then return x<w[i] fi od; true
{ for types [T], including [int], one can use |lexicographic(leq@(T,T))| instead }

set ranking = ranking(lex_leq@(vec,vec))
set sort_lex = sort(lex_leq@(vec,vec))
set sort_u_lex = sort_u(lex_leq@(vec,vec))

{ sorting rational ratvectors lexicographically }
set lex_leq (ratvec v,ratvec w) = bool: { assert(#v=#w); }
   for x@i in v do if x!=w[i] then return x<w[i] fi od; true

set ranking = ranking(lex_leq@(ratvec,ratvec))
set sort_lex = sort(lex_leq@(ratvec,ratvec))
set sort_u_lex = sort_u(lex_leq@(ratvec,ratvec))