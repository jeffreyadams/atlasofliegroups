Starting computation at Sun Apr 21 13:25:25 2024
Computing FPP for Sp(4,R)
(default) main file: FPP.at
other at files: 
Job number: 2
Job pid: 3090035
function: FPP_unitary_hash_bottom_layer
coh_ind_flag: false
revert_flag: true
deform_flag: false
every_KGB_flag: true
every_lambda_flag: true
every_lambda_deets_flag: true
facet_verbose: true
test_slightly_verbose: true
test_verbose: true
global_top: 3
low_KGB_frac: 2/5
bottom_length_frac: 1/1
global_facets_file_loaded: false
coh_ind_file_loaded: false
more_flag: true
old_proj_flag: false
==================================================================
size of main_queue: 1
current size of unitary_hash: Value: 0
Current size of surprise_hash: Value: 0
list_number=2
in xlambdalists_flag loop: size of list:  2
starting FPP_unitary_hash_timeout with 3 unitary hash functions  [0:00:00  0:00:00]
size of xlambdalists: 3  [0:00:00  0:00:00]
size of xlambdalist: 2  [0:00:00  0:00:00]
Starting size of unitary_hash: 0  [0:00:00  0:00:00]
==============================================================  [0:00:00  0:00:00]
FPP_unitary_hash_timeout step 0  [0:00:00  0:00:00]
function= Function defined at FPP_globalDirac.at:865:7--998:66  [0:00:00  0:00:00]
(xlambdas,UhashG,Uparamhash,more_shift,max_time):  if timeout_verbose then prints@(string,int)("start of function (2): FPP_unitary_hash_bottom_layer with max_time=",max_time) else () fi ; let timedout=-1 in  let success=true in  let failed=[] in  if =@(int,int)(#@[(KGBElt,ratvec)](xlambdas),0) then  return [] else  let ((x,),pol_hash)=(xlambdas[0],make_KTypePol_hash@void()) in  let G=real_form@KGBElt(x) in  let disconn_flag=>@(int,int)(components_rank@RealForm(G),0) in  let (Gsc,M)= if disconn_flag then derived_cover_real_form_info@RealForm(G) else (G,id_mat@int(rank@RootDatum(RdRf:G))) fi  in  let xlambdas_sc= if disconn_flag then  for (x,lambda) in xlambdas do (inverse_embed_KGB@(KGBElt,RealForm,mat)(x,Gsc,M),*@(mat,ratvec)(M,lambda)) od  else xlambdas fi  in  let Uhash= if disconn_flag then make_Param_hash@void() else UhashG fi  in  let start=elapsed_ms@void() in  if timeout_verbose then prints@string("starting timer") else () fi ;unitaryTime:=0;dfkiTime:=0; if Dirac_flag then prepDirac@RealForm(Gsc) else () fi ; let xnums= for (x,) in xlambdas do  let (,m)=%@KGBElt(x) in m od  in  let lambdas= for (,lambda) in xlambdas do lambda od  in  let LPmss= for (x,lambda) in xlambdas_sc do (LPm_table.LPm_entry)(IcRf:Gsc,involution@KGBElt(x),ratvec_as_vec@ratvec(+@(ratvec,ratvec)(lambda,*@(mat,ratvec)(involution@KGBElt(x),lambda)))) od  in  let (old_facet_verbose,old_time_verbose,old_test_verbose,old_test_slightly_verbose)=(facet_verbose,time_verbose,test_verbose,test_slightly_verbose) in facet_verbose:=false;time_verbose:=false;test_verbose:=false;test_slightly_verbose:=false; if unip_flag then  if timeout_verbose then prints@string("computing unipotents_to_hash") else () fi ;unipotents_to_hash@(RealForm,Param_hash)(G,UhashG) else () fi ; if coh_ind_flag then  if timeout_verbose then prints@string("computing coh_ind_unip_long") else () fi ;coh_ind_unip_long@(RealForm,Param_hash)(G,UhashG) else () fi ; if disconn_flag then  for j: (UhashG.size)() do  for psc in sc_lifts@(Param,RealForm,mat)((UhashG.index)(j),Gsc,M) do (Uhash.match)(psc) od  od  else () fi ; let xlambdatimes=[I]V:null@int(#@[(KGBElt,ratvec)](xlambdas)) in  let answerCards=[I]V:null@int(#@[(KGBElt,ratvec)](xlambdas)) in  let oldUhash=(Uhash.size)() in  if  if =@(int,int)(#@[[vec]](global_facets),0) then true else !=@(int,int)(#@[vec](global_facets[0]),#@[ratvec]((LPm_table.FPP_vertex_data)(IcRf:Gsc).list)) fi  then global_facets:=low_FPP_facets@InnerClass(IcRf:G) else () fi ; if  if by_zero_flag then  if =@(int,int)(#@[[[vec]]](global_facets_by_zero),0) then true else !=@(int,int)(#@[[vec]](global_facets_by_zero[0]),#@[ratvec]((LPm_table.FPP_vertex_data)(IcRf:Gsc).list)) fi  else false fi  then global_facets_by_zero:=low_FPP_facets_by_zero@[[vec]](global_facets) else () fi ; let (current,oldUhash,currentUhash,formerUhash,oldUcounter,currentUcounter)=(elapsed_ms@void(),(UhashG.size)(),(Uhash.size)(),(Uhash.size)(),(unitary_test_counter.use_count)(),(unitary_test_counter.use_count)()) in  for (x,lambda)@k in xlambdas do prints@(string,int,string,string,KGBElt,string,ratvec,string,string)("entry number A ",k,new_line,"(x,lambda)=(",x,",",lambda,")",new_line); let (start,startUhash,(x_sc,lambda_sc),startUcounter,theta,startUparamhash,startmorebad)=(elapsed_ms@void(),(Uhash.size)(),xlambdas_sc[k],(unitary_test_counter.use_count)(),involution@KGBElt(x),(Uparamhash.size)(),(more_bad_hash.size)()) in  let (Lvd,Perm2,mapAct)=LPmss[k] in  let LF= if by_zero_flag then localFD_1Dirac2_by_zero@(KGBElt,ratvec,VertexData,(vec,[(int,int)]),vec,[[[vec]]])(x_sc,lambda_sc,Lvd,Perm2,mapAct,global_facets_by_zero) else localFD_1Dirac2@(KGBElt,ratvec,VertexData,(vec,[(int,int)]),vec,[[vec]])(x_sc,lambda_sc,Lvd,Perm2,mapAct,global_facets) fi  in  if =@(int,int)(#@[vec](LF[0]),0) then () else  if every_lambda_deets_flag then facet_verbose:=old_facet_verbose;time_verbose:=old_time_verbose;test_verbose:=old_test_verbose;test_slightly_verbose:=old_test_slightly_verbose else () fi ; let (answer,success)=local_test_GEO_hash_bottom_layer@(KGBElt,ratvec,VertexData,VertexData,[[vec]],KTypePol_hash,Param_hash,int,int)(x_sc,lambda_sc,(LPm_table.FPP_vertex_data)(IcRf:Gsc),Lvd,LF,pol_hash,Uhash,more_shift,max_time) in answerCards[k]:=#@[Param](answer); if success then () else failed:=#@([T],T)(($failed,(x,lambda)~)) fi ; for p in answer do (Uparamhash.match)(p) od ;current:=elapsed_ms@void();currentUhash:=(Uhash.size)();currentUcounter:=(unitary_test_counter.use_count)();xlambdatimes[k]:=-@(int,int)(current,start); if every_lambda_flag then prints@(string,string,string,int,string,int,string,ratvec,string,int,string,RealForm,string,string)("  ",print_time_string@int(xlambdatimes[k])," = time for (x,lambda) = (",xnums[k],",",k,",",lambdas[k],"), ht = ",height@Param(parameter@(KGBElt,ratvec,ratvec)(x,lambda,*@(int,ratvec)(0,lambda))),", L = ", let (Q,)=theta_stable_quasi_data@Param(parameter@(KGBElt,ratvec,ratvec)(x,lambda,*@(int,ratvec)(0,lambda))) in Levi@KGPElt(Q),",",test_string);prints@(string,[int],string,int,string,int,string,int,string,int)("    #LF = ", for L in LF do #@[vec](L) od ,"; #unitary params = ",answerCards[k],", #new unitary = ",-@(int,int)((Uhash.size)(),startUhash),", #tests = ",-@(int,int)((unitary_test_counter.use_count)(),startUcounter),", #Params missed by more = ",-@(int,int)((more_bad_hash.size)(),startmorebad));prints@string("  ------------------") else () fi  fi  od ; if disconn_flag then  for j: (Uhash.size)() do  for p in sc_descends@(Param,RealForm,mat)((Uhash.index)(j),G,M) do (UhashG.match)(p) od  od  else () fi ;facet_verbose:=old_facet_verbose;time_verbose:=old_time_verbose;test_verbose:=old_test_verbose;test_slightly_verbose:=old_test_slightly_verbose; let longest=max_loc@[int](xlambdatimes) in  if print_time_info then prints@(string,string,string,string,string,string,int,string,ratvec,string)(new_line,"Total time = ",print_time_string@int(-@(int,int)(current,start)),"; max time = ",print_time_string@int(xlambdatimes[longest])," for (x,lambda) = (",xnums[longest],",",lambdas[longest],")");prints@(string,string,string,int,string,int)("Time spent in is_unitary = ",print_time_string@int(unitaryTime),", #unitarity tests = ",(unitary_test_counter.use_count)(),", #K-types studied = ",(minBottomData.size)());prints@(string,string)("Time in derived_factor_K_types_info = ",print_time_string@int(dfkiTime));prints@(string,string,string,string)("Time in min_bottom_factors = ",print_time_string@int(mbfTime),", time in min_bottom_elim_factors = ",print_time_string@int(mbefTime));prints@(string,string,string,string)("Time in bottom layer branching = ",print_time_string@int((rf_sig_tables.bottom_branch_time)()),", time in bottom layer sig = ",print_time_string@int((rf_sig_tables.bottom_sig_time)())); if more_flag then prints@(string,string,string,string,string,int,string,int)("Time in bottom_factors = ",print_time_string@int(bfTime),", time in bottom_elim_factors_more = ",print_time_string@int(-@(int,int)(befmoreTime,bfTime)),", more_shift = ",more_shift,", #Params missed by more = ",(more_bad_hash.size)()) else () fi ; if  if surprise_flag then >@(int,int)((surprise_hash.size)(),0) else false fi  then prints@(string,int,string)("  Found ",(surprise_hash.size)()," counterexamples to coh_ind(unitary) = unitary; they're in surprise_hash.") else () fi ;prints@(string,int,string,int,string,int,string,int)("  #hash_def_dumb =",(hash_def_dumbCounter.use_count)(),", #hash2 =",(hash2Counter.use_count)(),", #hash_one_level = ",(hash_one_levelCounter.use_count)(),", #hash_bottom_layer =",(hash_bottom_layerCounter.use_count)());prints@(string,int)("Number of unitary params = ",sum@[int](answerCards));prints@(string,int,string,int)("Number of FPP-unitary facets = ",(UhashG.size)(),", number found on this run = ",-@(int,int)((UhashG.size)(),oldUhash));prints@(string,int)("timedout value: ",timedout) else () fi  fi ; if timeout_verbose then prints@(string,int)("end of function: FPP_unitary_hash_bottom_layer with max_time, timedout=",timedout) else () fi ;prints@(string,int)("returning failed list of size ",#@[(KGBElt,ratvec)](failed));failed  [0:00:00  0:00:00]
function parameters=(5,10)  [0:00:00  0:00:00]
size of unitary hash: 0  [0:00:00  0:00:00]
size of xlambdalist: 2  [0:00:00  0:00:00]
xlambdalist:  [0:00:00  0:00:00]
0 (KGB element #6,[ 1, 1 ]/1)  [0:00:00  0:00:00]
1 (KGB element #6,[ 0, 1 ]/1)  [0:00:00  0:00:00]
more_shift: 5 max_time: 10  [0:00:00  0:00:00]
start of function (2): FPP_unitary_hash_bottom_layer with max_time=10  [0:00:00  0:00:00]
starting timer  [0:00:00  0:00:00]
computing unipotents_to_hash  [0:00:00  0:00:00]
entry number A 0  [0:00:00  0:00:00]
(x,lambda)=(KGB element #6,[ 1, 1 ]/1)  [0:00:00  0:00:00]
  [0:00:00  0:00:00]
start of function: local_test_GEO_hash_bottom(KGBElt x, ...), max_time=10  [0:00:00  0:00:00]
more_shift=5  [0:00:00  0:00:00]
time for more datas/BKT was 0.000sec at lambda = [ 1, 1 ]/1  [0:00:00  0:00:00]
facet counts to dim 1: [2,1]  [0:00:00  0:00:00]
testing height = 8  [0:00:00  0:00:00]
  [0:00:00  0:00:00]
0.001sec for localFD_KHash_01  [0:00:00  0:00:00]
time for more datas/maxQs was 0.014sec at lambda = [ 1, 1 ]/1  [0:00:00  0:00:00]
0.023sec for local_testK_hash_bottom_layer  [0:00:00  0:00:00]
unitary on bottom layer to 8 facet counts to dim 1: [2,1]  [0:00:00  0:00:00]
number of tests so far = 0  [0:00:00  0:00:00]
start of function (3): local_test_hash_bottom(KGBElt x, ...), max_time=10  [0:00:00  0:00:00]
running is_unitary on: final parameter(x=6,lambda=[1,1]/1,nu=[0,1]/1)  [0:00:00  0:00:00]
In is_unitary_hash, max_time=10  [0:00:00  0:00:00]
is hermitian  [0:00:00  0:00:00]
is_unitary_hash, other case  [0:00:00  0:00:00]
finished is_unitary_hash, timedout=-1  [0:00:00  0:00:00]
completed is_unitary_hash, timedout=true  [0:00:00  0:00:00]
running is_unitary on: final parameter(x=6,lambda=[1,1]/1,nu=[0,0]/1)  [0:00:00  0:00:00]
In is_unitary_hash, max_time=10  [0:00:00  0:00:00]
is hermitian  [0:00:00  0:00:00]
is_unitary_hash, other case  [0:00:00  0:00:00]
finished is_unitary_hash, timedout=-1  [0:00:00  0:00:00]
completed is_unitary_hash, timedout=true  [0:00:00  0:00:00]
unitary facets by dim = [ 2, 1 ] using local_test_GEO_hash_bottom_layer  [0:00:00  0:00:00]
number of tests = 4  [0:00:00  0:00:00]
0.007sec for UParams calculation  using local_test_GEO_hash_bottom_layer  [0:00:00  0:00:00]
  [0:00:00  0:00:00]
0.045sec = time for (x,lambda) = (6,0,[ 1, 1 ]/1), ht = 3, L = connected quasisplit real group with Lie algebra 'sl(2,R).u(1)', using local_test_GEO_hash_bottom_layer  [0:00:00  0:00:00]
#LF = [2,1]; #unitary params = 3, #new unitary = 3, #tests = 4, #Params missed by more = 0  [0:00:00  0:00:00]
------------------  [0:00:00  0:00:00]
entry number A 1  [0:00:00  0:00:00]
(x,lambda)=(KGB element #6,[ 0, 1 ]/1)  [0:00:00  0:00:00]
  [0:00:00  0:00:00]
start of function: local_test_GEO_hash_bottom(KGBElt x, ...), max_time=10  [0:00:00  0:00:00]
more_shift=5  [0:00:00  0:00:00]
0.000sec = time for (x,lambda) = (6,1,[ 0, 1 ]/1), ht = 0, L = connected split real group with Lie algebra 'sp(4,R)', using local_test_GEO_hash_bottom_layer  [0:00:00  0:00:00]
#LF = [1,0]; #unitary params = 1, #new unitary = 0, #tests = 0, #Params missed by more = 0  [0:00:00  0:00:00]
------------------  [0:00:00  0:00:00]
end of function: FPP_unitary_hash_bottom_layer with max_time, timedout=-1  [0:00:00  0:00:00]
returning failed list of size 0  [0:00:00  0:00:00]
end of step 0 nothing left to do  [0:00:00  0:00:00]
unitary reps found this step: 19  [0:00:00  0:00:00]
size of unitary_hash: 19  [0:00:00  0:00:00]
finished all 3 steps  [0:00:00  0:00:00]
unitary reps found this step: 19  [0:00:00  0:00:00]
Finished_KGB element 2: elapsed time: 0:00:00  time from start: 0:00:00
Get another item from queue
No more KGB elements to do; time: Sun Apr 21 13:25:27 2024
Times:
Time for list number:2 0:00:00
Total time for 1 lists: 0:00:00
Size of unitary_hash: Value: 19
Size of surprise_hash: Value: 0
Killing process at Sun Apr 21 13:25:27 2024
