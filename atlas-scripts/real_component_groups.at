<nilpotent_orbits.at

{set real_forms_of_orbit_with_Levi (RealForm G,[int] H)=[(RealNilpotent, RealForm, vec)]:
   let (S,K)=Levi_of_H(H,G) then Levis=viable_Levis(G,S) then
   list=##for M in Levis do test_real_orbit_plus (G,K,M,S) then
   for psir
}
set test_real_orbit_plus (RealForm G,[int] H, RealForm M, [int] S) = [(KGBElt, KGBElt, RealForm)]:
 ##for x_M in KGB(M)
   do let P_L=Parabolic:(simple_roots_from_coweight(root_datum(M),H),x_M)
   in if is_parabolic_theta_stable(P_L) and x_M=x_min(P_L) else []
      then
         let MC=complex_Levi(G,S), theta=involution(x_M)
         then dim_center=rank(lie_compact_radical(inner_class(MC,theta)))
         , number_roots =
            for alpha in posroots(M)
            do if is_noncompact_imaginary(alpha,x_M) and H*alpha=2 then 1
               elif is_complex(alpha,x_M) and H*alpha=2 then /2 { with 2/2=1 }
               else 0
               fi
            od.sum
      in if dimension(K_0(Levi_of_orbit(real_nilpotent(H,x_M))))
           =dim_center+number_roots
         then [(embed_KGB(x_M,G),x_M,M)]
         else []
         fi
      fi
    od

set test_real_orbit_alt (RealForm G,[int] H, RealForm M) = [KGBElt]:
 ##for x_M in KGB(M)
   do let P_L=Parabolic:(simple_roots_from_coweight(root_datum(M),H),x_M)
   in if is_parabolic_theta_stable(P_L) and x_M=x_min(P_L) else []
      then
         let MC=root_datum(M), theta=involution(x_M)
         then dim_center=rank(lie_compact_radical(inner_class(MC,theta)))
         , number_roots =
            for alpha in posroots(M)
            do if is_noncompact_imaginary(alpha,x_M) and H*alpha=2 then 1
               elif is_complex(alpha,x_M) and H*alpha=2 then /2 { with 2/2=1 }
               else 0
               fi
            od.sum
      in if dimension(K_0(Levi_of_orbit(real_nilpotent(H,x_M))))
           =dim_center+number_roots
         then [embed_KGB(x_M,G)]
         else []
         fi
      fi
    od

{. Given G and a coweight H, find all x so that (H_nd,x,) is a real
   nilpotent orbit. Here H_nd is the conjugate of H corresponding to
   the associated Bala-Carter Levi M. There may be duplications of
   orbits. .}
set all_real_nilpotent_orbit_KGBs_plus (RealForm G,[int] H) = [(KGBElt,KGBElt,RealForm)]:
   let (S,K)=Levi_of_H(H,G) then Levis=viable_Levis(G,S) in
 ##for M in Levis do test_real_orbit_plus(G,K,M,S) od

set x_preserving_root_datum (RootDatum rd, RealForm G)=[KGBElt]:
   ##for x in KGB(G) do if
   all(for alpha in simple_roots(rd) do is_root (rd,involution(x)*alpha) od) then [x]
   else [] fi od

set real_form_of_pseudo_Levi (RootDatum rd, KGBElt x)=RealForm:
   let theta=involution(x) then
   ic_L=inner_class(rd,theta)   in real_form(ic_L,theta,torus_factor(x))

set is_elliptic_pseudo_Levi_x (RootDatum rd, KGBElt x) = bool:
   {in_distinguished_fiber(x)} let G=real_form(x) in
        Cartan_class(x)= fundamental_Cartan(G) and
   all(for alpha in simple_roots(rd) do let beta=involution(x)*alpha in
      (is_posroot (rd,beta) and is_simple_root(rd,beta)) od)

set real_forms_of_pseudo_Levi (RootDatum rd, RealForm G)=[(RealForm,KGBElt)]:
   let result=[(RealForm,KGBElt)]:[] in
   for x in x_preserving_root_datum (rd,G) do
   let L=real_form_of_pseudo_Levi (rd,x) in
   if none (for (M,) in result do M=L od) then result#:=(L,x) fi od;
   result

set elliptic_forms_of_pseudo_Levi (RootDatum rd, RealForm G)=[(RealForm,KGBElt)]:
   let result=[(RealForm,KGBElt)]:[] in
   for x in KGB(G) do if is_elliptic_pseudo_Levi_x (rd,x) then
   let L=real_form_of_pseudo_Levi (rd,x) in
   if none (for (M,) in result do M=L od) then result#:=(L,x) fi fi od;
   result

set elliptic_pseudo_Levis (RealForm G)=[RealForm]:
   let rd=root_datum(G) in let
      temp= ##for L in pseudo_Levi_subgroups(rd)
      do  elliptic_forms_of_pseudo_Levi (L,G) od in
      for (L,) in temp do L od

set proper_pseudo_Levis (RootDatum rd)=[[int]]:
   let r=semisimple_rank (rd) in
   ##for S in pseudo_Levis(rd) do if #S>0 and S[0]=r then [S] else [] fi od

set real_orbit_KGBs_with_pseudo_Levis (ComplexNilpotent OC, RealForm G)=[(RealForm,vec,[KGBElt])]:
   let pairs=pseudo_Levis(OC) then
   result=[(RealForm,vec,[KGBElt])]:[] in
   for (LC,K) in pairs do
      for (L,) in real_forms_of_pseudo_Levi (LC,G) do
         let kgbs=test_real_orbit_alt (G,K,L) in result#:= (L,K,kgbs) od od;
      result

set standard_real_orbit (vec H,KGBElt x)=RealNilpotent:
   let K=dominant(H,root_datum(x)),G=real_form(x) in
   if =H then real_nilpotent(H,KGB(G,0))
       else let P=parabolic_of_orbit(real_nilpotent(H,x))
           in real_nilpotent(K,x_min(P)) fi

set standard_real_orbits (vec H,[KGBElt] list)=[RealNilpotent]:
   if #list=0 then []
     else let result=[RealNilpotent]:[] in for x in list
          do let orb=standard_real_orbit (H,x)
	     in if none(for O in result do is_conjugate_orbit (O,orb) od)
	        then result#:=orb fi od;
      result
    fi

set pseudo_Levis (RealNilpotent O)=[RealForm]:
   let G=real_form(O), OC=complex_orbit(O)
    then triples=real_orbit_KGBs_with_pseudo_Levis(OC,G) then
    result=[RealForm]:[] in
       for (M,H,list) in triples
       do if any (for x in list do is_conjugate_orbit(O,standard_real_orbit (H,x)) od)
          then result#:=M fi od;
       result

set is_noticed_orbit (RealNilpotent (H,y,()))=bool:
   let G=real_form(y) then
      P=Parabolic:(simple_roots_from_coweight(root_datum(G),H),y)
          in if is_parabolic_theta_stable(P) else false
      then let x=x_min(P) then
         MC=root_datum(G), theta=involution(x)
         then dim_center=rank(lie_compact_radical(inner_class(MC,theta)))
         , number_roots =
            for alpha in posroots(G)
            do if is_noncompact_imaginary(alpha,x) and H*alpha=2 then 1
               elif is_complex(alpha,x) and H*alpha=2 then /2 { with 2/2=1 }
               else 0
               fi
            od.sum
      in dimension(K_0(Levi_of_orbit(real_nilpotent(H,x))))
           =dim_center+number_roots
         fi

{set is_noticed_orbit_in_M (RealNilpotent (H,x,()),RealForm M)=bool:
   let G=real_form(x) then rd=root_datum(G), MC=root_datum(M) then
   orbits=nilpotent_orbits(MC) in
   let n=first(for (,,K) in orbits do is_conjugate(K,H,rd) od) in
   if n=-1 then {prints("The orbit does not meet M.");} false
   else let M_orbits=real_nilpotent_orbits(orbits[n],M) then
     noticed_orbits=##for orb in M_orbits do
        if is_noticed_orbit (orb) then [orb] else [] fi od
     in any(for (K,y,) in noticed_orbits do
       let orb=RealNilpotent:(K,embed_KGB(y,G),()) in
                 is_conjugate_orbit (orb,(H,x,())) od) fi}

set is_noticed_orbit_in_M (RealNilpotent (H,x,()),RealForm M)=(bool,vec):
   let G=real_form(x) then rd=root_datum(G), MC=root_datum(M) then
   orbits=nilpotent_orbits(MC) in
   let n=first(for (,,K) in orbits do is_conjugate(K,H,rd) od) in
   if n=-1 then {prints("The orbit does not meet M.");} (false,[])
   else let M_orbits=real_nilpotent_orbits(orbits[n],M) then
     noticed_orbits=##for orb in M_orbits do
        if is_noticed_orbit (orb) then [orb] else [] fi od
     in
     if any(for (K,y,) in noticed_orbits do
       let orb=RealNilpotent:(K,embed_KGB(y,G),()) in
              is_conjugate_orbit (orb,(H,x,())) od)
	      then (true,orbits[n].H) else (false,[]) fi fi

set noticed_elliptic_pseudo_Levis (RealNilpotent O)=[(RealForm,vec)]:
   let G=real_form(O) then list=elliptic_pseudo_Levis(G) in
   ##for L in list do let (b,v)=is_noticed_orbit_in_M (O,L) in if b then [(L,v)]
                         else [] fi od

set generators_of_component_group (RealNilpotent (H,x,()))=
[(RealForm,vec,[ratvec],[ratvec],[ratvec],[ratvec])]:
  let rd=root_datum(x), G=real_form(x)
  in for (EL,H_L) in noticed_elliptic_pseudo_Levis (H,x,()) do let L=root_datum(EL)
   then Lmod=mod_central_torus(L)
   then Z_Lmod=elements_of_center(Lmod)
   then L_rad=radical_basis(L)
   then (,M)=Levi_of_subspace(rd,L_rad)
   then Z_Lmod_reg=##for v in Z_Lmod do
     if dimension(centralizer(M,lift(L,v)))=L.dimension then [v]
     else [] fi od
   then Z_Lmod_reg_lifted=for v in Z_Lmod_reg do lift(L,v) od
   then (,Levi_H_L_M)=Levi_of_coweight(M,H_L)
   then  (,Levi_H_L)=Levi_of_coweight(rd,H_L)
   {then (indices,Z_Lmod_reg_lifted_cc)
               = semisimple_conjugacy_class_reps(Levi_H_L,Z_Lmod_reg_lifted)}
   then (indices,Z_Lmod_reg_lifted_cc)
            = semisimple_conjugacy_class_mod_torus_reps(Levi_H_L,Z_Lmod_reg_lifted,L_rad)
   then Z_Lmod_reg_cc=for i in indices do Z_Lmod_reg[i] od
   in (EL,H_L,Z_Lmod,Z_Lmod_reg,Z_Lmod_reg_lifted,Z_Lmod_reg_lifted_cc) od

set component_datum(RealNilpotent O)=(RealNilpotent,[int],[(RealForm,[ratvec])]):
  if O.root_datum.is_abelian then
     let EL=O.real_form in (O,[1],[(EL,[null(root_datum(O).rank)/1])])
  else let g=generators_of_component_group(O)
       then orders=## for (a,H,b,c,d,S) in g do for v in S do
                              order_in_A(v,O.root_datum,H) od od
       in (O,sort(orders),for (L,H,b,c,d,S) in g do (L,S) od) fi

set print_component_info (RealNilpotent O)=void:
   let (,orders,d)=component_datum(O)
   then header=["pseudo_Levi","Generators"]
   then values=
        for (L,S) in d do [L.to_string,S.to_string] od in
   prints("Component info for orbit:",new_line, "H=", O.H{_of_triple}, " ",x(O),
      ", diagram:", O.complex_orbit.diagram);
   prints("orders:",orders);
   tabulate(header#values)

set is_K_conjugate(KGBElt x,vec mu,vec lambda)=bool:
   let ((,v),,,)=make_strongly_dominant(x,mu),
   ((,w),,,)=make_strongly_dominant(x,lambda)
   in v=w
   