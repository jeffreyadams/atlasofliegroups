{ The purpose of this module is to collect basic combinatorial functions,
  like factorials, binomial coefficients, generators of partitions and so on
}

<basic.at
<sort.at
<groups.at { for root data computed by |GL|, |Sp|, |SO| }

{ |fac@int| is now defined in basic.at }

set binom (int n, int k) = int:
   if n.>= and k+k>n then k:=n-k fi; { use symmetry to limit |k| }
   case k then 0 in 1, n
   else let p=n*(n-1) in for i:k-2 from 2 do p:=p\i*(n-i) od; p\k
   esac

set binom (rat n, int k) = rat:
   if n.denom=1 and n.>= and k+k>n then k:=n.numer-k fi; { try for efficiency }
   case k then 0 in 1, n
   else let p=n*(n-1) in for i:k-2 from 2 do p:=p/i*(n-i) od; p/k
   esac

set multi_choose (int n,int k) = int: binom(n+k-1,k)

set falling_power (int n, int k) = int: assert(>=0,"Negative exponent");
   let p=1 in for i:k from n-k+1 do p*:=i od; p

set rising_power (int n, int k) = int: assert(>=0,"Negative exponent");
   let p=1 in for i:k from n do p*:=i od; p

{ Combinatorial number system ${\N\choose k}\to\N$ encoding and decoding }

{ Represent any $k$-combination on $\N$ as a single natural number
  For fixed $k$ this is bijective, and a decoding follows.
}
set combination_encode([int] list) = int: { |list| strictly increasing }
   for c@i in list do binom(c,i+1) od.sum

set combination_decode(int k) = (int->[int]):
{ no need of case distinction for |k=0|: code below builds constant function }
   (int N) [int]:
   let bound=N+k { conservative start; we must have |binom(bound,k)>N| }
in for i:k from 1 ~ { entries are determined in decreasing order }
   do let c_i = binary_search_first((int n)bool: binom(n,i)>N, 1,bound) - 1
   in N -:= binom(c_i,i); bound:=c_i
  ~od { next assert(N=0) }

{		some transformations of sequences of numbers		}

set cumulate_forward ([int] seq) = [int]:
   let sum=0 in for k in seq do sum+:=k od
set cumulate_backward ([int] seq) = [int]:
   let sum=0 in for k in seq ~do sum+:=k ~od

set forward_differences ([int] seq) = [int]: { inverse of |cumulate_forward| }
   let last=0 in for k in seq do k-last next last:=k od
set backward_differences ([int] seq) = [int]: { inverse of |cumulate_backward| }
   let last=0 in for k in seq ~do k-last next last:=k ~od

{ extract components at even or odd positions }
set even_places ([int] v) = for i:-(-#v)\2 do v[2*i] od
set odd_places  ([int] v) = for i:#v\2 do v[2*i+1] od


{				Permutations				}

{ Matrix whose left-multiplication to a column vector permutes it by |pi|.
  It has nonzero entries at each (pi(j),j), it could have been defined (using
  |matrix| from basic.at) as |matrix((#pi,#pi),(int i,int j): #(i=pi[j]) )|.
}
set permutation_matrix ([int] pi) = mat:
   let n=#pi then I=n.id_mat in n# for v in pi do I[v] od

set permutation (mat P) { assumed a permutation matrix} = [int]:
  (vec: #P.n_rows)*P { right-act on row [0,1,...,n-1] for one-line form }

set compose_permutations ([int] sigma, [int] pi) = [int]:
  for i in pi do sigma[i] od

set inverse ([int] pi) = [int]: { hope that name causes no conflict }
  let n=#pi then result=for :n do n od { sentinel values} in
  for i@j in pi
  do assert(i.>= and i<n and result[i]=n { in range, and no seen before }
           ,to_string("not a permutation (",i,")"));
     result[i]:=j
  od; result

{ longer name for non-checking (so faster) version of the above }
set permutation_inverse ([int] pi) = [int]:
  let result=null(#pi) in for i@j in pi do result[i]:=j od; result

set permute ([int] pi,vec v) = vec: { replaces |v[i]| by |v[pi.inverse[i]]| }
  assert(#pi=#v { and |pi| is a permutation },"length mismatch");
  let result=null(#v) in for i@j in pi do result[i]:=v[j] od; result

set permutation_cycles ([int] pi) = [[int]]:
  let n=#pi then todo = for :n do true od in
  for start:n { try every index once as |start|, those visited give 0-cycles }
  do let i=start { we need a modifiable index }
     then cycle = while todo[i] do todo[i]:=false; i next i:=pi[i] od
     in if =#cycle then [] else [cycle] fi { suppress the 0-cycles }
  od.##

{ group root indices by orbits under group generated by |w| }
set root_orbits (WeylElt w) = [[int]]:
   let perm=root_permutation(w) then npr=#perm\2 { number of positive roots }
in for cycle in permutation_cycles(perm)
   do for index in cycle do index-npr od { shift back to interval [-npr,npr[ }
   od


{				Partitions				}

set_type Partition = [int]   { list of decreasing parts, no trailing zeros }

set strip_to_partition (Partition lambda) = [int]:
  lambda[:1+last(#lambda,(int i)bool: !=lambda[i])]
{ alternatively: |for x in list do if =x then break fi od| }

set is_partition ([int] seq) = bool: backward_differences(seq).>=

set frequencies (Partition lambda) = vec: { frequency vector, position 0 unused }
  let v=null(1) in { ensure the unused position 0 is always present }
  for l in lambda
  do if l>=#v then v ##:= null(l-#v)#1 { append final 1 } else v[l]+:=1 fi
  od; v

{ the following is a right-inverse to |frequencies|, image is all partitions }
set repeat_parts (vec frequencies) = Partition:
  for f@i in frequencies[1:] { skip 0, reverse:} ~ do for :f do i+1 od od.##

set sort_to_partition ([int] parts) = Partition:
  parts.frequencies.repeat_parts

set cycle_type ([int] pi) = Partition: { cycle sizes in decreasing order }
  for cycle in permutation_cycles(pi) do #cycle od.sort_to_partition

{ transpose of a composition, after implicitly sorting it to a partition }
set transpose ([int] parts) = Partition:
   parts.frequencies[1:].cumulate_backward
{ or more "manually", when |parts| assumed already in decreasing order
  if #lambda=0 then []
  else let l=#lambda in
    for i:lambda[0] { value |lambda[0]| is sentinel ensuring |l>0| below }
    do while lambda[l-1]<=i do l-:=1 od; l
    od
  fi
}

{ basic data for Levi factor of $A_{n-1}$ given by composition |parts| of $n$ }
set Levi_A ([int] parts) = (int,LieType,[int]): {  |(n,Levi_type,simples)| }
   let sum=minus_1, lt=Lie_type("")
   then bars = [int]:
      for p in parts do if p>1 then lt:=extend(lt,"A",p-1) fi; sum+:=p od
in (sum+1,lt,complement(sum,bars))

set compressed_string(Partition P) = string:
   let mult=1
   then result =
      for l@i in P
      do if i=0 then "[ "
	 elif l=P[i-1] then mult+:=1; ""
	 elif mult=1 then P[i-1]+", "
	 else P[i-1]+"^"+mult+", " next mult:=1
	 fi
      od.##
in result ## if mult=1 then P~[0].to_string else P~[0]+"^"+mult fi ## " ]"


{ comparing partitions of same |n| lexicographically; implicitly 0-extend }
set leq_equal_sum_partitions(Partition lambda, Partition mu) = bool:
   let m=#mu in
   for l@i in lambda
   do if i>=m then assert(=l,"unequal sum"); return true
      elif l!=mu[i] then return l<mu[i]
      fi
   od; assert(=mu[#lambda:],"unequal sum"); true

{ same, but three-way result in $\{-1,0,1\}$ for less/equal/greater; no 0-ext }
set cmp_equal_sum_partitions(Partition lambda, Partition mu) = int:
   let m=#mu in
   for l@i in lambda
   do if l!=mu[i] { equal sum, nonzero entries, so |mu| cannot run out }
      then return if l<mu[i] then minus_1 else 1 fi
      fi
   od; 0 { if |lambda| exhausted then so is |mu|, and we have equality }

{ comparing partitions by sum then lexicographically; implicitly 0-extend }
set leq_partitions ((Partition,Partition) (lambda,mu):pair) = bool:
  let sl=lambda.sum, sm=mu.sum in
  if sl!=sm then sl<sm else leq_equal_sum_partitions(pair) fi

set cmp_partitions ((Partition,Partition) (lambda,mu):pair) = int:
  let sl=lambda.sum, sm=mu.sum in
  case sl-sm then minus_1 in cmp_equal_sum_partitions(pair) else 1 esac

{ look up partition in sorted list of partitions, all assumed of same sum }
set index_partition([Partition] sorted_list) = (Partition->int):
(  let l=#sorted_list in { precompute constant }
   (Partition lambda) int:
      binary_search_first
      ((int i)bool:leq_equal_sum_partitions(lambda,sorted_list[i])
      ,0,l
      )
)

{ dominance order of partitions }
set leq_dominance_order_partitions (Partition v,Partition w) = bool:
   if =#v then assert(=w ,"not comparable"); true
   elif =#w then assert(=v ,"not comparable"); true
   else v:=sort_to_partition(v); w:=sort_to_partition(w)
   ; assert(v~[0].>= and w~[0].>=,"negative terms")
   ; let sums_v = cumulate_forward(v), sums_w = cumulate_forward(w)
     in assert(sums_v~[0]=sums_w~[0],"not comparable")
     ; for i:min(#v,#w) do sums_v[i]<=sums_w[i] od.all { need exactly these }
   fi

{ same as previous but assume each term is already reverse sorted,
  and all terms are comparable }
set leq_dominance_order_partitions_presorted (Partition v,Partition w) = bool:
   let sums_v = cumulate_forward(v), sums_w = cumulate_forward(w)
   in for i:min(#v,#w) do sums_v[i]<=sums_w[i] od.all

{		functions related to representations of S_n		}

set hook_lengths (Partition lambda) = [int]:
   let lambda_tr=lambda.transpose in
   for part@i in lambda
   do for j:part do (part-j) + (lambda_tr[j]-i) - 1 od { arm + leg - 1 }
   od.##.sort_to_partition { not viewed as partition, but sorting is the same }

set Sn_representation_dimension (Partition lambda) = int:
   let hl=lambda.hook_lengths in hl.#.fac\hl.product

set hook_lengths ([bool] edges) = [int]:
   let last=#edges-1 in
 ##for edge@i in edges
   do if edge then []
      else ##for j:last-i from i+1 do if edges[j] then [j-i] else [] fi od
      fi
   od

{ edge sequence from first horizontal (false) to last horizontal, and shift }
set edge_sequence (Partition lambda) = ([bool],int):
   if =#lambda or =lambda[0] then ([],0)
   else
      let d = lambda.transpose[0] { offset, index of edge above main diagonal }
      , edge_val=is_member_sorted(for part@i in lambda do part-i-1 ~od)
      in (for i:lambda[0]+d from -d do edge_val(i) od, d)
   fi

set cycle_type_order = lcm@[int]
set cycle_centralizer_order ([int] cycles) = int:
  product(cycles)*product(for m in cycles.frequencies do m.fac od)
set cycle_class_size ([int] cycles) = int:
  cycles.sum.fac \ cycle_centralizer_order(cycles)

{ compute cycle type of power of a permutation, given its cycle type }
set cycle_power ([int] cycles, int k) = [int]:
   for l in cycles
   do let d=gcd(l,k) then q=l\d in for :d do q od { splitting of one cycle }
   od.##.sort_to_partition

{ character of irreducible Sn representation lambda at give cycle type }
set Murnaghan_Nakayama (Partition lambda, [int] cycle_type) = int:
   assert(sum(lambda)=sum(cycle_type),"Size mismatch");
   let (edge,) = edge_sequence(lambda), alpha=cycle_type.sort { increasing } in
   (#alpha-1).
   (rec_fun MN (int j) int:
    if j.< then 1 { the unique character value for the trivial group S0 }
    else
       let k=alpha[j] { size of cycle in cycle type, and hence of rim hooks } in
       if k=1 { this case will be handled separately for efficiency }
       else { traverse candidate positions for removal of a |k| rim hook: }
	  for i in list(#edge-k,(int i)bool: not edge[i] and edge[i+k])
	  do edge[i+k]:=false; edge[i]:=true { remove our chosen |k| rim hook }
	  ; minus_1^count(edge[i+1:i+k])*MN(j-1) { recursive value, hook sign }
	  next edge[i]:=false; edge[i+k]:=true { restore: add rim hook back }
	  od
	 .sum { add up value from all candidate positions }
       then { |k=1| case, used the hook length formula for remaining partition }
          let hl=edge.hook_lengths in hl.#.fac\hl.product
       fi
    fi
   )



{ generating all partitions; for counting, see |n_partitions| in lazy_lists.at }

set partitions = (int n) [Partition]:
  if n.< then []
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m then [ [[]] ] { empty partition of 0 } else [] { nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do let rem = m-k { amount remaining after using one part |k| of |m| } in
        { traverse all partitions of |rem| with parts at most |min(k,rem)|: }
	for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

{ generating partitions, all of whose parts must lie in a given set }

set part_restricted_partitions ((int->bool)pred) =
  (int n) [Partition]:
  if n.< then []
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m then [ [[]] ] { empty partition of 0 } else [] { nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do
        if pred(k) then
          let rem = m-k { amount remaining after using one part |k| of |m| } in
    	  { traverse all partitions of |rem| with parts at most |min(k,rem)|: }
	  for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
	else [] { leave empty list at position |k| which fails |pred| }
	fi
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

set odd_part_partitions = part_restricted_partitions(is_odd@int)

{ partitions with distinct parts: all multiplicities are 0 or 1 }
set strict_partitions = (int n) [Partition]:
  if n.< then []
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m then [ [[]] ] { empty partition of 0 } else [] { nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m-1) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do { traverse all partitions |m-k| with parts at most |min(k,m-k)|: }
        let rem = m-k in
        for lambda in ##table[rem][:min(k-1,rem)+1] do k#lambda od
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi


{		Jordan types of nilpotent elements (or orbits)		}

{ test if partition is valid (nilpotent orbit) JOrdan type in type ABCD }
set is_valid (string type,Partition P) = bool:
{ avoid constructing |Lie_type(type[0]+n|, to avoid choking on "B1" and such }
  P:=P.strip_to_partition; { avoid frequencies of 0 }
  case ascii(type)-ascii("A")
  in { type A } true
  , { type B } sum(P).is_odd and
    all(for mult in P.frequencies.even_places do mult.is_even od)
  , { type C } sum(P).is_even and
    all(for mult in P.frequencies.odd_places do mult.is_even od)
  , { type D } sum(P).is_even and
    all(for mult in P.frequencies.even_places do mult.is_even od)
  else false { exceptional types are not valid }
  esac

set is_valid (LieType t) = (Partition->bool):
   let codes = simple_factors(t)
   then (letter,r)= assert(#codes=1,"Non-simple Lie type"); codes[0]
   then n =
      case ascii(letter)-ascii("A") in r+1, r+r+1, r+r, r+r
      else error("Exceptional ",t)
      esac
in (Partition P) bool: #P = n and is_valid(letter,P)

{ partitions with even multiplicity of parts of one parity (odd or even) }
set parity_restricted_partitions (bool restrict_odd_parts) = (int->[Partition]):
  let is_multiplicity_restricted = (int->bool):
    if restrict_odd_parts then is_odd@int else is_even@int fi   in
  (int n) [Partition]:
  if n.< or restrict_odd_parts and n.is_odd then [] { impossible, so nothing }
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m then [ [[]] ] { empty partition of 0 } else [] { nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do { traverse all partitions |m-k| with parts at most |min(k,m-k)|: }
        if k.is_multiplicity_restricted
        then { restrict use of k to using it twice, |lambda| may also have |k| }
	  let rem=m-k-k in
          if rem.< then []  { if a negative remainder, then no solutions here }
          else for lambda in ##table[rem][:min(k,rem)+1] do [k,k]##lambda od
          fi
	else { we use |k| once, |lambda| could have part(s) equal to |k| too }
	  let rem = m-k in
          for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
        fi
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

{	Combinatorics specifically for (Weyl groups of) types B,C,D	}

{ for conjugagy classes: cycles with product of signs, for simple types B,C,D }
set_type Signed_cycles = [int,bool] { bool |b| encodes product |minus_1^#b| }

{ for $W(C_n)$ irreducible representations: partition pairs of total size $n$ }
set_type BiPartition = (Partition,Partition)
{ no specific interpretation imposed here, but ordering should always have:
  positive/even/0/false/trivial repn BEFORE negative/odd/1/true/sign repn one
  parametrises irreps of the hyperoctahedral group $W(C_n)=W(B_n)$
  also in bijection with |Signed_cycles| as (unflipped lengths,flipped lengths)
}

{ Sometimes (Springer correspondence) a transformation of |BiPartition| is used
  The type to represent them is delibetately distinct from |BiPartition| }
set_type Symbol = [[int]]  { must have 2 lists, first longer than second by 1 }
{ both lists strictly INcreasing with non-negative entries
  equivalence [a_1,...a_k]->[0,a_1+1,s_2+1,...a_k+1] can be used to adapt length
  every symbol can be written with length difference 1 and at most one term 0
}


set rank (Signed_cycles cycles) = int: for (c,) in cycles do c od.sum
set rank (BiPartition(lambda,mu)) = int: lambda.sum+mu.sum

{ equality is strict (don't want to force interpretation onto |[int,bool|]) }
set = (Signed_cycles cyc0,Signed_cycles cyc1) = bool:
   #cyc0=#cyc1 and
   ( for (n,b)@i in cyc0
     do let(m,c)=cyc1[i] in if n!=m or b!=c then return false fi
     od
   ; true
   )
set != (Signed_cycles cyc0,Signed_cycles cyc1) = bool: not(cyc0=cyc1)

{ for equivalence up to permutation of cycles, use |c0.same_as(c1)| }
set same_as (Signed_cycles cyc) = (Signed_cycles->bool):
   let freq_pos = for (n,b) in cyc do if b then [] else [n] fi od.##.frequencies
   ,   freq_neg = for (n,b) in cyc do if b then [n] else [] fi od.##.frequencies
in (Signed_cycles c) bool:
   freq_pos = for (n,b) in c do if b then [] else [n] fi od.##.frequencies and
   freq_neg = for (n,b) in c do if b then [n] else [] fi od.##.frequencies

{ The hyperoctahedral group $H_n$ can be represented by sigend permutation
  matrices (where every row and column has a unique nonzero entry, which lies in
  $\{-1,1\}$. There is a surjective group morphism to $S_n$ forgetting the signs.

  This is the symmetry group of en $n$-dimensional hyperoctahedron (also of the
  hypercube), centered at the origin, with 2 vertices on each coordinate axis.

  Conjugacy classes of $H_n$ are given by signed cycle types: projection to
  $S_n$ gives a cycle type (for the permutation of the axes), and to each cycle
  is attached the product of the signs for the coordinate axes in the cycle.
}

{ converting partition pairs to signed cycle types, second has flipped cycles }
set to_cycles (BiPartition(lambda,mu)) = Signed_cycles:
  for part in lambda do (part,false) od ## for part in mu do (part,true) od

{ the inverse of |to_cycles@BiPartition| }
set to_partition_pair(Signed_cycles cy) = BiPartition:
( for (part,b) in cy do if b then 0 else part fi od.sort_to_partition
, for (part,b) in cy do if b then part else 0 fi od.sort_to_partition
)


{ generate pairs of partitions of total size |n| with size |k| components
  produced in the order in which |lister| lists them, starting all on left }
set pairs_of_total_sum (int n,(int->[Partition]) lister) = [BiPartition]:
  let list = for i:n+1 do lister(i) od in
  for parts_i@i in list ~ { reversal means taking larger partitions first }
  do for lambda in parts_i do for mu in list[n-i] do (lambda,mu) od od.##
  od.##

{ generate all bi-partitions of |n| by size distribution, starting all left }
set partition_pairs (int n) = [BiPartition]:
  pairs_of_total_sum(n,partitions@int)

set = (BiPartition (P,Q), BiPartition (R,S)) = bool: P=R and Q=S

{ compare |BiPartition| values of same sum, in ordering of |partition_pairs| }
set <=(BiPartition (P,Q), BiPartition (R,S)) = bool:
   case P.sum-R.sum
   then false else true { size balance is decisive, inverted ordering! }
   in { equal size case: compare left partitions, or right if ex aequo }
      if P=R else (P,R) then (Q,S) fi.leq_equal_sum_partitions
   esac

{ look up pair in sorted list of partition pairs, all assumed of same sum }
set index_bipartition ([BiPartition] sorted_list) = (BiPartition->int):
   (BiPartition PQ) int:
      binary_search_first( (int i)bool: PQ<=sorted_list[i], 0, #sorted_list )

{ counterpart of the Murnaghan-Nakayama rule for hyperocthedral groups }

{ Characters of the hyperoctahedral group $H_n$ are parametrised as follows by
  bi-partitions |(lambda,mu)| of $n$. Call "axis-sign" the 1-dimensional
  representation of any hyperoctahedral group that takes value $+1$ on all
  simple reflection except the last (for the off-length simple root) where it
  takes the value $-1$: on a general signed permutation it is the product of the
  nonzero entries in its matrix (it is also the product of the cycle-signs in
  its signed cycle type).

  Given a bi-partition |(lambda,mu)|, let |l=sum(lambda),m=sum(mu)|, let $K$ be
  the $H_l\times H_m$ subgroup of $H_n$, restrict (back up the surjective group
  morphisms $H_i\to S_i$) the irreducible representations for |lambda| and |mu|
  of $S_l$ respectively $S_m$ to ones of $H_l$ respectively $H_m$, tensor the
  latter with the axis-sign representation of $H_m$, then induce the resulting
  (outer tensor product) representation of $K=H_l\times H_l$ from $K$ to $H_n$.
}

set hyperoctahedral_character (
       BiPartition (lambda,mu):pair { irreducible repn, sign applies to |mu| }
      ,Signed_cycles signed_cycle_type { describes a conjugacy class }
      ) = int:
   assert(rank(pair)=rank(signed_cycle_type),"Size mismatch");
{ The formula implemented is recursive in the number of cycles, similarly to the
  Murnaghan-Nakayama rule. Pick a signed cycle |(k,sign)| (we start with picking
  longest ones, so as to have all length 1 cycles remaining at the bottom of the
  recursion) and find all the hooks in |mu| or |lambda| of length |k|; for each
  match remove the (rim) hook, recursively compute the character value of the
  remaining |BiPartition| at the class obtained by removing the signed cycle,
  multiply it by the sign $(-1)^h$ of the hook (where $h$ is the number of
  vertical adjacencies in the hook), and in case the hook was removed from |mu|
  by |sign| as well; the character value is the sum all the values so obtained.
}
   let alpha = signed_cycle_type. { preprocess putting longs cycles at end }
               (sort_by((int l,bool.)int: l))
   then (c,d) = (int,int): { numbers of 1-cycles with - resp. + in |alpha| }
     for (l,sign) in alpha do if l>1 then break else s^#sign{use |Split|} fi
     od.sum.% { sum powers of |s|, then extract its two components }
   , (edge0,)=edge_sequence(lambda), (edge1,)=edge_sequence(mu)
   in (#alpha-1).
   (rec_fun f (int j) int:
    if j.< then 1 { termination case: value for the trivial group S0 }
    else let (k,sign)=alpha[j] { size of cycle type, and hence of rim hook } in
       if k=1 { only 1-cycles left; will be handled separately for efficiency }
       else { traverse candidate positions for removal of a |k| rim hook: }
       (  for i in list(#edge0-k,(int i)bool: not edge0[i] and edge0[i+k])
	  do edge0[i+k]:=false; edge0[i]:=true { remove chosen |k| rim hook }
	  ; f(j-1)*minus_1^count(edge0[i+1:i+k]) { recursive value, hook sign }
	  next edge0[i]:=false; edge0[i+k]:=true { restore: add rim hook back }
	  od
	 .sum { add up value from all candidate positions }
       ,  for i in list(#edge1-k,(int i)bool: not edge1[i] and edge1[i+k])
	  do edge1[i+k]:=false; edge1[i]:=true { remove chosen |k| rim hook }
	  ; f(j-1)*minus_1^count(edge1[i+1:i+k]) { recursive value, hook sign }
	  next edge1[i]:=false; edge1[i+k]:=true { restore: add rim hook back }
	  od
	 .sum { add up value from all candidate positions }
       )
       . if sign else +@(int,int) then -@(int,int) fi { add or subtract sums }
       then { |k=1| case: use the hook length formula for remaining partition.
              Sum over maps from of the 1-cycles to $\{1,-1\}$ such that |a| of
	      them map to $1$ and |b| to $-1$, where $(a,b)$ are the sizes of
	      the remaining partitions $(lambda',\mu')$; for each map multiply
	      the product of the hook length formulas for $\lambda'$ and $\mu'$
	      by $(-1)^l$ where $l$ counts the negative cycles mapping to $-1$.
	      Grouping similar cases, the summation reduces to one over 2x2
	      matrices with entries in $\N$ and row sums a$,$b and column sums
	      c$,$d, with $l$ being its bottom-right entry. }
          let hl0=edge0.hook_lengths, hl1=edge1.hook_lengths
          then { get fixed row sums and column sums for $\N$-matrix [.,.|.,l] }
            (a,b) = (#hl0,#hl1) { partition sizes to be filled }
          then lwb = max(0,d-a{=b-c}), upb=min(b,d) { bounds for l }
          in assert(a+b=c+d);
          for l:upb-lwb+1 from lwb do minus_1^l*binom(c,b-l)*binom(d,l)od.sum
          * (a.fac\hl0.product)*(b.fac\hl1.product) { factor independent of l }
       fi
    fi
   )


{
  Core and quotient operations can be defined in terms of associating to any
  partition $\lambda$ the subset $\{ lambda[i]-i-1 | i\in\N \}$ of $\Z$. This
  set represents the set of vertical edges terminating the rows of the Young
  diagram, recorded by their diagonal positions (the main diagonal separating
  positions in $\N$ from its complement, i.e., its splits between -1 and 0).

  This set is bounded above while its complement is bounded below; more
  specifically the set meets $\N$, and its complement the complement of $\N$, in
  equal size finite sets. An ordered pair of partitions can be "spliced
  together" as follows: take there associated sets, transform the former by
  $i\mapsto 2i$ and the latter by $i\mapsto 2i+1$, merge the results and find
  the partition corresponding to the set. If the Young diagrams original
  partitions together have $n$, the spliced partition can be covered by $n$
  dominos. More generally we could add a fixed integer $d$ in the first
  transformation and subtract it in the second; then $d$ will be the unbalance
  of black and white squares in the diagram of the resulting partition, and
  after removing $n$ dominos from it we are left with a "2-core" still having
  the same unbalance. It is a staircase diagram with |core_length(d)| parts.
  The pair of original partitions is the "2-quotient" of the spliced partition.
}

set core_length (int n) = int: if n.<= then 2*-n else 2*n-1 fi
set core_number (int k) = int: assert(k.>=); case k in -k\2, -k\-2 esac

{ Core number and quotient partition pair. In the latter, as per |BiPartition|
  convention, the partition coming from the EVEN edge positions comes first }
set core_quotient_2 (Partition lambda) = (int,BiPartition):
   let d = int: { black/white unbalance of diagram }
      for l@i in lambda do case l in 0, minus_1^i esac od.sum
   ,  positions = [int]: for l@i in lambda do l-i-1 od
   then e = for p in positions do case p in [p\2-d],[] esac od.##
   ,    o = for p in positions do case p in [],[p\2+d] esac od.##
   then  ep = for x@i in e do x+i+1 od, op = for x@i in o do x+i+1 od
   in (d,(ep.strip_to_partition,op.strip_to_partition))

{ Splicing BiPartitions |(lambda,mu)|, with 2-core with (unbalance) number |d| }
set from_core_quotient_2 (int d,BiPartition(lambda,mu)) = Partition:
{ Implementation is delicate, as we must represent infinite sets finitely.

  Initially take just one number for each (nonzero) part of each partition, and
  record the first numbers |k|, |l| that are omitted in this representation.
  Also reverse the order to increasing, since this is what |merge@([int,[int])|
  defined in sort.at assumes. Before merging, we need to "even out" the
  (negative) heads of the lists by adding omitted terms to one of them, those
  whose absence would produce gaps in the merged result. The first such term to
  be added (if any) is 3 more than the first omitted term in the other list.
}
(  let evens = for l@i in lambda do 2*(l-i-1+d) ~od { space out and reverse }
   ,   odds = for m@i in mu do 2*(m-i-1-d)+1 ~od { likewise }
   ,   k = 2*(-#lambda-1+d), l = 2*(-#mu-1-d)+1 { last omitted values before }
in if k>l
   then evens := for i:(k-l)\2 from l\2+2 do i+i od ## evens
   else odds := for i:(l-k)\2 from k\2+1 do i+i+1 od ## odds
   fi
;  for v@i in merge(evens,odds)~[:] do v+i+1 od.strip_to_partition
)

{ Find classical (permutation or signed permutation) description of Weyl group
  elements in classical types. The associated root datum must have one simple
  factor of type A-D, but need not have standard (Bourbaki) diagram numbering.

  The output is a (signed) permutation in one-line format. For type $A_n$ this
  is just a permutation of $n+1$ (hence 0-based), for types $B_n$, $C_n$, $D_n$
  this is a permutation of the $2n$ elements $-n, ,..., -2 -1, 1, 2, ..., n$,
  commuting with $x \mapsto -x$, and the one-line format consists of a list of
  the images of $1, 2, ..., n$ (1-based); it determines the signed permutation.
}
set classic_permutation (WeylElt w) = [int]:
(  let rd=w.root_datum then (lt,map)=Cartan_matrix_type(rd.Cartan_matrix)
   then factors=simple_factors(lt) then nf=#factors
in assert(nf=1,"Root datum diagram is not connected ("+ nf +" components)")
;  let word = { |w.word| translated to word for Bourbaki numbered diagram }
      let inv = permutation_inverse(map) in for s in w.word do inv[s] od
   , (type,rank)=factors[0]
in case char_index(type,"ABCD")
   in let n=rank+1 in (vec:#n)*W_elt(GL(n),word) { right act on [0,1,...,n-1] }
   , (vec:for i:rank from 1 do i od)*W_elt(Sp(rank+rank),word) { B is same as C }
   , (vec:for i:rank from 1 do i od)*W_elt(Sp(rank+rank),word)
   , (vec:for i:rank from 1 do i od)*W_elt(SO(rank+rank),word)
   else error("Root datum of exceptional type "+type)
   esac
)

{ a simpler version when |w| is known to be for some Sp(2n) or SO(m) }
set signed_permutation(WeylElt w) = [int]:
   (vec:for i:w.root_datum.rank from 1 do i od)*w

{ for a signed permutation |sigma| of $\{1,...,n\}$, represented by the images
  of $1,...,n$, compute the cycle type as list of pairs (cycle length, sign);
  return weakly decreasing vector of sign*cycle_length, e.g., |[4,2,-1,-1,-3]|
}
set signed_cycle_type_code ([int] sigma) = vec:
  let cycles = for a in sigma do abs(a)-1 od.permutation_cycles
  then lengths = { lengths of cycles, negated when there is a flip }
    for cyc in cycles do sign(for i in cyc do <sigma[i] od.XOR) * #cyc od
  in reverse_sort(lengths)
set cycle_code(WeylElt w) = vec: { assuming |w| is for |Sp(2n)| or |SO(m)| }
  signed_cycle_type_code(signed_permutation(w))

{ convert code as above to |Signed_cycles|, ordering as |to_cycles| does }
set as_signed_cycles (vec v) = Signed_cycles:
  let pos_part = for cyc in v do if cyc.> then [(cyc,false)] else [] fi od.##
  , neg_part = for cyc in v ~ do if cyc.< then [(-cyc,true)] else [] fi od.##
  in pos_part ## neg_part
set as_bipartition (vec v) = BiPartition:
  ( for l in v  do if l.> then [l]  else [] fi od.##
  , for l in v ~do if l.< then [-l] else [] fi od.##
  )
set signed_cycle_type ([int] sigma) = Signed_cycles:
  signed_cycle_type_code(sigma).as_signed_cycles

set cycle_type_order (Signed_cycles cycles) = int:
  for (cycle,sign) in cycles do if sign else cycle then cycle+cycle fi od.lcm
set cycle_centralizer_order (Signed_cycles cycles) = int:
  let plus_cycles = for (c,s) in cycles do if s then [] else [c] fi od.##
  ,  minus_cycles = for (c,s) in cycles do if s then [c] else [] fi od.##
  in product(for (cycle,) in cycles do cycle+cycle od)*
     product(for m in plus_cycles.frequencies do m.fac od)*
     product(for m in minus_cycles.frequencies do m.fac od)
set cycle_class_size (Signed_cycles cycles) = int:
  let n=rank(cycles) in n.fac * 2^n \ cycle_centralizer_order(cycles)

{ compute cycle type of power of a signed permutation, given its cycle type }
set cycle_power (Signed_cycles cycles, int k) = Signed_cycles:
   let m = for (c,) in cycles do c od.(max(0))
   then n_cycles = { multiplicities by cycle length and sign }
     mat: null(m,2) { row index offset by 1, minus_1^(column index) is sign }
in for (l,sign) in cycles
   do let d=gcd(l,k) in n_cycles[l\d-1,#sign*(k\d)%2] +:= d
   od;
 ##for b:2 ~ { true (negative) before false (positive) }
   do let kind = b.is_odd in
    ##for l:m from 1 ~do for :n_cycles[l-1,b] do (l,kind) od od
   od

{ a |Symbol| is a transformed |BiPartition|: reversed, strict, length diff. 1 }

{ normalize symbol: |f|=|g|+1 and at most 1 zero }
set normalize (Symbol S) = Symbol:
   let normalize ([int] v) = [int]: { shrink |v| until it starts nonzero }
      let nv=#v, i=0
      in while i<nv and v[i]<=i do i+:=1 od ;  for e in v[i:] do e-i od
  , expand([int] v, int r) = [int]: #r ## for c in v do c+r od
  then f=S[0].normalize, g=S[1].normalize then d=#f-(#g+1) in
  case d in [f,g] then [expand(f,-d),g] else [f,expand(g,d)] esac
{ all other functions taking |Symbol| assume that argument is normalized }

set symbol (BiPartition(lambda,mu)) = Symbol: { normalized }
(  let d =
     #(lambda:=strip_to_partition(lambda)) - (#(mu:=strip_to_partition(mu))+1)
in case d { make |d=0| by zero-extending one of the partitions if necessary }
   then { #lambda<#mu+1 } lambda ##:= for : -d do 0 od
   in { #lambda=#mu+1 }     ()
   else { #lambda>#mu+1 } mu     ##:= for : d do 0 od
   esac
;  [ for i:#lambda do lambda~[i]+i od, for j:#mu do mu~[j]+j od ]
)

set symbol_to_bipartition (Symbol S) = BiPartition:
( for f_i@i in S[0] do f_i-i ~od.strip_to_partition
, for g_i@i in S[1] do g_i-i ~od.strip_to_partition
)

set is_special (Symbol S) = bool:
   let S0=S[0],S1=S[1] in all(#S1,(int i)bool: S0[i]<=S1[i] and S1[i]<=S0[i+1])

set make_special (Symbol S) = Symbol:
   let S0=S[0],S1=S[1] then l=#S1 in { sort, using known increase in each list }
(  for i:l
   do let e=S0[i], j=i in while e>S1[j] do if (j+:=1)=l then break fi od
   ;  if j>i
      then S0[i]:=S1[i]; for k:j-1-i from i do S1[k]:=S1[k+1] od; S1[j-1]:=e
      fi
   ;  if (e:=S1[i],j:=i+1); while e>S0[j] do if (j+:=1)=l+1 then break fi od
      ; j>i+1
      then S1[i]:=S0[i+1]; for k:j-i-2 from i+1 do S0[k]:=S0[k+1] od; S0[j-1]:=e
      fi
   od
;  [S0,S1]
)

set make_special (BiPartition bip) = BiPartition:
   bip.symbol.make_special.symbol_to_bipartition


{ adaptation to the above to deal with Weyl groups of type Dn }

{ a condition relevant to which cycle types give split classes in $W(D_n)$ }
set is_very_even (Partition P) = bool: =P%2 { whether all parts are even }

{ a condition relevant to which $D_n$ nilpotent orbits are split from $O(2n)$ }
set is_doubly_even (Partition P) = bool: { even parts even multiplicities only }
  let freq = frequencies(P) in =freq.odd_places and =freq.even_places%2

set_type
[ D_class = { cycle types restricted to Dn subgroup }
   ( Signed_cycles unsplit_class { the XOR of all |bool| values is |false| }
   | (Partition,bool) split_class { "all false" even cycles, and a single sign }
   )
, D_irrep = { from folding pairs of partitions under swapping }
   ( (Partition,Partition) unsplit_irr { unequal partitions, larger first }
   | (Partition,bool) split_irr { for pair of equal partitions, with sign }
   )
]

{ recover the value of |n| }
set rank (D_class c) = int:
   case c
   | cycles.unsplit_class: cycles.rank { rank@Signed_cycles; combinatorics.at }
   | (lambda,).split_class: lambda.sum { |lambda| has all cycles (even,false) }
   esac

set rank (D_irrep chi) = int:
   case chi
   | pair.unsplit_irr: pair.rank { rank@(Partition,Partition); combinatorics.at }
   | (lambda,).split_irr: 2*lambda.sum { |lambda| stands for (lambda,lambda) }
   esac

set cycle_type_order (D_class c) = int:
   case c
   | cycles.unsplit_class: cycles.cycle_type_order { as in types B, C }
   | (lambda,).split_class: lambda.cycle_type_order { as in type A }
   esac
set centralizer_order (D_class c) = int:
   case c
   | cycles.unsplit_class: { unsplit means half of BC centralizer is not in Dn }
       cycles.cycle_centralizer_order\2
   | (alpha,).split_class: { split means full BC centralizer is in Dn subgroup }
       { simulate |cycle_centralizer_order@Signed_cycles|, using ..@Partition }
       alpha.cycle_centralizer_order*2^#alpha { add a factor 2 for each cycle }
   esac
set class_size (D_class c) = int:
  let n=rank(c) in n.fac * 2^(n-1) \ centralizer_order(c)

set class_size (D_class c) = int:
  let n=rank(c) in n.fac * 2^(n-1) \ centralizer_order(c)

{ compute cycle type of power of a signed permutation, given its cycle type }
set cycle_power (D_class c, int k) = D_class:
   case c
   | cycles.unsplit_class: cycle_power(cycles,k).unsplit_class
   | (alpha,sign).split_class: let beta=cycle_power(alpha,k) in
     if beta.is_very_even { whether class remains split (may fail for even |k|) }
     then (beta,sign).split_class { keep sign when class remains split }
     { an easy way to see that this is right: certainly when |sign=false|, the
       power gets no sign, but since an outer automorphisme interchanges the
       halves of every split class, |sign=true| should give the opposite half }
     else for part in beta do (part,false) od.unsplit_class
     fi
   esac

{ rather than |signed_cycle_type_code|, $D_n$ classes need a finer analysis }
set to_D_class ([int] sigma) { as from |classic_permutation } = D_class:
   let cycles = for a in sigma do abs(a)-1 od.permutation_cycles
   then cycle_signs = for cyc in cycles do for i in cyc do <sigma[i] od.XOR od
   then type_code =
       for cyc@i in cycles do #cyc*sign(cycle_signs[i]) od.reverse_sort
   , neg_count = count(cycle_signs) { number of cycles with odd flip count }
in if neg_count.is_odd then error("Permutation is not in type D subgroup")
   elif not(neg_count.= and type_code.is_very_even)
   then type_code.as_signed_cycles.unsplit_class
   else { we have a split cycle, count parities of flip positions for sign }
      let parity =
	 for cyc in cycles
	 do for i@pos in cyc do <sigma[i] and pos.is_odd od.XOR
	 od.XOR
   in (type_code,parity).split_class
   fi

set same_as (D_class c0) = (D_class->bool):
   case c0
   | cyc0.unsplit_class:
     let test=same_as(cyc0) in
     (D_class c1) bool:
        case c1 | cyc1.unsplit_class: test(cyc1) | else false esac
   | (lambda,eps0).split_class:
     let freq=lambda.frequencies in
     (D_class c1) bool:
        case c1 | (mu,eps1).split_class: freq=mu.frequencies and eps0=eps1
        | else false
        esac
   esac

set = (D_class c0, D_class c1) = bool: c0.same_as(c1)
set != (D_class c0,D_class c1) = bool: not c0.same_as(c1)

set D_classes (int n) = [D_class]:
   for (lambda,mu):pair in partition_pairs(n)
   do if (#mu).is_odd then [] { must have even number of cycles in |mu| }
      elif not(=mu and lambda.is_very_even) { whether unsplit }
      then [pair.to_cycles.unsplit_class]
      else [ (lambda,false).split_class, (lambda,true).split_class ]
      fi
   od.##

{ predicate of coming before a given element in the ordering of |D_classes| }
set less_eq (D_class elt) = (D_class->bool):
   case elt
   | cycles.unsplit_class:
     let pair = cycles.to_partition_pair in
     (D_class C) bool:
	case C
	| cycles_C.unsplit_class: cycles_C.to_partition_pair<=pair
	| (lambda,).split_class: (lambda,lambda)<=pair
	esac
   | (nu,b1).split_class:
     (D_class C) bool:
	case C
	| cycles_C.unsplit_class:
	  cycles_C.to_partition_pair<=(nu,nu)
	| (lambda,b0).split_class:
	  case cmp_equal_sum_partitions(lambda,nu)
	  then true
	  in not b0 or b1 { same as |#b0<=#b1|; or |b0| implies |b1| }
	  else false
	  esac
	esac
   esac


set <= (D_class a,D_class b) = bool: a.(less_eq(b)) { i.e., |less_eq(b)(a)| }

{ look up pair in sorted list of |D_class|es, all assumed for the same size }
set index_D_classes ([D_class] sorted_list) = (D_class->int):
   let predicate = [(D_class->bool)]: for elt in sorted_list do less_eq(elt) od
in (D_class C) int:
      binary_search_first( (int i)bool: predicate[i](C), 0, #sorted_list )

set same_as (D_irrep chi) = (D_irrep->bool):
   case chi
   | (p0a,p0b):pair0.unsplit_irr: let swapped=(p0b,p0a) in
     (D_irrep xi) bool:
     case xi | pair1.unsplit_irr: pair0=pair1 or swapped=pair1 | else false esac
   | (lambda,b0).split_irr:
     (D_irrep psi) bool:
     case psi | (mu,b1).split_irr: lambda=mu and b0=b1 | else false esac
   esac

set = (D_irrep c0, D_irrep c1) = bool: c0.same_as(c1)
set != (D_irrep c0,D_irrep c1) = bool: not c0.same_as(c1)

set make_special (D_irrep chi) = D_irrep:
   case chi
   | (,).split_irr: chi
   | (lambda,mu).unsplit_irr:
           (let d=#lambda-#mu-1 in { make |lambda| one longer than |mu| }
	    case d then lambda ##:= null(-d) in () else mu ##:= null(d) esac
	   )
	 ;  let spec = make_special
	       (Symbol:[ for e@i in lambda do e-i ~od
	               , for e@i in mu     do e-i ~od
		       ] )
	 { now in particular |spec[1][i]<=spec[0][i+1]| for all |i<#mu|, so
	   the first partition below has strictly larger sum than the second:
	   the only alternative would be both partitions being equal, but that
	   cannot happen because |lambda| and |mu| differ, as one easily shows }
	 in ( for i:#lambda do spec[0]~[i]+i od.strip_to_partition
	    , for i:#mu do spec[1]~[i]+i od.strip_to_partition
	    ).unsplit_irr
   esac

set character (D_irrep chi, D_class c) = int:
   assert(chi.rank = c.rank,"Size mismatch");
   let pos_cycles(Partition mu)=Signed_cycles: for l in mu do (l,false) od in
   case chi
   | pair.unsplit_irr:
     case c
     | cycles.unsplit_class: hyperoctahedral_character(pair,cycles)
     | (alpha,).split_class: { both halves behave as their BC class }
        hyperoctahedral_character(pair,pos_cycles(alpha))
     esac
   | (lambda,epsilon).split_irr:
     case c
     | cycles.unsplit_class:
       let (q,r) = hyperoctahedral_character((lambda,lambda),cycles)\%2 in
       assert(=r,"Odd character value at unsplit class"); q
     | (alpha,delta).split_class:
       let Hn_char = int:
           hyperoctahedral_character((lambda,lambda),pos_cycles(alpha))
       ,   Sn_char = int:
           assert(alpha.is_very_even,"Split class with odd cycle(s)");
           Murnaghan_Nakayama(lambda, alpha\2)
       then (q,r) = (Hn_char+sign(epsilon!=delta)*2^#alpha*Sn_char)\%2
       in assert(=r,"Parity problem for split-split character value"); q
     esac
   esac


{ for printing |BiPartition| values compactly }
set compressed_string(BiPartition(P,Q)) = string:
(  let mult=1
   then result =
      for l@i in P
      do if i=0 then "[ "
	 elif l=P[i-1] then mult+:=1; ""
	 elif mult=1 then P[i-1]+", "
	 else P[i-1]+"^"+mult+", " next mult:=1
	 fi
      od.##
in result ##:=
      if mult=1 then P~[0].to_string else P~[0]+"^"+mult next mult:=1 fi
;  result ##:=
      for l@i in Q
      do if i=0 then " L|S "
	 elif l=Q[i-1] then mult+:=1; ""
	 elif mult=1 then Q[i-1]+", "
	 else Q[i-1]+"^"+mult+", " next mult:=1
	 fi
      od.##
;  result ## if mult=1 then Q~[0].to_string else Q~[0]+"^"+mult fi ## " ]"
)
