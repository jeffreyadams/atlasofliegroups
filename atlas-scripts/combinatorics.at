{ The purpose of this module is to collect basic combinatorial functions,
  like factorials, binomial coefficients, generators of partitions and so on
}

<basic.at
<sort.at
<groups.at { for root data computed by |GL|, |Sp|, |SO| }

{ |fac@int| is now defined in basic.at }

set binom (int n, int k) = int:
   if n.>= and k+k>n then k:=n-k fi; { use symmetry to limit |k| }
   case k then 0 in 1, n
   else let p=n*(n-1) in for i:k-2 from 2 do p:=p\i*(n-i) od; p\k
   esac

set binom (rat n, int k) = rat:
   if n.denom=1 and n.>= and k+k>n then k:=n.numer-k fi; { try for efficiency }
   case k then 0 in 1, n
   else let p=n*(n-1) in for i:k-2 from 2 do p:=p/i*(n-i) od; p/k
   esac

set multinom ([int] a) = int: { multinomial coefficient, upper index implicit }
   let upper = cumulate_backward(a) in
   for m@i in a do binom(upper[i],m) od.product

set multi_choose (int n,int k) = int: binom(n+k-1,k)

set falling_power (int n, int k) = int: assert(@:k>=0,"Negative exponent");
   let p=1 in for i:k from n-k+1 do p*:=i od; p

set rising_power (int n, int k) = int: assert(@:k>=0,"Negative exponent");
   let p=1 in for i:k from n do p*:=i od; p

{ Combinatorial number system ${\N\choose k}\to\N$ encoding and decoding }

{ represent a permutation as a single number: its lexicographic position }
set permutation_encode([int] sigma) = int:
   let n=#sigma then unseen=#n, acc=0
in for x in sigma
   do let l=#unseen
      then pos = binary_search_first((int i): unseen[i]>=x,0,l)
   in assert(@:unseen[pos]=x)
   ; unseen:=unseen[:pos]##unseen[pos+1:]
   ; acc:=l*acc+pos
   od; acc

set permutation_decode(int code, int n) = [int]:
(   let result=null(n), unseen=#n
in  (code,1).
    (rec_fun f (int rem, int i) void:
       let (q,r)=rem\%i in
       if i<n then f(q,i+1) fi
    ;  result~[i-1] := unseen[r]
    ;  unseen := unseen[:r]##unseen[r+1:]
    )
;   result
)

{ The following generates partitions starting froim #n, without large storage
  Example (this is subtle: body does |next| to yield old before preparing new):

    let pi=vec:#4, go=true in
    while go
    do pi
    next case next_permutation(pi) | none: go:=false | some(sig): pi:=sig esac
    od

  This can be applied even if some entries of |sigma| are the same (a multiset
  permutation), in which case the lexicographically next permutation is found.
}
set permutation_iterator (int n) = Iterator<vec>:
   let pi = vec: #n, go=true
in ( @Maybe<vec>: if go then some(pi) else none() fi
   , @void:
      let i = last(n-1,(int i)bool: pi[i]<pi[i+1]) in
      if i<0 then go:=false
      else let x=pi[i], j=0
      in while pi~[j]<=x do j+:=1 od { search least element >x after it}
      ;  pi[i] := pi~[j]; pi~[j] := x { swap to increase |perm[i]| }
      ;  pi := pi[:i+1] ## pi~[:i+1~] { reverse tail after |pi[i]| }
      fi
   )

any_type T begin
set permutations([T] xs) = [[T]]: { permutations of entries, ignore equalities }
   let n  = #xs
in for i:fac(n) do for e in permutation_decode(i,n) do xs[e] od od
end

{ Represent any $k$-combination on $\N$ as a single natural number
  For fixed $k$ this is bijective, and a decoding follows.
}
set combination_encode([int] list) = int: { |list| strictly increasing }
   for c@i in list do binom(c,i+1) od.sum

set combination_decode(int k) = (int->[int]):
{ no need of case distinction for |k=0|: code below builds constant function }
   (int N) [int]:
   let bound=N+k { conservative start; we must have |binom(bound,k)>N| }
in for i:k from 1 ~ { entries are determined in decreasing order }
   do let c_i = binary_search_first((int n)bool: binom(n,i)>N, 1,bound) - 1
   in N -:= binom(c_i,i); bound:=c_i
  ~od { next assert(@:N=0) }

{ extract components at even or odd positions }
set even_places ([int] v) = for i:-(-#v)\2 do v[2*i] od
set odd_places  ([int] v) = for i:#v\2 do v[2*i+1] od


{				Permutations				}

{ Matrix whose left-multiplication to a column vector permutes it by |pi|.
  It has nonzero entries at each (pi(j),j), it could have been defined (using
  |matrix| from basic.at) as |matrix((#pi,#pi),(int i,int j): #(i=pi[j]) )|.
}
set permutation_matrix ([int] pi) = mat:
   let n=#pi then I=n.id_mat in n# for v in pi do I[v] od

set permutation (mat P) { assumed a permutation matrix} = [int]:
  (vec: #P.n_rows)*P { right-act on row [0,1,...,n-1] for one-line form }

set compose_permutations ([int] sigma, [int] pi) = [int]:
  for i in pi do sigma[i] od

set inverse ([int] pi) = [int]: { hope that name causes no conflict }
  let n=#pi then result=for :n do n od { sentinel values} in
  for i@j in pi
  do assert(@:(0<=i and i<n and result[i]=n { in range, and no seen before }
              ,to_string("not a permutation (",i,")")
	      ));
     result[i]:=j
  od; result

{ longer name for non-checking (so faster) version of the above }
set permutation_inverse ([int] pi) = [int]:
  let result=null(#pi) in for i@j in pi do result[i]:=j od; result

{ a product of many permutations, arranged as columns of a matrix }
set permutation_product (mat M) = [int]:
   for i: n_rows(M) do let x=i in for j:n_columns(M) ~do x:=M[x,j] od; x od

set cyclic_permutation (int n) = ([int]->[int]): { cycle to one-line form }
   ([int] cycle) [int]:
   let pi=#n, l=#cycle in for e@i in cycle do pi[e]:=cycle[(i+1)%l] od; pi

set cycle_product (int n) = ([[int]]->[int]): { cycles to one-line form }
   let as_column = cyclic_permutation(n) in
   ([[int]] cycles)[int]:
   permutation_product(mat: n # for c in cycles do c.as_column od)

set permute ([int] pi,vec v) = vec: { replaces |v[i]| by |v[pi.inverse[i]]| }
  assert(@:#pi=#v { and |pi| is a permutation },"length mismatch");
  let result=null(#v) in for i@j in pi do result[i]:=v[j] od; result

any_type T begin
set permute ([int] pi,[T]a) = [T]: { replaces |a[i]| by |a[pi.inverse[i]]| }
  assert(@:#pi=#a { and |pi| is a permutation },"length mismatch");
{ here we cannot pre-allocate a row of undefined T values, but have no need to }
  for i in permutation_inverse(pi) do a[i] od
end

set permutation_act([int] sigma, mat M) = mat: { permutation_matrix(sigma)*M }
   M.n_columns ^ for i in permutation_inverse(sigma) do row(M,i) od

{ M*inverse(permutation_matrix(sigma)), for a right-action of S_n }
set permutation_right_act (mat M,[int] sigma) = mat:
   M.n_rows # for j in sigma do column(M,j) od

set permutation_conjuagation([int] sigma, mat M) = mat:
   permutation_act(sigma,permutation_right_act(M,sigma))


set permutation_cycles ([int] pi) = [[int]]:
  let n=#pi then todo = full_bitset(n) in
  for start:n { try every index once as |start|, those visited give 0-cycles }
  do let ii = exp_2(start)
     then cycle =
        while bitwise_subset(ii,todo)
	do todo:=AND_NOT(todo,ii)
	;  let i=first_set_bit(ii) in ii:=exp_2(pi[i])
	;  i
	od
     in if #cycle>0 do cycle fi { suppress the 0-cycles }
  od.##

{ group root indices by orbits under action of cyclic group generated by |w| }
set root_orbits (WeylElt w) = [[int]]:
   let perm=root_permutation(w) then npr=#perm\2 { number of positive roots }
in for cycle in permutation_cycles(perm)
   do for index in cycle do index-npr od { shift back to interval [-npr,npr[ }
   od


set multiset_permutations ([int] multiplicities) = [[int]]:
   ([],multiplicities).
   (rec_fun mp ([int] prefix, vec mult) [[int]]:
    if =mult then [prefix]
    else
       for m@i in mult
	  if m>0
	  do let new_mult=mult in new_mult[i]-:=1; mp(prefix#i,new_mult)
	  fi
       od.##
    fi
   )

{				Partitions				}

set_type Partition = [int]   { list of decreasing parts, no trailing zeros }

set strip_to_partition (Partition lambda) = [int]:
  lambda[:1+last(#lambda,(int i)bool: !=lambda[i])]
{ alternatively: |for x in list do if =x then break fi od| }

set is_partition ([int] seq) = bool: backward_differences(seq).>=

set frequencies (Partition lambda) = vec: { frequency vector, position 0 unused }
  let v=null(1) in { ensure the unused position 0 is always present }
  for l in lambda
  do if l>=#v then v ##:= null(l-#v)#1 { append final 1 }
     elif l>=0 then v[l]+:=1
     else error("Negative entry present") fi
  od; v

{ the following is a right-inverse to |frequencies|; assuming |frequencies[0]=0|
  to avoid getting trialing 0's, the image is precisely the set of partitions }
set repeat_parts (vec frequencies) = Partition:
  for f@i in frequencies { reverse: } ~ if i>0 for :f do i od fi od

set sort_to_partition ([int] parts) = Partition:
  parts.frequencies.repeat_parts

set cycle_type ([int] pi) = Partition: { cycle sizes in decreasing order }
  for cycle in permutation_cycles(pi) do #cycle od.sort_to_partition

{ transpose of a composition, after implicitly sorting it to a partition }
set transpose ([int] parts) = Partition:
   parts.frequencies[1:].cumulate_backward
{ or more "manually", when |parts| assumed already in decreasing order
  if #lambda=0 then []
  else let l=#lambda in
    for i:lambda[0] { since |i<lambda[0]|, we can never set |l:=0| below }
    do while lambda[l-1]<=i do l-:=1 od; l
    od
  fi
}

set compressed_string(Partition P) = string:
   let mult=1
   then result =
      for l@i in P
      do if i=0 then "[ "
	 elif l=P[i-1] then mult+:=1; ""
	 elif mult=1 then P[i-1]+", "
	 else P[i-1]+"^"+mult+", " next mult:=1
	 fi
      od.##
in result ## if mult=1 then P~[0].to_string else P~[0]+"^"+mult fi ## " ]"

{ lexicographic comparison restricted to partitions of same |n| (0-extended) }
set rlex_leq_partitions (Partition lambda, Partition mu) = bool:
   let m=#mu in
   for l@i in lambda
   do if i>=m then assert(@:l=0,"unequal sum"); return true
      elif l!=mu[i] then return l<mu[i]
      fi
   od; assert(@:mu[#lambda:].=,"unequal sum"); true

{ same, but three-way result in $\{-1,0,1\}$ for less/equal/greater; no 0-ext }
set rlex_cmp_partitions (Partition lambda, Partition mu) = int:
   let m=#mu in
   for l@i in lambda
   do if l!=mu[i] { equal sum, nonzero entries, so |mu| cannot run out }
      then return if l<mu[i] then -1 else 1 fi
      fi
   od; 0 { if |lambda| exhausted then so is |mu|, and we have equality }

{ comparing partitions by sum then lexicographically; implicitly 0-extend }
set slex_leq_partitions ((Partition,Partition) (lambda,mu):pair) = bool:
  let sl=lambda.sum, sm=mu.sum in
  if sl!=sm then sl<sm else rlex_leq_partitions(pair) fi

set slex_cmp_partitions ((Partition,Partition) (lambda,mu):pair) = int:
  let sl=lambda.sum, sm=mu.sum in
  case sl-sm then minus_1 in rlex_cmp_partitions(pair) else 1 esac

{ look up partition in sorted list of partitions, all assumed of same sum }
set index_partition([Partition] sorted_list) = (Partition->int):
(  let l=#sorted_list in { precompute constant }
   (Partition lambda) int:
      binary_search_first
      ((int i)bool:rlex_leq_partitions(lambda,sorted_list[i])
      ,0,l
      )
)

{ dominance order on compositions, assumed to be so of the same number }
set dominance_leq_compositions (Partition v,Partition w) = bool:
(  v:=sort_to_partition(v); w:=sort_to_partition(w)
;  if   #v=0 then #w=0 or error("compositions not of same number")
   else assert(@: #w>0,"compositions not of same number")
   { |sort_to_partition| balks on negative entries, so |v~[0]>0 and w~[0]>0| }
   ;  let sums_v = cumulate_forward(v), sums_w = cumulate_forward(w)
   in assert(@:sums_v~[0]=sums_w~[0],"compositions not of same number")
   ;  for sw@i in sums_w do @: sums_v[i]<=sw od.all { is safe and sufficient }
   fi
)

{ same as previous, but assuming |v|,|w| are equal sum partitions (so sorted) }
set dominance_leq_partitions (Partition v,Partition w) = bool:
   let limit=#w
in limit=0 {in which case |#v=0| as well by assumption} or
  (let sum_v=v[0],sum_w=w[0] { both exist, since absence of 0-entries assumed }
   in for i:limit-1 from 1
      do @: { so that evaluation stops once a |false| is encountered }
         if sum_v<=sum_w
         then true next sum_v+:=v[i]; sum_w+:=w[i]
	 else false
	 fi
      od.all
  )

{		functions related to representations of S_n		}

set hook_lengths (Partition lambda) = [int]:
   let lambda_tr=lambda.transpose in
   for part@i in lambda
      for j:part do (part-j) + (lambda_tr[j]-i) - 1 od { arm + leg - 1 }
   od.sort_to_partition { not viewed as partition, but sorting is the same }

set Sn_representation_dimension (Partition lambda) = int:
   let hl=lambda.hook_lengths in hl.#.fac\hl.product

set hook_lengths ([bool] edges) = [int]:
   let last=#edges-1
in for edge@i in edges
   do if edge then []
      else for j:last-i from i+1 if edges[j] do j-i fi od
      fi
   od.##

{ edge sequence from first horizontal (false) to last horizontal, and shift }
set edge_sequence (Partition lambda) = ([bool],int):
   if =#lambda or =lambda[0] then ([],0)
   else
      let d = lambda.transpose[0] { offset, index of edge above main diagonal }
      , edge_val=is_member_sorted(for part@i in lambda do part-i-1 ~od)
      in (for i:lambda[0]+d from -d do edge_val(i) od, d)
   fi

set cycle_type_order = lcm@[int]
set cycle_centralizer_order ([int] cycles) = int:
  product(cycles)*product(for m in cycles.frequencies do m.fac od)
set cycle_class_size ([int] cycles) = int:
  cycles.sum.fac \ cycle_centralizer_order(cycles)

{ compute cycle type of power of a permutation, given its cycle type }
set cycle_power ([int] cycles, int k) = [int]:
   for l in cycles
   do let d=gcd(l,k) then q=l\d in for :d do q od { splitting of one cycle }
   od.##.sort_to_partition

{ character of irreducible Sn representation lambda at give cycle type }
set Murnaghan_Nakayama (Partition lambda, [int] cycle_type) = int:
   assert(@:sum(lambda)=sum(cycle_type),"Size mismatch");
   let (edge,) = edge_sequence(lambda), alpha=cycle_type.sort { increasing } in
   (#alpha-1).
   (rec_fun MN (int j) int:
    if j.< then 1 { the unique character value for the trivial group S0 }
    else
       let k=alpha[j] { size of cycle in cycle type, and hence of rim hooks } in
       if k=1 { this case will be handled separately for efficiency }
       else { traverse candidate positions for removal of a |k| rim hook: }
	  for i in list(#edge-k,(int i)bool: not edge[i] and edge[i+k])
	  do edge[i+k]:=false; edge[i]:=true { remove our chosen |k| rim hook }
	  ; (-1)^count(edge[i+1:i+k])*MN(j-1) { recursive value, hook sign }
	  next edge[i]:=false; edge[i+k]:=true { restore: add rim hook back }
	  od
	 .sum { add up value from all candidate positions }
       then { |k=1| case, used the hook length formula for remaining partition }
          let hl=edge.hook_lengths in hl.#.fac\hl.product
       fi
    fi
   )



{ generating all partitions; for counting, see |n_partitions| in lazy_lists.at }

set partitions = (int n) [Partition]:
  if n.< then []
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m do [[]] { empty partition of 0, else nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do let rem = m-k { amount remaining after using one part |k| of |m| } in
        { traverse all partitions of |rem| with parts at most |min(k,rem)|: }
	for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

{ generating partitions, all of whose parts must lie in a given set }

set part_restricted_partitions ((int->bool)pred) =
  (int n) [Partition]:
  if n.< then []
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m do [[]] { empty partition of 0, else nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do
        if pred(k) then
          let rem = m-k { amount remaining after using one part |k| of |m| } in
    	  { traverse all partitions of |rem| with parts at most |min(k,rem)|: }
	  for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
	else [] { leave empty list at position |k| which fails |pred| }
	fi
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

set odd_part_partitions = part_restricted_partitions(is_odd@int)

{ partitions with distinct parts: all multiplicities are 0 or 1 }
set strict_partitions = (int n) [Partition]:
  if n.< then []
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if =m do [[]] { empty partition of 0, else nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m-1) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do { traverse all partitions |m-k| with parts at most |min(k,m-k)|: }
        let rem = m-k in
        for lambda in ##table[rem][:min(k-1,rem)+1] do k#lambda od
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi


{		Jordan types of nilpotent elements (or orbits)		}

{ test if partition is valid (nilpotent orbit) Jordan type in type ABCD }
set is_valid (string type,Partition P) = bool:
{ avoid constructing |Lie_type(type[0]+n|, to avoid choking on "B1" and such }
  P:=P.strip_to_partition; { avoid frequencies of 0 }
  case ascii(type)-ascii("A")
  in { type A } true
  , { type B } sum(P).is_odd and
    all(for mult in P.frequencies.even_places do mult.is_even od)
  , { type C } sum(P).is_even and
    all(for mult in P.frequencies.odd_places do mult.is_even od)
  , { type D } sum(P).is_even and
    all(for mult in P.frequencies.even_places do mult.is_even od)
  else false { exceptional types are not valid }
  esac

set is_valid (LieType t) = (Partition->bool):
   let codes = simple_factors(t)
   then (letter,r)= assert(#codes=1,"Non-simple Lie type"); codes[0]
   then n =
      case ascii(letter)-ascii("A") in r+1, r+r+1, r+r, r+r
      else error("Exceptional ",t)
      esac
in (Partition P) bool: #P = n and is_valid(letter,P)


{	Combinatorics specifically for (Weyl groups of) types B,C,D	}

{ partitions with even multiplicity of parts of one parity (odd or even) }
set parity_restricted_partitions (bool restrict_odd_parts) = (int->[Partition]):
  let is_multiplicity_restricted = (int->bool):
    if restrict_odd_parts then is_odd@int else is_even@int fi   in
  (int n) [Partition]:
  if n.< or restrict_odd_parts and n.is_odd then [] { impossible, so nothing }
  else
    let table = [[ [Partition] ]]: { partitions by sum, then by largest part }
      for m:n+1
      do if m=0 do [[]] { empty partition of 0, else nothing yet } fi
      od
    in
    for m:n from 1
    do table[m] := ([Partition]: []) { no partitions with largest part 0 } #
      for k: if m=n then n else min(m,n-m) { truncate to need } fi from 1
	 { form list of partitions of |m| with largest part |k| }
      do { traverse all partitions |m-k| with parts at most |min(k,m-k)|: }
        if k.is_multiplicity_restricted
        then { restrict use of k to using it twice, |lambda| may also have |k| }
	  let rem=m-k-k in
          if rem.< then []  { if a negative remainder, then no solutions here }
          else for lambda in ##table[rem][:min(k,rem)+1] do [k,k]##lambda od
          fi
	else { we use |k| once, |lambda| could have part(s) equal to |k| too }
	  let rem = m-k in
          for lambda in ##table[rem][:min(k,rem)+1] do k#lambda od
        fi
      od
    od
  ; ##table~[0] { concatenate entries of final table row }
  fi

{ for conjugagy classes: cycles with product of signs, for simple types B,C,D }
set_type Signed_cycles = [int,bool] { bool |b| encodes product |minus_1^#b| }

{ for $W(C_n)$ irreducible representations: partition pairs of total size $n$ }
set_type BiPartition = (Partition,Partition)
{ no specific interpretation imposed here, but ordering should always have:
  positive/even/0/false/trivial repn BEFORE negative/odd/1/true/sign repn one
  parametrises irreps of the hyperoctahedral group $W(C_n)=W(B_n)$
  also in bijection with |Signed_cycles| as (unflipped lengths,flipped lengths)
}


set rank (Signed_cycles cycles) = int: for (c,) in cycles do c od.sum
set rank (BiPartition(lambda,mu)) = int: lambda.sum+mu.sum

{ equality is strict (don't want to force interpretation onto |[int,bool|]) }
set = (Signed_cycles cyc0,Signed_cycles cyc1) = bool:
   #cyc0=#cyc1 and
   ( for (n,b)@i in cyc0
     do let(m,c)=cyc1[i] in if n!=m or b!=c then return false fi
     od
   ; true
   )
set != (Signed_cycles cyc0,Signed_cycles cyc1) = bool: not(cyc0=cyc1)

{ The hyperoctahedral group $H_n$ can be represented by sigend permutation
  matrices (where every row and column has a unique nonzero entry, which lies in
  $\{-1,1\}$. There is a surjective group morphism to $S_n$ forgetting the signs.

  This is the symmetry group of en $n$-dimensional hyperoctahedron (also of the
  hypercube), centered at the origin, with 2 vertices on each coordinate axis.

  Conjugacy classes of $H_n$ are given by signed cycle types: projection to
  $S_n$ gives a cycle type (for the permutation of the axes), and to each cycle
  is attached the product of the signs for the coordinate axes in the cycle.
}

{ converting partition pairs to signed cycle types, second has flipped cycles }
set to_cycles (BiPartition(lambda,mu)) = Signed_cycles:
  for part in lambda do (part,false) od ## for part in mu do (part,true) od

{ the inverse of |to_cycles@BiPartition| }
set to_partition_pair(Signed_cycles cy) = BiPartition:
( for (part,b) in cy do if b then 0 else part fi od.sort_to_partition
, for (part,b) in cy do if b then part else 0 fi od.sort_to_partition
)

{ generate pairs of partitions of total size |n| with size |k| components
  produced in the order in which |lister| lists them, starting all on left }
set pairs_of_total_sum (int n,(int->[Partition]) lister) = [BiPartition]:
  let list = for i:n+1 do lister(i) od in
  for parts_i@i in list ~ { reversal means taking larger partitions first }
     for lambda in parts_i for mu in list[n-i] do (lambda,mu) od od
  od

{ generate all bi-partitions of |n| by size distribution, starting all left }
set partition_pairs (int n) = [BiPartition]:
  pairs_of_total_sum(n,partitions@int)

set = (BiPartition (P,Q), BiPartition (R,S)) = bool: P=R and Q=S

{ compare |BiPartition| values of same sum, in ordering of |partition_pairs| }
set <=(BiPartition (P,Q), BiPartition (R,S)) = bool:
   case P.sum-R.sum
   then false else true { size balance is decisive, inverted ordering! }
   in { equal size case: compare left partitions, or right if ex aequo }
      if P=R else (P,R) then (Q,S) fi.rlex_leq_partitions
   esac

{ look up pair in sorted list of partition pairs, all assumed of same sum }
set index_bipartition ([BiPartition] sorted_list) = (BiPartition->int):
   (BiPartition PQ) int:
      binary_search_first( (int i)bool: PQ<=sorted_list[i], 0, #sorted_list )


{ counterpart of the Murnaghan-Nakayama rule for hyperocthedral groups }

{ Characters of the hyperoctahedral group $H_n$ are parametrised as follows by
  bi-partitions |(lambda,mu)| of $n$. Call "axis-sign" the 1-dimensional
  representation of any hyperoctahedral group that takes value $+1$ on all
  simple reflection except the last (for the off-length simple root) where it
  takes the value $-1$: on a general signed permutation it is the product of the
  nonzero entries in its matrix (it is also the product of the cycle-signs in
  its signed cycle type).

  Given a bi-partition |(lambda,mu)|, let |l=sum(lambda),m=sum(mu)|, let $K$ be
  the $H_l\times H_m$ subgroup of $H_n$, restrict (back up the surjective group
  morphisms $H_i\to S_i$) the irreducible representations for |lambda| and |mu|
  of $S_l$ respectively $S_m$ to ones of $H_l$ respectively $H_m$, tensor the
  latter with the axis-sign representation of $H_m$, then induce the resulting
  (outer tensor product) representation of $K=H_l\times H_l$ from $K$ to $H_n$.
}

set hyperoctahedral_character (
       BiPartition (lambda,mu):pair { irreducible repn, sign applies to |mu| }
      ,Signed_cycles signed_cycle_type { describes a conjugacy class }
      ) = int:
   assert(@:rank(pair)=rank(signed_cycle_type),"Size mismatch");
{ The formula implemented is recursive in the number of cycles, similarly to the
  Murnaghan-Nakayama rule. Pick a signed cycle |(k,sign)| (we start with picking
  longest ones, so as to have all length 1 cycles remaining at the bottom of the
  recursion) and find all the hooks in |mu| or |lambda| of length |k|; for each
  match remove the (rim) hook, recursively compute the character value of the
  remaining |BiPartition| at the class obtained by removing the signed cycle,
  multiply it by the sign $(-1)^h$ of the hook (where $h$ is the number of
  vertical adjacencies in the hook), and in case the hook was removed from |mu|
  by |sign| as well; the character value is the sum all the values so obtained.
}
   let alpha = signed_cycle_type
               .(sort_by((int l,bool.)int: l, <=@(int,int))) { do long first }
   then (c,d) = (int,int): { numbers of 1-cycles with - resp. + in |alpha| }
     for (l,sign) in alpha do if l>1 then break else s^#sign{use |Split|} fi
     od.sum.% { sum powers of |s|, then extract its two components }
   , (edge0,)=edge_sequence(lambda), (edge1,)=edge_sequence(mu)
   in (#alpha-1).
   (rec_fun f (int j) int:
    if j.< then 1 { termination case: value for the trivial group S0 }
    else let (k,sign)=alpha[j] { size of cycle type, and hence of rim hook } in
       if k=1 { only 1-cycles left; will be handled separately for efficiency }
       else { traverse candidate positions for removal of a |k| rim hook: }
       (  for i in list(#edge0-k,(int i)bool: not edge0[i] and edge0[i+k])
	  do edge0[i+k]:=false; edge0[i]:=true { remove chosen |k| rim hook }
	  ; f(j-1)*(-1)^count(edge0[i+1:i+k]) { recursive value, hook sign }
	  next edge0[i]:=false; edge0[i+k]:=true { restore: add rim hook back }
	  od
	 .sum { add up value from all candidate positions }
       ,  for i in list(#edge1-k,(int i)bool: not edge1[i] and edge1[i+k])
	  do edge1[i+k]:=false; edge1[i]:=true { remove chosen |k| rim hook }
	  ; f(j-1)*(-1)^count(edge1[i+1:i+k]) { recursive value, hook sign }
	  next edge1[i]:=false; edge1[i+k]:=true { restore: add rim hook back }
	  od
	 .sum { add up value from all candidate positions }
       )
       . if sign else +@(int,int) then -@(int,int) fi { add or subtract sums }
       then { |k=1| case: use the hook length formula for remaining partition.
              Sum over maps from of the 1-cycles to $\{1,-1\}$ such that |a| of
	      them map to $1$ and |b| to $-1$, where $(a,b)$ are the sizes of
	      the remaining partitions $(lambda',\mu')$; for each map multiply
	      the product of the hook length formulas for $\lambda'$ and $\mu'$
	      by $(-1)^l$ where $l$ counts the negative cycles mapping to $-1$.
	      Grouping similar cases, the summation reduces to one over 2x2
	      matrices with entries in $\N$ and row sums a$,$b and column sums
	      c$,$d, with $l$ being its bottom-right entry. }
          let hl0=edge0.hook_lengths, hl1=edge1.hook_lengths
          then { get fixed row sums and column sums for $\N$-matrix [.,.|.,l] }
            (a,b) = (#hl0,#hl1) { partition sizes to be filled }
          then lwb = max(0,d-a{=b-c}), upb=min(b,d) { bounds for l }
          in assert(@:a+b=c+d);
          for l:upb-lwb+1 from lwb do (-1)^l*binom(c,b-l)*binom(d,l)od.sum
          * (a.fac\hl0.product)*(b.fac\hl1.product) { factor independent of l }
       fi
    fi
   )


{
  Core and quotient operations can be defined in terms of associating to any
  partition $\lambda$ the subset $\{ lambda[i]-i-1 | i\in\N \}$ of $\Z$. This
  set represents the set of vertical edges terminating the rows of the Young
  diagram, recorded by their diagonal positions (the main diagonal separating
  positions in $\N$ from its complement, i.e., its splits between -1 and 0).

  This set is bounded above while its complement is bounded below; more
  specifically the set meets $\N$, and its complement the complement of $\N$, in
  equal size finite sets. An ordered pair of partitions can be "spliced
  together" as follows: take there associated sets, transform the former by
  $i\mapsto 2i$ and the latter by $i\mapsto 2i+1$, merge the results and find
  the partition corresponding to the set. If the Young diagrams original
  partitions together have $n$, the spliced partition can be covered by $n$
  dominos. More generally we could add a fixed integer $d$ in the first
  transformation and subtract it in the second; then $d$ will be the unbalance
  of black and white squares in the diagram of the resulting partition, and
  after removing $n$ dominos from it we are left with a "2-core" still having
  the same unbalance. It is a staircase diagram with |core_length(d)| parts.
  The pair of original partitions is the "2-quotient" of the spliced partition.
}

set core_length (int n) = int: if n.<= then 2*-n else 2*n-1 fi
set core_number (int k) = int: assert(@:k>=0); case k in -k\2, -k\-2 esac

{ Core number and quotient partition pair. In the latter, as per |BiPartition|
  convention, the partition coming from the EVEN edge positions comes first }
set core_quotient_2 (Partition lambda) = (int,BiPartition):
   let d = int: { black/white unbalance of diagram }
      for l@i in lambda do case l in 0, (-1)^i esac od.sum
   ,  positions = [int]: for l@i in lambda do l-i-1 od
   then e = for p in positions do case p in [p\2-d],[] esac od.##
   ,    o = for p in positions do case p in [],[p\2+d] esac od.##
   then  ep = for x@i in e do x+i+1 od, op = for x@i in o do x+i+1 od
   in (d,(ep.strip_to_partition,op.strip_to_partition))

{ Splicing BiPartitions |(lambda,mu)|, with 2-core with (unbalance) number |d| }
set from_core_quotient_2 (int d,BiPartition(lambda,mu)) = Partition:
{ Implementation is delicate, as we must represent infinite sets finitely.

  Initially take just one number for each (nonzero) part of each partition, and
  record the first numbers |k|, |l| that are omitted in this representation.
  Also reverse the order to increasing, since this is what |merge@([int,[int])|
  defined in sort.at assumes. Before merging, we need to "even out" the
  (negative) heads of the lists by adding omitted terms to one of them, those
  whose absence would produce gaps in the merged result. The first such term to
  be added (if any) is 3 more than the first omitted term in the other list.
}
(  let evens = for l@i in lambda do 2*(l-i-1+d) ~od { space out and reverse }
   ,   odds = for m@i in mu do 2*(m-i-1-d)+1 ~od { likewise }
   ,   k = 2*(-#lambda-1+d), l = 2*(-#mu-1-d)+1 { last omitted values before }
in if k>l
   then evens := for i:(k-l)\2 from l\2+2 do i+i od ## evens
   else odds := for i:(l-k)\2 from k\2+1 do i+i+1 od ## odds
   fi
;  for v@i in merge(evens,odds)~[:] do v+i+1 od.strip_to_partition
)

{ Find classical (permutation or signed permutation) description of Weyl group
  elements in classical types. The associated root datum must have one simple
  factor of type A-D, but need not have standard (Bourbaki) diagram numbering.

  The output is a (signed) permutation in one-line format. For type $A_n$ this
  is just a permutation of $n+1$ (hence 0-based), for types $B_n$, $C_n$, $D_n$
  this is a permutation of the $2n$ elements $-n, ,..., -2 -1, 1, 2, ..., n$,
  commuting with $x \mapsto -x$, and the one-line format consists of a list of
  the images of $1, 2, ..., n$ (1-based); it determines the signed permutation.
}
set classic_permutation (WeylElt w) = [int]:
(  let rd=w.root_datum then (lt,map)=Cartan_matrix_type(rd.Cartan_matrix)
   then factors=simple_factors(lt) then nf=#factors
in assert(@:(nf=1,"Root datum diagram is not connected ("+ nf +" components)"))
;  let word = { |w.word| translated to word for Bourbaki numbered diagram }
      let inv = permutation_inverse(map) in for s in w.word do inv[s] od
   , (type,rank)=factors[0]
in case char_index(type,"ABCD")
   in let n=rank+1 in (vec:#n)*W_elt(GL(n),word) { right act on [0,1,...,n-1] }
   , (vec:for i:rank from 1 do i od)*W_elt(Sp(rank+rank),word) { B is same as C }
   , (vec:for i:rank from 1 do i od)*W_elt(Sp(rank+rank),word)
   , (vec:for i:rank from 1 do i od)*W_elt(SO(rank+rank),word)
   else error("Root datum of exceptional type "+type)
   esac
)

{ a simpler version when |w| is known to be for some Sp(2n) or SO(m) }
set signed_permutation(WeylElt w) = [int]:
   (vec:for i:w.root_datum.rank from 1 do i od)*w

{ for a signed permutation |sigma| of $\{1,...,n\}$, represented by the images
  of $1,...,n$, compute the cycle type as list of pairs (cycle length, sign);
  return weakly decreasing vector of sign*cycle_length, e.g., |[4,2,-1,-1,-3]|
}
set signed_cycle_type_code ([int] sigma) = vec:
  let cycles = for a in sigma do abs(a)-1 od.permutation_cycles
  then lengths = { lengths of cycles, negated when there is a flip }
    for cyc in cycles do sign(for i in cyc do <sigma[i] od.XOR) * #cyc od
  in reverse_sort(lengths)
set cycle_code(WeylElt w) = vec: { assuming |w| is for |Sp(2n)| or |SO(m)| }
  signed_cycle_type_code(signed_permutation(w))

{ convert code as above to |Signed_cycles|, ordering as |to_cycles| does }
set as_signed_cycles (vec v) = Signed_cycles:
  let pos_part = for cyc in v if cyc.> do (cyc,false) fi od
  , neg_part = for cyc in v ~ if cyc.< do (-cyc,true) fi od
  in pos_part ## neg_part
set as_bipartition (vec v) = BiPartition:
  ( for l in v   if l.> do  l fi od
  , for l in v ~ if l.< do -l fi od
  )
set signed_cycle_type ([int] sigma) = Signed_cycles:
  signed_cycle_type_code(sigma).as_signed_cycles

set cycle_type_order (Signed_cycles cycles) = int:
  for (cycle,sign) in cycles do if sign else cycle then cycle+cycle fi od.lcm
set cycle_centralizer_order (Signed_cycles cycles) = int:
  let plus_cycles = for (c,s) in cycles if not s do c fi od
  ,  minus_cycles = for (c,s) in cycles if   s   do c fi od
  in product(for (cycle,) in cycles do cycle+cycle od)*
     product(for m in plus_cycles.frequencies do m.fac od)*
     product(for m in minus_cycles.frequencies do m.fac od)
set cycle_class_size (Signed_cycles cycles) = int:
  let n=rank(cycles) in n.fac * 2^n \ cycle_centralizer_order(cycles)

{ compute cycle type of power of a signed permutation, given its cycle type }
set cycle_power (Signed_cycles cycles, int k) = Signed_cycles:
(  let m = for (c,) in cycles do c od.(max(0))
   then n_cycles = { multiplicities by cycle length and sign }
     mat: null(m,2) { row index offset by 1, (-1)^(column index) is sign }
in for (l,sign) in cycles
   do let d=gcd(l,k) in n_cycles[l\d-1,#sign*(k\d)%2] +:= d
   od
;  for b:2 ~ { true (negative) before false (positive) }
   do let kind = b.is_odd in
      for l:m from 1 ~ for :n_cycles[l-1,b] do (l,kind) od od
   od.##
)

{ adaptation to the above to deal with Weyl groups of type Dn }

{ a condition relevant to which cycle types give split classes in $W(D_n)$ }
set is_very_even (Partition P) = bool: =P%2 { whether all parts are even }

{ a condition relevant to which $D_n$ nilpotent orbits are split from $O(2n)$ }
set is_doubly_even (Partition P) = bool: { even parts even multiplicities only }
  let freq = frequencies(P) in =freq.odd_places and =freq.even_places%2

set_type D_class = { cycle types restricted to Dn subgroup }
   ( Signed_cycles unsplit_class { the XOR of all |bool| values is |false| }
   | (Partition,bool) split_class { "all false" even cycles, and a single sign }
   )
set_type D_irrep = { from folding pairs of partitions under swapping }
   ( (Partition,Partition) unsplit_irr { unequal partitions, larger first }
   | (Partition,bool) split_irr { for pair of equal partitions, with sign }
   )

{ recover the value of |n| }
set rank (D_class c) = int:
   case c
   | (cycles).unsplit_class: cycles.rank { rank@Signed_cycles; combinatorics.at }
   | (lambda,).split_class: lambda.sum { |lambda| has all cycles (even,false) }
   esac

set rank (D_irrep chi) = int:
   case chi
   | (pair).unsplit_irr: pair.rank { rank@(Partition,Partition) }
   | (lambda,).split_irr: 2*lambda.sum { |as lambda| stands for (lambda,lambda) }
   esac

set cycle_type_order (D_class c) = int:
   case c
   | (cycles).unsplit_class: cycles.cycle_type_order { as in types B, C }
   | (lambda,).split_class: lambda.cycle_type_order { as in type A }
   esac
set centralizer_order (D_class c) = int:
   case c
   | (cycles).unsplit_class: { unsplit means half of BC centralizer isn't in Dn }
       cycles.cycle_centralizer_order\2
   | (alpha,).split_class: { split means full BC centralizer is in Dn subgroup }
       { simulate |cycle_centralizer_order@Signed_cycles|, using ..@Partition }
       alpha.cycle_centralizer_order*2^#alpha { add a factor 2 for each cycle }
   esac
set class_size (D_class c) = int:
  let n=rank(c) in n.fac * 2^(n-1) \ centralizer_order(c)

{ compute cycle type of power of a signed permutation, given its cycle type }
set cycle_power (D_class c, int k) = D_class:
   case c
   | (cycles).unsplit_class: cycle_power(cycles,k).unsplit_class
   | (alpha,sign).split_class: let beta=cycle_power(alpha,k) in
     if beta.is_very_even { whether class remains split (may fail for even |k|) }
     then (beta,sign).split_class { keep sign when class remains split }
     { an easy way to see that this is right: certainly when |sign=false|, the
       power gets no sign, but since an outer automorphisme interchanges the
       halves of every split class, |sign=true| should give the opposite half }
     else for part in beta do (part,false) od.unsplit_class
     fi
   esac

set D_classes (int n) = [D_class]:
   for (lambda,mu):pair in partition_pairs(n)
   do if (#mu).is_odd then [] { must have even number of cycles in |mu| }
      elif not(=mu and lambda.is_very_even) { whether unsplit }
      then [pair.to_cycles.unsplit_class]
      else [ (lambda,false).split_class, (lambda,true).split_class ]
      fi
   od.##

set D_irreducibles (int n) = [D_irrep]:
(  for (lambda,):pair in partition_pairs(n)
      if not slex_leq_partitions(pair) do pair.unsplit_irr fi
   od
##(let (s,r)=n\%2 in
   if =r else []
   then
      for lambda in partitions(s)
      do [(lambda,false).split_irr,(lambda,true).split_irr]
      od.##
   fi
  )
)

set character (D_irrep chi, D_class c) = int:
   assert(@:chi.rank = c.rank,"Size mismatch");
   let pos_cycles(Partition mu)=Signed_cycles: for l in mu do (l,false) od in
   case chi
   | (pair).unsplit_irr:
     case c
     | (cycles).unsplit_class: hyperoctahedral_character(pair,cycles)
     | (alpha,).split_class: { both halves behave as their BC class }
        hyperoctahedral_character(pair,pos_cycles(alpha))
     esac
   | (lambda,epsilon).split_irr:
     case c
     | (cycles).unsplit_class:
       let (q,r) = hyperoctahedral_character((lambda,lambda),cycles)\%2 in
       assert(@:r=0,"Odd character value at unsplit class"); q
     | (alpha,delta).split_class:
       let Hn_char = int:
           hyperoctahedral_character((lambda,lambda),pos_cycles(alpha))
       ,   Sn_char = int:
           assert(@:alpha.is_very_even,"Split class with odd cycle(s)");
           Murnaghan_Nakayama(lambda, alpha\2)
       then (q,r) = (Hn_char+sign(epsilon!=delta)*2^#alpha*Sn_char)\%2
       in assert(@:r=0,"Parity problem for split-split character value"); q
     esac
   esac


{ for printing |BiPartition| values compactly }
set compressed_string(BiPartition(P,Q)) = string:
(  let mult=1
   then result =
      for l@i in P
      do if i=0 then "[ "
	 elif l=P[i-1] then mult+:=1; ""
	 elif mult=1 then P[i-1]+", "
	 else P[i-1]+"^"+mult+", " next mult:=1
	 fi
      od.##
in result ##:=
      if mult=1 then P~[0].to_string else P~[0]+"^"+mult next mult:=1 fi
;  result ##:=
      for l@i in Q
      do if i=0 then " L|S "
	 elif l=Q[i-1] then mult+:=1; ""
	 elif mult=1 then Q[i-1]+", "
	 else Q[i-1]+"^"+mult+", " next mult:=1
	 fi
      od.##
;  result ## if mult=1 then Q~[0].to_string else Q~[0]+"^"+mult fi ## " ]"
)
