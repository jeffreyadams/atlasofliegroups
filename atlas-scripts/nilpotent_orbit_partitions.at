<basic.at
<combinatorics.at { for |Partition| type ans partition generators }
<coordinates.at
<groups.at
<sort.at {for reverse_sort}
<Weylgroup.at
<partitions.at

{ (complex) nilpotent orbits for simple classical groups,
  classical groups: SL(n), GL(n), Sp(2n), SO(n),
  orbits: partition-type parameterization
  no attempt is made to handle I/II orbits in type D,
  so these are really orbits for O(n,C) not SO(n,C)
  semisimple_element: H\in X^* from Lie triple (H,X,Y),
  standard (classical group) coordinates
  (in type A_n lambda has n+1 coordinates, i.e. for GL(n))
}

{ utility to convert type A-G of a simple root system to a number 0-6
  we allow and ignore (trailing) torus factors; a pure torus classifies as 7 }
set type_number (LieType t) = int:
  let codes = simple_factors(t) in assert(#codes<=1,"Non-simple Lie type");
  if =#codes then { pure torus } 7
  else let (c,)=codes[0] in ascii(c)-ascii("A")
  fi

{ same as previous applied to a RootDatum }
set type_number (RootDatum rd) = int: type_number(Lie_type(rd))

{ (complex) nilpotent orbits, partition-type classification,
  for simple group of type A-D
}
set nilpotent_orbit_partitions (LieType t)= [Partition]:
  let n=semisimple_rank(t) in
  case type_number(t) { this only lets simple types through }
  in partitions(n+1) { all partitions in type A }
  , parity_restricted_partitions(2*n+1,false) { even restricted in type B }
  , parity_restricted_partitions(2*n,true) { odd restricted in type C }
  , parity_restricted_partitions(2*n,false) { even restricted in type D }
  else error("Exceptional type")
  esac

{ insert conversion to LieType from (type converting to RootDatum)
  (types A-D only; this only depends on complexification of real group)
}
set nilpotent_orbit_partitions(RootDatum rd) = [Partition]:
   nilpotent_orbit_partitions(Lie_type(rd))

{ test if partition is valid orbit in type ABCD }
set is_valid (string type,vec P) = bool:
{ avoid constructing |Lie_type(type[0]+n|, to no choke on "B1" and such }
  case ascii(type)-ascii("A")
  in true
  , { type B } sum(P).is_odd and
    all(for mult in P.frequencies.even_places do mult.is_even od)
  , { type C } sum(P).is_even and
    all(for mult in P.frequencies.odd_places do mult.is_even od)
  , { type D } sum(P).is_even and
    all(for mult in P.frequencies.even_places do mult.is_even od)
  else false { exceptional types are not valid }
  esac

set is_valid (LieType t,vec P) = bool:
  let tn=type_number(t), r=t.rank in
  #P = case tn in r+1, r+r+1, r+r, r+r esac and is_valid("ABCD"[tn],P)

{ nilpotent orbits of dual group (types A-D only) }
set dual_nilpotent_orbit_partitions(RootDatum rd)=[Partition]:
  nilpotent_orbit_partitions(dual(rd))
set dual_nilpotent_orbit_partitions(RealForm G)=[Partition]:
  dual_nilpotent_orbit_partitions(root_datum(G))

{ tools for computing h(O^\vee): apply to rows of Young diagram }
set tworho (int n)=vec: for k:n do (n-1)-2*k od { e.g., [2,0,-2] or [3,1,-1,-3]}
set rho (int n)=[rat]: tworho(n)/2

set String (int n) = Partition:
  for k:n\2 do (n-1)-2*k od { e.g., [4,2] or [5,3,1]  }

{ compute 1/2 h(O^\vee) for G of type |t| (types A-D only)
  O^\vee assumed to be an orbit of G^\vee, given by a partition |P|
  only Lie type (of complexification) of G plays a role }
set semisimple_element (LieType t,Partition P) = vec: { a coweight }
  if type_number(t)=0
  then ## for p in P do tworho(p) od
  else let strs = ## for k in P do String(k) od in
    strs ## for i: sum(P)\2-#strs do 0 od
  fi

{ same as previous applied to (RootDatum,vec p)
  in this case apply dominant(.,rd) to resulting coweight; this only works if
  RootDatum is a classical group with the usual classical coordinates
}
set semisimple_element (RootDatum rd,Partition p) = vec: { a dominant coweight }
  dominant(semisimple_element(Lie_type(rd),p),rd)

{ v,w are partitions of same n: sum(v)=sum(w)
  v, w written in decreasing order (actually use reverse_sort to assume this)
  v,w <-> nilpotent orbits in GL(n)
  return true if orbit(v) contained in closure of orbit(w)
  algorithm: v=(a_1,...,a_r), w=(b_1,...,b_s);
  a_1+...+a_k \le b_1+...+b_k for all k\le min(r,s)sawtrset v
}

set nilpotent_orbit_ss_elements (LieType t) = [vec]:
  for P in nilpotent_orbit_partitions(t) do semisimple_element(t,P) od
set nilpotent_orbit_ss_elements (RootDatum rd) = [vec]:
  for P in nilpotent_orbit_partitions(rd) do semisimple_element(rd,P) od



set lesseq_partition (Partition v,Partition w) = bool:
   assert(sum(v)=sum(w),"not comparable");
   assert(v.>= and w.>= , "negative terms");
   v:=reverse_sort(v); w:=reverse_sort(w);
   all(for i:min(#v,#w)+1 do sum(v[0:i]) <= sum(w[0:i]) od)

{ same as previous but assume each term is already reverse sorted,
  and all terms are comparable }
set lesseq_partition_presorted (Partition v,Partition w) = bool:
   for i:min(#v,#w)+1 do if v[i]!=w[i] then return v[i]<w[i] fi od;true

{ orbits=[v_1,...,v_n]
  closures(orbits)[i] is the set of j (not including i itself) such that
  orbits[j] contained in the closures of orbits[i]
}
set closures([Partition] orbits) = [[int]]:
  {pre-sort}
   let orbits=for P in orbits do reverse_sort(P) od in
   for P@i in orbits
   do
   ## for j:#orbits
      do if j!=i and lesseq_partition_presorted(orbits[j],P) then [j] else [] fi
      od
   od

{ this only works for simple classical groups, fails for exceptional groups;
  the more general version in nilpotent_orbits_exceptional handles the
  simple exceptional case also }
set nilpotent_lambdas_classical (RootDatum rd) = [ratvec]:
    for lambda in nilpotent_orbit_ss_elements(dual(rd)) do lambda/2 od
