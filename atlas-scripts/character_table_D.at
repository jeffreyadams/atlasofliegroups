<basic.at
<character_tables.at
<classical_W_classes_and_reps.at { for types |D_class|, |D_irrep| }

{ word representative in types D of unsplit conjugacy class for partition pair }
set class_word_D(Partition lambda,Partition mu) = [int]:
(  assert((lambda:=lambda.strip_to_partition).>, "lambda is not a partition")
;  assert((mu:=mu.strip_to_partition).>, "mu is not a partition")
;  assert(=#mu%2, "mu has an odd number of parts")
;  assert(not(=mu and =lambda%2)
	 , "mu is empty and lambda has even parts: split class")
;  let n=sum(lambda), m=sum(mu)
   ,  Mbars = let sum=minus_1 in for k in mu do sum+:=k od
   ,  Lbars = let sum=minus_1 in for k in lambda do sum+:=k od
   ,  rise(int a,int len) = [int]: for i:len from a  do i od
   ,  fall(int a,int len) = [int]: for i:len from a ~do i od
then  L_gens = complement(n,Lbars) { for lambda part, do the same as in type A }
   ,  sign_pair(int k,int l) = [int]: { arguments are positions in |[0,m[| }
         rise(n+l,m-1-l)##rise(n+k,m-k) { |m-k-2|, plus 2 final for signs }
       ##fall(n+k,m-2-k)##fall(n+l,m-1-l) { remainder of conjugation }
then  M_gens = { each cycle pair from P gets sign flips when second end sensed }
      let odd=false { parity of number of Mbars elements seen }, k=minus_1 in
      for i:m
      do if isnt_member(Mbars)(i) then [n+i] { extend our cycle }
         elif odd:=not odd
	 then [] next k:=i { break cycle, save index, wait for sign }
	 else sign_pair(k,i) { wrap up two cycles by adding signs }
	 fi
      od.##
in L_gens##M_gens
)

{ word representative in types D of split conjugacy class for partition pair }
set class_word_D(Partition lambda,bool minus) = [int]:
(  assert((lambda:=lambda.strip_to_partition).>, "lambda is not a partition")
;  assert(lambda.is_very_even, "lambda is has odd parts: not a split class")
;  let n=sum(lambda), bars = let sum=minus_1 in for k in lambda do sum+:=k od
in if minus else complement(n,bars) { just have a word for each (even) cycle }
   then complement(n,bars) ## [n-2,n-1] { add adjacent flips in last cycle }
   fi
)

set class_word(D_class c) =  [int]:
   case c
   | unsplit_class(cycles): class_word_D(cycles.to_partition_pair)
   | split_class(lambda_minus): class_word_D(lambda_minus)
   esac


set conjugacy_class_SO(D_class c) = WeylElt:
   let n=rank(c) in W_elt(SO(n+n),class_word(c))

{ for general type D root data, we need to look up and use the diagram order }
set conjugacy_class_D(RootDatum rd) = (D_class->WeylElt):
   let map = test_simple_type("D",rd) then n=#map in
   (D_class cycles) WeylElt:
(  let size = rank(cycles)
in assert(size=n,"Cycles sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word(cycles) do map[s] od)
)

set class_table_D(int n) = WeylClassTable:
   let rd=SO(n+n), classes = [D_class]: D_classes(n)
   then lookup = (D_class->int):
      let ranked = { |ranked[i]| is index in |classes| of class ranked |i| }
         sort(#classes,(int i,int j)bool: classes[i]<=classes[j])
      then list = for i in ranked do classes[i] od
      in (D_class c) int: { index in |classes| where one finds |c| }
         ranked[binary_search_first((int i)bool: c<=list[i], 0,#classes)]
in W_class_table( rd, for class in classes do conjugacy_class_SO(class) od
		, (int i)int: cycle_class_size(classes[i])
		, (WeylElt w)int: lookup(signed_permutation(w).to_D_class)
		, (int i,int k)int: lookup(cycle_power(classes[i],k))
		)

set class_table_D(RootDatum rd) = WeylClassTable:
   let classes = [D_class]: D_classes(rd.semisimple_rank)
   , class_rep = (D_class->WeylElt): conjugacy_class_D(rd)
   then lookup = (D_class->int):
      let ranked = { |ranked[i]| is index in |classes| of class ranked |i| }
         sort(#classes,(int i,int j)bool: classes[i]<=classes[j])
      then list = for i in ranked do classes[i] od
      in (D_class c) int: { index in |classes| where one finds |c| }
         ranked[binary_search_first((int i)bool:c<=list[i], 0,#classes)]
in W_class_table( rd, for class in classes do class_rep(class) od
		, (int i)int: cycle_class_size(classes[i])
		, (WeylElt w)int: lookup(classic_permutation(w).to_D_class)
		, (int i,int k)int: lookup(cycle_power(classes[i],k))
		)


{ all irreducible representations of D_n }
set D_irreps (int n) = [D_irrep]:
   for (lambda,mu):pair
     in pairs_of_total_sum(n,(int k):partitions(k)~[:]) { list [k],..,ones(k) }
   do if not leq_partitions(pair) then [pair.unsplit_irr]
      elif lambda=mu then [(lambda,false).split_irr,(lambda,true).split_irr]
      else []
      fi
   od.##

set character_table_D(int n) = CharacterTable:
   let class_list =  D_classes(n)
   then classes = [WeylElt,classical_class,string]:
      for c in class_list
      do (conjugacy_class_SO(c),c.class_D,c.cycles_string)
      od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in D_irreps(n)
      do ( rep.irrep_D, rep.irrep_string
         , for class in class_list do character(rep,class) od
	 )
      od
in character_table(class_table_D(n),classes,irreps)

set character_table_D(RootDatum rd) = CharacterTable:
   let n=rd.semisimple_rank
   , class_rep = (D_class->WeylElt): conjugacy_class_D(rd)
   then class_list =  D_classes(n)
   then classes = [WeylElt,classical_class,string]:
      for c in class_list do (class_rep(c),c.class_D,c.cycles_string) od
   ,  irreps = [classical_irrep,string,[int]]:
      for rep in D_irreps(n)
      do ( rep.irrep_D, rep.irrep_string
         , for class in class_list do character(rep,class) od
	 )
      od
in character_table(class_table_D(rd),classes,irreps)

{ functions that expect a |CharacterTable| of simple type D }
set split_class_nrs(CharacterTable ct) = [int]:
   for i:ct.n_classes
   do case ct.classes(i) | else []
      | class_D(c):
        case c | else []
        | split_class(x): [ i ]
	esac
      esac
   od.##

set split_rep_nrs(CharacterTable ct) = [int]:
   for i:ct.n_classes
   do case ct.classical_reps(i) | else []
      | irrep_D(rep):
        case rep | else []
	| split_irr(x): [ i ]
	esac
      esac
   od.##

set split_table (CharacterTable ct) = ([classical_irrep],[classical_class],mat):
   let reps = split_rep_nrs(ct), classes = split_class_nrs(ct)
in ( for i in reps do ct.classical_reps(i) od
   , for j in classes do ct.classes(j) od
   , for i in reps do for j in classes do ct.table[i,j] od od
   )
