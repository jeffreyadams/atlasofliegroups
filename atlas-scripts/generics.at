any_type S,T,R begin

set I (T x) = T: x
set constant (T x) = (S .) T: x
set compose ((S->R) g) = ((T->S)f): (T x): R: g(f(x))

set swap (S x,T y) = (T,S): (y,x)

set swapargs ((S,T->R) f) = (T y,S x) R: f(x,y)
set curry    ((S,T->R) f) = (S->(T->R)): (S x): (T y) R: f(x,y)
set uncurry  ((S->(T->R)) f) = (S x,T y) R: f(x)(y)

set curried_swapargs ((S->(T->R)) f) = (T->(S->R)): (T y):(S x) R: f(x)(y)

set foldl (S !start,(S,T->S) op) = ([T]->S):
  ([T] a) S: let v=start in for x in a do v op:= x od; v
  { rec_fun f ([T] a) S: if #a=0 then start else op(f(a[:1~]),a~[0]) fi }

set foldr ((S,T->T) op, T !start) = ([S]->T):
  ([S] a) T: let v=start in for x in a ~do v := op(x,v) od; v
  { rec_fun f ([S] a) T: if #a=0 then start else op(a[0],f(a[1:])) fi }

set combine { lile |foldl|, but nonempty only and with swapped arguments }
  ([T] a) = ((T,T->T) ->T):
  if #a=0 then error("Empty argument to 'combine'")
  else ((T,T->T) op) T: let v=a[0] in for i:#a-1 from 1 do v op:= a[i] od; v
  fi

end
