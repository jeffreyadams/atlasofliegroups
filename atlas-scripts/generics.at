<basic.at

any_type S,T,R begin

set I (T x) = T: x
set K (T x) = (S .) T: x
set compose ((S->R) g) = ((T->S)f): (T x): R: g(f(x))

set fst (S x,T y) = S: x
set snd (S x,T y) = T: y

set swap (S x,T y) = (T,S): (y,x)

set swapargs ((S,T->R) f) = (T y,S x) R: f(x,y)
set curry    ((S,T->R) f) = (S->(T->R)): (S x): (T y) R: f(x,y)
set uncurry  ((S->(T->R)) f) = (S x,T y) R: f(x)(y)

set curried_swapargs ((S->(T->R)) f) = (T->(S->R)): (T y):(S x) R: f(x)(y)

set filter ((T->bool) pred) = ([T]->[T]):
  ([T] r): for x in r if pred(x) do x fi od

set map ((S->T) f) = ([S] a) [T]: for x in a do f(x) od

set split ([S,T] l) = ([S],[T]): ( for(s,)in l do s od, for(,t)in l do t od )

set zip ([S] a,[T] b) = [S,T]:
  if #a<=#b then for x@i in a do (x,b[i]) od else for y@i in b do (a[i],y) od fi

set transpose ([[T]] rr) = [[T]]:
  for i: min(map(#@t([t]))(rr)) do for r in rr do r[i] od od

set foldl (S !start,(S,T->S) op) = ([T]->S):
  ([T] a) S: let v=start in for x in a do v:=op(v,x) od; v
  { rec_fun f ([T] a) S: if #a=0 then start else op(f(a[:1~]),a~[0]) fi }

set foldr ((S,T->T) op, T !start) = ([S]->T):
  ([S] a) T: let v=start in for x in a ~do v:=op(x,v) od; v
  { rec_fun f ([S] a) T: if #a=0 then start else op(a[0],f(a[1:])) fi }

end
