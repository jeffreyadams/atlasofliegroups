<painted_partitions.at
<weak_packets.at

{S is a subset of pp(O_v,label), i.e. an element of A_bar}
set_type ExtendedPaintedBiPartition=(Orbit O_v,PaintedBiPartition Z,[int] S)

{Nilpotent orbits via Barbasch-Ma-Sun-Zhu}
{type Orbit=Partition=[int]}

{G: group of type label=B,C,D
 P: partition for orbit of DUAL group: C,B,D
 G   G^v   condition
 B   C     even rows
 C   B     odd rows
 D   D     odd rows
} 
set is_good_parity(Orbit P, string label)=bool:
if label="A"
 then all(for row in P do is_even(row-size(P)) od)
elif label="A!"
 then all(for row in P do is_odd(row-size(P)) od)
elif is_in(label,["C","C*","D","D*"])  
 then all(for row in P do is_odd(row) od)
elif is_in(label,["B","B+","B-","C~"]) 
 then all(for row in P do is_even(row) od)
else
 error("missing case")
fi

set all_partitions(int n,string label)=[Orbit]:
if is_in(label,["B","D","D*"]) then BD_partitions(n)
elif is_in(label,["C","C~","C*"]) then C_partitions(n)
else
error("missing case")
fi

set good_parity_partitions(int n, string label)=
 {(n,C) -> G=Sp(2n) -> orbits for  G^v=SO(2n+1) -> BD_partitions(2*n+1)
  (n,D) -> G=SO(2n) -> orbits for G^v=SO(2n) -> BD_partitions(2n)
  (n,B) -> G=SO(2n+1) -> orbits for G^v=Sp(2n) -> C_partitions(2n)
  }
if is_in(label,["C","C*"]) then
 for P in  BD_partitions(2*n+1) do if is_good_parity(P,label) then [P] else [] fi od.##
elif is_in(label,["D","D*"]) then
 for P in  BD_partitions(2*n) do if is_good_parity(P,label) then [P] else [] fi od.##
elif is_in(label,["B","B+","B-","C~"]) then
 for P in  C_partitions(2*n) do if is_good_parity(P,label) then [P] else [] fi od.##
else
 error("missing case in good_parity_partitions")
fi

{numerology of extracting all rows with even/odd index (not the length of the row)
Suppose for example  n=#P=6 =[a0,a1,...,a5]
 even index rows: 1,3,5:  {2i+1 | i=0,1,2} i.e. i=0,1,...(n-1)\2=(n-2)\2
 odd index rows:  0,2,4   {2i   | i=0,1,2} i.e. i=0,1,...(n-1)\2

Suppose for example n=#P=7 = [a0,a1,...,a6]
 Even index rows: 1,3,5:   {2i+1| i=0,1,2}   i.e. i=0,1,..,(n-2)\2
 odd index rows:  0,2,4,6: {2i  | i=0,1,2,3} i.e. i=0,1,..,(n-1)\2
}

{rows are numbered 0,1,2,...,#P-1
 odd_index_rows are rows #0,2,...
 even_index_rows are rows #1,3,5,...
}
set even_index_rows(Orbit P)=Orbit:for i:(#P-2)\2+1 do P[2*i+1] od
set odd_index_rows(Orbit P)=Orbit:for i:(#P-1)\2+1 do P[2*i] od

{Definition 3.7: dual orbit -> pair of partitions <-> Weyl group representation}
set left_diagram(Orbit P, string bi_label)=Partition:
let left=
 if label_of(bi_label)="B" then  {P has even rows}
 for row in even_index_rows(P) do h(row) od
elif bi_label="C~" then  {P has even rows}
 for row in odd_index_rows(P) do h(row) od
elif is_in(bi_label,["C","C*"]) then  {P has odd rows}
 {all odd index rows except the last row if n=#P is odd,
  last row is row #n (odd) which = P[n-1], n-1 is even,
  so this is an even_index_row}
 let temp=for row in even_index_rows(P) do h(row+1) od in
 if 2*#temp-1=#P then temp[:#temp-1] else temp fi
{ if is_odd(#P) then temp[:#temp-1] else temp fi}
elif is_in(bi_label,["D","D*"]) then {P has odd rows and #P is even}
 if #P=0 then [0] else
  for i:#P\2 do   
   if i=0
    then if P[0]=0 then 0 else h(P[0]+1)
   fi
  else {prints("i", i, ", ", P[2*i]);} h(P[2*i]+1) fi od
 fi
else
 error("case not found")
fi
in transpose(left)

set right_diagram(Orbit P, string bi_label)=Orbit:
let right=
if label_of(bi_label)="B" then  {P has even rows}
 for row in odd_index_rows(P) do h(row) od
elif bi_label="C~" then  {P has even rows}
 for row in even_index_rows(P) do h(row) od
elif is_in(bi_label,["C","C*"]) then  {P has odd rows}
 for row in odd_index_rows(P) do h(row-1) od
elif is_in(bi_label,["D","D*"]) then {P has odd rows}
 if #P=0 then [0]
  else for i:#P\2 do  h(P[2*i+1]-1) od
 fi
else
 error("case not found")
fi
in transpose(right)

{diagram pair: orbit O^v -> bipartition for G of type label}
{e.g. diagram_pair([3,1,1],"C"): [3,1,1] is an orbit for SO(5) -> pair of partitions for Sp(4)}
set diagram_pair(Orbit dual_orbit,string label_for_G)=(Partition,Partition):
(left_diagram(dual_orbit,label_for_G),right_diagram(dual_orbit,label_for_G))

set left_valid_painted_partitions(int n,string label)=[PaintedPartition]:
let valid=for P in painted_partitions(n) do
 if is_valid_left(P,label) then [P] else [] fi od.##
in if #valid=0 then [null_painted_partition] else valid fi

set left_valid_painted_partitions(Partition P,string label)=[PaintedPartition]:
for Z in painted_partitions(size(P)) do
  if is_valid_left(Z,label) and partition(Z)=P then [Z] else [] fi od.##

set right_valid_painted_partitions(int n,string label)=
for P in painted_partitions(n) do
 if is_valid_right(P,label) then [P] else [] fi od.##

set right_valid_painted_partitions(Partition P,string label)=
for Z in painted_partitions(size(P)) do
  if is_valid_right(Z,label) and partition(Z)=P then [Z] else [] fi od.##

{label: type of G, orbit is for G^v}
set complex_group(Orbit O_v,string label)=RootDatum:
if is_in(label,["B","C~"]) then SO(2*#O_v+1)
elif is_in(label,["C","C*"]) then Sp(2*#O_v-1)
elif is_in(label,["D","D*"]) then SO(2*#O_v)
else
error("case not implemented yet")
fi

set find = find(=@(GroupDatum,GroupDatum))
{assume each PaintedBiPartition has same label and size;
 ->  [GroupData]=[G_0,...,G_n] 
 return [int]: #times G_i occurs as group_datum
 for example if list=[PaintedBiPartition] each of type C* and rank 2
 then [GroupData]=[("Sp",2,0),("Sp",1,1),("Sp",0,2)]
 return value [a,b,c] gives the number of times each GroupDatum occurs}
set collated_group_data([PaintedBiPartition] list)=([GroupDatum],[int]):
if #list=0 then ([],[]) else
 let rank=size(list[0]) then
 bi_label=list[0].bi_label then
 group_data=all_group_data(rank,bi_label) then
 rv=null(#group_data) in
 for Z in list do
  let j=find(group_data,group_datum(Z)) in
  rv[j]+:=1
 od;(group_data,rv)
fi

set show_collated_group_data([PaintedBiPartition] list)=void:
let (groups,numbers)=collated_group_data(list) in
for G@i in groups do 
prints(group_name(G), " ", numbers[i]) od

set nilpotent_info(RootDatum G)=void:
show_orbits_and_reps(G);
print_nilpotent_orbit_partitions(G);
show_orbits_and_reps(dual(G));
print_nilpotent_orbit_partitions(dual(G))

set add_one(Partition P)=Partition:P[0]+:=1;P
set subtract_one(Partition P)=Partition:P~[0]-:=1;P

set dual(Partition P, string label)=
if #P=0 then [] 
elif is_in(label,["B","B+","B-"]) then  {see springer_table_B.at}
B_to_C_dual(P) 
elif is_in(label,["C","C*"]) then
C_to_B_dual(P)
elif is_in(label,["C~"]) then  {NOT SURE ABOUT THIS}
C_to_B_dual(P) 
elif is_in(label,["D","D*"]) then 
let (Q,)=D_dual(P,true) in Q  {see springer_table_D.at}
else
error("(dual) only types BCD") 
fi

{dual orbit, label is for G -> orbit for G^v}
set dual_orbit_by_search(Partition P,Partition Q, string label)=Orbit:
let orbits= ##for orbit in good_parity_partitions(rank(P,Q), label) do
 if diagram_pair(orbit,label)=(P,Q) then [orbit] else [] fi od
in assert(#orbits<2,"orbit function returned >1 orbit");
assert(#orbits>0,"orbit function returned no orbits");
orbits[0]

set orbit_by_search(Partition P,Partition Q, string label)=Orbit:
dual(dual_orbit_by_search(P,Q,label),label) 

{dual orbit, label is for G -> orbit for G^v}
set dual_orbit(Partition P,Partition Q, string label)=Orbit:  {should only be one Orbit}
if is_in(label,["C","C*"]) then dual(orbit_C(P,Q),"C")
elif is_in(label,["B","B+","B-"]) then dual(orbit_B(P,Q),"B")
elif is_in(label,["D","D*","C~"]) then
 dual_orbit_by_search(P,Q,label)
else
 error("(dual_orbit) missing case")
fi
set dual_orbit(PaintedPartition P,PaintedPartition Q,string label)=Orbit:dual_orbit(P.partition,Q.partition,label)
set orbit(BiPartition (P,Q), string label)=dual_orbit(P,Q,label)
set dual_orbit(BiPartition (P,Q), string label)=dual_orbit(P,Q,label)

set orbit_by_search(Partition P,Partition Q, string label)=Orbit:
let orbits= ##for orbit in good_parity_partitions(rank(P,Q), label) do
 if diagram_pair(orbit,label)=(P,Q) then [dual(orbit,label)] else [] fi od
in assert(#orbits<2,"orbit function returned >1 orbit");
assert(#orbits>0,"orbit function returned no orbits");
orbits[0]

set orbit(Partition P,Partition Q, string label)=Orbit:
if is_in(label,["C","C*"]) then orbit_C(P,Q)
elif is_in(label,["B","B+","B-"])  then orbit_B(P,Q)
elif is_in(label,["D","D*","C~"]) then
 orbit_by_search(P,Q,label)
else
 error("(orbit) only types BCD")
fi
set orbit(PaintedPartition P,PaintedPartition Q,string label)=Orbit:orbit(P.partition,Q.partition,label)
set orbit(BiPartition (P,Q), string label)=orbit(P,Q,label)
set orbit(PaintedBiPartition Z)=orbit(Z.P,Z.Q,Z.label)

set painted_bi_partitions(Orbit O_vee,string label_for_G)=[PaintedBiPartition]:
let (left,right)=diagram_pair(O_vee,label_for_G) in
##for P in left_valid_painted_partitions(left,label_for_G) do
 ##for Q in right_valid_painted_partitions(right,label_for_G) do
  if is_valid(P,Q,label_for_G) then [(P,Q,label_for_G)] else [] fi
 od
od

set painted_bi_partitions(int n, string label)=[PaintedBiPartition]:
##for orbit in good_parity_partitions(n,label) do painted_bi_partitions(orbit,label) od

{this depends on the bi_label}
{NOTE: is_valid(P,Q,bi_label)=true does not imply the dual_orbit(P,Q,bi_label) is good parity.
 For example
atlas> A
Value: ([[0]],[[0,1]],"C")
atlas> is_valid(A)
Value: true
atlas> dual_orbit(A)
Value: [[3,2,2]]  {this is not good parity}
This rarely fails - perhaps it should always be true, and is_valid is not quite correct
NOTE: DANGEROUS BEND
}
set painted_bi_partitions_given_bi_label_old(int left, int right, string bi_label)=[PaintedBiPartition]:
let left_valid=left_valid_painted_partitions(left,bi_label) then
right_valid=right_valid_painted_partitions(right,bi_label) then
label=label_of(bi_label) in
##for P in left_valid do
 ##for Q in right_valid do
  let dual_orbit=dual_orbit(P,Q,bi_label) in 
{  if is_valid(P,Q,bi_label) {and is_good_parity(dual_orbit(P,Q,bi_label)[0],bi_label)} then [(P,Q,bi_label)] else [] fi od od}
  if is_valid(P,Q,bi_label)
   and is_good_parity(dual_orbit,bi_label)
   and not(size(dual_orbit)=0 and left+right>0)    {if dual orbit is empty but left+right \ne 0 then reject}
then [(P,Q,bi_label)] else [] fi od od

{usually specify label, not bi_label: same except in case B take the union of B+,B-}
set painted_bi_partitions_old(int left,int right, string label)=[PaintedBiPartition]:
if label="B" then
 painted_bi_partitions_given_bi_label_old(left,right,"B+")##painted_bi_partitions_given_bi_label_old(left,right,"B-")
 else  painted_bi_partitions_given_bi_label_old(left,right,label) fi

set painted_bi_partitions_given_bi_label_old(int n, string bi_label)=[PaintedBiPartition]:
for i:n+1 do painted_bi_partitions_given_bi_label_old(i,n-i,bi_label) od.##

set painted_bi_partitions_old(int n, string label)=[PaintedBiPartition]:
if label="B" then
 painted_bi_partitions_given_bi_label_old(n,"B+")##painted_bi_partitions_given_bi_label_old(n,"B-")
 else  painted_bi_partitions_given_bi_label_old(n,label) fi

{(O_v,label) -> diagram_pair (Left,Right)
Note: label (not bi_label)
-> set of painted bi partions (P,Q,label) with partition(P)=Left, partition(Q)=right
where label(bi_label)=label
}
set painted_bi_partitions_old(Orbit O_v, string label)=[PaintedBiPartition]:
let (left,right)=diagram_pair(O_v,label) in
let n=
if is_in(label,["C","C*"]) then {G=Sp(2n),G_v=SO(2n+1) size(O_v)=2n+1}
 h(size(O_v)-1)
elif is_in(label,["B","C~"]) then {G=SO(2n+1) G_v=Sp(2n) 2n=size(O_v)}
 h(size(O_v))
elif is_in(label,["D","D*"]) then {SO(2n)}
 h(size(O_v))
else
error("case not implemented yet")
fi
{in let ()=prints("n=", n)  then} in let
all = painted_bi_partitions_old(n,label) in
for Z in all do if partition(Z.P)=left and partition(Z.Q)=right then [Z] else [] fi od.##

set pbp(Orbit O_v, string label)=[PaintedBiPartition]:painted_bi_partitions(O_v,label)
set pbp(GroupDatum G,Orbit O_v, string label)=[PaintedBiPartition]:
##for Z in pbp(O_v,label) do
 if group_datum(Z)=G then [Z] else [] fi od
set number_pbp(Orbit O_v,string label)=int:#pbp(O_v,label)
set number_pbp(GroupDatum G,Orbit O_v, string label)=int:#pbp(G,O_v,label)


{see (3.8)}
set pbp_ext(Orbit O_v,string label)=([PaintedBiPartition],[[int]]):
if is_in(label,["B","C","D","C~"])
 then (pbp(O_v,label),A_bar(O_v,label))
 else (pbp(O_v,label),[[int]]:[[]])
fi

set pbp_ext(GroupDatum G,Orbit O_v,string label)=([PaintedBiPartition],[[int]]):
if is_in(label,["B","C","D","C~"])
 then (pbp(G,O_v,label),A_bar(O_v,label))
 else (pbp(G,O_v,label),[[int]]:[[]])
fi



{Note:
orbit for G^v -> (P,Q) diagram_pair(orbit,label_for_G) -> dual_orbit(P,Q,diagram_for_G) = orbit
for orbit in good_parity_partitions (4,"C") do dual_orbit(diagram_pair(orbit,"C"),"C")[0]=orbit od
}

set confirm(int n,string label_for_G)=bool:
all(for orbit in good_parity_partitions (n,label_for_G) do dual_orbit(diagram_pair(orbit,label_for_G),label_for_G)=orbit od)

set test (int n, string label)=
let good=good_parity_partitions(n,label) then
pairs=for P in good do diagram_pair(P,label) od in
tabulate(
for pair@i in pairs do
[i.to_string,good[i].to_string,pair.to_string,orbit(pair,label).to_string, dual_orbit(pair,label).to_string] od)

set show(PaintedBiPartition (P,Q,bi_label))=void:
prints(P, " ", Q, " ", bi_label, " ", group_name(P,Q,bi_label), " ", orbit(P,Q,bi_label), " ", dual_orbit(P,Q,bi_label))

set show([PaintedBiPartition] list)=void:
tabulate(
["P","Q","bi-label","group","orbit","dual orbit"]#
for (P,Q,bi_label) in list do
 [P.to_string,Q.to_string,bi_label,group_name(P,Q,bi_label),orbit(P,Q,bi_label).to_string,dual_orbit(P,Q,bi_label).to_string] od)

set show([[PaintedBiPartition]] list)=void:
for chain@i in list do
prints("==========================",new_line, "i=", i);
show(chain)
od

set show_long(PaintedBiPartition (P,Q,bi_label))=void:
prints("bi_label:", bi_label);
prints("painted partition P:");show_painted_partition(P);
prints("<<<<<<<<<<<<<<<<<<<<<<<<<<<",new_line,"painted partition Q:");show_painted_partition(Q);
prints(">>>>>>>>>>>>>>>>>>>>>>>>>>>")

set show_long([PaintedBiPartition] list)=void:
for Z in list do prints("lkjlkjlkj",new_line,Z);show(Z) od

set show_short(PaintedBiPartition (P,Q,bi_label))=void:
prints(P, " ", Q, " ", bi_label, " ", group_name(P,Q,bi_label), " ", orbit(P,Q,bi_label))

set show_short([PaintedBiPartition] list)=void:
tabulate(for (P,Q,bi_label) in list do
 [P.to_string,Q.to_string,bi_label,group_name(P,Q,bi_label),orbit(P,Q,bi_label).to_string] od)


set number_unipotent(Orbit O_v,string label)=int:
if label="B" or label="D" and size(O_v)=0
 then 2*number_pbp(O_v,label)*A_bar_order(O_v,label)
 else number_pbp(O_v,label)*A_bar_order(O_v,label)
fi

set number_unipotent(GroupDatum G,Orbit O_v,string label)=int:
number_pbp(G,O_v,label)*A_bar_order(O_v,label)

set report(Orbit O_v,string label)=void:
let bi_partitions=pbp(O_v,label) then
A_bar_order=A_bar_order(O_v,label) in 
prints("Orbit: ", O_v, new_line,
"#painted bi_partitions: ", #bi_partitions, new_line,
"#A_bar: ", A_bar_order,new_line,
"#unipotents: ", #bi_partitions*A_bar_order,new_line,
"#representations by group:");
show_collated_group_data(bi_partitions)

{get rid of the rank entry, shouldn't need it; only for the collated_group_data}
set report([Orbit] orbits,string bi_label, int rank )=void:
prints("pbp=#painted bi_partitions",new_line,"pp= #primitive indices+1");
tabulate(
["orbit","pbp","pp","#unip","reps by group"]#for orbit@i in orbits do
let pbp=pbp(orbit,bi_label) in
let number=2^number_primitive(orbit,bi_label) then
(,groups)=collated_group_data(pbp) in
[to_string(orbit),to_string(#pbp), to_string(number), to_string(number*#pbp),to_string(groups)] od);
prints("Groups:");for G in all_group_data(rank,bi_label) do prints(group_name(G)) od

set report(GroupDatum G,[Orbit] orbits,string label)=void:
prints("pbp=#painted bi_partitions",new_line,"pp= #primitive indices+1");
tabulate(
["orbit","pbp","pp","#unip","groups"]#for orbit@i in orbits do
let pbp_all=pbp(orbit,label) then
pbp=for Z in pbp_all do if group_datum(Z)=G then [Z] else [] fi od.##  then
number=2^number_primitive(orbit,label) then
(,groups)=collated_group_data(pbp) in
[to_string(orbit),to_string(#pbp), to_string(number), to_string(number*#pbp, to_string(groups))] od)

set report(int n,string label)=report(good_parity_partitions(n,label),label,n)

set report(GroupDatum G,int n,string label)=void:
let ()=prints("G: ", group_name(G) ) then
orbits=good_parity_partitions(n,label) in report(G,orbits,label)

set show_short(([ComplexNilpotent] orbits,[([([Param],[WCell])],[(int,int,Param)])] blocks_and_cells_and_packets,(ComplexNilpotent->Partition) partition_function))=void:
let packets=for (,packet) in blocks_and_cells_and_packets do packet od then
grand_total=0 then
blocks=blocks(packets) then
cells=cells(packets) then
m=mult(packets) in
tabulate(
 ["orbit","partition","gamma","|packet|"]#
 ##for i:#packets do
  let total=sum(for b in blocks do sum(for c in cells do m(i,b,c) od) od)
 in if total!=0 then grand_total+:=total;[[i.to_string,partition_function(orbits[i]).to_string,(orbits[i].H/2).to_string,total.to_string]] else [] fi
od
#["Total","","",grand_total.to_string]
);prints()



set bmsz(Partition P,string label)=let Z=painted_bi_partitions(P,label)[0] in (Z.P.partition,Z.Q.partition) 
set test_bmsz(Partition P, string label)=
bmsz(P,label)=wrep(dual_orbit(P))


set bmsz_pair(Orbit O,string label)=
let bp=painted_bi_partitions(O,label) then
Z=bp[0] then
pair=(Z.P.partition,Z.Q.partition) in 
prints("Z=",Z,new_line,"partition pair=",pair)

set bmsz_pairs(int n,string label)=
let good=good_parity_partitions(n,label) then
list=for orbit in good do painted_bi_partitions(orbit,label) od in
tabulate(["orbit","dual","bipartition","partition-pair"]#
for orbit@i in good do
 let Z=list[i][0] then
 pair=(Z.P.partition,Z.Q.partition)  in
[orbit.to_string,dual_orbit(orbit).to_string,Z.to_string,pair.to_string] od)

set orbit_info(RootDatum G)=void:
show_orbits_and_reps(G);
print_nilpotent_orbit_partitions(G)

set partition_of_orbit_D_weak(ComplexNilpotent orbit)=Partition:
let (P,)=partition_of_orbit_D(orbit) in P

set choose_dual_partition_function(RootDatum G)=
{handles SL(2), SO(3) separately}
let (type,)=simple_factors(Lie_type(G))[0] in
if G=SL(2,R) then prints("OK");partition_of_orbit_B@ComplexNilpotent
elif G=SO(3,0) or G=SO(2,1) or G=SO(1,2) or G=SO(0,3) then partition_of_orbit_D_weak@ComplexNilpotent
else 
if type="B" then partition_of_orbit_C@ComplexNilpotent
  elif type="C" then partition_of_orbit_B@ComplexNilpotent
  elif is_in(type,["D","A"]) then  partition_of_orbit_D_weak@ComplexNilpotent  {SO(4) and SO(6)}
  else error("missing case in choose_dual_partition_function")
fi
fi

set show_short(RealForm G,(ComplexNilpotent->Partition) partition_function)=void:
let orbits=dual_orbits(G) then
wp=weak_packets(G) in
show_short(orbits,wp,partition_function)

set show_short(RealForm G)=show_short(G,choose_dual_partition_function(G))
