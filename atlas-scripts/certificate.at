{hasn't been updated to work with FPP_global}
<basic.at
<K_types.at { for |int_part@KTypePol|, |s_part@KTypePol| }
<hermitian.at
<to_ht.at
<facetious.at

{For hermitian parameter p, decide whether the irreducible is unitary;
if not, find the K-types of minimal height on which the form is negative}
set nonunitarity_certificate(Param p)=(bool,[KType]):
(  let P=hermitian_form_irreducible(p), ht_p=height(p)
   then c=first_K_type(P)
   then a= #(!=int_part(c)), b=#(!=s_part(c)) { each one 0 or 1 }
   , ht_lim=ht_p { to ensure monotonicity }
in if a*b=1 then prints("The LKT is indefinite.") fi
;  let list=
   for k@q in P
   do let npart = int: b*int_part(k)+a*s_part(k) { |s_part(k*(a+b*s))| }
   ,  ht_q = height(q)
   in if npart!=0 and
        (ht_q=ht_p or
	 ht_q>ht_p and ht_q>=ht_lim and (ht_lim:=ht_q; true)
	)
      then [q]
      else []
      fi
   od.##
in if #list=0 then (true,[])
   else let kt=list[0] then n=height(kt)
       then short_list=##for mu in list
                         do if height(mu)=n then [mu] else [] fi
			 od
      in (false,short_list) fi
)

set nonunitarity_certificate_with_ht(Param p)=(bool,[(KType,int)]):
(  let P=hermitian_form_irreducible(p), ht_p=height(p)
   then c=first_K_type(P)
   then a= #(!=int_part(c)), b=#(!=s_part(c)) { each one 0 or 1 }
   , ht_lim=ht_p { to ensure monotonicity }
in if a*b=1 then prints("The LKT is indefinite.") fi
;  let list=
   for k@q in P
   do let npart = int: b*int_part(k)+a*s_part(k) { |s_part(k*(a+b*s))| }
   ,  ht_q = height(q)
   in if npart!=0 and
        (ht_q=ht_p or
	 ht_q>ht_p and ht_q>=ht_lim and (ht_lim:=ht_q; true)
	)
      then [(q,ht_q)]
      else []
      fi
   od.##
in if #list=0 then (true,[])
   else let (kt,n)=list[0]
       then short_list=##for (mu,k) in list
                         do if k=n then [(mu,k)] else [] fi
			 od
      in (false,short_list) fi
)

set nonunitarity_certificate_to_ht(Param p,int N)=(bool,[KType]):
(  let P=hermitian_form_irreducible_to_ht(p,N), ht_p=height(p)
   then c=first_K_type(P)
   then a= #(!=int_part(c)), b=#(!=s_part(c)) { each one 0 or 1 }
   , ht_lim=ht_p { to ensure monotonicity }
in if a*b=1 then prints("The LKT is indefinite.") fi
;  let list=
   for k@q in P
   do let npart = int: b*int_part(k)+a*s_part(k) { |s_part(k*(a+b*s))| }
   ,  ht_q = height(q)
   in if npart!=0 and
        (ht_q=ht_p or
	 ht_q>ht_p and ht_q>=ht_lim and (ht_lim:=ht_q; true)
	)
      then [q]
      else []
      fi
   od.##
in if #list=0 then (true,[])
   else let kt=list[0] then n=height(kt)
       then short_list=##for mu in list
                         do if height(mu)=n then [mu] else [] fi
			 od
      in (false,short_list) fi
)

{For each vertex v of the FPP, display the nonunitarity certificate of
the principal series at infinitesimal character v with lambda=rho+lam}
set show_certificates_ps (RealForm G,vec lam)=void:
   let ics=FPP_vertices(G,-1),x=x_open(G)
   in for v in ics
      do let p=parameter(x,rho(G)+lam,v)
      in {if not is_hermitian(p) then prints("p is not hermitian")}
         if not is_final(p) then prints("p is not final")
         elif is_hermitian(p) then let (b,c)=nonunitarity_certificate_with_ht(p)
	 in if not b then prints(new_line,v);
	               for (kt,ht) in c
	               do prints(kt,"    ",ht) od
            {else prints("p is unitary")}
	    fi
	 fi
      od

set show_certificates_spherical (RealForm G)=void:
    show_certificates_ps(G,ratvec_as_vec(rho(G)*0))

{Make a list of K-types which occur in nonunitarity certificates for
principal series with infinitesimal character a FPP vertex and lambda=rho+lam}
set certificate_list_ps (RealForm G,vec lam)=[KType]:
   let ics=FPP_vertices(G,-1),x=x_open(G)
   then result=[KType]:[]
   in for v in ics
       do let p=parameter(x,rho(G)+lam,v)
          in if is_hermitian(p) and is_final(p)
	     then let (b,kts)=nonunitarity_certificate(p)
	          in if not b then for kt in kts
	                           do if find(result,kt)=-1 then result#:=kt
			              fi
				   od
                     fi
	     fi
	od;
    result

set certificate_list_facets (RealForm G)=[KType]:
    let ics=FPP_barycenters(G,-1),x=x_open(G)
    then result=[KType]:[]
     in for list in ics
        do for v in list
           do let p=parameter(x,rho(G),v)
              in if is_hermitian(p) and is_final(p)
	          then let (b,kts)=nonunitarity_certificate(p)
	               in if not b then for kt in kts
	                           do if find(result,kt)=-1 then result#:=kt
			              fi
				   od
                          fi
	         fi
	    od
	od;
    result

{List of K-types occurring in nonunitarity certificates of spherical
representations for a given list ics of infinitesimal characters}
set certificate_list (RealForm G, [ratvec] ics)=[KType]:
    let x=x_open(G)
    then result=[KType]:[]
     in for v in ics
        do let p=parameter(x,rho(G),v)
            in if is_hermitian(p) and is_final(p)
	       then let (b,kts)=nonunitarity_certificate(p)
	             in if not b then for kt in kts
	                               do if find(result,kt)=-1 then result#:=kt
			                  fi
				       od
                        fi
	        fi
	od;
    result

set certificate_list_spherical(RealForm G)=[KType]:
       certificate_list_ps(G,ratvec_as_vec(rho(G)*0))

set show_certificates_facets (RealForm G)=void:
   let ics=FPP_barycenters(G,-1),x=x_open(G)
   in for list in ics
      do for v in list
         do let p=parameter(x,rho(G),v)
         in {if not is_hermitian(p) then prints("p is not hermitian")}
            if not is_final(p) then prints("p is not final")
            elif is_hermitian(p) then let (b,c)=nonunitarity_certificate_with_ht(p)
	                              in if not b then prints(new_line,v);
	                                    for (kt,ht) in c
	                                    do prints(kt,"    ",ht)
					    od
	                                 fi
	    fi
	 od
      od

set show_certificates_facets (RealForm G,int bd)=void:
   let ics=FPP_barycenters(G,-1),x=x_open(G)
   in for list in ics
      do for v in list
         do let p=parameter(x,rho(G),v)
         in {if not is_hermitian(p) then prints("p is not hermitian")}
            if not is_final(p) then prints("p is not final")
            elif is_hermitian(p) then let (b,c)=nonunitarity_certificate_with_ht(p)
	                              in if not b then let (,h)=c[0]
				                       in if h>=bd
						          then prints(new_line,v);
	                                                    for (kt,ht) in c
	                                                    do prints(kt,"    ",ht)
					                    od
							   fi
	                                 fi
	    fi
	 od
      od

{Create a list of infinitesimal characters for Sp(2n,R) of the form
  (a,b,c)/den with a \le n*den}
set ic_list (int n,int den)=[ratvec]:
   let m=n*den+1
   then alph= ##for i:m do for j:n do m-i-1 od od
   then result=[ratvec]:[]
   in for v in choices_from(alph,n)
       do if find (result,v/den)=-1 then result#:=v/den fi od;
       result
