<basic.at
<K_types.at { for |int_part@KTypePol|, |s_part@KTypePol| }
<hermitian.at
<to_ht.at
<K_highest_weights.at
<Kcone.at

{Decide whether a parameter is unitary; if hermitian nonunitary, find K-types
of minimal height with negative signature}
set nonunitarity_certificate(Param p)=(bool,[KType]):
(  let P=hermitian_form_irreducible(p), ht_p=height(p)
   then c=first_K_type(P)
   then a= #(!=int_part(c)), b=#(!=s_part(c)) { each one 0 or 1 }
   , ht_lim=ht_p { to ensure monotonicity }
in if a*b=1 then prints("The LKT is indefinite.") fi
;  let list=
   for k@q in P
   do let npart = int: b*int_part(k)+a*s_part(k) { |s_part(k*(a+b*s))| }
   ,  ht_q = height(q)
   in if npart!=0 and
        (ht_q=ht_p or
	 ht_q>ht_p and ht_q>=ht_lim and (ht_lim:=ht_q; true)
	)
      then [q]
      else []
      fi
   od.##
in if #list=0 then (true,[])
   else let kt=list[0] then n=height(kt)
       then short_list=##for mu in list
                         do if height(mu)=n then [mu] else [] fi
			 od
      in (false,short_list) fi
)

set nonunitarity_certificate_with_ht(Param p)=(bool,[(KType,int)]):
(  let P=hermitian_form_irreducible(p), ht_p=height(p)
   then c=first_K_type(P)
   then a= #(!=int_part(c)), b=#(!=s_part(c)) { each one 0 or 1 }
   , ht_lim=ht_p { to ensure monotonicity }
in if a*b=1 then prints("The LKT is indefinite.") fi
;  let list=
   for k@q in P
   do let npart = int: b*int_part(k)+a*s_part(k) { |s_part(k*(a+b*s))| }
   ,  ht_q = height(q)
   in if npart!=0 and
        (ht_q=ht_p or
	 ht_q>ht_p and ht_q>=ht_lim and (ht_lim:=ht_q; true)
	)
      then [(q,ht_q)]
      else []
      fi
   od.##
in if #list=0 then (true,[])
   else let (kt,n)=list[0]
       then short_list=##for (mu,k) in list
                         do if k=n then [(mu,k)] else [] fi
			 od
      in (false,short_list) fi
)

set nonunitarity_certificate_to_ht(Param p,int N)=(bool,[KType]):
(  let P=hermitian_form_irreducible_to_ht(p,N), ht_p=height(p)
   then c=first_K_type(P)
   then a= #(!=int_part(c)), b=#(!=s_part(c)) { each one 0 or 1 }
   , ht_lim=ht_p { to ensure monotonicity }
in if a*b=1 then prints("The LKT is indefinite.") fi
;  let list=
   for k@q in P
   do let npart = int: b*int_part(k)+a*s_part(k) { |s_part(k*(a+b*s))| }
   ,  ht_q = height(q)
   in if npart!=0 and
        (ht_q=ht_p or
	 ht_q>ht_p and ht_q>=ht_lim and (ht_lim:=ht_q; true)
	)
      then [q]
      else []
      fi
   od.##
in if #list=0 then (true,[])
   else let kt=list[0] then n=height(kt)
       then short_list=##for mu in list
                         do if height(mu)=n then [mu] else [] fi
			 od
      in (false,short_list) fi
)

{Like K_types (in K_highest_weights.at), but return empty list in case of
error}
set K_types_no_error (KHighestWeight(,x,v):mu_in)= [KType]:
   let G=real_form(x)
   then Q=parabolic_LKT(mu_in)
in assert(is_parabolic_theta_stable(Q), "Q is not theta stable");
   let x_Q=x_min(Q)
   then list=for wt in R_K_dom_mu_orbit(mu_in) do move_weight(wt,x_Q) od
   then test=for weight in list do inds(weight) od
   then good_mu_list=choose_irred_inds(test)
   then k=#good_mu_list
   in if k=0 then prints("No suitable weight in R-group orbit");[]
      else  ##for p in good_mu_list[0]
              do if any(for wt in highest_weights(K_type(p[0]))
                      do move_weight(wt,x_Q)=move_weight(mu_in,x_Q) od)
                 then [K_type(p[0])]
                 else []
                 fi
              od
      fi

{Calculate bottom layer map by adding rho(u) to lambda; this is to
test whether this function gives the right answer}
set bottom_layer_map_by_param (KType mu_L,KGPElt P)=[KType]:
   let G=real_form(P)
   then x=embed_KGB(mu_L.x,G),v=lambda(mu_L)+rho_u(P)-rho(G)
   then kt=K_type(x,ratvec_as_vec(v))
   in if is_dominant(kt) and not is_zero(kt) then [kt] else [] fi

set bottom_layer_map_alt (KType mu_L,KGPElt P)=KType:
   let G=real_form(P)
   then x=embed_KGB(mu_L.x,G),v=lambda(mu_L)+rho_u(P)-rho(G)
   in K_type(x,ratvec_as_vec(v))

set test_bottom_layer (Param p,int N)=void:
   let (P,q)=theta_stable_quasi_data(p),h=height(p)
   then hq=height(q)
   then Q=branch_irr(p,h+N), QL=branch_irr(q,hq+N)
   in for m@i in monomials(QL)
      do let kt=bottom_layer_map_alt(m,P) in
             if is_zero(kt) then prints(i," ",m," Zero K-type")
             elif is_dominant(kt) then prints(i," ",m," ",(true,Q[kt]!=0))
	     else prints(i," ",m," ",
	         (false,all(for mu in monomials(standardize(kt)) do Q[mu]!=0 od))) fi
      od

set test_bl_function ([[KType]] kts)=bool:
   let n=#kts
   in if n<=1 then true
   else let b=all(for kt in kts[0] do all(for list in kts do find(list,kt)>-1 od) od)
        in b
   fi

{Bottom layer map by adding 2rho(u\capp) to the highest weight; in the
disconnected case this may yield multiple K-types with the same highest weight}
set bottom_layer_map_by_hwt (KType mu_L,KGPElt P)=[KType]:
   let G=real_form(P)
   then wts=for (,x_L,v) in highest_weights(mu_L)
            do let x=embed_KGB(x_L,G)
               then shift=two_rho_u_cap_s(P,x)
               then wt=v+shift
	       in KHighestWeight:((),x,wt)
	    od
   then result= for wt in wts do  K_types_no_error(wt)
                              od
    in if test_bl_function (result) then result[0]
       else prints("The K-types attached to the highest weights don't match"); []
       fi

set test_bl_function (Param p,int m)=void:
   let (P,q)=theta_stable_quasi_data(p)
   then ht=height(q)
   then Q=monomials(branch_irr(q,ht+m))
   in for kt in Q
      do prints(bottom_layer_map_by_hwt(kt,P),new_line,
                bottom_layer_map_by_param(kt,P),new_line)
      od

set survives_in_bottom_layer(KType kt,KGPElt P,Param p)=bool:
   let result=bottom_layer_map_by_hwt (kt,P)
   in prints(result);
       if #result=0 then false
       else let ht=height(result[0]) then Q=branch_irr(p,ht) in Q[result[0]]!=0
       fi

set K_sign (Param p,int ht)=KTypePol:
   let hf=hermitian_form_irreducible(p)
   in branch_std(hf,ht)

set test_bl_conj (Param p)=void:
   if not is_hermitian(p) then prints("p in not hermitian")
   else
   let (P,q)=theta_stable_quasi_data(p)
   then (u,nul)=nonunitarity_certificate(q)
   in if u then prints(new_line,"The rep on L is unitary.")
   else for kt in nul
        do prints(new_line,kt,new_line,bottom_layer_map_by_hwt(kt,P),new_line,
	    bottom_layer_map_by_param(kt,P))
	od fi

  fi
