<basic.at

<simple_character_table.at
<character_table_B.at
<character_table_C.at
<character_table_D.at
<character_table_F.at
<character_table_G.at
<character_table_E6.at
<character_table_E7.at
<character_table_E8.at


set character_table_torus(RootDatum rd) = CharacterTable:
   assert(rd.is_abelian,"Not a torus");
   let e=id_W(rd)
   then Wct = W_class_table
       (rd,[e]
       ,(int i)int: 1 { class size }
       ,(WeylElt w)int: 0 { class number of |w| }
       ,(int i,int k)int: 0 { class power }
       )
   , classes = [WeylElt,classical_class,string]: [(e,null_class(),"{e}")]
   , irreps = [classical_irrep,string,[int]]: [ (null_irrep(),"trivial",[1]) ]
   in character_table(Wct,classes,irreps)

{including torus}
set character_table_simple(RootDatum rd,string letter,int n) = CharacterTable:
( if ct_verbose
  then prints("Computing character table for simple root datum: "
	     , rd.nice_format)
  fi
; let ct=
     case char_index(letter,"ABCDEFG")
     in character_table_A(rd)
     , character_table_B(rd)
     , character_table_C(rd)
     , character_table_D(rd)
     , case n-6
       in character_table_E6(rd), character_table_E7(rd), character_table_E8(rd)
       esac
     , character_table_F(rd)
     , character_table_G(rd)
     esac
in if ct_verbose then prints("Done computing character table") fi;ct
)

{ Combine conjugacy class tables of Weyl groups for root subdata whose simple
  roots form a mutually orthogonal partition of the simple roots of |rd|.
  Explicitly passing |rd| as argument allows the proper renumbering to be
  applied when passing to and from the Weyl group of the full root datum.
}
set combine(RootDatum rd,[WeylClassTable] tables) = WeylClassTable:
(  let rds = for table in tables do table.root_datum od
   , radix = for table in tables do table.n_classes od { mixed radix list }
   , tr = two_rho(rd)
in assert(for rdj@j in rds
          do for i:j { iterate of all pairs |i<j| }
	     do for alpha_v in simple_coroots(rds[i])
	        do for beta in simple_roots(rdj)
	           do =alpha_v*beta
		   od.all
	        od.all
	     od.all
	  od.all,"Factors are not mutually orthogonal")
;  let reps = [[WeylElt]]: { all class representatives, lifted to |rd| }
      for table in tables
      do for w in table.class_representatives() do chamber(rd,w*tr) od
      od
   , words = all_words(radix) { mixed radix representations of class numbers }
   , index = mixed_radix_nr(radix) { map from |word| to its index in |words| }
   , project_W = [(WeylElt->WeylElt)]: { projectors to component Weyl groups }
      for rdi in rds
      do let tri = two_rho(rdi) in (WeylElt w): chamber(rdi,w*tri)
      od
in W_class_table
   ( rd
   , for word in words do product(rd,for n@i in word do reps[i][n] od) od
   , (int N) int: { class size }
     for l@i in words[N] do tables[i].class_sizes()[l] od.product
   , (WeylElt w) int: { class number }
        for proj@i in project_W do tables[i].class_of(proj(w)) od.index
   , (int N,int k) int:
	for n@i in words[N] do tables[i].class_power(n,k) od.index
   )
)

set combine(RootDatum rd,[CharacterTable] factors) = CharacterTable:
(  let Wct = combine(rd,for factor in factors do factor.class_table od)
   , words = for factor in factors do factor.n_classes od.all_words
   then reps = Wct.class_representatives()
   , index = mixed_radix_nr(for factor in factors do factor.n_classes od)
   , tensor([vec] chars) = [int]: { all products of entries }
        for word in words do product(for l@i in word do chars[i][l] od)	od
in let classes = [WeylElt,classical_class,string]:
     for word in words
     do ( reps[for n@i in word do factors[i].to_class_table(n) od.index]
	, null_class()
	, join(for n@i in word do factors[i].class_label(n) od,"*","{}")
	)
     od
  , irreps = [classical_irrep,string,[int]]:
     for L in words
     do ( null_irrep()
	, join(for n@i in L do factors[i].irreducible_label(n) od,".","triv")
	, tensor(for n@i in L do factors[i].character(n) od)
	)
     od
in character_table(Wct,classes,irreps)
)

set character_table(RootDatum rd) = CharacterTable:
   let (Lie_type,map) = Cartan_matrix_type(rd.Cartan_matrix)
   then simples = simple_factors(Lie_type)
   then root_data = [RootDatum]: { subdata with a single simple factor + torus }
      let offset=0 in
      for (,rank) in simples
      do sub_datum(rd,for i:rank do map[offset+i] od)  next offset+:=rank
      od
   then simple_tables = [CharacterTable]: { tables for each of |root_data| }
      for rdi@i in root_data
      do let (letter,n)=simples[i] in character_table_simple(rdi,letter,n)
      od
in combine(rd,simple_tables)
