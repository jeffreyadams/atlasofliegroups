< basic.at
< generics.at

{ Hash tables for any type |T| that can provide hahshing and equality testing.

  The functions that implement this are combined into a |HashInfo<T>| structure,
  from which the generic function |make_hash| can make am empty |Hash<T>| value.
  Filling the table and other functionality is provided by the |Hash<T>|
  component functions. These are, in order of frequencey of use:
  . |match| to possibly add an entry, retuning its sequence number in all cases
  - |could_add| is similar but reports whether the element was new
  - |index| gets an element from its sequence number
  - |search| tests for membership and looks up, without modifying the table
  - |list| produces all values currently in the hash table, by order of arrival
  - |iterator| provides an |Iterator<T>| to range over entries dynamically
    (it will also find entries added after the |iterator| call, unlike |list|)
  - |fill| can add multiple elements to the table
  - |clear| empties the table so that it can be re-used
  - |size| tells the number of entries currrently stored
  - |capacity| gives the current size of the storage used
}

set_type HashInfo<T> = ((T,int->int) hash_code, (T,T->bool) eq)!

{ Sometimes it is useful to store non-key infomation in a hash table, which does
  not participate in hashing and testing for equality (and which will therefore
  be dropped when trying to add an entry for which the key information is
  already known in the table), but which can be retrieved using |index|, |list|
  and |iterator|. This can be implemented simply by creating a |HashInfo<T>|
  for a (tuple) type that contains a hashable subtype |S|. The function |lift|
  prouced this from a |HashInfo<S>| and a (projection) map |T->S|
}
any_type S,T begin
set lift ((S->T)f, HashInfo<T> (hash_code,eq)) = HashInfo<S>:
   ( (S x, int m) int: hash_code(f(x),m), (S a,S b)bool: eq(f(a),f(b)) )
end

{ One can even do this with a subtype |S=int|, which needs no active hashing }
set triv_hash_info =  HashInfo<int>: { make |int| into a "hashable" type }
   ( (int a, int mod) int: AND(a,mod-1), =@(int,int) )

{ The specification of the |Hash| interface, a type constructor. }
set_type Hash<T> =
  ( (   -> int) size
  , (   -> int) capacity
  , ([T]->    ) fill
  , (   ->    ) clear
  , (   -> [T]) list
  , (int->T   ) index
  , (T  ->int ) match
  , (T  ->bool) could_add { like |match|, but returns whether it was new }
  , (T  ->Maybe<int> ) search
  , (   ->Iterator<T>) iterator
  )!

{ And here is the implementation, in the form of the |make_hash| constructor }
any_type T begin
set make_hash (HashInfo<T> (hash_code,eq)) = Hash<T>:
   let !empty=minus_1, values = [T]:[]
   then seq_nbrs = [empty,empty]
   then max_fill() = 2*#seq_nbrs\3
   then clear() = void: seq_nbrs := [empty,empty]; values:=[]
   , locate(T x) = (int,bool):
     let  capacity=#seq_nbrs
     then code = hash_code(x,capacity)
     then i=seq_nbrs[code]
     in while not (i=empty or eq(values[i],x))
        do if (code+:=1)=capacity then code:=0 fi
	; i:=seq_nbrs[code]
        od
     ; (code,i=empty) { slot in |seq_nbrs|, and whether it is new }
   then rehash() = void:
     begin seq_nbrs := for j:2*#seq_nbrs do empty od
     ;  for v@i in values
	do let (code,new) = locate(v)
	in if new then seq_nbrs[code] := i
	   else error("value ",v.to_string," at positions ",seq_nbrs[code]
		     ," and ",i," while reshashing??")
	   fi
	od
     end
   then acquire(T x) = (bool,int):
      let (code,new) = locate(x), seq=#values in
      ( new
      , if new { an empty slot was found, fill it }
	then values #:= x
	;  if seq>=max_fill()
	   then rehash()
	   ; set(code,new):=locate(x)
	   ; assert(@:not new,"Miraculous disappearence in rehashing!")
	   fi
	;  seq_nbrs[code] := seq
	else seq_nbrs[code]
	fi
      )
in ( { (   -> int) size     } @: #values
   , { (   -> int) capacity } @: #seq_nbrs
   , { ([T]->    ) fill	    }
     ([T] list)void: for item in list do acquire(item) od
   , { (   ->    ) clear    } clear
   , { (   -> [T]) list	    } @[T]: values
   , { (int->T   ) index    } (int i)T: values[i]
   , { (T  ->int ) match    }  (T x)int:  acquire(x).snd
   , { (T  ->bool) could_add } (T x)bool: acquire(x).fst
   , { (T  ->Maybe<int> ) search   }
     (T x): let (i,new)=locate(x) in if new then none() else some(seq_nbrs[i]) fi
   , { (   ->Iterator<T>) iterator }
     @Iterator<T>: let i=0 in
                   (@Maybe<T>: if i<#values then some(values[i]) else none() fi
		   ,@void: i +:= 1
		   )
   )

set lookup(Hash<T> table) = (T x)int:
   case table.search(x) | none: -1 | some(i): i esac

{ efficient orbit generation; client seeds |hash| with initial element(s) first }
set exhaust ([(T->T)] actions, Hash<T> hash) = [T]:
   let (get,incr) = hash.iterator()
in while
      case get()
      | none: dont
      | some(x): do x next incr()
        ; for act in actions do hash.match(act(x)) od
      esac
   od
end { of abstraction of type |T| }

{ fast polynomial evaluation modulo power of 2, similar to polynomial |eval| }
set eval_at_mod(int n, int m) = (vec->int):
    let mask = m-1 then pow=bit_length(mask) in
    assert(@:n>1 and m=exp_2(pow)," bad values for eval_at_mod");
    (vec v) int: let sum=0 in  for e in v ~do sum:=AND(mask,e + n*sum) od; sum

{meant to hash a [vec] to int in [0,d_mod)}
set hash_code (vec v, int mod) = int: eval_at_mod(8647,mod)(v)

{meant to hash a [mat] to int in [0,mod)}
set hash_code (mat M, int mod) = int: hash_code(vec:M.##,mod)

{meant to hash a [rat_vec] to int in [0,mod)}
set hash_code (ratvec v, int mod) = int: let(n,d)=%v in hash_code(n#d,mod)


set make_vec_hash () = Hash<vec>: make_hash(hash_code@(vec,int),=@(vec,vec))
set make_mat_hash () = Hash<mat>: make_hash(hash_code@(mat,int),=@(mat,mat))
set make_ratvec_hash () = Hash<ratvec>:
   make_hash(hash_code@(ratvec,int),=@(ratvec,ratvec))

{meant to hash KTypes for single group G}
set hash_code (KType p, int mod) = int:
   let (x,lr) = %p in hash_code(vec: (#x)#lr, mod)

{meant to hash Params for single group G}
set hash_code (Param p, int mod) = int:
   let (x,lr,nu) = %p then (nun,nud) = %nu
   in hash_code(vec: (#x) # lr ## (nun#nud), mod)

{meant to hash a [KTypePol]}
set to_vecs (KTypePol P) = [vec]:
   for c@p in P do let (a,b)=%c,(x,lr)=%p in [a,b,#x]##lr od
set hash_code (KTypePol P, int mod) = int: hash_code(vec: to_vecs(P).##, mod)

set make_KType_hash () = Hash<KType>:
   make_hash(hash_code@(KType,int),=@(KType,KType))
set make_Param_hash () = Hash<Param>:
   make_hash(hash_code@(Param,int),=@(Param,Param))
set make_KTypePol_hash () = Hash<KTypePol>:
   make_hash(hash_code@(KTypePol,int),=@(KTypePol,KTypePol))


set hash_code (RootDatum rd, int mod) = int:
    (   hash_code(vec: rd.simple_roots.##, mod)
    + 5*hash_code(vec: rd.simple_coroots.##, mod)
    ) % mod

set hash_code (InnerClass ic, int mod) = int:
    (    hash_code(ic.root_datum,mod)
    + 11*hash_code(vec: ic.distinguished_involution.##,mod)
    ) % mod

set hash_code (RealForm G, int mod) = int:
    let (bgvn, bgvd) = %base_grading_vector(G)
    in ( hash_code(G.inner_class, mod) + hash_code(vec:bgvn # bgvd,mod) ) % mod

set make_RootDatum_hash () = Hash<RootDatum>:
   make_hash(hash_code@(RootDatum,int),=@(RootDatum,RootDatum))
set make_InnerClass_hash () = Hash<InnerClass>:
   make_hash(hash_code@(InnerClass,int),=@(InnerClass,InnerClass))
set make_RealForm_hash () = Hash<RealForm>:
   make_hash(hash_code@(RealForm,int),=@(RealForm,RealForm))


set_type KGBratvec = (KGBElt x, ratvec lambda)

set = (KGBratvec A, KGBratvec B) = bool:
    A.x = B.x and A.lambda = B.lambda

set != (KGBratvec A, KGBratvec B) = bool:
    A.x != B.x or A.lambda != B.lambda


set hash_code(KGBratvec p, int mod) = int:
    (17*#p.x + hash_code(ratvec:p.lambda,mod)) % mod

set make_xlambda_hash () = Hash<KGBratvec>:
    make_hash(hash_code@(KGBratvec,int),=@(KGBratvec,KGBratvec))

set hash_code(KGBElt x, int mod) = int:
    (17*#x) % mod

set_type vec_hash        = Hash<vec>
set_type ratvec_hash 	 = Hash<ratvec>
set_type mat_hash 	 = Hash<mat>
set_type RootDatum_hash  = Hash<RootDatum>
set_type InnerClass_hash = Hash<InnerClass>
set_type RealForm_hash   = Hash<RealForm>
set_type xlambda_hash	 = Hash<KGBratvec>
set_type KType_hash	 = Hash<KType>
set_type KTypePol_hash 	 = Hash<KTypePol>
set_type Param_hash 	 = Hash<Param>
set_type KGBElt_hash	 = Hash<KGBElt>

set make_RealForm_hash ([RealForm] list, (RealForm,int->int).) = RealForm_hash:
   let table = make_RealForm_hash() in table.fill(list); table
set make_KGBElt_hash () = Hash<KGBElt>:
   make_hash(hash_code@(KGBElt,int),=@(KGBElt,KGBElt))
