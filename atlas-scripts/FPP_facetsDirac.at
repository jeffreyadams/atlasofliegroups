<simple_factors.at { for simple_factors }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]), no_reps}
<lattice.at {for vec_solve}
<hash.at {for KTypePol_hash}
<goodroots.at {for is_pos_on_LKTs}
<sort.at {for no_reps}
<to_ht.at {for is_unitary_to_ht}
<time.at {for print_time_string}
<Dirac.at {to restrict to local facets subject to Dirac inequality}
{functions for calculating FPP facet lists, both "globally" (from the
root datum) and "local" (as relevant to parameters for a single LKT
(x,lambda)}

{current version incorporates storage of KTypePol's in a hash table
KPolHash, and MvL's code FPP_w_shifts for quickly finding FPP
facets. The functions that use neither of these are generally
suffixed "_old"}
{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])}

{ Just do this for root datum rd with simple derived datum.}

{ One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell) }

{ There are four notions of "facet":
1) a ([AffineCoroot],[AffineCoroot]) Facet of affine inequalities and
equalities defining it (NOT UNIQUE);
2) the [ratvec] FacetVerts of vertices;
3) the ratvec FacetBary, the barycenter of the facet; and
4) the [vec] FacetVertsIndex of indices of the vertices in a fixed list of vertices

I like FacetVerts the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) by looking at all
enlargements of the vertex set. Passage from FacetVerts to FacetBary is
trivial (average the vertices) There are functions facet, facetVerts and
facetBary which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{Here is a brief outline. Following Barbasch and Steve
Miller, calculate things related to the FUNDAMENTAL PARALLELEPIPED
FPP, which lies in the R-span of the roots, where all simple coroots
take values in [0,1]. The FPP is partitioned into facets of various
dimensions from 0 to the semisimple rank. Each d-dimensional facet is
determined by its barycenter (a ratvec) or by its vertices (a list of
d+1 ratvecs). The idea for computing all facets in the FPP is to
compute a list vlist of all vertices in the FPP (done by
FPP_vertices@RootDatum); then for each d-dimensional facet to store a
rank d+1 vec giving the indices of the vertices in vlist (done by
FPP_vertex_sets_indices).
What's needed to get going is a list of all barycenters of facets in
the FPP. These are calculated by

Theorem. Every [barycenter of a facet] gamma (not just in FPP) can be
written as w*gamma0 + tau, with gamma0 unique [barycenter of a facet]
in the fundamental alcove, w in W (finite Weyl group), and tau in the
root lattice. If we require

   w*gamma0 is integrally dominant

then w*gamma0 is unique, and so tau is unique.

There are 2^(semisimple rank - 1) facet barycenters gamma0 in the
fundamental alcove.; not too many. Marc kindly provided a very fast
listing of the W-orbits W*gamma0. Picking out the integrally dominant
ones is now done stupidly in functions with names like
W_fund_barycentersID: stupid in the sense that it would have been
cleverer to sort out the integrally dominant terms in the library.

Addenda 7/23/22. In unequal rank (and harmless in general) better to
work with the cofolded root datum, and the corresponding (smaller) set
of weights fixed by the distinguished involution. (Every unitary infl
character must be of this form.) The main functions for working this
way now have "Fold" in their names, and the plan is that these should
be ultimately be the only ones used. In particular, the special
scripts like sphericalC for dealing with complex groups can and should
now be replaced by sphericalFold.}

{if true, unitary candidates are checked for Dirac inequality before
anything else. This seems not to help significantly: checking Dirac
takes significant time, (maybe 4% of total for F4) and the resulting
savings in the rest of the computation seems tiny (maybe 1% for F4).}
set Dirac_flag = false

{ useful to assign this to 'true" to get information about the
  progress of long calculations }
set facet_verbose = false

{ if true, reports progress at each of 2^{rank+1} fundamental facets
  during FPP calculation }

set fund_facet_verbose = false

{ if true, loca; facet data is sorted by increasing height}
set sort_LFD_flag = true
{ for facets of codim > facet_codim, use shifted char formula to
improve memory use. Setting equal to folded semisimple rank means no
use of shifted char formula.}
set facet_codim = int: 3

{If the distinguished involution delta of G is nontrivial, then all
UNITARY infinitesimal characters must be delta-fixed, and so lie in
(h*)^\delta. They are most efficiently calculated not using the affine
Weyl group of G, but rather the "cofolded" affine Weyl group explained
in the notes alcoves.pdf ("Affine Weyl group alcoves") around 3.4. The
character lattice for this cofolded datum is (X^*)^\delta. The script
twisted_root_datum calculates the DUAL folded root datum; so what we
need here is the dual of folded(dual of G.root_datum)). I think...}

set cofoldedBOTH(RootDatum rd, mat delta) = (RootDatum, RootDatum, mat):
    assert(is_distinguished(rd,delta),"delta is not distinguished");
    let Tstar = SubTorus:eigen_lattice(delta,1)
{Tstar =(X^*)^\delta; columns are a basis of (X^*)^\delta}
{Tstar is nxr where n=rd.rank and r=dimension(Tstar)}
{ Tstar: matrix of map Tstar->X^*(H) \simeq Z^r -> Z^n: this is Tstar.inject
 ^Tstar: matrix of map X_*(H)->X_*(Tstar) \simeq Z^n->Z^r:   this is
 Tstar.project=Tstar.restrict}
    then coroots_nonreduced=sort_u(
	 for alphavee in rd.poscoroots do Tstar.restrict(alphavee) od
	 )
    then {DISCARDS COROOTS FOR WHICH ALPHAVEE/2 IS COROOT}
	corootsC =mat:##(for alphavee in coroots_nonreduced
	 do if all (for x in alphavee/2 do is_integer(x) od)
	    and find(coroots_nonreduced,ratvec_as_vec(alphavee/2))!=-1
	    then [] else [alphavee] fi
	 od),
	 {THIS DISCARDS COROOTS FOR WHICH 2*ALPHAVEE IS COROOT}
	  corootsB=mat:##(for alphavee in coroots_nonreduced
	 do if find(coroots_nonreduced,2*alphavee)!=-1
	    then [] else [alphavee] fi
	 od)
    then rootsC = [] in
	 for alphavee in corootsC do
	     let pullback_alphavee = let j = first(
		 for betavee in rd.poscoroots do Tstar.restrict(betavee) =
		 alphavee od
	     )
	      in rd.poscoroots[j] {ONE coroot restricting to alphavee}
	 then v = sum(##( for betavee in rd.poscoroots do
		 if Tstar.restrict(betavee) = alphavee
		 then [root(rd,betavee)]
		 else []
		 fi od)) {sum of ALL roots for ALL coroots restr to alphavee}
	  then w = 2*v/(v*pullback_alphavee)
	  then corestrict_w = solve(Tstar,w).requisition
	  in
	  rootsC#:=ratvec_as_vec(corestrict_w)
	  od;
	  let rootsB = [] in
	  for alphavee in corootsB do
	     let pullback_alphavee = let j = first(
		 for betavee in rd.poscoroots do Tstar.restrict(betavee) =
		 alphavee od
	     )
	      in rd.poscoroots[j] {ONE coroot restricting to alphavee}
	 then v = sum(##( for betavee in rd.poscoroots do
		 if Tstar.restrict(betavee) = alphavee
		 then [root(rd,betavee)]
		 else []
		 fi od)) {sum of ALL roots for ALL coroots restr to alphavee}
	  then w = 2*v/(v*pullback_alphavee)
	  then corestrict_w = solve(Tstar,w).requisition
	  in rootsB#:=ratvec_as_vec(corestrict_w)
	  od;
	  (root_datum_from_positive((rootsB,corootsB),rd.prefers_coroots),
	  root_datum_from_positive((rootsC,corootsC),rd.prefers_coroots),Tstar)

{The cofolded RootDatum has character lattice (X^*)^\delta, coroots
the restrictions to (X^*)^\delta of the coroots of rd. The matrix is a
map from the character lattice of the cofolded datum to the character
lattice of G.}

{set cofolded(TwistedRootDatum (rd,delta)) = (RootDatum, mat):
    let (rd1,M1) = folded(rd.dual,^delta) in (rd1.dual,M1)}

{returns the cofolded root system, needed to construct the correct
affine Weyl group to act on delta-fixed weights; and the unique label
j0 (or -1) for a simple coroot needing to be divided by two to get
full FPP}
set cofolded(RealForm G) = (RootDatum, mat, int):
    let (rdB,rdC,M) = cofoldedBOTH(G.root_datum, G.distinguished_involution)
    then j0=
	 first(
	 for alpha@j in rdB.simple_roots do alpha != rdC.simple_roots[j] od
	 )
    in (rdB,M,j0)


{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum
set_type
[ AffineCoroot = (vec linear_coroot, int shift)
, AffineCoWeylElt = (vec tau, WeylElt w) { apply |w|, then translate by |tau| }
]
{This is meant to record K-characters of different facets}
set Kpol_hash = make_KTypePol_hash()

set aff_rank (SimpleAffine Affd) = semisimple_rank(Affd) + 1

{.evaluate AffineCoroot at weight.}
set * (AffineCoroot (linear_coroot,shift), vec gamma) = int:
  linear_coroot*gamma + shift

{.evaluate AffineCoroot at rational weight.}
set * (AffineCoroot (linear_coroot,shift), ratvec gamma) = rat:
  linear_coroot*gamma + shift

{.apply AffineCoWeylElt to weight.}
set *(AffineCoWeylElt (tau,w) , vec gamma)    = vec:    tau + w*gamma
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = ratvec: tau + w*gamma

{.compose AffineCoWeylElts.}
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = AffineCoWeylElt:
    (tau1 + w1*tau2, w1*w2)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
    let w1=inverse(w) in (-w1*tau,w1)

{. act by AffineCoWeylElt on an AffineCoroot .}
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
    let bvw1=betav*inverse(w) in (bvw1, m-bvw1*tau)

{.simple affine coroots: number 0 is affine, rest are simple for RootDatum.}
set aff_simple_coroots (SimpleAffine affd) = [AffineCoroot]:
    (-highest_root(dual(affd)),1) #
    for alpha_v in simple_coroots(affd) do (alpha_v,0) od

{.sum of simple affine coroots times their labels is (null(rank),1).}
set labels(SimpleAffine affd) = [int]:
    let a = coroot_index(affd,highest_root(dual(affd))) in
    1 # coroot_expression(affd,a)

{.root attached to an AffineCoroot.}
set root (AffineCoroot (betav,m),SimpleAffine affd) = root(affd,betav)

{.affine reflection through Affine coroot, applied to weight.}
set reflection(AffineCoroot Betav, SimpleAffine affd, vec v) = vec:
    v - root(Betav,affd)*(Betav*v)

set reflection(AffineCoroot Betav, SimpleAffine affd, ratvec v) = ratvec:
    reflection(Betav, affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot strict inequalities and (n-k) AffineCoRoot equalities.
The total collection of affine coroots appearing must be a set of simple coroots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE. This representation is therefore not often used,
but see |facet0| (way) below }

set_type [Facet = ([AffineCoroot] pos,[AffineCoroot] zero)]

{ a UNIQUE characterization of a k-diml facet is as a set of k+1 vertices }

set_type FacetVerts = [ratvec]

set *(WeylElt w, FacetVerts FV) = FacetVerts:
    for v in FV do w*v od

set *(mat M, FacetVerts FV) = FacetVerts:
    for v in FV do M*v od

set *(AffineCoWeylElt wtilde, FacetVerts FV) = FacetVerts:
    for v in FV do wtilde*v od

{ Maybe the smallest UNIQUE characterization of a facet is the barycenter }
set_type FacetBary = ratvec

{represents a k-diml facet as k+1 indices into a list of vertices
(held elsewhere)}
set_type FacetVertsIndex = vec { of length k+1 for k-dimensional facet }

set_type
[ FacetVertsKHash = vec {next to last entry is index of KChar in some hash, last is #LQ's}
, LocalFacetVertsKHash = vec {next to last entry is index of KChar in some hash, last is #LQ'a}
]

set_type
[ VertexData = ([ratvec] list, (ratvec->int) lookup)
, FacetDataKHash = (VertexData v_data
,   [[FacetVertsKHash]] Fverts)
, LocalFacetDataKHash = (VertexData v_data_local, KGBElt x,
  ratvec lambda, [[LocalFacetVertsKHash]] LFverts)
]

set to_vertex_data ([ratvec] vlist) = VertexData: (vlist,index_in(vlist))

set facet_indices((ratvec->int) lookup, FacetVerts facet) = FacetVertsIndex:
    for gammav in facet do lookup(gammav) od.sort

set sorted_is_subset([int] a, [int] b) = bool:
   let i=0, l=#b in
   for x in a
   do while if i<l then b[i]<x else return false fi do i+:=1 od
   ;  if x<b[i] then return false fi
   od; true

set sorted_is_disjoint([int] a, [int] b) = bool:
   let i=0, l=#b in
   for x in a
   do while if i<l then b[i]<x else return true fi do i+:=1 od
   ;  if x=b[i] then return false fi
   od; true

set index_in_facet_list([LocalFacetVertsKHash] L) = (vec->int):
    let m = #L[0]-4 
    in index_in(for v in L do v[:m] od)

{.compute the |Facet| of a barycenter (or any point) in the fundamental alcove.}
set facet0(SimpleAffine Affd, FacetBary gamma) = Facet:
    let S = [AffineCoroot]: { the simple system for the fundamental alcove }
       Affd.aff_simple_coroots
in ( for av in S do if =av*gamma then [] else [av] fi od.## { positives }
   , for av in S do if =av*gamma then [av] else [] fi od.## { zeros }
   )

{.simple roots corresponding to simple affine coroots: number 0 is
affine,  rest are simple for RootDatum.}
set aff_simple_roots(SimpleAffine affd) = mat:
    (-highest_root(dual(affd))) # affd.simple_roots

{.vertices of the fundamental alcove, ordered by |affd.affine_simple_coroots|.}
{ the vertex corresponding to an affine simple coroot is the one nonzero on it }
set fundamental_vertices (SimpleAffine affd) = [ratvec]:
    (ratvec:null(affd.rank)) { origin is vertex for the truly affine s.c.r. } #
    (let labs=affd.labels[1:] in
     for lab@j in labs do fundamental_weight(affd,j)/lab od)



{. select vertices of fund. alcove for aff. simple coroots nonzero on |gamma0|.}
set facet_verts0(SimpleAffine affd, FacetBary gamma0) = FacetVerts:
    let vert=fundamental_vertices(affd) in
    for coroot@d in [AffineCoroot]: affd.aff_simple_coroots
    do if =coroot*gamma0 then [] else [vert[d]] fi
    od.##

set barycenter ([ratvec] verts) = ratvec: { |verts| should be nonempty }
    sum(#verts[0],verts) / #verts

{. barycenter of facet of fundamental alcove that contains |gamma0|.}
set facet_bary0(SimpleAffine affd, ratvec gamma0) = FacetBary:
    barycenter(facet_verts0(affd,gamma0))

{. produces all k-element subsets of verts. The term "# #verts" is
[0,1,...,#verts - 1]
 .}
set choices_from( [ratvec]verts, int k) = [[ratvec]]:
    for S in choices_from(# #verts,k) do for s in S do verts[s] od od

set facets_fundamental(SimpleAffine affd, int d) = [FacetVerts]:
    choices_from(fundamental_vertices(affd),d+1)

{ vertex sets for facets in the fundamental alcove, organized by dimension }
set facets_fundamental(SimpleAffine affd) = [[FacetVerts]]:
    let fund_vertices = fundamental_vertices(affd) in
    for d: affd.aff_rank do choices_from(fund_vertices,d+1) od

{.barycenters of d-dimensional facets in the fundamental alcove.}
set fund_barycenters(SimpleAffine affd, int d) = [FacetBary]:
    for facet in facets_fundamental(affd,d) do barycenter(facet) od

{.barycenters of facets in fundamental alcove, organized by dimension.}
set fund_barycenters(SimpleAffine affd) = [[FacetBary]]:
    for L in facets_fundamental(affd)
    do for facet in L do barycenter(facet) od
    od

{ enumerate sums of roots to be added to gamma to land in FPP }
set FPPtauRoots(SimpleAffine Affd, ratvec gamma) = [vec]:
    let g=for av in Affd.simple_coroots do av*gamma od,
    	FW = Affd.fundamental_weights,
	FCW = Affd.fundamental_coweights
    then INT = [int]: for j:#Affd.simple_coroots
	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od.##
    in
    for S in power_set(INT)
    do
	let tau = ratvec: sum(Affd.rank,
	    	for xi@j in FW
	      	do -floor(g[j])*xi
		od) +
	   	    sum(Affd.rank,for k in S do FW[k] od)
    	then (w,d) = %(ratvec: (for xiv in FCW do xiv*tau od))
    	in if d=1 then [w] else [] fi
     od.##

{ same thing, with (perhaps) one simple root j0 for which FPP takes values in
[0,2] on coroot j0. So need to use values -floor(g[j0]),
-floor(g([j0]) + 1 for that root always, and also -floor(g[j0]) + 2 if
g[j0] is an integer. }
{If j0 is in INT, then this counts 1*fundamental_weights[j0] WITH MULT 2}
set FPPtauRoots(SimpleAffine Affd, ratvec gamma, int j0) = [vec]:
    let g=^(Affd.simple_coroots)*gamma, flr = null(Affd.semisimple_rank)
    then INT = ##for j:#Affd.simple_coroots
	 do
	 if (flr[j]:= floor(g[j]))=g[j] then [j] else []
	 fi
	 od
    in
    let tau0 = -Affd.fundamental_weights*flr
    then taus = for S in power_set(INT)
	 do tau0+ sum(
	    Affd.rank,for j in S do Affd.fundamental_weights[j] od
		     )
	 od
    then () = if j0 >=0
    	      then taus:=taus## for tau in taus do tau+Affd.fundamental_weights[j0] od
	      fi
    in
    for tau in taus do
	if(all(
	for xiv in Affd.fundamental_coweights do is_integer(xiv*tau) od))
	then [ratvec_as_vec(tau)]
	else []
    fi
    od.##.no_reps

{ same thing, with (perhaps) one simple root j0 for which FPP takes
values in [0,2] on coroot j0. So need to use values -floor(g[j0]),
-floor(g([j0]) + 1 for that root always, and also -floor(g[j0]) + 2 if
g[j0] is an integer. This Fast version gives too many tau (finds
integral weights, not just root sums) unless G is adjoint and simply
connected, but it's up to 40% faster; when possible, just take the
extra tau and do a no_reps}

set FPPtauRootsFast(SimpleAffine Affd, ratvec gamma, int j0) = [vec]:
    let g=^(Affd.simple_coroots)*gamma, flr = null(Affd.semisimple_rank)
    then INT = ##for j:#Affd.simple_coroots
	 do
	 if (flr[j]:= floor(g[j]))=g[j] then [j] else []
	 fi
	 od
    in
    let tau0 = -Affd.fundamental_weights*flr
    then taus = for S in power_set(INT)
	 do tau0 + sum(
	    Affd.rank,for j in S do Affd.fundamental_weights[j] od
		     )
	 od
    then () = if j0 >=0
    	      then taus:=taus## for tau in taus do tau+Affd.fundamental_weights[j0] od
	      fi
     in for tau in taus
     	do let (tau0,d) = %tau
       	   in if d=1 then [tau0] else [] fi
	od.##

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) =
    (AffineCoWeylElt,ratvec):
    let tau = alcove_root_vertex(rd,gamma)
    then (w,gamma0TIMESDEN) = from_dominant(rd,gamma.numer - gamma.denom*tau)
    in
    {assert (gamma=w*gamma0 + tau,"Bad affine!");}
    ((tau,w),gamma0TIMESDEN/gamma.denom)

{. for each vertex v of the fundamental alcove, a list of all w-v with [w,v] an edge of the (cofolded)
affine facets ENDING at v. For use in deciding whether a random [y,x] is an edge of the affine facets. }
set edge_lists_folded(SimpleAffine affd) = [[ratvec]]:
    let FVs = fundamental_vertices(affd)
    in for v in FVs
       do for w in FVs
       	  do if v =w then [ratvec]: []
       	     else let (num,den) = %(v-w)
	       	  in [ratvec]:
	       	     for x in Weyl_orbit(integrality_datum(affd,v), num) do x/den od
	     fi
          od.##
       od

{lists of rational weights for affd}
set edge_lists(RealForm G) = [[ratvec]]:
    let (affd, ,) = cofolded(G)
{    then N = required_solution(M.^, id_mat(affd.rank)).^} {maps (preferably delta-fixed) G-wts to affd-wts}
    in edge_lists_folded(affd)

{. the jth function here looks up its argument in the list of edges originating at fundamental vertex #j. }
set edge_list_lookups([[ratvec]] edgeLists) = [(ratvec->int)]:
    for list in edgeLists do index_in(list) od

{. the jth function here looks up its argument in the list of edges originating at fundamental vertex #j. }
set edge_list_lookups(RealForm G) = [(ratvec->int)]:
    edge_list_lookups(edge_lists(G))

{. tests whether [v0, v1] is an edge of the affine facet decomposition. }
set is_edge(RealForm G, [(ratvec->int)] lookups, ratvec gamma0, ratvec gamma1) = bool:
    let (affd, M, j0) = cofolded(G)
    then N = required_solution(M.^, id_mat(affd.rank)).^
         {maps (preferably delta-fixed) G-wts to affd-wts}
    then v0 = N*gamma0, v1 = N*gamma1
    then lookupFundVert = index_in(fundamental_vertices(affd))
    then ((,w),xi0) = from_fundamental_alcove(affd,v0)
    then n1 = lookupFundVert(xi0)
    in if n1 <0 then false
       else lookups[n1]((w.inverse)*(v1-v0))>=0
       fi

{.restored from 3/30/22 version for use in computing bigger facets with
same unitarity status.}
set facet (SimpleAffine Affd, ratvec gamma) = Facet:
   let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
   then (F0pos,F0zero) = facet0(Affd,gamma0)
   in (for betav in F0pos do wtilde*betav od
      ,for betav in F0zero do wtilde*betav od)

{ computes barycenter from a facet as a vertex list }
set facet_bary([ratvec] vert_list, FacetVertsIndex facet) = FacetBary:
    sum(#vert_list[0], for v in facet do vert_list[v] od)/(#facet)

{ computes the FacetVerts (vertex set) of any barycenter of a facet of them }
set facet_verts(SimpleAffine Affd, ratvec gamma) = FacetVerts:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in wtilde*facet_verts0(Affd,gamma0)

set lookup_vertices_for_barycenters \
    (SimpleAffine Affd, VertexData vd, [FacetBary] centers) \
    = [FacetVertsIndex]:
    for gamma in centers
    do for vertex in facet_verts(Affd, gamma)
       do vd.lookup(vertex)
       od.sort
    od

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }
set facet(SimpleAffine Affd, ratvec gamma) = Facet:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    then (F0pos,F0zero) = facet0(Affd,gamma0)
    in (for betav in F0pos do wtilde*betav od ,
       for betav in F0zero do wtilde*betav od)

{ computes the FacetBary of any ratvec, for possibly nonsimple rd}
set facet_bary(RootDatum rd, ratvec gamma) = FacetBary:
    sum(rd.rank, for Affd in simple_factors(rd)
		 do
		 let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
		 in	wtilde*facet_bary0(Affd,gamma0)
		 od)

{.number of vertices in W*(fundamental alcove).}
set W_fund_vertices_card(SimpleAffine Affd) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    1+sum(for S in choices_from(listn,n-2) do rat_as_int(N/#W(Levi(Affd,S))) od )

{.number of d-diml facets in W*(fundamental alcove).}
set W_fund_d_facets_card(SimpleAffine Affd,int d) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    if d=n
    then N
    else sum(for T in choices_from(listn,n-d) do rat_as_int(N/#W(Levi(Affd,T))) od) +
	 sum(for S in choices_from(listn,n-d-1) do rat_as_int(N/#W(Levi(Affd,S))) od)
    fi

{.number of facets in W*(fundamental alcove).}
set W_fund_facets_card(SimpleAffine Affd) = [int]:
    for d:Affd.aff_rank
	do W_fund_d_facets_card(Affd,d)
	od
{.integrally dominant weights W-conjugate to a fundamental alcove vertex .}
set W_fund_verticesID(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do  for gammawn in Weyl_orbit(Affd,gamma.numer)
    	do if is_integrally_dominant(Affd,gammawn/gamma.denom)
	   then [gammawn/gamma.denom]
	   else []
	   fi
	od.##
    od.##

{.one rep of each translations-by-roots coset in each W orbit of a
fundamental alcove vertex.}
set W_fund_vertices_mod_R(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do  for w in affine_orbit_ws(Affd, gamma)
    	do w*gamma
	od
    od.##

set W_fund_barycentersID(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycentersID.")
    fi;
		for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
		   do if is_integrally_dominant(Affd,gammawn/gamma0.denom)
		   then [gammawn/gamma0.denom]
		   else[]
		   fi
		   od.##
		od.##
     od

set W_fund_barycenters_mod_R(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycenters_mod_R.")
    fi;
		for gamma0 in fund_barycenters(Affd)[d]
		do for w in affine_orbit_ws(Affd, gamma0)
		   do w*gamma0
		   od
		od.##
    od

{ to get everything in the FPP, should use only _integrally dominant_ gammaw in WA0.}
set W_fund_barycentersID(SimpleAffine Affd, int d) = [FacetBary]:
	if facet_verbose
	then prints("start W_fund_barycenters_mod_R(Affd, ",d,").")
	fi;
	for gamma0 in fund_barycenters(Affd)[d]
	do for gammawn in Weyl_orbit(Affd,gamma0.numer)
	    do
	    if is_integrally_dominant(Affd,gammawn/gamma0.denom)
	    then [gammawn/gamma0.denom]
	    else []
	    fi
	    od.##
	od.##

{.to get everything in the FPP, need just reps mod root lattice.}
set W_fund_barycenters_mod_R(SimpleAffine Affd, int d) = [FacetBary]:
	if facet_verbose
	then prints("start W_fund_barycenters_mod_R(Affd, ",d,").")
	fi;
	for gamma0 in fund_barycenters(Affd)[d]
	do for w in affine_orbit_ws(Affd, gamma0)
	   do (w*gamma0.numer)/gamma0.denom
	   od
	od.##

{translate that preserves integral dominance, lands in WFA; and
corresponding translation back down. This version avoids constructing the
integrality datum for gamma, which is one of the many in "random position."}
set beta2(RootDatum rd, ratvec gamma) = (vec,vec):
    let (wtilde,gamma2) = from_fundamental_alcove(rd,gamma)
    then (b,w) = wtilde {w*gamma2 + b = gamma}
    then iw = inverse(w)
    then irdw = integrality_datum(rd,gamma2)
    {this integrality datum is the nice restricted type!}
    then (x3,) = from_dominant(irdw, iw*rd.two_rho)
{means x3 w^{-1} * rho is dominant for irdw.}
{x3 is w^-1 x^{-1} w}
    then bup = w*b + ratvec_as_vec(w*(x3*(iw*gamma2))-gamma2)
{so gamma + bup is x^{-1}(gamma+w*b), in x^{-1}w(fund alcove + 2rho)}
    in (bup, -inverse(x3)*(iw*bup) )

{imitates library FPP_w_shifts, allowing a single root #j0 that can be up to 2 on FPP}
set FPP_w_shifts(RootDatum Affd, ratvec gamma, int j0) = [(WeylElt,[vec])]:
    if j0=-1
    then FPP_w_shifts(Affd,gamma)
    else for w in affine_orbit_ws(Affd,gamma)
    	 do (w, FPPtauRoots{Fast}(Affd,w*gamma,j0))
	 od{.no_reps}
    fi

{.this includes all vertices of facets in the fundamental
parallelepiped, each exactly once. j0 is possible label of a simple
coroot that can be up to 2 on FPP}
set FPP_vertices(SimpleAffine Affd, int j0) = [ratvec]:
    { if facet_verbose then prints("start FPP_vertices.")
    fi;}
    for gamma in fundamental_vertices(Affd)
    do let aff_short_list = FPP_w_shifts(Affd,gamma,j0)
	  then aff_list = [AffineCoWeylElt]:
	       for (w,taus) in aff_short_list
	       do for tau in taus do (tau,w) od
	       od.##
	  in for wtilde in aff_list do wtilde*gamma od
       od.##

set FPP_vertices(RealForm G) = [ratvec]:
    { if facet_verbose then prints("start FPP_vertices of real form, ",G)
    fi; }
    let (Affd,M,j0) = cofolded(G)
    in for v in FPP_vertices(Affd,j0) do M*v od

set FPP_barycenters(SimpleAffine Affd, int dim, int j0) = [FacetBary]:
    if facet_verbose then prints("start dim ",dim,
       		     " in FPP_barycenters(Affd,",dim,").")
    fi;
    let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    in for FV@k in facets
       do { if facet_verbose
       	  then prints("start fund facet ",k," of ", #facets)
	  fi; }
       	  let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	  then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	  then aff_list = [AffineCoWeylElt]:
	       for (w,taus) in aff_short_list
	       do for tau in taus do (tau,w) od
	       od.##
	  in for wtilde in aff_list do wtilde*bary_F od
       od.##

set FPP_barycenters(SimpleAffine Affd, int j) = [[FacetBary]]:
    if facet_verbose then prints("start FPP_barycenters.")
    fi;
    for d:Affd.aff_rank
    do
    FPP_barycenters(Affd,d,j)
    od

set FPP_vertex_data (SimpleAffine Affd, int j) = VertexData:
   FPP_vertices(Affd,j).to_vertex_data

set FPP_vertex_data(RealForm G) = VertexData:
    FPP_vertices(G).to_vertex_data

{ using FPP_w_shift }
set FPP_facets(SimpleAffine Affd, VertexData vd, int dim, int j0) =
    [FacetVertsIndex]:
    let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    then ()= if facet_verbose
    	     then prints("start dim ",dim, " in FPP_facets")
	     fi
    in for FV@k in facets
       do if fund_facet_verbose or (facet_verbose and k=0)
       	  then prints("start fund facet ",k," of ", #facets, " in dim = ",dim,
	       " in FPP_facets")
	  fi;
	  let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	  then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	  then aff_list = [AffineCoWeylElt]:
	       for (w,taus) in aff_short_list
	       do for tau in taus do (tau,w) od
	       od.##
	  in [FacetVertsIndex]:
	     for wtilde in aff_list
	     do FacetVertsIndex:
		      for v in wtilde*FV
		      do vd.lookup(v)
		      od.sort
	     od { type is [FacetVertsIndex], remains for next line}
	 od.##

set FPP_facets (SimpleAffine Affd, [ratvec] vlist, int dim,
    int j) =
    [FacetVertsIndex]:
    FPP_facets(Affd, to_vertex_data(vlist), dim, j)

{global facets of dimensions zero to three, for use in local edge calculations}
set low_FPP_facets(RealForm G) = [[FacetVertsIndex]]:
    if G.semisimple_rank = 0 then []
    else let start = elapsed_ms(), (Affd, M, j0) = cofolded(G)
    	 then Avlist = FPP_vertices(Affd, j0)
    	 then Avd = Avlist.to_vertex_data
	 then () = if facet_verbose
	      	   then prints("start low_FPP_facets")
	           fi
    	 then answer = [[vec]]: [[vec]: for k:#Avlist do [k] od] ##
       	    for d:3 from 1
       	    do if d < Affd.semisimple_rank+1 then FPP_facets(Affd, Avd, d, j0)
	       else []
	       fi
	    od
	 then () = if time_verbose
	    	   then prints("time for low_FPP_facets was ",
		      	       print_time_string(elapsed_ms() - start),
			       "; counts = ", for L in answer do #L od)
		   fi
	 in answer
    fi

{Need low_facets to be size dim  \ge 2, so it includes edges and
facets dim - 1; then find facets of dim by starting with any dim-1
simplex, a vertex outside it, and checking whether the new edges are
allowed edges}
set FPP_add_dim (SimpleAffine Affd, int dim, [[FacetVertsIndex]] low_facets) =
    [[FacetVertsIndex]]:

(   let dim = #low_facets, num_verts = #low_facets[0]
    then () = assert(#low_facets > 1,"In FPP_add_dim, low_facets must include edges")
    then () = if facet_verbose
    	      then prints(new_line,"start FPP_add_dim, adding facets of dim ", dim)
    	      fi
    then lookup = index_in(low_facets[1])
    then Ldim = [FacetVertsIndex]:
    	 for f in low_facets[dim - 1]
	 do for v: #low_facets[0]-f~[0]-1 from f~[0]+1
	    do if all(for x in f do lookup([x,v]) >= 0 od)
	       then [f#v]
	       else []
	       fi
	    od.##{all facets starting with face f}
	 od.##{all facets in dim}
    in low_facets#Ldim
)

{global facets of dimensions zero to three, for use in local edge calculations
This version is more than ten times slower than low_FPP_facets for F4.}
{try instead to use super_facets?}
set low_FPP_facets_B(RealForm G) = [[FacetVertsIndex]]:
    let start = elapsed_ms()
    in if G.semisimple_rank = 0 then []
       else let (Affd, M, j0) = cofolded(G)
    	    then Avlist = FPP_vertices(Affd, j0)
	    then () = if facet_verbose
	      	      then prints("start low_FPP_facetsB")
	              fi
	    then low_facets = [[vec]]: [for k:#Avlist do [k] od]
    	    then () = low_facets:= low_facets # FPP_facets(Affd, Avlist, 1, j0)
	    then () = for d:2 from 2
	      	      do low_facets:= FPP_add_dim(Affd, d, low_facets)
	      	      od
	    then () = if time_verbose
	    	      then prints("time for low_FPP_facets_B was ",
		      	   		print_time_string(elapsed_ms() - start),
			       "; counts = ", for L in low_facets do #L od)
		      fi
 	    in low_facets
    fi


{Need low_facets to be size dim  \ge 2, so it includes edges and
facets dim - 1; then find facets of dim by starting with any dim-1
simplex, a vertex outside it, and checking whether the new edges are
allowed edges. superFacets is a bit faster}
set FPP_add_dim_B (SimpleAffine Affd, int dim, [[FacetVertsIndex]] low_facets) =
    [[FacetVertsIndex]]:

(   let dim = #low_facets, num_verts = #low_facets[0]
    then () = assert(#low_facets > 1,"In FPP_add_dim, low_facets must include edges")
    then () = if facet_verbose
    	      then prints(new_line,"start FPP_add_dim_B, adding facets of dim ", dim)
    	      fi
    then lookup = index_in(low_facets[dim - 1])
    then Ldim = [FacetVertsIndex]:
    	 for v in low_facets[0]
	 do for f in low_facets[dim - 1]
	    do if f[0] <= v[0]
	       then []
	       elif all(for k: dim do lookup(v[0]#delete(f,k)) >= 0 od)
	       then [v[0]#f]
	       else []
	       fi
	    od.##{all facets starting with vertex v}
	 od.##{all facets in dim}
    in low_facets#Ldim
)

{global facets of dimensions zero to three, for use in local edge calculations
This version is more than ten times slower than low_FPP_facets for F4.}
{try instead to use super_facets?}
set low_FPP_facets_BB(RealForm G) = [[FacetVertsIndex]]:
    let start = elapsed_ms()
    in if G.semisimple_rank = 0 then []
       else let (Affd, M, j0) = cofolded(G)
    	    then Avlist = FPP_vertices(Affd, j0)
	    then () = if facet_verbose
	      	      then prints("start low_FPP_facetsB")
	              fi
	    then low_facets = [[vec]]: [for k:#Avlist do [k] od]
    	    then () = low_facets:= low_facets # FPP_facets(Affd, Avlist, 1, j0)
	    then () = for d:2 from 2
	      	      do low_facets:= FPP_add_dim_B(Affd, d, low_facets)
	      	      od
	    then () = if time_verbose
	    	      then prints("time for low_FPP_facets_BB was ",
		      	   		print_time_string(elapsed_ms() - start),
			       "; counts = ", for L in low_facets do #L od)
		      fi
 	    in low_facets
    fi


{ m is a class known to be nonunitary; update classes above using
graph; label as "Ffrom"##tail}
{ first list in toDo all n covering m; then what covers those...
These get larger and larger.}
set updateNUclassesB([string] statuses, [[int]] covers, int m,
string tail) = [string]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
    	,id_mat(1)).quasicompact_form {CALLER SHOULD HANDLE NEXT LINE}
    then x0 = KGB(G1,0)
    then toDo = sum(G1, for n in covers[m] do 1*K_type(x0,[n]) od) {+
    	 (if statuses[m] = "?" then 1 else 0 fi)*K_type(x0,[m])}
    then () = while #toDo != 0
    	      do
	      let list = vec:
	      	  for p in monomials(toDo)
		  do lambda_rho(p)[0]
		  od
	      then () = toDo := sum(G1, for n in list
	      	   	  	  do sum(G1,
					for q in covers[n]
					do 1*K_type(x0,[q]) od)
				  od)
	      in for k in list
	      	 do  if statuses[k] = "?"
    	     	     then statuses[k] := "Ffrom"##tail
		     fi
		 od
	      od
    in statuses

{ m is a class known to be nonunitary; update classes above using
graph; label as "Ffrom"m}
set updateNUclassesB([string] statuses, [[int]] covers, int m) = [string]:
    updateNUclassesB(statuses, covers, m, to_string(m))

{vlist is a collection of possible infinitesimal characters for reps
(x,lambda,?), typically vertices from FPP. If vlist[i] shows up as
a vertex of a unitary facet, then there is another vertex vlist[j] so that

theta(vlist[i]) = -vlist[j] + (1+theta)lambda

The sequence [int] records the permutation i |--> j. The actual
vertices of the unitary facet are (vlist[i] + vlist[j])/2.

So this can be used to compute the actual facets of unitary
parameters, which are indeed simplices.  In the non-equal rank case,
one should apply this function to cofolded vertices, to be sure that
everything in sight is hermitian.}
{ONLY DEPENDS ON dlambda}
set thetaAct (KGBElt x, ratvec lambda, VertexData vd) = vec:
{
for v in vd.list
    do vd.lookup(parameter(x,(x.involution)*lambda,-v).normal.infinitesimal_character)
    od
}
    let theta = x.involution then thetaPlus = (1+theta)*lambda
    in for v in vd.list do vd.lookup(-theta*v + thetaPlus) od

set_type PermOrderTwo = (vec fixed, [(int,int)] trans)

{only keep the transpositions (v,w) where [v,w] is an edge}
set thetaAct2 (KGBElt x, ratvec lambda, VertexData vd,  [(ratvec->int)] edge_lookups) = PermOrderTwo:
    let theta = x.involution, G = x.real_form, vlist = vd.list
    then thetaPlus = (1+theta)*lambda
    then answer = PermOrderTwo: ([],[])
    then () = for v@i in vlist
    	      do let j = vd.lookup(-theta*v + thetaPlus)
    	      	 in if j = i
		    then answer.fixed#:= i
		    else if j > i and is_edge(G, edge_lookups, v, vlist[j])
		    	 then answer.trans#:= (i,j)
		    	 fi
		    fi
	      od
    in answer

{want a faster version using already computed stuff?}
set local_vertices(Param p, VertexData vd, VertexData Lvd, vec Perm) = FacetVerts:
    let G = p.real_form, gamma = p.infinitesimal_character
    then list = [ratvec]: {these are vertices in vd}
    	 if is_equal_rank(G) then facet_verts(G, gamma)
    	 else let (Affd,M,j0) = cofolded(G)
    	      then gamma0 = solve(M,gamma).requisition
    	      in M*facet_verts(Affd, gamma0)
	 fi
    then perm = for v in list do Perm[vd.lookup(v)] od
    then () = assert(perm.>=,"p appears not to be a hermitian parameter")
    in for v@j in list do (v + vd.list[perm[j]])/2 od.no_reps

set local_vertices2(Param p, VertexData vd, VertexData Lvd, PermOrderTwo Perm) = FacetVerts:
    let G = p.real_form, gamma = p.infinitesimal_character
    then list = [ratvec]: {these are "global" vertices in vd}
    	 if is_equal_rank(G) then facet_verts(G, gamma)
    	 else let (Affd,M,j0) = cofolded(G)
    	      then gamma0 = solve(M,gamma).requisition
    	      in M*facet_verts(Affd, gamma0)
	 fi
    then nums = for v in list do vd.lookup(v) od
    then () = assert(nums.>=,"p appears not to be an FPP parameter")
    then firsts = for (n,) in Perm.trans do n od
    then perm = PermOrderTwo: ([],[])
    then () = for n@j in nums
	      do if is_member_sorted(Perm.fixed)(n)
	      	 then perm.fixed #:=n
	    	 else if is_member_sorted(firsts)(n)
		      then let j = first(for (x,y) in Perm.trans
		      	       	   	 do x = n
					 od)
		      	   then (,m) = Perm.trans[j]
	              	   then () = assert(is_member(nums)(m),"p appears not to be a hermitian parameter")
			   in perm.trans #:=(n,m)
		      fi
	    	 fi
	      od
     in for n in perm.fixed do list[n] od ##
        for (n,m) in perm.trans do (vd.list[n] + vd.list[m])/2 od

{computes the full vertices of the facet containing a delta-fixed dom
 ratl weight gamma}
set local_vertices(RealForm G, ratvec gamma) = FacetVerts:
    if is_equal_rank(G) then facet_verts(G, gamma)
    else let (Affd,M,j0) = cofolded(G)
    	 then gamma0 = solve(M,gamma).requisition
    	 in M*facet_verts(Affd, gamma0)
    fi

{compute the vertices of the local facet containing the HERMITIAN FPP parameter p}
set local_vertices(Param p) = FacetVerts:
    let G = p.real_form, gamma = p.infinitesimal_character
    then list = local_vertices(G, gamma)
{    [ratvec]:
    	 if is_equal_rank(G) then facet_verts(G, gamma)
    	 else let (Affd,M,j0) = cofolded(G)
    	      then gamma0 = solve(M,gamma).requisition
    	      in M*facet_verts(Affd, gamma0)
	 fi}
    then vd = to_vertex_data(list), x = p.x, lambda = p.lambda
    then Perm = thetaAct(x,lambda,vd)
    then () = assert(Perm.>=,"p appears not to be a hermitian parameter")
    in for v@j in list do (v + list[Perm[j]])/2 od.no_reps

set herm_center(Param p) = Param:
    let list = local_vertices(p)
    in parameter(p.x, p.lambda, sum(#list[0], list)/#list)

{Take character_formula(p), and move each term to infl char gamma0. This works (give
honest deformed rep) if gamma0 is in the local facet of infl_char(p)}
set wiggle(Param p, ratvec gamma0) = ParamPol:
let P = character_formula(p)
in  sum(p.real_form, for c@q in P do c*parameter(q.x, q.lambda, gamma0) od)

set wiggle(ParamPol P, ratvec gamma0) = ParamPol:
sum(P.real_form, for c@q in P do c*parameter(q.x, q.lambda, gamma0) od)

{compute the deformations of irrep p to boundary facets of its facet. This is
a list of 2^{#local_vertices} - 1 ParamPol's, the character formulas on the walls.
If p is unitary, this is a sum with positive coeffs of characters of unitary reps}
set local_defs(Param p) = [ParamPol]:
 let list = local_vertices(p), CF = character_formula(p)
 then d = #list {dim of local facet plus 1}
 in for j:d from 1
    do for S in choices_from(list,j)
       do let gamma0 = sum(#list[0],S)/j
       in wiggle(CF,gamma0)
       od
    od.##

{compute the deformations of irrep p to boundary faces of its facet. This is
a list of #local_vertices ParamPol's, the character formulas on the faces.
If p is unitary, each is a sum with positive coeffs of characters of unitary reps}
set local_face_defs(Param p) = [ParamPol]:
    let list = local_vertices(p)
    in if #list = 1 then [ParamPol]: []
       else let CF = character_formula(p), sum = sum(#list[0], list), d=#list
       	    in for v in list
       do wiggle(CF, (sum - v)/(d-1))
       od
       fi

{compute the deformations of parameter p to walls of its facet. This begins with a list of
2^{#local_vertices} - 1 Param's (which may not be final), and finalizes.}
set local_param_defs(Param p) =[Param]:
let list = local_vertices(p)
then d = #list {dim of local facet plus 1}
in for j:d from 1
   do for S in choices_from(list,j)
      do let gamma0 = sum(#list[0],S)/j
      in monomials(1*parameter(p.x,p.lambda,gamma0))
      od.##
   od.##

{this is all the (automatically unitary) unitary irrs arising by
deformation of one know unitary irr p}
set deformed_unitaries_pol(Param p) = ParamPol:
sum(p.real_form, local_defs(p))

set face_deformed_unitaries_pol(Param p) = ParamPol:
sum(p.real_form, local_face_defs(p))

set deformed_unitaries(Param p) = [Param]:
    monomials(composition_series(deformed_unitaries_pol(p)))

set face_deformed_unitaries(Param p) = [Param]:
    monomials(composition_series(face_deformed_unitaries_pol(p)))

set face_deformed_unitaries_new(Param p) = [Param]:
    for q in face_deformed_unitaries(p)
    do if q.x != p.x
       then [herm_center(q)]
       else []
       fi
    od.##

{ set #(Param_hash U) = U.size()}
set size([Param_hash] Us) = sum(for U in Us do U.size() od)

{takes the known unitaries from unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, VertexData Lvd,
    [[FacetVertsKHash]] LFDKH) = [vec]:
    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
    	      	  	    	     	      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = Uhash.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
       	 do let p = Uhash.index(k)
       	    then list = local_vertices(p)
            in if p.x = x and p.lambda=lambda and #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
	     	    then m = lookups[#list-1](local_verts)
		    then () = assert(m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]:= (out[#list-1] next out[#list -1]:=[])#m
		    in ()
	       fi
	 od
     in out

{Here UhashLocal is assumed to consist of Param's at (x,lambda)}
{this misses (in local_testK_level) unitary Param's that finalize to different x;
those are caught by local_testK_hash}
set known_unitaries(Param_hash UhashLocal, VertexData Lvd,
    [[FacetVertsKHash]] LFDKH) = [vec]:
    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
    	      	  	    	     	      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = UhashLocal.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
       	 do let p = UhashLocal.index(k)
       	    then list = local_vertices(p)
            in if #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
	     	    then m = lookups[#list-1](local_verts)
		    then () = assert(m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]:=out[#list-1]#m
		    in ()
	       fi
	 od
     in out

set localize(Param_hash Uhash, KGBElt x, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.x = x and p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc

set localize(Param_hash Uhash, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc
{collection of lookup functions for facets of various dimensions}
set lookups([[vec]] LFD) = [(vec->int)]:
    for L@d in LFD do index_in(for v in L do v[:d+1] od) od

{assume LFDKH has tail coords referring to K-char}
set sort(RealForm G, VertexData Lvd, [[FacetVertsKHash]] LFDKH, int tail) = [[FacetVertsKHash]]:
    if sort_LFD_flag
    then let tworhocheck = G.two_rho_check
    	 then f(vec v) = int:
    	      let (num,den) = %(sum(for j in v[:#v - tail] do Lvd.list[j]*tworhocheck od)*1000)
	      in num\den
    	 in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
    else LFDKH
    fi

{this is the Q(infinitesimal character) bound provided by Dirac inequality on all LKTs}
set DiracBD(KGBElt x, ratvec lambda) = rat:
    let G = x.real_form
    then Q = invariant_form(G)
    in if not(Dirac_flag and is_equal_rank(G))
       then Q(G.rho,G.rho)
       else let mus = LKTs(parameter(x,lambda,0*lambda))
       	    then ics = for mu in mus do DiracIC(mu) od
    	    in min(for ic in ics do Q(ic,ic) od)
       fi

{"true" means unitarity is possible in light of Dirac}
set DiracTest(Param p) = bool:
    let G=p.real_form
    then () = Dirac_flag:=true
    in if not is_equal_rank(G) then return is_hermitian(p)
       else let gamma = p.infinitesimal_character
    	    then Q = invariant_form(G)
	    then bound = DiracBD(p.x, p.lambda)
	    in Q(gamma, gamma) <= bound
       fi


{creates LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local verts}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.

parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}
set localFD_Lvd \
  ( KGBElt x, ratvec lambda, VertexData vd) =
  (VertexData, vec, vec):
(   {if facet_verbose
    then prints("start localFD_Lvd")
    fi;}
    let start = elapsed_ms(), Perm = thetaAct(x, lambda, vd), G = x.real_form
    then vlist = vd.list
    then vlistAct = [ratvec]:
 	 for v@i in vlist
	     do let j = Perm[i]
	     	in if j = i
		   then [v]
		   else if j > i
		   	then let w = vlist[j]
			     then u = (v+w)/2
			     then FV = local_vertices(G,u)
			     in if #FV=2 and
			     	   (FV[0] = v and FV[1] = w) or
				   (FV[0] = w and FV[1] = v)
			     	then [u]
				else let () = Perm[i] := minus_1
				     then () = Perm[j] := minus_1
				     in []
				fi
			else []
			fi
		   fi
	     od.##
    {then vlistAct = vlistRep.no_reps}
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec:
    {maps FPP vertex indices from vd to local indices from Lvd}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then Llookup(v)
	     elif j >=0 then Llookup((v+vlist[j])/2)
	     else minus_1
	     fi
	 od
    then () = if time_verbose then prints("     ",print_time_string(elapsed_ms() - start),
    	      	 		     " for localFD_Lvd") fi
    in (Lvd, Perm, mapAct)
)



{creates LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local verts}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.

parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}
set localFD_Lvd2 \
  ( KGBElt x, ratvec lambda, VertexData vd, [(ratvec->int)] edge_lookups) =
  (VertexData, PermOrderTwo, vec):
(   {if facet_verbose
    then prints("start localFD_Lvd2")
    fi;}
    let start = elapsed_ms(), Perm2 = thetaAct2(x, lambda, vd, edge_lookups), G = x.real_form
    then vlist = vd.list
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    then () = if time_verbose then prints("     ",print_time_string(elapsed_ms() - start),
    	      	 		     " for localFD_Lvd2") fi
    in (Lvd, Perm2, mapAct)
)

{creates LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local verts}
{argument lookups enables is_edge}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.

parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}
{This time we know FPP edges}

set localFD_Lvd_edges2 \
  ( KGBElt x, ratvec lambda, VertexData vd, [(ratvec->int)] edge_lookups) =
  (VertexData, PermOrderTwo, vec):
(   if facet_verbose
    then prints("start localFD_Lvd_edges2")
    fi;
    let start = elapsed_ms(), Perm2 = thetaAct2(x, lambda, vd, edge_lookups), G = x.real_form
    then vlist = vd.list
    then vlistAct = [ratvec]:
 	 for i in Perm2.fixed do vlist[i] od ## for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    then () = if time_verbose then prints("     ",print_time_string(elapsed_ms() - start),
    	      	 		     " for localFD_Lvd_edges2") fi
    in (Lvd, Perm2, mapAct)
)


set localFD_000(VertexData Lvd) = [[FacetVertsIndex]]:
    [for k:#Lvd.list do [k] od]

{creates vd, LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local
 verts, and 0-facets for (x,lambda)}
set localFD_000 \
  ( KGBElt x, ratvec lambda, VertexData vd) =
  (VertexData, VertexData, vec, vec, [[FacetVertsIndex]]):
(   let (Lvd, Perm, mapAct) = localFD_Lvd(x, lambda, vd)
  in (vd, Lvd, Perm, mapAct, sort(x.real_form, Lvd,[ for v@k in Lvd.list do [k] od ],2))
)

{creates vd, LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local
 verts, and 0-facets for (x,lambda)}
set localFD_0002 \
  ( KGBElt x, ratvec lambda, VertexData vd,  [(ratvec->int)] edge_lookups) =
  (VertexData, VertexData, PermOrderTwo, vec, [[FacetVertsIndex]]):
(   let (Lvd, Perm2, mapAct) = localFD_Lvd2(x, lambda, vd, edge_lookups)
  in (vd, Lvd, Perm2, mapAct, sort(x.real_form, Lvd,[ for v@k in Lvd.list do [k] od ],2))
)
{not used}
{set localFD_000 \
  ( KGBElt x, ratvec lambda) =
  (VertexData, VertexData, vec, vec, [[FacetVertsIndex]]):
  localFD_000(x, lambda, FPP_vertex_data(x.real_form) )
}

{
set localFD_0002 \
  ( KGBElt x, ratvec lambda, [(ratvec->int)] edge_lookups) =
  (VertexData, VertexData, PermOrderTwo, vec, [[FacetVertsIndex]]):
  localFD_0002(x, lambda, FPP_vertex_data(x.real_form), edge_lookups)
}
{
{takes local vertices LFKH, and adds local 1-d facets; so output is size 2. NOT USED?}
set localFD_KHash1 \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   assert(#LFKH = 1,"localFD_KHash1 takes only local VERTEX list");
    if facet_verbose
    then prints(new_line, "start localFD_Khash1")
    fi;
    let G = x.real_form
    then (Affd, M, j0) = cofolded(G)
    then top = int: if any(for j:#Perm do Perm[j] > j od) then 3 else 1 fi
    then Edges = [vec]:
    	       for dim:top from 1
    	       do [vec]:
	       	  let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	 	  in for FV@k in facets
		     do [vec]:
		     	let bary_F =FacetBary: sum(Affd.rank,FV)/(dim+1)
			then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	then aff_list = [AffineCoWeylElt]:
	       	    	     for (w,taus) in aff_short_list
	       	    	     do for tau in taus do (tau,w) od
	       	    	     od.##
	       	 	in for wtilde in aff_list
	       	    	   do let (tau,w) = wtilde
		       	      then global = vec:
				   for v in wtilde*FV
		       	    	   do (vd.lookup)(M*v)
				   od.sort {indices into FPP vertex list}
			      then local = for ell in global do Perm[ell] od
				     	  	  {indices into Lvd list}
			      then actual = vec:
				   if local.>= and
				      is_subset(local,global) and
				      none(for i in global do mapAct[i] < 0 od)
			    	   then for i in global
			    	 	   do mapAct[i]
				 	   od.sort_u
			    	   else []
			    	      fi
			       in if #actual = 2 then [actual] else [] fi
			    od.## {list of edges from FV}
			od.## {list of edges from dim FPP facets}
		 od.## {list of edges from dims 1-3}
    then LFKH1 = [FacetVertsKHash]:
    	 for actual in Edges
	 do let bary = facet_bary(Lvd.list,actual)
	    then p0 = parameter(x,lambda,bary)
	    then P = finalize(p0)
	    then ms = monomials(P)
	    in if all ( for p in ms do is_pos_on_LKTs(p) od)
	    {think this gives hermitian also?}
	       then let Q = K_type_pol(character_formula(P))
	       	    in [actual##[ktp_hash.match(Q), #ms]]
	       else []
	       fi
	 od.##
    in if(facet_verbose) then prints("After localFD_KHash1, facet counts are [",
       			 #LFKH[0], ",",#LFKH1,"]")
       fi;
       sort(x.real_form, Lvd, LFKH#LFKH1,2)
)
}


{takes local vertices LFKH, and adds local 1-d facets; so output is size 2.}
{ WORKING on it!
set localFD_KHash12 \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, PermOrder2 Perm2, vec mapAct,
    [[FacetVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   assert(#LFKH = 1,"localFD_KHash1 takes only local VERTEX list");
    if facet_verbose
    then prints(new_line, "start localFD_Khash12")
    fi;
    let G = x.real_form
    then (Affd, M, j0) = cofolded(G)
    then top = int: if any(for j:#Perm do Perm[j] > j od) then 3 else 1 fi
    then Edges = [vec]:
    	       for dim:top from 1
    	       do [vec]:
	       	  let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	 	  in for FV@k in facets
		     do [vec]:
		     	let bary_F =FacetBary: sum(Affd.rank,FV)/(dim+1)
			then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	then aff_list = [AffineCoWeylElt]:
	       	    	     for (w,taus) in aff_short_list
	       	    	     do for tau in taus do (tau,w) od
	       	    	     od.##
	       	 	in for wtilde in aff_list
	       	    	   do let (tau,w) = wtilde
		       	      then global = vec:
				   for v in wtilde*FV
		       	    	   do (vd.lookup)(M*v)
				   od.sort {indices into FPP vertex list}
			      then local = for ell in global do Perm[ell] od
				     	  	  {indices into Lvd list}
			      then actual = vec:
				   if local.>= and
				      is_subset(local,global) and
				      none(for i in global do mapAct[i] < 0 od)
			    	   then for i in global
			    	 	   do mapAct[i]
				 	   od.sort_u
			    	   else []
			    	      fi
			       in if #actual = 2 then [actual] else [] fi
			    od.## {list of edges from FV}
			od.## {list of edges from dim FPP facets}
		 od.## {list of edges from dims 1-3}
    then LFKH1 = [FacetVertsKHash]:
    	 for actual in Edges
	 do let bary = facet_bary(Lvd.list,actual)
	    then p0 = parameter(x,lambda,bary)
	    then P = finalize(p0)
	    then ms = monomials(P)
	    in if all ( for p in ms do is_pos_on_LKTs(p) od)
	    {think this gives hermitian also?}
	       then let Q = K_type_pol(character_formula(P))
	       	    in [actual##[ktp_hash.match(Q), #ms]]
	       else []
	       fi
	 od.##
    in if(facet_verbose) then prints("After localFD_KHash12, facet counts are [",
       			 #LFKH[0], ",",#LFKH1,"]")
       fi;
       sort(x.real_form, Lvd, LFKH#LFKH1,2)
)
}

{this is the largest dimension of a global facet on which an element tau in Z(G)^hat of order two can act
 with exactly two orbits on the vertices. The bound 3 is only obtained for D_2n.}

set global_top = int: 3
{takes local vertices LF, and adds local 1-d facets; so output is size
2. Only depends on x.involution and dlambda. MAY NOT BE HERMITIAN}
set localFD_1\
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm,
  vec mapAct, [[FacetVertsIndex]] LF) = [[FacetVertsIndex]]:
(   assert(#LF = 1,"localFD_1 takes only local VERTEX list");
    if facet_verbose
    then prints(new_line,"start localFD_1")
    fi;
    let start = elapsed_ms(), G = x.real_form
    then (Affd, M, j0) = cofolded(G)
    then top = int: if any(for j:#Perm do Perm[j] > j od) then global_top else 1 fi
    then Edges = [vec]:
    	       for dim:top from 1
    	       do [vec]:
	       	  let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	 	  in for FV@k in facets
		     do [vec]:
		     	let bary_F =FacetBary: sum(Affd.rank,FV)/(dim+1)
			then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	then aff_list = [AffineCoWeylElt]:
	       	    	     for (w,taus) in aff_short_list
	       	    	     do for tau in taus do (tau,w) od
			     od.##
	       	 	in for wtilde in aff_list
	       	    	   do let (tau,w) = wtilde
		       	      then global = vec:
				   for v in wtilde*FV
		       	    	   do (vd.lookup)(M*v)
				   od.sort {indices into FPP vertex list}
			      then local = for ell in global do Perm[ell] od
				     	  	  {indices into Lvd list}
			      then actual = vec:
				   if local.>= and
				      is_subset(local,global) and
				      none(for i in global do mapAct[i] < 0 od)
			    	   then for i in global
			    	 	   do mapAct[i]
				 	   od.sort_u
			    		   else []
			    	      fi
			       in if #actual = 2 then [actual] else [] fi
			    od.## {list of edges from FV}
			od.## {list of edges from dim FPP facets}
		 od.## {list of edges from dims 1-3}
    then answer = sort(G, Lvd, LF#Edges, 0)
    in if(facet_verbose) then prints("After localFD_1, facet counts are [",#LF[0],
    		      	   	  ",",#Edges,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1") fi;
       answer
 )



{takes local vertices LF, and adds local 1-d facets; so output is size
2. Only depends on x.involution and dlambda. MAY NOT BE HERMITIAN}
set localFD_12\
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, PermOrderTwo Perm2,
  vec mapAct, [[FacetVertsIndex]] LF) = [[FacetVertsIndex]]:
(   assert(#LF = 1,"localFD_1 takes only local VERTEX list");
    if facet_verbose
    then prints(new_line,"start localFD_12")
    fi;
    let start = elapsed_ms(), G = x.real_form
    then (Affd, M, j0) = cofolded(G), Perm = for k:#vd.list do minus_1 od
    then () = for i in Perm2.fixed do Perm[i] := i od
    then () = for (j,k) in Perm2.trans do Perm[j]:= k; Perm[k] := j od
    then top = int: if #Perm2.trans > 0 then global_top else 1 fi
    then Edges = [vec]:
    	       for dim:top from 1
    	       do [vec]:
	       	  let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	 	  in for FV@k in facets
		     do [vec]:
		     	let bary_F =FacetBary: sum(Affd.rank,FV)/(dim+1)
			then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	then aff_list = [AffineCoWeylElt]:
	       	    	     for (w,taus) in aff_short_list
	       	    	     do for tau in taus do (tau,w) od
			     od.##
	       	 	in for wtilde in aff_list
	       	    	   do let (tau,w) = wtilde
		       	      then global = vec:
				   for v in wtilde*FV
		       	    	   do (vd.lookup)(M*v)
				   od.sort {indices into FPP vertex list}
			      then local = for ell in global do Perm[ell] od
				     	  	  {indices into Lvd list}
			      then actual = vec:
				   if local.>= and
				      is_subset(local,global) and
				      none(for i in global do mapAct[i] < 0 od)
			    	   then for i in global
			    	 	   do mapAct[i]
				 	   od.sort_u
			    		   else []
			    	      fi
			       in if #actual = 2 then [actual] else [] fi
			    od.## {list of edges from FV}
			od.## {list of edges from dim FPP facets}
		 od.## {list of edges from dims 1-3}
    then answer = sort(G, Lvd, LF#Edges, 0)
    in if(facet_verbose) then prints("After localFD_1, facet counts are [",#LF[0],
    		      	   	  ",",#Edges,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1") fi;
       answer
 )


{computes local 1-d facets; so output is size
2. Only depends on x.involution and dlambda. PARAMS MAY NOT BE HERMITIAN!}
set localFD_01 \
  ( KGBElt x, ratvec lambda, VertexData vd) = (VertexData, vec, vec, [[FacetVertsIndex]]):
 let start = elapsed_ms(), (Lvd, Perm, mapAct) = localFD_Lvd(x,lambda,vd)
 then LF = localFD_000(Lvd)
 then () = if time_verbose then prints("     ",print_time_string(elapsed_ms()-start),
      	      		   	" for localFD_01") fi
 in (Lvd, Perm, mapAct, localFD_1(x,lambda,vd, Lvd, Perm,  mapAct, LF))

{computes local 1-d facets; so output is size
2. Only depends on x.involution and dlambda. PARAMS MAY NOT BE HERMITIAN!}
set localFD_012 \
  ( KGBElt x, ratvec lambda, VertexData vd) = (VertexData, PermOrderTwo, vec, [[FacetVertsIndex]]):
 let start = elapsed_ms(), (Lvd, Perm2, mapAct) = localFD_Lvd2(x,lambda,vd, edge_list_lookups(x.real_form))
 {fix this; caller should provide lookups!}
 then LF = localFD_000(Lvd)
 then () = if time_verbose then prints("     ",print_time_string(elapsed_ms()-start),
      	      		   	" for localFD_012") fi
 in (Lvd, Perm2, mapAct, localFD_12(x,lambda,vd, Lvd, Perm2,  mapAct, LF)) {???}
 
{takes local vertices and edges LF, and imposes Dirac AND hermitian}
set localFD_01Dirac\
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm,
  vec mapAct, [[FacetVertsIndex]] LF) = [[FacetVertsIndex]]:
(   assert(#LF = 2,"localFD_01Dirac takes only vertex and edge list");
   { if facet_verbose
    then prints(new_line,"start localFD_01Dirac")
    fi;}
    let G = x.real_form, start = elapsed_ms()
    {then () = prints("starting localFD_01Dirac, LF = ",LF)}
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then () = LF[0] :=
    	 for v in LF[0]
	 do let p = parameter(x,lambda,Lvd.list[v[0]])
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
	       (Dirac_flag and Q(Lvd.list[v[0]], Lvd.list[v[0]])> DiracBD)
	    then []
	    else [v]
	    fi
	 od.##
    {then () = if #Lvd.list > #LF[0] then prints("Dirac killed ",#Lvd.list - #LF[0]) fi}
    then Llookup = is_member_sorted((for v in LF[0] do v[0] od).sort)
    then () = LF[1] :=
    	 for v in LF[1]
	 do let p = parameter(x,lambda,facet_bary(Lvd.list, v[:2]))
	    in  if all(for k in v do Llookup(k) od) and
	       	   all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    then answer = sort(G, Lvd, LF, 0)
    in if(facet_verbose) then prints("After localFD_01Dirac, facet counts are [",#LF[0],
    		      	   	  ",",#LF[1],"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_01Dirac") fi;
       answer
 )

{takes local data and computes vertices and edges, imposing hermitian,
pos on LKTs, and Dirac}
set localFD_1Dirac\
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm,
  vec mapAct) = [[FacetVertsIndex]]:
(   { if facet_verbose
    then prints(new_line,"start localFD_1Dirac")
    fi;}
    let G = x.real_form, start = elapsed_ms()
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FacetVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then (Affd, M, j0) = cofolded(G)
    then top = int: if any(for j:#Perm do Perm[j] > j od) then global_top else 1 fi
    then Edges = [vec]:
    	       for dim:top from 1
    	       do [vec]:
	       	  let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	 	  in for FV@k in facets
		     do [vec]:
		     	let bary_F =FacetBary: sum(Affd.rank,FV)/(dim+1)
			then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	then aff_list = [AffineCoWeylElt]:
	       	    	     for (w,taus) in aff_short_list
	       	    	     do for tau in taus do (tau,w) od
			     od.##
	       	 	in for wtilde in aff_list
	       	    	   do let (tau,w) = wtilde
		       	      then global = vec:
				   for v in wtilde*FV
		       	    	   do (vd.lookup)(M*v)
				   od.sort {indices into FPP vertex list}
			      then local = for ell in global do Perm[ell] od
				     	  	  {indices into Lvd list}
			      then actual = vec:
				   if local.>= and
				      is_subset(local,global) and
				      none(for i in global do mapAct[i] < 0 od)
			    	   then for i in global
			    	 	   do mapAct[i]
				 	   od.sort_u
			    		   else []
			    	      fi
			       in if #actual = 2 then [actual] else [] fi
			    od.## {list of edges from FV}
			od.## {list of edges from dim FPP facets}
		 od.## {list of edges from dims 1-3}
    then LF1 = [FacetVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,facet_bary(Lvd.list, v))
	    in  if all(for k in v do Llookup(k) od) and
	       	   all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    in if(facet_verbose) then prints("After localFD_1Dirac, facet counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac") fi;
       answer
 )


  {takes local data and global 0 to 3 facets and computes vertices and edges, imposing hermitian,
pos on LKTs, and Dirac}
set localFD_1Dirac\
  ( KGBElt x, ratvec lambda, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsIndex]] globalFacets) = [[FacetVertsIndex]]:
(   if facet_verbose
    then prints(new_line,"start localFD_1Dirac")
    fi;
    let G = x.real_form, start = elapsed_ms()
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
              then let () = DiracBD := DiracBD(x,lambda)
                   then () = Q:=invariant_form(G)
                   in ()
              fi
    then LF0 = [FacetVertsIndex]:
         for v@j in Lvd.list
         do let p = parameter(x,lambda,v)
            in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
               (Dirac_flag and Q(v, v)> DiracBD)
            then []
            else [[j]]
            fi
         od.##
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then (Affd, M, j0) = cofolded(G)

    then top = int: if any(for j:#Perm do Perm[j] > j od) then 3 else 1 fi
    then Edges = [vec]:
               for dim:top from 1
               do [vec]: for global in globalFacets[dim]
                         do let local = for ell in global do Perm[ell] od
                                                  {indices into Lvd list}
                            then actual = vec:
                                 if local.>= and
                                    is_subset(local,global) and
                                    none(for i in global do mapAct[i] < 0 od)
                                 then for i in global
                                      do mapAct[i]
                                      od.sort_u
                                 else []
                                 fi
                             in if #actual = 2 then [actual] else [] fi
                         od.## {list of edges from dim global facets}
                 od.## {list of edges from dims 1-3}
    then LF1 = [FacetVertsIndex]:
         for v in Edges
         do let p = parameter(x,lambda,facet_bary(Lvd.list, v))
            in  if all(for k in v do Llookup(k) od) and
                   all(for q in monomials(p) do is_pos_on_LKTs(q) od)
            then [v]
            else []
            fi
         od.##
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    in if(facet_verbose) then prints("After localFD_1Dirac, facet counts are [",#LF0,
                                  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
                                          " for localFD_1Dirac") fi;
       answer
)


{takes local data and global 0 to 3 facets and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}

set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, VertexData Lvd, PermOrderTwo Perm2, vec mapAct,
    [[FacetVertsIndex]] globalFacets) = [[FacetVertsIndex]]:
(   {if facet_verbose
    then prints(new_line,"start localFD_1Dirac")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FacetVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
 	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then (Affd, M, j0) = cofolded(G)
    then top = int: let pairs = #Perm2.trans
    	       	    in if pairs > 1 then 3
    	       	       elif pairs > 0 then 2
		       else 1
		       fi
    then Edges = [vec]:
    	       let EdgesFixFix = [vec]:
	       if #Perm2.fixed > 1
 	       then for v in globalFacets[1]
	       	    do if is_member_sorted(Perm2.fixed)(v[0]) and is_member_sorted(Perm2.fixed)(v[1])
		       then let mloc = mapAct[v[0]], nloc = mapAct[v[1]]
		       	    in if Llookup(mloc) and Llookup(nloc)
			       then [[mloc,nloc].sort]
			       else []
			       fi
			else []
			fi
		    od.##
	       else []
	       fi
	       then EdgesFixTrans = [vec]:
	       if global_top >= 2 and #Perm2.trans > 0 and #Perm2.fixed > 0
	       then for v in globalFacets[2]
	       	    do let mixes = [[v[0],v[1],v[2]],[v[1],v[0],v[2]],[v[2],v[0],v[1]]]
		       in for w in mixes
		       	  do if is_member_sorted(Perm2.fixed)(w[0]) and trans_hash.lookup([w[1],w[2]]) >= 0
		       	     then let xloc = mapAct[w[0]], yloc = mapAct[w[1]]
		       	     	  in if Llookup(xloc) and Llookup(yloc)
			       	     then [[xloc,yloc].sort]
			       	     else []
			       	     fi
			      else []
			      fi
			  od.##
		     od.##
	       else []
	       fi
	       then EdgesTransTrans = [vec]:
	       if global_top >= 3 and #Perm2.trans > 1
	       then for v in globalFacets[3]
	       	    do let mixes = [[v[0],v[1],v[2],v[3]], [v[0],v[2],v[1],v[3]], [v[0],v[3],v[1],v[2]]]
		       in for w in mixes
		       	  do if trans_hash.lookup([w[0],w[1]]) >= 0 and trans_hash.lookup([w[2],w[3]]) >= 0 
		       	     then let xloc = mapAct[w[0]], zloc = mapAct[w[2]]
		       	     	  in if Llookup(xloc) and Llookup(zloc)
			       	     then [[xloc,zloc].sort]
			       	     else []
			       	     fi
			     else []
			     fi
			  od.##
		     od.##
	       else []
	       fi
	       in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FacetVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,facet_bary(Lvd.list, v))
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    in if(facet_verbose) then prints("After localFD_1Dirac2, facet counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2") fi;
       answer
)

{takes 0 and 1-diml local facets and adds K-char index}
set localFD_KHash_01 (KGBElt x, ratvec lambda, VertexData Lvd, KTypePol_hash ktp_hash,
[[FacetVertsIndex]] LF) = [[FacetVertsKHash]]:
    let start = elapsed_ms()
    then answer = for d:#LF
    	 do if fund_facet_verbose then prints(new_line, "start to compute ",#LF[d],
       	  		     " K-characters in dimension ",d,
			     " in localFD_KHash_01")
       	     fi;
	     for v@k in LF[d]
       	     do if k%(max(#LF[d]\10,2))=0 and fund_facet_verbose
	      	then prints("examining facet ",k,
	      	   "; #ktp_hash = ",ktp_hash.size())
	      	fi;
		let nu = facet_bary(Lvd.list, v)
       	      	then p0 = parameter(x, lambda, nu)
	      	then P = finalize(p0)
	      	then Q = K_type_pol(character_formula(P))
	      	in v##[ktp_hash.match(Q), #monomials(P)]
       	     od
    	od
   then () = answer:= sort(x.real_form, Lvd, answer, 2)
   then time = elapsed_ms() - start
   then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01") fi
   in answer

{takes 0 and 1-diml local facets and adds K-char index to height HT}
set localFD_KHash_01 (KGBElt x, ratvec lambda, VertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FacetVertsIndex]] LF) = [[FacetVertsKHash]]:
    let start = elapsed_ms()
    then answer = for d:#LF
    	 do if fund_facet_verbose then prints(new_line, "start to compute ",#LF[d],
       	  		     " K-characters to height ",HT, " in dimension ",d,
			     " in localFD_KHash_01")
       	    fi; for v@k in LF[d]
       	   do if k%(max(#LF[d]\10,2))=0 and fund_facet_verbose
	      then prints("examining facet ",k,
	      	   "; #ktp_hash = ",ktp_hash.size())
	      fi;
	      let nu = facet_bary(Lvd.list, v)
       	      then p0 = parameter(x, lambda, nu)
	      then P = finalize(p0)
	      then Q = K_type_pol(character_formula_to_height(P,HT))
	      in v##[ktp_hash.match(Q), #monomials(P)]
       	    od
    	  od
   then () = answer:= sort(x.real_form, Lvd, answer, 2)
   then time = elapsed_ms() - start
   then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01 to height ", HT) fi
   in answer

{takes local facets of dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets. Need to be sure that input is based only
on FPP facets up to dim b-1, or repetitions can appear in output.}
set localFD_bt \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsIndex]] LF, int b, int t) = [[FacetVertsIndex]]:
(   if facet_verbose
    then prints(new_line,"start localFD_bt")
    fi;
    {let Llookup = Lvd.lookup}
    let G = x.real_form
    then (Affd, M, j0) = cofolded(G)
    then () = LF := LF##(for dim:t-#LF from #LF do
    	 [FacetVertsIndex]: [] od)
    then () = for dim:t-b from b
    	      do let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	      	 then () = for FV@k in facets
       	      	      	   do if (facet_verbose and k=0) or fund_facet_verbose
       	       	       	      then prints("start fund facet ",k," of ", #facets,
	       	       	      	   " in dim ", dim,
		       		   " in localFD_bt")
	       	 	      fi;
	       	 	      let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	       	 	      then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	      then aff_list = [AffineCoWeylElt]:
	       	    	      	   for (w,taus) in aff_short_list
	       	    		   do for tau in taus do (tau,w) od
	       	    		   od.##
	       	 	      in for wtilde in aff_list
	       	    	      	 do let (tau,w) = wtilde
		       		    {global is called v earlier}
		       		    then global = for v in wtilde*FV
		       	    	     	 	  do (vd.lookup)(M*v)
				     		  od.sort
		       		    {local is called vtheta earlier}
		       		    then local = for ell in global do Perm[ell] od
				    {if -1 appears in local, subset fails}
		       		    {actual is called vAct earlier}
		       		    then actual = vec:
				    	 if local.>= and is_subset(local,global) and
					    none(for i in global do mapAct[i] < 0 od)
			    		 then for i in global
			    	 	      do mapAct[i]
				 	      od.sort_u
			    		 else []
			    		 fi
		       		    then () = if #actual > 1 {already got vertices}
					      then LF[#actual-1] :=
						      (LF[#actual-1] next LF[#actual-1]:=[])
			   	 	      		# actual
					      fi
				     in ()
	     	     		   od
	      	            od
			    in if(facet_verbose) then prints("after FPP dim ",dim,
			    " facet counts are ",for j:dim+1 do #LF[j] od) fi
		od
    in sort(G, Lvd, LF, 0)
)

{takes list of 0- and d-diml facets, with d \ge 1, and builds all
d+1-diml facets having all faces in the d-diml list. The int e is the
number of extra coords in each facet.}
set superFacets([vec] L0, [vec] Ld, int e) =
    [vec]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [vec]:
   for v in L0
   do let m0 = v[0] {first vertex in new facet}
      in [vec]:
      	 for small in Ld
      	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    elif any(for k:d+1 do lookupsd( m0#(small[:k]##small[k+1:d+1])) = -1 od)
	    then [] {require all d-faces to be in Ld}
	    else [m0#small[:d+1]] {now m0##small is a candidate facet}
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFacets was ",
		      	print_time_string(elapsed_ms() - start))
          fi}
in answer
fi

{global facets of dimensions zero to three, for use in local edge calculations
This version is better than _B, and _BB, but still many times slower than low_FPP_facets.}
set low_FPP_facets_C(RealForm G) = [[FacetVertsIndex]]:
    let start = elapsed_ms()
    in if G.semisimple_rank = 0 then []
       else let (Affd, M, j0) = cofolded(G)
    	    then Avlist = FPP_vertices(Affd, j0)
	    then () = if facet_verbose
	      	      then prints("start low_FPP_facetsB")
	              fi
	    then low_facets = [[vec]]: [for k:#Avlist do [k] od]
    	    then () = low_facets:= low_facets # FPP_facets(Affd, Avlist, 1, j0)
	    then () = for d:2 from 1
	      	      do low_facets:= low_facets # superFacets(low_facets[0],low_facets[d],0)
	      	      od
	    then () = if time_verbose
	    	      then prints("time for low_FPP_facets_C was ",
		      	   		print_time_string(elapsed_ms() - start),
			       "; counts = ", for L in low_facets do #L od)
		      fi
 	    in low_facets
    fi


{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary facets and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, VertexData Lvd, {vec Perm, vec mapAct,}
    [[FacetVertsKHash]] LFKH, int b, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   {if facet_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;}
    let G = x.real_form, start=elapsed_ms()
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFacets(LFKH[0],LFKH[dim-1],2)
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then [actual##[ktp_hash.match(
				              K_type_pol(character_formula(P))), #ms]]
		       		    	 else []
				    	 fi
		    	      	   od.## {[FacetVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, 2)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt to dim ",t-1) fi
    in if(facet_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, facet counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)


{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t). This time
just calculate K characters to HT

Need to assume b \ge 2, so have a list of potentially unitary facets and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, VertexData Lvd, {vec Perm, vec mapAct,}
    [[FacetVertsKHash]] LFKH, int b, int t, int HT, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;
    let G = x.real_form, start=elapsed_ms()
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFacets(LFKH[0],LFKH[dim-1],2)
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then [actual##[ktp_hash.match(
				              K_type_pol(character_formula_to_height(P, HT))), #ms]]
		       		    	 else []
				    	 fi
		    	      	   od.## {[FacetVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, 2)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	       " for localFD_Khashbt to height ", HT, " and dim ",t-1) fi
    in if(facet_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, facet counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)

{takes local facets of dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have known vertices and edges.}
set localFbt_lookDown_GEO \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, {vec Perm, vec mapAct,}
    [[FacetVertsIndex]] LF, int b, int t) = [[FacetVertsIndex]]:
(   if facet_verbose
    then prints(new_line,"start localFDbt_lookDown_GEO")
    fi;
    let G = x.real_form
    then () = for dim:t-#LF from #LF {b has to be at least 2}
    	      do LF := LF# superFacets(LF[0],LF[dim-1],0)
	      od
    in if(facet_verbose) then prints("After localFbt_lookDownGEO, facet counts are ",
        			      for list in LF do #list od) fi;
    sort(G, Lvd, LF, 0)
)

{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list}
set localFD_KHashbt_lookDown \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints(new_line,"start localFD_Khashbt_lookDown")
    fi;
    let G = x.real_form, b = #LFKH
    then (Affd,M,j0) = cofolded(G)
    then LFKHnew = [[FacetVertsKHash]]: LFKH##(for dim:t-b from b do
    	 [FacetVertsKHash]: [] od)
    then hashes = for d:#LFKHnew do make_vec_hash(for v in LFKHnew[d] do v[:d+1] od, hash_code@(vec,int)) od
    {use the hashes to avoid repetitions in the facet lists}
    then () = for dim:t-b from b
    	      do
	 let facets = [FacetVerts]: facets_fundamental(Affd,dim)
	 then lookups = lookups(LFKHnew)
    	 then () = for FV@k in facets
       	      	   do if (facet_verbose and k=0) or fund_facet_verbose
       	       	then prints("start fund facet ",k," of ", #facets,
	       	       	    " in dim ", dim,
		       	    " in localFD_KHashbt_lookDown; #ktp_hash = ",
		       	    ktp_hash.size())
	       	       fi;
	       	let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	       	then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	        then aff_list = [AffineCoWeylElt]:
	       	     for (w,taus) in aff_short_list
	       	     do for tau in taus do (tau,w) od
	       	     od.##
	       	in for wtilde in aff_list
	       	   do let (tau,w) = wtilde
		      then iw = inverse(w)
			{global is called v earlier}
		      then global = for v in wtilde*FV
		       	    	    do (vd.lookup)(M*v)
				    od.sort
		        {local is called vtheta earlier}
		      then local = for ell in global do Perm[ell] od
			{if -1 appears in local, subset fails}
		        {actual is called vAct earlier}
		      then actual = vec:
		       	 if local.>= and is_subset(local,global) and
			    none(for i in global do mapAct[i] < 0 od)
			 then for i in global
			      do mapAct[i]
			      od.sort_u
			 else []
			 fi
		      then d=#actual-1
		      then () = if d  > 0{already got vertices} and all(
		      	   for e:d+1 do lookups[d-1](delete(actual,e)) >= 0 od)
				{now we know that the subfacets are cand facets}
				then let s = hashes[#actual-1].size()
				     then i = hashes[#actual -1].match(actual)
				     then () =
				        if i=s
					then
					  let bary = M*(wtilde*bary_F)
					  then p0 = parameter(x,lambda, bary)
					  then P = finalize(p0)
					  then ms = monomials(P)
				      	  in if all(for p in ms do is_pos_on_LKTs(p) od)
					     then let Q= K_type_pol(character_formula(P))
				      	 	  then ()=actual :=
						    actual##[ktp_hash.match(Q), #ms]
						  in LFKHnew[#actual-2] :=
			    	 		     (LFKHnew[#actual-2] next
						     LFKHnew[#actual-2]:=[])# actual
				    	      fi {pos_on_LKTs}
				   fi {d > 0}
			in ()
			fi
		     in ()
	     	  od
	      	od
	      in ()
	od
    then dAct = last(for j:#LFKHnew do #LFKHnew[j] > 0 od)
    in sort(G, Lvd, LFKHnew[:dAct+1], 2)
)

set extend_K_characters(KGBElt x, ratvec lambda, VertexData Lvd, {vec Perm,
    vec mapAct,} [[FacetVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
    {if facet_verbose
    then prints(new_line,"start extend_K_characters")
    fi;}
    let G = x.real_form, start = elapsed_ms()
    then answer =
       for d:#LFKH
       do if fund_facet_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_facet_verbose
	      	 then prints("examining facet ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = facet_bary(Lvd.list, v[:d+1]), w=v
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
	  	 then Q = K_type_pol(character_formula(P))
	  	 then () = w[d+1] := ktp_hash.match(Q)
		 in w
              od
      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters") fi
     in answer

set extend_K_characters(KGBElt x, ratvec lambda, VertexData Lvd, {vec Perm,
    vec mapAct,} [[FacetVertsKHash]] LFKH, int ht, KTypePol_hash ktp_hash) =
    	[[FacetVertsKHash]]:
    if facet_verbose
    then prints(new_line,"start extend_K_characters to height ",ht)
    fi;
    let G = x.real_form, start = elapsed_ms()
    then answer =
       for d:#LFKH
       do if fund_facet_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_facet_verbose
	      	 then prints("examining facet ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = facet_bary(Lvd.list, v[:d+1]), w=v
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
	  	 then Q = K_type_pol(character_formula_to_height(P,ht))
	  	 then () = w[d+1] := ktp_hash.match(Q)
		 in w
              od
       od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters") fi
     in answer
