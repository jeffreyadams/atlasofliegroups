<basic.at
<hermitian.at
<convert_c_form.at
<count.at {for use counter}
{preferred to_ht(ParamPol,int)}
{Turns out the "preferred" versions are significantly slower almost
always; don't understand why. So switch to "old" versions as standard,
labelling others as "new"}
set herm_report = bool: false

set to_ht (int N) = (ParamPol->ParamPol): (ParamPol P):
  if N < 0 then P
  else let (below,)=height_split(P,N) in below
  fi

set full_deform_to_ht_old(Param p, int N) = to_ht(full_deform(p),N)
{ KTypePol:
if height(p) > N then null_K_module(p.real_form)
elif height(p) = N then K_type_pol(p)
else to_ht(full_deform(p),N)
fi
This version seems NOT faster or smaller}

set full_deform_to_ht(Param p, int N) = KTypePol:
    let pc = alcove_center(p)
    then k = deformedParams[N].match(pc)
    in if k < #deformations[N]
       then deformLookupCounter.use();
       	    regroup(p.real_form, deformations[N][k])
       else let j = deformedParams[0].lookup(pc)
       	    in if j.>=
	       then deformLookupCounter.use();
	            let P = regroup(p.real_form,to_ht(deformations[0][j],N))
	       	    then () = deformations[N]:= {deformations[N]#P}
		    (deformations[N] next deformations[N]:=[]) # P
		    in P
       	       else deformCalcCounter.use();
       	       	    let P = deform_to_height(p,N)
       	    	    then () = deformations[N]:= {deformations[N]#P}
	    	    (deformations[N] next deformations[N]:=[]) # P
	    	    in P
	       fi
       fi

{deform_to_height(p,N)}

set twisted_full_deform_to_ht(Param p,int N) = KTypePol:
    let pc = alcove_center(p)
    then k = twistedDeformedParams[N].match(pc)
    in if k < #twistedDeformations[N]
       then deformLookupCounter.use();
       	    regroup(p.real_form, twistedDeformations[N][k])
       else let j = twistedDeformedParams[0].lookup(pc)
       	    in if j.>=
	       then deformLookupCounter.use();
	            let P = regroup(p.real_form,
		    	to_ht(twistedDeformations[0][j],N))
	       	    then () = twistedDeformations[N]:= {twistedDeformations[N]#P}
		    (twistedDeformations[N] next twistedDeformations[N]:=[]) # P
		    in P
       	       else deformCalcCounter.use();
       	       	    let P = to_ht(twisted_full_deform(p),N)
       	    	    then () = twistedDeformations[N]:= {twistedDeformations[N]#P}
	    	    (twistedDeformations[N] next twistedDeformations[N]:=[]) # P
	    	    in P
	       fi
       fi

set KL_sum_at_s_to_ht(int N) = (Param p)ParamPol:
  KL_sum_at_s_to_height(p,N)

set twisted_KL_sum_at_s_to_ht(int N) = (Param p) ParamPol:
  to_ht(N)(twisted_KL_sum_at_s(p))

{.write c-invariant form on standard module as a ParamPol of
standardrepKs to specified height.}

set c_form_std_to_ht_old(int N) = (Param->KTypePol):(Param p):
{ never involves |twisted_full_deform| }
   full_deform_to_ht_old(p,N)

set c_form_std_to_ht(int N) = (Param->KTypePol):(Param p):
{ never involves |twisted_full_deform| }
   full_deform_to_ht(p,N)

set twisted_c_form_std_to_ht(int N) = (Param p)KTypePol:
   twisted_full_deform_to_ht(p,N)

{    c_form_to_ht on irreducible representations   }

set oriented_KL_sum_to_ht  (int N) = (Param p)ParamPol:
   let ori_nr_p = orientation_nr(p) in  null_module(real_form(p)) +
   for c@q in KL_sum_at_s_to_height(p,N) do (c*orientation_nr_term(ori_nr_p,q),q) od

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as ParamPol of standardrepKs.}
set c_form_irreducible_to_ht_old (Param p,int N) = KTypePol:
  if not(herm_report) then
  map(c_form_std_to_ht_old(N), oriented_KL_sum_to_ht(N)(p) )
  else
  let P=oriented_KL_sum_to_ht(N)(p), count=0 then nP=#P
  then
    f(Param p) = if count<11 or count%10=0 or nP-count<=10
                 then prints("Term ",count,": ",p)
                 fi; count+:=1; full_deform_to_ht(p,N)
  in prints("Fully deforming ",nP," terms"); map(f, P)
  fi

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as ParamPol of standardrepKs.}
set c_form_irreducible_to_ht (Param p,int N) = KTypePol:
  if not(herm_report) then
  map(c_form_std_to_ht(N), oriented_KL_sum_to_ht(N)(p) )
  else
  let P=oriented_KL_sum_to_ht(N)(p), count=0 then nP=#P
  then
    f(Param p) = if count<11 or count%10=0 or nP-count<=10
                 then prints("Term ",count,": ",p)
                 fi; count+:=1; full_deform_to_ht(p,N)
  in prints("Fully deforming ",nP," terms"); map(f, P)
  fi

{    twisted_c_form_irreducible_to_ht   }

{ utility: compute fixed and unfixed contributions to c-form on irreducible(p)
  no deformation is done, but orientation numbers are included;
  fixed contributions are already halved; for unfixed ones this needs to wait
}
set twisted_c_form_irreducible_contributions_to_ht(Param p,int N) =
    (ParamPol,ParamPol): { (fixed part, 2*unfixed part) }
  let G=p.real_form, ori_nr_p = orientation_nr(p)
  then formula = (1+s)*KL_sum_at_s_to_height(p,N) + (1-s)*twisted_KL_sum_at_s_to_ht(N)(p)
  in { two value-producing loops can be a lot more efficient than one: }
  ( G.null_module +
      for c@q in formula
      do if twist(q)=q then [(half(c)*orientation_nr_term(ori_nr_p,q),q)]
         else []
	 fi
      od.##
   , G.null_module +
      for c@q in formula
      do if twist(q)=q then []
         else [(c*orientation_nr_term(ori_nr_p,q),q)]
	 fi
      od.##
  )

{ The following function implements algorithm from Vogan in email 9/22/16:
  * for each delta-fixed term q add c_form_std(q) (fully twisted-deformed)
  * for each pair {q,delta(q)} add q.K_type_pol (deformation to nu=0 of q).
  For second kind it it convenient to add q.K_type_pol and delta(q).K_type_pol
  separately and at the end divide the sum of such contributions by 2.
}
{.twisted c-invariant form to height N on an irreducible in terms of
standardrepKs.}

set twisted_c_form_irreducible_to_ht (Param p,int N) = KTypePol:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions_to_ht(p,N)
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  in
  if not herm_report
  then map(twisted_c_form_std_to_ht(N),fixed)+half(unfixed.K_type_pol)
  else let nf = #fixed, count=0
  then
    f(Param p) = if count<11 or count%10=0 or nf-count<=10
                 then prints("Term ",count,": ",p)
		 fi; count+:=1; twisted_full_deform_to_ht(p,N)
    in prints("Fully twisted deforming ",nf," terms (",#unfixed,
    " unfixed).");
    map(f,fixed)+half(unfixed.K_type_pol)
  fi
)

{.Hermitian form to ht on a irreducible module, normalization from its
initial term.}

set hermitian_form_irreducible_to_ht_old (Param p,int N) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_irreducible_to_ht_old(p,N) { not twisted, in equal rank case this is faster }
  else  check_hermitian(p,true); twisted_c_form_irreducible_to_ht(p,N)
  fi.convert_cform_hermitian

set hermitian_form_irreducible_to_ht (Param p,int N) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_irreducible_to_ht(p,N) { not twisted, in equal rank case this is faster }
  else  check_hermitian(p,true); twisted_c_form_irreducible_to_ht(p,N)
  fi.convert_cform_hermitian

{ compute Hermitian form to ht on p, and report if it is unitary }
set is_unitary_to_ht (Param p,int N) = bool:
  unitary_test_counter.use();
  if N < 0 then is_unitary(p)
  else p.is_hermitian and hermitian_form_irreducible_to_ht(p,N).is_pure
  fi

{ compute Hermitian form to ht on p, and report if it is unitary }
set is_unitary_to_ht_old (Param p,int N) = bool:
  unitary_test_counter.use();
  p.is_hermitian and hermitian_form_irreducible_to_ht_old(p,N).is_pure

{ compute Hermitian form to ht on p, report if it is unitary,
  and record certificate }
set is_unitary_to_ht (Param p,int N, KTypePol_hash cert_hash) = bool:
  unitary_test_counter.use();
  p.is_hermitian and is_pure_cert_hash(hermitian_form_irreducible_to_ht(
  p,N), cert_hash)

set is_unitary_to_hts(Param p, [int] Ns) = bool:
    { is_pos_on_LKTs(p) and }
    unitary_test_counter.use();
    for N in Ns
    do if not is_unitary_to_ht(p,N)
       then return false
       fi
    od;
    true
