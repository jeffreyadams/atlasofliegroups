<basic.at
<hermitian.at
<convert_c_form.at
<count.at {for use counter}
{preferred to_ht(ParamPol,int)}
{Turns out the "preferred" versions are significantly slower almost
always; don't understand why. So switch to "old" versions as standard,
labelling others as "new"}
{If HT < 0, then use full version}
set herm_report = bool: false

set low_height(KTypePol P) = int:
    if P.= then -1
    else min(0)(for @t in P do height(t) od)
    fi

set low_height(ParamPol P) = int:
    if P.= then -1
    else min(0)(for @t in P do height(t) od)
    fi

set impure_height(KTypePol P) = int:
    if is_pure(P) then -1
    else let (a, mu) = first_term(P)
    	 then () = if not is_pure(a) then return height(mu) fi
	 then () = for c@tau in a*P
	    	   do if not s_part(c).=
		      then return height(tau)
		      fi
		   od
	 in -1
     fi

set to_ht (int N) = (ParamPol->ParamPol): (ParamPol P):
  if N < 0 then P
  else let (below,)=height_split(P,N) in below
  fi

set to_ht(maybe_KTP P,int N) = maybe_KTP:
    if N < 0 then return P fi;
    case P
    | timed_out: timed_out()
    | done(r): done(to_ht(r,N))
    esac

set full_deform_to_ht_MvL(ParamPol P, int HT) = KTypePol:
  deform_to_height(P,HT)

set full_deform_to_ht_MvL (Param p, int height, int time) = maybe_KTP:
( if deformed_hash_flag
  then let j = deformedHash.lookup(p)
       in if j.>= and (deformedHash.height_index(j).= or deformedHash.height_index(j) >= height)
       	  then return to_ht(regroup(p.real_form, deformedHash.data_index(j)),height).done
	  fi
  fi;
  if not strict_low(p,height)
  then return to_ht(full_deform(p,time),height)
  fi;
let !empty_K=null_K_module(p.real_form), !empty=null_module(p)
  then output = empty_K, def = empty, expiration = elapsed_ms() + time
  then P = empty +
  { snap p down to a reducibility point, or tempered parameter }
     (let rp = reducibility_points(p)
       in
        if =#rp then output +:= p.K_type; [] else [p*rp~[0]] fi)
  then () = while >#P
       	    do set (def,P) :=
               (let q=first_param(P) in block_deform(q,P next P:=empty,height))
  	       ; if elapsed_ms() > expiration then return timed_out() fi
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output := (output next output:=empty_K) + kt; P := (P next P:=empty) + pp
  	    od
  then () = if deformed_hash_flag
       	    then deformedHash.append(p,height,output)
	    fi
  in done(output)
)

set full_deform_to_ht_old(Param p, int N) = KTypePol:
if height(p) > N then null_K_module(p.real_form)
elif height(p) = N then K_type_pol(p)
else let pc = alcove_center(p)
     in if deformed_hash_flag
	then deformedHash.entry(pc,N)
	elif not strict_low(pc,N)
  	then return to_ht(full_deform(pc),N)
	else deform_to_height(pc,N)
	fi
fi

{This version seems NOT faster or smaller}
set full_deform_to_ht(Param p, int N) = KTypePol:
  if not strict_low(p,N)
  then return to_ht(full_deform(p),N)
  fi;
    if N < 0 then return full_deform(p) fi;
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then deformedHash.entry(pc,N)
       else  deform_to_height(pc,N)
       fi
{deform_to_height(p,N)}

set twisted_full_deform_to_ht_MvL(Param p, int N) = KTypePol:
    if N < 0 then return twisted_full_deform(p) fi;
    let pc = alcove_center(p)
    in to_ht(twisted_full_deform(pc), N)

set twisted_full_deform_to_ht_MvL(Param p, int N, int time) = maybe_KTP:
    if N < 0 then return twisted_full_deform(p,time) fi;
    let pc = alcove_center(p)
    in to_ht(twisted_full_deform(pc,time), N)

set twisted_full_deform_to_ht(Param p,int N) = KTypePol:
    if N < 0 then return twisted_full_deform(p) fi;
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then twistedDeformedHash.entry_to_ht(pc,N)
       else to_ht(twisted_full_deform(pc),N)
       fi

set KL_sum_at_s_to_ht(int N) = (Param p) ParamPol:
  {let P = KL_sum_at_s_to_height(p,N)
  in} KL_sum_at_s_to_height(p,N)

set twisted_KL_sum_at_s_to_ht(int N) = (Param p) ParamPol:
  to_ht(N)(twisted_KL_sum_at_s(p))

set twisted_KL_sum_at_s_to_ht(int N) = (Param p) ParamPol:
  to_ht(N)(twisted_KL_sum_at_s(p))


{.write c-invariant form on standard module as a ParamPol of
standardrepKs to specified height.}

set c_form_std_to_ht_MvL(int N) = (Param->KTypePol):(Param p):
{ never involves |twisted_full_deform| }
  if not strict_low(p,N)
  then return to_ht(full_deform(p),N)
  fi;
   full_deform_to_ht_MvL(p,N)

set c_form_std_to_ht_MvL(int N, int time) = (Param->maybe_KTP):(Param p):
{ never involves |twisted_full_deform| }
   full_deform_to_ht_MvL(p,N,time)


set c_form_std_to_ht(int N) = (Param->KTypePol):(Param p):
{ never involves |twisted_full_deform| }
  if not strict_low(p,N)
  then return to_ht(full_deform(p),N)
  fi;
   full_deform_to_ht(p,N)

set twisted_c_form_std_to_ht_MvL(int N) = (Param->KTypePol):(Param p):
   twisted_full_deform_to_ht_MvL(p,N)

set twisted_c_form_std_to_ht_MvL(int N, int time) = (Param->maybe_KTP):(Param p):
   twisted_full_deform_to_ht_MvL(p,N,time)

set twisted_c_form_std_to_ht(int N) = (Param p)KTypePol:
   twisted_full_deform_to_ht(p,N)

{    c_form_to_ht on irreducible representations   }
set oriented_KL_sum_to_ht  (int N) = (Param p)ParamPol:
   let ori_nr_p = orientation_nr(p) in  null_module(real_form(p)) +
   for c@q in KL_sum_at_s_to_height(p,N) do (c*orientation_nr_term(ori_nr_p,q),q) od

{    c_form_to_ht on irreducible representations   }
{
set oriented_KL_sum_to_ht  (int N, int time) = (Param p)ParamPol:
   let ori_nr_p = orientation_nr(p)
   then Q = KL_sum_at_s_to_height(p,N,time)
   then num = #Q
   in  if num = 0 or num = 105553145633924
       then Q
       else for c@q in Q
       	    do (c*orientation_nr_term(ori_nr_p,q),q)
	    od
}

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as ParamPol of standardrepKs.}
set c_form_irreducible_to_ht_MvL (Param p,int N) = KTypePol:
  if not strict_low(p,N)
  then return (to_ht(c_form_irreducible(p),N))
  fi;
  if not(herm_report) then
  map(c_form_std_to_ht_MvL(N), oriented_KL_sum_to_ht(N)(p) )
  else
  let P=oriented_KL_sum_to_ht(N)(p), count=0 then nP=#P
  then
    f(Param p) = if count<11 or count%10=0 or nP-count<=10
                 then prints("Term ",count,": ",p)
                 fi; count+:=1; full_deform_to_ht(p,N)
  in prints("Fully deforming ",nP," terms"); map(f, P)
  fi

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as ParamPol of standardrepKs.}

set c_form_irreducible_to_ht_MvL (Param p,int N, int time ) = maybe_KTP:
  if not strict_low(p,N)
  then return to_ht(c_form_irreducible(p,time),N)
  fi;
  let P=oriented_KL_sum_to_ht(N)(p), count=0 then nP=#P, expiration =
  elapsed_ms()+time, !empty_K = null_K_module(p.real_form)
  then list = for c@q in P
       	      ~do let Q = full_deform_to_ht_MvL(q, N, expiration - elapsed_ms())
	      	  in case Q
		     | timed_out: return timed_out()
		     | done(r): c*r
		     esac
	       od
       	     { ~do let Q = c*full_deform_to_ht(q, N)
	      	  then () = if elapsed_ms() - start > time
		       	    then flag:= false; break
			    fi
		  in Q
	       od}
  in sum(p.real_form, list).done


set c_form_irreducible_to_ht_MvL2 (Param p,int N, int time ) = maybe_KTP:
  if not strict_low(p,N)
  then return to_ht(c_form_irreducible(p,time),N)
  fi;
  let P=oriented_KL_sum_to_ht(N)(p), count=0 then nP=#P, expiration =
  elapsed_ms()+time, !empty_K = null_K_module(p.real_form)
  then list = for c@q in P
       	      ~do let Q = full_deform_to_ht_MvL(q, N, expiration - elapsed_ms())
	      	  in case Q
		     | timed_out: return timed_out()
		     | done(r): c*r
		     esac
	       od
       	     { ~do let Q = c*full_deform_to_ht(q, N)
	      	  then () = if elapsed_ms() - start > time
		       	    then flag:= false; break
			    fi
		  in Q
	       od}
  in sum(p.real_form, list).done


{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as ParamPol of standardrepKs.}
set c_form_irreducible_to_ht (Param p,int HT) = KTypePol:
  if not strict_low(p,HT)
  then return to_ht(c_form_irreducible(p),HT)
  fi;
  if not(herm_report) then
  let G = p.real_form in
  map(c_form_std_to_ht(HT), oriented_KL_sum_to_ht(HT)(p) )
  else
  let P=oriented_KL_sum_to_ht(HT)(p), count=0 then nP=#P
  then
    f(Param p) = if count<11 or count%10=0 or nP-count<=10
                 then prints("Term ",count,": ",p)
                 fi; count+:=1; full_deform_to_ht(p,HT)
  in prints("Fully deforming ",nP," terms"); map(f, P)
  fi

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as ParamPol of standardrepKs.}
set c_form_irreducible_to_ht (Param p,int HT, int time) = maybe_KTP:
  if not strict_low(p,HT)
  then return to_ht(c_form_irreducible(p,time),HT)
  fi;
  let G = p.real_form in
  map(c_form_std_to_ht_MvL(HT,time), oriented_KL_sum_to_ht(HT)(p) )

{ utility: compute fixed and unfixed contributions to c-form on irreducible(p)
  no deformation is done, but orientation numbers are included;
  fixed contributions are already halved; for unfixed ones this needs to wait
}
set twisted_c_form_irreducible_contributions_to_ht(Param p,int HT) =
    (ParamPol,ParamPol): { (fixed part, 2*unfixed part) }
  if not strict_low(p,HT)
  then let (fix, two_un) = twisted_c_form_irreducible_contributions(p)
       in return (to_ht(HT)(fix), to_ht(HT)(two_un))
  fi;
  let G=p.real_form, ori_nr_p = orientation_nr(p)
  then formula = (1+s)*KL_sum_at_s_to_ht(HT)(p) + (1-s)*twisted_KL_sum_at_s_to_ht(HT)(p)
  in { two value-producing loops can be a lot more efficient than one: }
  ( G.null_module +
      for c@q in formula
      do if twist(q)=q then [(half(c)*orientation_nr_term(ori_nr_p,q),q)]
         else []
	 fi
      od.##
   , G.null_module +
      for c@q in formula
      do if twist(q)=q then []
         else [(c*orientation_nr_term(ori_nr_p,q),q)]
	 fi
      od.##
  )

{ The following function implements algorithm from Vogan in email 9/22/16:
  * for each delta-fixed term q add c_form_std(q) (fully twisted-deformed)
  * for each pair {q,delta(q)} add q.K_type_pol (deformation to nu=0 of q).
  For second kind it it convenient to add q.K_type_pol and delta(q).K_type_pol
  separately and at the end divide the sum of such contributions by 2.
}
{.twisted c-invariant form to height HT on an irreducible in terms of
standardrepKs.}

set twisted_c_form_irreducible_to_ht (Param p,int HT) = KTypePol:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions_to_ht(p,HT)
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  in
  if not herm_report
  then map(twisted_c_form_std_to_ht(HT),fixed)+half(unfixed.K_type_pol)
  else let nf = #fixed, count=0
  then 
    f(Param p) = if count<11 or count%10=0 or nf-count<=10
                 then prints("Term ",count,": ",p)
		 fi; count+:=1; twisted_full_deform_to_ht(p,HT)
    in prints("Fully twisted deforming ",nf," terms (",#unfixed,
    " unfixed).");
    map(f,fixed)+half(unfixed.K_type_pol)
  fi
)

set twisted_c_form_irreducible_to_ht (Param p,int HT, int time) = maybe_KTP:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions_to_ht(p,HT), start = elapsed_ms(),
  !empty_K = null_K_module(p.real_form), flag = true
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
{fixed has the role of P in c_form_irreducible_to_ht_MvL}
   then Q = map(twisted_c_form_std_to_ht_MvL(HT,time),fixed)
   in case Q
      | timed_out: timed_out()
      | done(r): (r + half(unfixed.K_type_pol)).done
      esac
)

set twisted_c_form_irreducible_to_ht_MvL (Param p,int HT) = KTypePol:
    twisted_c_form_irreducible_to_ht (p,HT)

set twisted_c_form_irreducible_to_ht_MvL (Param p,int HT, int time) = maybe_KTP:
    twisted_c_form_irreducible_to_ht (p,HT,time)

{low(p,HT) is supposed to tell that to_ht is likely to take twice as long as truncating hermitian_form}
{.Hermitian form to ht on a irreducible module, normalization from its
initial term.}
set hermitian_form_irreducible_to_ht_MvL (Param p,int HT) = KTypePol:
  if not strict_low(p,HT) then return to_ht(hermitian_form_irreducible(p),HT) fi;
  unitary_test_counter.use();
  {if HT > height(p) + 20 then prints(p,HT) fi;}
  let start_time = elapsed_ms(), answer =
  if is_equal_rank(real_form(p))
  then c_form_irreducible_to_ht_MvL(p,HT) { not twisted, in equal rank case this is faster }
  else  check_hermitian(p,true); twisted_c_form_irreducible_to_ht_MvL(p,HT)
  fi.convert_cform_hermitian
  then () = unitaryTime+:=elapsed_ms() - start_time
  then () = was_tested_to_ht(p,HT, elapsed_ms() - start_time,is_pure(answer))
  in answer

{.Hermitian form to ht on a irreducible module, normalization from its
initial term.}
set hermitian_form_irreducible_to_ht_MvL (Param p,int HT,int time) = maybe_KTP:
  if not strict_low(p,HT) then return to_ht(hermitian_form_irreducible(p,time),HT) fi;
  unitary_test_counter.use();
  let start_time = elapsed_ms()
  then answer =
  case if is_equal_rank(real_form(p))
       then c_form_irreducible_to_ht_MvL(p,HT,time) { not twisted, in equal rank case this is faster }
       else  check_hermitian(p,true); twisted_c_form_irreducible_to_ht_MvL(p,HT,time)
       fi
  | timed_out: was_tested_inter(p, elapsed_ms() - start_time, time);
    	       unitaryTime+:=elapsed_ms() - start_time; return timed_out()
  | done(r): let ans = r.convert_cform_hermitian in was_tested_to_ht(p,HT,elapsed_ms() - start_time,
    	     is_pure(ans)); ans.done
  esac
  then () = unitaryTime+:=elapsed_ms() - start_time
  in answer

set hermitian_form_irreducible_to_ht (Param p,int HT) = KTypePol:
  if not strict_low(p,HT) then return to_ht(hermitian_form_irreducible(p),HT) fi;
  unitary_test_counter.use();
  {if HT > height(p) + 20 then prints(p,HT) fi;}
  let start_time = elapsed_ms(), answer =
  if is_equal_rank(real_form(p))
  then c_form_irreducible_to_ht(p,HT) { not twisted, in equal rank case this is faster }
  else  check_hermitian(p,true); twisted_c_form_irreducible_to_ht(p,HT)
  fi.convert_cform_hermitian
  then () = was_tested_to_ht(p,HT,elapsed_ms() - start_time, is_pure(answer))
  then () = unitaryTime+:=elapsed_ms() - start_time
  in answer

{ compute Hermitian form to ht on p, and report if it is unitary }
set is_unitary_to_ht_base (Param p,int HT) = bool:
   if HT < 0 then is_unitary(p)
   else p.is_hermitian and hermitian_form_irreducible_to_ht(p,HT).is_pure
   fi

{ compute Hermitian form to ht on p, and report if it is unitary }
set is_unitary_to_ht_MvL (Param p,int HT) = bool:
      p.is_hermitian and hermitian_form_irreducible_to_ht_MvL(p,HT).is_pure

{ compute Hermitian form to ht on p, and report if it is unitary }
set is_unitary_to_ht_MvL (Param p,int HT, int time) = int: { -1: no, 0:timed out, 1: yes }
   let start_time = elapsed_ms()
   in   if p.is_hermitian
      	else -1
      	then case hermitian_form_irreducible_to_ht_MvL(p, HT, time)
     	   | timed_out: 0
	   | done(result): let boo = result.is_pure
	     		   in if boo then 1 else -1 fi
	   esac
      fi

{ compute Hermitian form to ht on p, report if it is unitary,
  and record certificate }
set is_unitary_to_ht (Param p,int HT, KTypePol_hash cert_hash) = bool:
  p.is_hermitian and is_pure_cert_hash(hermitian_form_irreducible_to_ht(
  p,HT), cert_hash)

{table of is_unitary results, indexed by Param}
{not used}
{
set_type
[ unitarity_to_hts_bool_hash =
( ( -> int) heights_size {number of heights stored}
  , ( -> vec) heights_list
  , ( -> vec) count {entry i is number of Param's at ith height}
  , ( -> ) clear
  , ((Param,int)->bool) entry
  , ((Param,int)->) append
  , ((int,int) -> Param) param_index {for (i,j), returns Param #j
    	       	  	 	     from ith list}
  , ((int,int) -> bool) data_index
  )
]

{IS THERE A QUADRATIC CONCATENATION PROBLEM???}
set make_unitarity_to_hts_bool_hash () = unitarity_to_hts_bool_hash:
(  let heights_list = vec: []
   then param_hashes = [Param_hash]: []
   then bool_datas = [[bool]] : []
   then clear() = void:
   	let () = heights_list := []
	then () = param_hashes := []
 	then () = bool_datas:=[]
       	in ()
   in
   ( ( -> int): { heights_size } @int: #heights_list
   , ( -> vec): {heights_list} @vec: for data in bool_datas
       	  		       	     do #data
				     od
   , ( -> vec): { count } @vec: for data in bool_datas
       	  	  	  	  do count(data)
				  od
   , ( -> ): {clear} clear
   , ((Param,int)-> bool): {entry} (Param p, int h) bool:
     begin
	let M = #heights_list
	then m = find(heights_list, h)
	then () = if m = -1 {we haven't seen this height before}
	     	  then bool_datas:= (bool_datas next bool_datas:= [])#[];
		       param_hashes:=(param_hashes next param_hashes:=[])
		       				   #make_Param_hash();
		       heights_list:= (heights_list next heights_list := [])
		       		      #h;
		       m:=M
		  fi
	then N = param_hashes[m].size()
	then n = param_hashes[m].match(p)
	then () = if n = N {we haven't seen this p at this height}
	     	  then bool_datas[m]:=(bool_datas[m] next bool_datas[m] :=[])
		  		#is_unitary_to_ht_base(p,h)
		  fi
	then () =  assert(#bool_datas = #heights_list,
		       	      "unitarity_to_hts_bool_hash is damaged")
	then () = assert(#param_hashes = #heights_list,
		       	      "unitarity_to_hts_bool_hash is damaged")
	then () = assert(#bool_datas[m] = param_hashes[m].size(),
	     	  	      "unitarity_to_hts_bool_hash is damaged")
	in bool_datas[m][n]
     end
   , ((Param,int)->): {append } (Param p, int h):
     begin
	let M = #heights_list
	then m = find(heights_list, h)
	then () = if m = -1 {we haven't seen this height before}
	     	  then bool_datas:= (bool_datas next bool_datas:= [])#[];
		       param_hashes:=(param_hashes next param_hashes:=[])
		       				   #make_Param_hash();
		       heights_list:= (heights_list next heights_list := [])
		       		      #h;
		       m:=M
		  fi
	then N = param_hashes[m].size()
	then n = param_hashes[m].match(p)
	in if n = N {we haven't seen this p at this height}
	   then bool_datas[m]:=(bool_datas[m] next bool_datas[m] :=[])
		  		#is_unitary_to_ht_base(p,h)
	   fi
     end
   , ((int,int) -> Param): {param_index} (int i, int j):
     		param_hashes[i].index(j)
   , ((int,int) -> bool): {data_index} (int i, int j): bool_datas[i][j]
  )
)
}

{set unitarity_to_hts_hash = make_unitarity_to_hts_bool_hash ()}

{set is_unitary_to_ht_hash(Param p, int h) = unitarity_to_hts_hash.entry(p,h)}

{whether to tabulate results of is_unitary_to_ht. "true" certainly reduces
number of tests, and seems to help a bit with time.}

{set to_hts_hash_flag = true}

set is_unitary_to_ht(Param p, int h) =  bool:
    {if to_hts_hash_flag
    then unitarity_to_hts_hash.entry(p,h)
    else} is_unitary_to_ht_base(p,h)
    {fi}

set is_unitary_to_hts(Param p, [int] Ns) = bool:
    { is_pos_on_LKTs(p) and }
    {unitary_test_counter.use();}
    for N in Ns
    do if not is_unitary_to_ht(p,N)
       then return false
       fi
    od;
    true

{
set is_unitary_to_hts_hash(Param p, [int] Ns) = bool:
    { is_pos_on_LKTs(p) and }
    {unitary_test_counter.use();}
    for N in Ns
    do if not is_unitary_to_ht_hash(p,N)
       then return false
       fi
    od;
    true}
