<extParamPol.at

set ecf_verbose=false
{when translating an extended module:
suppose
1) p has regular infinitesimal character
2) delta*p\ne p
3) gamma is singular
4) T_std(p,gamma) is (nonzero and) delta-fixed
Then p represents the extended module ind(p) = ind(delta(p))
translation of p to gamma must be 2*T_std(p,gamma)
}

set T_std(Param p, ratvec gamma, mat delta)=ParamPol:
let Tp=T_std(p,gamma) in
if is_fixed(delta,Tp) and not(is_fixed(delta,p))
 then  2*Tp
 else  1*Tp
fi

set T_std(ParamPol P,ratvec gamma, mat delta)=ParamPol:
0*P  {null_module(P.real_form)} + for c@p in P do T_std(p,gamma,delta) od

set T_std(ZExtParamPol (P,Q,R,delta),ratvec gamma)=
(T_std(P,gamma),
 T_std(Q,gamma),
 T_std(R,gamma,delta),
 delta)


{the extended character formula for (p,delta), as a ZExtParamPol,
 i.e. (P,Q,R,delta), where P/Q/R are ZParamPols (no s terms), giving
 the plus/minus/induced terms of the character formula for the extended group G^delta}

{TEST: is_fixed(delta,p): right_restrict(extended_character_formula(p,delta)).s_to_1=character_formula(p)
         otherwise      : right_restrict(extended_character_formula(p,delta)).s_to_1=one_plus_twist(character_formula(p),delta)}

set extended_character_formula_reg (Param p,mat delta, bool strictly_regular) =ZExtParamPol:
assert(not strictly_regular or is_regular(p.root_datum,p.infinitesimal_character),"infinitesimal character is not regular");
let start_time=elapsed_ms() in
let G=p.real_form in
if not is_fixed(p,delta) then
{ extended rep = ind(\pi) = ind(\delta(pi))
  so if cf(p) = \sum a_i p_i + \sum b_j q_j (p_i/q_j fixed/non-fixed, resp.) then
  cf(extended rep) = \sum a_i (p_{i,+} + p_{i,-}) + \sum b_j ind(b_j)}
  let cf=character_formula(p) then
  fixed=fixed_terms(delta,cf) in
  ZExtParamPol:(fixed, fixed, cf-fixed,delta)
else
  {calculated using big_KL_P_signed_polynomials}
  let (,plus,minus,ind,)=null_ext_module(G) then
{  B=block_of(p) then}
  ()=if ecf_verbose then let end_time=elapsed_ms() then ()=prints("ecf time 1: ", end_time-start_time) then start_time=end_time in () fi  then
  B=partial_block(p) then
  ()=if ecf_verbose then let end_time=elapsed_ms() then ()=prints("ecf time 2: ", end_time-start_time) then start_time=end_time in () fi  then
  partial_KL_block=partial_KL_block(p) then
  ()=if ecf_verbose then let end_time=elapsed_ms() then ()=prints("ecf time 3: ", end_time-start_time) then start_time=end_time in () fi  then
  partial_extended_KL_block=partial_extended_KL_block(p,delta) then
  ()=if ecf_verbose then let end_time=elapsed_ms() then ()=prints("ecf time 4: ", end_time-start_time) then start_time=end_time in () fi  then
  (B_delta,P_delta_matrix,polys_delta)=partial_extended_KL_block then
  ()=if ecf_verbose then let end_time=elapsed_ms() then ()=prints("ecf time 5: ", end_time-start_time) then start_time=end_time in () fi  then
  map_B_Bdelta=mapping(B,B_delta) then
  ()=if ecf_verbose then let end_time=elapsed_ms() then ()=prints("ecf time 6: ", end_time-start_time) then start_time=end_time in () fi  then
   (B,P_matrix,polys)=partial_KL_block then
   tabulated_indices=tabulate_indices(B,delta) then
   (I_delta,g,complete_indices,delta_action)=tabulated_indices then
  ()=if ecf_verbose then let end_time=elapsed_ms() then ()=prints("ecf time 7: ", end_time-start_time) then start_time=end_time in () fi  then
  index=find(complete_indices,(find(B,p),1)) then
  ()=if ecf_verbose then prints("#complete indices: ", #complete_indices) fi in
  for (j,type)@i in complete_indices do
  let ()=if ecf_verbose then
     let end_time=elapsed_ms() then ()=prints("ecf time in loop: ",i, "  ", end_time-start_time) then start_time=end_time in () fi  in
    let c=eval(big_KL_P_signed_polynomial(p,partial_KL_block,partial_extended_KL_block,tabulated_indices,map_B_Bdelta,delta,i,index),1) in
     if !=c then
     if type=1 then {prints("plus "," index=",index, " i=",i, " j=",j," c=",c," B[j]=",B[j]);}plus+:=c*B[j]
       elif type=-1 then {prints("minus, i=", i, " j=",j, " index=",index," c=",c);}minus+:= c*B[j]
       elif type=0 then  {prints("ind", "j=",j, "c=",c);} ind+:=c*B[j]
       else error("c\ne 0,\pm 1")
     fi
    fi
  od;
  let rv=(plus,minus,ind,delta) in
  assert(is_ZExtParamPol(rv),"Not a ZExtParamPol");rv
fi

set extended_character_formula_reg (Param p,mat delta) =ZExtParamPol:
extended_character_formula_reg (p,delta,true)

set extended_character_formula_naive (Param p,mat delta) =ZExtParamPol:
extended_character_formula_reg (p,delta,false)

set extended_character_formula_by_translation (Param p,mat delta) =ZExtParamPol:
if is_regular(p) then extended_character_formula_reg(p,delta) else
let preg=make_regular_param(p) then
ecfreg=extended_character_formula_reg(preg,delta) then
rv=T_std(ecfreg,p.infinitesimal_character) in
  assert(is_ZExtParamPol(rv),"Not an ZExtParamPol");rv
fi
{TEST: is_fixed(delta,p): right_restrict(extended_character_formula(p,delta)).s_to_1=character_formula(p)
         otherwise      : right_restrict(extended_character_formula(p,delta)).s_to_1=one_plus_twist(character_formula(p),delta)}

set extended_character_formula (Param p,mat delta) =ZExtParamPol:extended_character_formula_naive(p,delta)

set test_extended_character_formula (Param p,mat delta) =(bool,ZExtParamPol,ParamPol):
let ecf=extended_character_formula(p,delta) then
cf=character_formula(p) in
if is_fixed(delta,p) then
 (right_restrict(ecf).s_to_1=cf,ecf,cf)
else
 (right_restrict(ecf).s_to_1=one_plus_twist(cf,delta),ecf,cf)
fi

set test_extended_character_formula_by_translation (Param p,mat delta) =(bool,ZExtParamPol,ParamPol):
let ecf=extended_character_formula_by_translation(p,delta) then
cf=character_formula(p) in
if is_fixed(delta,p) then
 (right_restrict(ecf).s_to_1=cf,ecf,cf)
else
 (right_restrict(ecf).s_to_1=one_plus_twist(cf,delta),ecf,cf)
fi