{the extended character formula for (p,delta), as a ZExtParamPol,
 i.e. (P,Q,R,delta), where P/Q/R are ZParamPols (no s terms), giving
 the plus/minus/induced terms of the character formula for the extended group G^delta}

{TEST: is_fixed(delta,p): right_restrict(extended_character_formula(p,delta)).s_to_1=character_formula(p)
         otherwise      : right_restrict(extended_character_formula(p,delta)).s_to_1=one_plus_twist(character_formula(p),delta)}

set extended_character_formula_reg (Param p,mat delta) =ZExtParamPol:
{assert(is_regular(p.root_datum,p.infinitesimal_character),"infinitesimal character is not regular");}
let G=p.real_form in
if not is_fixed(p,delta) then
{ extended rep = ind(\pi) = ind(\delta(pi))
  so if cf(p) = \sum a_i p_i + \sum b_j q_j (p_i/q_j fixed/non-fixed, resp.) then
  cf(extended rep) = \sum a_i (p_{i,+} + p_{i,-}) + \sum b_j ind(b_j)}
  let cf=character_formula(p) then
  fixed=fixed_terms(delta,cf) in
  ZExtParamPol:(fixed, fixed, cf-fixed,delta)
else
  {calculated using big_KL_P_signed_polynomials}
  let (,plus,minus,ind,)=null_ext_module(G) then
  B=block_of(p) then
  (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta) then
  P=big_KL_P_signed_polynomials(p,delta) then
  index=find(complete_indices,(find(B,p),1)) in
  let ()=prints("OK") in
  for (j,type)@i in complete_indices do
   let c=eval(P[i][index],1) in {key point here: evaluate at q=1}
    if !=c then
     if type=1 then prints("plus", "j=",j, "c=",c);plus+:=c*B[j]
       elif type=-1 then prints("minus", "j=",j, "c=",c);minus+:= c*B[j]
       elif type=0 then  prints("ind", "j=",j, "c=",c); ind+:=c*B[j]
       else error("c\ne 0,\pm 1")
     fi
    fi
  od;
(plus,minus,ind,delta)
fi

{
set extended_character_formula_reg_old (Param p,mat delta) =ZExtParamPol:
{assert(is_regular(p.root_datum,p.infinitesimal_character),"infinitesimal character is not regular");}
let G=p.real_form in
if not is_fixed(p,delta) then
{ extended rep = ind(\pi) = ind(\delta(pi))
  so if cf(p) = \sum a_i p_i + \sum b_j q_j (p_i/q_j fixed/non-fixed, resp.) then
  cf(extended rep) = \sum a_i (p_{i,+} + p_{i,-}) + \sum b_j ind(b_j)}
  let cf=character_formula(p) then
  fixed=fixed_terms(delta,cf) in
  ZExtParamPol:(fixed, fixed, cf-fixed,delta)
else
  {calculated using big_KL_P_signed_polynomials}
  let (,plus,minus,ind,)=null_ext_module(G) then
  B=block_of(p) then
  (I_delta,g,complete_indices,delta_action)=tabulate_indices(B,delta) then
  P=big_KL_P_signed_polynomials(B,delta) then   {this should the partial extended block?}
  index=find(complete_indices,(find(B,p),1)) in
  for (j,type)@i in complete_indices do
   let c=eval(P[i][index],s) in
    if !=c then
     if type=1 then plus+:=int_part(c)*B[j]; minus+:=s_part(c)*B[j]
       elif type=-1 then minus+:= int_part(c)*B[j];plus+:=s_part(c)*B[j]
       elif type=0 then  {prints("ind=", ind,"c=",c," j=",j);} ind+:=(int_part(c)+s_part(c))*B[j]
       else error("c\ne 0,\pm 1")
     fi
    fi
  od;
(plus,minus,ind,delta)
fi
}
{try this for now}
set extended_character_formula (Param p,mat delta) =ZExtParamPol:extended_character_formula_reg(p,delta)

{TEST: is_fixed(delta,p): right_restrict(extended_character_formula(p,delta)).s_to_1=character_formula(p)
         otherwise      : right_restrict(extended_character_formula(p,delta)).s_to_1=one_plus_twist(character_formula(p),delta)}
         
set test_extended_character_formula_reg (Param p,mat delta) =(bool,ZExtParamPol,ParamPol):
let ecf=extended_character_formula_reg(p,delta) then
cf=character_formula(p) in
if is_fixed(delta,p) then
 (right_restrict(ecf).s_to_1=cf,ecf,cf)
else
 (right_restrict(ecf).s_to_1=one_plus_twist(cf,delta),ecf,cf)
fi