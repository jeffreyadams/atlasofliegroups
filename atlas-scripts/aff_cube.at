<basic.at {for numer}
<ratmat.at {for ratmat}
<hash.at {for hash tables}
<FPP_faces_geom.at {for fundamental vertices}
<FPP_faces_herm.at {for FPP_lambdas}

{dimension of the convex hull of the vertices}
set cvx_hull_dim([ratvec] verts) = int:
    if #verts = 0 then return(-1) fi;
    let norms = mat: for v in verts[1:] do (v-verts[0]).numer od
    in rank(norms)

set make_ratmat([ratvec] cols) = ratmat:
    if #cols = 0 then return null(0,0)/1 fi;
    let D = lcm(for v in cols do v.denom od)
    then M = mat: for v in cols do ratvec_as_vec(D*v) od
    in M/D

{list of all representatives of conjugacy classes of Cartan involutions of greatest length,
indexed by CartanClass number}
set longest_invs(InnerClass ic) = [[mat]]:
    let G = quasisplit_form(ic)
    then CC = Cartan_classes(ic)
    then inv_hash = make_mat_hash()
    in for C in CC
       do let KGBlist = KGB(C,G)
       	  then max_lgth = length(KGBlist~[0])
	  then first_long = locate_sorted(for x in KGBlist do length(x) od, max_lgth)
	  then () = inv_hash.clear()
	  then () = for x in KGBlist[first_long:] do inv_hash.match(x.involution) od
	  in inv_hash.list()
       od
{Each vertex v is (w,tau)*f = wf + tau, with tau a sum of roots, w in W, and f a (UNIQUE)fundamental
vertex; w is in a unique coset of W(f1); here W(f1) is the maximal pseudoLevi in W generated by the
W parts of all affine reflections EXCEPT s_f1.

Each edge (v1,v2) is (w,tau)*(f1,f2) has a type (f1,f2), which is a (UNIQUE) pair of distinct
fundamental vertices. The edges of type (f1,f2) starting at f1 are (f1, W(f1)*(f1-f2))}

{ith list is edges starting at fundamental vertex i; put zero in ith place of ith list}
set fund_edges(InnerClass ic) = [[ratvec]]:
    let f_verts = fundamental_vertices(ic)
    in for v in f_verts
       do for w in f_verts
       	  do v - w
	  od
       od

{(i,j)th list is ALL edges starting at fundamental vertex i of type (i,j). "Half fundamental"
means that one endpoint of the edge is in the fundamental alcove.}
set half_fund_edges(InnerClass ic) = [[[ratvec]]]:
    let fverts = fundamental_vertices(ic)
    in for e@i in fverts
       do let rde = integrality_datum(ic,e)
       	  in for f@j in fverts
       	  do for w in Weyl_orbit_ws(rde, (f-e).numer)
       	     do w*(f-e)
	     od {this [ratvec] is the edges of type (i,j) starting at e}
	  od
       od

{to get edges of type (i,j) starting at some gamma = (x,tau)*fverts[i], apply x to half_fund_edges[i][j]}

{Given m by n integer matrix A and integer vec b of size m, consider
affine space

H = {v in Q^n | Av = b}

of dimension (m-rank(A)) (if b is in im(A); empty otherwise). Set

F = {v in Q^n | 0 \le v_i \le 1, all i}

unit cube. Goal is to describe explicitly the compact convex polytope
H\cap F by describing its extreme points. A d-dimensional FACE of F is
given by a subset S of {0,...,n-1} of cardinality n-d, and a fixed value
epsilon_i in {0,1} for each coordinate not in S; then

F(S,epsilon) = {v \in Q^n | v_i = epsilon_i (i in S), v_j \in [0,1] (j
not in S)}

A GOOD EXTREME POINT of F\cap H is a v in the interior of a face
F(S,epsilon), such that H\cap F(S,epsilon) = {v}

Claim/conjecture: H\cap F is the convex hull of its good extreme
points.}
{A size m by n, b size m}
set good_interior_point(mat A, vec b) = [ratvec]:
    if rank(A) < #A then []
    else
       for x in [ratvec]: solve(A,b/1).to_list
          if all(for xi in x do xi>0 and 1>xi od) do x fi
       od
    fi

{Faces of dim at most r. Each term in result is subset of {0,..,n-1} of
card n-d \ge n-r, and vec of size n-d with all entries 0 or 1}
set cube_faces(int n, int r) = [([int],vec)]:
    for m:r+1 from n-r
    do let N = binom(n,m) {number of subsets of n of size m}
       then betas = box(2,m)
       in for j:N
       	  do let S = combination_decode(m)(j)
       	     in for beta in betas
	     	do (S,vec:beta)
	     	od {everything attached to subset S}
       	  od.## {everything attached to all subsets of size m}
    od.##

{each term in result is subset of {0,..,n-1} of card n-d, and vec of
size n-d with all entries 0 or 1}
set cube_faces(int n) = [([int],vec)]:
    for S in power_set(n)
    do let n_minus_d = #S
       in for beta in box(2,n_minus_d)
       	  do (S,vec:beta)
	  od
    od.##

{S is meant to be n-d coordinates; on i in S, require v[i] = epsilon[i]}
set face_restrict(mat A, vec b, [int] S, vec epsilon) = (mat,vec):
    let m = #b, n=#A
    then T = complement(n,S)
    then Ares = mat:
    	 if #T = 0
    	 then null(m,0)
    	 else for j in T do A[j] od
    	 fi
    then bres = vec: b - sum(#b, for i@m in S do epsilon[m]*A[i] od)
    in (Ares, bres)

{A size m by n, b size m}
{should only look at subsets of size up to rank(A)}
set aff_cube_extrema(mat A, vec b) = [ratvec, [int], vec]:
    let n = #A
    then v = [rat]: for j:n do 0/1 od
    then r = rank(A) {replace by tr(A) - #A??}
    in for (S,epsilon) in cube_faces(n,r)
       do let this = good_interior_point(face_restrict(A,b,S,epsilon))
       	  then T = complement(n,S)
       	  then () = if #this = 1
	     	    then {prints(this, " ",T);}
		    	 for k@m in T do v[k]:=this[0][m] od;
		  	 for j@n in S do v[j]:=epsilon[n] od
		    fi
	  in if #this = 1 and A*v = b
       	     then {prints(this, "  ", A*v-b," ");}
	     [(ratvec:v, S, epsilon)]
	     else []
	     fi
       od.##

{just see if there's at least one soln}
set aff_cube_extrema_short(mat A, vec b) = bool:
    let n = #A, answer = false
    then r = rank(A) {replace by tr(A) - #A??}
    then () = for (S,epsilon) in cube_faces(n,r)
       	      ~do if #good_interior_point(face_restrict(A,b,S,epsilon)) = 1
       	      	 then answer:=true; break
		 fi
	      od
    in answer


{A size m by n, b size m}
{Now V is size n by q, the q edges of the parallelepiped we wish to investigate.}
{should only look at subsets of size up to rank(A)}
set aff_cube_extrema(mat C, [ratvec] V, vec b) = [{(}ratvec{,[int],ratvec)}]:
    let d = lcm(for v in V do v.denom od)
    then A = mat: for v in V do C*ratvec_as_vec(d*v) od
    in for (x,{S},{epsilon}) in aff_cube_extrema(A,d*b)
       do {(}V*x {, S, V*epsilon)}
       od

set aff_cube_extrema_short(mat C, [ratvec] V, vec b) = bool:
    let d = lcm(for v in V do v.denom od)
    then A = mat: for v in V do C*ratvec_as_vec(d*v) od
    in aff_cube_extrema_short(A,d*b)

set aff_cube_extrema_old(mat A, vec b) = [ratvec, [int], vec]:
    let n = #A
    then v = [rat]: for j:n do 0/1 od
    {then r = rank(A)} {replace by tr(A) - #A??}
    in for (S,epsilon) in cube_faces(n{,r})
       do let this = good_interior_point(face_restrict(A,b,S,epsilon))
       	  then T = complement(n,S)
       	  then () = if #this = 1
	     	    then {prints(this, " ",T);}
		    	 for k@m in T do v[k]:=this[0][m] od;
		  	 for j@n in S do v[j]:=epsilon[n] od
		    fi
	  in if #this = 1 and A*v = b
       	     then {prints(this, "  ", A*v-b," ");}
	     [(ratvec:v, S, epsilon)]
	     else []
	     fi
       od.##


set twist(KGBElt x, ratvec lambda) = ratvec:
    parameter(twist(x),x.real_form.distinguished_involution *lambda,
    	      0*lambda).lambda

set lFeCounter = int: 0
set lFeTimer = int: 0

{set aff_old_flag = false}

{NEED to compute entirely in delta-fixed cone; test delta_min_1*ans misses
pairs exchanged by delta}
set local_FPP_extrema_old(KGBElt x, ratvec lambda) = [ratvec]:
    let () = lFeCounter +:=1
    then start = elapsed_ms()
    then () = if twist(x) != x or twist(x,lambda) != lambda then return [] fi
    then G = x.real_form
    then Afflines = [ratvec]: FPP_lines(G) {edges of FPP}
    then Affcoroots = mat: FPP_coroots(G).^
    then Aold = 1+x.involution
    then lamthlam = (Aold*lambda).numer
    {then () = prints(Aold)}
    then A = mat: for xi@j in Afflines
    	     	  do ratvec_as_vec(Affcoroots*Aold*xi) od
    {then () = prints(A)}
    then b = Affcoroots*lamthlam
    {then () = prints(lamthlam," ",b)}
    then answer = for (u,,) in aff_cube_extrema(A,b)
       	 	  do Afflines*u
       		  od
    then () = lFeTimer +:= elapsed_ms() - start
    in answer

{NEED to compute entirely in delta-fixed cone; test delta_min_1*ans misses
pairs exchanged by delta}
set local_FPP_extrema_med = ((KGBElt, ratvec) -> [ratvec]):
    let rf_hash = make_RealForm_hash()
    then inv_hash = [mat_hash]: [] {one for each real form}
    then lamthlam_hash = [[vec_hash]]: [] {one for each real form and involution}
    then answer_list = [[[vec]]]: [] {for each real form, involution, and lamthlam, the indices in FPP
    	 	       		       	   vertices of the extremal points}
    then afflines = [[ratvec]]: [] {for each G, edges of FPP}
    then affcoroots = [mat]: [] {FPP_coroots(G), transpose}
    then vlists = [[ratvec]]: [] {possible local vertices for each G}
    then vlookups = [(ratvec -> int)]: []
    {then vds = [VertexData]: []}
    in ((KGBElt, ratvec) -> [ratvec]): (KGBElt x, ratvec lambda) [ratvec]:
       let RF = rf_hash.size(), rf = int:-1, inv = int: -1, ell = int: -1
       then G = x.real_form, start = elapsed_ms()
       then () = rf := rf_hash.match(G)
       then () = if rf = RF {haven't seen this real form before}
	   	 then inv_hash #:= make_mat_hash();
		      lamthlam_hash #:= ([vec_hash]:[]);
		      answer_list #:= ([[vec]]:[]);
		      afflines #:= FPP_lines(G);
		      affcoroots #:= FPP_coroots(G).^ ;
		      vlists #:= FPP_local_vertices(G);
		      vlookups #:= index_in(FPP_local_vertices(G))
		 fi {rf = RF}
       then I = inv_hash[rf].size()
       then theta = x.involution
       then () = inv := inv_hash[rf].match(theta)
       then () = if inv = I {haven't seen this involution before}
	         then lamthlam_hash[rf] #:= make_vec_hash();
		      answer_list[rf] #:= ([vec]:[])
		 fi {inv = I}
       then L = lamthlam_hash[rf][inv].size()
       then lamth = ((1+theta)*lambda).numer
       then () = ell := lamthlam_hash[rf][inv].match(lamth)
       then () = if ell = L {haven't see this lamthlam}
		 then let Aold = 1+theta
		      then A = mat: for xi@j in afflines[rf]
				    do ratvec_as_vec(affcoroots[rf]*Aold*xi)
			            od
		      then b = affcoroots[rf]*lamth
		      then alrf = answer_list[rf]
		      then () = alrf[inv] #:= for (u,,) in aff_cube_extrema(A,b)
					      do vlookups[rf](afflines[rf]*u)
					      od
		                then () = answer_list[rf]:= alrf
				then () = lFeCounter +:=1
 		                in ()
		  fi {ell=L}
	then () = lFeTimer +:= elapsed_ms() - start
	in for m in answer_list[rf][inv][ell] do vlists[rf][m] od

{this version might use less memory?}
set local_FPP_extrema_small = ((KGBElt, ratvec) -> [ratvec]):
    let rf_hash = make_RealForm_hash()
    then inv_hash = [mat_hash]: [] {one for each real form}
    then lamthlam_hash = [[vec_hash]]: [] {one for each real form and involution}
    then answer_list = [[[vec]]]: [] {for each real form, involution, and lamthlam, the indices in FPP
    	 	       		       	   vertices of the extremal points}
    then afflines = [[ratvec]]: [] {for each G, edges of FPP}
    then vlists = [[ratvec]]: [] {possible local vertices for each G}
    then vlookups = [(ratvec -> int)]: []
    {then vds = [VertexData]: []}
    in ((KGBElt, ratvec) -> [ratvec]): (KGBElt x, ratvec lambda) [ratvec]:
       let RF = rf_hash.size(), rf = int:-1, inv = int: -1, ell = int: -1
       then G = x.real_form, start = elapsed_ms()
       then () = rf := rf_hash.match(G)
       then () = if rf = RF {haven't seen this real form before}
	   	 then inv_hash #:= make_mat_hash();
		      lamthlam_hash #:= ([vec_hash]:[]);
		      answer_list #:= ([[vec]]:[]);
		      afflines #:= FPP_lines(G);
		      vlists #:= FPP_local_vertices(G);
		      vlookups #:= index_in(FPP_local_vertices(G))
		 fi {rf = RF}
       then I = inv_hash[rf].size()
       then theta = x.involution
       then () = inv := inv_hash[rf].match(theta)
       then () = if inv = I {haven't seen this involution before}
	         then lamthlam_hash[rf] #:= make_vec_hash();
		      answer_list[rf] #:= ([vec]:[])
		 fi {inv = I}
       then L = lamthlam_hash[rf][inv].size()
       then lamth = ((1+theta)*lambda).numer
       then () = ell := lamthlam_hash[rf][inv].match(lamth)
       then () = if ell = L {haven't see this lamthlam}
       	       	 then let th1 = 1+theta
		      then alrf = answer_list[rf]
		      then () = alrf[inv] #:= for u in aff_cube_extrema(th1, afflines[rf], lamth)
					      do vlookups[rf](u)
					      od
		                then () = answer_list[rf]:= alrf
				then () = lFeCounter +:=1
 		                in ()
		  fi {ell=L}
	then () = lFeTimer +:= elapsed_ms() - start
	in for m in answer_list[rf][inv][ell] do vlists[rf][m] od

{NEED to compute entirely in delta-fixed cone; test delta_min_1*ans misses
pairs exchanged by delta}
set local_FPP_extrema = ((KGBElt, ratvec) -> [ratvec]):
    let rf_hash = make_RealForm_hash()
    then afflines = [[ratvec]]: [] {for each G, edges of FPP}
    then inv_hash = [mat_hash]: [] {one for each real form}
    then lamthlam_hash = [[vec_hash]]: [] {one for each real form and involution}
    then answer_list = [[[[ratvec]]]]: [] {for each real form, involution, and lamthlam, the list of
    	 	       		       	       extremal vertices}
    in ((KGBElt, ratvec) -> [ratvec]): (KGBElt x, ratvec lambda) [ratvec]:
       let RF = rf_hash.size(), rf = int:-1, inv = int: -1, ell = int: -1
       then G = x.real_form, start = elapsed_ms()
       then () = rf := rf_hash.match(G)
       then () = if rf = RF {haven't seen this real form before}
	   	 then inv_hash #:= make_mat_hash();
		      lamthlam_hash #:= ([vec_hash]:[]);
		      answer_list #:= ([[[ratvec]]]:[]);
		      afflines #:= FPP_lines(G)
		 fi {rf = RF}
       then I = inv_hash[rf].size()
       then theta = x.involution
       then () = inv := inv_hash[rf].match(theta)
       then () = if inv = I {haven't seen this involution before}
	         then lamthlam_hash[rf] #:= make_vec_hash();
		      answer_list[rf] #:= ([[ratvec]]:[])
		 fi {inv = I}
       then L = lamthlam_hash[rf][inv].size()
       then lamth = ((1+theta)*lambda).numer
       then () = ell := lamthlam_hash[rf][inv].match(lamth)
       then () = if ell = L {haven't see this lamthlam}
       	       	 then let th1 = 1+theta
		      then alrf = answer_list[rf]
		      then () = alrf[inv] #:= aff_cube_extrema(th1, afflines[rf], lamth)
		      then () = answer_list[rf]:= alrf
		      then () = lFeCounter +:=1
 		      in ()
		  fi {ell=L}
	then () = lFeTimer +:= elapsed_ms() - start
	in answer_list[rf][inv][ell]

set local_FPP_extrema_short(KGBElt x, ratvec lambda) = bool:
    let () = lFeCounter +:=1
    then start = elapsed_ms()
    then () = if twist(x) != x or twist(x,lambda) != lambda then return false fi
    then G = x.real_form
    then Afflines = [ratvec]: FPP_lines(G) {edges of FPP}
    then Affcoroots = mat: FPP_coroots(G).^
    then Aold = 1+x.involution
    then lamthlam = (Aold*lambda).numer
    {then () = prints(Aold)}
    then A = mat: for xi@j in Afflines
    	     	  do ratvec_as_vec(Affcoroots*Aold*xi) od
    {then () = prints(A)}
    then b = Affcoroots*lamthlam
    {then () = prints(lamthlam," ",b)}
    then answer = aff_cube_extrema_short(A,b)
    then () = lFeTimer +:= elapsed_ms() - start
    in answer

set local_FPP_extrema_new_short(KGBElt x, ratvec lambda) = bool:
    let () = lFeCounter +:=1
    then start = elapsed_ms()
    then th1 = 1+x.involution, G = x.real_form
    then lamthlam = (th1*lambda).numer
    then answer = aff_cube_extrema_short(th1, FPP_lines(G), lamthlam)
    then () = lFeTimer +:= elapsed_ms() - start
    in answer

set trial(RealForm G) = void:
    for x in KGB(G)
    do prints("starting KGBElt ",x.number);
       let lambdas = FPP_lambdas(x), theta =x.involution
       then () = for lambda in lambdas
     	       	 do prints(new_line);
	      	    let b = ((1+x.involution)*lambda).numer
	     	    then Lvd = LPm_table.Lvd(G,theta,b)
	     	    then () = prints("Lvd.list = ",Lvd.list)
	     	    then long_answer = local_FPP_extrema (x,b)
	     	    then () = prints("extrema = ", long_answer)
	     	    then () = assert(all(for v in long_answer
	     	       		  	 do Lvd.lookup(v).>=
				  	 od),
				"trouble at x = " + to_string(x.number))
	     	     in ()
	         od
       in ()
   od

set trial_sizes(RealForm G) = [[int]]:
    for x in KGB(G)
    do let lambdas = FPP_lambdas(x), theta =x.involution
       then A = 1+theta
       in for lambda in lambdas
     	  do let b = (A*lambda).numer
	     then long_answer = local_FPP_extrema (x,b)
	     in #long_answer
	  od {list of ints for x}
    od
