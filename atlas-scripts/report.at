{note: big_unitary_hash.xl_sizes(G) must be set (for the lookup xl_pair_number->(x,lambda))
 if it isn't, do big_unitary_hash.set_xl_sizes(G,[])  (not recommended for big groups)}

set_type reportDatum =(int xl_pair_number,
int kgb_number,
ratvec lambda,
int file_number,
int x_lambda_total_time,
string nice_x_lambda_total_time,
int tested_pos_hash_size,
int sum_tested_pos_times,
int tested_neg_hash_size,
int sum_tested_neg_times,
int sum_tested_inter_counts,
int tested_inter_hash_size,
int sum_tested_inter_times,
int sum_tested_pos_to_ht_hash_size,
int sum_tested_pos_to_ht_time_sum,
int sum_tested_neg_to_ht_hashes_size,
int sum_tested_neg_to_ht_times_sum,
int OT_hash_size,
int sum_OT_counts,
int sum_OT_times,
int hash_bottom_layerCounter_use_count,
int hash_one_levelCounter_use_count,
int hash_real_dumbCounter_use_count,
int hash_dumbCounter_use_count,
int hash2Counter_use_count,
int hash_steveCounter_use_count,
int unitaryTime,
int unitary_test_counter_use_count,
int charTime,
int char_counter_use_count,
int up_mu_time,
int DTcount,
int DBTcount,
int def_thruples_time,
int hash_def_false_count,
int test_no_unitary_time,
int test_no_Dirac_time,
int none_count,
rat mu_time_mult,
rat shift_frac,
rat min_ht_mult)

set =(reportDatum a,reportDatum b)=bool:a.xl_pair_number=b.xl_pair_number
set emptyReportDatum=reportDatum:
(
-1,{int xl_pair_number}
-1,{int kgb_number}
ratvec:[], {lambda}
-1,{int file_number}
-1,{int x_lambda_total_time}
"", {string nice_x_lambda_total_time}
-1,{int tested_pos_hash_size}
-1,{int sum_tested_pos_times}
-1,{int tested_neg_hash_size}
-1,{int sum_tested_neg_times}
-1,{int sum_tested_inter_counts}
-1,{int tested_inter_hash_size}
-1,{int sum_tested_inter_times}
-1,{int sum_tested_pos_to_ht_hash_size}
-1,{int sum_tested_pos_to_ht_time_sum}
-1,{int sum_tested_neg_to_ht_hashes_size}
-1,{int sum_tested_neg_to_ht_times_sum}
-1,{int OT_hash_size}
-1,{int sum_OT_counts}
-1,{int sum_OT_times}
-1,{int hash_bottom_layerCounter_use_count}
-1,{int hash_one_levelCounter_use_count}
-1,{int hash_real_dumbCounter_use_count}
-1,{int hash_dumbCounter_use_count}
-1,{int hash2Counter_use_count}
-1,{int hash_steveCounter_use_count}
-1,{int unitaryTime}
-1,{int unitary_test_counter_use_count}
-1,{int charTime}
-1,{int char_counter_use_count}
-1,{int up_mu_time}
-1,{int DTcount}
-1,{int DBTcount}
-1,{int def_thruples_time}
-1,{int hash_def_false_count}
-1,{int test_no_unitary_time}
-1,{int test_no_Dirac_time}
-1,{int none_count}
-1/1, {rat mu_time_mult}
-1/1, {rat shift_frac}
-1/1 {rat min_ht_mult}
)
set_type reportArray = [reportDatum]

{size: the number of (x,lambda) pairs}
{make an empty report}
set make_report(int size)=reportArray:for i:size do emptyReportDatum od
set make_report(RealForm G)=reportArray:make_report(number_xl_pairs(G))

{make a report from scratch from [reportDatum]}
set make_report(int size,[reportDatum] list)=
  let report=make_report(size) in
  for datum in list do report[datum.xl_pair_number]:=datum od;
  report

{add single reportDatum to reportArray}
set add_to_report(reportArray rA,reportDatum rd)=reportArray:
rA[rd.xl_pair_number]:=rd;rA

{add [reportDatum] to reportArray}
set add_to_report(reportArray rA,[reportDatum] data)=reportArray:
for rd in data do add_to_report(rA,rd) od;rA

set seconds_in_day = 86400
set seconds_in_hour = 3600
set seconds_in_minute = 60

{convert seconds to days:hours:minutes:seconds}
set convert_seconds(int time)=(int,int,int,int):
    let days = time\seconds_in_day then
    time = time%seconds_in_day then
    hours=time\seconds_in_hour then
    time =time%seconds_in_hour then
    minutes=time\seconds_in_minute then
    seconds=time%seconds_in_minute in (days,hours,minutes,seconds)

set convert_dayhourminutesecond(int days,int hours,int minutes,int seconds)=int:
days*seconds_in_day + hours*seconds_in_hour + minutes*seconds_in_minute + seconds

set time_string(int days,int hours,int minutes,int seconds)=string:
to_string(days) + ":" + to_string(hours) + ":" + to_string(minutes) + ":" + to_string(seconds)

set nice_time(int time_in_seconds)=string:
    let (days,hours,minutes,seconds)=convert_seconds(time_in_seconds) in
    to_string(days) + ":" + to_string(hours) + ":" + to_string(minutes) + ":" + to_string(seconds)

set nice_time(reportDatum d)=string:nice_time(x_lambda_total_time(d))

{make a report datum (xl_pair_number, file_number, x_lambda_total_time, ... min_ht_mult)
 the first 3 entries are taken from the arguments, and the 4th is nice_time(x_lambda_total_time)
 all the rest come from big_unitary_hash
note: big_unitary_hash.xl_sizes(G) must be set (for the lookup xl_pair_number->(x,lambda))
 if it isn't, do big_unitary_hash.set_xl_sizes(G,[])  (not recommended for big groups)}
 
set report_datum(RealForm G,int xl_pair_number,int file_number,int x_lambda_total_time)=reportDatum:
let (x,lambda)=xl_pair(G,xl_pair_number) in 
(
xl_pair_number,
number(x),
lambda,
file_number,
x_lambda_total_time,
nice_time(x_lambda_total_time),
tested_pos_hash.size(),
sum(tested_pos_times),
tested_neg_hash.size(),
sum(tested_neg_times),
sum(tested_inter_counts),
tested_inter_hash.size(),
sum(tested_inter_times),
sum(for hash in tested_pos_to_ht_hashes do hash.size() od),
sum(for list in tested_pos_to_ht_times do sum(list) od),
sum(for hash in tested_neg_to_ht_hashes do hash.size() od),
sum(for list in tested_neg_to_ht_times do sum(list) od),
OT_hash.size(),
sum(OT_counts),
sum(OT_times),
hash_bottom_layerCounter.use_count(),
hash_one_levelCounter.use_count(),
hash_real_dumbCounter.use_count(),
hash_dumbCounter.use_count(),
hash2Counter.use_count(),
hash_steveCounter.use_count(),
unitaryTime,
unitary_test_counter.use_count(),
charTime,
char_counter.use_count(),
up_mu_time,
DTcount,
DBTcount,
def_thruples_time,
hash_def_false_count,
test_no_unitary_time,
test_no_Dirac_time,
none_count,
mu_time_mult,
shift_frac,
min_ht_mult)



