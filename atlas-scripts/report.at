<sorted_pairs.at

{note: big_unitary_hash.xl_sizes(G) must be set (for the lookup xl_pair_number->(x,lambda))
 if it isn't, do big_unitary_hash.set_xl_sizes(G,[])  (not recommended for big groups)}

set_type reportDatum =(int xl_pair_number,
int kgb_number,
ratvec lambda,
int file_number,
int x_lambda_total_time,
string nice_x_lambda_total_time,
int tested_pos_hash_size,
int sum_tested_pos_times,
int tested_neg_hash_size,
int sum_tested_neg_times,
int sum_tested_inter_counts,
int tested_inter_hash_size,
int sum_tested_inter_times,
int sum_tested_pos_to_ht_hash_size,
int sum_tested_pos_to_ht_time_sum,
int sum_tested_neg_to_ht_hashes_size,
int sum_tested_neg_to_ht_times_sum,
int OT_hash_size,
int sum_OT_counts,
int sum_OT_times,
int hash_bottom_layerCounter_use_count,
int hash_one_levelCounter_use_count,
int hash_real_dumbCounter_use_count,
int hash_dumbCounter_use_count,
int hash2Counter_use_count,
int hash_steveCounter_use_count,
int unitaryTime,
int unitary_test_counter_use_count,
int charTime,
int char_counter_use_count,
int up_mu_time,
int DTcount,
int DBTcount,
int def_thruples_time,
int hash_def_false_count,
int test_no_unitary_time,
int test_no_Dirac_time,
int none_count,
rat mu_time_mult,
rat shift_frac,
rat min_ht_mult)

set =(reportDatum a,reportDatum b)=bool:a.xl_pair_number=b.xl_pair_number
set emptyReportDatum=reportDatum:
(
-1,{int xl_pair_number}
-1,{int kgb_number}
ratvec:[], {lambda}
-1,{int file_number}
-1,{int x_lambda_total_time}
"", {string nice_x_lambda_total_time}
-1,{int tested_pos_hash_size}
-1,{int sum_tested_pos_times}
-1,{int tested_neg_hash_size}
-1,{int sum_tested_neg_times}
-1,{int sum_tested_inter_counts}
-1,{int tested_inter_hash_size}
-1,{int sum_tested_inter_times}
-1,{int sum_tested_pos_to_ht_hash_size}
-1,{int sum_tested_pos_to_ht_time_sum}
-1,{int sum_tested_neg_to_ht_hashes_size}
-1,{int sum_tested_neg_to_ht_times_sum}
-1,{int OT_hash_size}
-1,{int sum_OT_counts}
-1,{int sum_OT_times}
-1,{int hash_bottom_layerCounter_use_count}
-1,{int hash_one_levelCounter_use_count}
-1,{int hash_real_dumbCounter_use_count}
-1,{int hash_dumbCounter_use_count}
-1,{int hash2Counter_use_count}
-1,{int hash_steveCounter_use_count}
-1,{int unitaryTime}
-1,{int unitary_test_counter_use_count}
-1,{int charTime}
-1,{int char_counter_use_count}
-1,{int up_mu_time}
-1,{int DTcount}
-1,{int DBTcount}
-1,{int def_thruples_time}
-1,{int hash_def_false_count}
-1,{int test_no_unitary_time}
-1,{int test_no_Dirac_time}
-1,{int none_count}
-1/1, {rat mu_time_mult}
-1/1, {rat shift_frac}
-1/1 {rat min_ht_mult}
)

{sortedPairs: [(xl_number, time)] of top N pairs, sorted descending by time
 N=summary_size is fixed small number, for example 100}

set summary_size=100

set_type reportArray = [reportDatum]

{size: the number of (x,lambda) pairs;
 summary_size: number of (x,lambda) pairs, with largest times, saved for reporting}
{make an empty report}
set make_report(int size)=reportArray:(for i:size do emptyReportDatum od)
set make_report(RealForm G)=reportArray:make_report(number_xl_pairs(G))

{make a report from scratch from [reportDatum]}
set make_report(int size,[reportDatum] list)=
  let data=make_report(size) in
  for datum in list do data[datum.xl_pair_number]:=datum od;
  data

{add single reportDatum to reportArray:
 this is slow, so should not be used for many updates}
set update_report(reportArray rA,reportDatum rd)=void:
rA[rd.xl_pair_number]:=rd

{assuming reportDatum rA is defined, do this:
 however don't do it here, do it after you've defined rA}
{set add(reportDatum rd)=void:rA[rd.xl_pair_number]:=rd}

set seconds_in_day = 86400
set seconds_in_hour = 3600
set seconds_in_minute = 60

{convert seconds to days:hours:minutes:seconds}
set convert_seconds(int time)=(int,int,int,int):
    let days = time\seconds_in_day then
    time = time%seconds_in_day then
    hours=time\seconds_in_hour then
    time =time%seconds_in_hour then
    minutes=time\seconds_in_minute then
    seconds=time%seconds_in_minute in (days,hours,minutes,seconds)

set convert_dayhourminutesecond(int days,int hours,int minutes,int seconds)=int:
days*seconds_in_day + hours*seconds_in_hour + minutes*seconds_in_minute + seconds

set time_string(int days,int hours,int minutes,int seconds)=string:
to_string(days) + ":" + to_string(hours) + ":" + to_string(minutes) + ":" + to_string(seconds)

set nice_time(int time_in_seconds)=string:
    let (days,hours,minutes,seconds)=convert_seconds(time_in_seconds) in
    to_string(days) + ":" + to_string(hours) + ":" + to_string(minutes) + ":" + to_string(seconds)

set nice_time(reportDatum d)=string:nice_time(x_lambda_total_time(d))

{make a report datum (xl_pair_number, file_number, x_lambda_total_time, ... min_ht_mult)
 the first 3 entries are taken from the arguments, and the 4th is nice_time(x_lambda_total_time)
 all the rest come from big_unitary_hash
note: big_unitary_hash.xl_sizes(G) must be set (for the lookup xl_pair_number->(x,lambda))
 if it isn't, do big_unitary_hash.set_xl_sizes(G,[])  (not recommended for big groups)}
 
set report_datum(RealForm G,int xl_pair_number,int file_number,int x_lambda_total_time)=reportDatum:
let (x,lambda)=xl_pair(G,xl_pair_number) in 
(
xl_pair_number,
number(x),
lambda,
file_number,
x_lambda_total_time,
nice_time(x_lambda_total_time),
tested_pos_hash.size(),
sum(tested_pos_times),
tested_neg_hash.size(),
sum(tested_neg_times),
sum(tested_inter_counts),
tested_inter_hash.size(),
sum(tested_inter_times),
sum(for hash in tested_pos_to_ht_hashes do hash.size() od),
sum(for list in tested_pos_to_ht_times do sum(list) od),
sum(for hash in tested_neg_to_ht_hashes do hash.size() od),
sum(for list in tested_neg_to_ht_times do sum(list) od),
OT_hash.size(),
sum(OT_counts),
sum(OT_times),
hash_bottom_layerCounter.use_count(),
hash_one_levelCounter.use_count(),
hash_real_dumbCounter.use_count(),
hash_dumbCounter.use_count(),
hash2Counter.use_count(),
hash_steveCounter.use_count(),
unitaryTime,
unitary_test_counter.use_count(),
charTime,
char_counter.use_count(),
up_mu_time,
DTcount,
DBTcount,
def_thruples_time,
hash_def_false_count,
test_no_unitary_time,
test_no_Dirac_time,
none_count,
mu_time_mult,
shift_frac,
min_ht_mult)

{default output for each reportDatum: index, xl_pair_number, kgb_number, lambda, nice_time, x_lambda_total_time
 for more complex information use show_detail
 for result sorted by time use show_sorted}
{default output for reportDatum[j] from start to stop}
set show(reportArray rA,  int start, int stop)=void:
tabulate( ["i","pair","x", "lambda", "time", "time in seconds"]#
for i:stop-start from start  do
 let rd=rA[i] in
 [to_string(i),to_string(rd.xl_pair_number),to_string(rd.kgb_number),to_string(rd.lambda), rd.nice_time,to_string(rd.x_lambda_total_time)]
od)

{short: just the top 20 entries}
set show_short(reportArray rA)=void:show(rA,0,20)
{all rows, usually way to long to be useful}
set show(reportArray rA)=void:show(rA,0,#rA)

{sort [(int,int)] descending by the second entry}
set geq((int a, int b),(int c, int d))=b>=d
set sort_pairs=sort(geq@((int,int),(int,int)))
set test=[(20,3),(10,4),(9,20),(0,11),(24,5)]

set my_sort([int] list)=sort_pairs(for a@i in list do (i,a) od)

{sort reportArray decreasing by time; the result is list=[reportDatum],
 Note: in a reportArray rA[j].xl_pair_number=j
 this is not true in list, so this shouldn't be considered a reportArray}

set time_geq(reportDatum a,reportDatum b)=bool:a.x_lambda_total_time>=b.x_lambda_total_time
set sort_report_data=sort(time_geq@(reportDatum,reportDatum))
set sort(reportArray rA)=[reportDatum]:sort_report_data(rA)
set sorted_xl_pair_numbers(reportArray rA)=[int]:for rd in sort(rA) do rd.xl_pair_number od

{for sorted output, pass the list sorted of [reportData] sorted by time;
 to create this do set sorted=sorted_xl_pair_number(rA)}
set show_sorted(reportArray rA, [int] sorted,  int start, int stop)=void:
tabulate( ["i","pair","x", "lambda", "time", "time in seconds"]#
for i:stop-start from start  do
 let rd=rA[sorted[i]] in
 [to_string(i),to_string(rd.xl_pair_number),to_string(rd.kgb_number),to_string(rd.lambda), rd.nice_time,to_string(rd.x_lambda_total_time)]
od)





{list of fields, for use in reporting}
set reportDatumFields=(
[xl_pair_number@reportDatum,
kgb_number@reportDatum,
file_number@reportDatum,
x_lambda_total_time@reportDatum,
tested_pos_hash_size@reportDatum,
sum_tested_pos_times@reportDatum,
tested_neg_hash_size@reportDatum,
sum_tested_neg_times@reportDatum,
sum_tested_inter_counts@reportDatum,
tested_inter_hash_size@reportDatum,
sum_tested_inter_times@reportDatum,
sum_tested_pos_to_ht_hash_size@reportDatum,
sum_tested_pos_to_ht_time_sum@reportDatum,
sum_tested_neg_to_ht_hashes_size@reportDatum,
sum_tested_neg_to_ht_times_sum@reportDatum,
OT_hash_size@reportDatum,
sum_OT_counts@reportDatum,
sum_OT_times@reportDatum,
hash_bottom_layerCounter_use_count@reportDatum,
hash_one_levelCounter_use_count@reportDatum,
hash_real_dumbCounter_use_count@reportDatum,
hash_dumbCounter_use_count@reportDatum,
hash2Counter_use_count@reportDatum,
hash_steveCounter_use_count@reportDatum,
unitaryTime@reportDatum,
unitary_test_counter_use_count@reportDatum,
charTime@reportDatum,
char_counter_use_count@reportDatum,
up_mu_time@reportDatum,
DTcount@reportDatum,
DBTcount@reportDatum,
def_thruples_time@reportDatum,
hash_def_false_count@reportDatum,
test_no_unitary_time@reportDatum,
test_no_Dirac_time@reportDatum,
none_count@reportDatum],
[mu_time_mult@reportDatum,
shift_frac@reportDatum,
min_ht_mult@reportDatum],
[lambda@reportDatum],  {ratvec}
[nice_x_lambda_total_time@reportDatum] {string}
)

set reportDatumFieldNames=
(["xl_pair_number",
"kgb_number",
"file_number",
"x_lambda_total_time",
"tested_pos_hash_size",
"sum_tested_pos_times",
"tested_neg_hash_size",
"sum_tested_neg_times",
"sum_tested_inter_counts",
"tested_inter_hash_size",
"sum_tested_inter_times",
"sum_tested_pos_to_ht_hash_size",
"sum_tested_pos_to_ht_time_sum",
"sum_tested_neg_to_ht_hashes_size",
"sum_tested_neg_to_ht_times_sum",
"OT_hash_size",
"sum_OT_counts",
"sum_OT_times",
"hash_bottom_layerCounter_use_count",
"hash_one_levelCounter_use_count",
"hash_real_dumbCounter_use_count",
"hash_dumbCounter_use_count",
"hash2Counter_use_count",
"hash_steveCounter_use_count",
"unitaryTime",
"unitary_test_counter_use_count",
"charTime",
"char_counter_use_count",
"up_mu_time",
"DTcount",
"DBTcount",
"def_thruples_time",
"hash_def_false_count",
"test_no_unitary_time",
"test_no_Dirac_time",
"none_count"],
["mu_time_mult",
"shift_frac",
"min_ht_mult"],
["lambda"],
["time"]
)

set show(reportDatum d)=void:
let (int_fields,rat_fields, ratvec_fields, string_fields)=reportDatumFields then
(int_names,rat_names,ratvec_names,string_names)=reportDatumFieldNames in
prints("xl_pair_number: ", xl_pair_number(d));
prints("x: ", kgb_number(d));
prints("lambda: ", lambda(d));
for f@i in string_fields do prints(string_names[i], ": ", f(d)) od;
for f@i in int_fields do prints(int_names[i], ": ", f(d)) od;
for f@i in rat_fields do prints(rat_names[i], ": ", f(d)) od

set number_jobs(reportArray rA)=max(for rd in rA do rd.file_number od)+1
set total_time(reportArray rA)=int:sum(for rd in rA do rd.x_lambda_total_time od)
set max_time(reportArray rA)=int:max(for rd in rA do rd.x_lambda_total_time od)
set average_time_per_pair(reportArray rA)=total_time(rA)\#rA
set summary(reportArray rA,int number_jobs)=void:
let t=total_time(rA) then
m=max_time(rA) 
in prints("#pairs: ", #rA,new_line,"total time: ", t, " seconds; ", nice_time(t),
new_line,"avg time/job: ", t\number_jobs, " seconds; ", nice_time(t\number_jobs),new_line,
"longest pair time: ", m, " ", nice_time(m))
set summary(reportArray rA)=void:summary(rA,number_jobs(rA))


