<facetious.at


{main function is is_deformed(F,F0,vert_list,p). Decides whether unitarity of a facet F0 is transmitted to
a facet F with F0 in its boundary}

{given facets F,F0 with F0 in the boundary of F and a parameter p with infl char in F,
compute a new parameter p0 with same x and lambda as p but with infl char equal to the barycenter of F0--David
tells me that p0=(x,lambda,nu0) where nu0=bary(F0), but I don't understand why this works...}

set deform(FacetVertsIndex F, FacetVertsIndex F0, [ratvec] vert_list, Param p) = Param:
let x=x(p), lambda=lambda(p), nu0=facet_bary(vert_list,F0) in
parameter(x,lambda,nu0)

set deform(FacetVertsIndex F, FacetVertsIndex F0, [ratvec] vert_list, ParamPol P) = ParamPol:
null_module(P.real_form) + for (c,p) in %P do c*deform(F,F0,vert_list,p) od

{given facets F,F0 with F0 in the boundary of F and a parameter p with infl char in F, decide
whether unitarity is transmitted from F0 to F. Note: only `discrete' part of p (i.e. x(p),lambda(p)) matters}

set is_deformed(FacetVertsIndex F, FacetVertsIndex F0, [ratvec] vert_list, Param p) = bool:
deform(F,F0,vert_list,character_formula(p)) = character_formula(deform(F,F0,vert_list,p))
