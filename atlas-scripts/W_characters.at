<elliptic.at { for |elliptics_for_Levi@(RootDatum,[int])| }
<tabulate.at { for |tabulate| }
<cyclotomic.at {for |product_of_cyclotomic|}
<Weylgroup.at { for |is_relatively_elliptic| }
<conjugate.at

{ The purpose of this file is working with Weyl group characters.

  A large initial part is dedicated to deciding conjugacy in the Weyl group, and
  finding an explicit witness of conjugacy from a class representative.
}

{ Preliminary: some transformations of presentation of a Levi system

  A Levi system, not necessarily standard, can be defined either by the roots
  forming a simple system for it (represented by their indices, usually within
  |posroots(rd)|, though the code handles negative indices of negative roots
  too), or by a predicate selecting the indices of positive roots in the system.

  The function |Levi_info| deduces the predicate from the simple system, or from
  a Weyl group element $w$ (selecting coroots vanishing on $w$-fixed weights),
  and |Levi_datum| builds the root datum for the subsystem, given the predicate.
}

{ select posroots indices for (non standard) Levi, given by its simple system }
set Levi_info (RootDatum rd, [int] Levi) = (RootDatum,(int->bool)):
   let orth=kernel(rd.rank ^ for i in Levi do coroot(rd,i) od) in
   (rd,(int j) bool: =coroot(rd,j)*orth)

{ the |select| predicate for the above functions to use for a given |w| }
set Levi_info (WeylElt w) = (RootDatum,(int->bool)):
   let orth=eigen_lattice(matrix(w),1), rd=w.root_datum in
   (rd,(int i) bool: =coroot(rd,i)*orth)

set Levi_datum (RootDatum rd, (int->bool) select {from posroot indices}) =
      RootDatum:
   root_datum(simple_system_from_positive
      (columns_with(select,rd.posroots),columns_with(select,rd.poscoroots)) )

set Levi_datum ((RootDatum,[int])pair) = RootDatum: pair.Levi_info.Levi_datum
set Levi_datum (WeylElt w) = RootDatum: w.Levi_info.Levi_datum

{ A first task is to list the $W$ conjugacy classes.

  Every Weyl group element $w$ has an associated Levi subgroup (not necessarily
  standard), whose roots are those whose reflections fix all weights fixed by
  $w$ (its eigenspace for $1$ in the reflection representation). Then $w$ is in
  the Weyl group of this Levi subgroup, and by construction is elliptic there.

  The Weyl subgroup of any Levi subgroup is conjugate in $W$ to that of a
  standard Levi subgroup, so for the purpose of finding the conjugacy classes of
  $W$ it suffices to consider only standard Levi subgroups. A first task is to
  classify standard Levi subgroups (determined by subsets of the simple roots)
  by conjugacy. It turns out that Levi subsystems (whether or not standard) are
  conjugate in $W$ if and only if their sum-of-posroots ($2\rho$) are conjugate.
  We also compute explicit conjugating elements between standard Levi systems.

  So compute $2\rho$ values for standard Levi subsystems, use |dominant| to
  decide $W$-conjugacy, and classify all subsets of the set of simple roots
  (from |power_set| in basic.at) by conjugacy of their associated $2\rho$s.
}

{two_rho@(RootDatum,(int->bool)) and standard_Levi_conjugacy_representatives@RootDatum
 have been moved to conjugate.at}

{ The following functions, up to |classify_standard_Levis|, aim to classify
  standard Levis under conjugation _and_ find conjugators for each one from the
  first of their class. The Levi orbit table produced are then used in some
  functions defined later, but the ultimate goal of efficiently classifying Weyl
  group elements up to conjugation, with witnesses, is not achieved here, and
  these functions are not used in the |WeylClassTable| object (near the end).

  For each standard Levi system we determine the dominant orbit representative
  |rho2_dom| of $2\rho$, a Weyl group element |w0| that witnesses this, and the
  image under it of the Levi system (a non-standard Levi system $L$ whose value
  $2\rho_L$ equals |rho2_dom|, since the Levi system remains positive throughout
  the transformation). A conjugate standard Levi system will not necessarily map
  to the same non-standard Levi system $L$, whence we generate the orbit of the
  latter under the stabiliser subgroup of the |rho2_dom|, with witnesses.

  The orbit generation here is taylored to the specific situation that we know
  that all elements of the acting subgroup fix the $2\rho$ value for $L$, so the
  only way they can map all simple generators of $L$ to roots of $L$ is by
  permuting them among each other. Also since the $2\rho_L$ value is dominant,
  for the full system, and so a fortiori dominant for the positive roots in any
  system in the orbit of $L$, the acting stabiliser subgroup will map positive
  roots of $L$ to positive roots. We can then work with positive root indices
  only, act on lists of such indices, and sort the result to test for equality.
}

set_type orbit_data = [int,WeylElt] { posroot set as binary number, conjugator }
set right_act([int] Levi,WeylElt w) = int: { encode |w^-1*Levi| in binary }
   let rd=w.root_datum in
   for i in Levi do 2^coroot_index(rd,coroot(rd,i)*w) od.sum
set unbinary (int bin) = [int]: let i=0 in
   while bin.>
   do let (q,r)=bin\%2 in if =r then [] else [i] fi
   next i+:=1; bin:=q
   od.##

{ list of (L,w) where 2rho(L)=dominant(2rho(Levi)) and L=w*Levi  }
set rho_stabiliser_orbit (RootDatum rd, [int] standard_Levi) = orbit_data:
   let (w0,rho2_dom) = from_dominant(rd,two_rho(rd,is_member(standard_Levi)))
   then rho_stabiliser = Levi_datum(rd,(int i)bool: =coroot(rd,i)*rho2_dom)
   then root_perm = { list of posroot permutations for stabiliser generators }
      let two=2/1 then pow2(int n)=int:floor(two^n) { negatives to 0 } in
      for beta in rho_stabiliser.simple_roots
      do for alpha in rd.posroots
         do root_index(rd,reflect(rd,beta,alpha)).pow2
	 od
      od
   then act(int i,[int] roots) = int:
      let map = root_perm[i] in for j in roots do map[j] od.sum
   , orbit = [(right_act(standard_Levi,w0),/w0)] { starting point }
   , current=0
   in while current<#orbit
      do let (L_bin,w)=orbit[current] next current+:=1 then L=L_bin.unbinary in
         for k:rho_stabiliser.semisimple_rank
         do let new_L_bin=act(k,L) in
            if none(#orbit,(int i): let (x,)=orbit[i] in x=new_L_bin)
            then orbit #:=
              (new_L_bin,root_reflection(rd,rho_stabiliser.simple_roots[k])*w)
            fi
         od
      od; orbit

set_type Std_Levi_orbit = (vec rho2, [int] Levi_repr, [[int],WeylElt] others)
set_type Std_Levi_table = [Std_Levi_orbit]

{ group together conjugate standard Levis, with witness conjugating from first }
set classify_standard_Levis (RootDatum rd) =  Std_Levi_table:
   let classify_group ([[int]] list) = Std_Levi_table:
      let orbs = [orbit_data]:[], result = [Std_Levi_orbit]:[] in
      for Levi in list
      do let (w0,rho2_dom)=from_dominant(rd,two_rho(rd,is_member(Levi)))
         then i = first(#result,(int i)bool: let (v,,)=result[i] in v=rho2_dom)
      in if i.< { is this a previously unseen |rho2_dom| value }
         then orbs #:= rho_stabiliser_orbit(rd,Levi)
         ;  result #:= (rho2_dom,Levi,[])
         else { |rho2_dom| value already seen, and tabulated in |orbs[i]| }
            let orbit=orbs[i], cur=result[i], L = right_act(Levi,w0)
            then (,w) =
	       let pos = first(#orbit,(int i)bool: let (rts,)=orbit[i] in L=rts)
	       in assert(pos.>=,"conjugate with dominant rho not found in orbit")
	       ;  orbit[pos]
            in result[i] := (cur.rho2,cur.Levi_repr,cur.others#(Levi,w0*w))
					  { Levi <-w0-- L <-w-- Levi_rep }
	 fi
     od; result
  ,  r = rd.semisimple_rank
  in for k:r+1 do classify_group(choices_from(#r,k)) od.##


{standard_Levi_conjugacy_representatives (RootDatum rd) = [ [int] ]: moved to conjugate.at}

{ A second task is to enumerate elliptic conjugacy classes for each standard
  Levi subsystem. The function |elliptics_for_standard_Levi@(RootDatum,[int])|
  defined in elliptic.at accomplishes this, partly by explicit listing.
}

{. list of conjugacy class representatives of rd .}
set conjugacy_class_reps (RootDatum rd) = [WeylElt]:
##for subset in standard_Levi_conjugacy_representatives(rd)
  do elliptics_for_standard_Levi(rd,subset)
  od

set conjugacy_classes = conjugacy_class_reps@RootDatum
set elliptic_conjugacy_classes(RootDatum rd) = [WeylElt]:
##for w in conjugacy_classes(rd) do if is_elliptic(w) then [w] else [] fi od

{
  From $w$ we find the associated non-standard Levi subsystem, the minimal one
  in whose Weyl group $w$ occurs. Our next task, surprisingly difficult, is to
  find a standard Levi system conjugate to it, and a conjugating element of $W$.

  For the case where we are given a non standard list of simple generators (not
  all positive, and in arbitrary order) for the full root system, there is an
  easy algorithm to find $w$ (called |chamber| below) that maps the set of
  simple roots of |rd| to those generators, and the permutation of them (map
  from positions to simple root index being mapped to it) so obtained. It goes:
  as long as the system contains a negative root, select one (recording its
  position) and apply the corresponding (non simple) root reflection to all
  roots; ultimately all roots become positive, and as a set we have obtained the
  simple roots. The list of their indices is our permutation; as letters of $w$,
  from right to left, take for each reflection applied the simple generator that
  ended up at the recorded position. This is done in |chamber_max_system| below.

  Our approach is then to extend the Levi system one root at a time to a maximal
  system, and then apply this algorithm. To find a root by which we can extend
  the Levi system to a larger one, we first locate using |minimal_extenders| a
  set of candidates (root indices, not necessarily positive ones), whose roots
  are minimally positive for some some linear form vanishing on |Levi|. From
  these, |extend_Levi| will then select a minimal one for |Levi| root addition.
}

{ list of posroot indices, minimal>0 for some linear form vanishing on |Levi| }
set minimal_extenders (RootDatum rd,[int] Levi) = [int]:
   let orth = { columns: generators in $X_*$ of annihilator subspace of |Levi| }
      kernel(rd.rank ^ for i in Levi do root(rd,i) od)
in case a_column_with((vec alpha)bool: !=alpha*orth {@*(vec,mat)}, rd.posroots)
   | no_vec: [] { |Levi| already spans subspace containing all roots }
   | solution(alpha):
      { find a column |f| of |orth| (coweight) witnessing |alpha*orth| nonzero }
      let f = requisition(a_column_with((vec cowt)bool: !=cowt*alpha, orth))
      , min=0 { minimal positive coroot evaluation on |wt| so far; 0 if none }
      , result = [int]: [] { list of root indices with minimal positive eval }
      in for beta@i in rd.posroots
         do let eval=f*beta then abs_eval=eval.abs in
            if =eval then () { ignore roots on which |f| vanishes }
            elif min=0 or abs_eval<min { cases where |result| is replaced }
            then min:=abs_eval; result:=[if eval<0 then -1-i else i fi]
            elif abs_eval=min { ex aequo case, now |result| is extended }
            then result #:= if eval<0 then -1-i else i fi
            fi
         od
      ; result
   esac

set extend_Levi (RootDatum rd,[int] Levi) = [int]:
   let mins = minimal_extenders(rd,Levi) in
   for m in mins
   do let alpha=root(rd,m) in
      if none(#Levi,(int i): is_root(rd,alpha-root(rd,Levi[i])) )
      then return Levi#m { found a valid |m|, add it to Levi and return }
      fi
   od; assert(#mins=0); { if there were any candidates, one should work }
   [] { return indication that |Levi| was already maximal }

{ return maximal Levi containing |Levi|, ordered in the way they were found }
set maximise (RootDatum rd,[int] !Levi) = [int]:
   let ssr = rd.semisimple_rank, max=Levi in
   while #max<ssr do max:=extend_Levi(rd,max); assert(!=#max) od; max

{ find chamber defined by a maximal system, and its simple root permutation }
set chamber_max_system (RootDatum rd, [int] sys) = (WeylElt,[int]):
   let roots= rd.rank # for index in sys do root(rd,index) od
   , ssr=rd.semisimple_rank
   then positions = { a list of positions in |roots| (rather than a Weyl word) }
      assert(#sys=ssr) { first check that |sys| has enough roots };
      while let i=first(ssr,(int i)bool: not is_posroot(rd,roots[i])) in i.>=
      do roots := left_reflect(rd,roots[i],roots); i { record position }
     ~od
   then perm= for alpha in roots do root_index(rd,alpha) od
   in assert(all(ssr,is_member(perm)),"Not a complete system");
   (W_elt(rd,for pos in positions do perm[pos] od),perm)

set from_standard_Levi ((RootDatum,[int]) (rd,Levi):arg) =
      (WeylElt, [int]): { chamber, unsorted standard Levi }
   let (chamber,perm) = chamber_max_system(rd,maximise(arg)) in
   (chamber,perm[:#Levi] { select start of simple indices list })

set standard_Levi_lookup (RootDatum rd,Std_Levi_table table) =
      ([int]->WeylElt, [int]):
([int] unsorted_standard_Levi) (WeylElt, [int]):
   let rho2 = dominant(rd,two_rho(rd,is_member(unsorted_standard_Levi)))
   , standard_Levi=unsorted_standard_Levi.sort
   then (,Levi_repr,others) =
      table[first(#table,(int i)bool: table[i].rho2=rho2)]
in if standard_Levi=Levi_repr
   then (id_W(rd),standard_Levi)
   else let (,conj) =
      others[first(#others,(int i)bool: let (L,)=others[i] in L=standard_Levi)]
      in (conj , Levi_repr)
   fi


{ value of $2\rho$ for not necessarily standard Levi, from Levi info }
set subsystem_2rho (RootDatum rd, (int->bool) select {from posroot indices}) =
      vec: { two_rho(Levi_datum(rd,select)), but we can compute it directly: }
   sum(rd.rank #
       ##for alpha@i in rd.posroots do if select(i) then [alpha] else [] fi od)

set Levi_of (WeylElt w) = [int]: { posroot indices for simples of |w| system }
   let (rd,):Levi_info=w.Levi_info
   then Ld=Levi_datum(Levi_info), rho2_L = subsystem_2rho(Levi_info)
in for alpha_v in columns_with(is_simple_for(rho2_L),Ld.poscoroots)
   do coroot_index(rd,alpha_v) od

{ partial work: find some standard Levi conjugate to that of |w| }
set conjugate_from_standard_Levi (WeylElt w) =
       (WeylElt,[int],WeylElt): { conjugator from, standard Levi, conjugate w }
   let (chamber,unsorted_standard_Levi)
      = from_standard_Levi(w.root_datum,Levi_of(w))
   in (chamber,unsorted_standard_Levi.sort,/chamber*w*chamber)

set Levi_lookup (RootDatum rd,Std_Levi_table table) = ([int]->WeylElt,[int]):
   let lookup = standard_Levi_lookup(rd,table) in
([int] Levi) (WeylElt, [int]):
   let (chamber,unsorted_standard_Levi) = from_standard_Levi(rd,Levi)
   then (conj,Levi_repr) = lookup(unsorted_standard_Levi)
   in (chamber*conj,Levi_repr)

{ like |conjugate_from_standard_Levi|, using standard Levi chosen from |table| }
set conjugate_from_classified_standard_Levi (RootDatum rd,Std_Levi_table table) =
      (WeylElt->WeylElt,[int],WeylElt):
   let lookup = Levi_lookup(rd,table) in
(WeylElt w) (WeylElt,[int],WeylElt): { conjugator from, Levi_repr, w_repr) }
   let (conj,Levi_repr) = lookup(Levi_of(w)) in (conj,Levi_repr,/conj*w*conj)

{----------------------------------------------------------------------------}
{ compute minimal length representatives of an elliptic conjugacy class }

{ This algorithm (due to He) gives *some* minimal length representatives of |w|
  but it gives *all* such if |w| is elliptic. In that case one can conjugate |w|
  to a minimal length representative doing one simple, weakly length decreasing
  conjugation at a time (also: given one minimal length representative, all
  other minimal length representatives can be obtained by conjugating without
  increasing the length)

  NOTE: in A2 the two simple generators are conjugate, but (obviously) not by
        either one of them, so any conjugation path increases length in this
	case the algorithm does give a minimal length representative but not
	all of them; since these simple generators are not elliptic, this does
	not contradict what is said here.
  So:
  given a list of Weyl group elements, all conjugate and of the same length,
  compute all their conjugates by simple generators that are not longer, keeping
  a list |shorter| of all that are strictly shorter while extending the list by
  any new elements of the same length. If |shorter| is non empty, replace the
  list by |shorter| and repeat, else if any new elements were added repeat, and
  if neither is the case terminate returning the list.

  The function below implements this, while also returning conjugations witnesses
}
set apply_He (WeylElt w) = [WeylElt,WeylElt]:
(  let !rd = w.root_datum
   then stack = [[],[(w,id_W(rd))]], lw=length(w)
   , absent([WeylElt,WeylElt] pairs, WeylElt w) = bool:
        for (x,) in pairs do if x=w then return false fi od; true
in while { loop with embedded |do| instances near end }
      let shorter=false
      then new_level = [WeylElt,WeylElt]:
	 for s in W_gens(rd)
	 do for (w,witness) in stack~[0]
	    do let sws=s*w*s in
	       case length(sws)-lw
	       then { less }
		  stack:=[[],[(sws,s*witness)]]; shorter:=true; break 1
	       in { equal }
		 if absent(stack~[1]##stack~[0],sws) then [(sws,s*witness)]
		 else []
		 fi
	       else { greater } []
	       esac
	    od.##
	 od.##
      in
      if shorter then do lw:=lw-2 { and |stack| was reset }
      else >#new_level
      do let filtered = new_level[:1] in { we still need to remove duplicates }
         for (w,):p in new_level[1:]
	 do if absent(filtered,w) then filtered#:=p fi
	 od
      ;  stack#:=filtered
      fi
   od { while }
;  ##stack
)

{ these functions give *some* minimal length representatives of |w|
  but are guaranteed to give all of them if |w| is elliptic
}
set minimal_representatives_witnesses (WeylElt w) = ([WeylElt],[WeylElt]):
   let list = apply_He(w) in
   (for (w,) in list do w od, for (,witness) in list do witness od)

set minimal_representative_witness (WeylElt w) = (WeylElt,WeylElt):
   apply_He(w)[0]

set minimal_representatives (WeylElt w) = [WeylElt]:
   for (rep,) in apply_He(w) do rep od
set minimal_representative (WeylElt w) = WeylElt:
   let (rep,) = apply_He(w)[0] in rep


{------------------------------------------------------------------- }

{ Conjugacy test, using reduction to elliptic

  We use the fact that x,y are conjugate iff L_x=x.Levi_datum is
  conjugate to L_y=y.Levi_datum, and, after conjugating L_y to L_x,
  x_ell is L_x conjugate to y_ell, where x_ell, y_ell are the elliptic
  classes in L_x, L_y corresponding to x,y
  Note that there is a choice of how to conjugate L_y to L_x, however the
  result is independent of that choice, essentially because the only elliptic
  class in type A is the Coxeter element, and the elliptic classes in a
  simple group are fixed by all outer automorphisms.
}

set elliptic_reduction (WeylElt w) = WeylElt: convert_to(Levi_datum(w),w)

{ conjugacy test, using reduction to elliptic, and provided elliptic case test }

set is_conjugate_to ( (WeylElt->(WeylElt->bool)) elliptic_conjugacy_test
		    , WeylElt x) = (WeylElt->bool):
   let rd=x.root_datum, ord_x = order(x), chi=char_poly(x)
   , L_x = RootDatum: x.Levi_datum
   then sL_x= RootDatum: standard_Levi(rd,L_x)
   , w_x = WeylElt: standard_Levi_witness(rd,L_x) { an element of W(rd) }
   , x_ell= convert_to(L_x,x) { convert |x| to relatively elliptic for |L_x| }
   then elliptic_test=elliptic_conjugacy_test(x_ell)
   in { end of preparations for |x|, now define the function of |y| }
   (WeylElt y) bool:
   { start with easy necessary conditions on |y|: }
   y.root_datum=rd and order(y)=ord_x and char_poly(y)=chi and
(  let L_y = y.Levi_datum
in standard_Levi(rd,L_y)=sL_x and
(  let y_ell = let conjugator = /w_x * standard_Levi_witness(rd,L_y)
	       in convert_to(L_x,conjugator * y * /conjugator)
   in elliptic_test(y_ell)
))

{conjugacy test, using reduction to elliptic, and an arbitrary test for elliptic}
set is_conjugate(WeylElt x,WeylElt y,((WeylElt,WeylElt)->bool) elliptic_conjugacy_test) = bool:
let rd=x.root_datum in
if
 order(x)!=order(y) {easy and necessary} or
 y.root_datum!=rd { easy and necessary } or
 char_poly(x)!=char_poly(y) { easy and necessary }
 then false
else
 (let L_x = x.Levi_datum, L_y = y.Levi_datum in
  if standard_Levi(rd,L_x)!=standard_Levi(rd,L_y) then false else
   let w_x=standard_Levi_witness(rd,L_x),
    w_y=standard_Levi_witness(rd,L_y) then
    x_ell=W_elt(L_x,x.matrix) then   {x_ell \in W(L_x)}
    y_ell_0=inverse(w_x)*w_y*y*inverse(w_y)*w_x {  y_ell_0\in W(L_x)} then
    (y_ell,)=from_dominant(L_x,y_ell_0*L_x.two_rho) in   {y_ell\in W(L_x)}
     {      let ()=prints("x=", x, "y=", y, new_line,"y_ell_0: ", y_ell_0, "y_ell: ", y_ell, " x_ell: ", x_ell)  in}
    elliptic_conjugacy_test(x_ell,y_ell)
  fi
 )
fi

{------------------------------------------------------------------- }

set present([WeylElt] list,WeylElt w) = bool: any(#list,(int i)bool: list[i]=w)

{ Given elliptic |x|, produce test for conjugacy of elliptic |y| to it }
set is_conjugate_to_elliptic_He (WeylElt x) = (WeylElt->bool):
   assert(is_relatively_elliptic(x),"Class is not (relatively) elliptic");
  let reps = minimal_representatives(x) in
  (WeylElt y)bool: present(reps,minimal_representative(y))

{ He's algorithm to definitively tell if two elliptic elements are conjugate
  actually only the first needs to be (relatively) elliptic using
  minimal_representative test for elliptic elements of a Levi
}
set is_conjugate_elliptic_He (WeylElt x,WeylElt y) = bool:
   assert(is_relatively_elliptic(x),"Class is not (relatively) elliptic");
   is_relatively_elliptic(y) and
   present(minimal_representatives(x),minimal_representative(y))

{ use |is_conjugate_elliptic_He| to create a general is_conjugate funtion}
set is_conjugate_to_He (WeylElt x) = (WeylElt->bool):
   is_conjugate_to(is_conjugate_to_elliptic_He@(WeylElt),x)



{----------------------------------------------------------------------------}

{conjugacy test using reduction to elliptic, and characteristic polynomial
on each simple factor}

{ The above allows us to conjugate any $w$ a Weyl group element to one that is
  elliptic (up to a torus part) for a standard Levi system. However, the problem
  of deciding conjugacy of elliptic elements in a given standard Levi subgroup
  and producing a witness does not seem essentially simpler than the same
  problem in the full Weyl group.

  Therefore, we use for the moment a method for deciding conjugacy that does not
  produce any witness, and is not entirely complete. It basically compares
  characteristic polynomials, but adds a special test to discriminate between
  two classes of elliptic elements for F4 that share a characteristic polynomial
  (an outer automorphism switches them). This method does not work when the
  implied Levi subsystem is composite and contains a factor F4.

  This version is not correct: it requires a further test on each simple
  factor. Alternatively, this test is correct for a simple factor,
  and could be used (on each simple factor) to write an alternative function
  to elliptic_conjugate_test above, and plugged in to
  set is_conjugate@(WeylElt,WeylElt,(WeylElt,WeylElt)->bool)
}

{conjugacy test for elliptic elements of a simple group:
 equality of characteristic polynomial, plus additional
 check in F4
}
set is_conjugate_elliptic_simple_char_poly (WeylElt x,WeylElt y) = bool:
assert(x.root_datum=y.root_datum,"RootDatum mismatch");
assert(x.root_datum.derived.is_simple,"Derived group is not simple");
assert(x.is_relatively_elliptic and y.is_relatively_elliptic,"x and/or y is not (relatively) elliptic");
if order(x)!=order(y) then false {easy test}
elif char_poly(x)!=char_poly(y) then false  {easy test}
else
 let (code,)=factors(x.root_datum.Lie_type)[0] in
 if code = "F" and x.order=6 and x.length=10 then
 {extra test in this one case}
 let is_negated(WeylElt w) = (int->bool):
   let M = w.matrix+1 in (int i)bool: =M*root(w.root_datum,i) { root in -1 eigenspace }
 then
 alpha = root(x.root_datum,first(24,is_negated(x))),
 beta =  root(x.root_datum,first(24,is_negated(y))) in
 dominant(x.root_datum,alpha)=dominant(x.root_datum,beta) { whether these have same length }
 else true
 fi
fi

{conjugacy test for elliptic elements: previous test on each simple factor}
set is_conjugate_elliptic_char_poly(WeylElt x,WeylElt y)=bool:
assert(x.root_datum=y.root_datum,"RootData don't match");
assert(x.is_relatively_elliptic and y.is_relatively_elliptic,"x and/or y is not (relatively) elliptic");
let x_factors=factor_strong(x),y_factors=factor_strong(y) in
{x_factors is a list of WeylElts, each for the simple group
 simple_factors(rd).derived
}
all(for i:#x_factors do is_conjugate_elliptic_simple_char_poly(x_factors[i],y_factors[i]) od)

{general conjugacy test: reduce to elliptic and then use is_conjugate_elliptic_char_poly}
set is_conjugate_char_poly(WeylElt x,WeylElt y)=bool:
is_conjugate(x,y,is_conjugate_elliptic_char_poly@(WeylElt,WeylElt))

{----------------------------------------------------------------------------}
{decide which is_conjugate to use as the default:}

set is_conjugate_to = (WeylElt->(WeylElt->bool)): is_conjugate_to_He@WeylElt

{ uncurried version, less efficient for frequent use }
set is_conjugate (WeylElt x,WeylElt y) = bool: is_conjugate_to(x)(y)

{----------------------------------------------------------------------------}

{ brute force enumerate the conjugacy class of |w|, with conjugacy witnesses }
set conjugators_and_conjugacy_class (WeylElt !w0) = ([WeylElt],[WeylElt]):
   let rd=w0.root_datum, class = [w0]
   then conjugators= [id_W(rd)], current=0, ssr=semisimple_rank(rd)
   , absent (WeylElt x) = none(for y in class do @: y=x od)
in while current<#class
   do let c = conjugators[current], w=class[current] in current+:=1
   { assert(w=c*w0*/c); }
   ;  for s:ssr
      do let sws=s#w#s in
         if absent(sws) then class #:= sws; conjugators #:= s#c fi
      od
   od; (conjugators,class)

set full_conjugacy_class (WeylElt w) = [WeylElt]:let (,class)=conjugators_and_conjugacy_class(w) in class

{most users will guess:}
set conjugacy_class(WeylElt w)=[WeylElt]:full_conjugacy_class(w)

{should test each element of the conjugacy class as it is generated for a faster function}
set is_conjugate_direct (WeylElt x,WeylElt y) = bool:
   present(full_conjugacy_class(x),y)

{this works for all x, but is slow}
set all_minimal_representatives_direct(WeylElt x)=[WeylElt]:
let class=x.full_conjugacy_class then
rv=[class[0]], min_length=length(class[0]) in
for w in class do
 if length(w)<min_length then rv:=[w]; min_length:=length(w)
 elif length(w)=min_length then rv#:=w
 fi
od;
rv

set minimal_representative_direct(WeylElt x)=WeylElt:all_minimal_representatives_direct(x)[0]

{ some simple functions that exploit the conjugacy test }
set conjugacy_class_rep (WeylElt w, [WeylElt] classes) = WeylElt:
   for rep in classes do if is_conjugate(w,rep) then return rep fi od;
   error("missing class")

set conjugacy_class_rep (WeylElt w) = WeylElt:
  conjugacy_class_rep(w,conjugacy_class_reps(w.root_datum))

set full_centraliser (WeylElt w) = [WeylElt]:
   ##for x in W(w.root_datum) do if x*w=w*x then [x] else [] fi od

set conjugator (WeylElt x, WeylElt w) = WeylElt: { find v such that x=v*w*/v }
   assert(is_conjugate(x,w),"Weyl group elements are not conjugate");
   let (conjugators,class)=conjugators_and_conjugacy_class(w) in
   conjugators[last(#class,(int i)bool: class[i]=x)]

{ $W$-orbit of (non standard) Levi subsystem, represented by simple systems }
set Levi_orbit (RootDatum rd, [int] Levi { posroot indices } ) = [[int]]:
   let root_perm =
     for i:rd.semisimple_rank
     do for alpha in rd.posroots do root_index(rd,W_gen(rd,i)*alpha) od
     od { this is negative on the main diagonal, but those entries are unused }
   then act(int i,[int] roots) = (bool,[int]):
      if is_member(roots)(i)
      then (false,roots) { Levi's own simple reflection normalises system }
      else (true, let map = root_perm[i] in for j in roots do map[j] od.sort)
      fi
   , orbit = [Levi], current=0
in while current<#orbit
   do let L=orbit[current] in current+:=1
   ;  for s:rd.semisimple_rank
      do let (moved,M)=act(s,L) in
         if moved and none(#orbit,(int i):orbit[i]=M) then orbit #:= M fi
      od
   od; orbit


{ Computing just the size of this Levi orbit can be done a bit more efficiently
  than generating it, though it requires a some preliminary computation. The
  idea is to use the stabiliser subgroup $M$ in $W$ of $\rho_L$; though it does
  not contain $N_L$, the intersection $M\cap N_L$ has known index in $N_L$,
  namely the size of $W_L$ (every coset by $W_L$ meets the intersection
  uniquely). So we generate the (hopefully small) orbit under $M$ of images of
  the Levi system, then by dividing the size of $M$ by that of the orbit find
  the size of the intersection, which multiplied by that of $W_L$ gives the size
  of $N_L$, and dividing the size of $W$ by that gives our Levi orbit size.

  The orbit generation here is taylored to the specific situation, whence we do
  it using local code (the |begin|-|end| block below) rather than writing or
  using a more general orbit generation. The special circumstance is that we
  know that all elements of the acting subgroup fix $\rho_L$, so the only way
  they can map all simple generators of $L$ to roots of $L$ is by permuting them
  among each other. We can then ignore the distinction between a root and its
  opposite (working only with positive root indices) and not worry about
  choosing the simple generators for the positive part of each Levi system
  (which is why we had to single out the "do nothing" case above): the Levi
  system implied by a set of indices is the one additively generated by those
  roots and their opposites, and this results in the same system only if the
  indices are the same up to permutation. So again we can use an equality test
  for orbit membership, provided we sort our lists of indices to be increasing.
}

set Levi_normalizer_index ((RootDatum,(int->bool))(rd,select):Levi_info) = int:
   let rho2_L = subsystem_2rho(Levi_info)
   then rho_L_stabiliser = Levi_datum(rd,(int i)bool: =coroot(rd,i)*rho2_L)
   then stab_orbit = [[int]]:
      begin
      let root_perm =
         let ab (int i) = int: if i.< then -1-i else i fi { to positive index }
         in for beta in rho_L_stabiliser.simple_roots
            do for alpha in rd.posroots
               do root_index(rd,reflect(rd,beta,alpha)).ab
               od
            od
      , Levi = { indices in |rd| for simple system of Levi }
         list(rd.nr_of_posroots,(int i): select(i) and coroot(rd,i)*rho2_L=2)
      then act(int i,[int] roots) = [int] :
         let map = root_perm[i] in for j in roots do map[j] od.sort
      , orbit = [Levi]
      , current=0
      in while current<#orbit
         do let L=orbit[current] in current+:=1
         ;  for k:#root_perm
            do let M=act(k,L) in
               if none(#orbit,(int i):orbit[i]=M) then orbit #:= M fi
            od
         od
      ; { stab_orbit = } orbit
      end
   in rho_L_stabiliser.order_W \ #stab_orbit { index of $W_L$ in $N_L$ }

set Levi_orbit_size ((RootDatum,(int->bool))(rd,):Levi_info) = int:
  rd.order_W \ (Levi_info.Levi_normalizer_index * Levi_info.Levi_datum.order_W)

{ Now onward to the task of getting the size of the conjugacy class of |w| in
  for |Levi_datum(w)|, where ignoring the central torus it is elliptic. This
  root datum can have multiple simple factors, and we can decompose |w| as
  commuting product of elements of the Weyl groups of the simple factors, and
  its conjugacy class will be the Cartesian product of the conjugacy classes of
  the factors (the same goes for the centraliser). The following function
  determines this decomposition, where each |WeylElt| in the result is
  associated to a different root datum, which is simple up to a central torus.
}

set elliptic_simple_decomposition (WeylElt w) = [WeylElt,(string,int)]:
   let rd_L = Levi_datum(w)
   then (type,map)=Cartan_matrix_type(rd_L.Cartan_matrix)
   then codes = type.simple_factors, w_L=W_elt(rd_L,w.matrix) { convert }
   , offset=0 { rank within |type| already seen in loop below }
   , !r = rd_L.rank { full rank, needed when gathering roots/coroots }
in for (,rank):code in codes { traverse the simple factors }
   do let sub_map = map[offset:offset+rank] { index mapping for this factor }
      then factor_word =
	 ## for s in w_L.word
	    do let i=find(sub_map,s) in if i.>= then [i] else [] fi
	    od
      , simple_datum = root_datum
	( r # for i in sub_map do rd_L.simple_roots[i]   od
	, r # for i in sub_map do rd_L.simple_coroots[i] od
	)
   in ( W_elt(simple_datum,factor_word), code )
   next offset +:= rank
   od

set centralizer_order = (WeylElt->int):
  let elliptic_simple_order(WeylElt w,(string type, int rank)) = int:
     { here |w| is elliptic, with simple associated datum of given type,rank }
     case char_index(type,"ABCD")
     in rank+1 { type $A_n$ has unique elliptic, an $n+1$ cycle permutation }
     , order_of_centralizer_elliptic_BCD(w)
     , order_of_centralizer_elliptic_BCD(w)
     , order_of_centralizer_elliptic_BCD(w)
     else exceptional_elliptic_centr_order(type,rank,char_poly(w))
     esac
  in { centralizer_order = }
  (WeylElt w) int:
    for (w_i,type_rank) in elliptic_simple_decomposition(w)
    do elliptic_simple_order(w_i,type_rank)
    od . product * Levi_normalizer_index(w.Levi_info)

{. number of elements of a conjugacy class .}
set size_of_conjugacy_class (WeylElt w) = int:
  w.root_datum.order_W \ w.centralizer_order
set sizes_of_conjugacy_classes (RootDatum rd) = [int]:
  for w in conjugacy_class_reps(rd) do w.size_of_conjugacy_class od

{ test: sum of sizes of conjugacy class = |W| }
set test_size_of_conjugacy_classes (RootDatum rd,[WeylElt] c) = (int,int):
  (order_W(rd),sum(for w in c do  size_of_conjugacy_class(w)  od))

set test_size_of_conjugacy_classes (RootDatum rd) = bool:
  =test_size_of_conjugacy_classes(rd,conjugacy_classes(rd))

{. print order, length, Levi.}
set print_conjugacy_classes ([WeylElt] C) = void:
  let data=["order","length","Levi"] { column headers }
  # for w in C
    do [ w.order.to_string
       , w.length.to_string
       , w.Levi_datum.Lie_type.semisimple.str
       ]
    od
  in tabulate(data,"rrl",2," ")

{. print order, length, Levi.}
set print_conjugacy_classes_med ([WeylElt] C) = void:
  let data=["order","length","Levi","Cyclotomic"] { column headers }
  # for w in C
    do [ w.order.to_string
       , w.length.to_string
       , w.Levi_datum.Lie_type.semisimple.str
       , product_of_cyclotomic(rat_poly:("q",char_poly(w),())).to_string
       ]
    od
  in tabulate(data,"rrrl",2," ")

set print_conjugacy_classes_long ([WeylElt] C) = void:
  let data=["order","length","Levi","size","word"] { column headers }
  # for w in C
    do [ w.order.to_string
       , w.length.to_string
       , w.Levi_datum.Lie_type.semisimple.str
       , w.size_of_conjugacy_class.to_string
       , w.word.to_string
       ]
    od
  in tabulate(data,"rrlll",2," ")

set print_conjugacy_classes (RootDatum rd) = void:
  print_conjugacy_classes(conjugacy_class_reps(rd))
{set print_conjugacy_classes_med (RootDatum rd) = void:
  rd.conjugacy_class_reps.(sort_by(order@WeylElt)).print_conjugacy_classes_med}
set print_conjugacy_classes_long (RootDatum rd) = void:
  rd.conjugacy_class_reps.(sort_by(order@WeylElt)).print_conjugacy_classes_long

{. print elliptic classes only .}
set print_elliptic_conjugacy_classes (RootDatum rd) = void:
  print_conjugacy_classes(sort_by(order@WeylElt)(elliptic(rd)))
set print_elliptic_conjugacy_classes_long (RootDatum rd) = void:
  rd.elliptic.(sort_by(order@WeylElt)).print_conjugacy_classes_long

{ A final production is a type for storing data relevant to W-characters,
  notably information about conjugacy classes. This will be a (mildly) "stateful
  value" in that some data, notably for the symmetric powers of the reflection
  representation, are computed and stored on demand only. In order to achieve
  this access is often via function components that can access the hidden state.
}
set_type
[ WeylClassTable =
  ( (->) print_classes
  , int n_classes
  , (->[WeylElt]) class_representatives
  , (WeylElt->int) class_of
  , (->[int]) class_sizes
  , (int,int->int) class_power
  , [int] trivial
  , [int] sign
  , [int] reflection
  , ([int]->int) dimension
  , ([int]->int) norm2
  , ([int],[int]->int) inner
  , ([int],[int]->[int]) direct_sum
  , ([int],int->[int]) Cartesian_power
  , ([int],[int]->[int]) tensor
  , ([int],int->[int]) tensor_power
  , (int->[int]) sym_power_refl
  )
]

{ From the above functions, the generic table constructor will only use
  |conjugacy_class_reps|, |size_of_conjugacy_class|, and |is_conjugate| to get
  its information (and choices) concerning conjugacy. Since these general
  purpose functions may be much slower than type specific ones, our main
  constructor takes additional arguments in their place, and then the generic
  constructor will provide mentioned functions in thir place.
}
set W_class_table ( RootDatum rd
		  , [WeylElt] !reps
		  , (WeylElt->int) class_size
		  , (WeylElt->int) class_nr_of
		  , (int,int->int) power_map
		  ) = WeylClassTable:
   let !sizes = [int]: for w in reps do class_size(w) od
   , !ncc = #reps { number of conjugacy classes }
   , !nW = rd.order_W
   , !rank = rd.rank, !npr=rd.nr_of_posroots
   , !e = class_nr_of(id_W(rd))
   then inner ([int] x, [int] y) = int:
     assert(#x=ncc and #y=ncc,"Wrong sizes");
     let s = for size@i in sizes do size*x[i]*y[i] od.sum then (q,r)=s \% nW in
     if =r then q else error("Non integer inner product ",s/nW) fi
   , sum ([int] x, [int] y) = [int]: for xi@i in x do xi+y[i] od
   , product ([int] x, [int] y) = [int]: for xi@i in x do xi*y[i] od
   , refl_characteristic = [vec]: for w in reps do char_poly(w) od
   , power_table = [vec]:
        for i:ncc do for k:reps[i].order do power_map(i,k) od od
   , reflection_sympowers = [[int]]: { characters of Sym^k(reflection_rep) }
        for :ncc do 1 od { initial symmetric 0-power, only one computed here }
	# for :npr do [int]:[] od { reserve empty table rows }
   , k=0 { last symmetric power computed}
in
( {print_classes} @:
   let data = ["nr","count","order","length","Levi type","representative"] #
     for w@i in reps
     do [ i.to_string
        , sizes[i].to_string
        , w.order.to_string
        , w.length.to_string
        , w.Levi_datum.Lie_type.semisimple.str
	, reps[i].to_string
        ]
     od
   in tabulate(data,"rrrrll",2," ")

, {n_classes} ncc
, {class_representatives} @: reps
, {class_of} class_nr_of
, {class_sizes} @: sizes
, {class_power} (int i,int n) int: let v=power_table[i] in v[n % #v]
, {trivial}     for :ncc do 1 od
, {sign}        for w in reps do minus_1^w.length od
, {reflection}  for w in reps do w.matrix.trace od
, {dimension}   ([int] val) int: val[e]
, {norm2} ([int] x) int: inner(x,x)
, {inner} inner
, {direct_sum}
  (([int],[int])(x,y):pair) [int]:
  assert(#x=ncc and #y=ncc,"Wrong sizes"); sum(pair)
, {Cartesian_power}
  ([int] x,int n) [int]: assert(#x=ncc,"Wrong size"); for v in x do n*v od
, {tensor}
  (([int],[int])(x,y):pair) [int]:
  assert(#x=ncc and #y=ncc,"Wrong sizes");  product(pair)
, {tensor_power}
   ([int] x, int n) [int]: assert(#x=ncc,"Wrong size"); for xi in x do xi^n od
, {sym_power_refl}
  (int n) [int]: assert(n<=npr,"No symmetric powers recorded beyond "+npr);
     while k<n { extend until |reflection_sympowers[n]| has been set }
     do k+:=1; reflection_sympowers[k] :=
        for j:ncc
	do let s=0, !chi=refl_characteristic[j] in
	   for i:min(rank,k) from 1
	   do s-:=chi~[i]*reflection_sympowers[k-i][j]
	   od
	;  s
	od
     od
  ;  reflection_sympowers[n]
)

set W_class_table ( RootDatum rd
		  , [WeylElt] reps
		  , (WeylElt->int) class_size
		  , (WeylElt->(WeylElt->bool)) is_conjugate_to
		  ) = WeylClassTable:
   let memberships = [(WeylElt->bool)]: for r in reps do is_conjugate_to(r) od
   then class_of(WeylElt w) = int: first(#reps,(int i)bool: memberships[i](w))
in W_class_table( rd, reps, class_size, class_of
		, (int i, int k) int: let pred=is_conjugate_to(reps[i]^k) in
		    for r@j in reps do if pred(r) then return j fi od; minus_1
		)

set W_class_table (RootDatum rd) = WeylClassTable:
   W_class_table( rd, conjugacy_class_reps(rd)
		, size_of_conjugacy_class@WeylElt, is_conjugate_to@WeylElt
		)

{. root datum of WeylClassTable .}
set root_datum (WeylClassTable tab) = RootDatum:
    tab.class_representatives()[0].root_datum { at least one class exists }

{ compare characters when paired up with a |WeylClassTable| }
set =((WeylClassTable ct,[int] char_values)
     ,(WeylClassTable ct2,[int] char_values2)) = bool:
     ct.root_datum=ct2.root_datum and char_values=char_values2

{. index i for which w is conjugate to classes[i], in given WeylClassTable .}
set conjugacy_class_number (WeylClassTable ct,WeylElt w) = int: ct.class_of(w)

{. value of character at w\in W .}
set character_value (WeylClassTable ct, WeylElt w,[int] char) = int:
  char[ct.class_of(w)]

{ Adams's operation (not Jeff's): evaluate character at class of $w^n$ }
set Adams (WeylClassTable tab) = ([int]char, int n) [int]:
   for i:tab.n_classes do char[tab.class_power(i,n)] od

{ symmetric power of a character }
set sym_power (WeylClassTable tab) = ([int]char, int n) [int]:
{ with $h_k$ symmetric, $p_k$ Adams, use $kh_k=\sum_{i=0}{k-1} h_ip_{k-i}$ }
   let { define two local tables of characters, to be expanded in loop }
     p = { "power sum polynomials", results of Adams operations } [[int]]: [ ]
         { since there is no $p_0$, the $k$-the Adams operation gives the entry
           |p[k-1|, but never mind since we will always reverse-index |p| }
   , h = { "complete homogeneous polynomials", symmetric powers } [tab.trivial]
   , Adams = tab.Adams { shorthand }
in for k:n from 1
   do p #:= Adams(char,k) { expand }
   ;  let sum=p~[0]
   in for i:k-1 from 1 do sum:=tab.direct_sum(sum,tab.tensor(h[i],p~[i])) od
   ; h #:= for s in sum do s\k od { expand table by |sum\k| }
   od; h[n] { last symmetric power is the one we want }

{ exterior power of a character }
set ext_power (WeylClassTable tab) = ([int]char, int n) [int]:
{ with $e_k$ ext, $p_k$, use $ke_k=\sum_{i=0}{k-1}(-1)^{k-i-1} e_ip_{k-i}$ }
   let { define two local tables of characters, to be expanded in loop }
    sp = { "signed power sum polynomials", $(-1)^{i-1}p_i$ } [[int]]: [ ]
         { since there is no $p_0$, the $k$-the Adams operation gives the entry
           |p[k-1|, but never mind since we will always reverse-index |p| }
   , e = { "elementary symmetric polynomials", exterior powers } [tab.trivial]
   , Adams = tab.Adams { shorthand }
in for k:n from 1
   do sp #:= tab.Cartesian_power(Adams(char,k),minus_1^(k-1)) { expand }
   ;  let sum=sp~[0]
   in for i:k-1 from 1 do sum:=tab.direct_sum(sum,tab.tensor(e[i],sp~[i])) od
   ; e #:= for s in sum do s\k od { expand table by |sum\k| }
   od; e[n] { last symmetric power is the one we want }

{reduce list of Weyl group elements do distinct conjugacy classes}
set filter_by_class ([WeylElt] list)=
   let classes=[WeylElt]:[]
in for elt in list
   do if none(for w in classes do is_conjugate(w,elt) od) then classes#:=elt fi
   od; classes
