<combinatorics.at { for |even_places@[int] }
<parabolics.at { for |Levi@Parabolic|, |parabolic_by_cwt@(ratvec,KGBElt)| }
<parameters.at { for |parameter@(KGBElt,KGBElt,ratvec)| }
<W_classes.at {for |standard_Levi_conjugacy_representatives@RootDatum| }
<K.at { for |K_0@RealForm| }
<induction.at { for |embed_KGB@(KGBElt,RealForm)| }
<center.at { for |lie_compact_radical)@InnerClass| }
<induction.at { for |is_coh_ind_from_finite_dimensional| }
<all_finite_order.at
<subgroups.at { for |pseudo_Levi_subgroups| }
<twisted_conjugacy.at

set nilpotent_verbose=false

{ ComplexNilpotent: (RootDatum rd,vec H)
  where [H,X,Y] is a Lie triple, H\in X_*, and orbit=G.X
  H must satisfy <alpha,H>=0,1,2 for all simple roots,
  in particular is_dominant(H,rd) should hold
}
set_type
[ ComplexNilpotent = (RootDatum root_datum, void ., vec H{_of_triple})
, RealNilpotent    = (vec H, KGBElt x, void .)
]

set complex_nilpotent (RootDatum rd, vec H) = ComplexNilpotent:
   (rd,(),dominant(H,rd))
{ an alias for people tired of typing "complex_" }
set nilpotent = complex_nilpotent@(RootDatum,vec)

{complex orbit; list of orders of conjugacy classes;
for each conjugacy class a list of pairs (L,[ratvec])
L is a pseudo-Levi, and each ratvec is a semisimple element,
each pair (L,ratvec) gives one conjugacy class in A(O)
}
set_type ComplexNilpotentComponentDatum =
             (ComplexNilpotent orbit,[int] orders,[(RootDatum,[ratvec])] pairs)

{ Two complex nilpotent orbits are equal if the root data are, and moreover
   the H's are conjugate by the Weyl group. Since we assume dominant coweights
   all the time, equality test is just equality of both relevant components }
set = (ComplexNilpotent O1,ComplexNilpotent O2) = bool:
   let rd=O1.root_datum in rd=O2.root_datum and O1.H=O2.H

{ dimension of the orbit of nilpotents described by a |ComplexNilpotent| }
set dim_nilpotent (ComplexNilpotent(rd,,H)) = int:
   sum(for alpha in posroots(rd) do case H*alpha in 0, 1 else 2 esac od)

{ a synonym }
set dim = dim_nilpotent@ComplexNilpotent

{ saturate an orbit from an equal rank subgroup to G }
set saturate(ComplexNilpotent O,RootDatum rd) = ComplexNilpotent:
  complex_nilpotent(rd,O.H) { replace the |root_datum| and re-|dominant| for it }

{ saturate an orbit from an injectively mapped group |S=O.root_datum|, the
  embedding X_*(T_S-> X_*(T_{rd}) being right-multiplication by |inc|; in other
  words |inc| itself is the projection matrix X^*(T_{rd}->X^*(T_S) }
set saturate(ComplexNilpotent O,mat inc,RootDatum rd) = ComplexNilpotent:
   complex_nilpotent(rd,O.H*inc)

{ As will be mentioned for many "simple" Springer table constructions, it is
  noteworthy that |diagram(O)| and |stratified_diagram(O)| allow |O.H| to have
  a nonzero "radical component", which is ignored since only the evaluation on
  roots is used. This property allows the construction of Springer tables for
  general root data to pass an orbit to its "simple" sub-rootdata without
  explicitly projecting away the part of |O.H| that is irrelevant for it.
}
set diagram(ComplexNilpotent O) = [int]:
   assert(is_dominant(O.H,O.root_datum)); O.H * simple_roots(O.root_datum)

{ with |map| a permutation of the simple generators from |Cartan_matrix_type| }
set stratified_diagram(ComplexNilpotent O,[int] map) = [int]:
   let rd = O.root_datum in assert(is_dominant(O.H,rd));
   O.H*(rd.rank # for pos in map do root(rd,pos) od)

set stratified_diagram(ComplexNilpotent O) = [int]:
   let (,pi) = Cartan_matrix_type(O.root_datum) in stratified_diagram(O,pi)

{ diagram_normalized returns [[int]] to allow for multiple simple factors }
{ however, there is no sorting of simple factors of |Lie_type(O.root_datum) }
set diagram_normalized(ComplexNilpotent O) = [[int]]:
   let H = vec: {coweight} dominant(O.H,O.root_datum)
   , factors = simple_factors(O.root_datum) { each factor Bourbaki ordered }
in for f in factors do H*f.simple_roots od

{ construct complex orbit (rd,(),H) from (rd,labelled Dynkin diagram) }
set complex_nilpotent_from_diagram(RootDatum rd,[int] diagram) =
      ComplexNilpotent:
(  complex_nilpotent
   (rd
   ,ratvec_as_vec
     (sum(rd.rank,for a@i in diagram do a*rd.fundamental_coweights[i] od))
   )
)

set sort_by((ComplexNilpotent->int) f) =
   ([ComplexNilpotent] v) [ComplexNilpotent]:
      for index in inv_standardisation(for x in v do f(x) od) do v[index] od

set sort_by_dimension = ([ComplexNilpotent]->[ComplexNilpotent]):
   sort_by(dim_nilpotent@ComplexNilpotent)

set find ([ComplexNilpotent] list,ComplexNilpotent O) = int:
   first(#list,(int i)bool:list[i].root_datum=O.root_datum and
                           list[i].H=O.H)

set find ([RealNilpotent] list,RealNilpotent O) = int:
   first(#list,(int i)bool:list[i].x=O.x and
                           list[i].H=O.H)

set remove_duplicates([ComplexNilpotent] orbits)=[ComplexNilpotent]:
let rv=[ComplexNilpotent]:[] in
for orbit in orbits do
 if find(rv,orbit)=-1 then rv#:=orbit fi
od;rv

set dim_eigenspace (RootDatum rd, ratvec H, int k) = int:
   if =k { level 0 is special: include torus and negative roots at this level }
   then rank(rd) + 2*count(for alpha in posroots(rd) do =alpha*H od)
   else count(for alpha in posroots(rd) do H*alpha=k od)
   fi

set max_eigenvalue (RootDatum rd, vec H) = int:
   max(for alpha in posroots(rd) do H*alpha od)

set eigenspace_dimensions (RootDatum rd, vec H) = [int]:
   assert(is_dominant(dual(rd),H),"H is not dominant");
   for k:max_eigenvalue(rd,H)+1 do dim_eigenspace(rd,H,k) od

set even_eigenspaces (RootDatum rd, vec H) = [int]:
   even_places(eigenspace_dimensions(rd,H))
set odd_eigenspaces(RootDatum rd, vec H)=[int]:
   odd_places(eigenspace_dimensions(rd,H))

set support (Param p) = [int]:
   support(x(p)) { using |support@KGBElt| from parabolics.at }

set support_dual (Param p) = [int]:
   support_dual(x(p))

set blocku(RealForm G) = [Param]:
 ##for p in block_of(trivial(G))
   do if for k in support(x(p)) do is_descent(k,p) od.all then [p] else [] fi
   od

{. Choose the H among the candidates which correspond to distinguished
   nilpotent orbits. .}
set distinguished_Hs_definition (RootDatum rd_L) = [vec]:
   let S_weight([int] S) = ratvec: {twice sum of fundamental coweights for S}
      sum(rd_L.rank, for k in S do fundamental_coweight(rd_L,k) od)*2
   then H_candidates = [ratvec]:
       for S in power_set(#rd_L.semisimple_rank) do S_weight(S) od
in for H in H_candidates
    do if dim_eigenspace(rd_L,H,2) =
          dim_eigenspace(rd_L,H,0)-central_torus_rank(rd_L)
       then [ratvec_as_vec(H)]
       else []
       fi
    od.##

{ in order to implement the effect of |distinguished_Hs_definition| more
  efficiently, each of the |H_candidates| can be represented by |v=H/2|, so that
  when applied to a posroot, the integer value gives half the eigenvalue; the
  the dimension difference above then is found by counting the occurrences of a
  value 0 twice (as the opposite root also contributes here), minus the
  occurrences of a value 1; when total is zero, we record |H=v*2| in the result.
}
set distinguished_Hs (RootDatum rd) = [vec]:
   let r=semisimple_rank(rd)
   then cwts = [ratvec]: { all sums of a subset of fundamental coweights }
      let fcws = for i:r do %fundamental_coweight(rd,i) od
      then common {denominator} = lcm(for (,d) in fcws do d od)
      then M = mat: rank(rd) # for (v,d) in fcws do v*(common\d) od
        { same as: |let (M,common)=invert(^rd.root_coradical) in M := M[:r]| }
      in for select in all_0_1_vecs(r) do M*select/common od
   , pr=posroots(rd)
in for v in cwts
   do let count = r { start with dimension of torus mod central torus }
   in
   { get |dim_eigenspace(rd,v,0)-central_torus_rank(rd)-dim_eigenspace(rd,v,1)|,
     computed by adding to torus contribution those from the root spaces }
     for x in v*pr\1 do case x in count+:=2{pos+neg}, count-:=1 else () esac od
   ; if =count then [ratvec_as_vec(v*2)] else [] fi
   od.##

set distinguished_H_diagrams (RootDatum rd, RootDatum rd_L) = [vec]:
   for H in distinguished_Hs(rd_L) do diagram(complex_nilpotent(rd,H)) od

{. As previous function, with H dominant. .}
set distinguished_H_dom (RootDatum rd, RootDatum rd_L) = [vec]:
   for H in distinguished_Hs(rd_L) do dominant(H,rd) od


{. Given a Root Datum rd for a complex group G, list the neutral elements
   (dominant for G) corresponding to the complex nilpotent orbits. .}
set all_H (RootDatum rd) = [vec]:
 ##for S in standard_Levi_conjugacy_representatives(rd)
   do for H in distinguished_Hs(Levi_datum(rd,S)) do dominant(H,rd) od
   od

{. As previous function, except the coweights H are given as sums of fundamental
   weights for the standard (Bala-Carter) Levi M in which the orbit is
   distinguished, rather than as dominant coweights for |rd|. .}
set all_H_nd (RootDatum rd) = [vec]: { nd stands for non-dominant }
 ##for S in standard_Levi_conjugacy_representatives(rd)
   do distinguished_Hs(Levi_datum(rd,S))
   od

{. List all (complex) nilpotent orbits(with H dominant) for a complex group. .}
set nilpotent_orbits (RootDatum rd) = [ComplexNilpotent]:
   for H in all_H_nd(rd) { as |nilpotent| calls |dominant|, omit it here }
   do nilpotent(rd,H) od.sort_by_dimension

{tired of typing so many characters}
set orbits = (RootDatum->[ComplexNilpotent]): nilpotent_orbits@RootDatum

set distinguished_nilpotent_orbits (RootDatum rd) = [ComplexNilpotent]:
   for H in rd.distinguished_Hs do complex_nilpotent(rd,H) od

set distinguished_orbits = (RootDatum->[ComplexNilpotent]): { alias }
   distinguished_nilpotent_orbits@RootDatum

{ return Bala-Carter Levi and distinguished H_L for it, conjugate to |O.H| }
set Bala_Carter_Levi_plus (ComplexNilpotent O) = ([int],vec):
   let rd = O.root_datum in
   for S in standard_Levi_conjugacy_representatives(rd)
   do for H_L in distinguished_Hs(Levi_datum(rd,S))
      do if dominant(H_L,rd)=O.H then return (S,H_L) fi
      od
   od; error("Nilpotent ",O," erroneous: no Bala-Carter Levi subgroup found")

{ Bala-Carter Levi subgroup only }
set Bala_Carter_simples (ComplexNilpotent O) = [int]:
   let (S,) = Bala_Carter_Levi_plus(O) in S

{ Bala-Carter Levi subgroup only }
set Bala_Carter_Levi (ComplexNilpotent O) = RootDatum:
   Levi_datum(O.root_datum,Bala_Carter_simples(O))


{. List all H's for |rd|, grouping them by standard Levi in which they are
   disinguished .}
set all_H_with_L (RootDatum rd) = [[int],[vec]]:
   for S in standard_Levi_conjugacy_representatives(rd)
   do (S,distinguished_Hs(Levi_datum(rd,S)))
   od

{. Given a coweight H corresponding to a complex nilpotent orbit, find the
   Levi M in which the orbit is distinguished. The output is the pair consisting
   of the simple roots for M, and the conjugate of H corresponding to the
   standard Levi M (not dominant for G). The input H0 need not be dominant. .}
set Levi_of_H (vec H0,RootDatum rd)=([int],vec):
   let dom_H0 = dominant(H0,rd)
in for (M,Hs) in all_H_with_L(rd)
   do for H in Hs
      do if dominant(H,rd)=dom_H0 then return (M,H) fi
      od
   od; error("No Levi found")

{ parabolics.at defines type |Parabolic| and |KGPElt| as ([int] S, KGBElt x) }

{ find H which work for given q=q(x,H)=(L,u) }
set find_H (Parabolic P) = [vec,mat]:
begin
   let x=maximal(P)
   then u_p=columns_with(is_noncompact(x),nilrad_roots(P))
   , rho_L = rho(P.Levi)
   , theta_1 = involution(x)-1
in for H in all_H(P.real_form.root_datum)
   do
      if =H*theta_1 and =H*rho_L and >H*u_p { all its entries >0 }
      else []
      then let level_two_roots = columns_with((vec alpha): H*alpha=2, u_p ) in
           [ (H,level_two_roots) ]
      fi
   od.##
end

{ containment order }
set <= ([int] a,[int] b) = bool:
   let test = is_member(b) in all(#a,(int i)bool: test(a[i]) )
set <  ([int] a,[int] b) = bool: sort(a) != sort(b) and a<=b

set principal_block (RealForm G) = Block: block(G,dual_quasisplit_form(G))

{ convert Block to [param] }
set convert (Block B,ratvec gamma) = [Param]:
   for i:#B do let (x,y)=element(B,i) in parameter(x,y,gamma) od

{ just subset of block }
set convert (Block B, [int] S,ratvec gamma) = [Param]:
   for i in S do  let (x,y)=element(B,i) in parameter(x,y,gamma) od

set real_form (Block B) = RealForm: let (G,)=%B in G
set rho (Block B) = ratvec: rho(real_form(B))

{ choose appropriate infinitesimal character for (x,y) }
set choose_gamma (KGBElt x,KGBElt y) = ratvec: choose_g(y,x)

{ choose appropriate infinitesimal character for B }
set choose_gamma (Block B) = ratvec: choose_gamma(element(B,0))

set convert (Block B) =         [Param]: convert(B,choose_gamma(B))
set convert (Block B,[int] S) = [Param]: convert(B,S,choose_gamma(B))

{ convert list of wcells [[int]] to [[Param]] }
set convert_list_W_cells (Block B,ratvec gamma,[[int]] Wcells) = [[Param]]:
    let converted_block=convert(B,gamma) in
    for cell in Wcells do for k in cell do converted_block[cell[k]] od od

{ return list of tau-invariants for B
  tau_invariants(B)[i]=tau-invariant of block element i
}
set tau_invariants (Block B) = [[int]]:
   let gamma=choose_gamma(B) in
   for i:#B do let (x,y)=element(B,i) in tau(parameter(x,y,gamma)) od

set tau_invariants_of_cell (Block B, [int] cell) = [int,[int]]:
   let gamma=choose_gamma(B) in
   for i in cell do let (x,y)=element(B,i) in (i,tau(parameter(x,y,gamma))) od

set tau_invariants_of_cell_raw (Block B, [int] cell) = [[int]]:
   let gamma=choose_gamma(B) in
   for i in cell do let (x,y)=element(B,i) in tau(parameter(x,y,gamma)) od

set tau_containing (Block B,[int] P) = [int]:
   let t=tau_invariants(B) in
 ##for ti@i in t do if P<=ti then [i] else [] fi od

{moved elsewhere since needed earlier
 for now: is_Aq.at}
{ test if (x,y) -> Aq parameter }
{ the first version isn't necessary, just use the second }
{ because element(B,i) returns (x,y), so this makes is_Aq(element(B,i)) work: }
{ set is_Aq(KGBElt x,KGBElt y) = is_Aq(parameter(x,y,choose_gamma(x,y))) }
set is_Aq ((KGBElt x,KGBElt y)) = bool:
   is_coh_ind_from_finite_dimensional(parameter(x,y,choose_gamma(x,y)))

set is_Aq_cell (Block B,[int] C) = bool:
   any(#C,(int i)bool: is_Aq(element(B,C[i])))

set is_Aq (Block B,int i) = bool: is_Aq(element(B,i))

set Aq_cells (Block B,[[int]] cells) = [[int]]:
 ##for C in cells do if is_Aq_cell(B,C) then [C] else [] fi od

set Aq_reps (Block B,[int] cell) = [int]:
 ##for i in cell do if is_Aq(B,i) then [i] else [] fi od

set Aq_cells (RealForm G,[[int]] cells) = [[int]]:
   Aq_cells(principal_block(G),cells)


{				Real nilpotents

  |set_type RealNilpotent = (vec H, KGBElt x, void .)| defined above

  A real nilpotent orbit is determined by a coweight H and a KGBElt x
  where x should be in the distinguished fiber, and H\in X_* is the semisimple
  element of a Lie triple.
  It is required that \theta_x(H)=H
  set q=parabolic_by_cwt(x,H), then
  orbit=induced from trivial orbit of Levi factor, equivalently
       =associated variety of A_q(lambda)

  If H is dominant it must satisfy: <\alpha,H>\in {0,1,2} for all simple alpha
  not all such H are allowed
  (H,x) is equivalent to (H*inverse(w), cross(w,x))
  in particular if H is not dominant it can be replaced by
  an equivalent one with H dominant
}

set real_nilpotent (vec H,KGBElt x) = RealNilpotent:(H,x,())

set printable_real_nilpotent (RealNilpotent (H,x,)) = (vec,KGBElt): (H,x)

set parabolic_of_orbit (RealNilpotent (H,x,)) = Parabolic: parabolic_by_cwt(H,x)

set =(RealNilpotent (H,x,):O1, RealNilpotent (K,y,):O2) = bool:
   real_form(x)=real_form(y) and
   dominant(H,x.root_datum)=dominant(K,y.root_datum) and
   parabolic_of_orbit(O1)=parabolic_of_orbit(O2)

set sort_by ((RealNilpotent->int) f) =
   ([RealNilpotent] v) [RealNilpotent]:
      for index in inv_standardisation(for x in v do f(x) od) do v[index] od

set root_datum (RealNilpotent O) = RootDatum: O.x.root_datum
set real_form (RealNilpotent O) = RealForm: O.x.real_form
set Levi_of_orbit (RealNilpotent O) = RealForm: Levi(parabolic_of_orbit(O))
set complex_orbit (RealNilpotent O) = ComplexNilpotent:
   complex_nilpotent(O.x.root_datum,O.H)
set dimension (RealNilpotent O) = int: dim_nilpotent(O.complex_orbit)

set sort_by_dimension = ([RealNilpotent]->[RealNilpotent]):
   sort_by(dimension@RealNilpotent)

set simple_roots_from_coweight (RootDatum rd, ratvec v) = [int]:
 ##for alpha@i in simple_roots(rd) do if =alpha*v then [i] else [] fi od

set simple_roots_from_coweights (RootDatum rd,[ratvec] list) = [[int]]:
   for v in list do simple_roots_from_coweight(rd,v) od

set find_cayley (KGBElt x) = int:
   first(#simple_roots(x.root_datum), (int i)bool: status(i,x)=2 {real root})

set choose_Cayley (int i,KGBElt x) = KGBElt:
   let y=Cayley(i,x) in
   if torus_bits(y)=torus_bits(x) then y
   else let z=cross(i,y) in
      assert(torus_bits(z)=torus_bits(x),"failure in choose_cayley")
   ;  z
   fi

set move_to_distinguished_fiber (KGBElt x) = (KGBElt,WeylElt):
   (x,id_W(x.root_datum)). { apply following recursive function }
   (rec_fun f(KGBElt x,WeylElt w) (KGBElt,WeylElt):
      if in_distinguished_fiber(x) then (x,w)
      else let (w1,y)=from_no_Cminus(x) then j=find_cayley(y) in
         if j.< then f(y,inverse(w1)*w)
         else f(choose_Cayley(j,y),inverse(w1)*w)
         fi
      fi
   )

set move_to_distinguished_fiber (([int] H,KGBElt x)) = (vec,KGBElt):
   let (y,w)=move_to_distinguished_fiber(x) in (H*inverse(w),y)

set move_to_distinguished_fiber (RealNilpotent O) = RealNilpotent:
   let (H,x,)=O in real_nilpotent(move_to_distinguished_fiber((H,x)))

set stabilizer_of_x (KGBElt x) = [WeylElt]:
   let G=real_form(x) in
 ##for w in W(G) do if cross(w,x)=x then [w] else [] fi od

{. Given a real group G and a list of simple roots determining a standard
   complex Levi MC, make a list of real forms of MC in G. .}
set viable_Levis (RealForm G,[int] S) = [RealForm]:
   for P in parabolics_with_theta_stable_Levi(G,S) do Levi(P) od

{. Given a real form G, a coweight H which determines a complex nilpotent
   orbit OC, distinguished in the Levi MC, find all KGB elements x so that
   (H,x,) is a real form of OC. M is a real form of MC in G, and MC is
   determined by the simple roots S. H must be the conjugate determined
   by MC. .}
set test_real_orbit (RealForm G,[int] H, RealForm M, [int] S) = [KGBElt]:
 ##for x_M in KGB(M)
   do let P_L=Parabolic:(simple_roots_from_coweight(root_datum(M),H),x_M)
   in if is_parabolic_theta_stable(P_L) and x_M=x_min(P_L) else []
      then
         let MC=complex_Levi(G,S), theta=involution(x_M)
         then dim_center=rank(lie_compact_radical(inner_class(MC,theta)))
         , number_roots =
            for alpha in posroots(M)
            do if is_noncompact_imaginary(alpha,x_M) and H*alpha=2 then 1
               elif is_complex(alpha,x_M) and H*alpha=2 then /2 { with 2/2=1 }
               else 0
               fi
            od.sum
      in if dimension(K_0(Levi_of_orbit(real_nilpotent(H,x_M))))
           =dim_center+number_roots
         then [KGB_elt(G,x_M)]
         else []
         fi
      fi
    od

{. Given G and a coweight H, find all x so that (H_nd,x,) is a real
   nilpotent orbit. Here H_nd is the conjugate of H corresponding to
   the associated Bala-Carter Levi M. There may be duplications of
   orbits. .}
set all_real_nilpotent_orbit_KGBs (RealForm G,[int] H) = [KGBElt]:
   let (S,K)=Levi_of_H(H,G) then Levis=viable_Levis(G,S) in
 ##for M in Levis do test_real_orbit(G,K,M,S) od

set is_conjugate_orbit (RealNilpotent O,RealNilpotent P) = bool:
   assert(O.real_form=P.real_form);
   let (H,x,)=move_to_distinguished_fiber(O)
   ,   (K,y,)=move_to_distinguished_fiber(P)
   then L=K*inverse(cross_divide(x,y))
   in any(for w in stabilizer_of_x(x) do L*w=H od)

{. Replace (H,x) with equivalent (H',x') with H' dominant. .}
set dominant (RealNilpotent(H,x,):O) = RealNilpotent:
   let (H_dom,w)=from_dominant(H,O.real_form)
   then O_dom=real_nilpotent(H_dom,cross(w,x))
in {=(H*inverse(w), cross(w,x))}
   assert(is_conjugate_orbit(O_dom,O),"dominant(orbit) failed");
   O_dom

set find_conjugate ([RealNilpotent] list,RealNilpotent O) = int:
   first(#list,(int i)bool: list[i].root_datum=O.root_datum and
                            is_conjugate_orbit(list[i],O))

{. Remove duplications (conjugates) from the list of
   all_real_nilpotent_orbit_KGBs. .}
set real_nilpotent_orbit_KGBs (RealForm G,vec H) = [KGBElt]:
   let result=[KGBElt]:[] { need access to result to eliminate conjugates }
in for x in all_real_nilpotent_orbit_KGBs(G,H)
   do if for y in result
         do is_conjugate_orbit(real_nilpotent(H,x),real_nilpotent(H,y))
         od.none
      then result#:=x fi
   od; result

{. Auxiliary function. .}
set real_nilpotent_orbit_KGPs (RealForm G,vec H) = [KGPElt]:
   if =H then [parabolic_by_cwt(H,KGB(G,0))]
   else let result=[KGPElt]:[] { need access to eliminate repetition } in
      for x in all_real_nilpotent_orbit_KGBs(G,H)
      do let P=parabolic_of_orbit(real_nilpotent(H,x)) in
         if for Q in result do P=Q od.none then result#:=P fi
      od
   ;  result
   fi

{. Make a list of all real nilpotent orbits (H,x,) of G with
   H dominant and x in the distinguished fiber. .}
set real_nilpotent_orbits (RealForm G) = [RealNilpotent]:
   for H in all_H_nd(G)
   do let K=dominant(H,root_datum(G))
      ,  kgps=real_nilpotent_orbit_KGPs(G,H)
   in for P in kgps do real_nilpotent(K,x_min(P)) od
   od.##.sort_by_dimension

set number_real_nilpotent_orbits (RealForm G) = int: #G.real_nilpotent_orbits
set number_real_nilpotent_orbits ([RealForm] groups) = [int]:
   for G in groups do G.number_real_nilpotent_orbits od
set number_real_nilpotent_orbits (InnerClass ic) = [int]:
   number_real_nilpotent_orbits(ic.real_forms)

{. Make a list of the real forms of a given complex nilpotent orbit. .}
set real_nilpotent_orbits (ComplexNilpotent OC,RealForm G) = [RealNilpotent]:
   let (,K)=Levi_of_H(OC.H,OC.root_datum) in
   for P in real_nilpotent_orbit_KGPs(G,K)
   do real_nilpotent(dominant(K,OC.root_datum),x_min(P))
   od

set number_real_nilpotent_orbits (ComplexNilpotent O,RealForm G) = int:
   #real_nilpotent_orbits(O,G)
set number_real_nilpotent_orbits (ComplexNilpotent O,[RealForm] groups) = [int]:
   for G in groups do number_real_nilpotent_orbits(O,G) od
set number_real_nilpotent_orbits (ComplexNilpotent O,InnerClass ic) = [int]:
   number_real_nilpotent_orbits(O,ic.real_forms)

{ filter |list| of real nilpotents, keeping the real forms of given OC }
set real_nilpotent_orbits([RealNilpotent] list, ComplexNilpotent OC) =
      [RealNilpotent]:
   for O in list do if complex_orbit(O)=OC then [O] else [] fi od.##

set make_dominant_H (RealNilpotent (H,x,):O) = RealNilpotent:
   real_nilpotent(dominant(H,root_datum(x)),x_min(parabolic_of_orbit(O)))

{. Given a real nilpotent orbit, find all real Levi subgroups M so that the
   orbit has an element that is distinguished in M. There may be duplications.
.}
set Levis_with_distinguished_orbit (RealNilpotent (H,x,):O) =
       [(vec,KGBElt),RealForm]:
   let G=x.real_form then (S,K)=Levi_of_H(H,G.root_datum)
in for (M,xes) in for M in viable_Levis(G,S) do (M,test_real_orbit(G,K,M,S)) od
   do for y in xes
      do if is_conjugate_orbit(O,real_nilpotent(K,y)) then [((K,y),M)]
         else []
         fi
      od.##
   od.##

set find_vec (vec H, [vec] m) = int:
   first(#m, (int i)bool: m[i]=H)

set is_w_conjugate ([vec] r1, [vec] r2, WeylElt w)=bool:
   #r1=#r2 and
   for H in r1
   do let Hw=H*w { this used to be |w*H|: improper action on coweights } in
      for H2 in r2 do H2=Hw od.any
   od.all

{ laborious test to see if acting by any w in W transforms r1 into r2 }
set is_conjugate ([vec] r1, [vec] r2, [WeylElt] W) = bool:
   for w in W do is_w_conjugate (r1,r2,w) od.any
set is_W_conjugate ([vec] r1, [vec] r2, RootDatum rd) = bool:
   is_conjugate(r1,r2,W(rd))

{ same, but export a witnessing |w| too }
set is_W_conjugate_by_w ([vec] r1, [vec] r2, [WeylElt] W) = (bool,WeylElt):
   for w in W
   do if is_w_conjugate(r1,r2,w) then return(true,w) fi
   od; (false,W[0])

set is_W_conjugate_by_w ([vec] r1, [vec] r2, RootDatum rd) = (bool,WeylElt):
   is_W_conjugate_by_w(r1,r2,W(rd))

{ this function assumes elements of |S| are >=0, and |rd| has a |highest_root| }
set pseudo_roots ([int] S, RootDatum rd) = [vec]:
   for i in S
   do if i<semisimple_rank(rd) then root(rd,i)
      else {any higher index encodes lowest root} -highest_root(rd)
      fi
   od

set roots ([int] S, RootDatum rd) = [vec]: for i in S do root(rd,i) od

set two_rho_of_pseudo_Levi (RootDatum rd,[int] list)=vec:
   dominant(rd,ratvec_as_vec(2*rho(complex_pseudo_Levi(rd,list))))

{use is_conjugate to test conjugacy}
{this only works if rd(.derived?) is simple}
{alternative: pseudo_Levi_subgroups defined in subgroups.at}
set pseudo_Levis (RootDatum rd)=[[int]]:
let
   r=semisimple_rank(rd) then
   levis=standard_Levi_conjugacy_representatives(rd) then
   triples=[([int],vec,[vec])]:
   for L in levis
   do (L,two_rho_of_pseudo_Levi(rd,L),pseudo_roots(L,rd)) od
   in for S in power_set(#r)
     do let T=r#S in
        if #S<r then let rhoT=two_rho_of_pseudo_Levi(rd,T) then
                pr=pseudo_roots(T,rd) then
                temp=[([int],vec,[vec])]:
                ##for (a,v,c) in triples
                    do if v=rhoT then [(a,v,c)] else []
                       fi
                    od in
                      if none(for (,,m) in temp do is_conjugate(rd,pr,m) od)
                         then triples#:=(T,rhoT,pr)
                      fi
         fi
     od;
     for (T,,) in triples do T od

{use is_conjugate to test conjugacy}
{slightly different version from jda
 delete this once we're sure we have the right version
set pseudo_Levis (RootDatum rd)=[[int]]: let W=W(rd) then
   r=semisimple_rank(rd) then
   levis=standard_Levi_conjugacy_representatives(rd) then
   triples=[([int],vec,[vec])]:
   for L in levis
   do (L,two_rho_of_pseudo_Levi(rd,L),pseudo_roots(L,rd)) od
   in for S in power_set(#r)
     do let T=add_element(S,r) in
        if #S<r then let rhoT=two_rho_of_pseudo_Levi(rd,T) then
                pr=pseudo_roots(T,rd) then
                temp=[([int],vec,[vec])]:
                ##for (a,v,c) in triples
                    do if v=rhoT then [(a,v,c)] else []
                       fi
                    od in
                      if none(for (,,m) in temp do is_conjugate(pr,m,W) od)
                         then triples#:=(T,rhoT,pr)
                      fi
         fi
     od;
     for (T,,) in triples do T od
}

{don't need d_L}
set d_L (RootDatum rd,[int] L)=int: let r=semisimple_rank(rd)
   in if #L=0 then 0 else
   if max(L)<r then 1 else
    let list= for i in complement(r+1,sort(L)) do simple_root_labels(rd)[i] od
    in gcd(list) fi fi

set d_L(RootDatum rd,RootDatum rd_L)=order_center(rd_L.mod_central_torus)

{don't use this, use is_conjugate(rd,L,M) from conjugate.at instead}
set is_conjugate_pseudo_Levi ([int] L, [int] M, RootDatum rd)=bool:
   #L=#M and
(  let W=W(rd), prl=pseudo_roots(L,rd), prm=pseudo_roots(M,rd)
   in is_conjugate(prl,prm,W)
)

{replaces old pseudo_Levis_of_orbit
 also return H_L in L mapping to (conjugacy class of) H in rd
 use H_L to construct the relevant centralizer_rd(H_L)
 for use in generators_of_component_group
}
set pseudo_Levis (ComplexNilpotent O) = [RootDatum,vec]:
   for L in pseudo_Levi_subgroups(O.root_datum)
   do let distinguished_H_L=distinguished_Hs(L)
      then j=first
	(for H_L in distinguished_H_L do dominant(H_L,O.root_datum)=O.H od)
   in if j>=0 then [(L,distinguished_H_L[j])] else [] fi
   od.##

{orbits in pseudo Levis which saturate to O}
set saturating_orbits(ComplexNilpotent O) = [ComplexNilpotent]:
   for (L,H) in O.pseudo_Levis do (L,(),H) od

{Note: affine root is n+1 not 0}
{this works only if rd.derived is simple}
set pseudo_Levi(RootDatum rd,[int] S)=RootDatum:
if #S=0 then root_datum(null(rank(rd),0),null(rank(rd),0),rd.prefers_coroots)
else
let simple_roots=for i in S do
 if i<ss_rank(rd) then simple_roots(rd)[i] else -highest_root(rd) fi od
then simple_coroots=for v in simple_roots do coroot(rd,v) od
in root_datum(simple_roots,simple_coroots,rd.prefers_coroots)  fi

{run over list of pairs [(v,w)], only keep those for which the v's
give distint torus elements
use this to filter result of Kac_diagrams_with_centralizer
previously the filtering was done on the fly which was wasteful
}
set filter(RootDatum rd,[[int],WeylElt] list) = [[int],WeylElt]:
   let keep=[([int],WeylElt)]:[]
in for (v,w) in list
   do if none(for (u,) in keep do is_conjugate_Kac(v,u,rd) od)
      then keep#:=(v,w)
      fi
   od; keep

{use maybe_conjugate from conjugate.at to test conjugacy}
{. Given a pseudo-Levi L, find all Kac diagrams of order m and whose
   centralizer is conjugate to L. .}
set Kac_diagrams_with_centralizer (RootDatum rd, RootDatum L,int m)=[([int],WeylElt)]:
   let ()=if nilpotent_verbose then prints("Kac_diagrams_with_centralizer: L=", L,
   " m=", m) fi in
   let diags=Kac_classes_given_order_crude(rd,m) in
   let ()=if nilpotent_verbose then prints("#diagrams: ",#diags) fi in
   let crude=##for d in diags do
     let maybe=maybe_conjugate(rd,pseudo_Levi(rd,zero_roots(rd,d)),L)
   in
      if any(maybe) then [(d,req(maybe))] else [] fi od then
   rv=filter(rd,crude) in
   if nilpotent_verbose then prints("crude answer:", #crude, "  final result:", #rv)
   fi;rv

{order_center is defined in center.at}
{set order_of_center (RootDatum rd)=#Kac_classes_given_order(rd,1)}

set Kac_triples_simple (RootDatum rd,RootDatum L, int c)=[(int,[int],ratvec,WeylElt)]:
   let d=d_L(rd,L) in
     let list=Kac_diagrams_with_centralizer (rd,L,c*d) in
        for (diag,w) in list do (c*d,diag,Kac_x(rd,diag),w) od

set Kac_triples (RootDatum rd, RootDatum L)=[(int,[int],ratvec,WeylElt)]:
   let c=order_center (rd) in
   let ()=if nilpotent_verbose then prints("c=",c, new_line,"2*d*c=", 2*d_L(rd,L)*c)
          fi in
   ##for i:2*d_L(rd,L)*c from 1 do Kac_triples_simple(rd,L,i) od

set in_radical (ratvec v, RootDatum rd) = bool:
   let (,M)=mod_central_torus_info(rd) in is_integer(v*M)


set generators_of_Z_mod_Z_0 (RootDatum rd, RootDatum L) = [ratvec]:
   let result=[ratvec]:[] in
   let KC=Kac_triples (rd,L) in
   for (i,diag,v,w) in KC do let k=v*inverse(w) in
       if none (for u in result do in_radical((k-u),L) od)
        then result#:=v*inverse(w) fi od;
   result

{Need a matrix A lifting an element of T/Z(G)^0 to T,
i.e. satisfying:
Gmod=G/Z^0
A*simple_coroots(Gmod)=simple_coroots(G)
 Gmod is semisimple so simple_coroots(Gmod) is (square and) invertible/Q
 => A=simple_coroots(G)*inverse(simple_coroots(Gmod))
 this is applied to L
}
set lift(RootDatum rd,ratvec v)=ratvec:
 let rd_mod=mod_central_torus(rd) then
 A=simple_coroots(rd)*inverse(mat_as_ratmat(simple_coroots(rd_mod))) in A*v

set generators_of_component_group_old (ComplexNilpotent O)=
      [RootDatum,[ratvec],[ratvec],[ratvec],[ratvec]]:
  for (L,H_L) in pseudo_Levis(O)
  do let Lmod=mod_central_torus(L)
     then Z_Lmod=elements_of_center(Lmod) {center of L/Z(L)^0}
     then L_rad=radical_basis(L) {central torus}
     then (,M)=Levi_of_subspace(O.root_datum,L_rad) {centralizer of L_rad}
     then
{ A=simple_coroots(L)*inverse(mat_as_ratmat(simple_coroots(Lmod))) then}
 { Z_Lmod_lifted=for v in ratmat_to_bigmat(A*Z_Lmod) do ratvec:v  od {convert ratmat to
list of ratvecs}  then}
 {cut down Z_Lmod to those elements satisfying Cent_G(tZ(L)^0)=L}
        Z_Lmod_reg =
        ##for v in Z_Lmod
          do if dimension(centralizer(M,lift(L,v)))=L.dimension
             then [v] else []
	     fi
	  od
     then
 {we now have elements [s_1,...,s_n] of L/Z(L)^0
  lift these to [t_1,...,t_n] of G (not unique of course)
  keep one from each conjugacy class, say [t_i_1,...,t_i_r]
  THEN what matters is the corresponding elements [s_i_1,...,s_i_r], specifically their orders
  Guess/Hope: s_iZ(L)^0 is conjugate to s_jZ(L)^0 by cent_G(u) if and only if
  t_i is G-conjugate to t_j. This seems unlikely but looks to be true in examples
 }
	Z_Lmod_reg_lifted = for v in Z_Lmod_reg do lift(L,v) od
     then
 {need to use the Levi defined by H_L (not H itself) for computing conjugacy}
{ (,Levi_H_L)=Levi_of_coweight(rd,H_L) then}
         (,Levi_H_L_M)=Levi_of_coweight(M,H_L)
     then(,Levi_H_L)=Levi_of_coweight(O.root_datum,H_L)
     then
 {()=prints("Levi_H_L=",Levi_H_L," ", simple_roots(Levi_H_L)) then}
{  ()=prints("Z_Lmod_reg_lifted:", Z_Lmod_reg_lifted) then
  ()=prints("Levi_H_L:",Levi_H_L) then}
{  ()=prints(new_line,"L=",L, new_line, "M=",M) then}
{ (indices,Z_Lmod_reg_lifted_cc)=semisimple_conjugacy_class_reps(Levi_H_L,Z_Lmod_reg_lifted)
 then}
        (indices,Z_Lmod_reg_lifted_cc) =
     semisimple_conjugacy_class_mod_torus_reps(Levi_H_L,Z_Lmod_reg_lifted,L_rad)
    then
{ ()=prints("indices:", indices) then
 ()=prints("Z+Lmod_reg_lifted_cc: ", Z_Lmod_reg_lifted_cc) then}
	Z_Lmod_reg_cc=for i in indices do Z_Lmod_reg[i] od
  in (L,Z_Lmod,Z_Lmod_reg,Z_Lmod_reg_lifted,Z_Lmod_reg_lifted_cc)
  od

{returns array of:
L
H_L
Lmod
Z_Lmod
L_rad
M,
Z_Lmod_reg,
Z_Lmod_reg_lifted)
}
set generators_of_component_group_debug (ComplexNilpotent O)=
for (L,H_L) in pseudo_Levis(O) do
 let Lmod=mod_central_torus(L) then
 Z_Lmod=elements_of_center(Lmod) {center of L/Z(L)^0} then
 L_rad=radical_basis(L) {central torus} then
 (,M)=Levi_of_subspace(O.root_datum,L_rad) {centralizer of L_rad} then
 Z_Lmod_reg=##for v in Z_Lmod do if dimension(centralizer(M,lift(L,v)))=L.dimension then [v]
 else [] fi od then
 Z_Lmod_reg_lifted=for v in Z_Lmod_reg do lift(L,v) od then
 (,Levi_H_L)=Levi_of_coweight(O.root_datum,H_L) in
 (L,H_L,Levi_H_L,Lmod,Z_Lmod,L_rad,M,Z_Lmod_reg,Z_Lmod_reg_lifted)
od

set generators_of_component_group (ComplexNilpotent O)=
[(RootDatum,vec,[ratvec],[ratvec],[ratvec],[ratvec])]:
for (L,H_L) in pseudo_Levis(O) do
{let ()=prints("doing H_L:",H_L) in
let ()=prints("L=",L) in}
 let Lmod=mod_central_torus(L) then
 Z_Lmod=elements_of_center(Lmod) {center of L/Z(L)^0} then
 L_rad=radical_basis(L) {central torus} then
 (,M)=Levi_of_subspace(O.root_datum,L_rad) {centralizer of L_rad} then
{ A=simple_coroots(L)*inverse(mat_as_ratmat(simple_coroots(Lmod))) then}
 { Z_Lmod_lifted=for v in ratmat_to_bigmat(A*Z_Lmod) do ratvec:v  od {convert ratmat to
list of ratvecs}  then}
 {cut down Z_Lmod to those elements satisfying Cent_G(tZ(L)^0)=L}
 Z_Lmod_reg=##for v in Z_Lmod do if dimension(centralizer(M,lift(L,v)))=L.dimension then [v]
 else [] fi od then
 {we now have elements [s_1,...,s_n] of L/Z(L)^0
  lift these to [t_1,...,t_n] of G (not unique of course)
  keep one from each conjugacy class, say [t_i_1,...,t_i_r]
  THEN what matters is the corresponding elements [s_i_1,...,s_i_r], specifically their orders
  Guess/Hope: s_iZ(L)^0 is conjugate to s_jZ(L)^0 by cent_G(u) if and only if
  t_i is G-conjugate to t_j. This seems unlikely but looks to be true in examples
 }
 Z_Lmod_reg_lifted=for v in Z_Lmod_reg do lift(L,v) od then
 {need to use the Levi defined by H_L (not H itself) for computing conjugacy}
{ (,Levi_H_L)=Levi_of_coweight(O.root_datum,H_L) then}
 (,Levi_H_L_M)=Levi_of_coweight(M,H_L) then
  (,Levi_H_L)=Levi_of_coweight(O.root_datum,H_L) then
  {()=prints("Levi_H_L=",Levi_H_L," ", simple_roots(Levi_H_L)) then
  ()=prints("Z_Lmod_reg_lifted:", Z_Lmod_reg_lifted) then
  ()=prints("Levi_H_L:",Levi_H_L) then
  ()=prints(new_line,"L=",L, new_line, "M=",M) then
  ()=prints(new_line,"Levi_H_L= ",Levi_H_L,new_line,"Z_Lmod_reg_lifted=",Z_Lmod_reg_lifted) then}
 (indices,Z_Lmod_reg_lifted_cc)=semisimple_conjugacy_class_reps(Levi_H_L,Z_Lmod_reg_lifted)
 then
 (indices,Z_Lmod_reg_lifted_cc)=semisimple_conjugacy_class_mod_torus_reps(Levi_H_L,Z_Lmod_reg_lifted,L_rad) then
{ ()=prints("indices:", indices) then
 ()=prints("Z+Lmod_reg_lifted_cc: ", Z_Lmod_reg_lifted_cc) then}
 Z_Lmod_reg_cc=for i in indices do Z_Lmod_reg[i] od in
 (L,H_L,Z_Lmod,Z_Lmod_reg,Z_Lmod_reg_lifted,Z_Lmod_reg_lifted_cc)
od

{ complex Levi of orbit: defined by diagram of H (not the Bala Carter Levi) }
set complex_Levi(ComplexNilpotent O) = RootDatum:
   let rd =O.root_datum
   then S =
     for alpha@i in rd.simple_roots do if =O.H*alpha then [i] else [] fi od.##
   in sub_datum(rd,S)

set order_in_A (ratvec v, RootDatum rd, vec H) = int:
   let div=divisors(denom(v))
   then k=first(#div,
          (int i): let dv=div[i]*v then CL = RootDatum: centralizer(rd,dv)
                   then L=Bala_Carter_Levi(complex_nilpotent(CL,H))
	           in in_radical(dv,L)
          )
in div[k]

set component_datum(ComplexNilpotent O)=ComplexNilpotentComponentDatum:
(ComplexNilpotent,[int],[(RootDatum,[ratvec])]):
if O.root_datum.is_abelian then
 let rd=O.root_datum in
 (O,[1],[(rd,[null(rd.rank)/1])]) else
let g=generators_of_component_group(O)
then orders=## for (a,H,b,c,d,S) in g do for v in S do order_in_A(v,O.root_datum,H) od od in
(O,sort(orders),for (L,H,b,c,d,S) in g do (L,S) od)
fi

set component_datum_plus(ComplexNilpotent O) =
   (ComplexNilpotent,[int],[(RootDatum,vec,[ratvec])]):
if O.root_datum.is_abelian
then (O,[1],[(O.root_datum,null(0),[null(O.root_datum.rank)/1])])
else let g=generators_of_component_group(O)
   then orders=
      ## for (a,H,b,c,d,S) in g
         do for v in S do order_in_A(v,O.root_datum,H) od
	 od
   in (O,sort(orders),for (L,H,b,c,d,S) in g do (L,H,S) od)
fi


{representatives of conjugacy classes in A(O)
 each ratvec v gives an element exp(2\pi iv) which is G-conjugate
 to an element of Cent(O)
}
set component_representatives(ComplexNilpotent orbit) = [RootDatum,ratvec]:
let (,,pairs)=orbit.component_datum in
 ##for (L,ratvecs) in pairs do
    for v in ratvecs do (L,v)
    od
   od

set component_representatives_plus(ComplexNilpotent orbit) =
      [(RootDatum,vec,ratvec)]:
let (,,triples)=orbit.component_datum_plus in
 ##for (M,v,ratvecs) in triples do
    for w in ratvecs do (M,v,w) od
   od

set conjugacy_class_orders(ComplexNilpotent O) = [int]: O.component_datum.orders
set number_conjugacy_classes_component_group(ComplexNilpotent O) = int:
   #O.component_datum.orders
set number_conjugacy_classes_A = (ComplexNilpotent->int):
   number_conjugacy_classes_component_group@ComplexNilpotent

set show(ComplexNilpotentComponentDatum d) = void:
   let header=["pseudo_Levi","Generators"] in
   let values=
   for (L,S) in d.pairs do
   [L.derived.nice_format,S.to_string] od in
   prints("Component info for orbit:",new_line,"H=", d.orbit.H{_of_triple}, " diagram:",
   d.orbit.diagram, " dim:", d.orbit.dim_nilpotent);
prints("orders of conj. classes:",d.orders);
   tabulate(header#values)

set print_component_info (ComplexNilpotent O) = void:
   let d=component_datum(O) then
   header=["pseudo_Levi","Generators"] then
   values=
   for (L,S) in d.pairs do
   [L.derived.nice_format,S.to_string] od in
   prints("Component info for orbit:",new_line, "H=", O.H{_of_triple}, " diagram:",
   O.diagram, " dim:", O.dim_nilpotent);
   prints("orders:",d.orders);
   tabulate(header#values)


set print_component_info_long (ComplexNilpotent O) = void:
prints("Component info for orbit:",new_line, "H=", O.H{_of_triple}, " diagram:",
O.diagram, " dim:", O.dim_nilpotent);
for (L,H_L,Z_Lmod,Z_Lmod_reg,Z_Lmod_reg_lifted,Z_Lmod_reg_cc) in generators_of_component_group(O) do
prints(new_line,"L:",L.derived,new_line,"Z(L)/Z(L)^0: ",Z_Lmod,new_line,"Z(L)/Z(L)^0-reg: ",
Z_Lmod_reg,new_line,"Z(L)/Z(L)^0-reg-lifted: ",
Z_Lmod_reg_lifted,new_line,"Z(L)/Z(L)^0-cc: ",Z_Lmod_reg_cc) od

set print_component_info (RootDatum rd)=void:
   prints("Component groups of nilpotent orbits",new_line,"G=",rd);
   for orb@i in nilpotent_orbits (rd) do
   prints(new_line,"Orbit #",i);print_component_info (orb) od

set print_component_info_long (RootDatum rd)=void:
   for orb@i in nilpotent_orbits (rd) do prints();
   prints(new_line,"Orbit #",i);print_component_info_long (orb) od

set print_component_info_short (RootDatum rd)=void:
tabulate(["i","H","diag","dim","A(O)"]#
 for orb@i in nilpotent_orbits (rd) do
 let d=component_datum(orb) in
 [i.to_string,orb.H{_of_triple}.to_string,orb.diagram.to_string,orb.dim_nilpotent.to_string,
 d.orders.to_string] od
 )

set print_component_info_alt (RootDatum rd)=void:
tabulate(["i","diag","dim","A(O)"]#
 for orb@i in nilpotent_orbits (rd) do
 let d=component_datum(orb) in
 [i.to_string,orb.diagram.to_string,orb.dim_nilpotent.to_string,
 d.orders.to_string] od
 )

{------ principal, zero, subregular and minimal orbits -----}

set principal_orbit(RootDatum rd) = ComplexNilpotent:
   complex_nilpotent(rd,two_rho_check(rd))

set zero_orbit(RootDatum rd) = ComplexNilpotent:
   complex_nilpotent(rd,null(rank(rd)))

set subregular_orbit_simple (RootDatum rd) = ComplexNilpotent:
assert(rd.derived_is_simple,"RootDatum is not simple");
if is_abelian(rd) then (rd,(),rd.rank.null) else
let orbits=nilpotent_orbits(rd) then
j=first(for orbit in orbits do orbit.dim_nilpotent=rd.dimension-rd.rank-2 od) in
orbits[j] fi

set minimal_orbit_simple(RootDatum rd) = ComplexNilpotent:
assert(rd.derived_is_simple,"RootDatum is not simple");
{L=SL(2,highest_root)
 2*rho^v(L)=highest_short_root(dual(rd))
}
  complex_nilpotent(rd,rd.dual.highest_short_root)

{if rd has n simple factors it has n subregular orbits
each has codimension 2
could find them by dimension, but alternatively
take the product of the principal orbits in all
but 1 factor, and the subregular in that factor
this is what is needed in the minimal case
subregular_orbits(rd)[i] is the subregular orbit
 on factor i, and principal on all other factors
}
set subregular_orbits(RootDatum rd) = [ComplexNilpotent]:
let factors=simple_factors(rd) then
orbits=[ComplexNilpotent]:[] in
for i:#factors do
 let H=null(rd.rank) in
 for j:#factors do
  if i=j then H+:=factors[j].subregular_orbit_simple.H{_of_triple}
   else H+:=ratvec_as_vec(2*factors[j].rho_check)
  fi
 od;
 orbits#:=complex_nilpotent(rd,H)
od;
orbits

{if rd has n simple factors it has n minimal orbits
take the product of the 0 orbit in all
but 1 factor, and the minimal orbit in that factor
minimal_orbits(rd)[i] is the minimal orbit
 on factor i, and 0 on all other factors
}
set minimal_orbits(RootDatum rd) = [ComplexNilpotent]:
let factors=simple_factors(rd) then
orbits=[ComplexNilpotent]:[] in
for i:#factors do
 let H=null(rd.rank) in
 for j:#factors do
  if i=j then H+:=factors[j].minimal_orbit_simple.H{_of_triple}
  fi
 od;
 orbits#:=complex_nilpotent(rd,H)
od;
orbits


set minimal_real_nilpotent_orbits (RealForm G) = [RealNilpotent]:
##for orbit in minimal_orbits(G.root_datum) do real_nilpotent_orbits(orbit,G) od


{show commands moved to nilpotent_centralizer.at}
{
set show_nilpotent_orbits([ComplexNilpotent] orbits)=void:
tabulate(for orbit in orbits do
[orbit.H{_of_triple}.to_string,orbit.diagram.to_string,orbit.dim_nilpotent.to_string] od)

set show_nilpotent_orbits(RootDatum rd)=void:
show_nilpotent_orbits(nilpotent_orbits(rd))
}

{integrality_datum of an orbit O_check for G_check
 rd=root datum on group side -> integrality_datum(rd,H/2)
 this is the dual of the root datum of a subgroup of G_check
}
set integrality_datum (ComplexNilpotent O_check) = RootDatum:
   integrality_datum(O_check.root_datum.dual,O_check.H/2)

{given an orbit O_check on the dual side
 rd_int: integrality datum(O_check)
 rd_int_dual: dual(rd_int), root datum of subgroup on dual side
 return (rd_int_dual,(),O_check.H)
}
set integral_descent (ComplexNilpotent O_check) = ComplexNilpotent:
   complex_nilpotent(integrality_datum(O_check).dual,O_check.H)

{see weak_packets.at for integral_descent@(SpringerTable,ComplexNilpotent)}

set is_even(ComplexNilpotent O) = bool: is_integer(O.diagram/2)
set is_non_even(ComplexNilpotent O) = bool: not is_integer(O.diagram/2)

set even_orbits([ComplexNilpotent] orbits) = [ComplexNilpotent]:
##for O in orbits do if is_even(O) then [O] else [] fi od
set even_orbits(RootDatum rd) = even_orbits(orbits(rd))

set non_even_orbits([ComplexNilpotent] orbits) = [ComplexNilpotent]:
##for O in orbits do if is_non_even(O) then [O] else [] fi od
set non_even_orbits(RootDatum rd) =[ComplexNilpotent]:
   non_even_orbits(rd.orbits)

set dual_orbits (RootDatum rd) = [ComplexNilpotent]: rd.dual.orbits
set even_dual_orbits(RootDatum rd) = [ComplexNilpotent]:
   even_orbits(rd.dual_orbits)
set non_even_dual_orbits(RootDatum rd) = [ComplexNilpotent]:
   non_even_orbits(rd.dual_orbits)

set twist(mat delta,ComplexNilpotent O) = ComplexNilpotent:
  complex_nilpotent(O.root_datum,O.H*delta)  {O.H\in X_*, delta acts on right}
