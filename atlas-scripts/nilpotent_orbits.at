<combinatorics.at { for |even_places@[int] }
<parabolics.at { for |Levi@Parabolic|, |parabolic_by_cwt@(ratvec,KGBElt)| }
<parameters.at { for |parameter@(KGBElt,KGBElt,ratvec)| }
<W_classes.at {for |standard_Levi_conjugacy_representatives@RootDatum| }
<K.at { for |K_0@RealForm| }
<induction.at { for |embed_KGB@(KGBElt,RealForm)| }
<center.at { for |lie_compact_radical)@InnerClass| }

{ ComplexNilpotent: (RootDatum rd,vec H)
  where [H,X,Y] is a Lie triple, H\in X_*, and orbit=G.X
  H must satisfy <alpha,H>=0,1,2 for all simple roots,
  in particular is_dominant(H,rd) should hold
}
set_type
[ ComplexNilpotent = (RootDatum root_datum, void ., vec H{_of_triple})
, RealNilpotent    = (vec H, KGBElt x, void .)
]

set complex_nilpotent (RootDatum rd, vec H) = ComplexNilpotent: (rd,(),H)

{. Two complex nilpotent orbits are equal if the root data are, and
   the H's are conjugate by the Weyl group. .}
set = (ComplexNilpotent O1,ComplexNilpotent O2) = bool:
   let rd=O1.root_datum in rd=O2.root_datum and
   dominant(O1.H,rd)=dominant(O2.H,rd)

{ dimension of the orbit of nilpotents described by a |ComplexNilpotent| }
set dim_nilpotent (ComplexNilpotent(rd,,H)) = int:
  sum(for alpha in posroots(rd) do case alpha*H in 0, 1 else 2 esac od)

set diagram (ComplexNilpotent(rd,,H)) = [int]:
   dominant(H,rd){action on coweight} * simple_roots(rd)

set sort_by_dimension = ([ComplexNilpotent]->[ComplexNilpotent]):
   sort_by(dim_nilpotent@ComplexNilpotent, <=@(int,int))

set find = find(=@(ComplexNilpotent,ComplexNilpotent))

set dim_eigenspace (RootDatum rd, ratvec H, int k) = int:
   if =k { level 0 is special: include torus and negative roots at this level }
   then rank(rd) + 2*count(for alpha in posroots(rd) do =alpha*H od)
   else count(for alpha in posroots(rd) do alpha*H=k od)
   fi

set max_eigenvalue (RootDatum rd, vec H) = int:
   max(for alpha in posroots(rd) do H*alpha od)

set eigenspace_dimensions (RootDatum rd, vec H) = [int]:
   assert(is_dominant(dual(rd),H),"H is not dominant");
   for k:max_eigenvalue(rd,H)+1 do dim_eigenspace(rd,H,k) od

set even_eigenspaces (RootDatum rd, vec H) = [int]:
   even_places(eigenspace_dimensions(rd,H))
set odd_eigenspaces(RootDatum rd, vec H)=[int]:
   odd_places(eigenspace_dimensions(rd,H))

set support (Param p) = [int]:
   support(x(p)) { using |support@KGBElt| from parabolics.at }

set blocku(RealForm G) = [Param]:
   for p in block_of(trivial(G))
      if for k in support(x(p)) do is_descent(k,p) od.all
      do p
      fi
   od

{. Auxiliary function: For a list of integers giving simple roots, compute
  twice the sum of the corresponding fundamental coweights. .}
set S_weight ([int] S, RootDatum rd) = ratvec:
   sum(rd.rank, for k in S do 2*fundamental_coweight(rd,k) od)

{. These are candidates H for the semisimple element of an SL(2) triple;
   not necessarily a vec, for example in SL(3). .}
set H_candidates (RootDatum rd) = [ratvec]:
   for S in power_set(#rd.semisimple_rank) do S_weight (S,rd) od

{. Choose the H among the candidates which correspond to distinguished
   nilpotent orbits. .}
set distinguished_H (RootDatum rd_L) = [vec]:
   for H in H_candidates(rd_L)
      if dim_eigenspace(rd_L,H,2) =
         dim_eigenspace(rd_L,H,0)+semisimple_rank(rd_L)-rank(rd_L)
      do ratvec_as_vec(H)
      fi
   od

{. Given a Root Datum rd for a complex group G, list the neutral elements
   (dominant for G) corresponding to the complex nilpotent orbits. .}
set all_H (RootDatum rd) = [vec]:
   for S in standard_Levi_conjugacy_representatives(rd)
      for H in distinguished_H(Levi_datum(rd,S)) do dominant(H,rd) od
   od

{. As previous function, except the coweights H are given as sums of fundamental
   weights for the standard (Bala-Carter) Levi M in which the orbit is
   distinguished. This is the conjugate of H used for further calculation. .}
set all_H_nd (RootDatum rd) = [vec]:
   for S in standard_Levi_conjugacy_representatives(rd)
   do distinguished_H(Levi_datum(rd,S))
   od.##

{. List all (complex) nilpotent orbits (with H dominant) for a complex group. .}
set complex_nilpotent_orbits (RootDatum rd) = [ComplexNilpotent]:
   for H in all_H(rd) do complex_nilpotent(rd,H) od.sort_by_dimension

{tired of typing so many characters}
set orbits = (RootDatum->[ComplexNilpotent]): complex_nilpotent_orbits@RootDatum

set distinguished_nilpotent_orbits(RootDatum rd) = [ComplexNilpotent]:
   for H in rd.distinguished_H do complex_nilpotent(rd,H) od

{. (one) complex nilpotent orbit of minimal dimension>0 .}
set minimal_nilpotent_orbit (RootDatum rd) = ComplexNilpotent:
   let orbits=complex_nilpotent_orbits(rd) in
   assert(#orbits>=2,"No minimal orbit present"); orbits[1]

{. For a complex group, for each standard Levi M given by a list of simple
   roots, list the corresponding neutral elements H (dominant for M, not G)
   giving the complex nilpotent orbits distinguished in M. .}
set all_H_with_L (RootDatum rd) = [[int],[vec]]:
   for S in standard_Levi_conjugacy_representatives(rd)
   do (S,distinguished_H(Levi_datum(rd,S)))
   od

set find_conjugate_coweight (RootDatum rd,[vec] m, vec H) = int:
   first(#m, (int i)bool: dominant(m[i],rd)=dominant(H,rd))

{. Given a coweight H corresponding to a complex nilpotent orbit, find the
   Levi M in which the orbit is distinguished. The output is the pair consisting
   of the simple roots for M, and the conjugate of H corresponding to the
   standard Levi M (not dominant for G). The input H need not be dominant. .}
set Levi_of_H (vec H,RootDatum rd)=([int],vec):
   for (M,Hs) in all_H_with_L(rd)
   do let i=find_conjugate_coweight(rd,Hs,H) in
      if i.>= then return(M,Hs[i]) fi
   od; error("No Levi found")

{ find H which work for given q=q(x,H)=(L,u) }
set find_H (Parabolic P) = [vec,mat]:
begin
   let x=maximal(P)
   then u_p=columns_with(is_noncompact(x),nilrad_roots(P))
   , rho_L = rho(P.Levi)
   , theta_1 = involution(x)-1
   in { prints("u_p:", u_p); }
   for H in all_H(P.real_form)
      if =H*theta_1 and =H*rho_L and >H*u_p { all its entries >0 }
      do let level_two_roots = columns_with((vec alpha): H*alpha=2, u_p ) in
         (H,level_two_roots)
      fi
   od
end

set max_only ([vec,mat] arg) = [vec,mat]:
   if >#arg else [(null(0),null(0,0))] { one cannot pick a bald chicken }
   then
      let (H_last,vectors_last)=arg[#arg-1] then max=#vectors_last in
      for (H,vectors) in arg if #vectors=max do (H,vectors) fi od
   fi


{ containment order }
set <= ([int] a,[int] b) = bool: all(#a,(int i)bool: find(b,a[i]).>=)
set <  ([int] a,[int] b) = bool: sort(a) != sort(b) and a<=b

set principal_block (RealForm G) = Block: block(G,dual_quasisplit_form(G))

{ convert Block to [param] }
set convert (Block B,ratvec gamma) = [Param]:
   for i:#B do let (x,y)=element(B,i) in parameter(x,y,gamma) od

{ just subset of block }
set convert (Block B, [int] S,ratvec gamma) = [Param]:
   for i in S do  let (x,y)=element(B,i) in parameter(x,y,gamma) od

set real_form (Block B) = RealForm: let (G,)=%B in G
set rho (Block B) = ratvec: rho(real_form(B))

{ choose appropriate infinitesimal character for (x,y) }
set choose_gamma (KGBElt x,KGBElt y) = ratvec: choose_g(y,x)

{ choose appropriate infinitesimal character for B }
set choose_gamma (Block B) = ratvec: choose_gamma(element(B,0))

set convert (Block B) =         [Param]: convert(B,choose_gamma(B))
set convert (Block B,[int] S) = [Param]: convert(B,S,choose_gamma(B))

{ convert list of wcells [[int]] to [[Param]] }
set convert_list_W_cells (Block B,ratvec gamma,[[int]] Wcells) = [[Param]]:
    let converted_block=convert(B,gamma) in
    for cell in Wcells do for k in cell do converted_block[cell[k]] od od

{ return list of tau-invariants for B
  tau_invariants(B)[i]=tau-invariant of block element i
}
set tau_invariants (Block B) = [[int]]:
   let gamma=choose_gamma(B) in
   for i:#B do let (x,y)=element(B,i) in tau(parameter(x,y,gamma)) od

set tau_invariants_of_cell (Block B, [int] cell) = [int,[int]]:
   let gamma=choose_gamma(B) in
   for i in cell do let (x,y)=element(B,i) in (i,tau(parameter(x,y,gamma))) od

set tau_invariants_of_cell_raw (Block B, [int] cell) = [[int]]:
   let gamma=choose_gamma(B) in
   for i in cell do let (x,y)=element(B,i) in tau(parameter(x,y,gamma)) od

set tau_containing (Block B,[int] P) = [int]:
   for ti@i in tau_invariants(B) if P<=ti do i fi od

{ test if p is an Aq }
set is_Aq (Param p) = bool:
   all(for i in support(p) do is_descent(i,p) od)

{ test if (x,y) -> Aq parameter }
{ the first version isn't necessary, just use the second }
{ because element(B,i) returns (x,y), so this makes is_Aq(element(B,i)) work: }
{ set is_Aq(KGBElt x,KGBElt y) = is_Aq(parameter(x,y,choose_gamma(x,y))) }
set is_Aq ((KGBElt x,KGBElt y)) = bool: is_Aq(parameter(x,y,choose_gamma(x,y)))

{ compute all Aq's for G as [int], (coming from principal block) }
set Blocku (RealForm G) = [int]:
   let B=principal_block(G) in
   for i:#B if is_Aq(element(B,i)) do i fi od

set is_Aq_cell (Block B,[int] C) = bool:
   any(#C,(int i)bool: is_Aq(element(B,C[i])))

set is_Aq (Block B,int i) = bool: is_Aq(element(B,i))

set Aq_cells (Block B,[[int]] cells) = [[int]]:
   for C in cells if is_Aq_cell(B,C) do C fi od

set Aq_reps (Block B,[int] cell) = [int]:
   for i in cell if is_Aq(B,i) do i fi od

set Aq_cells (RealForm G,[[int]] cells) = [[int]]:
   Aq_cells(principal_block(G),cells)


{ |set_type RealNilpotent = (vec H, KGBElt x, void .)| defined above
tau_invariants(B)
  A real nilpotent orbit is determined by a coweight H and a KGBElt x
  where x should be in the distinguished fiber, and H\in X_* is the semisimple
  element of a Lie triple.
  It is required that \theta_x(H)=H
 tau_invariants(B) set q=parabolic_by_cwt(x,H), then
  orbit=induced from trivial orbit of Levi factor, equivalently
       =associated variety of A_q(lambda)

  If H is dominant it must satisfy: <\alpha,H>\in {0,1,2} for all simple alpha
  not all such H are allowed
  (H,x) is equivalent to (H*inverse(w), cross(w,x))
  in particular if H is not dominant it can be replaced by
  an equivalent one with H dominant
}



set real_nilpotent (vec H,KGBElt x) = RealNilpotent:(H,x,())

set printable_real_nilpotent (RealNilpotent (H,x,)) = (vec,KGBElt): (H,x)

set parabolic_of_orbit (RealNilpotent (H,x,)) = Parabolic: parabolic_by_cwt(H,x)

set =(RealNilpotent (H,x,):O1, RealNilpotent (K,y,):O2) = bool:
   real_form(x)=real_form(y) and
   dominant(H,x.root_datum)=dominant(K,y.root_datum) and
   parabolic_of_orbit(O1)=parabolic_of_orbit(O2)

set root_datum (RealNilpotent O) = RootDatum: O.x.root_datum
set real_form (RealNilpotent O) = RealForm: O.x.real_form
set Levi_of_orbit (RealNilpotent O) = RealForm: Levi(parabolic_of_orbit(O))
set complex_orbit (RealNilpotent O) = ComplexNilpotent:
   let rd=O.x.root_datum in complex_nilpotent(rd,dominant(O.H,rd))
set dimension (RealNilpotent O) = int: dim_nilpotent(O.complex_orbit)

set sort_by_dimension = ([RealNilpotent]->[RealNilpotent]):
   sort_by(dimension@RealNilpotent, <=@(int,int))

set simple_roots_from_coweight (RootDatum rd, ratvec v) = [int]:
   for alpha@i in simple_roots(rd) if =alpha*v do i fi od

set simple_roots_from_coweights (RootDatum rd,[ratvec] list) = [[int]]:
   for v in list do simple_roots_from_coweight(rd,v) od

set find_cayley (KGBElt x) = int:
   first(#simple_roots(x.root_datum), (int i)bool: status(i,x)=2 {real root})

set choose_Cayley (int i,KGBElt x) = KGBElt:
   let y=Cayley(i,x) in
   if torus_bits(y)=torus_bits(x) then y
   else let z=cross(i,y) in
      assert(torus_bits(z)=torus_bits(x),"failure in choose_cayley")
   ;  z
   fi

set move_to_distinguished_fiber (KGBElt x) = (KGBElt,WeylElt):
   (x,id_W(x.root_datum)). { apply following recursive function }
   (rec_fun f(KGBElt x,WeylElt w) (KGBElt,WeylElt):
      if in_distinguished_fiber(x) then (x,w)
      else let (w1,y)=from_no_Cminus(x) then j=find_cayley(y) in
         if j.< then f(y,inverse(w1)*w)
         else f(choose_Cayley(j,y),inverse(w1)*w)
         fi
      fi
   )

set move_to_distinguished_fiber (([int] H,KGBElt x)) = (vec,KGBElt):
   let (y,w)=move_to_distinguished_fiber(x) in (H*inverse(w),y)

set move_to_distinguished_fiber (RealNilpotent O) = RealNilpotent:
   let (H,x,)=O in real_nilpotent(move_to_distinguished_fiber((H,x)))

set stabilizer_of_x (KGBElt x) = [WeylElt]:
   let G=real_form(x) in
   for w in W(G) if cross(w,x)=x do w fi od

{. Given a real group G and a list of simple roots determining a standard
   complex Levi MC, make a list of real forms of MC in G. .}
set viable_Levis (RealForm G,[int] S) = [RealForm]:
   for P in parabolics_with_theta_stable_Levi(G,S) do Levi(P) od

{. Given a real form G, a coweight H which determines a complex nilpotent
   orbit OC, distinguished in the Levi MC, find all KGB elements x so that
   (H,x,) is a real form of OC. M is a real form of MC in G, and MC is
   determined by the simple roots S. H must be the conjugate determined
   by MC. .}
set test_real_orbit (RealForm G,[int] H, RealForm M, [int] S) = [KGBElt]:
   for x_M in KGB(M)
   do let P_L=Parabolic:(simple_roots_from_coweight(root_datum(M),H),x_M)
   in if is_parabolic_theta_stable(P_L) and x_M=x_min(P_L) else []
      then
         let MC=complex_Levi(G,S), theta=involution(x_M)
         then dim_center=rank(lie_compact_radical(inner_class(MC,theta)))
         , number_roots =
            for alpha in posroots(M)
            do if is_noncompact_imaginary(alpha,x_M) and H*alpha=2 then 1
               elif is_complex(alpha,x_M) and H*alpha=2 then /2 { with 2/2=1 }
               else 0
               fi
            od.sum
      in if dimension(K_0(Levi_of_orbit(real_nilpotent(H,x_M))))
           =dim_center+number_roots
         do embed_KGB(x_M,G)
         fi
      fi
   od.##

{. Given G and a coweight H, find all x so that (H_nd,x,) is a real
   nilpotent orbit. Here H_nd is the conjugate of H corresponding to
   the associated Bala-Carter Levi M. There may be duplications of
   orbits. .}
set all_real_nilpotent_orbit_KGBs (RealForm G,[int] H) = [KGBElt]:
   let (S,K)=Levi_of_H(H,G) then Levis=viable_Levis(G,S) in
   for M in Levis do test_real_orbit(G,K,M,S) od.##

set is_conjugate_orbit (RealNilpotent O,RealNilpotent P) = bool:
   assert(O.real_form=P.real_form);
   let (H,x,)=move_to_distinguished_fiber(O)
   ,   (K,y,)=move_to_distinguished_fiber(P)
   then L=K*inverse(cross_divide(x,y))
   in any(for w in stabilizer_of_x(x) do L*w=H od)

{. Replace (H,x) with equivalent (H',x') with H' dominant. .}
set dominant (RealNilpotent(H,x,):O) = RealNilpotent:
   let (H_dom,w)=from_dominant(H,O.real_form)
   then O_dom=real_nilpotent(H_dom,cross(w,x))
in {=(H*inverse(w), cross(w,x))}
   assert(is_conjugate_orbit(O_dom,O),"dominant(orbit) failed");
   O_dom

set find_conjugate ([RealNilpotent] list,RealNilpotent O) = int:
   first(#list,(int i)bool: list[i].root_datum=O.root_datum and
                            is_conjugate_orbit(list[i],O))

{. Remove duplications (conjugates) from the list of
   all_real_nilpotent_orbit_KGBs. .}
set real_nilpotent_orbit_KGBs (RealForm G,vec H) = [KGBElt]:
   let result=[KGBElt]:[] { need access to result to eliminate conjugates }
in for x in all_real_nilpotent_orbit_KGBs(G,H)
   do if for y in result
         do is_conjugate_orbit(real_nilpotent(H,x),real_nilpotent(H,y))
         od.none
      then result#:=x fi
   od; result

{. Auxiliary function. .}
set real_nilpotent_orbit_KGPs (RealForm G,vec H) = [KGPElt]:
   if =H then [parabolic_by_cwt(H,KGB(G,0))]
   else let result=[KGPElt]:[] { need access to eliminate repetition } in
      for x in all_real_nilpotent_orbit_KGBs(G,H)
      do let P=parabolic_of_orbit(real_nilpotent(H,x)) in
         if for Q in result do P=Q od.none then result#:=P fi
      od
   ;  result
   fi

{. Make a list of all real nilpotent orbits (H,x,) of G with
   H dominant and x in the distinguished fiber. .}
set real_nilpotent_orbits (RealForm G) = [RealNilpotent]:
   for H in all_H_nd(G)
   do let K=dominant(H,root_datum(G))
   in for P in real_nilpotent_orbit_KGPs(G,H) do real_nilpotent(K,x_min(P)) od
   od.##.sort_by_dimension

{. Make a list of the real forms of a given complex nilpotent orbit. .}
set real_nilpotent_orbits (ComplexNilpotent (rd,,H):OC,RealForm G) =
      [RealNilpotent]:
   let (,K)=Levi_of_H(H,rd) in
   for P in real_nilpotent_orbit_KGPs(G,K)
   do real_nilpotent(dominant(K,rd),x_min(P))
   od

set minimal_real_nilpotent_orbits (RealForm G) = [RealNilpotent]:
   real_nilpotent_orbits(minimal_nilpotent_orbit(G.root_datum),G)

set make_dominant_H (RealNilpotent (H,x,):O) = RealNilpotent:
   real_nilpotent(dominant(H,root_datum(x)),x_min(parabolic_of_orbit(O)))

{. Given a real nilpotent orbit, find all real Levi subgroups M so
   that the orbit has an element that is distinguished in M. There
   may be duplications. .}
set Levis_with_distinguished_orbit (RealNilpotent (H,x,):O) =
       [(vec,KGBElt),RealForm]:
   let G=x.real_form then (S,K)=Levi_of_H(H,G.root_datum) in
   for M in viable_Levis(G,S)
      for y in test_real_orbit(G,K,M,S)
         if is_conjugate_orbit(O,real_nilpotent(K,y))
         do ((K,y),M)
	 fi
      od
   od
