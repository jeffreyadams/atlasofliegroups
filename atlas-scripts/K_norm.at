<all_parameters.at

{----------------norm of K-types------------------}

{K_norm(x,lambda)=
a) \sum |<alpha^v,(1+theta_x)lambda/2>| =

or equivalently

b)  <rho_check,make_dominant((1+theta_x)*lambda)> =
b') <2*rho_check,make_dominant((1+theta_x)*lambda/2)> 

More generally, use b) with rho_check replaced by an arbitrary ratvec v.

Typically L is a Levi factor of G,
and K_norm of an L\cap K type is with respect to v=rho_check(G)
}

set K_norm (RootDatum rd) = (K_Type->int): (K_Type(x,lambda)):
  let (mu,)=make_dominant(rd,(1+involution(x))*lambda)
  in rat_as_int(mu*rho_check(rd) + rho_r(x)*rho_check_r(x)*2) {MODIFIED}

set K_norm (RootDatum rd,K_Type p) = int: K_norm(rd)(p)
set K_norm (RootDatum rd,Param p) =  int: K_norm(rd)(K_type(p))
set K_norm (RootDatum rd,Split s,K_Type p)=int: K_norm(rd)(p)
set K_norm (RootDatum rd,Split s,Param p)=int:  K_norm(rd)(K_type(p))
set K_norm (K_Type p) =int: K_norm(root_datum(p))(p)
set K_norm (Param p)  =int: K_norm(K_type(p))  
set K_norm (Split s,K_Type p) = int: K_norm(p)

{ K_norm of P is the max of K_norm(terms) }
set K_norms (RootDatum rd) = let norm=K_norm(rd) in (K_Type_Pol P) [int]:
  for @p in P do norm(K_type(p)) od

set K_norms (K_Type_Pol P) = [int]: K_norms(root_datum(P)) (P)

set K_norm (RootDatum rd,K_Type_Pol P) = int: let norms=K_norms(rd) in
  if =P then 0 else max(norms(P)) fi

set K_norm (K_Type_Pol P) =int: K_norm(root_datum(P),P)

set leading_terms (RootDatum rd) = let norm=K_norm(rd) in (K_Type_Pol P): K_Type_Pol:
  let max=K_norm(rd,P), result=null_module(real_form(P)) in
  for c@p in P do if norm(K_type(p))=max then result+:=c*p fi od; result

set all_K_norms (RootDatum rd) = let norm=K_norm(rd) in (K_Type_Pol P) [int]:
  sort(for c@p in P do norm(K_type(p)) od)

set all_K_norms(K_Type_Pol P) = [int]: all_K_norms(root_datum(P)) (P)

{ sort [K_Type] by K_norm(v) }
set sort_by_K_norm (RootDatum rd) = ([K_Type] -> [K_Type]): sort_by(K_norm(rd))

set sort_K_Type_Pol_by_K_norm (RootDatum rd) = let norm=K_norm(rd) in
  ([(Split,K_Type)] -> [(Split,K_Type)]): sort_by((Split s,K_Type p):norm(p))

set sort_by_K_norm = ([K_Type] -> [K_Type]): sort_by( K_norm@K_Type )
set sort_by_K_norm = ([(Split,K_Type)] -> [(Split,K_Type)]):
  sort_by( K_norm@(Split,K_Type) )

set print_by_K_norm_short (RootDatum rd) = let norm=K_norm(rd) in (K_Type_Pol P) void:
  let result=sort_K_Type_Pol_by_K_norm(rd)(for c@p in P do (c,K_type(p)) od)
  in for (c,p) in result do prints(split_as_int(c),"*(",#x(p),",",lambda(p),") ", K_norm(rd)(p)) od

set print_by_K_norm (RootDatum rd) = let norm=K_norm(rd) in (K_Type_Pol P) void:
  let result=sort_K_Type_Pol_by_K_norm(rd)(for c@p in P do (c,K_type(p)) od)
  in for (c,p) in result do let (x_hw,lambda_hw)=highest_weight(p) in 
prints(split_as_int(c),"*(",#x(p),",",lambda(p),") ", " (", #x_hw, ",", lambda_hw, ")   ",  K_norm(rd)(p), "   [", dimension(p),"]") od

set print_by_K_norm (RootDatum rd,K_Type_Pol P) = void: print_by_K_norm(rd)(P)

set print_by_K_norm (K_Type_Pol P) = void:
  print_by_K_norm(root_datum(P),P)

set leading_terms (K_Type_Pol P) = K_Type_Pol:
  leading_terms(root_datum(P))(P)

{ all_dominant_norm_less_than(InnerClass rd,ratvec v,int N):
  list gamma dominant in X^* s.t. <gamma,v> <=N
  in applications gamma=(1+theta)lambda
  algorithm:
  set [lambda_1,...,lambda_{m-1}]=fundamental weights(ic)
  set [lambda_m,...,lambda_{n-1}]=coradical_basis(ic)
  [lambda_1,...,lambda_{n-1}] is Z-basis we want
  set [rat]:c =[c_1,...,c_{n-1}] where c_i=<lambda_i,v>
  use cone to find all mu=\sum a_i lambda_i such that <v,mu>=sum a_i*c_i<=N
}

{element of X^* restricted to identity component of the center}
set radical_character(RootDatum rd, vec lambda)=vec:lambda*radical_basis(rd)

set all_dominant_norm_upto (RootDatum rd, ratvec v,int N) =
  mat: { columns are weights }
  let basis = [ratvec]: { rational weights }
         fundamental_weights(rd) ## { concatenate }
         for w in coradical_basis(rd) do ratvec: w od
  , rk=#v, result=[vec]: []
  in
  for cs in cone(N,for col in basis do v*col od) do
    let (v,d) = %sum(for col@i in basis do col*cs[i] od,rk) in
    if d=1 then result #:= v fi
  od; rk { number of rows of matrix returned } # result

{inner class: use only compact_coradical_basis}
set all_dominant_norm_upto (InnerClass ic, ratvec cowt,int N) =
  mat: { columns are weights }
  let rd=root_datum(ic)
  then basis = [ratvec]: { rational weights }
         fundamental_weights(rd) ## { concatenate }
         for w in compact_coradical_basis(ic) do ratvec: w od
  , rk=rank(rd), result=[vec]: []
  in
  for cs in cone(N,for col in basis do cowt*col od) do
    let (v,d) = %sum(for col@i in basis do col*cs[i] od,rk) in
    if d=1 then result #:= v fi
  od; rk { number of rows of matrix returned } # result


{set of representatives of W/W_L, using
 w-> w.rho(u) is a bijection W/W_L -> W-orbit of rho(u)
}
set W_mod_W_L(RootDatum rd_L,RootDatum rd_G)=
let tworho_u=ratvec_as_vec(2*rho(rd_G)-2*rho(rd_L)) in
W_orbit_W_elements(rd_G,tworho_u)

{all W-conjugates of gamma which are L-dominant
 initialize empty list, for each w\in W/W_L add make_dominant(G,w.gamma)
 to the list if new
}
set L_dominant_conjugates(RootDatum rd_L, RootDatum rd_G, vec gamma)=
{let (gamma,)=make_dominant(rd_G,gamma) in} 
let rv=[vec]:[] in
for w in W_mod_W_L(rd_L,rd_G) do let (tau,)=make_dominant(rd_L,act(inverse(w),gamma)) in 
if find(rv,tau)=-1 then rv#:=tau fi  od;rv

{ filter and transform list of mu's into list of example lambda-rho values }
{L=G case}
set lambda_rho_from_dominant_norm_upto (KGBElt x, ratvec v, int N) = mat: {wts}
  let th1=1+involution(x), rho=rho(root_datum(x)), result=[vec]:[] in
  for mu in all_dominant_norm_upto(inner_class(x),v,N)
  do case solve(th1,mu-ratvec_as_vec(th1*rho))   {solution v is lambda-rho \in X^*}
     | no_solution: ()
     | solution(s): result #:= s
     esac
  od; #rho{rank} # result

set lambda_rho_from_dominant_norm_upto (KGBElt x_L, RootDatum rd, ratvec v, int N) = mat:
  let th1=1+involution(x_L), rho=rho(root_datum(x_L)), result=[vec]:[] in
  for mu_G in all_dominant_norm_upto(rd,v,N) do 
   for mu in L_dominant_conjugates(root_datum(x_L), rd, mu_G)
  do case solve(th1,mu-ratvec_as_vec(th1*rho))   {solution v is lambda-rho \in X^*}
     | no_solution: ()
     | solution(s): result #:= s
     esac
od od; #rho{rank} # result

{find (x_L,lambda) so that (1+theta_x)lambda is L-dominant, and
the G-dominant conjugate lambda' of this satisfies <lambda',rho_check(G)><=N
for each such lambda find all (L\cap K)-parameters with the same differential
}

set K_parameters_norm_upto (KGBElt x_L ,InnerClass ic, int N,ratvec v) = [K_Type]:
  let lrs = lambda_rho_from_dominant_norm_upto(x_L,ic,v,N), 
  rho=rho(root_datum(x_L)) 
  in ## for lr in lrs do all_equal_dlambda_K_parameters(x_L,lr+rho)  od

set K_parameters_norm_upto ((KGBElt,InnerClass,int)(x,ic,N):triple) = [K_Type]:
K_parameters_norm_upto(x,ic,N,rho_check(ic))

set K_parameters_norm_upto(RealForm G,InnerClass ic, int N, ratvec v)=
##(for x in ##(for x in KGB(G) do if no_Cminus_roots(x) 
then  [(x)] else [(KGBElt)]:[] fi od) do K_parameters_norm_upto(x,ic,N,v) od)

set K_parameters_norm_upto(RealForm G,InnerClass ic, int N)=K_parameters_norm_upto(G,ic,N,rho_check(ic))


