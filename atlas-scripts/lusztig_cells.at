<geck_generic { for |Springer_table_generic_degrees| }
<restricted_roots.at {for remove_zeros@[vec]}
<nci_nilrad_roots.at {for all_sums@([ratvec])}
<restricted_roots.at {for remove_zeros@[vec]}
<lusztig_cells_new.at

{the Lusztig map goes from triples (O,x,xi) to W^
 this file implements an algorithm (conjectural)
 to implement this when xi=1
 the set obtained for fixed O, running over x,
 is a Lusztig (left) cell
 Note: this used to involve the dual group but this has been changed,
 the dual version will be moved to lusztig_cells_dual.at
}

{sigma_lusztig (used to be sigma_L, the new name is better
sigma_lusztig(O,x) is a of a representation of W(G)
conjecturally it is the same as
Lusztig(O,x,1) as defined in the Orange book

G, O = special orbit for G, x\in A-bar(O)
M=M(A-bar(O)): pairs defined by Lusztig
xi an irreducible representation of Cent_{A-bar(O)}(x)
(O,x,xi)  -- Lusztig -->  W(G)^

generalization of Springer map

(O,1,1) -> Springer(O)  Springer correspondence for G
        -> Springer(O)\otimes sign \in W(G)^
        -> W(G)^ via the isomorphism W(G)\simeq W(G)

More general case:
(O,x,1)  -> L_x=Cent_{G}(x)^0
         -> O_L_x (same H)
         -> Springer(O_L_x)\otimes sgn in W(L_x)^   NOT the same as Sommers: Springer(dual(O_L_x))
	 -> sigma_lusztig_x\in W(L_x) via W(L_x)\simeq W(L_x_v)
	 -> [ no: truncated induction from W(L_x) to W(G)]
         -> induce to W(G) and keep the term(s) with the same degree as sigma_lusztig(O,1,1)

Note: this O_L_x might not be special, so Springer(dual(orbit)) \ne Springer(orbit)*sign

Non-trivial \xi not yet considered
}

set sigma_lusztig_verbose=true

{main algorithm for computing sigma_lusztig, this won't usually be called by the user
 M is a pseudo-Levi
 H_M is (the ss element of) an orbit for M
 exp(2pi i y) is an element of center of M^0
 typically (M,H_M,y) are provided by component_datum@ComplexNilpotent
}
{arguments:
 G given group with its coordinate, need this to compute roots of L in G
 G.ct is needed to compute truncated induction/exchange_long_short
 L.st is needed to compute Springer(O_L)  (L=centralizer of y)
 O: given orbit on the dual side
 M: pseudo-Levi in which exp(2\pi iy) is central
  (this isn't really needed but is helpful information)
 H_M: ss element for orbit of M
 y: x=exp(2\pi iy)
 note that L depends on y
}

{-------------------------------------------------------------------}
{modify to work on the group side:
generalization of Springer map

(O,1,1) -> Springer(O)  Springer correspondence for G  (Springer(0)=sign/Springer(principal)=trivial)

General case:
(O,x,1)  -> L_x=Cent_{G}(x)^0
	 -> O_L_x (same H)
	 -> Springer(O_L_x) in W(L_x)^
	 -> induce from W(L_x) to W(G)
	 -> keep term(s) with generic degree: generic_degree(Springer(O))
}

{returns [(int,int)] = [(index,multiplicity)]
 usually [(j,1)]: meaning only character #j appears with multiplicity 1
 rarely  [(j,1),(k,1)...] : several characters appear with multiplicity 1
 occasionally []: empty
 so far never see mult>0
}

set degree_data(CharacterTable ct,int i)=[int]:
{[i, dim_i, deg_i, gdeg_i, j, dim_j, deg_j, gdeg_j]}
let j=ct.tensor_sign_index(i) in 
[i,dimension(ct,i), ct.degree(i), ct.generic_degree(i),j,dimension(ct,j), ct.degree(j), ct.generic_degree(j)]

set degree_data(CharacterTable ct)=(int->[int]):(int i):degree_data(ct,i)

set sigma_lusztig(RootDatum G, ComplexNilpotent O_M, ComplexNilpotent O_L)=
(ComplexNilpotent,ComplexNilpotent,[int],[int],[[int]],[int],[int],ComplexNilpotent,bool):
let G_vee = G.dual then
st_G_vee = G_vee.Springer_table then
ct_G_vee = st_G_vee.ct then
L=O_L.root_datum then
st_L = L.Springer_table then
is_special=is_special(st_L,O_L) then
O_L_vee = st_L.dual_map(O_L) then
L_vee=dual(L) then
st_L_vee = L_vee.Springer_table then
ct_L_vee=st_L_vee.ct then
sigma_L_vee_index=int:st_L_vee.springer(O_L_vee) then
sigma_L_vee=st_L_vee.ct.character(sigma_L_vee_index) then
embed(WeylElt w) = WeylElt: convert_to(G_vee,w) then
ind_vee_char=induce_character(ct_L_vee.class_table,ct_G_vee.class_table,embed,sigma_L_vee)  then
ind_vee=ct_G_vee.decompose(ind_vee_char) then
ind_vee_data=##for i:#ind_vee do
  if ind_vee[i]>0 then
   [ct_G_vee.degree_data(i)]
  else
   []
  fi
 od then
(min_degree,t_ind_vee)=truncate(ct_G_vee,ind_vee_char,ct_G_vee.degree) then
sigma_G_vee_index=t_ind_vee[0] then
(valid,O_G_vee)=st_G_vee.springer_inverse(sigma_G_vee_index) then
sigma_G_vee_sign_index=ct_G_vee.tensor_sign_index(sigma_G_vee_index) in
if sigma_lusztig_verbose then
 prints("sigma_lusztig: ",new_line,
   "M: ", O_M.root_datum,new_line,
   "O_M: ", O_M.diagram, new_line,

   "O_L_vee: ", O_L_vee.diagram, new_line,
   "sigma_L_vee: ", sigma_L_vee,
   "sigma_L_vee_index: ", sigma_L_vee_index,
   "sigma_G_vee_index: ", sigma_G_vee_index,
   "ind_vee_char: ", ind_vee_char,new_line,
   "ind_vee: ", ind_vee,new_line,
   "ind_vee_data: ", ind_vee_data,new_line,
   "ct_L_vee.degree_data: ",  ct_L_vee.degree_data(sigma_L_vee_index), new_line,
   "ct_G_vee.degree_data: ", ct_G_vee.degree_data(sigma_G_vee_index), new_line,
   "O_G_vee: ", O_G_vee.diagram, new_line,
   "is_special: ", is_special,new_line) fi;
(O_M,O_L,
 ind_vee_char,
 ind_vee,
 ind_vee_data,
 ct_L_vee.degree_data(sigma_L_vee_index),
 ct_G_vee.degree_data(sigma_G_vee_index),
 O_G_vee,
 is_special)

{sigma_lusztig: takes Springer table for G and a ComplexNilpotent for M}
set sigma_lusztig_short(RootDatum G,ComplexNilpotent O_M,ComplexNilpotent O_L) =
let (,,j_values,,,,,,)=sigma_lusztig(G,O_M,O_L) in j_values

{returns array of (O_M,ind,sigma_G_index,O_G_vee,is_special)}
set lusztig_cell (ComplexNilpotent O_G) =
  for (M,H_M,y) in component_representatives_plus(O_G)
  do let ()=
     if sigma_lusztig_verbose
     then prints
       ("------------------------------------------------",new_line,
       "computing sigma_lusztig for orbit", O_G.diagram, new_line
       ,"M=", M, new_line
       ,"H_M=",H_M,new_line
       , "y=", y
       )
     fi
     then L=centralizer(O_G.root_datum,y) 
     then O_M=complex_nilpotent(M,H_M)
     then O_L=complex_nilpotent(L,H_M) in
  sigma_lusztig(O_G.root_datum,O_M,O_L)
od

{include terms coming from deformation}
set lusztig_cell_plus (RootDatum G,ComplexNilpotent O_G) =
let
rv=for (M,H_M,y) in component_representatives_plus(O_G) do
    let O_M=complex_nilpotent(M,H_M) then
    basis=M.radical_basis then
    variants=if =#basis then [null(G.rank)] else all_sums(basis) fi in
    for v in variants do
        let L = centralizer(G,y+v)
        then st_L=L.Springer_table
        then O_L=complex_nilpotent(L,H_M) in
     if sigma_lusztig_verbose
      then prints("y=", y, new_line, "v=",v/(G.coxeter_number+1));
	  prints("lusztig_cell_plus", new_line
         	,"orbit: ", O_G.diagram, basis, new_line
                ,"M=", M, new_line
                ,"O_M=",O_M.diagram,new_line
                ,"y=", y
               ,"L=", L, new_line
               ,"O_L=",O_L.diagram,new_line
		)
     fi;
     sigma_lusztig(G,O_M,O_L)
    od
   od
in rv


set lusztig_cells (RootDatum G,[ComplexNilpotent] orbits_G) =
for orbit in orbits_G do (orbit,lusztig_cell(orbit)) od

set lusztig_cells ([ComplexNilpotent] orbits_G) = lusztig_cells(orbits_G[0].root_datum,orbits_G)
set lusztig_cells(RootDatum G)=lusztig_cells(G,G.orbits)

set lusztig_cells_plus (RootDatum G,[ComplexNilpotent] orbits_G) =
for orbit in orbits_G do (orbit,lusztig_cell_plus(G,orbit)) od

set lusztig_cells_plus([ComplexNilpotent] orbits_G) =lusztig_cells_plus(orbits_G[0].root_datum,orbits_G)
set lusztig_cells_plus(RootDatum G)=lusztig_cells_plus(G,G.orbits)


{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells(RootDatum G,[ComplexNilpotent] orbits, bool strict) = 
let table =
##for (orbit,data)@k in lusztig_cells(G,orbits) do
   for (O_M,
        O_L,
        ind_vee_char,
        ind_vee,
        ind_vee_data,
        ct_M_vee_degree_data,
        ct_G_vee_degree_data,
        O_G_vee,
        is_special) in data do
  if =#ind_vee
   then { even if there are no |ind|, build one [string] }
    [[[[orbit.diagram.to_string
    ,orbit.dim_nilpotent.to_string
    ,k.to_string
    ,integrality_datum(orbit).nice_format
    ,O_M.root_datum.nice_format
    ,O_M.diagram.to_string
    ,O_L.root_datum.nice_format
    ,O_L.diagram.to_string
    ,"[]"
    ,"x"
    ,"x"
    ,"x"
    ,"x"
    ,"x"
    ,"x"
    ,"x"
    ]]]]
   else
    for d in ind_vee_data do
    {[i, dim_i, deg_i, gdeg_i, j, dim_j, deg_j, gdeg_j]  i=index of G^v rep, j=index of i\otimes sign}
     let i=d[0], j=d[4] in
     let star= if d[2]=ct_M_vee_degree_data[2] then "*" else " " fi in
     let plus= if d[3]=ct_M_vee_degree_data[3] then "+" else " " fi in
     if  (not strict ) then
       [[[orbit.diagram.to_string
       ,orbit.dim_nilpotent.to_string
       ,k.to_string
       ,integrality_datum(orbit).nice_format
       ,O_M.root_datum.nice_format
       ,O_M.diagram.to_string
       ,O_L.root_datum.nice_format
       ,O_L.diagram.to_string
       ,is_special.to_string
       ,i.to_string
       ,ct_M_vee_degree_data[1].to_string
       ,ct_M_vee_degree_data[2].to_string + star
       ,ct_M_vee_degree_data[3].to_string + plus
       ,i.to_string + " " + d[1].to_string + " " + d[2].to_string + " " + d[3].to_string
       ,j.to_string + " " + d[5].to_string + " " + d[6].to_string + " " + d[7].to_string + " " + star + plus
      ]]] else [[[string]]]:[]
     fi{/if not strict)}
    od{/for ind_vee_data}
  fi{=#ind}
 od.##.##{/for (O_M,...)}
od.##{/for i:#data}
then
table_header=
[["O_M","",""
    ,""
    ,"","",""
    ,"diag"
    ,""
    ,"M_v"
    ,"M_v"
    ,"M_v"
    ,"M_v"
    ,"G_v"
    ,"xsgn"
    ],
    ["diag"
    ,"dim"
    ,"i"
    ,"int"
    ,"M_v"
    ,"O_M_v"
    ,"L_v"
    ,"O_L_v"
    ,"special"
    ,"rep"
    ,"dim"
    ,"deg"
    ,"gdeg"
    ,"i D d gd"
    ,"i D d gd"
    ]]
    in
prints("===================================================================",new_line,"G=", G.nice_format, new_line, "#orbits: ", #orbits);
prints("i D d gd:  index of W-rep, Dimension, degree, generic degree",new_line,\
"G_v: representation of G_v, factor if induced of lowest degree",new_line,\
"xsgn: previous, tensored with sign");
tabulate(table_header##table)

set show_lusztig_cells(RootDatum G)=show_lusztig_cells(G,G.orbits,false)
set show_lusztig_cell(ComplexNilpotent orbit,bool strict)=show_lusztig_cells(orbit.root_datum,[orbit],strict)
set show_lusztig_cell(ComplexNilpotent orbit)=show_lusztig_cell(orbit,false)




set show_lusztig_cell_new(ComplexNilpotent orbit)=
show_lusztig_cell_new(orbit.root_datum.Springer_table,orbit)

{
set sigma_lusztig_data(RootDatum G, ComplexNilpotent O_M)=
let G_vee = G.dual then
st_G_vee = G_vee.Springer_table then
ct_G_vee = st_G_vee.ct then
M=O_M.root_datum then
st_M = M.Springer_table then
is_special=is_special(st_M,O_M) then
O_M_vee = st_M.dual_map(O_M) then
M_vee=dual(M) then
st_M_vee = M_vee.Springer_table then
ct_M_vee=st_M_vee.ct then
sigma_M_vee_index=int:st_M_vee.springer(O_M_vee) then
sigma_M_vee=st_M_vee.ct.character(sigma_M_vee_index) then
embed(WeylElt w) = WeylElt: convert_to(G_vee,w) then
ind_vee_char=induce_character(ct_M_vee.class_table,ct_G_vee.class_table,embed@WeylElt,sigma_M_vee)  then
ind_vee=ct_G_vee.decompose(ind_vee_char) then
ind_vee_data=##for i:#ind_vee do
  if ind_vee[i]>0 then
   [ct_G_vee.degree_data(i)]
  else
   []
  fi
 od in
 (O_M,O_M_vee,sigma_M_vee_index,sigma_M_vee,ind_vee_char,ind_vee,ind_vee_data,embed)

set sigma_lusztig_new_data(SpringerTable st_G, RootDatum M, vec H_M) =
(RootDatum,vec,int,ComplexNilpotent):
    {returns (M,H_M,index in char table(G) of desired
    W rep, nilpotent in G_vee)}
let G = st_G.root_datum, ct_G = st_G.ct
then O_M=ComplexNilpotent:(M,(),H_M), G_vee = G.dual
then st_G_vee = G_vee.Springer_table
then st_M = M.Springer_table, ct_G_vee = st_G_vee.ct
then () = assert(is_special(st_M,O_M),
"in sigma_lusztig_even, "+O_M.diagram.to_string+" is not special for "+M.nice_format)
then st_M = M.Springer_table, M_vee = dual(M)
then st_M_vee = M_vee.Springer_table, O_M_vee =
	     st_M.dual_map(O_M)
then ()=if sigma_lusztig_new_verbose then
  prints("O_M_vee: ", O_M_vee, new_line,"sigma_M_vee: ", st_M.ct.character(st_M_vee.springer(O_M_vee))) fi
then O_G_vee = induce_orbit(st_M_vee, st_G_vee,O_M_vee)
then sigma_G_vee_num = st_G_vee.springer(O_G_vee)
ind_vee_char=induce_character(ct_M_vee.class_table,ct_G_vee.class_table,embed,sigma_M_vee)  then
ind_vee=ct_G_vee.decompose(ind_vee_char) then
ind_vee_data=##for i:#ind_vee do
  if ind_vee[i]>0 then
   [ct_G_vee.degree_data(i)]
  else
   []
  fi
 od in
 (O_M,O_M_vee,sigma_G_vee_num,x,ind_vee_char,ind_vee,ind_vee_data,
}
{


{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells_plus\
   (SpringerTable st_G,[ComplexNilpotent] orbits) = void:
   let G=st_G.root_datum in 
   prints("G=", G.nice_format, new_line, "#orbits: ", #orbits);
let table_header =
    ["O","dim","i","rd_int","M","H_M","y","v","L","ind"
    ,"sp_L","deg_L","special","dim","deg","gdeg","char=ct.character(sigma[0])"
    ]
, table = [ [string] ]: { concatenation of all [string] values from |data| }
   for data@i in lusztig_cells_plus({G,}st_G,orbits) {[[(M,H_M,y,values)]]}
   do for (orbit,M,H_M,y,v,values) in data
      do if =#values
         then { even if there are no |values|, build one [string] }
	    [[orbit.diagram.to_string + st_G.special_star(orbit)
	    ,orbit.dim_nilpotent.to_string
	    ,i.to_string
	    ,integrality_datum(orbit).nice_format
	    ,M.nice_format
	    ,H_M.compact_string
            ,""
	    ,y.compact_string
	    ,v.compact_string
	    ,centralizer(G,y).nice_format
	    ,"[]"
	    ,"x"
	    ,"x"
	    ,"x"
	    ,"x"
	    ,"x"
	    ]]
	 else
            let L=centralizer(G,(y+v)/(coxeter_number(G)+1)) then
            O_L=complex_nilpotent(L,H_M) then
            st_L=Springer_table(L) then
            sigma_L=st_L.springer(O_L) in
	    for k in values do
	    [orbit.diagram.to_string + st_G.special_star(orbit)
	    ,orbit.dim_nilpotent.to_string
	    ,i.to_string
	    ,integrality_datum(orbit).nice_format
	    ,M.nice_format
	    ,H_M.compact_string
	    ,y.compact_string
	    ,v.compact_string
	    ,L.nice_format
	    ,if #values=1 then k.to_string
	     else values.to_string + ":" + k.to_string
	     fi
            ,if is_special(st_L,O_L) then "*" else "" fi
            ,sigma_L.to_string + "/" + st_L.ct.degree(sigma_L).to_string
            ,if =y then st_G.ct.special(st_G.springer(orbit)).to_string else "" fi
	    ,dimension(st_G.ct,k).to_string
	    ,st_G.ct.degree(k).to_string
      	    ,st_G.ct.generic_degree(k).to_string
	    ,st_G.ct.character(k).to_string
	    ]
	    od {for k in values}
	 fi
      od.## { for (...) in data }
   od.##{for data in Lusztig_cells }
in tabulate(table_header#table)

{some shorthands which are handy but sometimes inefficient}
set lusztig_cell (RootDatum G,ComplexNilpotent O) = [[int]]:
    lusztig_cell({G,}G.Springer_table,O)

set show_lusztig_cells ({RootDatum G,}SpringerTable st_G) = void:
   show_lusztig_cells({G,}st_G,st_G.root_datum.orbits)

set show_lusztig_cells_plus (RootDatum G,SpringerTable st_G) = void:
   show_lusztig_cells_plus({G,}st_G,G.orbits)

set show_lusztig_cells(RootDatum G) = void:
   let st=Springer_table(G) in show_lusztig_cells({G,}st)

set show_lusztig_cells_plus (RootDatum G) = void:
   let st=Springer_table(G) in show_lusztig_cells_plus(G,st)

set A_bar(SpringerTable st,ComplexNilpotent O)=([int],[[RootDatum]]):
let data=lusztig_cell_long(st,O) then
sigmas=(##for (,,,j_values) in data do if =#j_values then [] else [j_values[0]] fi od).sort_u in
(sigmas,
 for i:#sigmas do
  ##for (M,,,j_values) in data do
    if #j_values>0 and sigmas[i]=j_values[0] then [M] else [] fi
 od
od)

set A_bar(SpringerTable st)=(ComplexNilpotent ->([int],[[RootDatum]])):(ComplexNilpotent O):A_bar(st,O)


set show_A_bar([int] sigmas,[[RootDatum]] pseudolevis)=void:
for i:#sigmas do
 let str="" in
  for M in pseudolevis[i] do str+:=" " + nice_format(M) od
 ;prints(sigmas[i],str)
od

set show_A_bar(SpringerTable st,ComplexNilpotent orbit)=void:
let (sigmas,pseudolevis)=A_bar(st,orbit) in
prints("orbit: ", orbit.diagram);
for i:#sigmas do prints(sigmas[i], " ", #pseudolevis[i]) od;
prints(sigmas.to_string +
##for i:#sigmas do
 let str="" in
  for M in pseudolevis[i] do str+:=" " + nice_format(M) od
 ;"  " +sigmas[i].to_string + str
od)


{four inner products stuff moved to inner_products.at}
{---------------------------------------------------------------------------}
{stuff that used to be in lusztig_cells_complete.at}
{these generic versions are no longer needed:


{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells_generic\
   (RootDatum G,SpringerTable st_G,[ComplexNilpotent] orbits) = void:
  (new_line
  ,"Lusztig cells",new_line
  ,"G=", G.nice_format, new_line
  , "#orbits: ", #orbits
  ).prints;
let table = [ [string] ]: { concatenation of all [string] values from |data| }
    for data@i in lusztig_cells(G,st_G,orbits) {[[(M,H_M,y,values)]]}
    do for (orbit,M,H_M,y,values) in data
       do
          if =#values
	  then { even if there are no |values|, build one [string] }
	     [[orbit.diagram.to_string + st_G.special_star(orbit)
	     ,orbit.dim_nilpotent.to_string
	     ,i.to_string
	     ,integrality_datum(orbit).nice_format
	     ,M.nice_format
	     ,H_M.compact_string
	     ,y.compact_string
	     ,centralizer(G,y).nice_format
	     ,"[]"
	     ,"x"
	     ,"x"
	     ,"x"
	     ,"x"
	     ,"x"
	     ]]
	  else { contribute one or more [string] values }
	     for k in values
	     do
	     [orbit.diagram.to_string + st_G.special_star(orbit)
	     ,orbit.dim_nilpotent.to_string
	     ,i.to_string
	     ,integrality_datum(orbit).nice_format
	     ,M.nice_format
	     ,H_M.compact_string
	     ,y.compact_string
	     ,centralizer(G,y).nice_format
	     ,if #values=1 then k.to_string { mention unique |k| }
	      else values.to_string + ":" + k.to_string { mention |k| from list }
	      fi
	     ,if =y then st_G.ct.special(st_G.springer(orbit)).to_string else "" fi
	     ,dimension(st_G.ct,k).to_string
	     ,st_G.ct.degree(k).to_string
	     ,st_G.ct.generic_degree(k).to_string
	     ,st_G.ct.character(k).to_string
	     ]
	     od {for k in values}
	  fi
       od.## { for (...) in data }
    od.## {for data in Lusztig_cells }
in
( ["O"
  ,"dim"
  ,"i"
  ,"rd_int"
  ,"M"
  ,"H_M"
  ,"special_M"
  ,"v"
  ,"L"
  ,"sigma"
  ,"special"
  ,"dim"
  ,"deg"
  ,"gdeg"
  ,"char=ct.character(sigma[0])"
  ]
# table
).tabulate

set show_lusztig_cells_generic_long\
   (RootDatum G,SpringerTable st_G,[ComplexNilpotent] orbits) = void:
   show_very_long(st_G.ct);
   show_long(st_G);
   show_lusztig_cells_generic(G,st_G,orbits)

set show_lusztig_cells_generic (RootDatum G,SpringerTable st_G) = void:
   show_lusztig_cells_generic(G,st_G,G.orbits)

set show_lusztig_cells_generic_long (RootDatum G,SpringerTable st_G) = void:
   show_lusztig_cells_generic_long(G,st_G,G.orbits)

set show_lusztig_cells_generic (RootDatum G) = void:
let st=Springer_table_generic_degrees(G)
in show_lusztig_cells_generic(G,G.Springer_table)

set show_lusztig_cells_generic_long (RootDatum G) = void:
let st=Springer_table_generic_degrees(G)
in show_lusztig_cells_generic_long(G,st)
}

