{the Lusztig map goes from triples (O^v,x,xi) to W^
 this file implements an algorithm (conjectural)
 to implement this when xi=1
 the set obtained for fixed O^v, running over x,
 is a Lusztig (left) cell
}
<coherent_characters.at
<isomorphism_W.at
<truncated_induction.at
<springer_tables_reductive.at

{sigma_L (L stands for "Lusztig")
sigma_L(O^v,x) is a of a representation of W(G)
conjecturally it is the same as
Lusztig(O^v,x,1) as defined in the Orange book, this also
}

{G G^v, O^v = special orbit for G^vee, x\in A-bar(O^v)
M=M(A-bar(O^v)): pairs defined by Lusztig
xi an irreducible representation of Cent_{A-bar(O^v)}(x)
(O^v,x,xi)  -- Lusztig -->  W(G)^

generalization of Springer map

(O^v,1,1) -> Springer(O^v)  Springer corresdponence for G^v
          -> Springer(O^v)\otimes sign \in W(G^v)^
	  -> W(G)^ via the isomorphism W(G^v)\simeq W(G)

More general case:
(O^v,x,1)  -> L_x^v=Cent_{G^v}(x)^0
	   -> O_L_x^v (same H)
	   -> Springer(O_L_x^v)\otimes sgn in W(L_x^v)^
	   -> sigma_L_x\in W(L_x) via W(L_x)^v\simeq W(L_x_v)
	   -> truncated induction from W(L_x) to W(G)

Note: this O_L_x^v might not be special, so Springer(dual(orbit)) \ne Springer(orbit)*sign

Non-trivial \xi not yet considered
}

{Example: O^v=0-orbit, x=1
L_x_v=G_v, O_L_x_v=0-orbit of G^v
Springer(O_L_x_v)=sign of W(G^)
\otimes sgn=trivial of
}
set sigma_L_verbose=false

{main algorithm for computing sigma_L, this won't usually be called by the user
 M_v is a pseudo-Levi
 H_M_v is (the ss element of) an orbit for M_v
 exp(2pi i y) is an element of center of M^0
 typically (M_v,H_M_v,y) are provided by component_datum@ComplexNilpotent
}
{arguments:
 G given group with its coordinate, need this to compute roots of L in G
 G.ct is needed to compute truncated induction/exchange_long_short
 G_L_v.st is needed to compute Springer(O_L_v)
 O_v: given orbit on the dual side
 M_v: pseudo-Levi in which exp(2\pi iy) is central
  (this isn't really needed but is helpful information)
 H_M_v: ss element for orbit of M_v
 y: x=exp(2\pi iy)
 note that L_v depends on y
}
set sigma_L(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v,RootDatum M_v,vec H_M_v,ratvec y)=int:
let ()=if sigma_L_verbose then
   prints("Computing sigma_L: ",new_line,
   "G=", G, "st_G_v: ",new_line, st_G_v.root_datum, new_line,"M_v=", M_v, new_line, "H_M_v=",H_M_v,new_line,"y=", y) fi
in if y.is_integer then  {L_v=G_v, L=G, don't need induction}
 let ()=if sigma_L_verbose then prints("y is integer, no induction")  fi then
 sigma_v=st_G_v.ct.characters[st_G_v.springer(O_v)] then
 sigma= exchange_long_short(ct_G,st_G_v.ct.tensor_sign(sigma_v)) in
 ct_G.character_index(sigma)
else  {need induction; compute L, sigma_L, truncated_induce}
 let ()=if sigma_L_verbose then prints("need induction: ")  fi in
 let G_v=O_v.root_datum then
 ()=if sigma_L_verbose then prints(("y=",y) ) fi then
 L_v=centralizer(G_v,y) then
 ()=if sigma_L_verbose then prints(("L_v=",L_v, new_line, "G_v=", G_v) ) fi then
 {O_M_v=ComplexNilpotent:(M_v,(),H_M_v) -> saturation -> O_L_v
  O_L_v has the same H=H_M_v, but made L_v-dominant}
 H_L_v=dominant(H_M_v,L_v) then
 O_L_v=ComplexNilpotent:(L_v,(),H_L_v) then
 ()=if sigma_L_verbose
   then prints(("L_v=", L_v,new_line,"H_L_v=", H_L_v,new_line,"O_L_v:", O_L_v.H, " ", O_L_v.diagram) ) fi then
 L=dual(L_v) then
 roots_L=for alpha in L.simple_roots do find(G.roots,alpha) od then
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
 sigma_L=
 if O_L_v=L_v.zero_orbit then L.character_table.trivial
 elif O_L_v=L_v.principal_orbit then L.character_table.sign
 else  {not 0 or principal orbit: need to compute L.springer_table}
  let ()=if sigma_L_verbose then prints(("computing st_L:") ) fi then
  st_L_v=L_v.springer_table then
  ()=if sigma_L_verbose then prints(("done computing L.springer_table") ) fi then
  sigma_L_v=st_L_v.springer(O_L_v) then
  char=st_L_v.ct.characters[sigma_L_v] then
  sigma_L_0=st_L_v.ct.tensor_sign(char) in
  exchange_long_short(L_v.character_table,sigma_L_0)
 fi  {end if O_L_v=L_v.zero_orbit} then
 (ignore_degree,char_indices)=truncate_induce_character(G,ct_G,roots_L,sigma_L) then
 ()=if sigma_L_verbose then prints("truncated inducex: ", "G=",G,new_line,"roots_L: ", roots_L, " ", sigma_L) fi then
  char=ct_G.characters[char_indices[0]] then
  ()=if sigma_L_verbose then prints("character of L: ", char_indices[0], new_line, char) fi in
  ct_G.character_index(char)
fi

{run over all ratvecs from component_representatives(orbit)}
set lusztig_cell(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v)=[int]:
prints("sigma_L for: ", O_v,"  ", O_v.diagram,new_line, " st_G_v:",st_G_v.root_datum);
for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
 let ()=if sigma_L_verbose then prints(new_line,"computing sigma_L for M_v=", M_v, new_line,"H_M_v=",H_M_v,new_line, "y=", y)  fi in
    let ()=if sigma_L_verbose then prints("calling sigma_L(x):", new_line,"G: ", G, new_line,
   "st:", st_G_v.root_datum, new_line,"M_v: ", M_v, new_line, "H_M_v", H_M_v, new_line, "y: ", y) fi in 
 sigma_L(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) od

set lusztig_cell(RootDatum G,ComplexNilpotent O_v)=[int]:lusztig_cell(G,G.character_table,O_v.root_datum.springer_table,O_v)
set lusztig_cell(RootDatum G,ComplexNilpotent O_v)=[int]:lusztig_cell(G,G.character_table,O_v.root_datum.springer_table,O_v)
set lusztig_cell(RootDatum G,ComplexNilpotent O_v)=[int]:lusztig_cell(G,G.character_table,O_v.root_datum.springer_table,O_v)
set lusztig_cell(RootDatum G,CharacterTable ct_G,ComplexNilpotent O_v)=[int]:lusztig_cell(G,ct_G,G.dual.springer_table,O_v)
set lusztig_cells(RootDatum G,[ComplexNilpotent] dual_orbits)=[[int]]:
 for orbit in dual_orbits do lusztig_cell(G,G.character_table,orbit.root_datum.springer_table,orbit) od
set lusztig_cells(RootDatum G)=[[int]]:lusztig_cells(G,G.dual_orbits)

set show_lusztig_cells(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
prints("G=", G.nice_format, new_line, "#orbits: ", #dual_orbits);
tabulate(
["O","dim","i","rd_int","M","H_M","v","L","sigma","dim","deg","char"]#
##for O_v@counter in dual_orbits do
  let ()=prints("orbit ",counter,": ", O_v.root_datum.nice_format,
        " H=", O_v.H, " diagram=", O_v.diagram, " normalized diagram=", O_v.diagram_normalized) in
  let data=
  for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
    let j=sigma_L(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) in (M_v,H_M_v,y,j)
  od
  in
  for i:#data do
   let (M_v,H_M_v,y,j)=data[i] then
   sigma=ct_G.characters[j] in
   [O_v.diagram.to_string,
    O_v.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(O_v).nice_format,
    M_v.nice_format,
    H_M_v.compact_ratvec,
    y.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma="+j.to_string,
    ct_G.dimension(j).to_string,
    ct_G.degrees[j].to_string,
    sigma.to_string]
  od  {/for i:#data}
 od {for O_v})

set show_lusztig_cell(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent dual_orbit)=void:
 show_lusztig_cells(G,ct_G,st_G_v,[dual_orbit])
set show_lusztig_cell(RootDatum G, CharacterTable ct_G,ComplexNilpotent O_v)=void:show_lusztig_cell(G,ct_G,G.dual.springer_table,O_v)
set show_lusztig_cell(RootDatum G, ComplexNilpotent O_v)=void:show_lusztig_cell(G,G.character_table,G.dual.springer_table,O_v)
set show_lusztig_cell(ComplexNilpotent O_v)=void:show_lusztig_cell(O_v.root_datum.dual,O_v)

set show_lusztig_cells(RootDatum G,CharacterTable ct)=void:show_lusztig_cells(G,ct,G.dual.springer_table,G.dual_orbits)
set show_lusztig_cells(RootDatum G)=void:show_lusztig_cells(G,G.character_table,G.dual.springer_table,G.dual_orbits)


set init(RootDatum G)=(CharacterTable,SpringerTable,[ComplexNilpotent]):(G.character_table,G.dual.springer_table,G.dual.orbits)

set f(RealForm G,CharacterTable ct_G,[Param] parameters,ComplexNilpotent O_v)=
let coh=character_coherent(ct_G,parameters) then
lusztig_cell=lusztig_cell(G,ct_G,O_v)
then lusztig_cell_character=sum(for i in lusztig_cell do ct_G.characters[i] od) in
ct_G.inner_product(coh,lusztig_cell_character)

set g(RealForm G,CharacterTable ct_G,[Param] parameters,[ComplexNilpotent] orbits)=
let sizes=for orbit in orbits do f(G,ct_G,parameters,orbit) od in
tabulate(["orbit","#reps"]#
 for orbit@i in orbits do [orbit.diagram.to_string,sizes[i].to_string] od)

set dual_special_orbits(RealForm G,SpringerTable st_G_v)=
##for a in G.dual_orbits do if st_G_v.is_special(a) then [a] else [] fi od

set dual_special_orbits(RealForm G)=dual_special_orbits(G,G.dual.springer_table)

set g(RealForm G,CharacterTable ct_G,[Param] parameters)=g(G,ct_G,parameters,G.dual_special_orbits)

set g(RealForm G)=
g(G,G.character_table,all_parameters_gamma(G,rho(G)),G.dual_special_orbits)
