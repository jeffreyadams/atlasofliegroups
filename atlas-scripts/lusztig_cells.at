<geck_generic { for |Springer_table_generic_degrees| }
<restricted_roots.at {for remove_zeros@[vec]}
<nci_nilrad_roots.at {for all_sums@([ratvec])}
<restricted_roots.at {for remove_zeros@[vec]}

{the Lusztig map goes from triples (O,x,xi) to W^
 this file implements an algorithm (conjectural)
 to implement this when xi=1
 the set obtained for fixed O, running over x,
 is a Lusztig (left) cell
 Note: this used to involve the dual group but this has been changed,
 the dual version will be moved to lusztig_cells_dual.at
}

{sigma_lusztig (used to be sigma_L, the new name is better
sigma_lusztig(O,x) is a of a representation of W(G)
conjecturally it is the same as
Lusztig(O,x,1) as defined in the Orange book

G, O = special orbit for G, x\in A-bar(O)
M=M(A-bar(O)): pairs defined by Lusztig
xi an irreducible representation of Cent_{A-bar(O)}(x)
(O,x,xi)  -- Lusztig -->  W(G)^

generalization of Springer map

(O,1,1) -> Springer(O)  Springer correspondence for G
        -> Springer(O)\otimes sign \in W(G)^
        -> W(G)^ via the isomorphism W(G)\simeq W(G)

More general case:
(O,x,1)  -> L_x=Cent_{G}(x)^0
         -> O_L_x (same H)
         -> Springer(O_L_x)\otimes sgn in W(L_x)^   NOT the same as Sommers: Springer(dual(O_L_x))
	 -> sigma_lusztig_x\in W(L_x) via W(L_x)\simeq W(L_x_v)
	 -> [ no: truncated induction from W(L_x) to W(G)]
         -> induce to W(G) and keep the term(s) with the same degree as sigma_lusztig(O,1,1)

Note: this O_L_x might not be special, so Springer(dual(orbit)) \ne Springer(orbit)*sign

Non-trivial \xi not yet considered
}

set sigma_lusztig_verbose=false

{main algorithm for computing sigma_lusztig, this won't usually be called by the user
 M is a pseudo-Levi
 H_M is (the ss element of) an orbit for M
 exp(2pi i y) is an element of center of M^0
 typically (M,H_M,y) are provided by component_datum@ComplexNilpotent
}
{arguments:
 G given group with its coordinate, need this to compute roots of L in G
 G.ct is needed to compute truncated induction/exchange_long_short
 L.st is needed to compute Springer(O_L)  (L=centralizer of y)
 O: given orbit on the dual side
 M: pseudo-Levi in which exp(2\pi iy) is central
  (this isn't really needed but is helpful information)
 H_M: ss element for orbit of M
 y: x=exp(2\pi iy)
 note that L depends on y
}

{-------------------------------------------------------------------}
{modify to work on the group side:
generalization of Springer map

(O,1,1) -> Springer(O)  Springer correspondence for G  (Springer(0)=sign/Springer(principal)=trivial)

General case:
(O,x,1)  -> L_x=Cent_{G}(x)^0
	 -> O_L_x (same H)
	 -> Springer(O_L_x) in W(L_x)^
	 -> induce from W(L_x) to W(G)
	 -> keep term(s) with generic degree: generic_degree(Springer(O))
}

{returns [(int,int)] = [(index,multiplicity)]
 usually [(j,1)]: meaning only character #j appears with multiplicity 1
 rarely  [(j,1),(k,1)...] : several characters appear with multiplicity 1
 occasionally []: empty
 so far never see mult>0
}

set sigma_lusztig_long(SpringerTable st_G, ComplexNilpotent O_M)=
(ComplexNilpotent,[int],int,ComplexNilpotent,bool):
{(O_M,ind,sigma_G_index,O_G_vee,is_special)}
let G = st_G.root_datum then
G_vee = G.dual then
ct_G = st_G.ct then
st_G_vee = G_vee.Springer_table then
ct_G_vee = st_G_vee.ct then
M=O_M.root_datum then
H_M=O_M.H then
st_M = M.Springer_table then
ct_M = st_M.ct then
M_vee = dual(M) then
st_M_vee = M_vee.Springer_table then
ct_M_vee=st_M_vee.ct then
O_M=complex_nilpotent(M,H_M) then
sigma_M_index=st_M.springer(O_M) then
sigma_M = [int]: ct_M.character(sigma_M_index) then
is_special=is_special(st_M,O_M) then
O_M_vee = st_M.dual_map(O_M) then
sigma_M_vee=st_M_vee.springer(O_M_vee) then
embed(WeylElt w) = WeylElt: convert_to(ct_G.root_datum,w) then
ind=induce_character(ct_M_vee.class_table,ct_G_vee.class_table,embed,sigma_M)  then
(,t_ind)=truncate(ct_G,ind,ct_G.degree) then
sigma_G_vee_index=t_ind[0] then
(valid,O_G_vee)=st_G_vee.springer_inverse(sigma_G_vee_index) then
sigma_G_index=ct_G.tensor_sign_index(sigma_G_vee_index) in
(O_M,ind,sigma_G_index,O_G_vee,is_special)

{sigma_lusztig: takes Springer table for G and a ComplexNilpotent for M}
set sigma_lusztig(SpringerTable st_G,ComplexNilpotent O_M) =[int]:
let (,j_values,,,)=sigma_lusztig_long(st_G,O_M) in j_values

{returns array of (O_M,ind,sigma_G_index,O_G_vee,is_special)}
set lusztig_cell (SpringerTable st_G,ComplexNilpotent O_G) =[(ComplexNilpotent,[int],int,ComplexNilpotent,bool)]:
  for (M,H_M,y) in component_representatives_plus(O_G)
  do let ()=
     if sigma_lusztig_verbose
     then prints
       ("computing sigma_lusztig for orbit=", O_G, " ", O_G.diagram, new_line
       ,"M=", M, new_line
       ,"H_M=",H_M,new_line
       , "y=", y
       )
     fi in
  sigma_lusztig_long(st_G,complex_nilpotent(M,H_M))
od

{include terms coming from deformation}
set lusztig_cell_plus (SpringerTable st_G,ComplexNilpotent O_G) = [[int]]:
let G=st_G.root_datum then
rv=for (M,H_M,y) in component_representatives_plus(O_G) do
    let basis=M.radical_basis in
    let variants=if =#basis then [null(G.rank)] else all_sums(basis) fi in
    for v in variants do
        let L = centralizer(G,y+v/(coxeter_number(G)+1))
        then st_L=L.Springer_table
        then O_L=complex_nilpotent(L,H_M) in
     if sigma_lusztig_verbose
      then prints("y=", y, new_line, "v=",v/(G.coxeter_number+1));
	  prints("lusztig_cell_plus", new_line
         	,"orbit: ", O_G.diagram, basis, new_line
                ,"M=", M, new_line
                ,"H_M=",H_M,new_line
                ,"y=", y
		)
     fi;
     sigma_lusztig(st_G,O_L)
    od
   od.##
in sort_u(remove_zeros(rv))


set lusztig_cells (SpringerTable st_G,[ComplexNilpotent] orbits_G) =[(ComplexNilpotent,[(ComplexNilpotent,[int],int,ComplexNilpotent,bool)])]:
for orbit in orbits_G do (orbit,lusztig_cell(st_G,orbit)) od

set lusztig_cells (RootDatum G,[ComplexNilpotent] orbits_G) = lusztig_cells(G.Springer_table,orbits_G)
set lusztig_cells ([ComplexNilpotent] orbits_G) = lusztig_cells(orbits_G[0].root_datum,orbits_G)
set lusztig_cells(RootDatum G)=lusztig_cells(G,G.orbits)
set lusztig_cells(SpringerTable st)=lusztig_cells(st,st.orbits)

set lusztig_cells_plus(SpringerTable st_G,[ComplexNilpotent] orbits_G) =
for orbit in orbits_G do (orbit,lusztig_cell_plus(st_G,orbit)) od

set lusztig_cells_plus(RootDatum G,[ComplexNilpotent] orbits_G) = lusztig_cells_plus(G.Springer_table,orbits_G)
set lusztig_cells_plus([ComplexNilpotent] orbits_G) =lusztig_cells_plus(orbits_G[0].root_datum,orbits_G)
set lusztig_cells_plus(RootDatum G)=lusztig_cells_plus(G,G.orbits)
set lusztig_cells_plus(SpringerTable st)=lusztig_cells_plus(st,st.orbits)

{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells(SpringerTable st_G,[ComplexNilpotent] orbits) = 
let G=st_G.root_datum in
prints("G=", G.nice_format, new_line, "#orbits: ", #orbits);
let table =
##for (orbit,data)@i in lusztig_cells(st_G,orbits) do {[(RootDatum,vec,[int],int,ComplexNilpotent,bool)]}
 for (O_M,ind,sigma_G_index,O_G_vee,is_special) in data do
  if =#ind
   then { even if there are no |ind|, build one [string] }
    [[[[orbit.diagram.to_string
    ,orbit.dim_nilpotent.to_string
    ,i.to_string
    ,integrality_datum(orbit).nice_format
    ,O_M.root_datum.nice_format
    ,O_M.H.compact_string
    ,"[]"
    ,"x"
    ,"x"
    ,"x"
    ,"x"
    ,"x"
    ,"x"
    ,"x"
    ]]]]
   else
    for k:#ind do
     if ind[k]>0 then
       [[[orbit.diagram.to_string
       ,orbit.dim_nilpotent.to_string
       ,i.to_string
       ,integrality_datum(orbit).nice_format
       ,O_M.root_datum.nice_format
       ,O_M.H.compact_string
       , "" +if #ind=1 then k.to_string else ind.to_string + ":" + k.to_string fi
       ,dimension(st_G.ct,k).to_string
       ,st_G.ct.degree(k).to_string
       ,st_G.ct.generic_degree(k).to_string
       ,st_G.ct.character(k).to_string
       ,is_special.to_string
      ]]] else [[[string]]]:[]
     fi{/if ind[k]>0}
    od{/for k:#ind}
  fi{=#ind}
 od.##.##{/for (O_M,...)}
od.##{/for i:#data}
in {table=[[string]]}
   ([["O"
    ,"dim"
    ,"i"
    ,"rd_int"
    ,"M"
    ,"H_M"
    ,"special_M"
    ,"v"
    ,"L"
    ,"sigma"
    ,"special"
    ,"dim"
    ,"bool"
    ]]; tabulate(table)
)


set show_lusztig_cells (RootDatum G,[ComplexNilpotent] orbits_G) = show_lusztig_cells(G.Springer_table,orbits_G)
set show_lusztig_cells ([ComplexNilpotent] orbits_G) = show_lusztig_cells(orbits_G[0].root_datum,orbits_G)
set show_lusztig_cells(RootDatum G)=show_lusztig_cells(G,G.orbits)
set show_lusztig_cells(SpringerTable st)=show_lusztig_cells(st,st.orbits)


{
{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells_plus\
   (SpringerTable st_G,[ComplexNilpotent] orbits) = void:
   let G=st_G.root_datum in 
   prints("G=", G.nice_format, new_line, "#orbits: ", #orbits);
let table_header =
    ["O","dim","i","rd_int","M","H_M","y","v","L","ind"
    ,"sp_L","deg_L","special","dim","deg","gdeg","char=ct.character(sigma[0])"
    ]
, table = [ [string] ]: { concatenation of all [string] values from |data| }
   for data@i in lusztig_cells_plus({G,}st_G,orbits) {[[(M,H_M,y,values)]]}
   do for (orbit,M,H_M,y,v,values) in data
      do if =#values
         then { even if there are no |values|, build one [string] }
	    [[orbit.diagram.to_string + st_G.special_star(orbit)
	    ,orbit.dim_nilpotent.to_string
	    ,i.to_string
	    ,integrality_datum(orbit).nice_format
	    ,M.nice_format
	    ,H_M.compact_string
            ,""
	    ,y.compact_string
	    ,v.compact_string
	    ,centralizer(G,y).nice_format
	    ,"[]"
	    ,"x"
	    ,"x"
	    ,"x"
	    ,"x"
	    ,"x"
	    ]]
	 else
            let L=centralizer(G,(y+v)/(coxeter_number(G)+1)) then
            O_L=complex_nilpotent(L,H_M) then
            st_L=Springer_table(L) then
            sigma_L=st_L.springer(O_L) in
	    for k in values do
	    [orbit.diagram.to_string + st_G.special_star(orbit)
	    ,orbit.dim_nilpotent.to_string
	    ,i.to_string
	    ,integrality_datum(orbit).nice_format
	    ,M.nice_format
	    ,H_M.compact_string
	    ,y.compact_string
	    ,v.compact_string
	    ,L.nice_format
	    ,if #values=1 then k.to_string
	     else values.to_string + ":" + k.to_string
	     fi
            ,if is_special(st_L,O_L) then "*" else "" fi
            ,sigma_L.to_string + "/" + st_L.ct.degree(sigma_L).to_string
            ,if =y then st_G.ct.special(st_G.springer(orbit)).to_string else "" fi
	    ,dimension(st_G.ct,k).to_string
	    ,st_G.ct.degree(k).to_string
      	    ,st_G.ct.generic_degree(k).to_string
	    ,st_G.ct.character(k).to_string
	    ]
	    od {for k in values}
	 fi
      od.## { for (...) in data }
   od.##{for data in Lusztig_cells }
in tabulate(table_header#table)

{some shorthands which are handy but sometimes inefficient}
set lusztig_cell (RootDatum G,ComplexNilpotent O) = [[int]]:
    lusztig_cell({G,}G.Springer_table,O)

set show_lusztig_cells ({RootDatum G,}SpringerTable st_G) = void:
   show_lusztig_cells({G,}st_G,st_G.root_datum.orbits)

set show_lusztig_cells_plus (RootDatum G,SpringerTable st_G) = void:
   show_lusztig_cells_plus({G,}st_G,G.orbits)

set show_lusztig_cells(RootDatum G) = void:
   let st=Springer_table(G) in show_lusztig_cells({G,}st)

set show_lusztig_cells_plus (RootDatum G) = void:
   let st=Springer_table(G) in show_lusztig_cells_plus(G,st)

set A_bar(SpringerTable st,ComplexNilpotent O)=([int],[[RootDatum]]):
let data=lusztig_cell_long(st,O) then
sigmas=(##for (,,,j_values) in data do if =#j_values then [] else [j_values[0]] fi od).sort_u in
(sigmas,
 for i:#sigmas do
  ##for (M,,,j_values) in data do
    if #j_values>0 and sigmas[i]=j_values[0] then [M] else [] fi
 od
od)

set A_bar(SpringerTable st)=(ComplexNilpotent ->([int],[[RootDatum]])):(ComplexNilpotent O):A_bar(st,O)


set show_A_bar([int] sigmas,[[RootDatum]] pseudolevis)=void:
for i:#sigmas do
 let str="" in
  for M in pseudolevis[i] do str+:=" " + nice_format(M) od
 ;prints(sigmas[i],str)
od

set show_A_bar(SpringerTable st,ComplexNilpotent orbit)=void:
let (sigmas,pseudolevis)=A_bar(st,orbit) in
prints("orbit: ", orbit.diagram);
for i:#sigmas do prints(sigmas[i], " ", #pseudolevis[i]) od;
prints(sigmas.to_string +
##for i:#sigmas do
 let str="" in
  for M in pseudolevis[i] do str+:=" " + nice_format(M) od
 ;"  " +sigmas[i].to_string + str
od)


{four inner products stuff moved to inner_products.at}
{---------------------------------------------------------------------------}
{stuff that used to be in lusztig_cells_complete.at}
{these generic versions are no longer needed:


{show lusztig cells, running over given list of nilpotents}
set show_lusztig_cells_generic\
   (RootDatum G,SpringerTable st_G,[ComplexNilpotent] orbits) = void:
  (new_line
  ,"Lusztig cells",new_line
  ,"G=", G.nice_format, new_line
  , "#orbits: ", #orbits
  ).prints;
let table = [ [string] ]: { concatenation of all [string] values from |data| }
    for data@i in lusztig_cells(G,st_G,orbits) {[[(M,H_M,y,values)]]}
    do for (orbit,M,H_M,y,values) in data
       do
          if =#values
	  then { even if there are no |values|, build one [string] }
	     [[orbit.diagram.to_string + st_G.special_star(orbit)
	     ,orbit.dim_nilpotent.to_string
	     ,i.to_string
	     ,integrality_datum(orbit).nice_format
	     ,M.nice_format
	     ,H_M.compact_string
	     ,y.compact_string
	     ,centralizer(G,y).nice_format
	     ,"[]"
	     ,"x"
	     ,"x"
	     ,"x"
	     ,"x"
	     ,"x"
	     ]]
	  else { contribute one or more [string] values }
	     for k in values
	     do
	     [orbit.diagram.to_string + st_G.special_star(orbit)
	     ,orbit.dim_nilpotent.to_string
	     ,i.to_string
	     ,integrality_datum(orbit).nice_format
	     ,M.nice_format
	     ,H_M.compact_string
	     ,y.compact_string
	     ,centralizer(G,y).nice_format
	     ,if #values=1 then k.to_string { mention unique |k| }
	      else values.to_string + ":" + k.to_string { mention |k| from list }
	      fi
	     ,if =y then st_G.ct.special(st_G.springer(orbit)).to_string else "" fi
	     ,dimension(st_G.ct,k).to_string
	     ,st_G.ct.degree(k).to_string
	     ,st_G.ct.generic_degree(k).to_string
	     ,st_G.ct.character(k).to_string
	     ]
	     od {for k in values}
	  fi
       od.## { for (...) in data }
    od.## {for data in Lusztig_cells }
in
( ["O"
  ,"dim"
  ,"i"
  ,"rd_int"
  ,"M"
  ,"H_M"
  ,"special_M"
  ,"v"
  ,"L"
  ,"sigma"
  ,"special"
  ,"dim"
  ,"deg"
  ,"gdeg"
  ,"char=ct.character(sigma[0])"
  ]
# table
).tabulate

set show_lusztig_cells_generic_long\
   (RootDatum G,SpringerTable st_G,[ComplexNilpotent] orbits) = void:
   show_very_long(st_G.ct);
   show_long(st_G);
   show_lusztig_cells_generic(G,st_G,orbits)

set show_lusztig_cells_generic (RootDatum G,SpringerTable st_G) = void:
   show_lusztig_cells_generic(G,st_G,G.orbits)

set show_lusztig_cells_generic_long (RootDatum G,SpringerTable st_G) = void:
   show_lusztig_cells_generic_long(G,st_G,G.orbits)

set show_lusztig_cells_generic (RootDatum G) = void:
let st=Springer_table_generic_degrees(G)
in show_lusztig_cells_generic(G,G.Springer_table)

set show_lusztig_cells_generic_long (RootDatum G) = void:
let st=Springer_table_generic_degrees(G)
in show_lusztig_cells_generic_long(G,st)
}
