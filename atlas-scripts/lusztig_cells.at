<all.at

{This can replace lusztig_cells.at in the 7/1/21 version of leaner}

{the Lusztig map goes from triples (O^v,x,xi) to W^
 this file implements an algorithm (conjectural)
 to implement this when xi=1
 the set obtained for fixed O^v, running over x,
 is a Lusztig (left) cell
}
<coherent_characters.at
<truncated_induction.at
<isomorphism_W.at
<generic_degrees.at

{sigma_L (L stands for "Lusztig")
sigma_L(O^v,x) is a of a representation of W(G)
conjecturally it is the same as
Lusztig(O^v,x,1) as defined in the Orange book, this also
}

{G G^v, O^v = special orbit for G^vee, x\in A-bar(O^v)
M=M(A-bar(O^v)): pairs defined by Lusztig
xi an irreducible representation of Cent_{A-bar(O^v)}(x)
(O^v,x,xi)  -- Lusztig -->  W(G)^

generalization of Springer map

(O^v,1,1) -> Springer(O^v)  Springer corresdponence for G^v
          -> Springer(O^v)\otimes sign \in W(G^v)^
	  -> W(G)^ via the isomorphism W(G^v)\simeq W(G)

More general case:
(O^v,x,1)  -> L_x^v=Cent_{G^v}(x)^0
	   -> O_L_x^v (same H)
	   -> Springer(O_L_x^v)\otimes sgn in W(L_x^v)^   [NOT the same as Sommers: Springer(dual(O_L_x^v)]
	   -> sigma_L_x\in W(L_x) via W(L_x)^v\simeq W(L_x_v)
	   -> [ no: truncated induction from W(L_x) to W(G)]
           -> induce to W(G) and keep the term(s) with the same degree as sigma_L(O^v,1,1)

Note: this O_L_x^v might not be special, so Springer(dual(orbit)) \ne Springer(orbit)*sign

Non-trivial \xi not yet considered
}

{Example: O^v=0-orbit, x=1
L_x_v=G_v, O_L_x_v=0-orbit of G^v
Springer(O_L_x_v)=sign of W(G^)
\otimes sgn=trivial of
}
set sigma_L_verbose=false

{main algorithm for computing sigma_L, this won't usually be called by the user
 M_v is a pseudo-Levi
 H_M_v is (the ss element of) an orbit for M_v
 exp(2pi i y) is an element of center of M^0
 typically (M_v,H_M_v,y) are provided by component_datum@ComplexNilpotent
}
{arguments:
 G given group with its coordinate, need this to compute roots of L in G
 G.ct is needed to compute truncated induction/exchange_long_short
 L_v.st is needed to compute Springer(O_L_v)  (L_v=centralizer of y on dual side, L=dual(L_v))
 O_v: given orbit on the dual side
 M_v: pseudo-Levi in which exp(2\pi iy) is central
  (this isn't really needed but is helpful information)
 H_M_v: ss element for orbit of M_v
 y: x=exp(2\pi iy)
 note that L_v depends on y
}
{Lusztig only}
set sigma_L(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v,RootDatum M_v,vec H_M_v,ratvec y)=
{variant: add center of M_v to y}
let ()=if sigma_L_verbose then
   prints(new_line,"Computing sigma_L: ",new_line,"O_v=", O_v.diagram,new_line,
   "G=", G,new_line, "st_G_v: ", st_G_v.root_datum, new_line,"M_v=", M_v, new_line, "H_M_v=",H_M_v,new_line,"y=", y) fi
in if y.is_integer then  {L_v=G_v, L=G, don't need induction}
 let ()=if sigma_L_verbose then prints("y is integer, no induction")  fi then
 sigma_v=st_G_v.ct.characters[st_G_v.springer(O_v)] then
 ()=if sigma_L_verbose then prints("sigma_v (no induction): ", sigma_v) fi  then
 sigma= exchange_long_short(ct_G,st_G_v.ct.tensor_sign(sigma_v)) then
 ()=if sigma_L_verbose then prints("exchange/tensor sign: ", sigma) fi in
 ct_G.character_index(sigma)
else  {need induction; compute L, sigma_L, truncated_induce}
 let ()=if sigma_L_verbose then prints("need induction: ")  fi in
 let G_v=O_v.root_datum then
 ()=if sigma_L_verbose then prints(("y=",y) ) fi then
 L_v=centralizer(G_v,y) then
 ()=if sigma_L_verbose then prints(("L_v=",L_v, new_line, "G_v=", G_v) ) fi then
 {O_M_v=ComplexNilpotent:(M_v,(),H_M_v) -> saturation -> O_L_v
  O_L_v has the same H=H_M_v, but made L_v-dominant}
 H_L_v=dominant(H_M_v,L_v) then
 O_L_v=ComplexNilpotent:(L_v,(),H_L_v) then
 ()=if sigma_L_verbose
   then prints(("L_v=", L_v,new_line,"H_L_v=", H_L_v,new_line,"O_L_v:", O_L_v.H, " ", O_L_v.diagram) ) fi then
 L=dual(L_v) then
 roots_L=for alpha in L.simple_roots do find(G.roots,alpha) od then
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
 sigma_L=
 if O_L_v=L_v.zero_orbit then prints("zero orbit");   L.character_table.trivial
 elif O_L_v=L_v.principal_orbit then L.character_table.sign
 else  {not 0 or principal orbit: need to compute L.springer_table}
  let ()=if sigma_L_verbose then prints(("computing st_L_v:") ) fi then
  st_L_v=L_v.springer_table then
  ()=if sigma_L_verbose then prints(("done computing L_v.springer_table (not including generic degree)") ) fi then
{ st_L_v=update_fake_degrees(L_v.split_form,st_L_v_0) then 
  ()=if sigma_L_verbose then prints("done updating fake degrees for L_v_0") fi then }
  sigma_L_v=st_L_v.springer(O_L_v) then
  char=st_L_v.ct.characters[sigma_L_v] then
  sigma_L_0=st_L_v.ct.tensor_sign(char) then
  ex=exchange_long_short(L_v.character_table,sigma_L_0) in
  let ()=if sigma_L_verbose then prints("sigma_L_v: ", sigma_L_v, new_line, "char: ", char, new_line, "sigma_L_0: ", sigma_L_0, new_line,
  "ex: ", ex) fi in ex
 fi  {end if O_L_v=L_v.zero_orbit} then
 {now induce sigma_L}
 { ()=    assert(#(ct_G.fake_degrees)>0,"need to compute fake degrees for ct_G (ct:=update_fake_degrees(G,ct) or st:=update_fake_degrees(G,st)") then }
 {maybe need fake degrees for st_G_v}
{ ()=    assert(#(st_G_v.fake_degrees)>0,"need to compute fake degrees for st_G_v (ct:=update_fake_degrees(G,ct) or st:=update_fake_degrees(G,st)") then}
  degree_function(int j)=ct_G.generic_degree(j) then
  ()=if sigma_L_verbose then prints("inducing character from L:", L) fi then
  ind=induce_character(G,ct_G,roots_L,sigma_L) then
    ()=if sigma_L_verbose then prints("finished inducing character from L:", L) fi then
{  char_indices=truncate_induce_character(G,ct_G,roots_L,sigma_L,degree_function) then}
{ in F4, trying variants:}
  ind_decomposed=ct_G.decompose(ind) then
  desired_generic_degree = st_G_v.ct.degrees[st_G_v.springer(O_v)] then
  ()=if sigma_L_verbose then prints("desired_generic_degree: ", desired_generic_degree) fi then
  char_indices=[int]:
     ##for i:#ind_decomposed do
       if (ind_decomposed[i]>0 and ct_G.generic_degree(i)=desired_generic_degree) then [i]  else [] fi od then
{     if      (ind_decomposed[i]>0 and ct.fake_degrees[i]=desired_generic_degree) then [i] else [int]:[] fi od }
  ()=if sigma_L_verbose then  prints("O_v: ", O_v.diagram, new_line,"L_v: ", L_v,new_line,"O_L_v: ", O_L_v.diagram,new_line,"sigma_L: ", sigma_L,new_line);
    prints("induced char: ", ind,new_line, "decomposition(1):", ct_G.decompose(ind));ct_G.view_char(ind);
    prints("minimal degree terms in induced: ", char_indices) fi then
 ()=if sigma_L_verbose then prints("truncated induce (sigma_L): ", "G=",G,new_line,"roots_L: ", roots_L, " sigma_L=", sigma_L) fi then
  char_index=   if =#char_indices then -1
    else
     let char_L_0=ct_G.characters[char_indices[0]] then
     ()=if sigma_L_verbose then prints("character of L: ", char_indices[0], new_line, char_L_0) fi in
     ct_G.character_index(char_L_0)
    fi
  in if sigma_L_verbose then prints("char_index=", char_index) fi;char_index
fi  {end if y.is_integer}

{-------------------------------------------------------------------}
{modify to work on the group side:
generalization of Springer map

(O,1,1) -> Springer(O)  Springer correspondence for G  (Springer(0)=sign/Springer(principal)=trivial)
        -> Springer(O)*sgn  (so 0->trivial/principal->sign)

General case:
(O,x,1)  -> L_x=Cent_{G}(x)^0
	 -> O_L_x (same H)
	 -> Springer(O_L_x) in W(L_x)^
	 -> induce from W(L_x) to W(G)
  	 -> exchange_long_short   (W(B4)->W(C4) in F4)
	 -> keep term(s) with generic degree: generic_degree(Springer(O)*sign)
}

{returns [(int,int)] = [(index,multiplicity)]
 usually [(j,1)]: meaning only character #j appears with multiplicity 1
 rarely  [(j,1),(k,1)...] : several characters appear with multiplicity 1
 occasionally []: empty
 so far never see mult>0
}
set sigma_L_no_dual(RootDatum G,SpringerTable st_G,ComplexNilpotent O,RootDatum M,vec H_M,ratvec y)=[int]: 
let ()=if sigma_L_verbose then  prints(new_line,"Computing sigma_L_no_dual: ",new_line,"O=", O.diagram,new_line,
       "G=", G,new_line, "st_G: ", st_G.root_datum, new_line,"M=", M, new_line, "H_M=",H_M,new_line,"y=", y)  fi
then
ct_G=st_G.character_table in
if y.is_integer then  {L=G, L=G, don't need induction}
 let ()=if sigma_L_verbose then prints("y is integer, no induction",new_line)  fi then
 sigma=st_G.springer(O) {int} then
 ()=if sigma_L_verbose then prints("sigma (no induction): ", sigma,new_line) fi  in
 [sigma]  {return value}
else  {need induction; compute L, sigma_L}
 let ()=if sigma_L_verbose then prints("need induction: ") fi in
 let L=centralizer(G,y) then
{ let (,L)=subgroup(G,M.roots) then}
 H_L=dominant(H_M,L) then
 O_L=ComplexNilpotent:(L,(),H_L) then
 ()=if sigma_L_verbose
   then prints(("L=", L,new_line,"H_L=", H_L,new_line,"O_L:", O_L.H, " ", O_L.diagram) ) fi then
{ roots_L=for alpha in L.simple_roots do find(st_G.root_datum.roots,alpha) od then}{no: should be G.roots}
 roots_L=for alpha in L.simple_roots do find(G.roots,alpha) od then
{ ()=if sigma_L_verbose then prints("L.simple_roots: ", L.simple_roots, new_line, "st_G.root.datum.roots: ", st_G.root_datum.roots) fi then}
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
 sigma_L=[int]:
 if O_L=L.zero_orbit then    L.character_table.sign 
 elif O_L=L.principal_orbit then L.character_table.trivial
 else  {not 0 or principal orbit; need to compute L.springer_table: main work is here}
  let ()=if sigma_L_verbose then prints(("computing st_L:") ) fi then
  st_L=L.springer_table then
   ()=if sigma_L_verbose then prints(("done computing L.springer_table (not including generic degree)") ) fi then
  sigma_L_0=st_L.springer(O_L) then
  char=st_L.ct.characters[sigma_L_0] then
   ()=if sigma_L_verbose then prints("sigma_L: ", char) fi  in char
 fi  {now have sigma_L=character of L}{end if O_L=L.zero_orbit} then
 {next: induce sigma_L}
  ()=if sigma_L_verbose then prints("inducing character from L:", L,new_line, "roots_L: ", roots_L, new_line, "sigma_L: ", sigma_L) fi then
 ind=induce_character(G,ct_G,roots_L,sigma_L) then
  ()=if sigma_L_verbose then
   prints("finished inducing character from L:", L, new_line, "ind=(2)" , ind,new_line);
   ct_G.view_char(ind)
  fi then
  ind_decomposed=ct_G.decompose(ind) then
   springer_O=st_G.springer(O) then
   desired_generic_degree = st_G.ct.generic_degree(springer_O) then
    ()=if sigma_L_verbose then prints("getting desired fake degree: ", new_line, "O=",O.diagram, new_line, "springer(O): ", springer_O,
     new_line, "sigma_L for generic degree: ", sigma_L, new_line,"desired_generic_degree: ", desired_generic_degree)
    fi then
   char_indices=[int]:  
   ##for i:#ind_decomposed do
      if (ind_decomposed[i]>0 and ct_G.generic_degree(i)=desired_generic_degree) then
       {probably never happens: correct generic degree and mult >1. If so print loud WARNING}
       if ind_decomposed[i]>1 then prints("WARNING: multiplicity >1: ", new_line, "i=", i, " mult= ",ind_decomposed[i],new_line,
       "ind_decomposed=",ind_decomposed) fi;
      [i]  else [] fi
      od
   in char_indices
{   ()=if sigma_L_verbose then  prints("O: ", O.diagram, new_line,"L: ", L,new_line,"O_L: ", O_L.diagram,new_line,"sigma_L: ", sigma_L,new_line);
    prints("induced char: ", ind,new_line, "decomposition(3):", ct_G.decompose(ind));ct_G.view_char(ind) fi
  then}
{  char_index=   if =#char_indices then -1
    else
     let char_L_0=ct_G.characters[char_indices[0]] then
     ()=if sigma_L_verbose then prints("character of L: ", char_indices[0], new_line, char_L_0) fi in
     ct_G.character_index(char_L_0)}
fi  {end if y.is_integer}


{-------------------------------------------------------------------}
{Lusztig and Sommers version}
{also return: O_L_v}
set sigma_L_S(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v,RootDatum M_v,vec H_M_v,ratvec y)=(int,int,ComplexNilpotent):
{variant: add center of M_v to y}
let ()=if sigma_L_verbose then
   prints("Computing sigma_L: ",new_line,
   "G=", G, "st_G_v: ",new_line, st_G_v.root_datum, new_line,"M_v=", M_v, new_line, "H_M_v=",H_M_v,new_line,"y=", y) fi
in if y.is_integer then  {L_v=G_v, L=G, don't need induction}
 let ()=if sigma_L_verbose then prints("y is integer, no induction")  fi then
 sigma_v=st_G_v.ct.characters[st_G_v.springer(O_v)] then
 sigma= exchange_long_short(ct_G,st_G_v.ct.tensor_sign(sigma_v)) then
 char= ct_G.character_index(sigma) in
 (char,char,O_v)  {sigma_L=sigma_S=char}
else  {need induction; compute L, sigma_L, truncated_induce}
 let ()=if sigma_L_verbose then prints("need induction: ")  fi in
 let G_v=O_v.root_datum then
 ()=if sigma_L_verbose then prints(("y=",y) ) fi then
 L_v=centralizer(G_v,y) then
 ()=if sigma_L_verbose then prints(("L_v=",L_v, new_line, "G_v=", G_v) ) fi then
 {O_M_v=ComplexNilpotent:(M_v,(),H_M_v) -> saturation -> O_L_v
  O_L_v has the same H=H_M_v, but made L_v-dominant}
 H_L_v=dominant(H_M_v,L_v) then
 O_L_v=ComplexNilpotent:(L_v,(),H_L_v) then
 ()=if sigma_L_verbose
   then prints(("L_v=", L_v,new_line,"H_L_v=", H_L_v,new_line,"O_L_v:", O_L_v.H, new_line,"O_L_v.diagram:", O_L_v.diagram) ) fi then
 L=dual(L_v) then
 roots_L=for alpha in L.simple_roots do find(G.roots,alpha) od then
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
 (sigma_L,sigma_sommers)=
 if O_L_v=L_v.zero_orbit then let char=L.character_table.trivial in (char,char)
 elif O_L_v=L_v.principal_orbit then let char=L.character_table.sign in (char,char) {sigma_L=sigma_S}
 else  {not 0 or principal orbit: need to compute L.springer_table}
  (let ()=if sigma_L_verbose then prints(("computing st_L:") ) fi then
  st_L_v=L_v.springer_table then
  ()=if sigma_L_verbose then prints(("done computing L.springer_table") ) fi then
  sigma_L_v=st_L_v.springer(O_L_v) then
  char=st_L_v.ct.characters[sigma_L_v] then
  sigma_L_0=st_L_v.ct.tensor_sign(char) in
  exchange_long_short(L_v.character_table,sigma_L_0),{that's sigma_L}
  {now sigma_sommers}
  let st_L=L.springer_table then
  O_L=st_L.dual_map_i(O_L_v) then
  rv=  st_L.ct.characters[st_L.springer(O_L)] in
  if sigma_L_verbose then
   prints("O_L: ", O_L, " ", O_L.diagram, new_line,"sigma_sommers: ", rv) fi; rv)
 fi  {end if O_L_v=L_v.zero_orbit} in
 {now induce sigma_L and sigma_sommers}
 {sigma_L:}
  (let char_index=truncate_by_degree_induce_character(G,ct_G,roots_L,sigma_L) then
  ()=if sigma_L_verbose then prints("sigma_L: ", sigma_L, "char_index: ", char_index) fi then
  ()=if sigma_L_verbose then prints("truncated induce (sigma_L): ", "G=",G,new_line,"roots_L: ", roots_L, " sigma_L=", sigma_L) fi then
  char_L=ct_G.characters[char_index] then
  ()=if sigma_L_verbose then prints("character of L: ", char_L) fi in char_index,
  {now sommers:}
   let char_index=truncate_by_degree_induce_character(G,ct_G,roots_L,sigma_sommers) then
  ()=if sigma_L_verbose then prints("sigma_sommers: ", sigma_sommers, "char_index: ", char_index) fi then
  ()=if sigma_L_verbose then prints("truncated induce (sommers): ", "G=",G,new_line,"roots_L: ", roots_L, " sigma_sommers", sigma_sommers) fi then
   char_sommers=ct_G.characters[char_index] then
   ()=if sigma_L_verbose then prints("character of L: ", char_index, new_line, char_sommers) fi in
{   ct_G.character_index(char_sommers),O_L_v)}
   char_index,O_L_v)
fi  {end if y.is_integer}

{---------------}

{run over all ratvecs from component_representatives(orbit)}
set lusztig_cell(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v)=[int]:
{prints("sigma_L for: ", O_v,"  ", O_v.diagram,new_line, " st_G_v:",st_G_v.root_datum);}
{sort_u: avoid duplicates from A-bar(O_v)\ne A(O_v)}
sort_u(for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
 let ()=if sigma_L_verbose then prints("computing sigma_L for M_v=", M_v, new_line,"H_M_v=",H_M_v,new_line, "y=", y)  fi in
    {let ()=if sigma_L_verbose then prints("calling sigma_L(x):", new_line,"G: ", G, new_line,"O_v: ", O_v.diagram, " ", O_v.dim_nilpotent,
   "st:", st_G_v.root_datum, new_line,"M_v: ", M_v, new_line, "H_M_v", H_M_v, new_line, "y: ", y) fi in}
 sigma_L(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) od)


{run over all ratvecs from component_representatives(orbit)}
set lusztig_cell_no_dual(RootDatum G,SpringerTable st_G,ComplexNilpotent O)=[[int]]:
sort_u(
 for (M,H_M,y) in component_representatives_plus(O) do
     let ()=if sigma_L_verbose then prints("computing sigma_L for M=", M, new_line,"H_M=",H_M,new_line, "y=", y)  fi in
 sigma_L_no_dual(G,st_G,O,M,H_M,y)
od)


set lusztig_cell_char(RootDatum G,CharacterTable ct_G,SpringerTable st_G,ComplexNilpotent O)=
sum(for index in lusztig_cell(G,ct_G,st_G,O) do ct_G.character(index) od)

set lusztig_cell_char_no_dual(RootDatum G,CharacterTable ct_G,SpringerTable st_G,ComplexNilpotent O)=
sum(for index in lusztig_cell(G,ct_G,st_G,O) do ct_G.character(index) od)

{some shorthands which are handy but inefficient}
set lusztig_cell_no_dual(RootDatum G,ComplexNilpotent O)=[[int]]:lusztig_cell_no_dual(G,G.springer_table,O)

{Caution: we need to run over special orbits of G and/or G^v,
 and keep track of the permutation given by duality}

{lusztig cells are parametrized by dual special orbits, but parametrized
 by G.special_orbits}
set lusztig_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=[[int]]:
 for O in st_G.special_orbits do
  let O_dual=st_G.dual_map(O) then
  O_v=orbit_by_diagram(G.dual,O_dual.diagram_normalized) then
  ()=if sigma_L_verbose then prints(new_line,"-----------------------------------------------",new_line,"computing Lusztig cell of dual orbit: ",O_v.diagram, " ", O_v.dim_nilpotent) fi in
  lusztig_cell(G,st_G.ct,st_G_v,O_v) od


{show lusztig cells, running over given list of dual nilpotents}
set show_lusztig_cells(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
prints("G=", G.nice_format, new_line, "#orbits: ", #dual_orbits);
tabulate(
["O^v","dim","i","rd_int","M","H_M","v","L","sigma","dim","deg","fdeg","char"]#
##for O_v@counter in dual_orbits do
  let ()=  if sigma_L_verbose then prints(new_line, "------------------------------------------------------------",new_line,
  "orbit #",counter,": ", O_v.root_datum.nice_format,
        " H=", O_v.H, new_line,"diagram=", O_v.diagram,new_line, "normalized diagram=", O_v.diagram_normalized) fi 
	in
  let data=
  for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
    let j=sigma_L(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) in  (M_v,H_M_v,y,j)
  od
  in
  for i:#data do
   let (M_v,H_M_v,y,j)=data[i] then
   sigma=
    if j=-1 then [] else ct_G.characters[j] fi in
   [O_v.diagram.to_string,
    O_v.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(O_v).nice_format,
    M_v.nice_format,
    H_M_v.compact_ratvec,
    y.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma="+j.to_string,
    if j=-1 then "x" else dimension(ct_G,j).to_string fi,
    if j=-1 then "x"  else ct_G.degrees[j].to_string fi,
    if j=-1 then "x"
     { elif #ct_G.generic_degrees>0 then ct_G.fake_degrees[j].to_string }
else ct_G.generic_degree(j).to_string
{     else "x"} fi,
    sigma.to_string]
  od  {/for i:#data}
 od {for O_v})

{show lusztig cells, running over given list of dual nilpotents}
set show_lusztig_cells_no_dual(RootDatum G,SpringerTable st_G,[ComplexNilpotent] dual_orbits)=void:
prints("G=", G.nice_format, new_line, "#orbits: ", #dual_orbits);
tabulate(
["O","dim","i","rd_int","M","H_M","v","L","sigma(s)","dim","deg","fdeg","char=ct.characters[sigma[0]]"]#
##for O@counter in dual_orbits do
  let ()=if sigma_L_verbose then
     prints(new_line,"------------------------------------------------------------",new_line, "orbit #",counter,": ", O.root_datum.nice_format,
        " H=", O.H, " diagram=", O.diagram, " normalized diagram=", O.diagram_normalized) fi
	in
  let data=
  for (M,H_M,y) in component_representatives_plus(O) do
    let j_values=sigma_L_no_dual(G,st_G,O,M,H_M,y) in  (M,H_M,y,j_values)
  od
  in
  for i:#data do
   let (M,H_M,y,j_values)=data[i] then
   j=if =#j_values then -1 else j_values[0] fi then
   sigma=[int]:
    if #j_values=0 then [] else st_G.ct.characters[j_values[0]] fi in
   [O.diagram.to_string,
    O.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(O).nice_format,
    M.nice_format,
    H_M.compact_ratvec,
    y.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma="+
     if #j_values=1 then j.to_string else j_values.to_string fi,
    if j=-1 then "x" else dimension(st_G.ct,j).to_string fi,
    if j=-1 then "x"  else st_G.ct.degrees[j].to_string fi,
    if j=-1 then "x"
{     elif #st_G.fake_degrees>0 then st_G.ct.fake_degrees[j].to_string }
     else st_G.ct.generic_degree(j).to_string
     {else "x"} fi,
    sigma.to_string]
  od  {/for i:#data}
 od {for O})

set show_lusztig_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
show_lusztig_cells(G,st_G.ct,st_G_v,dual_orbits)

{set show_lusztig_cells_no_dual(RootDatum G,SpringerTable st_G,[ComplexNilpotent] orbits)=void:
show_lusztig_cells_no_dual(G,st_G,orbits)}

set show_lusztig_cells(RootDatum G,SpringerTable st_G)=void:
show_lusztig_cells(G,st_G.ct,st_G,
for O in st_G.orbits do let O_dual=st_G.dual_map(O) in orbit_by_diagram(G.dual,O_dual.diagram_normalized)
od)

set show_lusztig_cells_no_dual(RootDatum G,SpringerTable st_G)=void:
{show_lusztig_cells_no_dual(G,st_G,{st_}G.orbits)}{no: should be G.orbits}
show_lusztig_cells_no_dual(G,st_G,{st_}G.orbits)

set show_lusztig_cells_no_dual(RootDatum G)=void:
let st=G.springer_table in
update_generic_degrees(st.ct,G.split_form);
show_lusztig_cells_no_dual(G,st)

set show_lusztig_cell_no_dual(RootDatum G,SpringerTable st_G,ComplexNilpotent O)=void:
 show_lusztig_cells_no_dual(G,st_G,[O])


{set show_lusztig_cells(RootDatum G)=void:show_lusztig_cells(G,G.springer_table,G.dual.springer_table)}

set show_lusztig_cell(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent dual_orbit)=void:
 show_lusztig_cells(G,ct_G,st_G_v,[dual_orbit])
set show_lusztig_cell(RootDatum G, CharacterTable ct_G,ComplexNilpotent O_v)=void:show_lusztig_cell(G,ct_G,G.dual.springer_table,O_v)
set show_lusztig_cell(RootDatum G, ComplexNilpotent O_v)=void:show_lusztig_cell(G,G.character_table,G.dual.springer_table,O_v)
set show_lusztig_cell(ComplexNilpotent O_v)=void:show_lusztig_cell(O_v.root_datum.dual,O_v)
set show_lusztig_cells(RootDatum G,CharacterTable ct)=void:show_lusztig_cells(G,ct,G.dual.springer_table,G.dual_orbits)

set show_lusztig_cells(RealForm G)=void:
let st=G.springer_table in
update_generic_degrees(st.ct,G);
show_lusztig_cells(G,st.ct,G.dual.springer_table,
   for O in st.special_orbits do let O_dual=st.dual_map(O) in orbit_by_diagram(G.dual,O_dual.diagram_normalized) od)

set show_lusztig_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=void:
show_lusztig_cells(G,st_G.ct,st_G_v,
for O in st_G.special_orbits do let O_dual=st_G.dual_map(O) in orbit_by_diagram(G.dual,O_dual.diagram_normalized)
od)


{for convenience:}
{set init(RootDatum G)=(CharacterTable,SpringerTable,[ComplexNilpotent]):
let ct_0=G.character_table then
st_v_0=G.dual.springer_table then
ct=update_fake_degrees(G.split_form,ct_0) then
st_v=update_fake_degrees(G.dual.split_form,st_v_0) then
orbits=st_v.special_orbits in (ct,st_v,orbits)}
{
set dual_special_orbits_indexed(RootDatum G,SpringerTable st_G_v)=([int],[ComplexNilpotent]):
special_orbits_indexed(G.dual,st_G_v)
set dual_special_orbits_indexed(RootDatum G)=([int],[ComplexNilpotent]):dual_special_orbits_indexed(G,G.dual.springer_table)
set dual_special_orbits(RootDatum G,SpringerTable st_G_v)=[ComplexNilpotent]:special_orbits(G.dual,st_G_v)
set dual_special_orbits(RootDatum G)=[ComplexNilpotent]:dual_special_orbits(G,G.dual.springer_table)
}

{parametrize by special orbits for G}
set lusztig_cells_characters_special(RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=[[int]]:
for orbit in st_G.special_orbits do lusztig_cell_char(G,st_G.ct,st_G_v,orbit_by_diagram(G.dual,st_G.dual_map(orbit).diagram_normalized)) od

set four_inner_products(RealForm G,CharacterTable ct_G,[int] char_G)=
let (valid,M)=root_permutation(G,ct_G.root_datum) then
char=assert(valid,"root data are not locally isomorphic");permute_character(M,ct_G,char_G) in
(ct_G.inner_product(char,character_coherent_B(G,ct_G)),
 ct_G.inner_product(char,character_coherent_X(G,ct_G)),
 ct_G.inner_product(char,character_coherent_Y(G,ct_G)),
 ct_G.inner_product(char,character_coherent_I(ct_G)))

set four_inner_products(RealForm G,RealForm G_dual,CharacterTable ct_G,[int] char_G)=
let (valid,M)=root_permutation(G,ct_G.root_datum) then
char=assert(valid,"root data are not locally isomorphic");permute_character(M,ct_G,char_G) in
(ct_G.inner_product(char,character_coherent_B(G,ct_G)),
 ct_G.inner_product(char,character_coherent_X(G,ct_G)),
 ct_G.inner_product(char,character_coherent_Y(ct_G,G_dual)),
 ct_G.inner_product(char,character_coherent_I(ct_G)))

set four_inner_products(RealForm G,CharacterTable ct_G,[[int]] chars)=
for char in chars do four_inner_products(G,ct_G,char) od

set four_inner_products(RealForm G,RealForm G_dual,CharacterTable ct_G,[[int]] chars)=
for char in chars do four_inner_products(G,G_dual,ct_G,char) od

{_sgn version shouldn't be necessary, here for historical/debugging
 reasons, not called}
set four_inner_products_sgn(RealForm G,CharacterTable ct_G,[int] char_G)=
let (valid,M)=root_permutation(G,ct_G.root_datum) then
char_G_sgn=ct_G.tensor_sign(char_G) then
char=assert(valid,"root data are not locally isomorphic");permute_character(M,ct_G,char_G_sgn) in
(ct_G.inner_product(char,character_coherent_B(G,ct_G)),
 ct_G.inner_product(char,character_coherent_X(G,ct_G)),
 ct_G.inner_product(char,character_coherent_Y(G,ct_G)),
 ct_G.inner_product(char,character_coherent_I(ct_G)))

set four_inner_products_sgn(RealForm G,CharacterTable ct_G,[[int]] chars)=
for char in chars do four_inner_products_sgn(G,ct_G,char) od

{
set four_inner_products_special(RealForm G,SpringerTable st_G)=
let chars=special_representations(st_G) in
four_inner_products(G,st_G.ct,for j in chars do st_G.ct.tensor_sign(st_G.ct.characters[j]) od)
}
{set four_inner_products_all(RealForm G,SpringerTable st_G)=
four_inner_products(G,st_G.ct,for j:st_G.ct.n_classes do  st_G.ct.tensor_sign(st_G.ct.characters[j]) od)
}

set special_characters(SpringerTable st)=[[int]]: for orbit in st.special_orbits do st.ct.characters[st.springer(orbit)] od

set show_big_table(RealForm G,CharacterTable ct_G)=
let all=four_inner_products(G,ct_G,ct_G.characters) in
prints("i: #of character of W",new_line,
"dim: dim(sigma)",new_line, "deg: degree(sigma)", new_line,
 "gdeg: generic degree(sigma)", new_line,
"mult of sigma in B,X,Y,I",new_line);
tabulate(
["i","dim","deg", "gdeg","B","X","Y","I"]#
for i:ct_G.n_classes do let (a,b,bprime,c)=all[i] in
[i.to_string,
dimension(ct_G,i).to_string,
ct_G.degree(i).to_string,
{if #ct_G.fake_degrees>0 then }ct_G.generic_degree(i).to_string {else "" fi},
a.to_string,b.to_string,bprime.to_string,c.to_string] od)

set show_big_table(RealForm G)=show_big_table(G,G.character_table)

set show_four_inner_products_special(RealForm G,SpringerTable st_G,SpringerTable st_G_v)=
let tip=four_inner_products(G,st_G.ct,st_G.special_characters) then   {orbits indexed by special orbits in G}
other=four_inner_products(G,st_G.ct,lusztig_cells_characters_special(G,st_G,st_G_v))  {for each orbit mult((sum over Lusztig left cell),BXYI)} then
lusztig_cells=lusztig_cells(G,st_G,st_G_v) then
(indices,orbits)=st_G.special_orbits_indexed in
prints(new_line,"Table of inner products for G=", G,new_line,"#: number of special orbit O_v of G^v in list of all orbits",new_line,
"diag: diagram of orbit O_v",new_line,
"dim: dimension of special representation",new_line,
"deg: degree of special representation",new_line,
"bxyi: multiplicity of special in coherent continuation representations B,X,Y,I",new_line,
"BXYI: inner product of Lusztig left cell character with coherent continuation representations B,X,Y,I");
tabulate( ["#O^v","diag","dim","deg","fdeg","sigma","sigma*sgn","b","x","y","i", "B", "X","Y", "I"]#
 for i:#indices do let (a,b,bprime,c)=tip[i] then (d,e,eprime,f)=other[i] then
  j=indices[i] in
 [j.to_string,
  st_G.dual_map(st_G.special_orbits[i]).diagram.to_string,
  {st_G_v.orbits[j].diagram.to_string,}{wrong order}
  dimension(st_G.ct,lusztig_cells[i][0]).to_string,
  st_G.ct.degree(lusztig_cells[i][0]).to_string,
  {if #st_G.fake_degrees>0 then} (st_G.ct.generic_degree(i)).to_string {else "" fi},
  lusztig_cells[i].to_string,
  (for a in lusztig_cells[i] do st_G.ct.tensor_sign_index(a) od).to_string,
  a.to_string,b.to_string,bprime.to_string,c.to_string, d.to_string,e.to_string,eprime.to_string,f.to_string] od);
  prints(new_line,"Springer table of G_^v:");show_reps(st_G_v);
  prints(new_line,"Springer table of G:");show_reps(st_G);
  prints(new_line,"Orbits for G:");show_long(st_G);
  prints(new_line,"lusztig cells for G:"); show_lusztig_cells(G,st_G,st_G_v);
  prints(new_line,"full decomposition of BXYI: ");show_big_table(G,st_G.ct)

set show_four_inner_products_special(RealForm G,RealForm G_dual,SpringerTable st_G,SpringerTable st_G_v)=
let tip=four_inner_products(G,G_dual,st_G.ct,st_G.special_characters) then   {orbits indexed by special orbits in G}
other=four_inner_products(G,G_dual,st_G.ct,lusztig_cells_characters_special(G,st_G,st_G_v))  {for each orbit mult((sum over Lusztig left cell),BXYI)} then
()=prints("tip: ", tip, new_line, "other: ", other) then
lusztig_cells=lusztig_cells(G,st_G,st_G_v) then
(indices,orbits)=st_G.special_orbits_indexed in
prints(new_line,"Table of inner products for G=", G,new_line,"#: number of special orbit O_v of G^v in list of all orbits",new_line,
"diag: diagram of orbit O_v",new_line,
"dim: dimension of special representation",new_line,
"deg: degree of special representation",new_line,
"bxyi: multiplicity of special in coherent continuation representations B,X,Y,I",new_line,
"BXYI: inner product of Lusztig left cell character with coherent continuation representations B,X,Y,I");
tabulate( ["#O^v","diag","dim","deg","fdeg","sigma","sigma*sgn","b","x","y","i", "B", "X","Y", "I"]#
 for i:#indices do let (a,b,bprime,c)=tip[i] then (d,e,eprime,f)=other[i] then
  j=indices[i] in
 [j.to_string,
  st_G.dual_map(st_G.special_orbits[i]).diagram.to_string,
  {st_G_v.orbits[j].diagram.to_string,}{wrong order}
  dimension(st_G.ct,lusztig_cells[i][0]).to_string,
  st_G.ct.degree(lusztig_cells[i][0]).to_string,
  {if #st_G.fake_degrees>0 then} st_G.ct.generic_degree(i).to_string {else "" fi},
  lusztig_cells[i].to_string,
  (for a in lusztig_cells[i] do st_G.ct.tensor_sign_index(a) od).to_string,
  a.to_string,b.to_string,bprime.to_string,c.to_string, d.to_string,e.to_string,eprime.to_string,f.to_string] od);
  prints(new_line,"Springer table of G_^v:");show_reps(st_G_v);
  prints(new_line,"Springer table of G:");show_reps(st_G);
  prints(new_line,"Orbits for G:");show_long(st_G);
  prints(new_line,"lusztig cells for G:"); show_lusztig_cells(G,st_G,st_G_v);
  prints(new_line,"full decomposition of BXYI: ");show_big_table(G,st_G.ct)

set show_four_inner_products_special(RealForm G)=void:
let st=G.springer_table in
update_generic_degrees(st.ct,G);
show_four_inner_products_special(G,st, G.dual.springer_table)

set show_four_inner_products_special(RealForm G,RealForm G_dual)=void:
let st=G.springer_table in
update_generic_degrees(st.ct,G);
show_four_inner_products_special(G,G_dual,st, G.dual.springer_table)



{
set g(RealForm G,CharacterTable ct_G,[Param] parameters)=g(G,ct_G,parameters,G.dual_special_orbits)

set g(RealForm G)=
g(G,G.character_table,all_parameters_gamma(G,rho(G)),G.dual_special_orbits)
}
{note st_G here not ct_G}
set show_lusztig_sommers_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
let ct_G=st_G.ct then
()=prints("O^v: orbit for dual",new_line,"M: (small) pseudo_levi",
new_line, "H_M: H for orbit in M",new_line,
"v: exp(2\pi iv) in center of M",new_line,
"L: centralizer of exp(2\pi iv)",new_line,
"j_L: index of W-representation sigma_L given by Lusztig algorithm",new_line,
"dim/deg: dimension/degree of this character",new_line,
"O_L: sigma_L=Springer(O_L) (blank if sigma_L is not a Springer representation)",
"j_S: index of W-representation given by Sommers algorithm",new_line,
"dim/deg: dimension/degree of this character",new_line,
"O_S: sigma_S=Springer(O_S) (blank if sigma_S is not a Springer representation",
"=: Lusztig and Sommers give same result") then
()=prints("G=", G.nice_format, new_line, "#orbits: ", #dual_orbits) in
tabulate(
["O^v","dim","i","M","H_M","v","L_v","O_L_v","j_L","dim","deg","O_L","j_S","dim","deg","O_S","="]#
##for O_v@counter in dual_orbits do
  let ()=prints("orbit ",counter,": ", O_v.root_datum.nice_format,
        " H=", O_v.H, " diagram=", O_v.diagram, " normalized diagram=", O_v.diagram_normalized) in
  let data=
  for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
    let (j_L,j_S,O_L_v)=sigma_L_S(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) in (M_v,H_M_v,O_L_v,y,j_L,j_S)
  od
  in
  for i:#data do
   let (M_v,H_M_v,O_L_v,y,j_L,j_S)=data[i] then
   sigma_L=ct_G.characters[j_L] then
   sigma_S=ct_G.characters[j_S] in
   [O_v.diagram.to_string+st_G_v.special_star(O_v),
    O_v.dim_nilpotent.to_string,
    i.to_string,
    M_v.nice_format,
    H_M_v.compact_ratvec,
    y.compact_ratvec,
    O_L_v.root_datum.nice_format,
    O_L_v.diagram.to_string,
    j_L.to_string,
    dimension(ct_G,j_L).to_string,
    ct_G.degrees[j_L].to_string,
    let (valid,orbit)=st_G.springer_inverse(j_L) in if valid then orbit.diagram.to_string+st_G.special_star(orbit) else "*" fi,
    j_S.to_string,
    dimension(ct_G,j_S).to_string,
    ct_G.degrees[j_S].to_string,
    let (valid,orbit)=st_G.springer_inverse(j_S) in if valid then orbit.diagram.to_string+st_G.special_star(orbit) else "*" fi,
    if j_L=j_S then "=" else "" fi
]
  od  {/for i:#data}
 od {for O_v})

set show_lusztig_sommers_cells(
 RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=void:
  show_lusztig_sommers_cells(G,st_G,st_G_v,G.dual_orbits)

set show_lusztig_sommers_cell(RootDatum G,SpringerTable st_G,SpringerTable st_G_v,ComplexNilpotent dual_orbit)=void:
 show_lusztig_sommers_cells(G,st_G,st_G_v,[dual_orbit])
set show_lusztig_sommers_cell(RootDatum G, SpringerTable st_G,ComplexNilpotent O_v)=void:show_lusztig_sommers_cell(G,st_G,G.dual.springer_table,O_v)

{set show_lusztig_sommers_cell(RootDatum G, ComplexNilpotent O_v)=void:show_lusztig_sommers_cell(G,G.character_table,G.dual.springer_table,O_v)
set show_lusztig_sommers_cell(ComplexNilpotent O_v)=void:show_lusztig_sommers_cell(O_v.root_datum.dual,O_v)

set show_lusztig_sommers_cells(RootDatum G,SpringerTable st_G)=void:show_lusztig_sommers_cells(G,st_G,G.dual.springer_table,G.dual_orbits)
}
set show_lusztig_sommers_cells(RootDatum G)=void:show_lusztig_sommers_cells(G,G.springer_table,G.dual.springer_table,G.dual_orbits)
