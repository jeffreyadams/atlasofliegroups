{the Lusztig map goes from triples (O^v,x,xi) to W^
 this file implements an algorithm (conjectural)
 to implement this when xi=1
 the set obtained for fixed O^v, running over x,
 is a Lusztig (left) cell
}
<coherent_characters.at
<truncated_induction.at
<isomorphism_W.at
<fake_degrees.at

{sigma_L (L stands for "Lusztig")
sigma_L(O^v,x) is a of a representation of W(G)
conjecturally it is the same as
Lusztig(O^v,x,1) as defined in the Orange book, this also
}

{G G^v, O^v = special orbit for G^vee, x\in A-bar(O^v)
M=M(A-bar(O^v)): pairs defined by Lusztig
xi an irreducible representation of Cent_{A-bar(O^v)}(x)
(O^v,x,xi)  -- Lusztig -->  W(G)^

generalization of Springer map

(O^v,1,1) -> Springer(O^v)  Springer corresdponence for G^v
          -> Springer(O^v)\otimes sign \in W(G^v)^
	  -> W(G)^ via the isomorphism W(G^v)\simeq W(G)

More general case:
(O^v,x,1)  -> L_x^v=Cent_{G^v}(x)^0
	   -> O_L_x^v (same H)
	   -> Springer(O_L_x^v)\otimes sgn in W(L_x^v)^   [NOT the same as Sommers: Springer(dual(O_L_x^v)]
	   -> sigma_L_x\in W(L_x) via W(L_x)^v\simeq W(L_x_v)
	   -> truncated induction from W(L_x) to W(G)

Note: this O_L_x^v might not be special, so Springer(dual(orbit)) \ne Springer(orbit)*sign

Non-trivial \xi not yet considered
}

{Example: O^v=0-orbit, x=1
L_x_v=G_v, O_L_x_v=0-orbit of G^v
Springer(O_L_x_v)=sign of W(G^)
\otimes sgn=trivial of
}
set sigma_L_verbose=false

{main algorithm for computing sigma_L, this won't usually be called by the user
 M_v is a pseudo-Levi
 H_M_v is (the ss element of) an orbit for M_v
 exp(2pi i y) is an element of center of M^0
 typically (M_v,H_M_v,y) are provided by component_datum@ComplexNilpotent
}
{arguments:
 G given group with its coordinate, need this to compute roots of L in G
 G.ct is needed to compute truncated induction/exchange_long_short
 L_v.st is needed to compute Springer(O_L_v)  (L_v=centralizer of y on dual side, L=dual(L_v))
 O_v: given orbit on the dual side
 M_v: pseudo-Levi in which exp(2\pi iy) is central
  (this isn't really needed but is helpful information)
 H_M_v: ss element for orbit of M_v
 y: x=exp(2\pi iy)
 note that L_v depends on y
}
{Lusztig only}
set sigma_L(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v,RootDatum M_v,vec H_M_v,ratvec y)=
{variant: add center of M_v to y}
let ()=if sigma_L_verbose then
   prints("Computing sigma_L: ",new_line,
   "G=", G,new_line, "st_G_v: ", st_G_v.root_datum, new_line,"M_v=", M_v, new_line, "H_M_v=",H_M_v,new_line,"y=", y) fi
in if y.is_integer then  {L_v=G_v, L=G, don't need induction}
 let ()=if sigma_L_verbose then prints("y is integer, no induction")  fi then
 sigma_v=st_G_v.ct.characters[st_G_v.springer(O_v)] then
 ()=if sigma_L_verbose then prints("sigma_v (no induction): ", sigma_v) fi  then
 sigma= exchange_long_short(ct_G,st_G_v.ct.tensor_sign(sigma_v)) then
 ()=if sigma_L_verbose then prints("exchange/tensor sign: ", sigma) fi in 
 ct_G.character_index(sigma)
else  {need induction; compute L, sigma_L, truncated_induce}
 let ()=if sigma_L_verbose then prints("need induction: ")  fi in
 let G_v=O_v.root_datum then
 ()=if sigma_L_verbose then prints(("y=",y) ) fi then
 L_v=centralizer(G_v,y) then
 ()=if sigma_L_verbose then prints(("L_v=",L_v, new_line, "G_v=", G_v) ) fi then
 {O_M_v=ComplexNilpotent:(M_v,(),H_M_v) -> saturation -> O_L_v
  O_L_v has the same H=H_M_v, but made L_v-dominant}
 H_L_v=dominant(H_M_v,L_v) then
 O_L_v=ComplexNilpotent:(L_v,(),H_L_v) then
 ()=if sigma_L_verbose
   then prints(("L_v=", L_v,new_line,"H_L_v=", H_L_v,new_line,"O_L_v:", O_L_v.H, " ", O_L_v.diagram) ) fi then
 L=dual(L_v) then
 roots_L=for alpha in L.simple_roots do find(G.roots,alpha) od then
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
 sigma_L=
 if O_L_v=L_v.zero_orbit then   L.character_table.trivial
 elif O_L_v=L_v.principal_orbit then L.character_table.sign
 else  {not 0 or principal orbit: need to compute L.springer_table}
  let ()=if sigma_L_verbose then prints(("computing st_L_v:") ) fi then
  st_L_v=L_v.springer_table then
  ()=if sigma_L_verbose then prints(("done computing L_v.springer_table") ) fi then
  sigma_L_v=st_L_v.springer(O_L_v) then
  char=st_L_v.ct.characters[sigma_L_v] then
  sigma_L_0=st_L_v.ct.tensor_sign(char) then
  ex=exchange_long_short(L_v.character_table,sigma_L_0) in
  let ()=if sigma_L_verbose then prints("sigma_L_v: ", sigma_L_v, new_line, "char: ", char, new_line, "sigma_L_0: ", sigma_L_0, new_line,
  "ex: ", ex) fi in ex
 fi  {end if O_L_v=L_v.zero_orbit} then
 {now induce sigma_L}
 ()=    assert(#(ct_G.fake_degrees)>0,"need to compute fake degrees (ct:=update_fake_degrees(G,ct) or st:=update_fake_degrees(G,st)") then
  degree_function(int j)=ct_G.fake_degrees[j] then
  ind=induce_character(G,ct_G,roots_L,sigma_L) then
  char_indices=truncate_induce_character(G,ct_G,roots_L,sigma_L,degree_function) then
 ()=if sigma_L_verbose then  prints("O_v: ", O_v.diagram, new_line,"L_v: ", L_v,new_line,"O_L_v: ", O_L_v.diagram,new_line,"sigma_L: ", sigma_L,new_line);
    prints("induced char: ", ind,new_line, "decomposition:", ct_G.decompose(ind));ct_G.view_char(ind);
    prints("minimal degree terms in induced: ", char_indices) fi then
 ()=if sigma_L_verbose then prints("truncated induce (sigma_L): ", "G=",G,new_line,"roots_L: ", roots_L, " sigma_L=", sigma_L) fi then
 char_L=ct_G.characters[char_indices[0]] then
 ()=if sigma_L_verbose then prints("character of L: ", char_indices[0], new_line, char_L) fi in
 ct_G.character_index(char_L)
fi  {end if y.is_integer}


{-------------------------------------------------------------------}
{Lusztig and Sommers version}
{also return: O_L_v}
set sigma_L_S(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v,RootDatum M_v,vec H_M_v,ratvec y)=(int,int,ComplexNilpotent):
{variant: add center of M_v to y}
let ()=if sigma_L_verbose then
   prints("Computing sigma_L: ",new_line,
   "G=", G, "st_G_v: ",new_line, st_G_v.root_datum, new_line,"M_v=", M_v, new_line, "H_M_v=",H_M_v,new_line,"y=", y) fi
in if y.is_integer then  {L_v=G_v, L=G, don't need induction}
 let ()=if sigma_L_verbose then prints("y is integer, no induction")  fi then
 sigma_v=st_G_v.ct.characters[st_G_v.springer(O_v)] then
 sigma= exchange_long_short(ct_G,st_G_v.ct.tensor_sign(sigma_v)) then
 char= ct_G.character_index(sigma) in
 (char,char,O_v)  {sigma_L=sigma_S=char}
else  {need induction; compute L, sigma_L, truncated_induce}
 let ()=if sigma_L_verbose then prints("need induction: ")  fi in
 let G_v=O_v.root_datum then
 ()=if sigma_L_verbose then prints(("y=",y) ) fi then
 L_v=centralizer(G_v,y) then
 ()=if sigma_L_verbose then prints(("L_v=",L_v, new_line, "G_v=", G_v) ) fi then
 {O_M_v=ComplexNilpotent:(M_v,(),H_M_v) -> saturation -> O_L_v
  O_L_v has the same H=H_M_v, but made L_v-dominant}
 H_L_v=dominant(H_M_v,L_v) then
 O_L_v=ComplexNilpotent:(L_v,(),H_L_v) then
 ()=if sigma_L_verbose
   then prints(("L_v=", L_v,new_line,"H_L_v=", H_L_v,new_line,"O_L_v:", O_L_v.H, " ", O_L_v.diagram) ) fi then
 L=dual(L_v) then
 roots_L=for alpha in L.simple_roots do find(G.roots,alpha) od then
 {avoid computing L.springer_table if orbit_L =0 or principal, only need L.character_table}
 (sigma_L,sigma_sommers)=
 if O_L_v=L_v.zero_orbit then let char=L.character_table.trivial in (char,char)
 elif O_L_v=L_v.principal_orbit then let char=L.character_table.sign in (char,char) {sigma_L=sigma_S}
 else  {not 0 or principal orbit: need to compute L.springer_table}
  (let ()=if sigma_L_verbose then prints(("computing st_L:") ) fi then
  st_L_v=L_v.springer_table then
  ()=if sigma_L_verbose then prints(("done computing L.springer_table") ) fi then
  sigma_L_v=st_L_v.springer(O_L_v) then
  char=st_L_v.ct.characters[sigma_L_v] then
  sigma_L_0=st_L_v.ct.tensor_sign(char) in
  exchange_long_short(L_v.character_table,sigma_L_0),{that's sigma_L}
  {now sigma_sommers}
  let st_L=L.springer_table then
  O_L=st_L.dual_map_i(O_L_v) then
  rv=  st_L.ct.characters[st_L.springer(O_L)] in
  if sigma_L_verbose then
   prints("O_L: ", O_L, " ", O_L.diagram, new_line,"sigma_sommers: ", rv) fi; rv)
 fi  {end if O_L_v=L_v.zero_orbit} in
 {now induce sigma_L and sigma_sommers}
 {sigma_L:}
  (let char_index=truncate_by_degree_induce_character(G,ct_G,roots_L,sigma_L) then
  ()=if sigma_L_verbose then prints("sigma_L: ", sigma_L, "char_index: ", char_index) fi then 
  ()=if sigma_L_verbose then prints("truncated induce (sigma_L): ", "G=",G,new_line,"roots_L: ", roots_L, " sigma_L=", sigma_L) fi then
  char_L=ct_G.characters[char_index] then
  ()=if sigma_L_verbose then prints("character of L: ", char_L) fi in char_index,
  {now sommers:}
   let char_index=truncate_by_degree_induce_character(G,ct_G,roots_L,sigma_sommers) then
  ()=if sigma_L_verbose then prints("sigma_sommers: ", sigma_sommers, "char_index: ", char_index) fi then 
  ()=if sigma_L_verbose then prints("truncated induce (sommers): ", "G=",G,new_line,"roots_L: ", roots_L, " sigma_sommers", sigma_sommers) fi then
   char_sommers=ct_G.characters[char_index] then
   ()=if sigma_L_verbose then prints("character of L: ", char_index, new_line, char_sommers) fi in
{   ct_G.character_index(char_sommers),O_L_v)}
   char_index,O_L_v)
fi  {end if y.is_integer}

{---------------}

{run over all ratvecs from component_representatives(orbit)}
set lusztig_cell(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v)=[int]:
{prints("sigma_L for: ", O_v,"  ", O_v.diagram,new_line, " st_G_v:",st_G_v.root_datum);}
{sort_u: avoid duplicates from A-bar(O_v)\ne A(O_v)}
sort_u(for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
 let ()=if sigma_L_verbose then prints("computing sigma_L for M_v=", M_v, new_line,"H_M_v=",H_M_v,new_line, "y=", y)  fi in
    {let ()=if sigma_L_verbose then prints("calling sigma_L(x):", new_line,"G: ", G, new_line,"O_v: ", O_v.diagram, " ", O_v.dim_nilpotent,
   "st:", st_G_v.root_datum, new_line,"M_v: ", M_v, new_line, "H_M_v", H_M_v, new_line, "y: ", y) fi in}
 sigma_L(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) od)

set lusztig_cell_char(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent O_v)=
sum(for index in lusztig_cell(G,ct_G,st_G_v,O_v) do ct_G.character(index) od)

{some shorthands which are handy but inefficient}
set lusztig_cell(RootDatum G,ComplexNilpotent O_v)=[int]:lusztig_cell(G,G.character_table,O_v.root_datum.springer_table,O_v)
set lusztig_cell(RootDatum G,ComplexNilpotent O_v)=[int]:lusztig_cell(G,G.character_table,O_v.root_datum.springer_table,O_v)
set lusztig_cell(RootDatum G,ComplexNilpotent O_v)=[int]:lusztig_cell(G,G.character_table,O_v.root_datum.springer_table,O_v)
set lusztig_cell(RootDatum G,CharacterTable ct_G,ComplexNilpotent O_v)=[int]:lusztig_cell(G,ct_G,G.dual.springer_table,O_v)

{Caution: we need to run over special orbits of G and/or G^v,
 and keep track of the permutation given by duality}

{lusztig cells are parametrized by dual special orbits, but parametrized
 by G.special_orbits}
set lusztig_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=[[int]]:
 for O in st_G.special_orbits do
  let O_dual=st_G.dual_map(O) then
  O_v=orbit_by_diagram(G.dual,O_dual.diagram_normalized) then
  ()=if sigma_L_verbose then prints(new_line,"-----------------------------------------------",new_line,"computing Lusztig cell of dual orbit: ",O_v.diagram, " ", O_v.dim_nilpotent) fi in
  lusztig_cell(G,st_G.ct,st_G_v,O_v) od

{show lusztig cells, running over given list of dual nilpotents}
set show_lusztig_cells(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
prints("G=", G.nice_format, new_line, "#orbits: ", #dual_orbits);
tabulate(
["O^v","dim","i","rd_int","M","H_M","v","L","sigma","dim","deg","fdeg","char"]#
##for O_v@counter in dual_orbits do
  let ()=prints("orbit ",counter,": ", O_v.root_datum.nice_format,
        " H=", O_v.H, " diagram=", O_v.diagram, " normalized diagram=", O_v.diagram_normalized) in
  let data=
  for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
    let j=sigma_L(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) in  (M_v,H_M_v,y,j)
  od
  in
  for i:#data do
   let (M_v,H_M_v,y,j)=data[i] then
   sigma=ct_G.characters[j] in
   [O_v.diagram.to_string,
    O_v.dim_nilpotent.to_string,
    i.to_string,
    integrality_datum(O_v).nice_format,
    M_v.nice_format,
    H_M_v.compact_ratvec,
    y.compact_ratvec,
    centralizer(G,y).nice_format,
    "sigma="+j.to_string,
    ct_G.dimension(j).to_string,
    ct_G.degrees[j].to_string,
    if #ct_G.fake_degrees>0 then ct_G.fake_degrees[j].to_string else "" fi,
    sigma.to_string]
  od  {/for i:#data}
 od {for O_v})

set show_lusztig_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
show_lusztig_cells(G,st_G.ct,st_G_v,dual_orbits)

{default: run over dual special orbits, parametrized by dual(special orbits for G)}
set show_lusztig_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=void:
show_lusztig_cells(G,st_G.ct,st_G_v,
for O in st_G.special_orbits do let O_dual=st_G.dual_map(O) in orbit_by_diagram(G.dual,O_dual.diagram_normalized)
od)

{set show_lusztig_cells(RootDatum G)=void:show_lusztig_cells(G,G.springer_table,G.dual.springer_table)}

set show_lusztig_cell(RootDatum G,CharacterTable ct_G,SpringerTable st_G_v,ComplexNilpotent dual_orbit)=void:
 show_lusztig_cells(G,ct_G,st_G_v,[dual_orbit])
set show_lusztig_cell(RootDatum G, CharacterTable ct_G,ComplexNilpotent O_v)=void:show_lusztig_cell(G,ct_G,G.dual.springer_table,O_v)
set show_lusztig_cell(RootDatum G, ComplexNilpotent O_v)=void:show_lusztig_cell(G,G.character_table,G.dual.springer_table,O_v)
set show_lusztig_cell(ComplexNilpotent O_v)=void:show_lusztig_cell(O_v.root_datum.dual,O_v)
set show_lusztig_cells(RootDatum G,CharacterTable ct)=void:show_lusztig_cells(G,ct,G.dual.springer_table,G.dual_orbits)

set show_lusztig_cells(RealForm G)=void:
let st=G.springer_table then
st=update_fake_degrees(G,st)  in
show_lusztig_cells(G,st.ct,G.dual.springer_table,
   for O in st.special_orbits do let O_dual=st.dual_map(O) in orbit_by_diagram(G.dual,O_dual.diagram_normalized) od)


{for convenience:}
set init(RootDatum G)=(CharacterTable,SpringerTable,[ComplexNilpotent]):(G.character_table,G.dual.springer_table,G.dual.orbits)
{
set dual_special_orbits_indexed(RootDatum G,SpringerTable st_G_v)=([int],[ComplexNilpotent]):
special_orbits_indexed(G.dual,st_G_v)
set dual_special_orbits_indexed(RootDatum G)=([int],[ComplexNilpotent]):dual_special_orbits_indexed(G,G.dual.springer_table)
set dual_special_orbits(RootDatum G,SpringerTable st_G_v)=[ComplexNilpotent]:special_orbits(G.dual,st_G_v)
set dual_special_orbits(RootDatum G)=[ComplexNilpotent]:dual_special_orbits(G,G.dual.springer_table)
}

{parametrize by special orbits for G}
set lusztig_cells_characters_special(RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=[[int]]:
for orbit in st_G.special_orbits do lusztig_cell_char(G,st_G.ct,st_G_v,
orbit_by_diagram(G.dual,st_G.dual_map(orbit).diagram_normalized)) od

set four_inner_products(RealForm G,CharacterTable ct_G,[int] char_G)=
let (valid,M)=root_permutation(G,ct_G.root_datum) then
char=assert(valid,"root data are not locally isomorphic");permute_character(M,ct_G,char_G) in
(ct_G.inner_product(char,character_coherent_B(G,ct_G)),
 ct_G.inner_product(char,character_coherent_X(G,ct_G)),
 ct_G.inner_product(char,character_coherent_Y(G,ct_G)),
 ct_G.inner_product(char,character_coherent_I(ct_G)))

set four_inner_products(RealForm G,RealForm G_dual,CharacterTable ct_G,[int] char_G)=
let (valid,M)=root_permutation(G,ct_G.root_datum) then
char=assert(valid,"root data are not locally isomorphic");permute_character(M,ct_G,char_G) in
(ct_G.inner_product(char,character_coherent_B(G,ct_G)),
 ct_G.inner_product(char,character_coherent_X(G,ct_G)),
 ct_G.inner_product(char,character_coherent_Y(ct_G,G_dual)),
 ct_G.inner_product(char,character_coherent_I(ct_G)))

set four_inner_products(RealForm G,CharacterTable ct_G,[[int]] chars)=
for char in chars do four_inner_products(G,ct_G,char) od

set four_inner_products(RealForm G,RealForm G_dual,CharacterTable ct_G,[[int]] chars)=
for char in chars do four_inner_products(G,G_dual,ct_G,char) od

{_sgn version shouldn't be necessary, here for historical/debugging
 reasons, not called}
set four_inner_products_sgn(RealForm G,CharacterTable ct_G,[int] char_G)=
let (valid,M)=root_permutation(G,ct_G.root_datum) then
char_G_sgn=ct_G.tensor_sign(char_G) then
char=assert(valid,"root data are not locally isomorphic");permute_character(M,ct_G,char_G_sgn) in
(ct_G.inner_product(char,character_coherent_B(G,ct_G)),
 ct_G.inner_product(char,character_coherent_X(G,ct_G)),
 ct_G.inner_product(char,character_coherent_Y(G,ct_G)),
 ct_G.inner_product(char,character_coherent_I(ct_G)))

set four_inner_products_sgn(RealForm G,CharacterTable ct_G,[[int]] chars)=
for char in chars do four_inner_products_sgn(G,ct_G,char) od

{
set four_inner_products_special(RealForm G,SpringerTable st_G)=
let chars=special_representations(st_G) in
four_inner_products(G,st_G.ct,for j in chars do st_G.ct.tensor_sign(st_G.ct.characters[j]) od)
}
{set four_inner_products_all(RealForm G,SpringerTable st_G)=
four_inner_products(G,st_G.ct,for j:st_G.ct.n_classes do  st_G.ct.tensor_sign(st_G.ct.characters[j]) od)
}

set special_characters(SpringerTable st)=[[int]]: for orbit in st.special_orbits do st.ct.characters[st.springer(orbit)] od

set show_big_table(RealForm G,CharacterTable ct_G)=
let all=four_inner_products(G,ct_G,ct_G.characters) in
prints("i: #of character of W",new_line,
"dim: dim(sigma)",new_line, "deg: degree(sigma)", new_line,
 "fdeg: fake degree(sigma)", new_line,
"mult of sigma in B,X,Y,I",new_line);
tabulate(
["i","dim","deg", "fdeg","B","X","Y","I"]#
for i:ct_G.n_classes do let (a,b,bprime,c)=all[i] in
[i.to_string,
ct_G.dimension(i).to_string,
ct_G.degree(i).to_string,
if #ct_G.fake_degrees>0 then ct_G.fake_degrees[i].to_string else "" fi,
a.to_string,b.to_string,bprime.to_string,c.to_string] od)

set show_big_table(RealForm G)=show_big_table(G,G.character_table)

set show_four_inner_products_special(RealForm G,SpringerTable st_G,SpringerTable st_G_v)=
let tip=four_inner_products(G,st_G.ct,st_G.special_characters) then   {orbits indexed by special orbits in G}
other=four_inner_products(G,st_G.ct,lusztig_cells_characters_special(G,st_G,st_G_v))  {for each orbit mult((sum over Lusztig left cell),BXYI)} then
lusztig_cells=lusztig_cells(G,st_G,st_G_v) then
(indices,orbits)=st_G.special_orbits_indexed in
prints(new_line,"Table of inner products for G=", G,new_line,"#: number of special orbit O_v of G^v in list of all orbits",new_line,
"diag: diagram of orbit O_v",new_line,
"dim: dimension of special representation",new_line,
"deg: degree of special representation",new_line,
"bxyi: multiplicity of special in coherent continuation representations B,X,Y,I",new_line,
"BXYI: inner product of Lusztig left cell character with coherent continuation representations B,X,Y,I");
tabulate( ["#O^v","diag","dim","deg","fdeg","sigma","sigma*sgn","b","x","y","i", "B", "X","Y", "I"]#
 for i:#indices do let (a,b,bprime,c)=tip[i] then (d,e,eprime,f)=other[i] then
  j=indices[i] in
 [j.to_string,
  st_G.dual_map(st_G.special_orbits[i]).diagram.to_string,
  {st_G_v.orbits[j].diagram.to_string,}{wrong order}
  st_G.ct.dimension(lusztig_cells[i][0]).to_string,
  st_G.ct.degree(lusztig_cells[i][0]).to_string,
  if #st_G.fake_degrees>0 then st_G.fake_degrees[i].to_string else "" fi,
  lusztig_cells[i].to_string,
  (for a in lusztig_cells[i] do st_G.ct.tensor_sign_index(a) od).to_string,
  a.to_string,b.to_string,bprime.to_string,c.to_string, d.to_string,e.to_string,eprime.to_string,f.to_string] od);
  prints(new_line,"Springer table of G_^v:");show_reps(st_G_v);
  prints(new_line,"Springer table of G:");show_reps(st_G);
  prints(new_line,"Orbits for G:");show_long(st_G);
  prints(new_line,"lusztig cells for G:"); show_lusztig_cells(G,st_G,st_G_v);
  prints(new_line,"full decomposition of BXYI: ");show_big_table(G,st_G.ct)

set show_four_inner_products_special(RealForm G,RealForm G_dual,SpringerTable st_G,SpringerTable st_G_v)=
let tip=four_inner_products(G,G_dual,st_G.ct,st_G.special_characters) then   {orbits indexed by special orbits in G}
other=four_inner_products(G,G_dual,st_G.ct,lusztig_cells_characters_special(G,st_G,st_G_v))  {for each orbit mult((sum over Lusztig left cell),BXYI)} then
()=prints("tip: ", tip, new_line, "other: ", other) then
lusztig_cells=lusztig_cells(G,st_G,st_G_v) then
(indices,orbits)=st_G.special_orbits_indexed in
prints(new_line,"Table of inner products for G=", G,new_line,"#: number of special orbit O_v of G^v in list of all orbits",new_line,
"diag: diagram of orbit O_v",new_line,
"dim: dimension of special representation",new_line,
"deg: degree of special representation",new_line,
"bxyi: multiplicity of special in coherent continuation representations B,X,Y,I",new_line,
"BXYI: inner product of Lusztig left cell character with coherent continuation representations B,X,Y,I");
tabulate( ["#O^v","diag","dim","deg","fdeg","sigma","sigma*sgn","b","x","y","i", "B", "X","Y", "I"]#
 for i:#indices do let (a,b,bprime,c)=tip[i] then (d,e,eprime,f)=other[i] then
  j=indices[i] in
 [j.to_string,
  st_G.dual_map(st_G.special_orbits[i]).diagram.to_string,
  {st_G_v.orbits[j].diagram.to_string,}{wrong order}
  st_G.ct.dimension(lusztig_cells[i][0]).to_string,
  st_G.ct.degree(lusztig_cells[i][0]).to_string,
  if #st_G.fake_degrees>0 then st_G.fake_degrees[i].to_string else "" fi,
  lusztig_cells[i].to_string,
  (for a in lusztig_cells[i] do st_G.ct.tensor_sign_index(a) od).to_string,
  a.to_string,b.to_string,bprime.to_string,c.to_string, d.to_string,e.to_string,eprime.to_string,f.to_string] od);
  prints(new_line,"Springer table of G_^v:");show_reps(st_G_v);
  prints(new_line,"Springer table of G:");show_reps(st_G);
  prints(new_line,"Orbits for G:");show_long(st_G);
  prints(new_line,"lusztig cells for G:"); show_lusztig_cells(G,st_G,st_G_v);
  prints(new_line,"full decomposition of BXYI: ");show_big_table(G,st_G.ct)

set show_four_inner_products_special(RealForm G)=void:
let st_0=G.springer_table then
st=update_fake_degrees(G,st_0) in
show_four_inner_products_special(G,st, G.dual.springer_table)

set show_four_inner_products_special(RealForm G,RealForm G_dual)=void:
let st_0=G.springer_table then
st=update_fake_degrees(G,st_0) in
show_four_inner_products_special(G,G_dual,st, G.dual.springer_table)



{
set g(RealForm G,CharacterTable ct_G,[Param] parameters)=g(G,ct_G,parameters,G.dual_special_orbits)

set g(RealForm G)=
g(G,G.character_table,all_parameters_gamma(G,rho(G)),G.dual_special_orbits)
}
{note st_G here not ct_G}
set show_lusztig_sommers_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v,[ComplexNilpotent] dual_orbits)=void:
let ct_G=st_G.ct then
()=prints("O^v: orbit for dual",new_line,"M: (small) pseudo_levi",
new_line, "H_M: H for orbit in M",new_line,
"v: exp(2\pi iv) in center of M",new_line,
"L: centralizer of exp(2\pi iv)",new_line,
"j_L: index of W-representation sigma_L given by Lusztig algorithm",new_line,
"dim/deg: dimension/degree of this character",new_line,
"O_L: sigma_L=Springer(O_L) (blank if sigma_L is not a Springer representation)",
"j_S: index of W-representation given by Sommers algorithm",new_line,
"dim/deg: dimension/degree of this character",new_line,
"O_S: sigma_S=Springer(O_S) (blank if sigma_S is not a Springer representation",
"=: Lusztig and Sommers give same result") then
()=prints("G=", G.nice_format, new_line, "#orbits: ", #dual_orbits) in
tabulate(
["O^v","dim","i","M","H_M","v","L_v","O_L_v","j_L","dim","deg","O_L","j_S","dim","deg","O_S","="]#
##for O_v@counter in dual_orbits do
  let ()=prints("orbit ",counter,": ", O_v.root_datum.nice_format,
        " H=", O_v.H, " diagram=", O_v.diagram, " normalized diagram=", O_v.diagram_normalized) in
  let data=
  for (M_v,H_M_v,y) in component_representatives_plus(O_v) do
    let (j_L,j_S,O_L_v)=sigma_L_S(G,ct_G,st_G_v,O_v,M_v,H_M_v,y) in (M_v,H_M_v,O_L_v,y,j_L,j_S)
  od
  in
  for i:#data do
   let (M_v,H_M_v,O_L_v,y,j_L,j_S)=data[i] then
   sigma_L=ct_G.characters[j_L] then
   sigma_S=ct_G.characters[j_S] in
   [O_v.diagram.to_string+st_G_v.special_star(O_v),
    O_v.dim_nilpotent.to_string,
    i.to_string,
    M_v.nice_format,
    H_M_v.compact_ratvec,
    y.compact_ratvec,
    O_L_v.root_datum.nice_format,
    O_L_v.diagram.to_string,
    j_L.to_string,
    ct_G.dimension(j_L).to_string,
    ct_G.degrees[j_L].to_string,
    let (valid,orbit)=st_G.springer_inverse(j_L) in if valid then orbit.diagram.to_string+st_G.special_star(orbit) else "*" fi,
    j_S.to_string,
    ct_G.dimension(j_S).to_string,
    ct_G.degrees[j_S].to_string,
    let (valid,orbit)=st_G.springer_inverse(j_S) in if valid then orbit.diagram.to_string+st_G.special_star(orbit) else "*" fi,
    if j_L=j_S then "=" else "" fi 
]
  od  {/for i:#data}
 od {for O_v})

set show_lusztig_sommers_cells(RootDatum G,SpringerTable st_G,SpringerTable st_G_v)=void:
show_lusztig_sommers_cells(rd,st_G,st_G_v,G.dual_orbits)

set show_lusztig_sommers_cell(RootDatum G,SpringerTable st_G,SpringerTable st_G_v,ComplexNilpotent dual_orbit)=void:
 show_lusztig_sommers_cells(G,st_G,st_G_v,[dual_orbit])
set show_lusztig_sommers_cell(RootDatum G, SpringerTable st_G,ComplexNilpotent O_v)=void:show_lusztig_sommers_cell(G,st_G,G.dual.springer_table,O_v)

{set show_lusztig_sommers_cell(RootDatum G, ComplexNilpotent O_v)=void:show_lusztig_sommers_cell(G,G.character_table,G.dual.springer_table,O_v)
set show_lusztig_sommers_cell(ComplexNilpotent O_v)=void:show_lusztig_sommers_cell(O_v.root_datum.dual,O_v)

set show_lusztig_sommers_cells(RootDatum G,SpringerTable st_G)=void:show_lusztig_sommers_cells(G,st_G,G.dual.springer_table,G.dual_orbits)
}
set show_lusztig_sommers_cells(RootDatum G)=void:show_lusztig_sommers_cells(G,G.springer_table,G.dual.springer_table,G.dual_orbits)
