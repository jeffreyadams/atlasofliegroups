<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]) }

{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])

Just do this for SIMPLE root datum rd.

One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell

}

{ There are three notions of "facet": a set Facet of affine equalities and
inequalities defining it (NOT UNIQUE); the set FacetV of vertices; and
the barycenter FacetB. I like FacetV the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) bu looking at all
enlargements of the vertex set. Passage from FacetV to FacetB is
trivial (average the vertices) There are functions facet, facetV and
facetB at the end which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum

set aff_rank(SimpleAffine Affd) = ss_rank(Affd) + 1

set_type AffineCoroot = (vec,int)
set *(AffineCoroot (betav,m), ratvec gamma) = m+betav*gamma

{first apply w, then translate by tau}
set_type AffineCoWeylElt = (vec tau, WeylElt w)

set *(AffineCoWeylElt (tau,w) , vec gamma) = w*gamma + tau
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = w*gamma + tau
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = (w1*tau2 +
tau1, w1*w2)
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
(betav*inverse(w), m-(betav*inverse(w))*tau)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
(-inverse(w)*tau, inverse(w))

set aff_simple_coroots(SimpleAffine Affd) = [AffineCoroot]:
for j:Affd.aff_rank do
if j=0 then (-coroot(Affd, highest_short_root(Affd)),1) else
(Affd.simple_coroots[j-1],0) fi od

{compute facet of a point in fundamental alcove, where all positive
roots are in [0,1]}

set labels(SimpleAffine Affd) = [int]:
for j:Affd.aff_rank do
if j=0 then 1 else rat_as_int(Affd.fundamental_weights[j-1] *
coroot(Affd, highest_short_root(Affd))) fi od

set root(AffineCoroot (betav,m),SimpleAffine Affd) = root(Affd,betav)

set *(AffineCoroot (betav,m), vec v) = betav*v + m


set reflection(AffineCoroot Betav, SimpleAffine Affd, vec v) = v -
(Betav*v)*root(Betav,Affd)

set reflection(AffineCoroot Betav, SimpleAffine Affd, ratvec v) =
reflection(Betav, Affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot inequalities and (n-k) AffineCoRoot equalities. The total
collection of affine coroots appearing must be a set of simple roots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE }

set_type Facet = ([AffineCoroot] pos,[AffineCoroot] zero)

{ a UNIQUE characterization of a k-diml facet is as a set of
k+1 vertices }

set_type FacetV = [ratvec]

{ Maybe the smallest UNIQUE characterization is as the barycenter }

set_type FacetB = ratvec

{ computes the Facet of a point gamma0 in the fundamental alcove }
set facet0(SimpleAffine Affd, ratvec gamma0) = Facet:
let S=Affd.aff_simple_coroots in (##for j:Affd.aff_rank do if S[j]*gamma0 != 0
then [S[j]] else [] fi od, ##for j:Affd.aff_rank do if S[j]*gamma0 = 0
then [S[j]] else [] fi od)
set aff_simple_roots(SimpleAffine Affd) = for j:Affd.aff_rank do
if j=0 then -highest_short_root(Affd) else
Affd.simple_roots[j-1] fi od

{ vertices of fundamental alcove }
set fundamental_vertices(SimpleAffine Affd) = [ratvec]:
for j:Affd.aff_rank do 
if j=0 then null(Affd.rank)/1 else
Affd.fundamental_weights[j-1]/Affd.labels[j] fi od

{ computes the FacetV of a point gamma0 in the fundamental alcove }
set facetV0(SimpleAffine Affd, ratvec gamma0) = FacetV:
let S=Affd.aff_simple_coroots, V=fundamental_vertices(Affd) in
##for d:#S do if !=S[d]*gamma0 then [V[d]] else [] fi od

{ computes the FacetB of a point gamma0 in the fundamental alcove }
set facetB0(SimpleAffine Affd, ratvec gamma0) = FacetB:
let Verts = facetV0(Affd,gamma0) in sum(Affd.rank, for v in Verts do v/#Verts
od)

{ list of facets in the fundamental alcove, organized by dimension }
set fund_facets(SimpleAffine Affd) = [[Facet]]:
let n = Affd.aff_rank, Sv = Affd.aff_simple_coroots
then listn = for j:n do j od {, P = power_set(n)} in
for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN} (for j in S
do{TRMSA} Sv[j] od{TRMSA}, for k in complement(n,S) do{TRMSB} Sv[k]
od{TRMSB}) od{BIN} od{DIM}

{ for i:2^n-1 from 1 do (for j in P[i] do Sv[j] od, for
k in complement(n,P[i]) do Sv[k] od) od }

{ barycenters of facets in the fundamental alcove, organized by
dimension }
set fund_barycenters(SimpleAffine Affd) = [[FacetB]]:
let  n = Affd.aff_rank, LAB = Affd.labels,
FWts=Affd.fundamental_weights then listn = for j:n do j od
in for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN} 
sum(n-1, for j in S do{VERT} if j=0 then null(n-1)/1 else
FWts[j-1]/((d+1)*LAB[j]) fi od{VERT}) od{BIN} od{DIM}

{ vertex sets for facets in the fundamental alcove, organized by
dimension }

set fund_vertex_sets(SimpleAffine Affd) = [[FacetV]]:
let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
then listn = for j:n do{DIM} j od
in for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN}
for j in S do{VERTS} Verts[j] od{VERTS} od{BIN} od{DIM}

{ vertices in W*(fundamental alcove) }
set W_fund_vertices(SimpleAffine Affd) = [ratvec]:
## for gamma in fundamental_vertices(Affd) do{VERT} for w in
stabiliser_quotient_of_dominant(Affd,gamma.numer) do{W} w*gamma od{W} od{VERT}

{ barycenters in W*(fundamental alcove), organized by dimension }
set W_fund_barycenters(SimpleAffine Affd) = [[FacetB]]:
for d:Affd.aff_rank do{DIM} ## for gamma in fund_barycenters(Affd)[d]
do{BIN} for w in stabiliser_quotient_of_dominant(Affd,gamma.numer)
do{W} w*gamma od{W} od{BIN} od{DIM}

{ vertex sets for facets in W*(fundamental alcove), organized by
dimension }
set W_fund_vertex_sets(SimpleAffine Affd) = [[FacetV]]:
let n=Affd.aff_rank, Verts = fundamental_vertices(Affd) then listn=for
j:n do j od in
for d:n do{DIM} ## for S in choices_from(listn,d+1) do{BIN} for w in
stabiliser_quotient_of_dominant(Affd, ratvec_as_vec(sum(n-1,for j in S do{VERTS}
Verts[j].numer od{VERTS}))) do{W} for j in S do{VERTS} w*Verts[j] od{VERTS}
od{W} od{BIN} od{DIM}

{ integral weights to be added to gamma to land in fundamental
parallelepiped where all simple coroots take values in [0,1] }
{need to make a list of all possible tau; if g is an integer, use
either -g or -g+1.}

set FPtau(SimpleAffine Affd, ratvec gamma) = [ratvec]: let g=for
j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od then INT =
##for j:#Affd.simple_coroots do if is_integer(g[j]) then [j] else []
fi od in for S in power_set(#INT) do sum(Affd.rank, for
j:#Affd.simple_coroots do -floor(g[j])*Affd.fundamental_weights[j]
od) + sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od) od

{ this includes all vertices of facets in the fundamental
parallelepiped, with repetitions }
set FPP_vertices_rep(SimpleAffine Affd) = [ratvec]:
## for gamma in W_fund_vertices(Affd)
do{WA0} for tau in FPtau(Affd,gamma) do{TAU} gamma+tau od{TAU} od{WA0}

{this eliminates repetition}
set FPP_vertices(SimpleAffine Affd) = [ratvec]:
let longList = FPP_vertices_rep(Affd) in
##for j:#longList do{LIST} if all(for i:j
do{SRCH} longList[i] != longList[j] od{SRCH}) then [longList[j]] else
[] fi od{LIST}

{ this includes all barycenters of facets in the fundamental
parallelepiped, organized by dimension, with repetitions }
set FPP_barycenters_rep(SimpleAffine Affd) = [[FacetB]]:
let WBs = W_fund_barycenters(Affd) in for d:Affd.aff_rank do{DIM} ##
for gamma in WBs[d] do{WA0} for tau in FPtau(Affd,gamma) do{TAU}
gamma+tau od{TAU} od{WA0} od{DIM}

{this eliminates repetition}
set FPP_barycenters(SimpleAffine Affd) = [[FacetB]]:
let FPPBs = FPP_barycenters_rep(Affd) in for d:Affd.aff_rank do{DIM} let
longList = FPPBs[d] in ##for j:#longList do{LIST} if all(for i:j
do{SRCH} longList[i] != longList[j] od{SRCH}) then [longList[j]] else
[] fi od{LIST} od{DIM}

{ vertex sets for all facets in the fundamental parallelepiped,
organized by dimension, with some repetitions }
set FPP_vertex_sets_rep(SimpleAffine Affd) = [[FacetV]]:
let WVs = W_fund_vertex_sets(Affd) in for d:Affd.aff_rank do{DIM}
##for gammas in WVs[d] do{WA0} for tau in FPtau(Affd, sum(Affd.rank,gammas)/(d+1)) do{TAU} for gamma in gammas do{GAM}
gamma+tau od{GAM} od{TAU} od{WA0} od{DIM}

{this eliminates repetition}
set FPP_vertex_sets(SimpleAffine Affd) = [[FacetV]]:
let FPPVs = FPP_vertex_sets_rep(Affd) in for d:Affd.aff_rank do{DIM}
let longList = FPPVs[d] in ##for j:#longList do{LIST} if all(for i:j
do{SRCH} sum(Affd.rank,longList[i]) != sum(Affd.rank,longList[j])
od{SRCH}) then [longList[j]] else [] fi od{LIST} od{DIM}


{ computes vertex list as indices in a pre-computed vertex list }

set facetVnum([ratvec] vert_list, FacetV facet) =
vec:
for gammav in facet do find(vert_list,gammav) od.sort

set FPP_vertex_sets_indices(SimpleAffine Affd,[ratvec] vertex_list) =
[[vec]]:
let FPPV = FPP_vertex_sets(Affd) in for d:Affd.aff_rank do
if d=0 then for j:#FPPV[0] do [j] od else
for facet_V in FPPV[d] do facetVnum(vertex_list,facet_V) od fi od

set FPP_vertex_sets_indices(SimpleAffine Affd) = [[vec]]:
let FPPV = FPP_vertex_sets(Affd) then vertex_list = ##FPPV[0]
in for d:Affd.aff_rank do if d=0 then for j:#FPPV[0] do [j] od else
for facet_V in FPPV[d] do facetVnum(vertex_list,facet_V) od fi od

{ Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove: subtract roots until gamma lands in W*A0 =
set where gamma1 is at most one on every coroot.  Precisely,
gamma - tau(gamma) is in W*(fundamental alcove).

Uses mostly integer arithmetic. First make simple root
coords smaller than 1. }

set TAU(RootDatum rd,ratvec gamma) = vec:
let COROOTS = rd.coroots, ROOTS = rd.roots, gamma0NUM=gamma.numer,
DENOM = gamma.denom, m0= 0, q0=0 then d=#COROOTS in if d!=0
then for j:#rd.fundamental_coweights do let (num,den) =
(rd.fundamental_coweights[j].numer, rd.fundamental_coweights[j].denom) in
gamma0NUM := (gamma0NUM -
( ( ( num*gamma0NUM )\(DENOM*den))*DENOM*den)*rd.simple_roots[j]) od;
while (m0:=max_loc(for j:d do COROOTS[d-j-1]*gamma0NUM od); (q0:=
COROOTS[d-m0-1]*gamma0NUM; q0 > DENOM)) do gamma0NUM:= gamma0NUM -
ceil(q0/(2*DENOM))*DENOM*ROOTS[d-m0-1] od fi;
(gamma-gamma0NUM/DENOM).ratvec_as_vec

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) = (AffineCoWeylElt,
ratvec): let tau = TAU(rd,gamma) then (w,gamma0TIMESDEN) = from_dominant
(rd,gamma.numer - gamma.denom*tau) in
{assert (gamma=w*gamma0 + tau,"Bad affine!");}
((tau,w),gamma0TIMESDEN/gamma.denom)

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }

set facet(SimpleAffine Affd, ratvec gamma) = Facet:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) then
(F0pos,F0zero) = facet0(Affd,gamma0) in (for betav in F0pos
do wtilde*betav od , for betav in F0zero
do wtilde*betav od)

{ computes the FacetB of any ratvec }

set facetB(SimpleAffine Affd, ratvec gamma) = FacetB:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) in
wtilde*facetB0(Affd,gamma0) 

{ computes the FacetV (vertex set) of any ratvec }

set facetV(SimpleAffine Affd, ratvec gamma) = FacetV:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) then
Verts = facetV0(Affd,gamma0) in for gamma0v in Verts
do wtilde*gamma0v od

{ meant to record information about unitarity for all facets }
set facet_status([[ratvec]] FPPB) = [[string]]:
for d:#FPPB do for j:#FPPB[d] do "?" od od

{ meant to update facet unitarity status by testing a point in each
alcove }
set new_statusALC(RealForm G, [[ratvec]] FPPB,
[[vec]] FPPind,  [[string]] status) = [[string]]: 
let D = #status-1, new_status = status in for
j:#status[D] do{ALC} 
let result = if status[D][j] != "?" then status[D][j] else
if(is_unitary(parameter(x_open(G), G.rho,FPPB[D][j]))) then "T" else
"F" fi fi then nsD = new_status[D] in nsD[j] := result;
new_status[D]:= nsD; if result="T"
then for d:D  do{DIMS} let nsd = new_status[d] in for k:#nsd do{FAC}
if  is_subset_of_sorted(FPPind[D][j])(FPPind[d][k]) then
nsd[k] := "T"  fi od{FAC}; new_status[d] := nsd od{DIMS} fi od{ALC};
new_status

{ meant to update facet unitarity status by testing each vertex }
set new_statusVERT(RealForm G, [[ratvec]] FPPB,
[[vec]] FPPind, [[string]] status) = [[string]]:
let D = #status-1, new_status = status in for
j:#status[0] do{ALC} 
let result = if status[0][j] != "?" then status[0][j] else
if(is_unitary(parameter(x_open(G), G.rho,FPPB[0][j])))
then  "T" else "F" fi fi then ns0 = new_status[0] in ns0[j] := result;
new_status[0]:= ns0; if result="F"
then for d:D from 1  do{DIMS} let nsd = new_status[d] in for k:#nsd
do{FAC} if  is_subset_of_sorted(FPPind[d][k])(FPPind[0][j]) then
nsd[k] := "F"  fi od{FAC}; new_status[d] := nsd od{DIMS} fi od{ALC};
new_status
