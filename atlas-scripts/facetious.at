<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }

{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])

Just do this for SIMPLE root datum rd.

Big problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell

}

{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum

set aff_rank(SimpleAffine Affd) = ss_rank(Affd) + 1

set_type AffineCoroot = (vec,int)
set *(AffineCoroot (betav,m), ratvec gamma) = m+betav*gamma

{first apply w, then translate by tau}
set_type AffineCoWeylElt = (vec tau, WeylElt w)

set *(AffineCoWeylElt (tau,w) , vec gamma) = w*gamma + tau
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = w*gamma + tau
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = (w1*tau2 +
tau1, w1*w2)
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
(w*betav, m-betav*tau)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
(-inverse(w)*tau, inverse(w))

set aff_simple_coroots(SimpleAffine Affd) = [AffineCoroot]:
for j:Affd.aff_rank do
if j=0 then (-coroot(Affd, highest_short_root(Affd)),1) else
(Affd.simple_coroots[j-1],0) fi od

{compute facet of a point in fundamental alcove, where all positive
roots are in [0,1]}

set labels(SimpleAffine Affd) = [int]:
for j:Affd.aff_rank do
if j=0 then 1 else rat_as_int(Affd.fundamental_weights[j-1] *
coroot(Affd, highest_short_root(Affd))) fi od

set root(AffineCoroot (betav,m),SimpleAffine Affd) = root(Affd,betav)

set *(AffineCoroot (betav,m), vec v) = betav*v + m


set reflection(AffineCoroot Betav, SimpleAffine Affd, vec v) = v -
(Betav*v)*root(Betav,Affd)

set reflection(AffineCoroot Betav, SimpleAffine Affd, ratvec v) =
reflection(Betav, Affd, v.numer)/v.denom

{a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot inequalities and (n-k) AffineCoRoot equalities. The total
collection of affine coroots appearing 
must be a set of simple roots for the affine datum.}

set_type Facet = ([AffineCoroot] pos,[AffineCoroot] zero)

set facet(SimpleAffine Affd, ratvec gamma0) = Facet:
let S=Affd.aff_simple_coroots in (##for j:Affd.aff_rank do if S[j]*gamma0 != 0
then [S[j]] else [] fi od, ##for j:Affd.aff_rank do if S[j]*gamma0 = 0
then [S[j]] else [] fi od)
set aff_simple_roots(SimpleAffine Affd) = for j:Affd.aff_rank do
if j=0 then -highest_short_root(Affd) else
Affd.simple_roots[j-1] fi od

{ set stabilizer(Facet (pos,zero)) = root_datum(??, }

{ vertices of fundamental alcove }
set fundamental_vertices(SimpleAffine Affd) = [ratvec]:
for j:Affd.aff_rank + 1 do 
if j=0 then null(Affd.rank)/1 else
Affd.fundamental_weights[j-1]/Affd.labels[j-1] fi od

set fund_facets(SimpleAffine Affd) = [Facet]:
let n = Affd.aff_rank, Sv = Affd.aff_simple_coroots then P =
power_set(n) in for i:2^n-1 from 1 do (for j in P[i] do Sv[j] od, for
k in complement(n,P[i]) do Sv[k] od) od 

set fund_barycenters(SimpleAffine Affd) = [ratvec]:
let  n = Affd.aff_rank, LAB = Affd.labels,
FWts=Affd.fundamental_weights then P = power_set(n) in for i:2^n - 1
from 1 do sum(n-1,let m = #P[i] in for j in P[i] do if j=0 then
null(n-1)/1 else FWts[j-1]/(m*LAB[j]) fi od) od

set W_fund_barycenters(SimpleAffine Affd) = [ratvec]:
## for gamma in fund_barycenters(Affd) do for w in
stabiliser_quotient_of_dominant(Affd,gamma.numer) do w*gamma od od

{ integral weight to be added to gamma to land in fundamental
parallelepiped where all simple coroots take values in [0,1] }
{need to make a list of all possible tau; if g is an integer, use
either -g or -g+1.}

set FPtau(SimpleAffine Affd, ratvec gamma) = [ratvec]: let g=for
j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od then INT =
##for j:#Affd.simple_coroots do if is_integer(g[j]) then [j] else []
fi od in for S in power_set(#INT) do sum(Affd.rank, for
j:#Affd.simple_coroots do -floor(g[j])*Affd.fundamental_weights[j]
od) + sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od) od

{this includes all barycenters of facets in the fundamental
parallelepiped. Should be reorganized by dimension!}
set FPP_barycenters(SimpleAffine Affd) = [ratvec]:
## for gamma in W_fund_barycenters(Affd) do for tau in
FPtau(Affd,gamma) do gamma+tau od od

{this eliminates repetition}
set FPP_barycenters_unique(SimpleAffine Affd) = [ratvec]:
let longList = FPP_barycenters(Affd) in ##for j:#longList do if all(for i:j
do longList[i] != longList[j] od) then [longList[j]] else [] fi od

{ Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove: subtract roots until gamma lands in W*A0 =
set where gamma1 is at most one on every coroot.  Precisely,
gamma - tau(gamma) is in W*(fundamental alcove).

This version uses more integer arithmetic. First make simple root
coords smaller than 1.}

set TAU(RootDatum rd,ratvec gamma) = vec:
let COROOTS = rd.coroots, ROOTS = rd.roots, gamma0NUM=gamma.numer,
DENOM = gamma.denom, m0= 0, q0=0 then d=#COROOTS in if d!=0
then for j:#rd.fundamental_coweights do let (num,den) =
(rd.fundamental_coweights[j].numer, rd.fundamental_coweights[j].denom) in
gamma0NUM := (gamma0NUM -
( ( ( num*gamma0NUM )\(DENOM*den))*DENOM*den)*rd.simple_roots[j]) od;
while (m0:=max_loc(for j:d do COROOTS[d-j-1]*gamma0NUM od); (q0:=
COROOTS[d-m0-1]*gamma0NUM; q0 > DENOM)) do gamma0NUM:= gamma0NUM -
ceil(q0/(2*DENOM))*DENOM*ROOTS[d-m0-1] od fi;
(gamma-gamma0NUM/DENOM).ratvec_as_vec

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt (w,tau) moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) = (WeylElt,
vec, ratvec): let tau = TAU(rd,gamma) then (w,gamma0TIMESDEN) = from_dominant
(rd,gamma.numer - gamma.denom*tau) in
{assert (gamma=w*gamma0 + tau,"Bad affine!");}
(w,tau,gamma0TIMESDEN/gamma.denom)

{set facet(SimpleAffine Affd, ratvec gamma) = Facet:}


