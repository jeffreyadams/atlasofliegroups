<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]) }
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<K_highest_weights.at { for LKT }
{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])}

{ Just do this for SIMPLE root datum rd.}

{ at the end is a function "spherical" which (if G has simple derived
group) might return which facets correspond to non-cohomologically
induced spherical principal series. Haven't proven this. }

{ One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell) }

{ There are four notions of "facet":
1) a ([AffineCoroot],[AffineCoroot]) Facet of affine inequalities and
equalities defining it (NOT UNIQUE);
2) the [ratvec] FacetVerts of vertices;
3) the ratvec FacetBary, the barycenter of the facet; and
4) the [vec] FacetVertsIndex of indices of the vertices in a fixed list of vertices

I like FacetVerts the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) bu looking at all
enlargements of the vertex set. Passage from FacetVerts to FacetBary is
trivial (average the vertices) There are functions facet, facetVerts and
facetBary which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{ useful to assign this to 'true" to get information about the progress
of long calculations }
set facet_verbose=false

{.remove repetitions from list of ratvecs.}
set NoReps([ratvec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{.remove repetitions from a list of vecs.}
set NoReps([vec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum

set aff_rank(SimpleAffine Affd) = ss_rank(Affd) + 1

set_type [AffineCoroot = (vec,int)]

{.evaluate AffineCoroot at weight.}
set *(AffineCoroot (betav,m), vec gamma) = m+betav*gamma

{.evaluate AffineCoroot at rational weight.}
set *(AffineCoroot (betav,m), ratvec gamma) = m+betav*gamma

{.first apply w, then translate by tau.}
set_type [AffineCoWeylElt = (vec tau, WeylElt w)]

{.apply AffineCoWeylElt to weight.}
set *(AffineCoWeylElt (tau,w) , vec gamma) = w*gamma + tau
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = w*gamma + tau

{.compose AffineCoWeylElts.}
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = AffineCoWeylElt:
    (tau1 + w1*tau2, w1*w2)
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
    let bvw1=betav*inverse(w) in (bvw1, m-bvw1*tau)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
    let w1=inverse(w) in (-w1*tau,w1)

{.simple affine coroots: number 0 is affine, rest are simple for RootDatum.}
set aff_simple_coroots (SimpleAffine affd) = [AffineCoroot]:
    (highest_root(dual(affd)),1) #
    for alpha_v in simple_coroots(affd) do (alpha_v,0) od

{.sum of simple affine coroots times their labels is (null(rank),1).}
set labels(SimpleAffine affd) = [int]:
    let a = coroot_index(affd,highest_root(dual(affd))) in
    1 # coroot_expression(affd,a)

{.a common denominator for all vertices of alcoves.}
set denom (SimpleAffine affd) = int:
    let lab = labels(affd), fwts=affd.fundamental_weights in
    for fw@j in fwts do denom(fw)*lab[j+1] od.lcm

{.root attached to an AffineCoroot.}
set root (AffineCoroot (betav,m),SimpleAffine affd) = root(affd,betav)

{.affine reflection through Affine coroot, applied to weight.}
set reflection(AffineCoroot Betav, SimpleAffine affd, vec v) = vec:
    v - root(Betav,affd)*(Betav*v)

set reflection(AffineCoroot Betav, SimpleAffine affd, ratvec v) = ratvec:
    reflection(Betav, affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot strict inequalities and (n-k) AffineCoRoot equalities.
The total collection of affine coroots appearing must be a set of simple coroots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE }

set_type [Facet = ([AffineCoroot] pos,[AffineCoroot] zero)]

{ a UNIQUE characterization of a k-diml facet is as a set of
k+1 vertices }

set_type FacetVerts = [ratvec]

{ Maybe the smallest UNIQUE characterization is the barycenter }

set_type FacetBary = ratvec

{ actual barycenter is this divided by Bdenom(Affd) }
set_type FacetBaryNum = vec

{represents a k-diml facet as k+1 indices into a list of vertices
(held elsewhere)}
set_type FacetVertsIndex = vec

{.computes the Facet of a point gamma0 in the FUNDAMENTAL alcove.}
set facet0(SimpleAffine affd, ratvec gamma0) = Facet:
    let S=affd.aff_simple_coroots in
    (for a in S do if a*gamma0 = 0 then [] else [a] fi od.##
    ,for a in S do if a*gamma0 = 0 then [a] else [] fi od.##
    )

{.simple roots corresponding to simple affine coroots: number 0 is
affine,  rest are simple for RootDatum.}
set aff_simple_roots(SimpleAffine affd) = mat:
    (-highest_root(dual(affd))) # affd.simple_roots

{.vertices of the fundamental alcove.}
{ set has aff_rank elements }
set fundamental_vertices (SimpleAffine affd) = [ratvec]:
    (ratvec:null(affd.rank)) #
    (let labs=affd.labels[1:] in
     for lab@j in labs do fundamental_weight(affd,j)/lab od)

{.numerators only; actual are divided by denom(affd).}
set fundamental_vertices_numer(SimpleAffine affd) = mat:
    null(affd.rank) #
    (let labs=affd.labels[1:], d=denom(affd) in
     for lab@j in labs do ratvec_as_vec(d*fundamental_weight(affd,j)/lab) od)

{.FacetVerts of a point gamma0 in the fundamental alcove.}
set facet_verts0(SimpleAffine affd, ratvec gamma0) = FacetVerts:
    let vert=fundamental_vertices(affd) in
    for coroot@d in affd.aff_simple_coroots
    do if =coroot*gamma0 then [] else [vert[d]] fi
    od.##

{.computes the FacetBary of a point gamma0 in the fundamental alcove.}
set facet_bary0(SimpleAffine affd, ratvec gamma0) = FacetBary:
    let verts = facet_verts0(affd,gamma0) then n=#verts in
    sum(affd.rank, for v in verts do v/n od)

{.all facets in the fundamental alcove, organized by dimension.}
{ if aff_rank = n, set has 2^n - 1 elements, (n choose d+1) in dim d
for 0 \le d \le n-1. }
set fund_facets(SimpleAffine affd) = [[Facet]]:
    let n = affd.aff_rank, Sv = affd.aff_simple_coroots
    then listn = #n
    in
    for d:n
    do for S in choices_from(listn,d+1)
       do Facet:
       ( { pos  } for j in S do Sv[j] od
       , { zero } for k in complement(n,S) do Sv[k] od
       )
       od
    od

{.d-dimensional facets in the fundamental alcove.}
{ if aff_rank = n, set has (n choose d+1) elements }
set fund_facets(SimpleAffine affd,int d) = [Facet]:
    let n = affd.aff_rank, Sv = affd.aff_simple_coroots
    then listn = #n
    in
    for S in choices_from(listn,d+1)
    do Facet:
    ( { pos  } for j in S do Sv[j] od
    , { zero } for k in complement(n,S) do Sv[k] od
    )
    od

{.barycenters of facets in fundamental alcove, organized by dimension.}
set fund_barycenters(SimpleAffine affd) = [[FacetBary]]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd)
    then listn = #n
    in
    for d:n
    do for S in choices_from(listn,d+1)
       do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
       od
    od

{.barycenters of d-dimensional facets in the fundamental alcove.}
set fund_barycenters(SimpleAffine affd, int d) = [FacetBary]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd) in
    for S in choices_from(#n,d+1)
    do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
    od

{ a common denominator for all barycenters of facets }
set Bdenom(SimpleAffine affd) = int:
    for list in fund_barycenters(affd)
    do for fb in list do denom(fb) od.lcm
    od.lcm

{ barycenter numerators of facets in the fundamental alcove, organized by
dimension; actual barycenters are these divided by Bdenom(affd) }
set fund_barycenters_numer(SimpleAffine affd) = [[vec]]:
let  n = affd.aff_rank, LAB = affd.labels, BDENOM = Bdenom(affd),
FWts=affd.fundamental_weights then listn = for j:n do j od
in for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN}
ratvec_as_vec(BDENOM*sum(affd.rank, for j in S do{VERT} if j=0 then
null(affd.rank)/1 else FWts[j-1]/((d+1)*LAB[j]) fi od{VERT})) od{BIN} od{DIM}

{ vertex sets for facets in the fundamental alcove, organized by
dimension }

set fund_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
then listn = for j:n do{DIM} j od
in for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN}
for j in S do{VERTS} Verts[j] od{VERTS} od{BIN} od{DIM}

set fund_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
then listn = for j:n do{DIM} j od
in for S in choices_from(listn,d+1) do{BIN}
for j in S do{VERTS} Verts[j] od{VERTS} od{BIN}

{ vertex set numerators for facets in the fundamental alcove, organized by
dimension; actual are these divided by denom(Affd) }

set fund_vertex_sets_numer(SimpleAffine Affd) = [[[vec]]]:
let  n = Affd.aff_rank, Verts_numer=fundamental_vertices_numer(Affd)
then listn = for j:n do{DIM} j od
in for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN}
for j in S do{VERTS} Verts_numer[j] od{VERTS} od{BIN} od{DIM}

{ calculates the number of vertices in W*(fundamental alcove }
set W_fund_vertices_card(SimpleAffine Affd) = int:
let n=Affd.ss_rank, N=#W(Affd) then listn=for j:n do j od in
1+sum(for S in choices_from(listn,n-2) do
rat_as_int(N/#W(Levi(Affd,S))) od )

{ cardinality of W_fund_vertices[d] }
set W_fund_d_facets_card(SimpleAffine Affd,int d) = int:
let n=Affd.ss_rank, N=#W(Affd) then listn=for j:n do j od in
if d=n then N else sum(for T in choices_from(listn,n-d) do
rat_as_int(N/#W(Levi(Affd,T))) od) +
sum(for S in choices_from(listn,n-d-1) do
rat_as_int(N/#W(Levi(Affd,S))) od ) fi

{ cardinalities of all elts of W_fund_vertices }
set W_fund_facets_card(SimpleAffine Affd) = [int]:
for d:Affd.aff_rank do W_fund_d_facets_card(Affd,d) od

{ vertices in W*(fundamental alcove) }
set W_fund_verticesOLD(SimpleAffine Affd) = [ratvec]:
## for gamma in fundamental_vertices(Affd) do{VERT} for w in
stabiliser_quotient_of_dominant(Affd,gamma.numer) do{W} w*gamma od{W}
od{VERT}

set W_fund_vertices(SimpleAffine Affd) = [ratvec]:
let GC=Affd.complexification, r=Affd.rank, shift = Bdenom(Affd)*Affd.rho
then rhoC = GC.rho in
## for gamma in fundamental_vertices(Affd) do{VERT} for p in
block_of(parameter(GC,0,shift##gamma.numer, shift##gamma.numer)) do{P}
let (,v) = p.LKT in ratvec: for j:r do{GAM} (v[j+r] + v[j] -
shift[j])/gamma.denom od{GAM} od{P} od{VERT}

{ vertex numers in W*(fundamental alcove); for actuals divide by denom(Affd) }
set W_fund_vertices_numer(SimpleAffine Affd) = [vec]:
## for gamma in fundamental_vertices_numer(Affd) do{VERT} for w in
stabiliser_quotient_of_dominant(Affd,gamma) do{W} w*gamma od{W}
od{VERT}

{ barycenters in W*(fundamental alcove), organized by dimension }
set W_fund_barycentersOLD(SimpleAffine Affd) = [[FacetBary]]:
for d:Affd.aff_rank do{DIM}
if facet_verbose then prints("start dim ",d," in W_fund_barycentersOLD.")
fi;
## for gamma in fund_barycenters(Affd)[d]
do{BIN} for w in stabiliser_quotient_of_dominant(Affd,gamma.numer)
do{W} w*gamma od{W} od{BIN} od{DIM}

{ barycenters of d-dimensional facets in W*(fundamental alcove) }
set W_fund_barycentersOLD(SimpleAffine Affd,int d) = [FacetBary]:
if facet_verbose then prints("start dim ",d," in W_fund_barycentersOLD.")
fi;
## for gamma in fund_barycenters(Affd)[d]
do{BIN} for w in stabiliser_quotient_of_dominant(Affd,gamma.numer)
do{W} w*gamma od{W} od{BIN}

{ barycenters in W*(fundamental alcove), organized by
dimension. Compute W orbits using block_of command in GC. The shift
BDenom(Affd) is required to exceed the pairing of gamma.numer with any
coroot. }
set W_fund_barycenters(SimpleAffine Affd) = [[FacetBary]]:
let GC=Affd.complexification, r=Affd.rank, shift = Bdenom(Affd)*Affd.rho
then rhoC = GC.rho in
for d:Affd.aff_rank do{DIM}
if facet_verbose then prints("start dim ",d," in W_fund_barycenters.")
fi;
## for gamma in fund_barycenters(Affd)[d]
do{BIN} for p in
block_of(parameter(GC,0,shift##gamma.numer, shift##gamma.numer)) do{P}
let (,v) = p.LKT in ratvec: for j:r do{GAM} (v[j+r] + v[j] -
shift[j])/gamma.denom od{GAM} od{P} od{BIN} od{DIM}

{ barycenters of d-dimensional facets in W*(fundamental
alcove). Compute W orbits using block_of command in GC. The shift
BDenom(Affd) is required to exceed the pairing of gamma.numer with any
coroot. }
set W_fund_barycenters(SimpleAffine Affd, int d) = [FacetBary]:
let GC=Affd.complexification, r=Affd.rank, shift = Bdenom(Affd)*Affd.rho
then rhoC = GC.rho in
if facet_verbose then prints("start dim ",d," in W_fund_barycenters.")
fi;
## for gamma in fund_barycenters(Affd)[d]
do{BIN} for p in
block_of(parameter(GC,0,shift##gamma.numer, shift##gamma.numer)) do{P}
let (,v) = p.LKT in ratvec: for j:r do{GAM} (v[j+r] + v[j] -
shift[j])/gamma.denom od{GAM} od{P} od{BIN}

{ barycenter numers in W*(fundamental alcove), organized by dimension }
set W_fund_barycenters_numer(SimpleAffine Affd) = [[vec]]:
for d:Affd.aff_rank do{DIM}
if facet_verbose then prints("start dim ",d,
" in W_fund_barycenters_numer.") fi;
## for gamma in fund_barycenters_numer(Affd)[d]
do{BIN} for w in stabiliser_quotient_of_dominant(Affd,gamma)
do{W} w*gamma od{W} od{BIN} od{DIM}

{ vertex sets for facets in W*(fundamental alcove), organized by
dimension }
set W_fund_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
let n=Affd.aff_rank, Verts = fundamental_vertices(Affd) then listn=for
j:n do j od in
for d:n do{DIM}
if facet_verbose then prints("start dim ",d," in W_fund_vertex_sets.")
fi;
## for S in choices_from(listn,d+1) do{BIN} for w in
stabiliser_quotient_of_dominant(Affd, ratvec_as_vec(sum(Affd.rank,for
j in S do{VERTS}
Verts[j].numer od{VERTS}))) do{W} for j in S do{VERTS} w*Verts[j]
od{VERTS} od{W} od{BIN} od{DIM}

{ vertex sets for d-dimensional facets in W*(fundamental alcove) }
set W_fund_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
let n=Affd.aff_rank, Verts = fundamental_vertices(Affd) then listn=for
j:n do j od in
if facet_verbose then prints("start dim ",d," in W_fund_vertex_sets.")
fi;
## for S in choices_from(listn,d+1) do{BIN} for w in
stabiliser_quotient_of_dominant(Affd, ratvec_as_vec(sum(Affd.rank,for
j in S do{VERTS}
Verts[j].numer od{VERTS}))) do{W} for j in S do{VERTS} w*Verts[j]
od{VERTS} od{W} od{BIN}

{ vertex set numers for facets in W*(fundamental alcove), organized by
dimension; for actuals divide by denom(Affd)}
set W_fund_vertex_sets_numer(SimpleAffine Affd) = [[[vec]]]:
let n=Affd.aff_rank, Verts_numer = fundamental_vertices_numer(Affd)
then listn=for j:n do j od in for d:n do{DIM}
if facet_verbose then prints("start dim ",d,
" in W_fund_vertex_sets_numer.") fi;
## for S in choices_from(listn,d+1) do{BIN} for w in
stabiliser_quotient_of_dominant(Affd, sum(for j in S do{VERTS}
Verts_numer[j] od{VERTS})) do{W}
for j in S do{VERTS} w*Verts_numer[j] od{VERTS} od{W} od{BIN} od{DIM}

{ integral weights to be added to gamma to land in fundamental
parallelepiped where all simple coroots take values in [0,1] }
{need to make a list of all possible tau; if g is an integer, use
either -g or -g+1.}

set FPtau(SimpleAffine Affd, ratvec gamma) = [ratvec]: let g=for
j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od then INT =
##for j:#Affd.simple_coroots do if is_integer(g[j]) then [j] else []
fi od in for S in power_set(#INT) do sum(Affd.rank, for
j:#Affd.simple_coroots do -floor(g[j])*Affd.fundamental_weights[j]
od) + sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od) od

{ numerators; to get actual values, divide by denom(Affd) }
set FPtau_numer(SimpleAffine Affd, ratvec gamma) = [vec]: let g=for
j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od, DENOM =
denom(Affd) then FW_numer = for v in Affd.fundamental_weights do
ratvec_as_vec(DENOM*v) od  then INT =
##for j:#Affd.simple_coroots do if =g[j]%DENOM then [j] else []
fi od in for S in power_set(#INT) do sum(for j:#Affd.simple_coroots do
-floor(g[j]/DENOM)*FW_numer[j] od) + if =#S then null(Affd.rank) else
sum(for j in S do FW_numer[INT[j]] od) fi od

{ numerators; to get actual values, divide by denom(Affd) }
set FPtau_numer_int(SimpleAffine Affd, vec gamma) = [vec]: let g= vec:
for j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od, DENOM =
denom(Affd) then FW_numer = for v in Affd.fundamental_weights do
ratvec_as_vec(DENOM*v) od  then INT {list of integral simple coroot
nrs} = ##for j:#Affd.simple_coroots do if =g[j]%DENOM then [j] else []
fi od in for S in power_set(#INT) do sum(for j:#Affd.simple_coroots do
-floor(g[j]/DENOM)*FW_numer[j] od) + if =#S then null(Affd.rank) else
sum(for j in S do FW_numer[INT[j]] od) fi od

{ Bnumerators; to get actual values, divide by Bdenom(Affd) }
set FPtau_Bnumer(SimpleAffine Affd, ratvec gamma) = [vec]: let g=for
j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od, DENOM =
Bdenom(Affd)  then INT =
##for j:#Affd.simple_coroots do if is_integer(g[j]) then [j] else []
fi od in for S in power_set(#INT) do ratvec_as_vec(DENOM*(sum(Affd.rank, for
j:#Affd.simple_coroots do -floor(g[j])*Affd.fundamental_weights[j]
od) + sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od))) od

{ Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove: subtract roots until gamma lands in W*A0 =
set where gamma1 is at most one on every coroot.  Precisely,
gamma - tau(gamma) is in W*(fundamental alcove).

Uses mostly integer arithmetic. First make simple root
coords smaller than 1. }

set TAU(RootDatum rd,ratvec gamma) = vec:
let COROOTS = rd.coroots, ROOTS = rd.roots, gamma0NUM=gamma.numer,
DENOM = gamma.denom, m0= 0, q0=0 then d=#COROOTS in if d!=0
then for j:#rd.fundamental_coweights do let (num,den) =
(rd.fundamental_coweights[j].numer, rd.fundamental_coweights[j].denom) in
gamma0NUM := (gamma0NUM -
( ( ( num*gamma0NUM )\(DENOM*den))*DENOM*den)*rd.simple_roots[j]) od;
while (m0:=max_loc(for j:d do COROOTS[d-j-1]*gamma0NUM od); (q0:=
COROOTS[d-m0-1]*gamma0NUM; q0 > DENOM)) do gamma0NUM:= gamma0NUM -
ceil(q0/(2*DENOM))*DENOM*ROOTS[d-m0-1] od fi;
(gamma-gamma0NUM/DENOM).ratvec_as_vec

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) = (AffineCoWeylElt,
ratvec): let tau = TAU(rd,gamma) then (w,gamma0TIMESDEN) = from_dominant
(rd,gamma.numer - gamma.denom*tau) in
{assert (gamma=w*gamma0 + tau,"Bad affine!");}
((tau,w),gamma0TIMESDEN/gamma.denom)

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }

set facet(SimpleAffine Affd, ratvec gamma) = Facet:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) then
(F0pos,F0zero) = facet0(Affd,gamma0) in (for betav in F0pos
do wtilde*betav od , for betav in F0zero
do wtilde*betav od)

{ computes the FacetBary of any ratvec }

set facet_bary(SimpleAffine Affd, ratvec gamma) = FacetBary:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) in
wtilde*facet_bary0(Affd,gamma0)

{ computes the FacetVerts (vertex set) of any ratvec }

set facet_verts(SimpleAffine Affd, ratvec gamma) = FacetVerts:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) then
Verts = facet_verts0(Affd,gamma0) in for gamma0v in Verts
do wtilde*gamma0v od

{ this includes all vertices of facets in the fundamental
parallelepiped }
set FPP_vertices(SimpleAffine Affd) = [ratvec]:
if facet_verbose then prints("start FPP_vertices.") fi;
let GI = root_datum(null(Affd.rank,0),
null(Affd.rank,0),true).split_form
in for p in monomials(sum(GI, for gamma in W_fund_vertices(Affd)
do{WA0} sum(GI, for tau in FPtau(Affd,gamma) do{TAU}
parameter(GI,0,GI.rho,gamma+tau) od{TAU}) od{WA0})) do p.nu od

set FPP_verticesOLD(SimpleAffine Affd) = [ratvec]:
if facet_verbose then prints("start FPP_vertices.") fi;
let GI = root_datum(null(Affd.rank,0),
null(Affd.rank,0),true).split_form
in for p in monomials(sum(GI, for gamma in W_fund_verticesOLD(Affd)
do{WA0} sum(GI, for tau in FPtau(Affd,gamma) do{TAU}
parameter(GI,0,GI.rho,gamma+tau) od{TAU}) od{WA0})) do p.nu od

set FPP_barycenters(SimpleAffine Affd) = [[FacetBary]]:
if facet_verbose then prints("start FPP_barycenters.") fi;
let WBs = W_fund_barycenters(Affd), GI = root_datum(null(Affd.rank,0),
null(Affd.rank,0),true).split_form in for d:Affd.aff_rank do{DIM}
if facet_verbose then prints("start dim ",d," in FPP_barycenters.") fi;
for p in monomials(sum(GI, for gamma in WBs[d] do{WA0} sum(GI, for tau in
FPtau(Affd,gamma) do{TAU} parameter(GI,0,GI.rho,gamma+tau) od{TAU})
od{WA0})) do p.nu od od{DIM}

{ convert a FacetVerts to a FacetBary }
set facet_bary(FacetVerts facet) = ratvec:
let n = #facet[0], D = #facet in sum(n, facet)/D

{ using nu...}
set FPP_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
if facet_verbose then prints("start FPP_vertex_sets") fi;
let FPPBs = FPP_barycenters(Affd) in for d:Affd.aff_rank do{DIM}
if facet_verbose then prints("start dim ",d," in FPP_vertex_sets.") fi;
for b in FPPBs[d] do{FAC} facet_verts(Affd,b) od{FAC} od{DIM}

set facet_verts_index([ratvec] vert_list, FacetVerts facet) = FacetVertsIndex:
for gammav in facet do find(vert_list,gammav) od.sort

{ creates the indexing ParamPol }
set index([ratvec] list) = ParamPol:
let G1=root_datum(null(#list[0],0),null(#list[0],0),true).split_form in
sum(G1,for v@j in list do (j+1)*parameter(G1,0,G1.rho,v) od)

set find(ParamPol Index,ratvec v) = int:
let GI = Index.real_form in
split_as_int(Index[parameter(GI,0,GI.rho,v)]) - 1

{ same as facet_verts_index using a precreated ParamPol as index set }
set facet_verts_index(ParamPol Index, FacetVerts facet) = FacetVertsIndex:
for gammav in facet do find(Index,gammav) od.sort

{ computes barycenter from a facet as a vertex list }
set facet_bary([ratvec] vert_list, FacetVertsIndex facet) = FacetBary:
sum(#vert_list[0], for k:#facet do vert_list[facet[k]] od)/(#facet)

set FPP_vertex_sets_indices(SimpleAffine Affd) = [[FacetVertsIndex]]:
let FPPV = FPP_vertex_sets(Affd) then vertexIndex=index(##FPPV[0])
in for d:Affd.aff_rank do
if facet_verbose then prints("start dim ",d," in FPP_vertex_sets_indices") fi;
if d=0 then for j:#FPPV[0] do [j] od else
for facet in FPPV[d] do facet_verts_index(vertexIndex,facet) od fi od

{ Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove: subtract roots until gamma lands in W*A0 =
set where gamma1 is at most one on every coroot.  Precisely,
gamma - tau(gamma) is in W*(fundamental alcove).

Uses mostly integer arithmetic. First make simple root
coords smaller than 1. }

{ meant to record information about unitarity for all facets }
set facet_status([[ratvec]] FPPB) = [[string]]:
for d:#FPPB do for j:#FPPB[d] do "?" od od

set facet_status([[vec]] FPPind) = [[string]]:
for d:#FPPind do for j:#FPPind[d] do "?" od od


set show([[string]] status) = void:
for d:#status do let (countT,countF,countQ) = (0,0,0) in for
j:#status[d] do if status[d][j]="T" then countT+:=1 elif
status[d][j]="F" then countF+:=1 else countQ+:=1 fi od;
prints("Facet dimension ",d,": ", countT, " unitary, ",
countF, " nonunitary, ", countQ, " undecided.") od

{ meant to get the facets for spherical not cohom induced in
nonquasisplit G }

set pick_not_cohom(RealForm G, [[FacetBary]] FPPB, [[FacetVertsIndex]] FPPind) =
([[FacetBary]],[[FacetVertsIndex]]):
let inv=x_open(G).involution then tworhoM = G.rho + inv*G.rho
then FPPBnc = [[ratvec]]: for d:#FPPB do ##for j:#FPPB[d] do
if inv*FPPB[d][j] + FPPB[d][j] = tworhoM then [FPPB[d][j]]
else [] fi od od,
FPPindnc = [[vec]]: for d:#FPPind do ##for j:#FPPind[d] do
if inv*FPPB[d][j] + FPPB[d][j] = tworhoM then
[FPPind[d][j]] else [] fi od od in (FPPBnc,FPPindnc)

{this eliminates the nonhermitian facets from the lists. Would be good
also to organize the new lists by dimension of the hermitian part,
which is d-(# unfixed vertices)/2.}
set pick_hermitian(RealForm G, [[FacetBary]] FPPB, [[FacetVertsIndex]] FPPind) =
([[ratvec]],[[FacetVertsIndex]]):
let FPPBh = [[FacetBary]]: for d:#FPPB do ##for j:#FPPB[d] do if
is_hermitian(parameter(x_open(G),G.rho,FPPB[d][j])) then [FPPB[d][j]]
else [] fi od od,
FPPindh = [[vec]]: for d:#FPPind do ##for j:#FPPind[d] do
if is_hermitian(parameter(x_open(G),G.rho,FPPB[d][j])) then
[FPPind[d][j]] else [] fi od od in (FPPBh,FPPindh)

{ Need simple derived group }
set spherical(RealForm G, [ratvec] vlist, [[FacetVertsIndex]] FPPind) =
([[string]],[ratvec],[[FacetVertsIndex]]):
let FPPB = for d:G.aff_rank do{DIM} for j:#FPPind[d] do{FAC}
facet_bary(vlist, FPPind[d][j]) od{FAC} od{DIM} then
(FPPBnc,FPPindnc) = pick_not_cohom(G,FPPB,FPPind) then
(FPPBnch, FPPindnch) = pick_hermitian(G,FPPBnc,FPPindnc)
then status = facet_status(FPPBnch) in for d:#status do{DIMd}
if facet_verbose then prints("start dim ",d," in spherical(G,vlist,FPPind)") fi;
let nsd = status[d] in if facet_verbose then prints(); show(status) fi;
for j:#status[d] do{FACd} let result = if{RES}
nsd[j]!="?" then nsd[j]
else if{NEWU}
(is_unitary(first_param(standardize(parameter(x_open(G), G.rho,
FPPBnch[d][j])))))
then nsd[j]:="T" else{NEWU} for e: #status-d-1 from d+1 do{DIMe} let
nse=status[e] in for k:#nse do{FACe} if{SUB}
is_subset_of_sorted(FPPindnch[e][k])(FPPindnch[d][j])
then nse[k]:= "F" fi{SUB} od{FACe}; status[e]:=nse od{DIMe};
nsd[j]:="F" fi{NEWU} fi{RES} in result od{FACd}; status[d]:=nsd
od{DIMd};
prints(); show(status); (status,vlist,FPPindnch)

{ Meant to be applied to (G,output of spherical_to_h). Need simple
 derived group }
 set spherical(RealForm G, ([[string]] status, [ratvec] vlist,
 [[FacetVertsIndex]] FPPind)) = ([[string]],[ratvec],[[FacetVertsIndex]]):
let FPPB = for d:G.aff_rank do{DIM} for j:#FPPind[d] do{FAC}
facet_bary(vlist, FPPind[d][j]) od{FAC} od{DIM} in for d:#status do{DIMd}
if facet_verbose then prints("start dim ",d,
" in spherical(G,status,vlist,FPPind)") fi;
let nsd = status[d] in if facet_verbose then prints(); show(status) fi;
for j:#status[d] do{FACd} let result = if{RES}
nsd[j]="F" then "F" else if{NEWU}
(is_unitary(first_param(standardize(parameter(x_open(G), G.rho,
FPPB[d][j])))))
then nsd[j]:="T" else{NEWU} for e: #status-d-1 from d+1 do{DIMe} let
nse=status[e] in for k:#nse do{FACe} if{SUB}
is_subset_of_sorted(FPPind[e][k])(FPPind[d][j])
then nse[k]:= "F" fi{SUB} od{FACe}; status[e]:=nse od{DIMe};
nsd[j]:="F" fi{NEWU} fi{RES} in result od{FACd}; status[d]:=nsd
od{DIMd};
prints(); show(status); (status,vlist,FPPind)

{ in output, "F" is certain, "T" means "true to height=bound" }
set spherical_to_ht(RealForm G, [ratvec] vlist, [[FacetVertsIndex]] FPPind,
int bound) =
([[string]],[ratvec],[[FacetVertsIndex]]):
let FPPB = for d:G.aff_rank do{DIM} for j:#FPPind[d] do{FAC}
facet_bary(vlist, FPPind[d][j]) od{FAC} od{DIM} then
(FPPBnc,FPPindnc) = pick_not_cohom(G,FPPB,FPPind) then
(FPPBnch, FPPindnch) = pick_hermitian(G,FPPBnc,FPPindnc)
then status = facet_status(FPPBnch) in for d:#status do{DIMd}
if facet_verbose then prints("start dim ",d,
" in spherical_to_ht(G,vlist,FPPind,bound)") fi;
let nsd = status[d] in if facet_verbose then prints(); show(status) fi;
for j:#status[d] do{FACd} let result = if{RES}
nsd[j]!="?" then nsd[j]
else if{NEWU}
(is_unitary_to_ht(first_param(standardize(parameter(x_open(G), G.rho,
FPPBnch[d][j]))),bound))
then nsd[j]:="T" else{NEWU} for e: #status-d-1 from d+1 do{DIMe} let
nse=status[e] in for k:#nse do{FACe} if{SUB}
is_subset_of_sorted(FPPindnch[e][k])(FPPindnch[d][j])
then nse[k]:= "F" fi{SUB} od{FACe}; status[e]:=nse od{DIMe};
nsd[j]:="F" fi{NEWU} fi{RES} in result od{FACd}; status[d]:=nsd
od{DIMd};
prints(); show(status); (status,vlist,FPPindnch)

{ to be applied to result of a previous to_ht computation; FPPind is assumed
already to be cut to not cohom and hermitian }
{ in this calculation, don't trust old "T", which meant "true to some
previous height }
set spherical_to_ht(RealForm G, ([[string]] status, [ratvec] vlist,
[[FacetVertsIndex]] FPPind), int bound) =
([[string]],[ratvec],[[FacetVertsIndex]]):
let FPPB = for d:G.aff_rank do{DIM} for j:#FPPind[d] do{FAC}
facet_bary(vlist, FPPind[d][j]) od{FAC} od{DIM}
in for d:#status do{DIMd}
if facet_verbose then prints("start dim ",d,
" in spherical(G,status,vlist,FPPind)") fi;
let nsd = status[d] in if facet_verbose then prints(); show(status) fi;
for j:#status[d] do{FACd} let result = if{RES}
nsd[j]="F" then nsd[j]
else if{NEWU}
(is_unitary_to_ht(first_param(standardize(parameter(x_open(G), G.rho,
FPPB[d][j]))),bound))
then nsd[j]:="T" else{NEWU} for e: #status-d-1 from d+1 do{DIMe} let
nse=status[e] in for k:#nse do{FACe} if{SUB}
is_subset_of_sorted(FPPind[e][k])(FPPind[d][j])
then nse[k]:= "F" fi{SUB} od{FACe}; status[e]:=nse od{DIMe};
nsd[j]:="F" fi{NEWU} fi{RES} in result od{FACd}; status[d]:=nsd
od{DIMd};
prints(); show(status); (status,vlist,FPPind)

{ still need simple derived group }
set spherical(RealForm G) = ([[string]],[ratvec],[[FacetVertsIndex]]):
let vlist = FPP_vertices(G) in
spherical(G,vlist,FPP_vertex_sets_indices(G))

set spherical_to_ht(RealForm G, int bound) = ([[string]],[ratvec],[[FacetVertsIndex]]):
let vlist = FPP_vertices(G) in spherical_to_ht(G, vlist,
FPP_vertex_sets_indices(G),bound)

set update_status([[string]] status, [ratvec] vlist, [[FacetVertsIndex]]
Cand) = ([[string]], [ratvec], [[FacetVertsIndex]]):
let newCand = for d:#status do assert(#Cand[d] = #status[d],
"size mismatch between status and Cand"); ##for j:#status[d] do if
status[d][j] = "F" then [] else [Cand[d][j]] fi od od,  newstatus =
for d:#status do  ##for j:#status[d] do if
status[d][j] = "F" then [] else [status[d][j]] fi od od in
(newstatus,vlist,newCand)

{idea is in a session to say ">> FILENAME write(status,vlist,Cand)"}
set write([[string]] status, [ratvec] vlist, [[FacetVertsIndex]] Cand) = void:
prints("set status = ",status); prints("set vlist = ",vlist); prints("set Cand = ",Cand)
