<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]), no_reps}
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<unity.at { for is_unitary_test }
<TWOHEIGHTS.at { for HT, HTT, HTA }
<springer_tables_reductive.at { for Springer_table }
<associated_variety_annihilator.at { for GK_dim, used in identifying unipotent reps }
<lietypes.at { for simple_type }
<parabolics.at {for parabolic_by_wt}
<K_highest_weights.at {for all_parameters_x_gamma}
<lattice.at {for vec_solve}
<chopping_facets_fast.at {for chop_coroots(G, vertices)}
<facet_classes.at {for ordering on facets}
<hash.at {for KPolHash}
{current version incorporates storage of KTypePol's in a hash table
KPolHash, and MvL's code FPP_w_shifts for quickly finding FPP
facets. The functions that use neither of these are generally
suffixed "_old"}
{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])}

{ Just do this for root datum rd with simple derived datum.}

{ at the end is a function "spherical" which (if G has simple derived
group) might return which facets correspond to non-cohomologically
induced spherical principal series. Haven't proven this. }

{ One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell) }

{ There are four notions of "facet":
1) a ([AffineCoroot],[AffineCoroot]) Facet of affine inequalities and
equalities defining it (NOT UNIQUE);
2) the [ratvec] FacetVerts of vertices;
3) the ratvec FacetBary, the barycenter of the facet; and
4) the [vec] FacetVertsIndex of indices of the vertices in a fixed list of vertices

I like FacetVerts the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) by looking at all
enlargements of the vertex set. Passage from FacetVerts to FacetBary is
trivial (average the vertices) There are functions facet, facetVerts and
facetBary which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{ORGANIZATION: Main functions are spherical@RealForm and
spherical_to_ht@(RealForm,int), defined around line 945.

Here is a brief outline. Following Barbasch and Steve
Miller, calculate things related to the FUNDAMENTAL PARALLELEPIPED
FPP, which lies in the R-span of the roots, where all simple coroots
take values in [0,1]. The FPP is partitioned into facets of various
dimensions from 0 to the semisimple rank. Each d-dimensional facet is
determined by its barycenter (a ratvec) or by its vertices (a list of
d+1 ratvecs). The idea for computing all facets in the FPP is to
compute a list vlist of all vertices in the FPP (done by
FPP_vertices@RootDatum); then for each d-dimensional facet to store a
rank d+1 vec giving the indices of the vertices in vlist (done by
FPP_vertex_sets_indices).

What's needed to get going is a list of all barycenters of facets in
the FPP. These are calculated by

Theorem. Every [barycenter of a facet] gamma (not just in FPP) can be
written as w*gamma0 + tau, with gamma0 unique [barycenter of a facet]
in the fundamental alcove, w in W (finite Weyl group), and tau in the
root lattice. If we require

   w*gamma0 is integrally dominant

then w*gamma0 is unique, and so tau is unique.

There are 2^(semisimple rank - 1) facet barycenters gamma0 in the
fundamental alcove.; not too many. Marc kindly provided a very fast
listing of the W-orbits W*gamma0. Picking out the integrally dominant
ones is now done stupidly in functions with names like
W_fund_barycentersID: stupid in the sense that it would have been
cleverer to sort out the integrally dominant terms in the library.

Addenda 7/23/22. In unequal rank (and harmless in general) better to
work with the cofolded root datum, and the corresponding (smaller) set
of weights fixed by the distinguished involution. (Every unitary infl
character must be of this form.) The main functions for working this
way now have "Fold" in their names, and the plan is that these should
be ultimately be the only ones used. In particular, the special
scripts like sphericalC for dealing with complex groups can and should
now be replaced by sphericalFold.}

{ assigning this to "false" uses is_unitary_to_ht_old }
set new_to_ht = true

{ useful to assign this to 'true" to get information about the
  progress of long calculations }
set facet_verbose = false

{ if true, reports progress at each of 2^{rank+1} fundamental facets
  during FPP calculation }

set fund_facet_verbose = false

{ for facets of codim > facet_codim, use shifted char formula to
improve memory use. Setting equal to folded semisimple rank means no
use of shifted char formula.}
set facet_codim = int: 3

{. if assigned to 'true' then induction only records unitary reps of
Levis .}
set only_unitary = false

{. This controls the maximum denominator size kept in chop_coroots,
used in moving unitarity information from a Levi to G. Large values
allow more chopped facets, and so convey more information to G; but
small values are faster. Too small a value cannot lead to wrong
answers, but only to running more is_unitary tests .}
set chop_bound = int: 6

{. If "true," then print number of invocations of a unitarity test .}
set test_verbose = true

{If the distinguished involution delta of G is nontrivial, then all
UNITARY infinitesimal characters must be delta-fixed, and so lie in
(h*)^\delta. They are most efficiently calculated not using the affine
Weyl group of G, but rather the "cofolded" affine Weyl group explained
in the notes alcoves.pdf ("Affine Weyl group alcoves") around 3.4. The
character lattice for this cofolded datum is (X^*)^\delta. The script
twisted_root_datum calculates the DUAL folded root datum; so what we
need here is the dual of folded(dual of G.root_datum)). I think...}

set cofoldedBOTH(RootDatum rd, mat delta) = (RootDatum, RootDatum, mat):
    assert(is_distinguished(rd,delta),"delta is not distinguished");
    let Tstar = SubTorus:eigen_lattice(delta,1)
{Tstar =(X^*)^\delta; columns are a basis of (X^*)^\delta}
{Tstar is nxr where n=rd.rank and r=dimension(Tstar)}
{ Tstar: matrix of map Tstar->X^*(H) \simeq Z^r -> Z^n: this is Tstar.inject
 ^Tstar: matrix of map X_*(H)->X_*(Tstar) \simeq Z^n->Z^r:   this is
 Tstar.project=Tstar.restrict}
    then coroots_nonreduced=sort_u(
	 for alphavee in rd.poscoroots do Tstar.restrict(alphavee) od
	 )
    then {DISCARDS COROOTS FOR WHICH ALPHAVEE/2 IS COROOT}
	corootsC =mat:##(for alphavee in coroots_nonreduced
	 do if all (for x in alphavee/2 do is_integer(x) od)
	    and find(coroots_nonreduced,ratvec_as_vec(alphavee/2))!=-1
	    then [] else [alphavee] fi
	 od),
	 {THIS DISCARDS COROOTS FOR WHICH 2*ALPHAVEE IS COROOT}
	  corootsB=mat:##(for alphavee in coroots_nonreduced
	 do if find(coroots_nonreduced,2*alphavee)!=-1
	    then [] else [alphavee] fi
	 od)
    then rootsC = [] in
	 for alphavee in corootsC do
	     let pullback_alphavee = let j = first(
		 for betavee in rd.poscoroots do Tstar.restrict(betavee) =
		 alphavee od
	     )
	      in rd.poscoroots[j] {ONE coroot restricting to alphavee}
	 then v = sum(##( for betavee in rd.poscoroots do
		 if Tstar.restrict(betavee) = alphavee
		 then [root(rd,betavee)]
		 else []
		 fi od)) {sum of ALL roots for ALL coroots restr to alphavee}
	  then w = 2*v/(v*pullback_alphavee)
	  then corestrict_w = solve(Tstar,w).requisition
	  in
	  rootsC#:=ratvec_as_vec(corestrict_w)
	  od;
	  let rootsB = [] in
	  for alphavee in corootsB do
	     let pullback_alphavee = let j = first(
		 for betavee in rd.poscoroots do Tstar.restrict(betavee) =
		 alphavee od
	     )
	      in rd.poscoroots[j] {ONE coroot restricting to alphavee}
	 then v = sum(##( for betavee in rd.poscoroots do
		 if Tstar.restrict(betavee) = alphavee
		 then [root(rd,betavee)]
		 else []
		 fi od)) {sum of ALL roots for ALL coroots restr to alphavee}
	  then w = 2*v/(v*pullback_alphavee)
	  then corestrict_w = solve(Tstar,w).requisition
	  in rootsB#:=ratvec_as_vec(corestrict_w)
	  od;
	  (root_datum_from_positive((rootsB,corootsB),rd.prefers_coroots),
	  root_datum_from_positive((rootsC,corootsC),rd.prefers_coroots),Tstar)

{The cofolded RootDatum has character lattice (X^*)^\delta, coroots
the restrictions to (X^*)^\delta of the coroots of rd. The matrix is a
map from the character lattice of the cofolded datum to the character
lattice of G.}

{set cofolded(TwistedRootDatum (rd,delta)) = (RootDatum, mat):
    let (rd1,M1) = folded(rd.dual,^delta) in (rd1.dual,M1)}

{returns the cofolded root system, needed to construct the correct
affine Weyl group to act on delta-fixed weights; and the unique label
j0 (or -1) for a simple coroot needing to be divided by two to get
full FPP}
set cofolded(RealForm G) = (RootDatum, mat, int):
    let (rdB,rdC,M) = cofoldedBOTH(G.root_datum, G.distinguished_involution)
    then j0=
	 first(
	 for alpha@j in rdB.simple_roots do alpha != rdC.simple_roots[j] od
	 )
    in (rdB,M,j0)


{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum
set_type
[ AffineCoroot = (vec linear_coroot, int shift)
, AffineCoWeylElt = (vec tau, WeylElt w) { apply |w|, then translate by |tau| }
]
{This is meant to record K-characters of different facets}
set Kpol_hash = make_KTypePol_hash()

set aff_rank (SimpleAffine Affd) = semisimple_rank(Affd) + 1

{.evaluate AffineCoroot at weight.}
set * (AffineCoroot (linear_coroot,shift), vec gamma) = int:
  linear_coroot*gamma + shift

{.evaluate AffineCoroot at rational weight.}
set * (AffineCoroot (linear_coroot,shift), ratvec gamma) = rat:
  linear_coroot*gamma + shift

{.apply AffineCoWeylElt to weight.}
set *(AffineCoWeylElt (tau,w) , vec gamma)    = vec:    tau + w*gamma
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = ratvec: tau + w*gamma

{.compose AffineCoWeylElts.}
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = AffineCoWeylElt:
    (tau1 + w1*tau2, w1*w2)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
    let w1=inverse(w) in (-w1*tau,w1)

{. act by AffineCoWeylElt on an AffineCoroot .}
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
    let bvw1=betav*inverse(w) in (bvw1, m-bvw1*tau)

{.simple affine coroots: number 0 is affine, rest are simple for RootDatum.}
set aff_simple_coroots (SimpleAffine affd) = [AffineCoroot]:
    (-highest_root(dual(affd)),1) #
    for alpha_v in simple_coroots(affd) do (alpha_v,0) od

{.sum of simple affine coroots times their labels is (null(rank),1).}
set labels(SimpleAffine affd) = [int]:
    let a = coroot_index(affd,highest_root(dual(affd))) in
    1 # coroot_expression(affd,a)

{.a common denominator for all vertices of alcoves.}
set denom (SimpleAffine affd) = int:
    let lab = labels(affd), fwts=affd.fundamental_weights in
    for fw@j in fwts do denom(fw)*lab[j+1] od.lcm

{.root attached to an AffineCoroot.}
set root (AffineCoroot (betav,m),SimpleAffine affd) = root(affd,betav)

{.affine reflection through Affine coroot, applied to weight.}
set reflection(AffineCoroot Betav, SimpleAffine affd, vec v) = vec:
    v - root(Betav,affd)*(Betav*v)

set reflection(AffineCoroot Betav, SimpleAffine affd, ratvec v) = ratvec:
    reflection(Betav, affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot strict inequalities and (n-k) AffineCoRoot equalities.
The total collection of affine coroots appearing must be a set of simple coroots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE. This representation is therefore not often used,
but see |facet0| (way) below }

set_type [Facet = ([AffineCoroot] pos,[AffineCoroot] zero)]

{ a UNIQUE characterization of a k-diml facet is as a set of k+1 vertices }

set_type FacetVerts = [ratvec]

set *(WeylElt w, FacetVerts FV) = FacetVerts:
    for v in FV do w*v od

set *(mat M, FacetVerts FV) = FacetVerts:
    for v in FV do M*v od

set *(AffineCoWeylElt wtilde, FacetVerts FV) = FacetVerts:
    for v in FV do wtilde*v od

{ Maybe the smallest UNIQUE characterization of a facet is the barycenter }
set_type FacetBary = ratvec

{represents a k-diml facet as k+1 indices into a list of vertices
(held elsewhere)}
set_type FacetVertsIndex = vec { of length k+1 for k-dimensional facet }

set_type
[  {BigFacetVerts = (vec vertIndex, vec bup, vec bdown)}
   FacetVertsHash = vec {last two entries are indices in
	 hashUp and hashDown}
, FacetVertsKHash = vec {last entry is index of KChar in some hash}
, LocalFacetVertsHash = vec
{ Size is 2 + (dimension d0 of local facet) + 1. First d0+1 are
  vertices in local vertex data; last two are indices in hashUp and
  hashDown }
, LocalFacetVertsKHash = vec {last entry is index of KChar in some hash}
, LocalFacetStatusVertsHash = (string status, vec verts_hash)
]

set_type
[ VertexData = ([ratvec] list, (ratvec->int) lookup)
, FacetStatusVertsIndex = (string status, FacetVertsIndex verts)
, FacetStatusVertsIndexHash = (string status, FacetVertsHash verts)
, FacetData = (VertexData v_data, [[FacetStatusVertsIndex]]
  facet_status_inds)
{, BigFacetStatusVertsIndex = (string status, BigFacetVerts bfverts)
, BigFacetData = (VertexData v_data
,   [[BigFacetStatusVertsIndex]] big_facet_status_inds)}
, FacetDataHash = (VertexData v_data
,   [[FacetVertsHash]] hash_facet_inds)
, LocalFacetDataHash = (VertexData v_data_local, KGBElt x,
  ratvec lambda, [[LocalFacetVertsHash]] LFverts)
, FacetDataK_old = (VertexData v_data
,   [[FacetStatusVertsIndex]] facet_status_inds
,   [[KTypePol]] Kchars)
,  FacetDataK = (VertexData v_data
,   [[FacetStatusVertsIndex]] facet_status_inds
,   [vec] Knums)
, FacetDataOldKchar = (VertexData v_data, [[FacetStatusVertsIndex]]
  facet_status_inds, [[ratvec]] old_barys, [[KTypePol]] Kchars)
, FacetDataKcharPO_old = (VertexData v_data, [[FacetStatusVertsIndex]] facet_status_inds
  , [[KTypePol]] Kchars, [vec] equiv_classes, [vec] graph
  , [vec] inherited_unitary_classes, [vec] class_by_facet
  , [string] class_status )
  ,  FacetDataKcharPO = (VertexData v_data
  , [[FacetStatusVertsIndex]] facet_status_inds, [vec] equiv_classes
  , [vec] graph, [vec] inherited_unitary_classes, [vec] class_by_facet
  , [string] class_status )
, FacetDataOldKcharPO = (VertexData v_data, [[FacetStatusVertsIndex]]
  facet_status_inds, [[ratvec]] old_barys, [[KTypePol]] Kchars
  , [vec] equiv_classes, [vec] graph
  , [vec] inherited_unitary_classes, [vec] class_by_facet
  , [string] class_status)
]

set to_vertex_data ([ratvec] vlist) = VertexData: (vlist,index_in(vlist))

set facet_indices((ratvec->int) lookup, FacetVerts facet) = FacetVertsIndex:
    for gammav in facet do lookup(gammav) od.sort

{.list of unsettled terms in statusIndex.}
set to_do([FacetStatusVertsIndex] statusIndex) = vec:
    for stindj@j in statusIndex
    do if (stindj.status="?" or
	 (#stindj.status > 1 and stindj.status[1]="t"))
       then [j] else []
       fi
    od.##

set sorted_is_subset([int] a, [int] b) = bool:
   let i=0, l=#b in
   for x in a
   do while if i<l then b[i]<x else return false fi do i+:=1 od
   ;  if x<b[i] then return false fi
   od; true

set sorted_is_disjoint([int] a, [int] b) = bool:
   let i=0, l=#b in
   for x in a
   do while if i<l then b[i]<x else return true fi do i+:=1 od
   ;  if x=b[i] then return false fi
   od; true

{.given a single nonunitary facet F, updates the status of all strictly larger
  E with F contained in E-bar (F on the boundary of E) to nonunitary.}
set update([[FacetStatusVertsIndex]] StInd, FacetStatusVertsIndex nonUnitary) =
    [[FacetStatusVertsIndex]]:
(  assert(nonUnitary.status[0] = "F","update only applies to NONunitary facets")
;  let NUverts = nonUnitary.verts then nNU = #NUverts
in { we traverse |StInd| while modifying sublists, so counted loop is best here }
   for e:#StInd - nNU from nNU { only traverse facets of dimesion >=nNU }
   do let StInde = StInd[e] { take a modifiable copy of the list }
   in for j in to_do(StInde)
      do let facet_info = StInde[j]
      in if facet_info.status = "?" and
            {sorted_is_subset(NUverts,facet_info.verts)}
	     is_subset_of(facet_info.verts)(NUverts)
	 then facet_info.status := nonUnitary.status
	 ; StInde[j] := facet_info
	 fi
      od
   ; StInd[e]:=StInde
   od
;  StInd
)

set update \
   ( [FacetStatusVertsIndex] allInd { just one level of lists here }
   , FacetStatusVertsIndex nonUnitary
   , int START { offset into |allInd| at which work starts }
   ) = [FacetStatusVertsIndex]:
(  assert(nonUnitary.status[0] = "F","update only applies to NONunitary facets")
;  for facet_info@j in allInd[START:] { this makes a copy of tail of |allInd| }
   do if facet_info.status = "?" and
	 {sorted_is_subset(nonUnitary.verts,facet_info.verts)}
	 is_subset_of(facet_info.verts)(nonUnitary.verts)
      then let f_i=facet_info { need a modifyable copy }
      in f_i.status := nonUnitary.status
      ; allInd[START+j] := f_i { update in place in argument |allInd| }
      fi
   od
;  allInd { return modified argument }
)

 {.this version REMOVES nonunitary facets from the lists.}
set updateCUT ( [[FacetStatusVertsIndex]] StInd, FacetStatusVertsIndex nonUnitary) =
   [[FacetStatusVertsIndex]]:
(   assert(nonUnitary.status[0] = "F",
			"update only applies to NONunitary facets")
;   let NUverts=nonUnitary.verts
in  for e:#StInd - #NUverts from #NUverts
    do  StInd[e] :=
        for facet in StInd[e]
        do if {sorted_is_subset(NUverts,facet.verts)}
	      is_subset_of(facet.verts)(NUverts)
	   then [] else [facet]
	   fi
	od.##
    od
;   StInd
)

{.given a single unitary (to_ht) facet F, updates the status of all E in F-bar to unitary (to_ht).}
set downdate ([[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex Unitary) =
   [[FacetStatusVertsIndex]]:
(   assert(Unitary.status[0] = "T",
    		"downdate only applies to unitary facets");
    let tester = is_subset_of(Unitary.verts), label = Unitary.status##"closure"
    then () = for e:#Unitary.verts-1 { only try facet lists up
	    		       to dimension of |Unitary| facet }
    do  let StInde = StInd[e]
    	in  for j in to_do(StInde)
	    do let facet=StInde[j]
	    in if facet.status = "?" and
	   {sorted_is_subset(facet.verts,Unitary.verts)}
	      tester(facet.verts)
	   then facet.status:=label
	   ; StInde[j]:=facet
	   fi
	   od
    ; StInd[e]:=StInde
    od
    in StInd
)

{ same but with just one level of list, which is considered only up to position |END| }
set downdate \
   ( [FacetStatusVertsIndex] allInd,FacetStatusVertsIndex Unitary, int END) =
     [FacetStatusVertsIndex]:
(   assert(Unitary.status[0] = "T",
    	        "downdate only applies to unitary facets");
    let tester = is_subset_of(Unitary.verts)
    then () = for facet_info@j in allInd[:END]
    	 do if facet_info.status = "?" and
    	 {sorted_is_subset(facet_info.verts,Unitary.verts)}
    	 tester(facet_info.verts)
       	 then let f_i=facet_info { need a modifiable copy }
       in f_i.status := Unitary.status
       ; allInd[j] := f_i { update in place in argument |allInd| }
       fi
    od
    in allInd { return modified argument }
)

{.given a single nonunitary facet F, updates the status of all E _MATCHING KCHAR_ in F-bar to nonunitary.} 
set downdateSingK([(vec->int)] lookups, FacetDataKchar (vd, StInd, Kpols),
FacetStatusVertsIndex big, KTypePol bigPol) =
    [[FacetStatusVertsIndex]]:
    let verts0 = big.verts
    then () = for e:#verts0 - 1
    do
    let StInde = StInd[e]
    in
    for S in choices_from(verts0,e+1)
    	do
	let j = lookups[e](S)
	in
	if j >= 0 then
	   let stej = StInde[j].status
	   in
	   if (stej = "?" or (#stej > 1 and stej[1]="t"))
	      and Kpols[e][j] = bigPol
	   then StInde[j]:=(big.status, StInde[j].verts)
	   fi
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

{.given a single nonunitary facet F, updates the status of all E
_MATCHING KCHAR_ in F-bar to nonunitary. Confine deletions to subset
Base of big.verts, and leave at least #Base.}
set downdateSingK([(vec->int)] lookups, FacetDataKchar (vd, StInd, Kpols),
FacetStatusVertsIndex big, KTypePol bigPol, vec Base) =
    [[FacetStatusVertsIndex]]:
    let verts0 = big.verts
    	, memberTest = is_member(Base)
    then comp = for j in verts0 do if memberTest(j) then [] else [j]
    	      	      	 	   fi od.##
    then () =assert((#comp + #Base = #verts0),"oops, comp is wrong")
    then most_out = min(#Base, #comp)
    then () = for f:most_out from 1
    	 {f is number removed from Base}
    do
    let e = #verts0-f-1  {size of new vertex set is #verts0 - f}
    then StInde = StInd[e]
    in
    for S in choices_from(Base, #Base - f)
    	do
	let j = lookups[e]((S##comp).sort)
	in
	if j >= 0 then
	   let stej = StInde[j].status
	   in
	   if (stej = "?" or (#stej > 1 and stej[1]="t"))
	      and Kpols[e][j] = bigPol
	   then StInde[j]:=(big.status, StInde[j].verts)
	   fi
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

set index_in_facet_list ([FacetStatusVertsIndex] L) = (vec->int):
    index_in(for (,v) in L do v od) { calls |index_in@[vec]| }

set index_in_facet_list([LocalFacetVertsHash] L) = (vec->int):
    let m = #L[0]-4 
    in index_in(for v in L do v[:m] od)

{.compute the |Facet| of a barycenter (or any point) in the fundamental alcove.}
set facet0(SimpleAffine Affd, FacetBary gamma) = Facet:
    let S = [AffineCoroot]: { the simple system for the fundamental alcove }
       Affd.aff_simple_coroots
in ( for av in S do if =av*gamma then [] else [av] fi od.## { positives }
   , for av in S do if =av*gamma then [av] else [] fi od.## { zeros }
   )

{.simple roots corresponding to simple affine coroots: number 0 is
affine,  rest are simple for RootDatum.}
set aff_simple_roots(SimpleAffine affd) = mat:
    (-highest_root(dual(affd))) # affd.simple_roots

{.vertices of the fundamental alcove, ordered by |affd.affine_simple_coroots|.}
{ the vertex corresponding to an affine simple coroot is the one nonzero on it }
set fundamental_vertices (SimpleAffine affd) = [ratvec]:
    (ratvec:null(affd.rank)) { origin is vertex for the truly affine s.c.r. } #
    (let labs=affd.labels[1:] in
     for lab@j in labs do fundamental_weight(affd,j)/lab od)

{. select vertices of fund. alcove for aff. simple coroots nonzero on |gamma0|.}
set facet_verts0(SimpleAffine affd, FacetBary gamma0) = FacetVerts:
    let vert=fundamental_vertices(affd) in
    for coroot@d in [AffineCoroot]: affd.aff_simple_coroots
    do if =coroot*gamma0 then [] else [vert[d]] fi
    od.##

set barycenter ([ratvec] verts) = ratvec: { |verts| should be nonempty }
    sum(#verts[0],verts) / #verts

{. barycenter of facet of fundamental alcove that contains |gamma0|.}
set facet_bary0(SimpleAffine affd, ratvec gamma0) = FacetBary:
    barycenter(facet_verts0(affd,gamma0))

{. produces all k-element subsets of verts. The term "# #verts" is
[0,1,...,#verts - 1]
 .}
set choices_from( [ratvec]verts, int k) = [[ratvec]]:
    for S in choices_from(# #verts,k) do for s in S do verts[s] od od

set facets_fundamental(SimpleAffine affd, int d) = [FacetVerts]:
    choices_from(fundamental_vertices(affd),d+1)

{ vertex sets for facets in the fundamental alcove, organized by dimension }
set facets_fundamental(SimpleAffine affd) = [[FacetVerts]]:
    let fund_vertices = fundamental_vertices(affd) in
    for d: affd.aff_rank do choices_from(fund_vertices,d+1) od

{.barycenters of d-dimensional facets in the fundamental alcove.}
set fund_barycenters(SimpleAffine affd, int d) = [FacetBary]:
    for facet in facets_fundamental(affd,d) do barycenter(facet) od

{.barycenters of facets in fundamental alcove, organized by dimension.}
set fund_barycenters(SimpleAffine affd) = [[FacetBary]]:
    for L in facets_fundamental(affd)
    do for facet in L do barycenter(facet) od
    od

{ enumerate sums of roots to be added to gamma to land in FPP }
set FPPtauRoots(SimpleAffine Affd, ratvec gamma) = [vec]:
    let g=for av in Affd.simple_coroots do av*gamma od,
    	FW = Affd.fundamental_weights,
	FCW = Affd.fundamental_coweights
    then INT = [int]: for j:#Affd.simple_coroots
	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od.##
    in
    for S in power_set(INT)
    do
	let tau = ratvec: sum(Affd.rank,
	    	for xi@j in FW
	      	do -floor(g[j])*xi
		od) +
	   	    sum(Affd.rank,for k in S do FW[k] od)
    	then (w,d) = %(ratvec: (for xiv in FCW do xiv*tau od))
    	in if d=1 then [w] else [] fi
     od.##

{ same thing, with (perhaps) one simple root j0 for which FPP takes values in
[0,2] on coroot j0. So need to use values -floor(g[j0]),
-floor(g([j0]) + 1 for that root always, and also -floor(g[j0]) + 2 if
g[j0] is an integer. }
{If j0 is in INT, then this counts 1*fundamental_weights[j0] WITH MULT 2}
set FPPtauRoots(SimpleAffine Affd, ratvec gamma, int j0) = [vec]:
    let g=^(Affd.simple_coroots)*gamma, flr = null(Affd.semisimple_rank)
    then INT = ##for j:#Affd.simple_coroots
	 do
	 if (flr[j]:= floor(g[j]))=g[j] then [j] else []
	 fi
	 od
    in
    let tau0 = -Affd.fundamental_weights*flr
    then taus = for S in power_set(INT)
	 do tau0+ sum(
	    Affd.rank,for j in S do Affd.fundamental_weights[j] od
		     )
	 od
    then () = if j0 >=0
    	      then taus:=taus## for tau in taus do tau+Affd.fundamental_weights[j0] od
	      fi
    in
    for tau in taus do
	if(all(
	for xiv in Affd.fundamental_coweights do is_integer(xiv*tau) od))
	then [ratvec_as_vec(tau)]
	else []
    fi
    od.##.no_reps

{ same thing, with (perhaps) one simple root j0 for which FPP takes
values in [0,2] on coroot j0. So need to use values -floor(g[j0]),
-floor(g([j0]) + 1 for that root always, and also -floor(g[j0]) + 2 if
g[j0] is an integer. This Fast version gives too many tau (finds
integral weights, not just root sums) unless G is adjoint and simply
connected, but it's up to 40% faster; when possible, just take the
extra tau and do a no_reps}

set FPPtauRootsFast(SimpleAffine Affd, ratvec gamma, int j0) = [vec]:
    let g=^(Affd.simple_coroots)*gamma, flr = null(Affd.semisimple_rank)
    then INT = ##for j:#Affd.simple_coroots
	 do
	 if (flr[j]:= floor(g[j]))=g[j] then [j] else []
	 fi
	 od
    in
    let tau0 = -Affd.fundamental_weights*flr
    then taus = for S in power_set(INT)
	 do tau0 + sum(
	    Affd.rank,for j in S do Affd.fundamental_weights[j] od
		     )
	 od
    then () = if j0 >=0
    	      then taus:=taus## for tau in taus do tau+Affd.fundamental_weights[j0] od
	      fi
     in for tau in taus
     	do let (tau0,d) = %tau
       	   in if d=1 then [tau0] else [] fi
	od.##

{ same thing, with NO j0 and root lattice equal weight lattice: G2,
F4, and E8. FW is fundamental weights.}
set FPPtauRootsE8(SimpleAffine Affd, [vec] FW, ratvec gamma) = [vec]:
    let g=^(Affd.simple_coroots)*gamma, flr = null(Affd.semisimple_rank)
    then INT = ##for j:#Affd.simple_coroots
	 do
	 if (flr[j]:= floor(g[j]))=g[j] then [j] else []
	 fi
	 od
    then tau0 = -FW*flr
    in for S in power_set(INT)
       do if #S=0 then tau0
       	  else tau0+ sum(for j in S do FW[j] od)
	  fi
       od

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) =
    (AffineCoWeylElt,ratvec):
    let tau = alcove_root_vertex(rd,gamma)
    then (w,gamma0TIMESDEN) = from_dominant(rd,gamma.numer - gamma.denom*tau)
    then gamma0 = gamma0TIMESDEN/gamma.denom
    then irdw = integrality_datum(rd,gamma0)
    then (x3,) = from_dominant(irdw, inverse(w)*rd.two_rho)
    then (w3,) = from_dominant(rd, w*(x3*(rd.two_rho))) {this is w*x3}
    in
    {assert (gamma=w*gamma0 + tau,"Bad affine!");}
    ((tau + w*ratvec_as_vec(gamma0 - x3*gamma0), w3), gamma0)

{.restored from 3/30/22 version for use in computing bigger facets with
same unitarity status.}
set facet (SimpleAffine Affd, ratvec gamma) = Facet:
   let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
   then (F0pos,F0zero) = facet0(Affd,gamma0)
   in (for betav in F0pos do wtilde*betav od
      ,for betav in F0zero do wtilde*betav od)

{ computes barycenter from a facet as a vertex list }
set facet_bary([ratvec] vert_list, FacetVertsIndex facet) = FacetBary:
    sum(#vert_list[0], for v in facet do vert_list[v] od)/(#facet)

{ this uses is_perturbed to test for certain whether the signature at
the big facet deforms correctly to the small one }
set updateSing(RealForm G, FacetData (vd, StInd),
{[[FacetBary]] FBs,} FacetStatusVertsIndex small) =
    [[FacetStatusVertsIndex]]:
    let verts0 = small.verts
    then P0 = finalize(parameter(x_open(G),G.rho,facet_bary(vd.list,verts0)))
    then CFK0 = K_type_pol(character_formula(P0))
    then () = for e:#StInd - #verts0 from #verts0
    do
    let StInde = StInd[e]
    then TODOe = to_do(StInde)
    in
    for j in TODOe
	do
	if StInde[j].status = "?" and
	is_subset_of(StInde[j].verts)(verts0) and
	K_type_pol(character_formula(finalize(parameter(x_open(G), G.rho,
	{FBs[e][j]} facet_bary(vd.list, StInde[j].verts))))) = CFK0
	then StInde[j] := (small.status,
	   StInde[j].verts) fi
	od;
    StInd[e]:=StInde
    od
    in StInd

set updateSingKdumb(RealForm G, FacetDataKchar (vd, StInd, Kpols),
    FacetStatusVertsIndex small, KTypePol smallPol) =
    [[FacetStatusVertsIndex]]:
    let verts0 = small.verts
    then () = for e:#StInd - #verts0 from #verts0
    do
    let StInde = StInd[e]
    then TODOe = to_do(StInde)
    in
    for j in TODOe
	do
	if StInde[j].status = "?" and
	is_subset_of(StInde[j].verts)(verts0) and
	Kpols[e][j] = smallPol
	then StInde[j] := (small.status##"def", StInde[j].verts) fi
	od;
    StInd[e]:=StInde
    od
    in StInd

{.computes the collection of vertex sets of alcoves containing gamma
in their closures.}
set openure(SimpleAffine Affd, ratvec gamma) = [FacetVerts]:
    let rdI = integrality_datum(Affd, gamma), FVS = facets_fundamental(Affd, Affd.ss_rank)[0]
    then (fromFund,) = (AffineCoWeylElt,ratvec): from_fundamental_alcove(Affd,gamma)
    then shakers = [AffineCoWeylElt]: for x in W(rdI)
	 do (ratvec_as_vec(gamma - x*gamma),x) od
    in for wtilde in shakers do wtilde*(fromFund*FVS) od

{ computes the FacetVerts (vertex set) of any barycenter of a facet of them }
set facet_verts(SimpleAffine Affd, ratvec gamma) = FacetVerts:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in wtilde*facet_verts0(Affd,gamma0)

set lookup_vertices_for_barycenters \
    (SimpleAffine Affd, VertexData vd, [FacetBary] centers) \
    = [FacetVertsIndex]:
    for gamma in centers
    do for vertex in facet_verts(Affd, gamma)
       do vd.lookup(vertex)
       od.sort
    od

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }
set facet(SimpleAffine Affd, ratvec gamma) = Facet:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    then (F0pos,F0zero) = facet0(Affd,gamma0)
    in (for betav in F0pos do wtilde*betav od ,
       for betav in F0zero do wtilde*betav od)

{ computes the FacetBary of any ratvec, for possibly nonsimple rd}
set facet_bary(RootDatum rd, ratvec gamma) = FacetBary:
    sum(rd.rank, for Affd in simple_factors(rd)
		 do
		 let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
		 in	wtilde*facet_bary0(Affd,gamma0)
		 od)

{.number of vertices in W*(fundamental alcove).}
set W_fund_vertices_card(SimpleAffine Affd) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    1+sum(for S in choices_from(listn,n-2) do rat_as_int(N/#W(Levi(Affd,S))) od )

{.number of d-diml facets in W*(fundamental alcove).}
set W_fund_d_facets_card(SimpleAffine Affd,int d) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    if d=n
    then N
    else sum(for T in choices_from(listn,n-d) do rat_as_int(N/#W(Levi(Affd,T))) od) +
	 sum(for S in choices_from(listn,n-d-1) do rat_as_int(N/#W(Levi(Affd,S))) od)
    fi

{.number of facets in W*(fundamental alcove).}
set W_fund_facets_card(SimpleAffine Affd) = [int]:
    for d:Affd.aff_rank
	do W_fund_d_facets_card(Affd,d)
	od
{.integrally dominant weights W-conjugate to a fundamental alcove vertex .}
set W_fund_verticesID(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do  for gammawn in Weyl_orbit(Affd,gamma.numer)
    	do if is_integrally_dominant(Affd,gammawn/gamma.denom)
	   then [gammawn/gamma.denom]
	   else []
	   fi
	od.##
    od.##

{.one rep of each translations-by-roots coset in each W orbit of a
fundamental alcove vertex.}
set W_fund_vertices_mod_R(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do  for w in affine_orbit_ws(Affd, gamma)
    	do w*gamma
	od
    od.##

set W_fund_barycentersID(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycentersID.")
    fi;
		for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
		   do if is_integrally_dominant(Affd,gammawn/gamma0.denom)
		   then [gammawn/gamma0.denom]
		   else[]
		   fi
		   od.##
		od.##
     od

set W_fund_barycenters_mod_R(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycenters_mod_R.")
    fi;
		for gamma0 in fund_barycenters(Affd)[d]
		do for w in affine_orbit_ws(Affd, gamma0)
		   do w*gamma0
		   od
		od.##
    od

{ to get everything in the FPP, should use only _integrally dominant_ gammaw in WA0.}
set W_fund_barycentersID(SimpleAffine Affd, int d) = [FacetBary]:
	if facet_verbose
	then prints("start W_fund_barycenters_mod_R(Affd, ",d,").")
	fi;
	for gamma0 in fund_barycenters(Affd)[d]
	do for gammawn in Weyl_orbit(Affd,gamma0.numer)
	    do
	    if is_integrally_dominant(Affd,gammawn/gamma0.denom)
	    then [gammawn/gamma0.denom]
	    else []
	    fi
	    od.##
	od.##

{.to get everything in the FPP, need just reps mod root lattice.}
set W_fund_barycenters_mod_R(SimpleAffine Affd, int d) = [FacetBary]:
	if facet_verbose
	then prints("start W_fund_barycenters_mod_R(Affd, ",d,").")
	fi;
	for gamma0 in fund_barycenters(Affd)[d]
	do for w in affine_orbit_ws(Affd, gamma0)
	   do (w*gamma0.numer)/gamma0.denom
	   od
	od.##

{translate that preserves integral dominance, lands in WFA; and
corresponding translation back down. This version avoids constructing the
integrality datum for gamma, which is one of the many in "random position."}
set beta2(RootDatum rd, ratvec gamma) = (vec,vec):
    let (wtilde,gamma2) = from_fundamental_alcove(rd,gamma)
    then (b,w) = wtilde {w*gamma2 + b = gamma}
    then iw = inverse(w)
    then irdw = integrality_datum(rd,gamma2)
    {this integrality datum is the nice restricted type!}
    then bup = -b + w*rd.two_rho
{so gamma + bup is w*(gamma2 + 2rho), in w(fund alcove + 2rho)}
    in (bup, -(iw*bup) )

set niceCF2(Param p) = ParamPol:
    let gamma = p.infinitesimal_character, rd = p.root_datum, (x,lr,nu) = %p
    then (bup,bdown) = beta2(rd,gamma)
    in translate_param_by(character_formula( 1*parameter(x, lr+rd.rho
    + bup, nu+bup)), bdown)
    
{imitates library FPP_w_shifts, allowing a single root #j0 that can be
up to 2 on FPP}
{need to ensure that w*gamma is integrally dominant!}
set FPP_w_shifts(RootDatum Affd, ratvec gamma, int j0) = [(WeylElt,[vec])]:
    if j0=-1
    then FPP_w_shifts(Affd,gamma)
    else let irdw = integrality_datum(Affd,gamma)
    	 in for w in affine_orbit_ws(Affd,gamma)
    	 do let (x3,) = from_dominant(irdw,inverse(w)*(Affd.two_rho))
	    then (wprime,) = from_dominant(Affd, w*(inverse(x3)*Affd.two_rho))
	 in (wprime, FPPtauRoots{Fast}(Affd,wprime*gamma,j0))
	 od{.no_reps}
    fi

{.this includes all vertices of facets in the fundamental
parallelepiped, each exactly once. j0 is possible label of a simple
coroot that can be up to 2 on FPP}
set FPP_vertices(SimpleAffine Affd, int j0) = [ratvec]:
    if facet_verbose then prints("start FPP_vertices.")
    fi;
    for gamma in fundamental_vertices(Affd)
    do let aff_short_list = FPP_w_shifts(Affd,gamma,j0)
	  then aff_list = [AffineCoWeylElt]:
	       for (w,taus) in aff_short_list
	       do for tau in taus do (tau,w) od
	       od.##
	  in for wtilde in aff_list do wtilde*gamma od
       od.##

set FPP_vertices(RealForm G) = [ratvec]:
    if facet_verbose then prints("start FPP_vertices of real form, ",G)
    fi;
    let (Affd,M,j0) = cofolded(G)
    in for v in FPP_vertices(Affd,j0) do M*v od

set FPP_verticesE8(SimpleAffine Affd) = [ratvec]:
    if facet_verbose then prints("start FPP_verticesE8.")
    fi;
    let FW = for xi in Affd.fundamental_weights do ratvec_as_vec(xi) od
    in
    for gamma in W_fund_vertices_mod_R(Affd)
    do
    for tau in FPPtauRootsE8(Affd,FW,gamma)
	do gamma+tau od
    od.##

set FPP_barycenters(SimpleAffine Affd, int dim, int j0) = [FacetBary]:
    if facet_verbose then prints("start dim ",dim,
       		     " in FPP_barycenters(Affd,",dim,").")
    fi;
    let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    in for FV@k in facets
       do { if facet_verbose
       	  then prints("start fund facet ",k," of ", #facets)
	  fi; }
       	  let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	  then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	  then aff_list = [AffineCoWeylElt]:
	       for (w,taus) in aff_short_list
	       do for tau in taus do (tau,w) od
	       od.##
	  in for wtilde in aff_list do wtilde*bary_F od
       od.##

set FPP_barycentersE8(SimpleAffine Affd, int d) = [FacetBary]:
    if facet_verbose then prints("start dim ",d,
       		     " in FPP_barycentersE8(Affd,",d,").")
    fi;
    let WBsd = W_fund_barycenters_mod_R(Affd, d),
    FW = for xi in Affd.fundamental_weights do ratvec_as_vec(xi) od
    in
    for gamma in WBsd
	do
	for tau in FPPtauRootsE8(Affd,FW,gamma)
	    do gamma+tau od
	od.##

set FPP_barycenters(SimpleAffine Affd, int j) = [[FacetBary]]:
    if facet_verbose then prints("start FPP_barycenters.")
    fi;
    for d:Affd.aff_rank
    do
    FPP_barycenters(Affd,d,j)
    od


set FPP_barycentersE8(SimpleAffine Affd) = [[FacetBary]]:
    if facet_verbose then prints("start FPP_barycentersE8.")
    fi;
    for d:Affd.aff_rank
    do
    FPP_barycentersE8(Affd,d)
    od

set FPP_vertex_data (SimpleAffine Affd, int j) = VertexData:
   FPP_vertices(Affd,j).to_vertex_data

set FPP_vertex_data(RealForm G) = VertexData:
    FPP_vertices(G).to_vertex_data

{these are to store translations for delta-fixed FPP infl chars}
set hashUp = make_vec_hash()
set hashDown = make_vec_hash()

{ using FPP_w_shift }
set FPP_facets(SimpleAffine Affd, VertexData vd, int dim, int j0) =
    [FacetVertsIndex]:
    let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    then ()= if facet_verbose
    	     then prints("start dim ",dim, " in FPP_facets")
	     fi
    in for FV@k in facets
       do if fund_facet_verbose or (facet_verbose and k=0)
       	  then prints("start fund facet ",k," of ", #facets, " in dim = ",dim,
	       " in FPP_facets")
	  fi;
	  let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	  then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	  then aff_list = [AffineCoWeylElt]:
	       for (w,taus) in aff_short_list
	       do for tau in taus do (tau,w) od
	       od.##
	  in [FacetVertsIndex]:
	     for wtilde in aff_list
	     do FacetVertsIndex:
		      for v in wtilde*FV
		      do vd.lookup(v)
		      od.sort
	     od { type is [FacetVertsIndex], remains for next line}
	 od.##

set FPP_facets_hash(SimpleAffine Affd, VertexData vd, int dim, mat M,
int j0) = [FacetVertsHash]:
    let () = if facet_verbose
    	     then prints("start dim ",dim, " in FPP_facets_hash")
	     fi
    then zero = null(Affd.rank)
    then mZeroUp = hashUp.match(M*zero), mZeroDown = hashDown.match(M*zero)
    in if Affd.semisimple_rank - dim <= facet_codim
       then [FacetVertsHash]:
	    for FV in FPP_facets(Affd, vd, dim, j0)
	    do  FV##[mZeroUp, mZeroDown]
	    od
       else let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	    in [FacetVertsHash]:
       	       for FV@k in facets
       	       do if (facet_verbose and k=0) or fund_facet_verbose
       	       	  then prints("start fund facet ",k," of ", #facets,
	       	       " in dim ", dim," in FPP_facets_hash; hashUp.size() = ",
		       hashUp.size())
	       	  fi;
	       	  let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	       	  then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	  then aff_list = [AffineCoWeylElt]:
	       	       for (w,taus) in aff_short_list
	       	       do for tau in taus do (tau,w) od
	       	       od.##
	       	  in for wtilde in aff_list
	       	     do let (tau,w) = wtilde
	     	     	then iw = inverse(w)
	     	     	then bup = -tau + w*Affd.two_rho
	     	     	then mup = hashUp.match(M*bup)
	     	     	then mdown = hashDown.match(M*(-iw*bup))
	     	     	in FacetVertsIndex:
		     	   (for v in wtilde*FV
		  	    do vd.lookup(v)
		  	    od.sort)##[mup,mdown]
     		      od
	     	 od.##
     	 fi

{second output is indices in ktp_hash of K-chars}
{for now only works in unfolded case; G should be split}
{Also translation will fail outside split spherical}
set FPP_facets_KHash(RealForm G, VertexData vd, int dim, KTypePol_hash ktp_hash) =
    [FacetVertsKHash]:
    let () = if facet_verbose
    	     then prints("start dim ",dim, " in FPP_facets_Khash")
	     fi
    then x=x_open(G), lambda=G.rho
    then (Affd,M,j0) = cofolded(G)
    then facets = [FacetVerts]: facets_fundamental(Affd,dim)
    in [FacetVertsKHash]:
       	    	 for FV@k in facets
       	    	 do if (facet_verbose and k=0) or fund_facet_verbose
       	       	       then prints("start fund facet ",k," of ", #facets,
	       	       " in dim ", dim,
		       " in FPP_facets_Khash; ktp_hash.size() = ",
		       ktp_hash.size())
	       	    fi;
	       	    let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	       	    then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	    then aff_list = [AffineCoWeylElt]:
	       	    	 for (w,taus) in aff_short_list
	       	    	 do for tau in taus do (tau,w) od
	       	       	 od.##
	       	    	 in for wtilde in aff_list
	       	  	    do let (tau,w) = wtilde
	     	     	       then iw = inverse(w)
	     	     	       then bup = M*(-tau + w*Affd.two_rho)
			       then bdown = M*(iw*tau - Affd.two_rho)
			       then bary = M*(wtilde*bary_F)
	     	     	       in FacetVertsKHash:
		     	       (for v in wtilde*FV
		  	       	do vd.lookup(M*v)
		  		od.sort)##[ktp_hash.match(K_type_pol(translate_param_by(
			    character_formula(1*parameter(x,
			    lambda+bup,bary+bup)), bdown)))
				]
     		   	    od
	     	   od.##

{works only for simply connected adjoint}
set FPP_facetsE8(SimpleAffine Affd, VertexData vd, int dim) =
    [FacetVertsIndex]:
    let facets = [FacetVerts]: facets_fundamental(Affd,dim),
    FW = for xi in Affd.fundamental_weights do ratvec_as_vec(xi) od
    in [FacetVertsIndex]: for FV@k in facets
       do if fund_facet_verbose or (facet_verbose and k=0)
       	  then prints("start fund facet ",k," of ", #facets, " in dim = ",dim,
	       " in FPP_facetsE8")
	  fi;
	  let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
 	  in [FacetVertsIndex]:
	     for w in affine_orbit_ws(Affd,bary_F)
	     do for tau in FPPtauRootsE8(Affd,FW,w*bary_F)
	     	do FacetVertsIndex:
		      for v in (AffineCoWeylElt:(tau,w))*FV
		      do vd.lookup(v)
		      od.sort
	      	od { type is [FacetVertsIndex], remains for next 2 lines}
	     od.##
     	 od.##

set FPP_facetsE8(SimpleAffine Affd, int dim) = [FacetVertsIndex]:
    FPP_facetsE8(Affd, FPP_verticesE8(Affd).to_vertex_data, dim)

set FPP_facets (SimpleAffine Affd, [ratvec] vlist, int dim,
    int j) =
    [FacetVertsIndex]:
    FPP_facets(Affd, to_vertex_data(vlist), dim, j)

set FPP_facetsE8(SimpleAffine Affd, [ratvec] vlist, int dim) =
    [FacetVertsIndex]:
    FPP_facetsE8(Affd, to_vertex_data(vlist), dim)

set FPP_facetsE8 (SimpleAffine Affd, VertexData vd) =
    [[FacetVertsIndex]]:
      ([vec]:for @j in vd.list
      do [j]
      od) { singleton indices } #
      for dim: Affd.semisimple_rank from 1
      do [FacetVertsIndex]: FPP_facetsE8(Affd, vd, dim)
      od

set FPP_facets(SimpleAffine Affd, VertexData vd, int j) =
    [[FacetVertsIndex]]:
      ([vec]:for @j in vd.list
      do [j]
      od) { singleton indices } #
      for dim: Affd.semisimple_rank from 1
      do FPP_facets(Affd, vd, dim, j)
      od

set FPP_facets_hash(SimpleAffine Affd, VertexData vd, mat M, int j) =
    [[FacetVertsHash]]:
    for dim: Affd.semisimple_rank + 1
    do FPP_facets_hash(Affd, vd, dim, M, j)
    od

set FPP_facets_KHash(RealForm G, VertexData vd, KTypePol_hash ktp_hash) =
    [[FacetVertsKHash]]:
    for dim: G.semisimple_rank + 1
    do FPP_facets_KHash(G, vd, dim, ktp_hash)
    od

set facet_dataE8(SimpleAffine Affd,int j) = FacetData:
   let vd = FPP_vertex_data(Affd,j)
   then facets_indexed = FPP_facetsE8(Affd,vd)
   in (vd,for L in facets_indexed do for v in L do ("?",v) od od)

set facet_data(SimpleAffine Affd, int j) = FacetData:
   let vd = FPP_vertex_data(Affd,j)
   then facets_indexed = FPP_facets(Affd,vd,j)
   in (vd,for L in facets_indexed do for v in L do ("?",v) od od)


{transfers the status-by-class information in statuses to FDind}
set statuses_to_facets(RealForm G, VertexData vd,
    [[FacetStatusVertsIndex]] FDind, [vec] eq, [string] statuses) =
    FacetData:
    let FDindOne = FDind.##
    then () = for cl@m in eq
    	 do for n in cl
       	    do FDindOne[n] := (statuses[m],FDindOne[n].verts)
       	    od
    	 od
    then N = int: 0
    in (vd, for d:#FDind do FDindOne[N:N+#FDind[d]] next N+:= #FDind[d]
    			od)

{transfers the status-by-class information in statuses to FDind}
set statuses_to_facets(RealForm G, FacetDataKcharPO_old(vd, FDind, , eq, ,
    			, , statuses)) = FacetData:
    statuses_to_facets(G,vd,FDind,eq,statuses)

{same for KCharNum}
set statuses_to_facets(RealForm G, FacetDataKcharPO(vd, FDind,eq,,,
, statuses)) = FacetData:
    statuses_to_facets(G,vd,FDind,eq,statuses)

{extra argument j0 is a possible simple coroot allowed to be 2 on FPP;
use -1 if there's none}
set facet_data_fold(SimpleAffine Affd, mat M, int j0) =
    FacetData:
(   let vertex_dataFold = FPP_vertex_data(Affd,j0)
    then vertex_listG = for v in vertex_dataFold.list do M*v od
    then vertex_dataG = vertex_listG.to_vertex_data
    then N= [(string,vec)]: for @j in vertex_dataFold.list do ("?",[j]) od
    in
    ( vertex_dataG
    , [[(string,vec)]]:
      N #
      for d: Affd.semisimple_rank from 1
      do  {now need d-diml facets}
      	   for v in FPP_facets(Affd,vertex_dataFold,d,j0)
      	   do ("?",v)
      	   od
      od
    )
)

set facet_data_fold_hash(SimpleAffine Affd, mat M, int j0) =
    FacetDataHash:
(   let vertex_dataFold = FPP_vertex_data(Affd,j0)
    then vertex_listG = for v in vertex_dataFold.list do M*v od
    then vertex_dataG = vertex_listG.to_vertex_data
    then index = [[FacetVertsHash]]:
    	 for d: Affd.semisimple_rank+1
      	 do  {now need d-diml facets}
	     FPP_facets_hash(Affd,vertex_dataFold,d,M,j0)
	 od
    in (vertex_dataG, index)
)

set facet_data_foldE8(RealForm G) = FacetData:
(   let vertex_dataG = FPP_vertex_data(G)
    then N= [(string,vec)]: for @j in vertex_dataG.list do ("?",[j]) od
    in
    ( vertex_dataG
    , [[(string,vec)]]:
      N #
      for d: G.semisimple_rank from 1
      do  {now need d-diml facets}
      	   for v in FPP_facetsE8(G,vertex_dataG,d)
      	   do ("?",v)
      	   od
      od
    )
)

set facet_data_fold_hash(RealForm G) = FacetDataHash:
    facet_data_fold_hash(cofolded(G))

{This computes only OPEN facets. Extra argument is a possible simple
coroot allowed to be 2 on FPP}
set facet_data_fold_open(SimpleAffine Affd, mat M, int j0) =
(VertexData, [FacetStatusVertsIndex]):
(   let vertex_dataFold = FPP_vertex_data(Affd,j0)
    , fundVerts = facets_fundamental(Affd)
    then vertex_listG = for v in vertex_dataFold.list do M*v od
    then vertex_dataG = vertex_listG.to_vertex_data
    then d = Affd.semisimple_rank
    in
    ( vertex_dataG
    , [(string,vec)]:
      if facet_verbose
	  then prints("start facet_data_fold_open")
	  fi
      ;
	  for FV in fundVerts[d]
	  do  let FB = FacetBary: barycenter(FV)
	      then WBs_mod_R= [FacetBary]:
		  for w in affine_orbit_ws(Affd,FB)
		  do w*FB
		  od
	  in  [FacetStatusVertsIndex]:
	      for wFB in WBs_mod_R
	      do  let (w,) = from_dominant(Affd,wFB)
	      in  [(string, vec)]:
		  for tau in FPPtauRoots(Affd,wFB,j0)
 		  do ("?", vec: facet_indices(
		     vertex_dataFold.lookup, (tau,w)*FV))
		  od
	      od.##{ now type [string,vec] }
	  od.##
    )
)

set facet_data_fold_open(RealForm G) = (VertexData,
    [FacetStatusVertsIndex]):
    facet_data_fold_open(cofolded(G))

{ last two ints index a facet in FD now known to be nonunitary. }
set updateNU([[FacetStatusVertsIndex]] FD, [vec] equiv, [vec] fullUpClasses
    , [vec] classLists, int d,int j) = [[FacetStatusVertsIndex]]:
    let class = classLists[d][j]
    then () = for m in fullUpClasses[class]
    	      do
		let (d1,j1) = coords(FD, equiv[m][0])
		    then () = if FD[d1][j1].status = "?"
	     	    	      then for n in equiv[m]
	   	    	      	   do let (dx,jx) = coords(FD,n)
		     	    	      then FDdx = FD[dx]
		     	    	      in FDdx[jx] := ("Fdef",FD[dx][jx].verts)
		     	    	      ; FD[dx] :=FDdx
		  	 	   od
			      fi
         	in FD {this is terrifyingly wrong!}
    	    od
    in FD

{ m is a class known to be nonunitary; update classes above using INUCL}
set updateNUclasses([string] statuses, vec INUCLchange, int m) = [string]:
    let () = for k in INUCLchange do if statuses[k] = "?"
    	     		   then statuses[k] := "Ffrom"##to_string(m)
			   fi
			od
    in statuses

{ m is a class known to be nonunitary; update classes above using
graph; label as "Ffrom"##tail}
{ first list in toDo all n covering m; then what covers those...
These get larger and larger.}
set updateNUclassesB([string] statuses, [[int]] covers, int m,
string tail) = [string]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
    	,id_mat(1)).quasicompact_form {CALLER SHOULD HANDLE NEXT LINE}
    then x0 = KGB(G1,0)
    then toDo = sum(G1, for n in covers[m] do 1*K_type(x0,[n]) od) {+
    	 (if statuses[m] = "?" then 1 else 0 fi)*K_type(x0,[m])}
    then () = while #toDo != 0
    	      do
	      let list = vec:
	      	  for p in monomials(toDo)
		  do lambda_rho(p)[0]
		  od
	      then () = toDo := sum(G1, for n in list
	      	   	  	  do sum(G1,
					for q in covers[n]
					do 1*K_type(x0,[q]) od)
				  od)
	      in for k in list
	      	 do  if statuses[k] = "?"
    	     	     then statuses[k] := "Ffrom"##tail
		     fi
		 od
	      od
    in statuses

{ m is a class known to be nonunitary; update classes above using
graph; label as "Ffrom"m}
set updateNUclassesB([string] statuses, [[int]] covers, int m) = [string]:
    updateNUclassesB(statuses, covers, m, to_string(m))

set downdateU([[FacetStatusVertsIndex]] FD, [vec] equiv, [vec] fullDownClasses
    , [vec] classLists, int d,int j) = [[FacetStatusVertsIndex]]:
    let class = classLists[d][j]
    then () = for m in fullDownClasses[class]
    	      do
		let (d1,j1) = coords(FD, equiv[m][0])
		    then () = if FD[d1][j1].status = "?"
	     	    	      then for n in equiv[m]
	   	    	      	   do let (dx,jx) = coords(FD,n)
		     	    	      then FDdx = FD[dx]
		     	    	      in FDdx[jx] := ("Tdef",FD[dx][jx].verts)
		     	    	      ; FD[dx] :=FDdx
		  	 	   od
			      fi
         	in FD {this is terrifyingly wrong!}
    	    od
    in FD
{m is a class known to be unitary; update classes below using IUCL}
set downdateUclasses([string] statuses, vec IUCLchange, int m,
    string tail) = [string]:
    let () = for k in IUCLchange do if statuses[k] = "?"
    	     		   then statuses[k] := "Tfrom"##tail
			   fi
			od
    in statuses


{m is a class known to be unitary; update classes below using graph}
{first list in toDo everything covered by m: the n so m appears in covers[n].
Then what those cover... These n get SMALLER.}
set downdateUclassesB([string] statuses, [[int]] covers, int m,
string tail) = [string]:
    let G1 = inner_class(root_datum(null(1,0),null(1,0))
    	,id_mat(1)).quasicompact_form
    then x0 = KGB(G1,0)
    then toDo = (if statuses[m] = "?" then 1 else 0 fi)*K_type(x0,[m])
    then () = toDo +:= sum(G1, for C@n in covers[:m]
    	      	  	  ~do (if is_member_sorted(C)(m) then 1
			      else 0 fi)*K_type(x0,[n])
    	 {(if statuses[n] = "?" then 1 else 0 fi)}
			   od)
    then () = while #toDo != 0
    	      do
	      let list = vec:
	      	  for p in monomials(toDo)
		  do lambda_rho(p)[0]
		  od
	      then () = toDo :=
	      	   sum(G1, for n in list
	      	   	   do sum(G1, for C@q in covers[:n]
				      ~do (if is_member_sorted(C)(n)
				      	  then 1 else 0 fi)*K_type(x0,[q])
				      od)
			   od)
	      in for k in list
	      	 do  if statuses[k] = "?"
    	     	     then statuses[k] := "Ffrom"##tail{to_string(m)}
		     fi
		 od
	      od
    in statuses

set downdateUclasses([string] statuses, vec IUCLchange, int m) =
[string]:
	downdateUclasses(statuses, IUCLchange, m, to_string(m))

{.output is |dim| and indices into |FPPInd[dim]| to alcoves containing Base in
  their closure, for the largest |dim| for which this is non empty.}
set FPPopenureAlcoves \
   ([[FacetStatusVertsIndex]] FPPInd, FacetVertsIndex Base) = (int, vec):
    let degree = #FPPInd { initial too high value }
in  for L@dim in FPPInd { run through dimensions in decreasing order }
   ~do  let result =
        for facet@j in L
	do  if {sorted_is_subset(Base,facet.verts)}
	    is_subset_of(facet.verts)(Base) then [j] else [] fi
	od.##
    in  if >#result then return(dim,vec: result) fi
    od; (minus_1,[]) { if nothing found, report failure }

{.allow for the possibility that not all alcoves are indexed. Finds all alcoves
 in FPP containing Base in closure, even if not indexed.}
set FPPopenureAllAlcoves \
   (SimpleAffine Affd, VertexData vd, FacetVertsIndex Base) = [FacetVertsIndex]:
    for facet in [FacetVerts]: openure(Affd, facet_bary(vd.list,Base))
    do let indices = facet_indices(vd.lookup,facet)
    in if indices.>= { no negatives: all found } then [indices] else [] fi
    od.##

{. Given a list of alcoves represented as FacetVertsIndex, and a base
FacetVertsIndex Base, finds all indexed facets E having Base in their closure

I think lookups[d] takes a list of d+1 vertices and (if it's a
d-dimensional facet) returns its index in some hidden list of all
facets.

If Base has dimension d (d+1 vertices) then output[m] indexes
facets of dimension d+1+m with Base in closure .}
{IMPROVEMENT?: make output[m]  [vec], with each vec of size m+1 listing
vertices not in base}
set FPPopenureFacets \
    ( [FacetVertsIndex] Alcoves
    , [(vec->int)] lookups
    , FacetVertsIndex Base
    ) = [vec]:
    let BaseComps = [FacetVertsIndex]:
	for A in Alcoves
	do  for j in A do if isnt_member(Base)(j) then [j] else [] fi od.##
	od
in  if #BaseComps = 0 then []
    else [vec]:
       for m:#BaseComps[0]
       do vec:
	   for BC in BaseComps
	   do vec:
	      for S in choices_from(BC, m+1)
	      do let j = lookups[#Base+m](vec: sort(Base##S))
	      in if j>=0 then [j] else [] fi
	      od.##
	   od.##
       od
   fi

set FPPopenureFacets \
    ( [[FacetStatusVertsIndex]] FPPInd
    , [(vec->int)] lookups
    , FacetVertsIndex Base
    ) = [vec]:
    let (d,Alcs) = FPPopenureAlcoves(FPPInd, Base)
    then Alcoves = [FacetVertsIndex]: for j in Alcs do FPPInd[d][j].verts od
    in FPPopenureFacets(Alcoves, lookups, Base)

{only remove vertices in Base \subset Unitary.verts}
set downdate \
   ( [(vec->int)] lookups
   , [[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex Unitary
   , vec Base
   ) = [[FacetStatusVertsIndex]]:
    assert(Unitary.status[0] = "T","downdate only applies to unitary facets");
    let Uverts = Unitary.verts
    	, memberTest = is_member(Base)
	, newlabel = (Unitary.status)##"closure"
    then comp = for j in Uverts do if memberTest(j) then [] else [j]
    	      	      	 	   fi
				od.##
    then () =assert((#comp + #Base = #Uverts),"oops, comp is wrong")
    then most_out = min(#Base, #comp)
    then () = for f:most_out from 1
    	 { f is number removed from Base}
    do
    let e = #Uverts-f-1  {size of new vertex set is #Uverts - f}
    then StInde = StInd[e]
    in
    for S in choices_from(Base,#Base - f)
	do
	let j = lookups[e]((S##comp).sort)
	in
	if j >= 0 then
	   let stej = StInde[j].status
	   in
	   if stej = "?"
	   then StInde[j]:=(newlabel, StInde[j].verts)
	   fi
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

{.given a single nonunitary facet F, updates the status of all E with F
 contained in E-bar to nonunitary. Uses Indices into the FacetVerts sets}
set update \
    ( [vec] OpenureFacets
    , [[FacetStatusVertsIndex]] StInd
    , FacetStatusVertsIndex nonUnitary
    ) = [[FacetStatusVertsIndex]]:
(   assert(nonUnitary.status[0] = "F"
    	  ,"update only applies to NONunitary facets")
;   let NUverts = nonUnitary.verts
in  for e:#OpenureFacets from #NUverts
    do  let opene = OpenureFacets[e-#NUverts], StInde= StInd[e]
	in for j in opene
	do let stej = StInde[j].status
	in
	    if stej = "?" or (#stej > 1
	       and stej[1]="t")
	    {Still fails!	then StInde[j].status:=nonUnitary.status}
	    then StInde[j] := (nonUnitary.status, StInde[j].verts)
	    fi
	od
    ;   StInd[e]:=StInde
    od
;   StInd
)

set update \
    ( [(vec->int)] lookups
    , [[FacetStatusVertsIndex]] StInd
    , FacetStatusVertsIndex nonUnitary
    ) = [[FacetStatusVertsIndex]]:
    update( FPPopenureFacets(StInd, lookups, nonUnitary.verts)
          , StInd, nonUnitary)

{.given a single nonunitary facet F, updates the status of all E with F
 contained in E-bar to nonunitary; then goes to _smaller_ facets where
 allowed by perturbation. Uses Indices into the FacetVerts sets}
set updateClosureK \
    ( [vec] OpenureFacets
    , [(vec->int)] lookups
    , FacetDataKchar (vdata, StInd, Pols)
    , FacetStatusVertsIndex nonUnitary
    ) = [[FacetStatusVertsIndex]]:
(   assert(nonUnitary.status[0] = "F"
    	  ,"updateK only applies to NONunitary facets")
;   let NUverts = nonUnitary.verts
in  for e:#OpenureFacets from #NUverts
    do  let opene = OpenureFacets[e-#NUverts], StInde= StInd[e]
	in for j in opene
	do let stej = StInde[j].status
	in
	    if stej = "?"
	    then StInde[j] := ("Fdef", StInde[j].verts)
	    ; StInd:= downdateSingK(lookups
			, (vdata, StInd, Pols), ("Fdef", StInde[j].verts)
			, Pols[e][j], NUverts)
	    fi
	od
    	; StInd[e]:=StInde {already happens in downdate?}
    od
;   StInd
)

{want to make a version just running through bigger facets}
{But this tests 10% slower in Sp(10,R)}
set updateClosureKdumb \
    ( [(vec->int)] lookups
    , FacetDataKchar (vdata, StInd, Pols)
    , FacetStatusVertsIndex nonUnitary
    ) = [[FacetStatusVertsIndex]]:
(   assert(nonUnitary.status[0] = "F"
    	  ,"updateClosureKdumb only applies to NONunitary facets")
;   let NUverts = nonUnitary.verts
in  for e:#StInd-#NUverts from #NUverts
    do  let StInde = StInd[e]
	in for Find@j in StInde
	   do let stej = Find.status
	      in
	    if stej = "?" and is_subset_of_sorted(Find.verts)(NUverts)
	    then StInde[j] := ("Fdef", Find.verts)
	    {prefer to do next only down exactly to #NUverts}
	    ; StInd:= downdateSingK(lookups, (vdata, StInd, Pols), StInde[j],
	    	    			   Pols[e][j],NUverts)
	    fi
	od
    	; StInd[e]:=StInde {already happens in downdate?}
    od
;   StInd
)

set updateClosureK \
    ( [(vec->int)] lookups
    , FacetDataKchar(vdata, StInd,Pols)
    , FacetStatusVertsIndex nonUnitary
    ) = [[FacetStatusVertsIndex]]:
    updateClosureK(FPPopenureFacets(StInd, lookups, nonUnitary.verts)
    , lookups, (vdata, StInd, Pols), nonUnitary)

{should be applied just when small facet is unitary}
set updateSingK \
    ( [vec] OpenureFacets
    , [(vec->int)] lookups
    , FacetDataKchar (vd, StInd, Kpols)
    , FacetStatusVertsIndex small
    , KTypePol smallPol
    ) = [[FacetStatusVertsIndex]]:
    let verts0 = small.verts
    then () = for e:#OpenureFacets from #verts0
       do let opene = OpenureFacets[e-#verts0], StInde = StInd[e]
       	  then TODOe = to_do(StInde)
       	  in for j in opene
	     do
		if StInde[j].status = "?" and {{should be automatic}
		   is_subset_of(StInde[j].verts)(verts0) and}
		   Kpols[e][j] = smallPol
		then StInde[j] := (small.status##"def", StInde[j].verts)
		; StInd := downdate(lookups, StInd, StInde[j], small.verts)
		fi
	     od;
    	    StInd[e]:=StInde
       od
    in StInd

set updateSingK \
    ( [(vec->int)] lookups
    , FacetDataKchar(vdata, StInd,Pols)
    , FacetStatusVertsIndex nonUnitary
    , KTypePol nonUnitaryPol
    ) = [[FacetStatusVertsIndex]]:
    updateSingK( FPPopenureFacets(StInd, lookups, nonUnitary.verts)
    , lookups, (vdata, StInd, Pols), nonUnitary, nonUnitaryPol)

{.given a single unitary (to_ht) facet F, updates the status of all E in F-bar to unitary (to_ht).}
set downdate \
   ( [(vec->int)] lookups
   , [[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex Unitary
   ) = [[FacetStatusVertsIndex]]:
    assert(Unitary.status[0] = "T","downdate only applies to unitary facets");
    let Uverts = Unitary.verts
    then () = for e:#Uverts-1
    do
    let StInde = StInd[e]
    in
    for S in choices_from(Uverts,e+1)
	do
	let j = lookups[e](S)
	in
	if j >= 0 then
	   let stej = StInde[j].status
	   in
	   if stej = "?" { or (#stej > 1 and stej[1]="t") }
	   then StInde[j]:=(Unitary.status, StInde[j].verts)
	   fi
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

{ adds nonunitary status in dimension d+1 when deformed from a nonunitary
in dimension d. lookup is for [d].}
set one_up((vec->int) lookup, FacetDataKchar (vd, FPPstInd, Pols), int d) =
    [[FacetStatusVertsIndex]]:
    assert(0 <= d and d < #FPPstInd-1,"requesting one_up in invalid degree");
    let FPPstIndUp = FPPstInd[d+1]
    then () = for FindUp@j in FPPstIndUp
    do
     if FindUp.status="?" then
       let PUp = Pols[d+1][j], vertsUp = FindUp.verts
       in {prefer to construct subsets of VertsUp}
       	  for i:#vertsUp
	  do
	  let k = lookup(delete(vertsUp,i))
	  in  if k>= 0
		       and FPPstInd[d][k].status[0] = "F"
		       and Pols[d][k] = PUp
	    	    then FPPstIndUp[j] := ("Fdef", vertsUp)
		    ; break
	      fi
	  od
      fi
     od
     ; FPPstInd[d+1]:= FPPstIndUp
     in FPPstInd
 
{ meant to record information about unitarity for all facets }
set facet_status([[ratvec]] FPPB) = [[string]]:
    for FPPBd in FPPB do for FB in FPPBd do "?" od od

set facet_status([[vec]] FPPind) = [[string]]:
    for FPPindd in FPPind do for Find in FPPindd do "?" od od

{ meant to record information about unitarity for all facets }
{now marks unipotent parameters as "T[number of dual nilpotent]"}
{Now that we are emphasizing cofolded G, I THINK that for a simple G(R), all unipotent parameters must be
barycenters of (cofolded) facets of dimension 0.}
{to use Closure in this command, need to add a few lines as in
facetiousEQUIV.at}
set facet_statusu(RealForm G, FacetData(vd,FPPstInd)) = FacetData:
(  let FBs = [[FacetBary]]:
      for Findd in FPPstInd
      do for Find in Findd do facet_bary(vd.list, Find.verts) od
      od
   then FPPstIndQuo = FPPstInd
   , lookup0 = (ratvec->int): { lookup in list of facets of dimension 0 }
     index_in(for (,facet) in FPPstInd[0] do vd.list[facet[0]] od)
{   , (X,r) = simple_type(simple_factors(G)[0].derived) {this allows complex
     	  				    simple G} }
   , st = G.dual.Springer_table
   then FPPstInd0 = FPPstInd[0]
{   , FPPstInd1 = if #FPPstInd>0 then FPPstInd[1] else FPPstInd[0] fi}
in
   if not(is_split(G))
   then
      for O@j in st.orbits
      do let gamma = O.H/2
	 then m0 = lookup0(gamma)
      in if m0 >= 0 and
	    GK_dim(parameter(x_open(G),G.rho,gamma)) = dim(st.dual_map(O))/2
	 then FPPstInd0[m0] := ("Tunip"##to_string(j),FPPstInd0[m0].verts)
	 ;    FPPstIndQuo := updateSing{Closure}
	       (G, (vd,FPPstIndQuo), ("Tfrom"##to_string(j),
	       	   FPPstInd0[m0].verts))
	 fi
      od
   else
      for O@j in st.orbits
      do let gamma = O.H/2
	 then m0 = lookup0(gamma)
      in if m0 >= 0
	 then FPPstInd0[m0] := ("Tunip"##to_string(j),FPPstInd0[m0].verts)
	 ;    FPPstIndQuo := updateSing{Closure}
	       (G, (vd, FPPstIndQuo), ("Tfrom"##to_string(j),
	       	   FPPstInd0[m0].verts))
	 fi
      od
   fi
;  FPPstIndQuo[0] := FPPstInd0
;   (vd, FPPstIndQuo)
)

{ meant to record information about unitarity for all facets }
{now marks unipotent parameters as "T[number of dual nilpotent]"}
{Now that we are emphasizing cofolded G, I THINK that for a simple
G(R), all unipotent parameters must be 
barycenters of (cofolded) facets of dimension 0.}
{to use Closure in this command, need to add a few lines as in
facetiousEQUIV.at}
set facet_statusuK(RealForm G, FacetDataKchar (vd,FPPstInd, Pols)) = FacetData:
(  let FBs = [[FacetBary]]:
      for Findd in FPPstInd
      do for Find in Findd do facet_bary(vd.list, Find.verts) od
      od
   then lookups = for L in FPPstInd do index_in_facet_list(L) od
   , lookup0 = (ratvec->int): { lookup in list of facets of dimension 0 }
     index_in(for (,facet) in FPPstInd[0] do vd.list[facet[0]] od)
   then FPPstIndQuo = FPPstInd
   , st = G.dual.Springer_table
   then FPPstInd0 = FPPstInd[0]
{   , FPPstInd1 = if #FPPstInd>0 then FPPstInd[1] else FPPstInd[0] fi}
in
   if not(is_split(G))
   then
      for O@j in st.orbits
      do let gamma = O.H/2
	 then m0 = lookup0(gamma)
      in if m0 >= 0 and
	    GK_dim(parameter(x_open(G),G.rho,gamma)) = dim(st.dual_map(O))/2
	 then FPPstIndQuo := updateSingK(lookups, (vd,FPPstIndQuo,Pols)
	 , ("T"##"def"##to_string(j), FPPstInd0[m0].verts), Pols[0][m0])
	 ; FPPstInd0 := FPPstIndQuo[0]
	 ; FPPstInd0[m0] := ("T"##to_string(j),FPPstInd0[m0].verts)
	 ; FPPstIndQuo[0] := FPPstInd0
	 fi
      od
   else
      for O@j in st.orbits
      do let gamma = O.H/2
	 then m0 = lookup0(gamma)
      in if m0 >= 0
	 then FPPstIndQuo := updateSingK
	       (lookups, (vd, FPPstIndQuo, Pols), ("T"##"def"##to_string(j)
	       	, FPPstInd0[m0].verts), Pols[0][m0])
	 ; FPPstInd0 := FPPstIndQuo[0]
	 ; FPPstInd0[m0] := ("T"##to_string(j),FPPstInd0[m0].verts)
	 ; FPPstIndQuo[0] := FPPstInd0
	 fi
      od
   fi
;  FPPstIndQuo[0] := FPPstInd0
;   (vd, FPPstIndQuo)
)

{ meant to record information about unitarity for all facets }
{now marks unipotent parameters as "T[number of dual nilpotent]"}
{Now that we are emphasizing cofolded G, I THINK that for a simple G(R), all unipotent parameters must be
barycenters of (cofolded) facets of dimension 0.}
{to use Closure in this command, need to add a few lines as in
facetiousEQUIV.at}
set facet_statusuKPO(RealForm G, VertexData vd,
    [[FacetStatusVertsIndex]] FPPstInd, [vec] IUC, [vec] CLBF,
    [string] statuses) = [string]:
(   let () = if facet_verbose then prints("start facet_statusuKPO") fi
    then lookup0 = (ratvec->int): { lookup in list of facets of dimension 0 }
     index_in(for (,facet) in FPPstInd[0] do vd.list[facet[0]] od)
     , newStatuses = statuses
   then st = G.dual.Springer_table
   in if not(is_split(G))
      then for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup0(gamma)
      	      in if m0 >= 0 and
	      	 GK_dim(parameter(x_open(G),G.rho,gamma)) = dim(st.dual_map(O))/2
	 	 then newStatuses :=
		 { downdateUclassesB(newStatuses, gr }
		 downdateUclasses(newStatuses , IUC[CLBF[0][m0]]
		      , CLBF[0][m0], "unip"##to_string(j))
	 	 ; newStatuses[CLBF[0][m0]] := "Tunip"##to_string(j)
	 	 fi
      	   od
      else for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup0(gamma)
     	       in if m0 >= 0
	       	  then newStatuses :=
		  { downdateUclassesB(newStatuses, gr}
		  downdateUclasses(newStatuses, IUC[CLBF[0][m0]]
		       , CLBF[0][m0])
	 	  ; newStatuses[CLBF[0][m0]] := "Tunip"##to_string(j)
	 	  fi
            od
      fi
      ; newStatuses
)

{ meant to record information about unitarity for all facets }
{now marks unipotent parameters as "T[number of dual nilpotent]"}
{Now that we are emphasizing cofolded G, I THINK that for a simple
G(R), all unipotent parameters must be barycenters of (cofolded)
facets of dimension 0.}
{ERROR: jth element of LF[0] is NEED NOT be jth vertex in list. Need
to find a 0-facet whose first coord is j. Caller should define
different vd!}

set local_facet_statusU(KGBElt x, ratvec lambda,
    VertexData (list,lookup0), [vec] IUC, [vec] CLBF,
    [string] statuses) = [string]:

(   let () = if facet_verbose
    	     then prints("start local_facet_statusU")
	     fi
    then newStatuses = statuses, G = x.real_form
    then st = G.dual.Springer_table
    in if not(is_split(G) and (x=x_open(G)) and (lambda = G.rho))
      then for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup0(gamma)
      	      in if m0 >= 0 and
	      	    GK_dim(parameter(x,lambda,gamma)) =
		    dim(st.dual_map(O))/2
	 	 then newStatuses :=
		 downdateUclasses(newStatuses , IUC[CLBF[0][m0]]
		      , CLBF[0][m0], "unip"##to_string(j))
	 	 ; newStatuses[CLBF[0][m0]] := "Tunip"##to_string(j)
	 	 fi
      	   od
      else for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup0(gamma)
     	       in if m0 >= 0
	       	  then newStatuses :=
		  downdateUclasses(newStatuses, IUC[CLBF[0][m0]]
		       , CLBF[0][m0],"unip"##to_string(j))
	 	  ; newStatuses[CLBF[0][m0]] := "Tunip"##to_string(j)
	 	  fi
            od
      fi
      ; newStatuses
)

{returns the collection of unipotent points in list, as coords in list}
set local_unipotent_classes(KGBElt x, ratvec lambda, VertexData (list,lookup)) = vec:
(   let () = if facet_verbose
    	     then prints("start local_unipotent_classes")
	     fi
    then G = x.real_form
    then st = G.dual.Springer_table
    in if not(is_split(G) and (x=x_open(G)) and (lambda = G.rho))
       then for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
      	      in if m0 >= 0 and
	      	 GK_dim(parameter(x,lambda,gamma)) = dim(st.dual_map(O))/2
		 then [m0]
		 else []
		 fi
	   od.##
	else for O@j in st.orbits
      	   do let gamma = O.H/2
	      then m0 = lookup(gamma)
     	       in if m0 >= 0
	       	  then [m0]
		  else []
		  fi
	   od.##
	fi
)

{REARRAGEMENT of vd.lookup to find entry of FPPstInd[0] with vertex j is done by facet_statusuKPO}
set facet_statusuKPO_old(RealForm G,
    FacetDataKcharPO_old (vd,FPPstInd , , , ,IUC, CLBF, statuses) ) = [string]:
    { let vlistZero = for FSV in FPPstInd[0]
    		    do (vd.list)[(FSV.verts)[0]]
		    od
    {this is list of vertices appearing as 0-diml facets: smaller
     and differently ordered from vd.list}
    then vdZero = to_vertex_data(vlistZero)}
    facet_statusuKPO(G,vd,FPPstInd,IUC,CLBF,statuses)

{REARRAGEMENT of vd.lookup to find entry of FPPstInd[0] with vertex j is done by facet_statusuKPO}
set facet_statusuKPO(RealForm G, FacetDataKcharPO (vd,FPPstInd, , ,
    IUC, CLBF, statuses)) = [string]:
    {let vlistZero = for FSV in FPPstInd[0]
    		    do (vd.list)[(FSV.verts)[0]]
		    od
    {this is list of vertices appearing as 0-diml facets: smaller
     and differently ordered from vd.list}
    then vdZero = to_vertex_data(vlistZero)
    in }facet_statusuKPO(G,vd,FPPstInd,IUC,CLBF,statuses)

set facet_status([[vec]] FPPind) = [[string]]:
    for d:#FPPind do for j:#FPPind[d] do "?" od od

{vlist is a collection of possible infinitesimal characters for reps
(x,lambda,?), typically vertices from FPP. If vlist[i] shows up as
a vertex of a unitary facet, then there is another vertex vlist[j] so that

theta(vlist[i]) = -vlist[j] + (1+theta)lambda

The sequence [int] records the permutation i |--> j. The actual
vertices of the unitary facet are (vlist[i] + vlist[j])/2.

So this can be used to compute the actual facets of unitary
parameters, which are indeed simplices.  In the non-equal rank case,
one should apply this function to cofolded vertices, to be sure that
everything in sight is hermitian.}
set thetaAct (KGBElt x, ratvec lambda, VertexData vd) = vec:
    let theta = x.involution then thetaPlus = (1+theta)*lambda
    in for v in vd.list do vd.lookup(-theta*v + thetaPlus) od

{makes the FPP facets into facets of actual unitary parameters} {as
for thetaAct, need to in the unequal rank case to apply this to
cofolded vertices to get nice answers}

{makes the FPP facets into facets of actual unitary parameters} {as
for thetaAct, need in the unequal rank case to apply this to
cofolded vertices to get nice answers}
set actualize \
  ( KGBElt x, ratvec lambda
  , [ratvec] vlist, [[FacetStatusVertsIndex]] FPPstInd) = FacetData:
(   let vertex_data = vlist.to_vertex_data
    then Perm = thetaAct(x, lambda, vertex_data), n=#lambda
    then vlistActRep = [ratvec]: { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep)
    then lookup = index_in(vlistAct)
    then mapAct = [int]: {maps old vertex indices to actualized indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then lookup(v)
	     elif j > i then lookup((v+vlist[j])/2)
	     else            minus_1
	     fi
	 od
    then FSVIAct = [[FacetStatusVertsIndex]]:
        for @j in FPPstInd do [FacetStatusVertsIndex]: [] od
    then () = for FSVId@d in FPPstInd
    do if facet_verbose
        then prints("start dim ",d,
	       " in construction of actualized facet list")
	fi
	; for stFind in FSVId
	do  let v = stFind.verts
	    then vtheta = for i in v do if Perm[i] < 0 then break
	    	 	      	     	else Perm[i]
					fi od
	    then vAct = vec:
	       	    if is_subset(vtheta,v) {arguments were reversed before!}
		        then for i in v {NEED ALL mapAct[i] >= 0}
		    	     do if mapAct[i] >= 0 then [mapAct[i]] else [] fi
		    	     od.##.no_reps{sort} {this list may not have been sorted}
	            else []
		    fi
	     then () =  if #vAct > 0
	       	     	then  FSVIAct[#vAct - 1]:=
		      	(FSVIAct[#vAct -1] next FSVIAct[#vAct -1]:=[])
			 # (stFind.status, vAct)
	    	   	fi
	     in ()
	od
    od
    then dAct = last(for j:#FSVIAct do #FSVIAct[j] > 0 od)
    in (vlistAct.to_vertex_data, FSVIAct[:dAct+1])
)

set actualizeK \
  ( KGBElt x, ratvec lambda
  , [ratvec] vlist, [[FacetStatusVertsIndex]] FPPstInd) = FacetDataKchar:
(
    let () = if facet_verbose then prints("start actualizeK") fi
    then vertex_data = vlist.to_vertex_data
    then Perm = thetaAct(x, lambda, vertex_data), n=#lambda
    then vlistActRep = [ratvec]: { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep)
    then lookup = index_in(vlistAct)
    then mapAct = [int]: {maps old vertex indices to actualized indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then lookup(v)
	     elif j > i then lookup((v+vlist[j])/2)
	     else            minus_1
	     fi
	 od
    then FSVIAct = [[FacetStatusVertsIndex]]:
        for @j in FPPstInd do [FacetStatusVertsIndex]: [] od
    then () = for FSVId@d in FPPstInd
    do  if facet_verbose
	then prints("examining ", #FSVId, " facets of dim ",d,
	       " in construction of actualized facet list")
	fi
      ; for stFind in FSVId
	do  let v = stFind.verts
	    then vtheta = for i in v do if Perm[i] < 0 then break
	    	 	      	     	else Perm[i]
					fi od
	    then vAct = vec:
	       	    if is_subset(vtheta,v)  {arguments were reversed before!}
		        then for i in v  {Need ALL mapAct[i]>=0}
		    	     do if mapAct[i] >= 0 then [mapAct[i]] else [] fi
		    	     od.##.no_reps{sort} {this list may not have been sorted}
	            else []
		    fi
	     then () =  if #vAct > 0
	     	     	   {add functionality of "pick" here}
	     	  	then let FB = facet_bary(vlistAct, vAct)
			     then p = parameter(x,lambda, FB)
	       		     in  if {is_final(p) and} is_hermitian(p)
			      	    and p.infinitesimal_character = FB
				    then FSVIAct[#vAct - 1] :=
			   	     (FSVIAct[#vAct -1] next FSVIAct[#vAct -1]:=[])
			   	     		    # (stFind.status, vAct)
	    	      	     	 fi
		  	 fi
	      in ()
	od
    od
    then dAct = last(for j:#FSVIAct do #FSVIAct[j] > 0 od)
    then polsAct = for j:dAct+1 do
        if facet_verbose then prints("start computing Kchars in dim ",j)
    	fi
    ; for stFind in FSVIAct[j] 
    	 do K_type_pol(character_formula( finalize(parameter(
	    		x, lambda, facet_bary(vlistAct, stFind.verts)))))
  	 od
      od
    in (vlistAct.to_vertex_data, FSVIAct[:dAct+1], polsAct)
)

set polTestA((KGBElt x, ratvec lambda, [ratvec] vlistAct,
    [[FacetStatusVertsIndex]] FDAct, [[ratvec]] FB), int d) = [KTypePol]:
    for stFind in FDAct[d]
    do K_type_pol(character_formula( finalize(parameter(
	    		x, lambda, facet_bary(vlistAct, stFind.verts)))))
    od

set polTestB((KGBElt x, ratvec lambda, [ratvec] vlistAct,
    [[FacetStatusVertsIndex]] FDAct, [[ratvec]] FB), int d) = [KTypePol]:
    for v in FB[d]
    do K_type_pol(character_formula( finalize(parameter(
	    		x, lambda, v))))
    od


set actualizeKPO_old \
  ( KGBElt x, ratvec lambda
  , FacetData (vertex_data, FPPstInd)) = FacetDataKcharPO_old:
(   if facet_verbose
    then prints("start actualizeKPO_old")
    fi;
    let vlist = vertex_data.list
    then Perm = thetaAct(x, lambda, vertex_data), n=#lambda
    then vlistActRep = [ratvec]: { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep)
    then lookup = index_in(vlistAct)
    then mapAct = [int]: {maps old vertex indices to actualized indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then lookup(v)
	     elif j > i then lookup((v+vlist[j])/2)
	     else            minus_1
	     fi
	 od
    then FSVIAct = [[FacetStatusVertsIndex]]:
        for @j in FPPstInd do [FacetStatusVertsIndex]: [] od
    then () = for FSVId@d in FPPstInd
    do  if facet_verbose
        then prints("examining ", #FSVId, " facets of dim ",d,
	       " in construction of actualized facet list")
	fi
        ; for stFind in FSVId
	  do  let v = stFind.verts
	      then vtheta = for i in v do if Perm[i] < 0 then break
	    	 	      	     	else Perm[i]
					fi od
	      then vAct = vec:
	       	    if is_subset(vtheta,v)  {arguments were reversed before!}
		        then for i in v
		    	     do if mapAct[i] >= 0 then [mapAct[i]] else [] fi
		    	     od.##.no_reps{sort}{this list may not have been sorted}
	            else []
		    fi
	     then () =  if #vAct > 0
	     	     	   {add functionality of "pick" here}
	     	  	then let FB = facet_bary(vlistAct, vAct)
			     then p = parameter(x,lambda, FB)
		    	     in if {is_final(p) and} is_hermitian(p)
			   and p.infinitesimal_character = FB
		    	   then FSVIAct[#vAct - 1] :=
			   (FSVIAct[#vAct -1] next FSVIAct[#vAct -1]:=[])
			   # (stFind.status, vAct)
		    	fi
		  fi
	      in ()
	od
    od
    then dAct = last(for j:#FSVIAct do #FSVIAct[j] > 0 od)
    then polsAct = for j:dAct+1 do
    if facet_verbose then prints("start to compute ", #FSVIAct[j],
       " Kchars in dim ",j)
    fi
    ; for stFind in FSVIAct[j]
    	 do K_type_pol(character_formula( finalize(parameter(
	    		x, lambda, facet_bary(vlistAct, stFind.verts))))) od od
    then vdAct = vlistAct.to_vertex_data, FDAct = FSVIAct[:dAct+1]
    then FDK = (vdAct, FDAct, polsAct)
    next if facet_verbose then prints("start to compute facet graph") fi
    then (eq,gr) = GraphData: up_data(FDK)
    then classListByFacet = [vec]: class_lists(FDK,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
    then statuses = for C in eq do "?" od
    in (vdAct, FDAct, polsAct, eq, gr, IUCL, classListByFacet, statuses)
)

{SHOULD MAKE THREE FUNCTIONS:
 - construct the combinatorial data for relevant hermitian facets (ACTUALIZE)
 - compute KChar for each relevant facet (K_CHARS)
 - compute graph (GRAPH)}
 
{hash and polsNum not needed after graph computed, so don't return??}
set actualizeKPO \
  ( KGBElt x, ratvec lambda
  , FacetData (vertex_data, FPPstInd)) = FacetDataKcharPO:
(   if facet_verbose
    then prints("start actualizeKPO")
    fi;
    let vlist = vertex_data.list
    then Perm = thetaAct(x, lambda, vertex_data), n=#lambda
    then vlistActRep = [ratvec]: { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep)
    then lookup = index_in(vlistAct)
    then mapAct = [int]: {maps old vertex indices to actualized indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then lookup(v)
	     elif j > i then lookup((v+vlist[j])/2)
	     else            minus_1
	     fi
	 od
    then FSVIAct = [[FacetStatusVertsIndex]]:
        for @j in FPPstInd do [FacetStatusVertsIndex]: [] od
    then () = for FSVId@d in FPPstInd
    do  if facet_verbose
        then prints("examining ", #FSVId, " facets of dim ",d,
	       " in construction of actualized facet list")
	fi
        ; for stFind in FSVId
	  do  let v = stFind.verts
	      then vtheta = for i in v do if Perm[i] < 0 then break
	    	 	      	     	else Perm[i]
					fi od
	      then vAct = vec:
	       	    if vtheta.>= and is_subset(vtheta,v)  {arguments were reversed before!}
		    then let temp = for i in v do mapAct[i] od
		    {need ALL mapAct[i] >=0}
		         in if temp.>=
			    then temp.no_reps
			    else []
		    	    fi
		     else []
		     fi
	      then () =  if #vAct > 0
	     	     {add functionality of "pick" here}
	      	     	 then let FB = facet_bary(vlistAct, vAct)
	           	      then p = first_param(finalize(parameter(x,lambda, FB)))
		   	      in if {is_final(p) and} is_hermitian(p)
			      	 and p.infinitesimal_character = FB
		    	   	 then FSVIAct[#vAct - 1] :=
			   	      (FSVIAct[#vAct -1] next FSVIAct[#vAct -1]:=[])
			   	      # (stFind.status, vAct)
		    		 fi
		  	  fi
	      in ()
	od
    od
    then dAct = last(for j:#FSVIAct do #FSVIAct[j] > 0 od)
    then polsNum = [vec]:
    	 for j:dAct+1
	 do if facet_verbose then prints("start to compute ", #FSVIAct[j],
       	       " Kchars in dim ",j)
    	    fi
    	    ; for stFind in FSVIAct[j]
    	      do let Q = K_type_pol(character_formula(
	      	 finalize(parameter(x, lambda, facet_bary(vlistAct,
		 stFind.verts)))))
		 { then () = if Q=0*Q then prints("DANGER1: ",facet_bary(vlistAct,
		 stFind.verts)) fi }
		 in  Kpol_hash.match(Q)
	      {Kpol_hash.match(K_type_pol(character_formula(
	      	 finalize(parameter(x, lambda, facet_bary(vlistAct,
		 stFind.verts))))));}
	      od
	  od
    then vdAct = vlistAct.to_vertex_data, FDAct = FSVIAct[:dAct+1]
    then FDNum = (vdAct, FDAct, polsNum)
    next if facet_verbose then prints("start to compute facet graph") fi
    then (eq,gr) = GraphData: up_data(FDNum)
    then classListByFacet = [vec]: class_lists(FDNum,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
    then statuses = for C in eq do "?" od
    in (vdAct, FDAct, eq, gr, IUCL, classListByFacet, statuses)
)

{takes the general facet data FacetDataHash and builds one suited
 for (x,lambda)}
set localFD_hash \
  ( KGBElt x, ratvec lambda
  , FacetDataHash (vertex_data, FPPIndHash)) = LocalFacetDataHash:
(   if facet_verbose
    then prints("start localFD_hash")
    fi;
    let vlist = vertex_data.list, Glookup = vertex_data.lookup
    then Perm = thetaAct(x, lambda, vertex_data){, n=#lambda}
    then vlistActRep = [ratvec]:
    { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j.>= then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep) {SOURCE OF TROUBLE?}
{    then ()=prints("# vlistAct = ",#vlistAct)}
    then Lvd = vlistAct.to_vertex_data
    then lookup = Lvd.lookup
    then mapAct = vec:
    {maps FPP vertex indices to local indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then lookup(v)
	     elif j. >= then lookup((v+vlist[j])/2)
	     else            minus_1
	     fi
	 od
    {SERIOUS PROBLEM HERE... or perhaps not??}
    {this could produce lists with repetitions, which screws up the graph code}
    {example is G=U(4,2), x = x_open(G), lambda = G.rho... no it isn't!}
    then LFVI = [[LocalFacetVertsHash]]:
        for @j in FPPIndHash do [LocalFacetVertsHash]: [] od
    {then lists = for d:#FPPIndHash}
    then zup = hashUp.match(null(#lambda)), zdown = hashUp.match(null(#lambda))
    then () = LFVI[0] := for v@j in vlistAct
    	      	      	 do LocalFacetVertsHash:
			    let x = int: Glookup(v)
			    in if x.>= then [j, FPPIndHash[0][x][1], FPPIndHash[0][x][1]]
			      else [j,zup,zdown]
			      fi
			 od
    then () = for d:#FPPIndHash-1 from 1
    	      do if facet_verbose
              	 then prints("examining ", #FPPIndHash[d], " facets of dim ",d,
	       " in construction of local facet list")
	       	 fi
	  	 ; let FVInd  = FPPIndHash[d]
	  	   then () = for v@k in FVInd
	    	   	do  let vtheta = for ell in v[:d+1] do Perm[ell] od
	      	       	    then vAct = vec:
	       	       	    if vtheta.>= and
		       	    is_subset(vtheta,v[:d+1]) and
		       	    none(for i in v[:d+1] do mapAct[i] < 0 od)
		    	    then for i in v[:d+1]
		    	    	 do mapAct[i]
			 	 od.no_reps
	            	    else []
		    	    fi
	      	       	    then () = if #vAct > 1 {already have vertices}
	      	       	       	 then {let p = parameter(x,lambda, FB)}
			   	      let FB = facet_bary(vlistAct, vAct)
		   		      then p = parameter(x,lambda, FB)
		    		      in if {is_final(p) and is_hermitian(p)
			      and}    	    p.infinitesimal_character = FB
		    	      		 then let LF = LocalFacetVertsHash:
					      vAct##[v[d+1],v[d+2]]
					      in LFVI[#vAct - 1] :=
			   		      (LFVI[#vAct -1] next LFVI[#vAct -1]:=[])
			   		      # LF
			   		  fi
		     		   fi
	      	        in ()
		     od
		   in ()
    		 od
    { then () = prints("local facets counts are ",for j:#LFVI do #LFVI[j] od) }
    then dAct = last(for j:#LFVI do #LFVI[j] > 0 od)
    in(Lvd, x, lambda, LFVI[:dAct+1])
)

{creates the LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local
 verts, and 0-facets for (x,lambda)}
set localFD_KHash0 \
  ( KGBElt x, ratvec lambda, VertexData vd, int level, KTypePol_hash ktp_hash,
    			KTypePol_hash cert_hash) =
  (VertexData, vec, vec, [FacetVertsKHash]):
(   if facet_verbose
    then prints("start localFD_KHash0")
    fi;
    let vlist = vd.list
    then Perm = thetaAct(x, lambda, vd)
    then vlistActRep = [ratvec]:
    { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep) {SOURCE OF TROUBLE?}
    then Lvd = vlistAct.to_vertex_data
    then lookup = Lvd.lookup
    then mapAct = vec:
    {maps FPP vertex indices to local indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then lookup(v)
	     elif j >=0 then lookup((v+vlist[j])/2)
	     else            minus_1
	     fi
	 od
    then () = if facet_verbose
             	then prints("examining ", #vlistAct, " facets of dim ",0,
	       " in construction of local facet list0")
	     fi
    then FVK0 = [FacetVertsKHash]:
    	 for v@k in vlistAct
	 do let p = first_param(finalize(parameter(x,lambda,v)))
	    in if is_unitary_to_ht(p,level,cert_hash)
	       then let Q = K_type_pol({niceCF1}character_formula(p))
	       	    { then () = if Q=0*Q then prints(" DANGER2: ",v) fi }
		    in [[k,ktp_hash.match(Q)]]
	       {then [[k,ktp_hash.match(K_type_pol({niceCF1}character_formula(p)))]]}
	       else []
	       fi
	 od.##
	 {need to remove from mapAct vertices not appearing in FVK0}
    then lookup0 = index_in(for v in FVK0 do [v[0]] od)
    then () = for x@j in mapAct do if lookup0([x]) < 0 then mapAct[j] := -1 fi od
    in (Lvd, Perm, mapAct, FVK0)
)

{creates LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local
 verts, and 0-facets for (x,lambda)}
set localFD_KHash00 \
  ( KGBElt x, ratvec lambda, VertexData vd, KTypePol_hash ktp_hash) =
  (VertexData, vec, vec, [[FacetVertsKHash]]):
(   if facet_verbose
    then prints("start localFD_KHash00")
    fi;
    let vlist = vd.list
    then Perm = thetaAct(x, lambda, vd)
    then vlistActRep = [ratvec]:
    { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j >=0 then [(v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep)
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec:
    {maps FPP vertex indices to local indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then Llookup(v)
	     elif j >=0 then Llookup((v+vlist[j])/2)
	     else minus_1
	     fi
	 od
    then () = if facet_verbose
             	then prints("examining ", #vlistAct, " facets of dim ",0,
	       " in construction of local facet list0")
	     fi
    then FVK0 = [FacetVertsKHash]:
    	 for v@k in vlistAct
	 do let p = first_param(finalize(parameter(x,lambda,v)))
	    then Q = K_type_pol(character_formula(p))
	    { then () = if Q=0*Q then prints(" DANGER3: ",v) fi }
	    in {if is_unitary_to_ht(p,level,cert_hash)
	       then} {[k,ktp_hash.match(K_type_pol(character_formula(p)))]}
	       [k, ktp_hash.match(Q)]
	       {else []
	       fi}
	 od
	 {need to remove from mapAct vertices not appearing in FVK0}
	 {then lookup0 = index_in(for v in FVK0 do [v[0]] od)
    	 then () = for x@j in mapAct do if lookup0([x]) < 0 then mapAct[j] := -1 fi od}
    in (Lvd, Perm, mapAct, [FVK0])
)


{creates the LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local
 verts, and 0-facets for (x,lambda)
 Seek to use shift in KChar computation.}
{ set localFD_KHash00shift \
  ( KGBElt x, ratvec lambda, KTypePol_hash ktp_hash) =
  (VertexData, VertexData, vec, vec, [[FacetVertsKHash]]):
(   if facet_verbose
    then prints("start localFD_KHash00shift")
    fi;
    let shiftlist = [(vec,vec)]: []
    then vlist = [ratvec]:
    	 for gamma in fundamental_vertices(Affd)
    	 do let aff_short_list = FPP_w_shifts(Affd,gamma)
       	    then aff_list = [AffineCoWeylElt]:
            	 for (w,taus) in aff_short_list
            	 do for tau in taus do (tau,w) od
	         od.##
	    then for (tau,w) in aff_list
	     	 do let iw = inverse(w)
	     	    then bup = -tau + w*G.two_rho
		    then bdown = -w*bup
		    then () = shiftlist: = (shiftlist next shiftlist := [])#(bup,bdown)
	     	in ((tau,w)*gamma,bup,bdown)
	     	od.## {now have [ratvec] for aff_list(gamma)}
	 od.## {now have [ratvec] complete}
    let vd = vlist.to_vertex_data
    then Perm = thetaAct(x, lambda, vd)
    then vlistActRep = [ratvec]:
    { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep) 
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec:
    {maps FPP vertex indices to local indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then Llookup(v)
	     elif j >=0 then Llookup((v+vlist[j])/2)
	     else minus_1
	     fi
	 od
    then () = if facet_verbose
             	then prints("examining ", #vlistAct, " facets of dim ",0,
	       " in construction of local facet list0")
	     fi
    then FVK0 = [FacetVertsKHash]:
    	 for v@k in vlistAct
	 do let j = vd.lookup(v)
	    then shift = if j>=0 then shiftlist(j) else (null(G.rank), null(G.rank)) fi
	    then p = parameter(x,lambda,v)
	    in [k,ktp_hash.match(K_type_pol(translate character_formula(p)))]
	 od
	 {need to remove from mapAct vertices not appearing in FVK0}
	 {then lookup0 = index_in(for v in FVK0 do [v[0]] od)
    	 then () = for x@j in mapAct do if lookup0([x]) < 0 then mapAct[j] := -1 fi od}
    in (vd, Lvd, Perm, mapAct, [FVK0])
)
}
{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets. Need to be sure that input is based only
on FPP facets up to dim b-1, or repetitions can appear in output. Safety is
provided by the slower function without the argument b}
set localFD_KHashbt \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, int b, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints("start localFD_Khashbt")
    fi;
    {let Llookup = Lvd.lookup}
    let G = x.real_form
    then (Affd, M, j0) = cofolded(G)
    then LFKHnew = [[FacetVertsKHash]]: LFKH##(for dim:t-#LFKH from #LFKH do
    	 [FacetVertsKHash]: [] od)
    then () = for dim:t-b from b
    	      do let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	      	 then () = for FV@k in facets
       	      	      	   do if (facet_verbose and k=0) or fund_facet_verbose
       	       	       	      then prints("start fund facet ",k," of ", #facets,
	       	       	      	   " in dim ", dim,
		       		   " in localFD_Khashbt; ktp_hash.size() = ",
		       		   ktp_hash.size())
	       	 	      fi;
	       	 	      let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	       	 	      then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	      then aff_list = [AffineCoWeylElt]:
	       	    	      	   for (w,taus) in aff_short_list
	       	    		   do for tau in taus do (tau,w) od
	       	    		   od.##
	       	 	      in for wtilde in aff_list
	       	    	      	 do let (tau,w) = wtilde
				    then iw = inverse(w)
	     	     	       	    then bup = M*(-tau + w*Affd.two_rho)
				    then bdown = M*(iw*tau - Affd.two_rho)
		       		    {global is called v earlier}
		       		    then global = for v in wtilde*FV
		       	    	     	 	  do (vd.lookup)(M*v)
				     		  od.sort
		       		    {local is called vtheta earlier}
		       		    then local = for ell in global do Perm[ell] od
				    {if -1 appears in local, subset fails}
		       		    {actual is called vAct earlier}
		       		    then actual = vec:
				    	 if local.>= and is_subset(local,global) and 			       		    none(for i in global do mapAct[i] < 0 od)
			    		 then for i in global
			    	 	      do mapAct[i]
				 	      od.no_reps{sort}
			    		 else []
			    		 fi
		       		    then () = if #actual > 1 {already got vertices}
		       	       	      	      { then prints("facet candidate of dim ",#actual-1,
						       	      " is ",actual,"; s = ",s,", i = ",i); }
					      then let bary = M*(wtilde*bary_F)
					      	   then (xprime,lr,nuprime) = %first_param(finalize(
						   	 parameter(x,lambda, bary)))
						   then Q= K_type_pol(translate_param_by(
						   	character_formula(1*parameter(
							xprime,lr+G.rho+bup,nuprime+bup)),bdown))
					      	   {then Q = K_type_pol(translate_param_by(
						   character_formula(
						   1*parameter(x,lambda+bup,bary+bup)),bdown))}
						   { then () = if Q=0*Q then prints(" DANGER4: ",bary);
						   prints("(x,lambda,bary) = (",x,",",lambda,",",bary,")");
						   prints("bup = ",bup,", bdown = ",bdown)
						   	     fi}
						   then () = actual :=actual##[ktp_hash.match(Q)]
	     	       	    	      	   	   { then () = actual := actual##[ktp_hash.match(
				      		   K_type_pol(translate_param_by(character_formula(
						   1*parameter(x,lambda+bup,bary+bup)),bdown)))]}
						   in LFKHnew[#actual-2] :=
			    	 		   	(LFKHnew[#actual-2] next LFKHnew[#actual-2]:=[])
			   	 	      		# actual
					      fi
				     in ()
	     	     		   od
	      	            od
			    in ()
		od
    then dAct = last(for j:#LFKHnew do #LFKHnew[j] > 0 od)
    in LFKHnew[:dAct+1]
)

{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets. If input is _missing_ some facet dims up to b,
this can lead to running over the same FPP facets several times, and so to repetitions
in the output. hashes avoid that.}
set localFD_KHashbt \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints("start localFD_Khashbt")
    fi;
    {let Llookup = Lvd.lookup}
    let G = x.real_form, b = #LFKH
    then (Affd,M,j0) = cofolded(G)
    then LFKHnew = [[FacetVertsKHash]]: LFKH##(for dim:t-b from b do
    	 [FacetVertsKHash]: [] od)
    then hashes = for d:#LFKHnew do make_vec_hash(for v in LFKHnew[d] do v[:d+1] od, hash_code@(vec,int)) od
    {use the hashes to avoid repetitions in the facet lists}
    then () = for dim:t-b from b
    	      do let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	      	 then () = for FV@k in facets
       	      	      	   do if (facet_verbose and k=0) or fund_facet_verbose
       	       	       	      then prints("start fund facet ",k," of ", #facets,
	       	       	      	   " in dim ", dim,
		       		   " in localFD_Khashbt; ktp_hash.size() = ",
		       		   ktp_hash.size())
	       	 	      fi;
	       	 	      let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	       	 	      then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	      then aff_list = [AffineCoWeylElt]:
	       	    	      	   for (w,taus) in aff_short_list
	       	    		   do for tau in taus do (tau,w) od
	       	    		   od.##
	       	 	      in for wtilde in aff_list
	       	    	      	 do let (tau,w) = wtilde
				    then iw = inverse(w)
	     	     	       	    then bup = M*(-tau + w*Affd.two_rho)
				    then bdown = M*(iw*tau - Affd.two_rho)
		       		    {global is called v earlier}
		       		    then global = for v in wtilde*FV
		       	    	     	 	  do (vd.lookup)(M*v)
				     		  od.sort
		       		    {local is called vtheta earlier}
		       		    then local = for ell in global do Perm[ell] od
				    {if -1 appears in local, subset fails}
		       		    {actual is called vAct earlier}
		       		    then actual = vec:
				    	 if local.>= and is_subset(local,global) and 
			       		    none(for i in global do mapAct[i] < 0 od)
			    		 then for i in global
			    	 	      do mapAct[i]
				 	      od.no_reps{sort}
			    		 else []
			    		 fi
		       		    then () = if #actual > 1 {already got vertices}
		       	       	      	      then let s = hashes[#actual-1].size()
					      	   then i = hashes[#actual -1].match(actual)
						   { then () = prints("facet candidate of dim ",#actual-1,
						       	      " is ",actual,"; s = ",s,", i = ",i) }
						   then () = if i=s
						   	     then let bary = M*(wtilde*bary_F)
							     then (xprime,lr,nuprime) = %first_param(
							     	  finalize(parameter(x,lambda, bary)))
     							     then Q= K_type_pol(translate_param_by(
							     character_formula(1*parameter(
							     xprime,lr+G.rho+bup,nuprime+bup)),bdown))
							     {then Q = K_type_pol(translate_param_by(
								       character_formula(
						   		1*parameter(
								x,lambda+bup,bary+bup)),bdown))}
							     { then () = if Q=0*Q then prints(" DANGER5: "
							     	  ,bary) fi }
							     then ()=actual:= actual##[ktp_hash.match(Q)]
	     	       	    	      	   	   	     { then () = actual := actual##[ktp_hash.match(
				      		   K_type_pol(translate_param_by(character_formula(
						   1*parameter(x,lambda+bup,bary+bup)),bdown)))]}
							in LFKHnew[#actual-2] :=
			    	 		   	(LFKHnew[#actual-2] next LFKHnew[#actual-2]:=[])
			   	 	      		# actual
							      fi
						    in ()
			     	 	      fi
		       		   in ()
	     	     		od
	      	            od
			    in ()
		od
    then dAct = last(for j:#LFKHnew do #LFKHnew[j] > 0 od)
    in LFKHnew[:dAct+1]
)

{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).}
set localFD_KHashbt_lookDown \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, int b, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints("start localFD_Khashbt_lookDown")
    fi;
    let G = x.real_form
    then (Affd,M,j0) = cofolded(G)
    then LFKHnew = [[FacetVertsKHash]]: LFKH##(for dim:t-#LFKH from #LFKH do
    	 [FacetVertsKHash]: [] od)
    { then () = prints("in lookDown, #LFKHnew = ",#LFKHnew) }
    then () = for dim:t-b from b
    	      do let facets = [FacetVerts]: facets_fundamental(Affd,dim)
	      	 { then () = prints("dim = ",dim,", facets = ",facets) }
	      	 then lookups = lookups(LFKHnew)
    	      	 then () = for FV@k in facets
       	      	      	   do if (facet_verbose and k=0) or fund_facet_verbose
       	       	       	      then prints("start fund facet ",k," of ", #facets,
	       	       	      	   " in dim ", dim,
		       		   " in localFD_Khashbt; ktp_hash.size() = ",
		       		   ktp_hash.size())
	       	 	      fi;
	       	 	      let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	       	 	      then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	      then aff_list = [AffineCoWeylElt]:
	       	    	      	   for (w,taus) in aff_short_list
	       	    		   do for tau in taus do (tau,w) od
	       	    		   od.##
	       	 	      in for wtilde in aff_list
	       	    	      	 do let (tau,w) = wtilde
				    then iw = inverse(w)
	     	     	       	    then bup = M*(-tau + w*Affd.two_rho)
				    then bdown = M*(iw*tau - Affd.two_rho)
		       		    {global is called v earlier}
		       		    then global = for v in wtilde*FV
		       	    	     	 	  do (vd.lookup)(M*v)
				     		  od.sort
		       		    {local is called vtheta earlier}
		       		    then local = for ell in global do Perm[ell] od
				    {if -1 appears in local, subset fails}
		       		    {actual is called vAct earlier}
		       		    then actual = vec:
		       	    	    	 if local.>= and
					    is_subset(local,global) and
			       		    none(for i in global do mapAct[i] < 0 od)
			    		 then for i in global
			    	 	      do mapAct[i]
				 	      od.no_reps{sort}
			    		 else []
			    		 fi
				    { then () = prints("actual = ",actual) }
				    then d=#actual-1
				    then () = if d>0 {already got vertices}
				    	         and all(for e:d+1
						     do lookups[d-1](delete(actual,e)) >= 0 od)
						 {now we know that the subfacets are cand facets}
					      then let bary = M*(wtilde*bary_F)
					      	   then (xprime,lr,nuprime) =
						    %first_param(finalize(parameter(x,lambda, bary)))
					      	   then Q = K_type_pol(translate_param_by(
						   character_formula(
						   1*parameter(xprime,lr+G.rho+bup,nuprime+bup))
						   ,bdown))
						   { then () = if Q=0*Q then prints(" DANGER6: ",bary) fi }
	     	       	    	      	   	   then () = actual := actual##[ktp_hash.match(Q)]
						   { [ktp_hash.match(
				      		   K_type_pol(translate_param_by(character_formula(
						   1*parameter(x,lambda+bup,bary+bup)),bdown)))]}
						   { then () = prints("long actual = ",actual)
						   then () = prints("to insert in ",LFKHnew[#actual - 2]) }
						   in LFKHnew[#actual-2] :=
			    	 		     (LFKHnew[#actual-2] next LFKHnew[#actual-2]:=[])
			   	 	      	     # actual
						fi
				     in ()
	     	     		od
	      	            od
			    in ()
		od
    then dAct = last(for j:#LFKHnew do #LFKHnew[j] > 0 od)
    { then () = prints("LFKHnew = ",LFKHnew) }
    in LFKHnew[:dAct+1]
)

{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list}
set localFD_KHashbt_lookDown \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints("start localFD_Khashbt_lookDown")
    fi;
    let G = x.real_form, b = #LFKH
    then (Affd,M,j0) = cofolded(G)
    then LFKHnew = [[FacetVertsKHash]]: LFKH##(for dim:t-b from b do
    	 [FacetVertsKHash]: [] od)
    then hashes = for d:#LFKHnew do make_vec_hash(for v in LFKHnew[d] do v[:d+1] od, hash_code@(vec,int)) od
    {use the hashes to avoid repetitions in the facet lists}
    then () = for dim:t-b from b
    	      do let facets = [FacetVerts]: facets_fundamental(Affd,dim)
	      	 then lookups = lookups(LFKHnew)
    	      	 then () = for FV@k in facets
       	      	      	   do if (facet_verbose and k=0) or fund_facet_verbose
       	       	       	      then prints("start fund facet ",k," of ", #facets,
	       	       	      	   " in dim ", dim,
		       		   " in localFD_Khashbt; ktp_hash.size() = ",
		       		   ktp_hash.size())
	       	 	      fi;
	       	 	      let bary_F=FacetBary: sum(Affd.rank,FV)/(dim+1)
	       	 	      then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	      then aff_list = [AffineCoWeylElt]:
	       	    	      	   for (w,taus) in aff_short_list
	       	    		   do for tau in taus do (tau,w) od
	       	    		   od.##
	       	 	      in for wtilde in aff_list
	       	    	      	 do let (tau,w) = wtilde
				    then iw = inverse(w)
	     	     	       	    then bup = M*(-tau + w*Affd.two_rho)
				    then bdown = M*(iw*tau - Affd.two_rho)
		       		    {global is called v earlier}
		       		    then global = for v in wtilde*FV
		       	    	     	 	  do (vd.lookup)(M*v)
				     		  od.sort
		       		    {local is called vtheta earlier}
		       		    then local = for ell in global do Perm[ell] od
				    {if -1 appears in local, subset fails}
		       		    {actual is called vAct earlier}
		       		    then actual = vec:
		       	    	    	 if local.>= and
					    is_subset(local,global) and
			       		    none(for i in global do mapAct[i] < 0 od)
			    		 then for i in global
			    	 	      do mapAct[i]
				 	      od.no_reps{sort}
			    		 else []
			    		 fi
				    then d=#actual-1
		       		    then () = if d  > 0{already got vertices}
				    	         and all(for e:d+1
						     do lookups[d-1](delete(actual,e)) >= 0 od)
						 {now we know that the subfacets are cand facets}
					      then let s = hashes[#actual-1].size()
					      	   then i = hashes[#actual -1].match(actual)
						   { then () = prints("facet candidate of dim ",#actual-1,
						       	      " is ",actual,"; s = ",s,", i = ",i) }
						   then () = if i=s
						   	     then let bary = M*(wtilde*bary_F)
							     then (xprime,lr,nuprime) = %first_param(
							       finalize(parameter(x,lambda, bary)))
							     then Q= K_type_pol(translate_param_by(
							       character_formula(1*parameter(
							       xprime,lr+G.rho+bup,nuprime+bup)),bdown))
	     	       	    	      	   	   	     then ()=actual := actual##[ktp_hash.match(Q)]
				      		   {K_type_pol(translate_param_by(character_formula(
						   1*parameter(x,lambda+bup,bary+bup)),bdown)))]}
							in LFKHnew[#actual-2] :=
			    	 		   	(LFKHnew[#actual-2] next LFKHnew[#actual-2]:=[])
			   	 	      		# actual
							      fi
						    in ()
			     	 	      fi
		       		    in ()
	     	     		od
	      	            od
			    in ()
		od
    then dAct = last(for j:#LFKHnew do #LFKHnew[j] > 0 od)
    in LFKHnew[:dAct+1]
)

{takes list of 0- and d-diml facets, with d \ge 1, and builds all
d+1-diml facets having all faces in the d-diml list}
set superFacets([FacetVertsKHash] L0, [FacetVertsKHash] Ld) =
    [FacetVertsIndex]:
if #Ld = 0 then []
else
let d = #Ld[0] - 2 {-2 is needed if there is a KTypePol hash # appended}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
in [FacetVertsIndex]:
   for v in L0
   do let m0 = v[0] {first vertex in new facet}
      in [FacetVertsIndex]:
      	 for small in Ld
      	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    elif any(for k:d+1 do lookupsd( m0#(small[:k]##small[k+1:d+1])) = -1 od)
	    then [] {require all d-faces to be in Ld}
	    else [m0#small[:d+1]] {now m0##small is a candidate facet}
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
fi

{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary facets and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, int b, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints("start localFD_Khashbt_lookDown")
    fi;
    let G = x.real_form
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFacets(LFKH[0],LFKH[dim-1])
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	 then p = first_param(finalize(parameter(x,lambda, bary)))
		       		 then Q = K_type_pol(character_formula(p))
	     	       		 in actual##[ktp_hash.match(Q)]
		    	      	   od {[FacetVertsKHash]})
	 od
    in LFKH
)

{takes local data to height level, local dimension < d, and adds facets from d-dimensional
 FPP-facets. (In non-split/spherical cases, this might add nothing!)}
set localFD_KHash0 \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints("start localFD_Khash0 in dim ",#LFKH)
    fi;
    {let Llookup = Lvd.lookup}
    let dim = #LFKH, G = x.real_form
    then facets = [FacetVerts]: facets_fundamental(G,dim)
    then LFKHnew = [[FacetVertsKHash]]: LFKH#[]
    then () = for FV@k in facets
       	      do if (facet_verbose and k=0) or fund_facet_verbose
       	       	       then prints("start fund facet ",k," of ", #facets,
	       	       " in dim ", dim,
		       " in localFD_Khash; ktp_hash.size() = ",
		       ktp_hash.size())
	       	 fi;
	       	 let bary_F=FacetBary: sum(G.rank,FV)/(dim+1)
	       	 then aff_short_list = FPP_w_shifts(G,bary_F)
	       	 then aff_list = [AffineCoWeylElt]:
	       	    for (w,taus) in aff_short_list
	       	    do for tau in taus do (tau,w) od
	       	    od.##
	       	 in for wtilde in aff_list
	       	    do let (tau,w) = wtilde
		       {global is called v earlier}
		       then global = for v in wtilde*FV
		       	    	     do (vd.lookup)(v)
				     od.sort
		       {local is called vtheta earlier}
		       then local = for ell in global
		       	    	    do if Perm[ell] < 0
				       then break
				       else Perm[ell]
				       fi
				    od
		       {actual is called vAct earlier}
		       then actual = vec:
		       	    if is_subset(local,global)  {arguments were reversed before!}
			       and none(for i in global do mapAct[i] < 0 od) {mapAct.>=}
			    then for i in global
			    	 do mapAct[i]
				 od.no_reps{sort}
			    else []
			    fi
		       then () = if #actual > 1 {already got vertices}
		       	       	 then let bary = wtilde*bary_F
	     	       	    	      then () = actual := actual##[ktp_hash.match(
				      K_type_pol( character_formula(1*parameter(x,
				      		  lambda,bary))))]
		            	      in LFKHnew[#actual-2] :=
			    	 (LFKHnew[#actual-2] next LFKHnew[#actual-2]:=[])
			   	 	     # actual
			     	 fi
		       in ()
	     	     od
	      od
    then dAct = last(for j:#LFKHnew do #LFKHnew[j] > 0 od)
    in LFKHnew[:dAct+1]
)

{creates vd, LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local
 verts, and 0-facets for (x,lambda)}
set localFD_KHash000 \
  ( KGBElt x, ratvec lambda, KTypePol_hash ktp_hash) =
  (VertexData, VertexData, vec, vec, [[FacetVertsKHash]]):
(   if facet_verbose
    then prints("start localFD_KHash000")
    fi;
    let (Affd, M, j0) = cofolded(x.real_form)
    { then ups = [vec]: [], downs = [vec]: [] }
    then fvs = fundamental_vertices(Affd)
    then vlist = [ratvec]:
    	 for gamma@k in fvs
    	 do  if (facet_verbose and k=0) or fund_facet_verbose
       	       	       	      then prints("start fund vertex ",k," of ", #fvs,
		       		   " in localFD_KHash000")
	     fi;
	     let aff_short_list = FPP_w_shifts(Affd,gamma,j0)
	     then aff_list = [AffineCoWeylElt]:
	       for (w,taus) in aff_short_list
	       do for tau in taus do (tau,w) od
	       od.##
	  in for wtilde in aff_list
	     do {ups := ups#(-tau + w*Affd.two_rho)
	     then downs := downs#(inverse(w)*tau - Affd.two_rho)
	     in} M*(wtilde*gamma) od
       	  od.##
    then vd = vlist.to_vertex_data
    then Perm = thetaAct(x, lambda, vd)
    then vlistActRep = [ratvec]:
    { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [(v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep)
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec:
    {maps FPP vertex indices to local indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then Llookup(v)
	     elif j >=0 then Llookup((v+vlist[j])/2)
	     else minus_1
	     fi
	 od
    then () = if facet_verbose
             	then prints("examining ", #vlistAct, " facets of dim ",0,
	       " in construction of local facet list0")
	     fi
    then FVK0 = [FacetVertsKHash]:
    	 for v@k in vlistAct
	 do if k%(max(#vlistAct\10,2))=0 and fund_facet_verbose
	    then prints("examining facet ",k," of ",#vlistAct," in localFD_KHash000;",
	    "ktp_hash.size() = ",ktp_hash.size())
	    fi;
	    let p = Finalize(parameter(x,lambda,v))
	    then Q = K_type_pol(character_formula(p))
	    in [k, ktp_hash.match(Q)]
	 od
	 {need to remove from mapAct vertices not appearing in FVK0}
	 {then lookup0 = index_in(for v in FVK0 do [v[0]] od)
    	 then () = for x@j in mapAct do if lookup0([x]) < 0 then mapAct[j] := -1 fi od}
    in (vd, Lvd, Perm, mapAct, [FVK0])
)


{takes local vertices LFKH, and adds local 1-d facets; so output is size 2.}
set localFD_KHash1 \
  ( KGBElt x, ratvec lambda, VertexData vd, VertexData Lvd, vec Perm, vec mapAct,
    [[FacetVertsKHash]] LFKH, {int b, int t,} KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   assert(#LFKH = 1,"localFD_KHash1 takes only local VERTEX list");
    if facet_verbose
    then prints("start localFD_Khash1")
    fi;
    {let Llookup = Lvd.lookup}
    let G = x.real_form
    then (Affd, M, j0) = cofolded(G)
    then top = int: if any(for j:#Perm do Perm[j] > j od) then 3 else 1 fi
    then Edges = [vec]:
    	       for dim:top from 1
    	       do [vec]:
	       	  let facets = [FacetVerts]: facets_fundamental(Affd,dim)
    	 	  in for FV@k in facets
		     do [vec]:
		     	let bary_F =FacetBary: sum(Affd.rank,FV)/(dim+1)
			then aff_short_list = FPP_w_shifts(Affd,bary_F,j0)
	       	 	then aff_list = [AffineCoWeylElt]:
	       	    	     for (w,taus) in aff_short_list
	       	    	     do for tau in taus do (tau,w) od
	       	    	     od.##
	       	 	in for wtilde in aff_list
	       	    	   do let (tau,w) = wtilde
		       	      then global = vec:
				   for v in wtilde*FV
		       	    	   do (vd.lookup)(M*v)
				   od.sort {indices into FPP vertex list}
			      then local = for ell in global do Perm[ell] od
				     	  	  {indices into Lvd list}
			      then actual = vec:
				   if local.>= and
				      is_subset(local,global) and
				      none(for i in global do mapAct[i] < 0 od)
			    	   then for i in global
			    	 	   do mapAct[i]
				 	   od.no_reps{sort}
			    	   else []
			    	      fi
			       in if #actual = 2 then [actual] else [] fi
			    od.## {list of edges from FV}
			od.## {list of edges from dim FPP facets}
		 od.## {list of edges from dims 1-4}
    then  LFKH1 = [FacetVertsKHash]:
    	  for actual in Edges
    	  do let bary = facet_bary(Lvd.list,actual)
	     then p = first_param(finalize(parameter(x,lambda, bary)))
	     then Q= K_type_pol(character_formula(p))
	     in actual#ktp_hash.match(Q)
	  od
    in LFKH#LFKH1
)

{this takes the local facet data and computes K-chars. Used to be
done inside actualize}
set localKchars(LocalFacetDataHash(Lvd, x, lambda,LFverts)) = [vec]:
    let Kpol_hash_temp = make_KTypePol_hash(), G=x.real_form
    then pol_nums = [vec]:
    for LF@j in LFverts
    do if facet_verbose then prints("start to compute ",
       #LF," K-chars in dim ",j)
       fi;
       for v in LF
       do let mup = v~[1], mdown = v~[0]
       	  then bup = hashUp.index(mup), bdown = hashDown.index(mdown)
	  then (xprime,lr,nuprime) = %first_param(finalize(parameter(x,lambda,
	  facet_bary(Lvd.list, v[:j+1]))))
	  then Q= K_type_pol(translate_param_by(character_formula(1*parameter(
			xprime,lr+G.rho+bup,nuprime+bup)),bdown))
	  then()= if (Q-K_type_pol(character_formula(parameter(xprime,lr+G.rho,nuprime)))).!=
	       	  then prints("DANGER IN localKchars",facet_bary(Lvd.list, v[:j+1]))
	       	  fi
	  in Kpol_hash_temp.match(Q)
	  { K_type_pol(translate_param_by(
			    character_formula(1*parameter(x,
			    lambda+bup,facet_bary(Lvd.list, v[:j+1])+bup)),
  			    bdown)))}
       od
    od
    then () = if facet_verbose then prints("# facets = ",
    sum(for v in pol_nums do #v od), "; # distinct K_chars = ",
    Kpol_hash_temp.size())
	      fi
    in pol_nums
{SHOULD NOT RETURN Kpol_hash_temp!}

{this takes the local facet data and computes K-chars. Use the STORED Kpol_hash}
set localKcharsKeep(LocalFacetDataHash(Lvd, x, lambda,LFverts)) = [vec]:
    let G=x.real_form
    then pol_nums = [vec]:
    for LF@j in LFverts
    do if facet_verbose then prints("start to compute ",
       #LF," K-chars in dim ",j)
       fi;
       for v in LF
       do let mup = v~[1], mdown = v~[0]
       	  then bup = hashUp.index(mup), bdown = hashDown.index(mdown)
	  then (xprime,lr,nuprime) = %first_param(finalize(parameter(x,lambda,
	  facet_bary(Lvd.list, v[:j+1]))))
	  then Q= K_type_pol(translate_param_by(character_formula(1*parameter(
			xprime,lr+G.rho+bup,nuprime+bup)),bdown))
	  in Kpol_hash.match(Q)
	  {K_type_pol(translate_param_by(
			    character_formula(1*parameter(x,
			    lambda+bup,facet_bary(Lvd.list, v[:j+1])+bup)),
  			    bdown)))}
       od
    od
    then () = if facet_verbose then prints("# facets = ",
    sum(for v in pol_nums do #v od), "; # distinct K_chars = ",
    Kpol_hash.size())
	      fi
    in pol_nums

{computes directed graph of local facets. Output GraphData is
[[int]],[[int]] giving equivalence classes and the graph. Next output
[vec]s are IUCL and classListByFacet}
set localGraph(LocalFacetDataHash(Lvd,,,LFverts), [vec] pol_nums) =
    (GraphData, [vec],[vec]):
    let FDNum = (Lvd, LFverts, pol_nums)
    next if facet_verbose then prints("start to compute facet graph")
    	 fi
    then (eq,gr) = GraphData: up_data(FDNum)
    then classListByFacet = [vec]: class_lists(FDNum,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
	 in ((eq,gr), IUCL, classListByFacet)


set localGraph(LocalFacetDataHash(Lvd,,,LFverts), KTypePol_hash Kpol_hash,
    [vec] pol_nums, int level) =
    (GraphData, [vec],[vec]):
    let FDNum = (Lvd, LFverts, pol_nums)
    next if facet_verbose then prints("start to compute facet graph to level ",level)
    	 fi
    then (eq,gr) = GraphData: up_data(FDNum,Kpol_hash,level)
    then classListByFacet = [vec]: class_lists(FDNum,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
	 in ((eq,gr), IUCL, classListByFacet)

set localGraphK([[FacetVertsKHash]] LFvertsK) = (GraphData, [vec],[vec]):
    let () = if facet_verbose then prints("start to compute facet graph K")
    	     fi
    then (eq,gr) = GraphData: up_data(LFvertsK)
    then classListByFacet = [vec]: class_lists(LFvertsK,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) {[vec]:[[]]}
	 in ((eq,gr), IUCL, classListByFacet)

set localGraphK([[FacetVertsKHash]] FDKH, KTypePol_hash Kpol_hash, int level) =
    (GraphData, [vec],[vec]):
    let () = if facet_verbose then prints("start to compute facet graph K to level ",level)
    	     fi
    then (eq,gr) = GraphData: up_data(FDKH,Kpol_hash,level)
    then classListByFacet = [vec]: class_lists(FDKH,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr)
	 in ((eq,gr), IUCL, classListByFacet)

{Find the parameter with "smallest nu" in equivalence class m.}
{turns out to be nearly useless; better just to use first elt in each equiv class}
set shortest_param(KGBElt x, ratvec lambda, int m, [ratvec] vlistAct,
    			  [[FacetStatusVertsIndex]] FDAct, [vec] eq) = Param:
    let G=x.real_form, FDActLong = ##FDAct, C=eq[m]
    then best = facet_bary(vlistAct, FDActLong[C[0]].verts)
    then level = HT(G,best)
    then best0 = best
    then () = for c@j in C
      do let FB = facet_bary(vlistAct, FDActLong[c].verts)
	 in if HT(G,FB) < level then level:=HT(G,FB); best:=FB fi
      od
    then () = if facet_verbose=true then prints("Shrank HT in class ",m," from ",HT(G,best0)," to ",level)
              fi
    in first_param(finalize(parameter(x,lambda,best)))

set actualize_oldKPO \
  ( KGBElt x, ratvec lambda
  , FacetData (vertex_data, FPPstInd)) = FacetDataOldKcharPO:
(   if facet_verbose
    then prints("start actualize_oldKPO")
    fi;
    let vlist = vertex_data.list
    then Perm = thetaAct(x, lambda, vertex_data), n=#lambda
    then vlistActRep = [ratvec]: { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep)
    then lookup = index_in(vlistAct)
    then mapAct = [int]: {maps old vertex indices to actualized indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then lookup(v)
	     elif j > i then lookup((v+vlist[j])/2)
	     else            minus_1
	     fi
	 od
    then FSVIAct = [[FacetStatusVertsIndex]]:
        for @j in FPPstInd do [FacetStatusVertsIndex]: [] od
    then OldBary = [[ratvec]]:
    	 for @j in FPPstInd do [ratvec]: [] od
    then () = for FSVId@d in FPPstInd
    do  if facet_verbose
        then prints("examining ", #FSVId, " facets of dim ",d,
	       " in construction of actualized facet list")
	fi
        ; for stFind in FSVId
	  do  let v = stFind.verts
	      then FBold = facet_bary(vlist,v)
	      then vtheta = for i in v do if Perm[i] < 0 then break
	    	 	      	     	else Perm[i]
					fi od
	      then vAct = vec:
	       	    if is_subset(vtheta,v)  {arguments were reversed before!}
		        then for i in v
		    	     do if mapAct[i] >= 0 then [mapAct[i]] else [] fi
		    	     od.##.sort {this list may not have been sorted}
	            else []
		    fi
	     then () =  if #vAct > 0
	     	     	   {add functionality of "pick" here}
	     	  	then let FB = facet_bary(vlistAct, vAct)
			     then p = parameter(x,lambda, FB)
		    	     in if {is_final(p) and} is_hermitian(p)
			   and p.infinitesimal_character = FB
		    	   then FSVIAct[#vAct - 1] :=
			   (FSVIAct[#vAct -1] next FSVIAct[#vAct -1]:=[])
			   # (stFind.status, vAct)
			   ; OldBary[#vAct - 1] :=
			   (OldBary[#vAct - 1] next OldBary[#vAct - 1]:=[])
			   # FBold
		    	fi
		  fi
	      in ()
	od
    od
    then dAct = last(for j:#FSVIAct do #FSVIAct[j] > 0 od)
    then polsAct = for j:dAct+1 do
    if facet_verbose then prints("start to compute ", #FSVIAct[j],
       " Kchars in dim ",j)
    fi
    ; for stFind in FSVIAct[j]
    	 do K_type_pol(character_formula( finalize(parameter(
	    		x, lambda, facet_bary(vlistAct, stFind.verts))))) od od
    then vdAct = vlistAct.to_vertex_data, FDAct = FSVIAct[:dAct+1]
    then FDK = (vdAct, FDAct, polsAct)
    then (eq,gr) = GraphData: up_data(FDK)
    then classListByFacet = [vec]: {[[]]} class_lists(FDK,(eq,gr))
    	 , IUCL = full_down_classes(eq,gr) { [vec]:[[]]}
    then statuses = for C in eq do "?" od
    in (vdAct, FDAct, OldBary, polsAct, eq, gr, IUCL, classListByFacet, statuses)
)

{. include barycenters of actualized facets computed using old vertices;
useful for ind and reg .}
set actualize_oldK \
  ( KGBElt x, ratvec lambda
  , [ratvec] vlist, [[FacetStatusVertsIndex]] FPPstInd) =
  FacetDataOldKchar:
(   if facet_verbose
    then prints("start actualize_oldK")
    fi;
    let vertex_data = vlist.to_vertex_data
    then Perm = thetaAct(x, lambda, vertex_data), n=#lambda
    then vlistActRep = [ratvec]: { LIST CAN HAVE REPETITIONS IN U(3,3) }
	for v@i in vlist
	do  let j = Perm[i] in
	    if   j = i then [v]
	    elif j > i then [ (v + vlist[j])/2]
	    else []
	    fi
	od.##
    then vlistAct = no_reps(vlistActRep)
    then lookup = index_in(vlistAct)
    then mapAct = [int]: {maps old vertex indices to actualized indices}
        for v@i in vlist
	 do  let j = Perm[i] in
	     if   j = i then lookup(v)
	     elif j > i then lookup((v+vlist[j])/2)
	     else            minus_1
	     fi
	 od
    then FSVIAct = [[FacetStatusVertsIndex]]:
        for @j in FPPstInd do [FacetStatusVertsIndex]: [] od
    then OldBary = [[ratvec]]:
    	for @j in FPPstInd do [ratvec]: [] od
    then () = for FSVId@d in FPPstInd
    do  if facet_verbose
        then prints("examining ", #FSVId, " facets of dim ",d,
	       " in construction of actualized facet list")
	fi
        ; for stFind in FSVId
	do  let v = stFind.verts
	    then FBold = facet_bary(vlist, v)
	    then vtheta = for i in v do if Perm[i] < 0 then break
	    	 	      	     	else Perm[i]
					fi od
	    then vAct = vec:
	       	    if is_subset(v,vtheta)
		        then for i in v
		    	     do if mapAct[i] >= 0 then [mapAct[i]] else [] fi
		    	     od.##.sort {this list may not have been sorted}
	            else []
		    fi
	     then () =  if #vAct > 0
	     	     	   {add functionality of "pick" here}
	     	  	then {let FB = facet_bary(vlistAct, vAct)}
			     let p = parameter(x,lambda, FBold)
	       		     in  if {is_final(p) and} is_hermitian(p)
			      	    and p.infinitesimal_character = FBold
	       	      		 then let FSVId0 = FSVIAct[#vAct -1]
				 then  OldBaryd0 =OldBary[#vAct-1]
	    	             	 then () = FSVId0 ##:=
				      [(stFind.status, vAct)];
				      OldBaryd0 ##:= [FBold]
			     	 in FSVIAct[#vAct - 1]:=FSVId0;
				    OldBary[#vAct - 1]:=OldBaryd0
	    	      	     fi
		  	fi
	      in ()
	od
    od
    then dAct = last(for j:#FSVIAct do #FSVIAct[j] > 0 od)
    then polsAct = for j:dAct+1 do
        if facet_verbose then prints("start to compute ", #FSVIAct[j],
       " Kchars in dim ",j)
    fi
    ; for stFind in FSVIAct[j]
    	 do K_type_pol(character_formula( finalize(parameter(
	    		x, lambda, facet_bary(vlistAct, stFind.verts))))) od od
    in (vlistAct.to_vertex_data, FSVIAct[:dAct+1], OldBary[:dAct+1], polsAct)
)

set actualize(KGBElt x, ratvec lambda, FacetData FD) = FacetData:
    actualize(x, lambda, FD.v_data.list, FD.facet_status_inds)

set actualizeK(KGBElt x, ratvec lambda, FacetData FD) = FacetDataKchar:
    actualizeK(x, lambda, FD.v_data.list, FD.facet_status_inds)

set actualize_oldK(KGBElt x, ratvec lambda, FacetData FD) = FacetDataOldKchar:
    actualize_oldK(x, lambda, FD.v_data.list, FD.facet_status_inds)

{.included to provide the candidate unitary facet list and corr KTypePols.}
{ set facet_data_Kchar(RealForm G) = FacetDataKchar:
    actualizeK(x_open(G), G.rho, facet_data_fold(G))}

set show([[FacetStatusVertsIndex]] FPPstInd) = void:
    for FPPstIndd@d in FPPstInd
    do
    let (countTunip, countTtest, countTind, countTdef, countT,
    countFtest, countFdef, countFind, countF, countQ) =
	(0, 0, 0,0,0,0,0, 0, 0,0)
    in
	for stFind in FPPstIndd
	do
	if stFind.status="T"
	then countT+:=1
	elif stFind.status="F"
	then countF+:=1
	elif stFind.status="?"
	then countQ+:=1
	elif stFind.status[:2]="Tu"
	then countTunip+:=1
	elif stFind.status[:2]="Tt"
	then countTtest+:=1
	elif stFind.status[:2]="Ti"
	then countTind+:=1
	elif stFind.status[:2]="Tf"
	then countTdef+:=1
	elif stFind.status[:2]="Ft"
	then countFtest+:=1
	elif stFind.status[:2]="Ff"
	then countFdef+:=1
	elif stFind.status[:2]="Fi"
	then countFind+:=1
	fi
	od;
	prints("Facet dimension ",d,": ", countTunip, " equiv unip, ",countTind
	," equiv ind unit, ",countTdef, " deformed from unitary, "
	,countTtest, " tested unitary,  ", countT
	," other unit", new_line, "       ",countFind
	," equiv ind nonunit, ",countFdef
	," deformed from nonunitary, ",countFtest, " tested nonunitary, "
	, countF, " other nonunitary, "
	, countQ, " undecided.",new_line)
    od

set show(FacetData FD) = show(FD.facet_status_inds)

set show_short([string] statuses) = void:
    let countT = int:0, countF = int:0, countQ = int:0
    then () = for st in statuses do
    	if st[0]="T"
	then countT+:=1
	elif st[0]="F"
	then countF+:=1
	elif st[0]="?"
	then countQ+:=1
    	fi
	od
    in if countQ > 0
       then prints(#statuses," equiv classes of facets: ",countT,
	" unitary, ",countF," nonunitary, ",countQ,
	" still undetermined.")
       else prints(#statuses," equiv classes of facets: ",countT,
	" unitary, ",countF," nonunitary.")
	fi

set show_short([string] statuses, [Param] P) = show_short(statuses)

set show_very_short([string] statuses) = void:
    let countT = int:0, countF = int:0, countQ = int:0
    then () = for st in statuses do
    	if st[0]="T"
	then countT+:=1
	elif st[0]="F"
	then countF+:=1
	elif st[0]="?"
	then countQ+:=1
    	fi
	od
    in if countQ > 0
       then prints(countT,
	" unitary, ",countF," nonunitary, ",countQ,
	" still undetermined.")
	else prints(countT,
	" unitary, ",countF," nonunitary.")
	fi

{meant to display the collection of nonunitarity certificate K-types}
{KGBElt should be chosen to make K-highest weights look good; for example,
 KGB(G,(2^n) - 1) in Sp(2n,R).}
set show(KTypePol_hash cert_hash, KGBElt x) = void:
    let size = cert_hash.size()
    then muss = for j:size do monomials(cert_hash.index(j)) od
    in prints("Number of certificate K-types = ",sum(for mus in muss
       		      do #mus od));
       for j:size
       do prints(new_line, "certificates of height ",height(muss[j][0]));
       	  for mu in muss[j] do prints(j," dim = ",dimension(mu),
	  ",  hwt = ",highest_weights(mu,x)[0]) od
       od

set show(KTypePol_hash cert_hash) = void:
    if cert_hash.size() = 0
    then prints("Number of certificate K-types = 0")
    else show(cert_hash,KGB(cert_hash.index(0).real_form,0))
    fi

set look_up_vertices ([ratvec] vertices, [int] facet)=[ratvec]:
   for n in facet do vertices[n] od

set unitary_facets ([FacetStatusVertsIndex] FSVI)=[vec]:
   ##for (u,fac) in FSVI
   do if u[0]!="F" then [fac] else [] fi od

set remove_closure ([vec] short,[vec] long) =[vec]:
  ##for v in short
    do if any(for w in long do sorted_is_subset(v,w) od)
       then [] else [v]
       fi
    od

set remove_closure ([[vec]] all, int k) =[[vec]]:
   for level@i in all do if i<k
	       then remove_closure (level,all[k])
	       else level
	       fi od

{. The "interior" of the unitary dual set .}
set show_long ([ratvec] vertices,[[FacetStatusVertsIndex]] FSVIlist) = void:
   let n=#FSVIlist-1
   then ulist= for facets in FSVIlist
	       do unitary_facets(facets) od
   in for i:n do ulist:=remove_closure(ulist,n-i) od;
   for i:n+1
    do prints(new_line,"Unitary facets of dimension ",i,":",new_line);
	for fac in ulist[i]
	do  prints(look_up_vertices(vertices,fac))
	od
    od

{. Same, including also all boundary facets .}
set show_long_all ([ratvec] vertices,[[FacetStatusVertsIndex]] FSVIlist) = void:
   let n=#FSVIlist-1
   then ulist= for facets in FSVIlist
	       do unitary_facets(facets) od
   in for i:n+1
    do prints(new_line,"Unitary facets of dimension ",i,":",new_line);
	for fac in ulist[i]
	do  prints(look_up_vertices(vertices,fac))
	od
    od

set show_long (FacetData FD) = void:
   show_long(FD.v_data.list, FD.facet_status_inds)

set show_long_all (FacetData FD) = void:
   show_long(FD.v_data.list, FD.facet_status_inds)

{.picks the facets for hermitian, final parameters.}
{This eliminates a lot more than pick_not_cohom used to in the
nonquasisplit case, but maybe it's OK.

Tried to move the functionality of this into actualize.}

set pick(RealForm G, FacetData(D, FPPstInd)) =
    FacetData:
    let xopen = x_open(G), Grho = G.rho
    in
    ( D
    , for FPPstIndd in FPPstInd
      do
	  for FstInd in FPPstIndd
	  do
	  let FB = facet_bary(D.list, FstInd.verts)
	  then p = parameter(xopen, Grho, FB)
	  in if ({is_final(p) and } is_hermitian(p) and
	     (p.infinitesimal_character = FB)) then [FstInd] else [] fi
	  od.##
      od
    )

{. The next family of functions all need simple derived group. Always |D.list|
should be ALL vertices in the FPP. The facet lists carried by [[FacetBary]] or
[[FacetVertsIndex]] may be pruned of reps not interesting for unitarity, but the
indices will always refer to a constant vlist.}

set down_to_business(RealForm G, FacetData D) = FacetData:
    let (,FPPstIndFinalH) = pick(G, D)
    in
    if facet_verbose
    then prints("completing down_to_business"); show(FPPstIndFinalH)
    fi; facet_statusu(G, (D.v_data,FPPstIndFinalH))

{.Meant to be applied to output of down_to_business (with nonhermitian
  eliminated). Need simple derived group.}
set spherical(RealForm G, FacetData (vd,FPPstInd)) = FacetData:
    let xopen = x_open(G)
    , Grho = G.rho
    {, FBs = [[FacetBary]]:
	for FPPstIndd in [[FacetStatusVertsIndex]]: FPPstInd
	do for facet in FPPstIndd
	   do facet_bary(vd.list, facet.verts) od
	od}
    , lookups = [(vec->int)]: { lookup functions for equidimensional facets }
        for L in FPPstInd do index_in_facet_list(L) od
    , test_count = int:0
    then temp =
    for d:#FPPstInd
	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then temp = (); test_count := test_count+#TODOd; if facet_verbose
	then prints(); show(FPPstInd); prints("start dim ",d,
	     " in spherical(G,status,(vd,FPPind)); testing ",
	       #TODOd," parameters.")
	fi
	in
		for j@k in TODOd
		do{FACd}
		let Find = FPPstIndd[j]
		then result =
		    if facet_verbose
		     then if k <=5 or k% (1+#FPPstIndd\10) = 0
			  then prints("started test #",k," of ",#TODOd)
			  fi
		     fi;
		if{NEWU} (is_unitary(first_param(standardize(
			 parameter(xopen, Grho, facet_bary(vd.list,Find.verts))))))
		then FPPstInd:=updateSing(G, (vd, FPPstInd), ("T",
		     Find.verts));
		     FPPstIndd[j]:=("Ttest",Find.verts)
		else{NEWU}
		FPPstInd:=update(lookups, FPPstInd, ("F",Find.verts));
		FPPstIndd[j]:=("Ftest",Find.verts)
		fi
	in result
	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in if (test_verbose) then prints("total tests = ",test_count) fi;
    (vd,FPPstInd)

{.Meant to be applied to output of down_to_business (with nonhermitian
  eliminated). Need simple derived group.}
set sphericalK(RealForm G, FacetDataKchar (vd,FPPstInd,Pols)) = FacetData:
    let xopen = x_open(G)
    , Grho = G.rho
    , lookups = [(vec->int)]: { lookup functions for equidimensional facets }
        for L in FPPstInd do index_in_facet_list(L) od
    , test_count = int:0
    then temp =
    for d:#FPPstInd
	do{DIMd}
	let countd = int: 0
	then temp = ()
	; if facet_verbose
	then prints(); show(FPPstInd); prints("start dim ",d,
	     " in sphericalK(G,status,(vd,FPPind))")
	  fi
	in {would be nice to print j occasionally}
	for j: #FPPstInd[d]
	    do{FACd}
		let Find = FPPstInd[d][j]
		then () = if facet_verbose and d<=1 and j%(#FPPstInd[d]\5) = 0
		     then prints("examining facet #",j," of ",
		     	  #FPPstInd[d])
		     fi
		in   if Find.status[0]="?"
		     then countd := countd+1
		     ; if{NEWU} (is_unitary(first_param(standardize(
			 parameter(xopen, Grho, facet_bary(vd.list,
			 		  Find.verts))))))
		       then FPPstInd:=updateSingK(lookups, (vd, FPPstInd,Pols),
			  ("T", Find.verts), Pols[d][j])
		 	  ; let FPPstIndd = FPPstInd[d]
	 	 	  then () = FPPstIndd[j] := ("Ttest",Find.verts)
	 	 	  in FPPstInd[d] := FPPstIndd
		       else{NEWU} FPPstInd:=updateClosureK(lookups,
		     		(vd, FPPstInd, Pols), ("F",Find.verts))
			  ; let FPPstIndd = FPPstInd[d]
	 	 	  then () = FPPstIndd[j] := ("Ftest",Find.verts)
	 	 	  in FPPstInd[d] := FPPstIndd
		       fi
		     fi
	     od{FACd}
    	     ; if d < #FPPstInd-1 then FPPstInd:=
	       one_up(lookups[d], (vd,FPPstInd,Pols),d) fi
	     ; if(facet_verbose) then prints("did ",countd,
			  " tests in dimension ",d) fi
	     ; test_count:= test_count+countd
    	  od{DIMd}
    ; if(facet_verbose) then show(FPPstInd) fi
    in if(test_verbose) then prints("total tests = ",test_count) fi;
    (vd,FPPstInd)

set spherical_test(RealForm G, FacetData(vd,FPPstInd), (Param -> bool) tester) = FacetData:
    let xopen = x_open(G)
    , Grho = G.rho
    , FBs = [[FacetBary]]:
	 for FPPstIndd in FPPstInd
	 do for Find in FPPstIndd do facet_bary(vd.list, Find.verts) od
	 od
    , lookups = [(vec->int)]: { lookup functions for equidimensional facets }
        for L in FPPstInd do index_in_facet_list(L) od
    , test_count = int: 0
    then temp =
    for d:#FPPstInd
	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then TODOBd = for j in TODOd
		      do facet_bary(vd.list, FPPstIndd[j].verts) od,
		      GOALd = #TODOd; test_count:= test_count+#TODOd;
	if facet_verbose
	then prints(); show(FPPstInd); prints("start dim ",d,
	     " in spherical_test(G,vd.list,FPPstInd); testing ",
	       #TODOd," parameters.")
	fi
	in
		for j@k in TODOd
		do{FACd}
		let Find = FPPstIndd[j]
		then result =
		    if facet_verbose
		     then if k <=5 or k% (1+{GOALd}#TODOd\10) = 0
			  then prints("started test #",k," of ",{GOALd}#TODOd)
			  fi
		     fi;
		if{NEWU} tester(first_param(standardize(
			     	  parameter(xopen, Grho,
    				  TODOBd[k]))))
 		then FPPstInd:=updateSing(G, (vd, FPPstInd), ("T",
		     Find.verts));
		FPPstIndd[j]:=("Ttest", FPPstIndd[j].verts)
		else{NEWU}
		FPPstInd:=update(lookups, FPPstInd, ("F",Find.verts));
		FPPstIndd[j]:=("Ftest",Find.verts)
		fi
	in result
	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in if(test_verbose) then prints("total tests = ",test_count) fi;
    (vd,FPPstInd)

set spherical_testK(RealForm G, FacetDataKchar (vd,FPPstInd,Pols),
    (Param->bool) tester) = FacetData:
    let xopen = x_open(G)
    , Grho = G.rho
    , lookups = [(vec->int)]: { lookup functions for equidimensional facets }
        for L in FPPstInd do index_in_facet_list(L) od
    , test_count = int:0
    then temp =
    for d:#FPPstInd
	do{DIMd}
	let countd = int: 0
	{then TODOd = to_do(FPPstInd[d])}
	then temp = (); if facet_verbose
	then prints(); show(FPPstInd); prints("start dim ",d,
	     " in spherical_testK(G,status,(vd,FPPind,Pols),tester)")
	fi
	in
	for j {in TODOd}:#FPPstInd[d]
	    do{FACd}
		let Find = FPPstInd[d][j]
		then () = if facet_verbose and d<= 1 and j%(#FPPstInd[d]\5) = 0
		     	  then prints("examining facet #",j," of ",
		     	       #FPPstInd[d],"; ", #to_do(FPPstInd[d][j:]),
			       " still undecided.")
		     	  fi
		in   if Find.status[0]="?"
		     then countd := countd+1
		     ; if{NEWU} tester(first_param(standardize(
			 parameter(xopen, Grho, facet_bary(vd.list,
			 		  Find.verts)))))
		       then FPPstInd:=updateSingK(lookups, (vd, FPPstInd,Pols),
			  ("T", Find.verts), Pols[d][j])
		 	  ; let FPPstIndd = FPPstInd[d]
	 	 	  then () = FPPstIndd[j] := ("Ttest",Find.verts)
	 	 	  in FPPstInd[d] := FPPstIndd
		       else{NEWU} FPPstInd:=updateClosureK(lookups,
		     		(vd, FPPstInd, Pols), ("F",Find.verts))
			  ; let FPPstIndd = FPPstInd[d]
	 	 	  then () = FPPstIndd[j] := ("Ftest",Find.verts)
	 	 	  in FPPstInd[d] := FPPstIndd
		       fi
		     fi
	     od{FACd}
	     {; if(facet_verbose) then show(FPPstInd) fi}
    	     ; if d < #FPPstInd-1 then FPPstInd:=
	       one_up(lookups[d], (vd,FPPstInd,Pols),d) fi
	     ; if(facet_verbose) then prints("did ",countd,
			  " tests in dimension ",d) fi
	     ; test_count:= test_count+countd
    	  od{DIMd}
    ; if(facet_verbose) then show(FPPstInd) fi
    in if(test_verbose) then prints("total tests = ",test_count) fi;
    (vd,FPPstInd)

{ Output is a revision of the class status list statuses. }
{ try to compute and systematically use partial order on facets}
set spherical_testKPO(RealForm G, VertexData vd,
    [[FacetStatusVertsIndex]] FPPstInd,[vec] eq, [vec] gr,
    [vec] classListByFacet, [string] statuses,
    (Param->bool) tester) = [string]:
    let test_count = int:0, newStatuses = statuses, NumClasses = #eq
    	, printInterval = int: 1
    then () = if{FV} facet_verbose
    	      then prints(); prints("start spherical_testKPO with ",NumClasses
	      ," equivalence classes of facets")
	      ; show_short(newStatuses)
	      ; prints()
	      fi{FV}
	      ; for m:NumClasses
    	      ~do
	      if{FV} facet_verbose and ((NumClasses-m-1)%printInterval = 0)
	      then prints("examining equivalence class #",NumClasses-m -1,
	      	   "; so far ",test_count, " 'is_unitary' tests.")
	      ; show_very_short(newStatuses)
	      ; printInterval := 2*printInterval
	      fi{FV}
	      ; if{UNKNOWN} newStatuses[m] = "?"
	      	then test_count+:=1
		; let C=eq[m]
	      	  then (d,j) = coords(FPPstInd,C[0])
	      	  then verts = FPPstInd[d][j].verts
	      	  then p = first_param(finalize(parameter(x_open(G), G.rho
		    			, facet_bary(vd.list, verts))))
		   {shortest_param(x_open(G), G.rho, m, vd.list, FPPstInd, eq)}
	      	in if{NEWU} tester(p)
		   then newStatuses[m]:= "Ttest"##to_string(m)
		   {next line hits nothing}
		      {newStatuses:= downdateUclasses(newStatuses,IUCL[m],m)}
		      else newStatuses:=
		      	   { updateNUclasses(newStatuses, INUCL[m],m) }
			   updateNUclassesB(newStatuses, gr, m)
			   ; newStatuses[m] := "Ftest"##to_string(m)
		   fi
	         fi{UNKNOWN}
	      od
     then() = if(test_verbose)
     	      then prints(new_line,"total tests = ",test_count)
       	      fi
     in  newStatuses

{ Output is a revision of the class status list statuses. }
{ try to compute and systematically use partial order on facets}
set local_test(KGBElt x, ratvec lambda, VertexData Lvd,
    [[LocalFacetVertsHash]] LFVH, [[int]] eq, [[int]] gr,
    [vec] classListByFacet, [string] statuses,
    (Param->bool) tester, int test_count) = ([string],[Param]):
    let newStatuses = statuses, NumClasses = #eq
    	, printInterval = int: 1
    { then listZero = [ratvec]: if #LFVH = 0
    	 	    	      then []
    			      else for w in LFVH[0] do Lvd.list[w[0]] od
			      fi
    then vdZero = to_vertex_data(listZero) }
    then () = if facet_verbose
    	      then prints(); prints("start local_test with "
	      	   ,NumClasses," equivalence classes of facets")
	      ; show_short(newStatuses)
	      ; prints()
	      fi
	      ; for m:NumClasses
    	      ~do
	      if facet_verbose and
	      	 ((NumClasses-m-1)%printInterval = 0)
	      then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",test_count
	      ," 'is_unitary' tests.")
	      ; show_very_short(newStatuses)
	      ; printInterval := 2*printInterval
	      fi
	      ; if newStatuses[m] = "?"
	      	then test_count+:=1
		; let C=eq[m]
	      	  then (d,j) = coords(LFVH,C[0])
	      	  then verts = vec: LFVH[d][j][:d+1]
	      	  then p = first_param(finalize(parameter(x, lambda
		    	  , facet_bary(Lvd.list, verts))))
		  { then () = if(K_type_pol(character_formula(p)) - Kpol_hash.index(LFVH[d][j][d+1])).!=
		       then prints(p) fi}
	      	in if{NEWU} tester(p)
		   then newStatuses[m]:= "Ttest"##to_string(m)
		   else newStatuses:=
			   updateNUclassesB(newStatuses, gr, m)
		   ; newStatuses[m] := "Ftest"##to_string(m)
		   fi{NEWU}
	         fi
	      od
     then() = if(test_verbose)
     	      then prints(new_line,"total tests = ",test_count);
	      prints("number of tester-unitary facets = ",sum(for m:NumClasses
     	       		      	 	 	  	do if newStatuses[m][0]="T"
							   then [#eq[m]]
							   else []
							   fi
							od.##))
       	      fi
      then unitary_by_dim = vec: for d:#LFVH do 0 od
      then () = for C@m in eq
      	      	do if newStatuses[m][0] = "T"
      	      	   then for x in C
		   	do let (d,j) = coords(LFVH,x)
			   { then () = if d=0 then prints("unitary entry ",LFVH[d][j],
			   ", nu = ",facet_bary(Lvd.list, LFVH[d][j][:d+1])) fi }
			   in unitary_by_dim[d]+:=1
			od
		   fi
		 od
       then () = if test_verbose then prints("unitary facets by dim = ", unitary_by_dim) fi
       then UParams = [Param]:
       	    for m:NumClasses
	    do if statuses[m][0] = "T"
	       then for i in eq[m]
	       	    do let (d,j) = coords(LFVH,i)
		       in parameter(x,lambda,
		       	  facet_bary(Lvd.list,LFVH[d][j][:d+1]))
		    od {list of unitary Params}
	      else []
	      fi
	    od.##
      in  (newStatuses,UParams)

{meant to test candidate classes to (new) height |level|; delete from LFVH
 the facets established to be nonunitary in this way. Output is new shorter
 list of candidate facets, and the numbers of the corresponding KChars in }

set local_test_level(KGBElt x, ratvec lambda, VertexData Lvd,
    [[LocalFacetVertsHash]] LFVH, [[int]] pol_nums, [[int]] eq, [[int]] gr,
    [vec] classListByFacet, [string] statuses, int level,
    KTypePol_hash cert_hash, int test_count) =
    ([[LocalFacetVertsHash]],[[int]], int):
    let newStatuses = statuses, NumClasses = #eq
    	, printInterval = int: 1
    then tester = (Param->bool): (Param p) bool:
    	 is_unitary_to_ht(p, level, cert_hash)
    then () = if facet_verbose
    	      then prints(); prints("start local_test_level with "
	      	   ,NumClasses,
		   " equivalence classes of facets; now test to level ",level)
	      ; show_short(newStatuses)
	      ; prints()
	      fi
	      ; for m:NumClasses
    	      ~do
	      if facet_verbose and
	      	 ((NumClasses-m-1)%printInterval = 0)
	      then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",test_count
	      ," 'is_unitary' tests.")
	      ; show_very_short(newStatuses)
	      ; printInterval := 2*printInterval
	      fi
	      ; if newStatuses[m] = "?"
	      	then test_count+:=1
		; let C=eq[m]
		  {then ()=prints("C = ",C)}
	      	  then (d,j) = coords(LFVH,C[0])
	      	  then verts = vec: LFVH[d][j][:d+1]
		  {then () = prints("(d,j) = (",d,",",j,"), verts = ",verts,
		       	  " FB = ",facet_bary(Lvd.list,verts))}
	      	  then p = first_param(finalize(parameter(x, lambda
		    	  , facet_bary(Lvd.list, verts))))
	      	in if{NEWU} tester(p)
		   then newStatuses[m]:= "T"
		   else newStatuses:=
			   updateNUclassesB(newStatuses, gr, m)
		   ; newStatuses[m] := "F"
		   fi{NEWU}
	         fi
	      od
     then() = if(test_verbose)
     	      then prints(new_line,"total tests = ",test_count,
	      " to level ",level,"; about to create new facet list")
	      ;prints("so far ",cert_hash.size()," non-unitarity K-types")
	      ; show_very_short(newStatuses)
	      fi
     { then () = for m:NumClasses
     	       do if newStatuses[m][0]="T"
	       	  then let (d,j) = coords(LFVH,eq[m][0])
	     	       in prints("class ",m," is unitary to height ",level,", infl char ",
		       	  facet_bary(Lvd.list,LFVH[d][j][:d+1])) 
	     	  fi
	       od }
     { then () = prints("number of unitary facets = ",sum(for m:NumClasses
     	       		      	 	 	  	do if newStatuses[m][0]="T"
							   then [#eq[m]]
							   else []
							   fi
							od.##))}

     {make new local facet list using only facets not already proven nonunitary}
     {don't need hash numbers for shifts (last two coords)}
     then LFVHnew = for @m in LFVH do [LocalFacetVertsHash]: [] od
     then pol_numsnew = for @m in pol_nums do [int]: [] od
     then () = for C@m in eq do if newStatuses[m][0] = "T"
     	     	     	      	then for k in C
			      	   do let (d,j) = coords(LFVH,k)
				      in LFVHnew[d] :=
				      (LFVHnew[d] next LFVHnew[d]:=[])
				      #LFVH[d][j][:d+1];
				      pol_numsnew[d] :=
				      (pol_numsnew[d] next pol_numsnew[d]:=[])
				      #pol_nums[d][j]{ ;
				      prints("(d,j) = (",d,",",j,"), test = ",
				      tester(first_param(finalize(parameter(x,
				      lambda,facet_bary(Lvd.list,
				      LFVH[d][j][:d+1]))))))}
				   od{ ;
				 prints(new_line)}
			         fi
			      od
     {then () = prints(newStatuses)}
     then () = if test_verbose then prints("facet counts = ",for list in LFVHnew do #list od) fi
     in  (LFVHnew,pol_numsnew,test_count)

set local_testK_level(KGBElt x, ratvec lambda, VertexData vd,
    [[FacetVertsKHash]] FVKH, [[int]] eq, [[int]] gr,
    [vec] classListByFacet, [string] statuses, int level, 
    KTypePol_hash cert_hash, int test_count) =
    ([[FacetVertsKHash]], int):
    let newStatuses = statuses, NumClasses = #eq
    	, printInterval = int: 1
    then tester = (Param->bool): (Param p) bool:
    	 is_unitary_to_ht(p, level, cert_hash)
    then () = if facet_verbose
    	      then prints(); prints("start local_testK_level with "
	      	   ,NumClasses,
		   " equivalence classes of facets; now test to level ",level)
	      ; show_short(newStatuses)
	      ; prints()
	      fi
	      ; for m:NumClasses
    	      ~do
	      if facet_verbose and
	      	 ((NumClasses-m-1)%printInterval = 0)
	      then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",test_count
	      ," 'is_unitary' tests.")
	      ; show_very_short(newStatuses)
	      ; printInterval := 2*printInterval
	      fi
	      ; if newStatuses[m] = "?"
	      	then test_count+:=1
		; let C=eq[m]
		  {then ()=prints("C = ",C)}
	      	  then (d,j) = coords(FVKH,C[0])
	      	  then verts = vec: FVKH[d][j][:d+1]
		  {then () = prints("(d,j) = (",d,",",j,"), verts = ",verts,
		       	  " FB = ",facet_bary(Lvd.list,verts))}
	      	  then p = first_param(finalize(parameter(x, lambda
		    	  , facet_bary(vd.list, verts))))
	      	in if{NEWU} tester(p)
		   then newStatuses[m]:= "T"
		   else newStatuses:=
			   updateNUclassesB(newStatuses, gr, m)
		   ; newStatuses[m] := "F"
		   fi{NEWU}
	         fi
	      od
     then() = if(test_verbose)
     	      then prints(new_line,"total tests = ",test_count,
	      " to level ",level,"; about to create new facet list")
	      ;prints("so far ",cert_hash.size()," non-unitarity K-types")
	      ; show_very_short(newStatuses)
       	      fi
     {make new local facet list using only facets not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FacetVertsKHash]: [] od
          then () = for C@m in eq do if newStatuses[m][0] = "T"
     	     	     	      	then for k in C
			      	   do let (d,j) = coords(FVKH,k)
				      in FVKHnew[d] :=
				      (FVKHnew[d] next FVKHnew[d]:=[])
				      #FVKH[d][j]
				      {prints("(d,j) = (",d,",",j,"), test = ",
				      tester(first_param(finalize(parameter(x,
				      lambda,facet_bary(Lvd.list,
				      LFVH[d][j][:d+1]))))))}
				   od{ ;
				 prints(new_line)}
			         fi
			      od
     {then () = prints(newStatuses)}
     then () = if test_verbose then prints("facet counts = ",for list in FVKHnew do #list od) fi
     in  (FVKHnew,test_count)

{try to compute ahead on candidate unitary reps
 Last vecs in return are (new) unitaries and unitaries_to_hts}
set local_testK_level(KGBElt x, ratvec lambda, VertexData vd,
    [[FacetVertsKHash]] FVKH, [[int]] eq, [[int]] gr,
    [vec] classListByFacet, [string] statuses, vec next_heights, int step,
    [[vec]] unitaries, [[[vec]]] unitaries_to_hts,
    KTypePol_hash cert_hash, int test_count) =
    ([[FacetVertsKHash]], int, [[vec]], [[[vec]]]):
    let newStatuses = statuses, NumClasses = #eq
    	, printInterval = int: 1
    then tester = (Param->bool): (Param p) bool:
    	 is_unitary_to_ht(p, next_heights[step], cert_hash)
    then finds = for X@d in FVKH do index_in(for v in X do v[:d+1] od) od
    then () = if facet_verbose
    	      then prints(); prints("start local_testK_level with "
	      	   ,NumClasses,
		   " equivalence classes of facets; now test to level",
		     next_heights[step])
	      ; show_short(newStatuses)
	      ; prints()
	      fi
	      ; for m:NumClasses
    	      ~do
	      if facet_verbose and
	      	 ((NumClasses-m-1)%printInterval = 0)
	      then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",test_count
	      ," 'is_unitary' tests.")
	      ; show_very_short(newStatuses)
	      ; printInterval := 2*printInterval
	      fi
	      ; if newStatuses[m] = "?"
	      	then test_count+:=1
		; let C=eq[m]
		  {then ()=prints("C = ",C)}
	      	  then (d,j) = coords(FVKH,C[0])
	      	  then verts = vec: FVKH[d][j][:d+1]
		  {then () = prints("(d,j) = (",d,",",j,"), verts = ",verts,
		       	  " FB = ",facet_bary(Lvd.list,verts))}
	      	  then p = first_param(finalize(parameter(x, lambda
		    	  , facet_bary(vd.list, verts))))
	           in if{NEWU} tester(p)
		      then let () = newStatuses[m]:= "T"
		      	   then () = if d <#FVKH -1 or d=x.real_form.semisimple_rank
			   	{too few equivs on top-diml facets means too many partly unitary}
				{maybe 600 for SO(6,6)?}
		   	   	then let cert = is_unitary_cert(p)
		           	     in if #cert = 0 then unitaries[d]:= unitaries[d]#verts
				     {; prints(new_line,"new unitary rep p = ",p)}
			      	       	elif height(cert[0]) > next_heights[step+1]
					     then let h = step+1, ht = height(cert[0])
			      	   	{ then () = prints(new_line,"new partly unitary rep p = ",p)
				   	then () = prints("height of certificate = ",ht,
			     	   	     	    " h = ",h," next_heights[h] = ",next_heights[h])}
			     	   	in while h < #next_heights and next_heights[h] < ht
			     	      	   do let temph = unitaries_to_hts[h]
				       	      then () = temph[d] := temph[d]#verts
				       	      then () = unitaries_to_hts[h]:=temph
				       	      then () = h:=h+1
				       	      in ()
				      	   od
					fi
			      	  fi
			    in ()
		       else newStatuses:=
			   updateNUclassesB(newStatuses, gr, m)
		   	   ; newStatuses[m] := "F"
		       fi{NEWU}
	         fi
	      od
     then() = if(test_verbose)
     	      then prints(new_line,"total tests = ",test_count,
	      " to level ",next_heights[step],"; about to create new facet list")
	      ;prints("so far ",cert_hash.size()," non-unitarity K-types")
	      ; show_very_short(newStatuses)
       	      fi
     {make new local facet list using only facets not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FacetVertsKHash]: [] od
          then () = for C@m in eq do if newStatuses[m][0] = "T"
     	     	     	      	then for k in C
			      	   do let (d,j) = coords(FVKH,k)
				      in FVKHnew[d] :=
				      (FVKHnew[d] next FVKHnew[d]:=[])
				      #FVKH[d][j]
				      {prints("(d,j) = (",d,",",j,"), test = ",
				      tester(first_param(finalize(parameter(x,
				      lambda,facet_bary(Lvd.list,
				      LFVH[d][j][:d+1]))))))}
				   od{ ;
				 prints(new_line)}
			         fi
			      od
     {then () = prints(newStatuses)}
     then () = if test_verbose then prints("facet counts = ",for list in FVKHnew do #list od) fi
     in  (FVKHnew,test_count,unitaries, unitaries_to_hts)

{try to compute ahead on candidate unitary reps
 Last vecs in return are (new) unitaries and unitaries_to_ht}
set local_testK_level_D(KGBElt x, ratvec lambda, VertexData vd,
    [[FacetVertsKHash]] FVKH, [[int]] eq, [[int]] gr,
    [vec] classListByFacet, [string] statuses, vec next_heights, int step,
    [[vec]] unitaries, [[vec]] unitaries_to_ht,
    KTypePol_hash cert_hash, int test_count) =
    ([[FacetVertsKHash]], int, [[vec]], [[vec]]):
    let newStatuses = statuses, NumClasses = #eq
    	, printInterval = int: 1
    then tester = (Param->bool): (Param p) bool:
    	 is_unitary_to_ht(p, next_heights[step], cert_hash)
    then next_tester = (Param->bool): (Param p) bool:
    	 is_unitary_to_ht(p, next_heights[step+1], cert_hash)
    then finds = for X@d in FVKH do index_in(for v in X do v[:d+1] od) od
    then () = if facet_verbose
    	      then prints(); prints("start local_testK_level with "
	      	   ,NumClasses,
		   " equivalence classes of facets; now test to level",
		     next_heights[step])
	      ; show_short(newStatuses)
	      ; prints()
	      fi
	      ; for m:NumClasses
    	      ~do
	      if facet_verbose and
	      	 ((NumClasses-m-1)%printInterval = 0)
	      then prints("examining equivalence class #"
	      ,NumClasses-m -1, "; so far ",test_count
	      ," 'is_unitary' tests.")
	      ; show_very_short(newStatuses)
	      ; printInterval := 2*printInterval
	      fi
	      ; if newStatuses[m] = "?"
	      	then test_count+:=1
		; let C=eq[m]
		  {then ()=prints("C = ",C)}
	      	  then (d,j) = coords(FVKH,C[0])
	      	  then verts = vec: FVKH[d][j][:d+1]
		  {then () = prints("(d,j) = (",d,",",j,"), verts = ",verts,
		       	  " FB = ",facet_bary(Lvd.list,verts))}
	      	  then p = first_param(finalize(parameter(x, lambda
		    	  , facet_bary(vd.list, verts))))
	           in if{NEWU} tester(p)
		      then let () = newStatuses[m]:= "T"
		      	   then () = if next_tester(p)
			   	     then if is_unitary(p,cert_hash)
		      	   	      	  then unitaries[d]:=unitaries[d]#verts{;
					       prints("new unitary rep p = ",p)}
					  else unitaries_to_ht[d]:=
					       unitaries_to_ht[d]#verts{:
				     	       prints("new partly unitary rep p = ",p)}
					  fi
				      fi
			    in ()
		       else newStatuses:=
			   updateNUclassesB(newStatuses, gr, m)
		   	   ; newStatuses[m] := "F"
		       fi{NEWU}
	         fi
	      od
     then() = if(test_verbose)
     	      then prints(new_line,"total tests = ",test_count,
	      " to level ",next_heights[step],"; about to create new facet list")
	      ;prints("so far ",cert_hash.size()," non-unitarity K-types")
	      ; show_very_short(newStatuses)
       	      fi
     { then () = for m:NumClasses
     	      do if newStatuses[m][0]="T"
	       	  then let (d,j) = coords(FVKH,eq[m][0])
	     	       in prints("class ",m," is unitary, infl char ",
		       	  facet_bary(vd.list,FVKH[d][j][:d+1]))
	     	  fi
	       od
     then () = prints("number of unitary facets = ",sum(for m:NumClasses
     	       		      	 	 	  	do if newStatuses[m][0]="T"
							   then [#eq[m]]
							   else []
							   fi
							od.##)) }

     {make new local facet list using only facets not already proven nonunitary}
     then FVKHnew = for @m in FVKH do [FacetVertsKHash]: [] od
          then () = for C@m in eq do if newStatuses[m][0] = "T"
     	     	     	      	then for k in C
			      	   do let (d,j) = coords(FVKH,k)
				      in FVKHnew[d] :=
				      (FVKHnew[d] next FVKHnew[d]:=[])
				      #FVKH[d][j]
				      {prints("(d,j) = (",d,",",j,"), test = ",
				      tester(first_param(finalize(parameter(x,
				      lambda,facet_bary(Lvd.list,
				      LFVH[d][j][:d+1]))))))}
				   od{ ;
				 prints(new_line)}
			         fi
			      od
     {then () = prints(newStatuses)}
     then () = if test_verbose then prints("facet counts = ",for list in FVKHnew do #list od) fi
     in  (FVKHnew,test_count, unitaries, unitaries_to_ht)

set spherical_testKPO(RealForm G, FacetDataKcharPO_old (vd,FPPstInd,
    	, eq, gr, , CLBF, statuses)
    	, (Param->bool) tester) = [string]:
    spherical_testKPO(G,vd,FPPstInd,eq,gr,CLBF,statuses, tester)

set spherical_testKPO(RealForm G, FacetDataKcharPO (vd,FPPstInd
    	, eq, gr, , CLBF, statuses)
    	, (Param->bool) tester) = [string]:
    spherical_testKPO(G,vd,FPPstInd,eq,gr,CLBF,statuses, tester)

set default_tester(Param p) = is_unitary(p)


{this seems OK}
set spherical_old(RealForm G) = FacetData:
    let data = facet_data_fold(cofolded(G))
    then dataAct = actualize(x_open(G), G.rho, data)
    then dataIndncH = down_to_business(G,dataAct)
    in spherical_test(G, dataIndncH, default_tester@Param)

set spherical(RealForm G) = FacetData:
    let data = facet_data_fold(cofolded(G))
    then dataAct = actualize(x_open(G), G.rho, data)
    then dataIndncH = down_to_business(G,dataAct)
    in spherical_test(G, dataIndncH, default_tester@Param)

set spherical_open(RealForm G) = FacetData:
    let (vdata,topStatus) = facet_data_fold_open(G)
    then lowData = [[FacetStatusVertsIndex]]:
    	 for j:#topStatus[0].verts-1 do []  od
    then dataAct = actualize(x_open(G), G.rho,
    (vdata,[[FacetStatusVertsIndex]]: lowData##[topStatus]))
    then dataIndncH = down_to_business(G,dataAct)
    in spherical_test(G, dataIndncH, default_tester@Param)

set spherical_open_test(RealForm G, (Param -> bool) tester) = FacetData:
    let (vdata,topStatus) = facet_data_fold_open(G)
    then lowData = [[FacetStatusVertsIndex]]:
    	 for j:#topStatus[0].verts-1 do []  od
    then dataAct = actualize(x_open(G), G.rho,
    (vdata,[[FacetStatusVertsIndex]]: lowData##[topStatus]))
    then dataIndncH = down_to_business(G,dataAct)
    in spherical_test(G, dataIndncH, tester)

set sphericalK_old(RealForm G) = FacetData:
    let data = facet_data_fold(cofolded(G))
    then (vdata, dataAct, Pols) = actualizeK(x_open(G), G.rho, data)
    then (vdata, datau) = facet_statusuK(G, (vdata, dataAct,Pols))
    in spherical_testK(G, (vdata, datau, Pols), default_tester@Param)

set sphericalK(RealForm G) = FacetData:
    let data = facet_data_fold(cofolded(G))
    then (vdata, dataAct, Pols) = actualizeK(x_open(G), G.rho, data)
    then (vdata, datau) = facet_statusuK(G, (vdata, dataAct,Pols))
    in spherical_testK(G, (vdata, datau, Pols), default_tester@Param)

{. apply actualize to the FacetData before computing unitarity; should mean
   that output is already actualized .}
set spherical_test_old(RealForm G, (Param -> bool) tester) = FacetData:
    { let (rd,M,j0) = cofolded(G) }
    let dataFold = facet_data_fold(cofolded(G)) { (rd,M,j0) }
    then dataAct = actualize(x_open(G), G.rho, dataFold)
    then dataIndnch = down_to_business(G,dataAct)
    in spherical_test(G, dataIndnch, tester)

set spherical_test(RealForm G, (Param -> bool) tester) = FacetData:
    { let (rd,M,j0) = cofolded(G) }
    let dataFold = facet_data_fold(cofolded(G)) { (rd,M,j0) }
    then dataAct = actualize(x_open(G), G.rho, dataFold)
    then dataIndnch = down_to_business(G,dataAct)
    in spherical_test(G, dataIndnch, tester)

set spherical_testK_old(RealForm G, (Param -> bool) tester) = FacetData:
    { let (rd,M,j0) = cofolded(G) }
    let dataFold = facet_data_fold(cofolded(G)) { (rd,M,j0) }
    then (vdata, dataAct, Pols) = actualizeK(x_open(G), G.rho, dataFold)
    then (vdata, datau) = facet_statusuK(G, (vdata, dataAct,Pols))
    in spherical_testK(G,(vdata,datau, Pols), tester)

set spherical_testK(RealForm G, (Param -> bool) tester) = FacetData:
    { let (rd,M,j0) = cofolded(G) }
    let dataFold = facet_data_fold(cofolded(G)) { (rd,M,j0) }
    then (vdata, dataAct, Pols) = actualizeK(x_open(G), G.rho, dataFold)
    then (vdata, datau) = facet_statusuK(G, (vdata, dataAct,Pols))
    in spherical_testK(G,(vdata,datau, Pols), tester)

 {for now just return the class statuses}
set spherical_testKPO_old(RealForm G, (Param -> bool) tester) = [string]:
    { let (rd,M,j0) = cofolded(G) }
    let dataFold = facet_data_fold(cofolded(G)) { (rd,M,j0) }
    then FDKPO = actualizeKPO_old(x_open(G), G.rho, dataFold)
    then () = FDKPO.class_status := facet_statusuKPO_old(G,FDKPO)
    in spherical_testKPO(G,FDKPO, tester)

set spherical_testKPO(RealForm G, (Param -> bool) tester) = [string]:
    let dataFold = facet_data_fold(cofolded(G)) { (rd,M,j0) }
    then FDKPO = actualizeKPO(x_open(G), G.rho, dataFold)
    then () = FDKPO.class_status := facet_statusuKPO(G,FDKPO)
    in spherical_testKPO(G,FDKPO, tester)

set spherical_testKPO_long(RealForm G, (Param -> bool) tester) = FacetData:
    let dataFold = facet_data_fold(cofolded(G)) { (rd,M,j0) }
    then FDKPO = actualizeKPO(x_open(G), G.rho, dataFold)
    then () = FDKPO.class_status := facet_statusuKPO(G,FDKPO)
    then () = FDKPO.class_status :=
    	 spherical_testKPO(G, FDKPO, tester)
    in statuses_to_facets(G, FDKPO)

set spherical_testKPO_long(RealForm G, (Param -> bool) tester) = FacetData:
    let dataFold = facet_data_fold(cofolded(G)) { (rd,M,j0) }
    then FDKPO = actualizeKPO(x_open(G), G.rho, dataFold)
    then () = FDKPO.class_status := facet_statusuKPO(G,FDKPO)
    then () = FDKPO.class_status :=
    	 spherical_testKPO(G, FDKPO, tester)
    in statuses_to_facets(G, FDKPO)

{for now just return the class statuses}
set sphericalKPO_old(RealForm G) = [string]:
    spherical_testKPO_old(G,default_tester@Param)

set sphericalKPO(RealForm G) = [string]:
    spherical_testKPO(G,default_tester@Param)

{return like sphericalK}
set sphericalKPO_long(RealForm G) = FacetData:
    spherical_testKPO_long(G,default_tester@Param)

{outputs string with one status per equiv class}
set local_test(KGBElt x, ratvec lambda, (Param -> bool) tester) =
    ([string],[Param]):
    let G = x.real_form
    then  FPPDH = facet_data_fold_hash(cofolded(G))
    then LFD = if is_split(G) and x=x_open(G) and lambda=G.rho
    	       then (FPPDH.v_data, x, lambda, FPPDH.hash_facet_inds)
	       else localFD_hash(x,lambda,FPPDH)
	       fi
    then (Lvd,,,LFverts) = LFD
    then () = if test_verbose then prints("LFverts in local_test facet counts: ",
    	    for list in LFverts do #list od) fi
    then vlistZero = [ratvec]: if #LFverts > 0
    	 	     	       then for v0 in LFverts[0] do Lvd.list[v0[0]] od
		     	       else []
			       fi
    {this is list of vertices appearing as 0-diml facets: smaller
     and differently ordered from Lvd.list}
    then LvdZero = to_vertex_data(vlistZero)
    then pol_nums = localKchars(LFD)
    then ((eq,gr),IUCL,CLBF) = localGraph(LFD,pol_nums)
    then statuses = [string]: for j:#eq do "?" od
    then () = statuses:=local_facet_statusU(x, lambda, LvdZero,
    	      IUCL, CLBF, statuses)
    in local_test(x,lambda,Lvd,LFverts, eq, gr, CLBF, statuses,
       tester, 0)

set local_test_levels(KGBElt x, ratvec lambda, KTypePol_hash cert_hash, int depth) =
    ([string],[Param]):
    let G = x.real_form
    then FPPDH = facet_data_fold_hash(cofolded(G))
    then LFD = if is_split(G) and x=x_open(G) and lambda=G.rho
    	       then (FPPDH.v_data, x, lambda, FPPDH.hash_facet_inds)
	       else localFD_hash(x,lambda,FPPDH)
	       fi
    then (Lvd,,,LFverts) = LFD
    { then vlistZero = for v0 in LFverts[0] do Lvd.list[v0[0]] od
    {this is list of vertices appearing as 0-diml facets: smaller
     and differently ordered from Lvd.list}
    then LvdZero = to_vertex_data(vlistZero)}
    then unipotents = local_unipotent_classes(x,lambda,Lvd)
    then pol_nums = localKcharsKeep(LFD)
    then hts = next_heights(parameter(x,lambda,0*lambda),depth)
    then test_count = int:0
    then () = for level in hts[:depth -1]
    	      do let ((eq,gr),IUCL,CLBF) = localGraph(LFD,Kpol_hash,pol_nums,level)
	      	 {then ()=prints(let Verts = LFD.LFverts in for V in Verts do #V od)
		 then ()=for Vertsd@d in LFD.LFverts do prints("LFverts[",d,"] = ",
		      Vertsd) od
	      	 then ()=prints("pol_nums = ",pol_nums)
		 then ()=prints("eq = ",eq)
		 then ()=prints("gr = ",gr)}
    	      	 then statuses = [string]: for j:#eq do "?" od
		 then newStatuses = statuses
		 then find0 = index_in(if #LFverts = 0 then []
		      	      	       else for v in LFD.LFverts[0] do v[:1] od
				       fi)
		 then () = for m in unipotents
		      	   do let k = find0([m])
		      	      in if k>=0
			      	 then newStatuses:=downdateUclasses(newStatuses,
			    	 IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
			    	 fi
			   od
    	    	 then (LFvertsnew, pol_numsnew, test_countnew) =
		      local_test_level(x,lambda,Lvd,LFD.LFverts,
	    	      pol_nums, eq, gr, CLBF, newStatuses, level,
		      cert_hash, test_count)
     	    	 then ()= LFD:=(Lvd,x,lambda,LFvertsnew)
	    	 then ()= pol_nums:=pol_numsnew
		 then ()= test_count:=test_countnew
	    	 in ()
              od
     then ((eq,gr),IUCL,CLBF) = localGraph(LFD,pol_nums)
     then statuses = [string]: for j:#eq do "?" od
     then newStatuses = statuses
     then find0 = index_in(if #LFverts = 0 then []
		      	      	       else for v in LFD.LFverts[0] do v[:1] od
				       fi)
     then () = for m in unipotents
	       do let k = find0([m])
		  in if k>=0
		     then newStatuses:=downdateUclasses(newStatuses,
			  IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
		     fi
	       od
     then tester = (Param->bool): (Param p) bool: is_unitary_test(p, hts~[0], cert_hash)
     in local_test(x,lambda,Lvd, LFD.LFverts,eq,gr,CLBF,newStatuses,tester,test_count)

{depth needs to be at least 1}
set local_testK_levels(KGBElt x, ratvec lambda, KTypePol_hash cert_hash,
    int depth) = ([string],[Param]):
    let G = x.real_form
    then (Affd,,) = cofolded(G)
    then vd = FPP_vertex_data(G)
    then hts = next_heights(parameter(x,lambda,0*lambda),depth)
    { make this use shifts!}
    then (Lvd, Perm, mapAct, LFDKH) = localFD_KHash00(x,lambda, vd, Kpol_hash)
    {next add dims from 1 to folded semisimple rank}
    then () = LFDKH := localFD_KHashbt(x,lambda,vd, Lvd, Perm, mapAct,
	      LFDKH,1,Affd.semisimple_rank+1, Kpol_hash)
    then ()  = if test_verbose then prints("in levels, facet counts to ",Affd.semisimple_rank," are ",
    	       for list in LFDKH do #list od) fi
    then unipotents = local_unipotent_classes(x,lambda,Lvd)
        then test_count = int:0
    then () = for level in hts[:depth -1]
    	      do let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,Kpol_hash,level)
	      	 { then () = prints("at level ",level," LFDKH is ",LFDKH) }
    	      	 then statuses = [string]: for j:#eq do "?" od
		 then find0 = index_in(if #LFDKH = 0 then []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
		 then () = for m in unipotents
		      	   do let k = find0([m])
		      	      in if k>=0
			      	 then statuses:=downdateUclasses(statuses,
			    	 IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
			    	 fi
			   od
    	    	 then (LFDKHnew, test_countnew) =
		      local_testK_level(x,lambda,Lvd,LFDKH,
	    	      eq, gr, CLBF, statuses, level,
		      cert_hash, test_count)
     	    	 then ()= LFDKH:=LFDKHnew
		 then ()= test_count:=test_countnew
	    	 in ()
              od
     then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
     then statuses = [string]: for j:#eq do "?" od
     then newStatuses = statuses
     then find0 = index_in(if #LFDKH = 0 then []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
     then () = for m in unipotents
	       do let k = find0([m])
		  in if k>=0
		     then newStatuses:=downdateUclasses(newStatuses,
			  IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
		     fi
	       od
     then tester = (Param->bool): (Param p) bool: is_unitary_test(p, hts~[0], cert_hash)
     in local_test(x,lambda,Lvd, LFDKH,eq,gr,CLBF,newStatuses,tester,test_count)

set local_testK_levels_A(KGBElt x, ratvec lambda, KTypePol_hash cert_hash, int depth) =
    ([string],[Param]):
    let G = x.real_form, first_pass = 2
    then (Affd,,) = cofolded(G)
    then vd = FPP_vertex_data(G)
    then hts = next_heights(parameter(x,lambda,0*lambda),depth)
    then (Lvd, Perm, mapAct, LFDKH) = localFD_KHash00(x,lambda, vd, Kpol_hash)
    {next add dim from 1 to first_pass-1}
    then () = LFDKH := localFD_KHashbt(x,lambda,vd, Lvd, Perm, mapAct,
	      LFDKH, 1, first_pass, Kpol_hash)
    then unipotents = local_unipotent_classes(x,lambda,Lvd)
    then test_count = int:0
    then () =  if test_verbose then prints("facets to dim ",first_pass-1, " counts:",
			  for list in LFDKH do #list od) fi

    {compute graph on facets to dim first_pass-1}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,Kpol_hash,hts[0])
    	      	 then statuses = [string]: for j:#eq do "?" od
		 then find0 = index_in(if #LFDKH = 0 then [vec]: []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
		 then () = for m in unipotents
		      	   do let k = find0([m])
		      	      in if k>=0
			      	 then statuses:=downdateUclasses(statuses,
			    	 IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
			    	 fi
			   od
		 then (LFDKHnew, test_countnew) =
		      local_testK_level(x,lambda,Lvd,LFDKH,
	    	      eq, gr, CLBF, statuses, hts[0],
		      cert_hash, test_count)
     	    	 then ()= LFDKH:=LFDKHnew
		 then ()= test_count:=test_countnew
    {now add the rest of the facets, using only those with unitary candidate boundaries}
    	     	 then () = LFDKH := localFD_KHashbt_lookDown(x,lambda,vd, Lvd, Perm, mapAct,
	      	      	   LFDKH, first_pass, Affd.semisimple_rank+1, Kpol_hash)
		 then () = if test_verbose then prints("ready to loop: all facet counts: ",
			  for list in LFDKH do #list od) fi

    then () = for level in hts[1:depth]
    	      do let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,Kpol_hash,level)
    	      	 then statuses = [string]: for j:#eq do "?" od
		 then find0 = index_in(if #LFDKH = 0 then [vec]: []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
		 then () = for m in unipotents
		      	   do let k = find0([m])
		      	      in if k>=0
			      	 then statuses:=downdateUclasses(statuses,
			    	 IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
			    	 fi
			   od
    	    	 then (LFDKHnew, test_countnew) =
		      local_testK_level(x,lambda,Lvd,LFDKH,
	    	      eq, gr, CLBF, statuses, level,
		      cert_hash, test_count)
     	    	 then ()= LFDKH:=LFDKHnew
		 then ()= test_count:=test_countnew
		 then () = if test_verbose then prints("facet counts after level ",level,": ",
			  for list in LFDKH do #list od) fi
	    	 in ()
              od
     then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
     then statuses = [string]: for j:#eq do "?" od
     then find0 = index_in(if #LFDKH = 0 then [vec]: []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
     then () = for m in unipotents
	       do let k = find0([m])
		  in if k>=0
		     then statuses:=downdateUclasses(statuses,
			  IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
		     fi
	       od
     then tester = (Param->bool): (Param p) bool: is_unitary_test(p, hts~[0], cert_hash)
     in local_test(x,lambda,Lvd, LFDKH,eq,gr,CLBF,statuses,tester,test_count)

set local_testK_levels_B(KGBElt x, ratvec lambda, KTypePol_hash cert_hash) =
    ([string],[Param]):
    let G = x.real_form, first_pass = 2
    then (Affd,,) = cofolded(G)
    then vd = FPP_vertex_data(G), depth=Affd.semisimple_rank - first_pass+1
    then hts = next_heights(parameter(x,lambda,0*lambda),depth)
    then (Lvd, Perm, mapAct, LFDKH) = localFD_KHash00(x,lambda, vd, Kpol_hash)
    {next add dim from 1 to first_pass}
    then () = LFDKH := localFD_KHashbt(x,lambda,vd, Lvd, Perm, mapAct,
	      LFDKH, 1, first_pass, Kpol_hash)
    then unipotents = local_unipotent_classes(x,lambda,Lvd)
    then test_count = int:0, D=int:1
    then () =  if test_verbose then prints("facets counts to dim ",first_pass-1, " :",
			  for list in LFDKH do #list od) fi
    then () = while first_pass + D <= Affd.semisimple_rank + 1
    {while loop does is_unitary_to_ht on facets to dim first_pass; then adds facets of
    	  one dim higher and does is_unitary_to_ht on those...}
    	      do let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,Kpol_hash,hts[D-1])
       	      	 {compute graph on facets to dim first_pass}
       		 then statuses = [string]: for j:#eq do "?" od
		 then find0 = index_in(if #LFDKH = 0 then [vec]: []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
       		 then () = for m in unipotents
		      	   do let k = find0([m])
		    	      in if k>=0
		       	      	 then statuses:=downdateUclasses(statuses,
			    	 IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
		       		 fi
		 	   od
		 then (LFDKHnew, test_countnew) = local_testK_level(x,lambda,Lvd,
		      LFDKH, eq, gr, CLBF, statuses, hts[D-1],
		      		       cert_hash, test_count)
 		then ()= test_count:=test_countnew
        	then () = LFDKH := localFD_KHashbt_lookDown(x,lambda,vd, Lvd, Perm, mapAct,
	      	      	   LFDKHnew, first_pass + D-1, first_pass + D, Kpol_hash)
	        then () = if test_verbose then prints("facet counts to dim ",first_pass+D-1,": ",
	     	     	  		for list in LFDKH do #list od) fi
   		then ()= D:=D+1
   		in ()
     	     od
    {now have facets of all dims, to height hts[?]}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then statuses = [string]: for j:#eq do "?" od
    then find0 = index_in(if #LFDKH = 0 then [vec]: []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
    then () = for m in unipotents
	       do let k = find0([m])
		  in if k>=0
		     then statuses:=downdateUclasses(statuses,
			  IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
		     fi
	       od
    then tester = (Param->bool): (Param p) bool: is_unitary(p, cert_hash)
    in local_test(x,lambda,Lvd,
    	      LFDKH,eq,gr,CLBF,statuses,tester,test_count)

set local_test_GEO(KGBElt x, ratvec lambda, KTypePol_hash cert_hash) =
    ([string],[Param]):
    let G = x.real_form, first_pass = 2
    then (Affd,,) = cofolded(G)
    then depth=Affd.semisimple_rank - first_pass+1
    then hts = next_heights(parameter(x,lambda,0*lambda),depth+2)
    then (vd, Lvd, Perm, mapAct, LFDKH) = localFD_KHash000(x,lambda, Kpol_hash)
    {next add edges}
    then () = LFDKH := localFD_KHash1(x,lambda,vd,Lvd,Perm,mapAct,LFDKH,Kpol_hash)
    {next add dim from 2 to first_pass}
    then () = LFDKH := localFD_KHashbt(x,lambda,vd, Lvd, Perm, mapAct,
	      LFDKH, 2, first_pass, Kpol_hash)
    then unipotents = local_unipotent_classes(x,lambda,Lvd)
    then test_count = int:0, D=int:1
    then () =  if test_verbose then prints("facets counts to dim ",first_pass-1, " :",
			  for list in LFDKH do #list od) fi
    then () = while first_pass + D <= Affd.semisimple_rank + 1 and
    	      	    (#LFDKH = first_pass + D - 1) and
		    (#(LFDKH~[0])  > 0)
    {while loop does is_unitary_to_ht on facets to dim first_pass; then adds facets of
    	  one dim higher and does is_unitary_to_ht on those...}
    	      do let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,Kpol_hash,hts[D-1])
       	      	 {compute graph on facets to dim first_pass}
       		 then statuses = [string]: for j:#eq do "?" od
		 then find0 = index_in(if #LFDKH = 0 then [vec]: []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
       		 then () = for m in unipotents
		      	   do let k = find0([m])
		    	      in if k>=0
		       	      	 then statuses:=downdateUclasses(statuses,
			    	 IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
		       		 fi
		 	   od
		 then (LFDKHnew, test_countnew) = local_testK_level(x,lambda,Lvd,
		      LFDKH, eq, gr, CLBF, statuses, hts[D-1],
		      		       cert_hash, test_count)
 		then ()= test_count:=test_countnew
        	then () = LFDKH := localFD_KHashbt_lookDownGEO(x,lambda,vd, Lvd, Perm, mapAct,
	      	      	   LFDKHnew, first_pass + D-1, first_pass + D, Kpol_hash)
	        then () = if test_verbose then prints("facet counts to dim ",first_pass+D-1,": ",
	     	     	  		for list in LFDKH do #list od) fi
   		then ()= D:=D+1
   		in ()
     	     od
    {now have facets of all dims, to height hts[?]}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then statuses = [string]: for j:#eq do "?" od
    then find0 = index_in(if #LFDKH = 0 then [vec]: []
		      	      	       else for v in LFDKH[0] do v[:1] od
				       fi)
    then () = for m in unipotents
	       do let k = find0([m])
		  in if k>=0
		     then statuses:=downdateUclasses(statuses,
			  IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
		     fi
	       od
    then tester = (Param->bool): (Param p) bool: is_unitary(p, cert_hash)
    in if(facet_verbose) then prints();
       prints("setting tester = is_unitary_test(p,[",hts[D-1],"...])") fi;
       local_test(x,lambda,Lvd,
    	      LFDKH,eq,gr,CLBF,statuses,tester,test_count)

set local_testK_levels_C(KGBElt x, ratvec lambda, KTypePol_hash cert_hash) =
    ([string],[Param]):
    let G = x.real_form, first_pass = 2
    then (Affd,,) = cofolded(G)
    then vd = FPP_vertex_data(G), depth=Affd.semisimple_rank - first_pass+1
    then hts = next_heights(parameter(x,lambda,0*lambda),depth+2)
    then (Lvd, Perm, mapAct, LFDKH) = localFD_KHash00(x,lambda, vd, Kpol_hash)
    {next add dim from 1 to first_pass}
    then () = LFDKH := localFD_KHashbt(x,lambda,vd, Lvd, Perm, mapAct,
	      LFDKH, 1, first_pass, Kpol_hash)
    then unitaries = [[vec]]: for d:Affd.semisimple_rank + 1 do [] od
    then unipotents = [vec]: for m in local_unipotent_classes(x,lambda,Lvd) do vec: [m] od
    then unitaries_to_hts = [[[vec]]]: for k:depth+2 do unitaries od
    then () = unitaries[0]:=unipotents
    then test_count = int:0, D=int:1
    then () =  if test_verbose then prints("facets counts to dim ",first_pass-1, " :",
			  for list in LFDKH do #list od) fi
    then () = while first_pass + D <= Affd.semisimple_rank + 1
    {while loop does is_unitary_to_ht on facets to dim first_pass; then adds
     facets of one dim higher and does is_unitary_to_ht on those...}
    	      do let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,Kpol_hash,hts[D-1])
       	      	 {compute graph on facets to dim first_pass}
       		 then statuses = [string]: for j:#eq do "?" od
       		 then finds = for d:#LFDKH
		      	      do index_in(for v in LFDKH[d] do v[:d+1] od)
			      od
       		 then () = for d:#LFDKH
		      	   do for M in unitaries_to_hts[D-1][d]##unitaries[d]
		      	      do let k = finds[d](M)
		    	      	 in if k>=0
		       	      	    then statuses:=downdateUclasses(statuses,
			    	    IUCL[CLBF[d][k]], CLBF[d][k],"T"##to_string(M))
		       		    fi
			      od
		 	   od
		 then (LFDKHnew, test_countnew, unitaries_new,unitaries_to_hts_new) =
		      local_testK_level(x,lambda,Lvd,
		      LFDKH, eq, gr, CLBF, statuses, hts, D-1,
		      unitaries, unitaries_to_hts, cert_hash, test_count)
 		then ()= test_count:=test_countnew
		then ()= unitaries:=unitaries_new
		then ()= unitaries_to_hts:=unitaries_to_hts_new
        	then ()= LFDKH := localFD_KHashbt_lookDown(x,lambda,vd, Lvd, Perm, mapAct,
	      	      	   LFDKHnew, first_pass + D -1,first_pass + D, Kpol_hash)
	        then () = if test_verbose then prints("facet counts to dim ",first_pass+D-1,": ",
	     	     	  		for list in LFDKH do #list od)
		{then () =} ; prints("unitary counts: ",for list in unitaries do #list od)
		{then () =} ; prints("unitary_to_ht: ",for list in unitaries_to_hts[D] do #list od) fi
   		then ()= D:=D+1
   		in ()
     	     od
    {now have facets of all dims, to height hts[D-2]}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then statuses = [string]: for j:#eq do "?" od
    then finds = for d:#LFDKH
		 do index_in(for v in LFDKH[d] do v[:d+1] od)
	  	 od
    then () = for d:#LFDKH
	      do for M in unitaries[d]
		 do let k = finds[d](M)
		    in if k>=0
		       then statuses:=downdateUclasses(statuses,
			    	    IUCL[CLBF[d][k]], CLBF[d][k],"T"##to_string(M))
		       fi
		 od
	      od
    then tester = (Param->bool): (Param p) bool: is_unitary(p, cert_hash)
    in local_test(x,lambda,Lvd,
    	      LFDKH,eq,gr,CLBF,statuses,tester,test_count)

set local_testK_levels_D(KGBElt x, ratvec lambda, KTypePol_hash cert_hash) =
    ([string],[Param]):
    let G = x.real_form, first_pass = 2
    then (Affd,,) = cofolded(G)
    then vd = FPP_vertex_data(G), depth=Affd.semisimple_rank - first_pass+1
    then hts = next_heights(parameter(x,lambda,0*lambda),depth+2)
    then (Lvd, Perm, mapAct, LFDKH) = localFD_KHash00(x,lambda, vd, Kpol_hash)
    {next add dim from 1 to first_pass}
    then () = LFDKH := localFD_KHashbt(x,lambda,vd, Lvd, Perm, mapAct,
	      LFDKH, 1, first_pass, Kpol_hash)
    {next three lines define lists of possibly unitary facets as vecs whose entries refer
     to the list in Lvd, which doesn't change}
    then empty = [[vec]]: for d:Affd.semisimple_rank + 1 do [] od
    then unipotents = [vec]: for m in local_unipotent_classes(x,lambda,Lvd) do vec: [m] od
    then unitaries_to_ht = [[vec]]: empty
    then unitaries = [[vec]]: empty
    then () = unitaries[0]:=unipotents
    then test_count = int:0, D=int:1
    then () =  if test_verbose then prints("facets counts to dim ",first_pass-1, " :",
			  for list in LFDKH do #list od) fi
    then () = while first_pass + D <= Affd.semisimple_rank + 1
    {while loop does is_unitary_to_ht on facets to dim first_pass then adds
     facets of one dim higher and does is_unitary_to_ht on those...}
    	      do let ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH,Kpol_hash,hts[D-1])
       	      	 {compute graph on facets to dim first_pass}
       		 then statuses = [string]: for j:#eq do "?" od
       		 then finds = for d:#LFDKH
		      	      do index_in(for v in LFDKH[d] do v[:d+1] od)
			      od
       		 then () = for d:#LFDKH
		      	   do for M in unitaries_to_ht[d]##unitaries[d]
		      	      do let k = finds[d](M)
		    	      	 in if k>=0
		       	      	    then statuses:=downdateUclasses(statuses,
			    	    IUCL[CLBF[d][k]], CLBF[d][k],"T"##to_string(M))
		       		    fi
			      od
		 	   od
		 then (LFDKHnew, test_countnew, unitaries_new,unitaries_to_ht) =
		      local_testK_level_D(x,lambda,Lvd,
		      LFDKH, eq, gr, CLBF, statuses, hts, D-1,
		      unitaries, empty, cert_hash, test_count)
 		then ()= test_count:=test_countnew
		then ()= unitaries:=unitaries_new
        	then ()= LFDKH := localFD_KHashbt_lookDown(x,lambda,vd, Lvd, Perm, mapAct,
	      	      	   LFDKHnew, first_pass + D -1, first_pass + D, Kpol_hash)
	        then () = if test_verbose then prints("facet counts to dim ",first_pass+D-1,": ",
	     	     	  		for list in LFDKH do #list od)
		{then () =} ; prints("unitary counts: ",for list in unitaries do #list od)
		{then () =} ; prints("unitary_to_ht: ",for list in unitaries_to_ht do #list od) fi
   		then ()= D:=D+1
   		in ()
     	     od
    {now have facets of all dims, to height hts[D-2]}
    then ((eq,gr),IUCL,CLBF) = localGraphK(LFDKH)
    then statuses = [string]: for j:#eq do "?" od
    then finds = for d:#LFDKH
		 do index_in(for v in LFDKH[d] do v[:d+1] od)
	  	 od
    then () = for d:#LFDKH
	      do for M in unitaries[d]
		 do let k = finds[d](M)
		    in if k>=0
		       then statuses:=downdateUclasses(statuses,
			    	    IUCL[CLBF[d][k]], CLBF[d][k],"T"##to_string(M))
		       fi
		 od
	      od
    then tester = (Param->bool): (Param p) bool: is_unitary(p, cert_hash)
    in local_test(x,lambda,Lvd,
    	      LFDKH,eq,gr,CLBF,statuses,tester,test_count)


set local_testK_levels_old(KGBElt x, ratvec lambda, KTypePol_hash cert_hash, int depth) =
    ([string],[Param]):
    let G = x.real_form
    then vd = FPP_vertex_data(G)
    then FPPKH = FPP_facets_KHash(G,vd,Kpol_hash)
    then unipotents = local_unipotent_classes(x,lambda,vd)
    then hts = next_heights(parameter(x,lambda,0*lambda),depth)
    then test_count = int:0
    then () = for level in hts[:depth -1]
    	      do let ((eq,gr),IUCL,CLBF) = localGraphK(FPPKH,Kpol_hash,level)
    	      	 then statuses = [string]: for j:#eq do "?" od
		 then newStatuses = statuses
		 then find0 = index_in(if #FPPKH = 0 then [vec]:[]
		      	      	       else for v in FPPKH[0] do v[:1] od
				       fi)
		 then () = for m in unipotents
		      	   do let k = find0([m])
		      	      in if k>=0
			      	 then newStatuses:=downdateUclasses(newStatuses,
			    	 IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
			    	 fi
			   od
    	    	 then (FPPKHnew, test_countnew) =
		      local_testK_level(x,lambda,vd,FPPKH,
	    	      eq, gr, CLBF, newStatuses, level,
		      cert_hash, test_count)
     	    	 then ()= FPPKH:=FPPKHnew
		 then ()= test_count:=test_countnew
	    	 in ()
              od
     then ((eq,gr),IUCL,CLBF) = localGraphK(FPPKH)
     then statuses = [string]: for j:#eq do "?" od
     then newStatuses = statuses
     then find0 = index_in(if #FPPKH = 0 then [vec]:[]
     	  	  	   else for v in FPPKH[0] do v[:1] od
			   fi)
     then () = for m in unipotents
	       do let k = find0([m])
		  in if k>=0
		     then newStatuses:=downdateUclasses(newStatuses,
			  IUCL[CLBF[0][k]], CLBF[0][k],"Tunip"##to_string(m))
		     fi
	       od
     then tester = (Param->bool): (Param p) bool: is_unitary_test(p, hts~[0], cert_hash)
     in local_test(x,lambda,vd, FPPKH,eq,gr,CLBF,newStatuses,tester,test_count)

set local(KGBElt x, ratvec lambda) = ([string],[Param]):
    let hts = next_heights(parameter(x,lambda,0*lambda),2)
    then tester = (Param->bool): (Param p) bool:
    	 is_unitary_test(p, hts[0], hts[1])
    in local_test(x,lambda,tester)

set spherical_local(RealForm G) = ([string],[Param]):
    local(x_open(G),G.rho)
set spherical_cert_hash = make_KTypePol_hash()

set spherical_levels(RealForm G) = ([string],[Param]):
    local_test_levels(x_open(G),G.rho,spherical_cert_hash,4)

set sphericalK_levels(RealForm G) = ([string],[Param]):
    local_testK_levels(x_open(G),G.rho,spherical_cert_hash,4)

set sphericalK_levels_A(RealForm G) = ([string],[Param]):
    local_testK_levels_A(x_open(G),G.rho,spherical_cert_hash,4)

set sphericalK_levels_B(RealForm G) = ([string],[Param]):
    local_testK_levels_B(x_open(G),G.rho,spherical_cert_hash)

set spherical_GEO(RealForm G) = ([string],[Param]):
    local_test_GEO(x_open(G),G.rho,spherical_cert_hash)

set sphericalK_levels_C(RealForm G) = ([string],[Param]):
    local_testK_levels_C(x_open(G),G.rho,spherical_cert_hash)

set sphericalK_levels_D(RealForm G) = ([string],[Param]):
    local_testK_levels_D(x_open(G),G.rho,spherical_cert_hash)

{next functions aim to compute FULL spherical dual in non-split case, when several
 different x give spherical reps}

set spherical_xs(RealForm G) = [KGBElt]:
    let real_rank = rank(x_open(G).involution + 1)
    in for x in KGB(G)
       do if rank(x.involution + 1) = real_rank
       	  then [x]
	  else []
	  fi
       od.##

{ lists item d of answer is a list of facets of unitary spherical
reps, given as lists of their vertices: d+1 ratvecs }
set sphericalJustTheVertexLists(RealForm G) = [[[ratvec]]]:
    let FD = FacetData: sphericalKPO_long(G)
    then vlist = FD.v_data.list, FDind = FD.facet_status_inds
    in for FDindd in FDind
       do for find in FDindd
       	  do if find.status[0]="T"
	     then [for j in find.verts do vlist[j] od]
	     else []
	     fi
	  od.##
       od

{.forget dimension info; just (for each spherical hermitian barycenter)
whether or not unitary, inducing nu. G(R) must have simple derived group.}
set JustTheFacts_simple(RealForm G) = [(bool,ratvec)]:
    let (vd,FVstInd) = sphericalKPO_long(G)
    in
    ##(for d:#FVstInd
	    do if only_unitary then
	       for FVI@j in FVstInd[d]
	       do if FVI.status[0]="T"
	          then [(true,facet_bary(vd.list,FVI.verts))]
	 	  else []
	          fi
	       od.##
	       else
	       for FVI@j in FVstInd[d]
	       do
		(
	       if FVI.status[0]="T" then true
	       elif FVI.status[0] = "F" then false
	       else prints("ERROR at d = ",d,", j = ",j); false
	       fi,
		  facet_bary(vd.list,FVI.verts)
		)
	       od
	       fi
	    od)

{. records vertices of unitary regions for spherical dual real simple
G; complex is OK .}
set JustTheRegions_simple(RealForm G) = [(bool,[ratvec])]:
    let ((vlist,),FVstInd) = sphericalKPO_long(G)
    in
    ##(for d:#FVstInd
	 do if only_unitary then
	    for FVI@j in FVstInd[d]
	    do if FVI.status[0]="T"
	       then [(true,
	       	    for v in FVI.verts do vlist[v] od)]
	       else []
	       fi
	    od.##
	    else
	    for FVI@j in FVstInd[d]
	    do (
	       if FVI.status[0]="T" then true
	       elif FVI.status[0] = "F" then false
	       else prints("ERROR at d = ",d,", j = ",j); false
	       fi,
		 for v in FVI.verts do vlist[v] od
		)
	    od
	    fi
	 od)

{ lists real and/or complex simple factors }
set simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
	simpleFactors = simple_factors(RootDatum: G),
	Factors = [RealForm]:[]
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex),
	 newDiagram = diagram_component(G,newSimpleRootIndex)
    in  if diagram=newDiagram then Factors##:=
	 [real_form(inner_class(rd,delta), delta, tf)]
	 else if diagram[0] < newDiagram[0] then Factors##:=
	 [real_form(inner_class(sub_datum(G,diagram##newDiagram),
		delta), delta, tf)]
	      fi
	fi
    od; Factors

set max_real_Levis(RealForm G) = [RealForm]:
    let xopen=x_open(G), Grho = G.rho, List = 1*G.trivial
    then inv=xopen.involution
    then tworhoM = (1+inv)*Grho
     then MRL= [RealForm]: []
    in for xi@j in G.fundamental_weights
    do
    let restrFund = (1-inv)*xi
    in if all(for i:j do restrFund*G.simple_coroots[i] = 0 od) and
       List[real_induce_standard(real_Levi_by_wt(restrFund, xopen).trivial,G)] = 0
       then MRL##:= [real_Levi_by_wt(restrFund, xopen)]; 
       	    List +:= real_induce_standard(real_Levi_by_wt(restrFund, xopen).trivial,G)
       fi
    od; MRL

{restricted to L having three simple factors; meant to be applied to a
maximal Levi in a simple G. [ratvec] is infinitesimal chars for spherical reps of L;
[bool] whether unitary}
set JustTheFacts(RealForm L) = [(bool,ratvec)]:
    let (Ms) = simple_factors(L)
    then JTFs = for M in Ms do JustTheFacts_simple(M) od

    in
    case #Ms
	 in [(true,null(L.rank)/1)],
	 JTFs[0],
	 for (stat0,nu0) in JTFs[0]
	     do for (stat1,nu1) in JTFs[1]
		do (stat0 and stat1, nu0+nu1)
		od
	     od.##,
	 for (stat0,nu0) in JTFs[0]
	     do for (stat1,nu1) in JTFs[1]
		do for (stat2,nu2) in JTFs[2]
		   do (stat0 and stat1 and stat2, nu0+nu1+nu2)
		   od
		od.##
	     od.##
     esac

{. takes two nonempty lists of ratvecs all of the same size, and
produces a list of all sums of pairs. Intended for getting vertices of
a product region .}
set product_vertices([ratvec] list1, [ratvec] list2) = [ratvec]:
    let n1 = #list1, n2 = #list2
    in for j:n1*n2 do
    list1[j\n2] + list2[j%n2]
    od

{. record vertices of unitarity regions. Works only for up to three
simple factors of L .}
set JustTheRegions(RealForm L) = [(bool,[ratvec])]:
    let Ls = simple_factors(L)
    then JTFs = for Lj in Ls do JustTheRegions_simple(Lj) od

    in
    case #Ls
	 in [(true,[null(L.rank)/1])],
	 JTFs[0],
	 for (stat0,nu0s) in JTFs[0]
	     do for (stat1,nu1s) in JTFs[1]
		do (stat0 and stat1,
		   product_vertices(nu0s, nu1s))
		od
	     od.##,
	 for (stat0,nu0s) in JTFs[0]
	     do for (stat1,nu1s) in JTFs[1]
		do for (stat2,nu2s) in JTFs[2]
		   do (stat0 and stat1 and stat2,
		   product_vertices(product_vertices(nu0s,nu1s),nu2s))
		   od
		od.##
	     od.##
     esac


{.like facet_statusu, adding info from real induction.}
{Marks unipotent parameters as "Tunip[number of dual nilpotent]", induced
as "TindLevi#" or "FindLevi#" FPPQuo should first be pruned by down_to_business}
set facet_statusu_ind(RealForm G, FacetData(vd,FPPQuo)) = FacetData:
    let old_facet_verbose = facet_verbose, old_test_verbose = test_verbose next
	if facet_verbose then prints("starting FPPB in facet_statusu_ind") fi
    then FPPB = for d:#FPPQuo do for Find in FPPQuo[d] do
	facet_bary(vd.list,Find.verts) od od next facet_verbose := false;
				      test_verbose := false
    then allFPPB = [ratvec]: ##FPPB, FPPnew = FPPQuo,
	 allLABELS =  ##(for d:#FPPB do for j:#FPPB[d] do (d,j) od od),
	 maxLevis = [RealForm]: max_real_Levis(G)
{indices to convert from FPPQuo to allFPPQuo}
    then bary_lookup = index_in(allFPPB)
    , lookups = [(vec->int)]: { lookup functions for equidiemnsional facets }
        for L in FPPQuo do index_in_facet_list(L) od
    then JTFLs = [ [(bool,ratvec)] ]:
	 for L in maxLevis
	 do
	 if old_facet_verbose then prints("starting JTF for Levi ",L,
	 " in facet_statusu_ind") fi;
	 JustTheFacts(L)
	 od
    then (rd,M,j) = cofolded(G)
    then leftM = M.left_inverse
{ update FPPQuo working through Levis }
    then totalChop = int: 0
    then temp = for L@j in maxLevis
    do
    if old_facet_verbose then prints(new_line,"updating status using Levi ",L);
	 prints("in facet_statusu_ind, using ",#JTFLs[j]," representations on L.") fi;
    let xL = x_open(L), rhoL = L.rho
    then countUp = int: 0, countDown = int: 0
    in
    for (uboolL,gammaL) in JTFLs[j]
	do
	let IgammaLstd = real_induce_standard(parameter(xL, rhoL, gammaL), G)
	then gammaG=first_param(IgammaLstd).infinitesimal_character
	then gammaGlisted = M*facet_bary(rd,leftM*gammaG)
	then nG = bary_lookup(gammaGlisted)
	then bigTrouble = if nG=-1 then prints("TROUBLE at MaxLevi #",j,
	     "  which is ",L, ",  and gammaL = ",gammaL, ", gammaG = ",
		gammaG); break fi
	then (d,j) = allLABELS[nG]
	then FPPnewd = FPPnew[d], Find = FPPnew[d][j]
	in
	let result =
	    if FPPnew[d][j].status!="?"
	    then FPPnew[d][j].status
		{if inducing rep is unitary, so is induced, and facets
		    in closure}
	    elif uboolL then countDown := countDown+1
		; FPPnew:= updateSing{Closure}(G, (vd,FPPnew),
		  ("Ti",Find.verts))
		; "Ti"
		{if inducing is hermitian nonunitary,
		    and induction is irreducible, then induced is hermitian
		    nonunitary, along with facets in opening}
	    elif #real_induce_irreducible(parameter(x_open(L),L.rho, gammaL),G)
	    	 = 1
	    then countUp := countUp+1
	    	 ; FPPnew:= update(lookups, FPPnew, ("Fi",Find.verts))
		 ; "Fi"
	    else "?" { FPPnew[d][j].status }
	    fi
	    then temp = (); FPPnewd[j]:= (result,FPPnewd[j].verts)
	    in FPPnew[d] := FPPnewd
	od; if old_facet_verbose then prints("completed Levi ",j," using ",
	    countUp, " updates and ", countDown, " downdates") fi
    od; facet_verbose := old_facet_verbose
    ; test_verbose := old_test_verbose
    in
    (vd, FPPnew)

set facet_statusu_ind(RealForm G) = FacetData:
    let data = facet_data_fold(cofolded(G))
    then dataAct = actualize(x_open(G), G.rho, data)
    then dataIndncH = down_to_business(G,dataAct)
    in facet_statusu_ind(G,dataIndncH)

set facet_statusu_reg(RealForm G, FacetDataOldKchar(vd,FPPQuo, OldBarys,
    Pols)) = FacetDataKchar:
    let old_facet_verbose = facet_verbose, old_test_verbose = test_verbose next
	if facet_verbose then prints("starting FPPB in facet_statusu_reg") fi
    then allFPPB = [ratvec]: ##OldBarys, FPPnew = FPPQuo,
	 allLABELS =  ##(for d:#OldBarys do for j:#OldBarys[d] do (d,j) od od),
	 maxLevis = [RealForm]: max_real_Levis(G) next facet_verbose:= false
	 ; test_verbose:=false
    {indices to convert from FPPQuo to allFPPQuo}
    then bary_lookup = index_in(allFPPB)
    	 , lookups = [(vec->int)]: { lookup functions for equidiml facets }
        for L in FPPQuo do index_in_facet_list(L) od
    then JTRs = [ [(bool,[ratvec])] ]:
	 for L in maxLevis
	 do
	 if old_facet_verbose then prints("starting JTR for Levi ",L,
	 " in facet_statusu_reg") fi;
	 JustTheRegions(L) od
    then (rd,M,j) = cofolded(G)
    then leftM = M.left_inverse
{ update FPPQuo working through Levis }
    then totalChop = int: 0
    then temp = for L@j in maxLevis
    do{LOOP OVER LEVIS}
    if old_facet_verbose then prints(new_line,"updating status using Levi ",L);
	 prints("in facet_statusu_reg, using ",#JTRs[j]," representations on L.") fi;
    let xL = x_open(L), rhoL = L.rho
    then countUp = int: 0, countDown = int: 0, countChopped = int: 0
    in
    for (uboolL,gammaLs) in JTRs[j] {Need first to chop}
	do{LOOP OVER L UNITARY REGIONS}
	{ bad next line: don't know how to chop using just folded root
	  datum; trouble is that L is not folded consistently with G }
	{ let gammaGs = [[ratvec]]: for w in chop_coroots(rd,
	    for v in gammaLs do leftM*v od, rd.semisimple_rank) do M*w od }
	let gammaGs = [[ratvec]]: chop_coroots(G,gammaLs,chop_bound)
	in
		countChopped := countChopped+#gammaGs;
		for gammaG {[ratvec], verts of one reg} in gammaGs
	     	     do{LOOP OVER CHOPPED PIECES}
		     let gammaLb = sum(G.rank, gammaG)/#gammaG
		     { next line converts to a barycenter of the folded datum }
		     then gammaGb = (1*real_induce_standard(
		     	  parameter(xL,rhoL,gammaLb),G)
			  ).infinitesimal_character
		     then gammaGlisted = M*facet_bary(rd, leftM*gammaGb)
		     then nG = bary_lookup(gammaGlisted)
		     then bigTrouble = if nG=-1 then prints(
		        "TROUBLE at MaxLevi #",j,
	     		"  which is ",L, ",  and gammaGb = ",gammaGb); break fi
		     then (d,j) = allLABELS[nG]
		     then FPPnewd = FPPnew[d], Find = FPPnew[d][j]
		     in
		     let result =
	    		if FPPnew[d][j].status!="?"
	    		then FPPnew[d][j].status
			     {if inducing rep is unitary, so is induced,
			      and facets in closure}
	    		elif uboolL then countDown := countDown+1;
			     FPPnew := downdate(lookups, FPPnew,
			         ("Ticlosure",FPPnew[d][j].verts));
			     FPPnew := updateSingK{Closure}(lookups
			     	       , (vd,FPPnew,Pols)
				       , ("Tiopen",Find.verts),Pols[d][j])
			; "Ti"
			     {if inducing is hermitian nonunitary,
		    	     	 and induction is irreducible, then
				 induced is hermitian nonunitary,
				 along with facets in opening}
	    		elif #real_induce_irreducible(parameter(
			     x_open(L),L.rho, gammaLb),G) = 1
	    		     	    then countUp := countUp+1
	    		;    FPPnew:= update(lookups, FPPnew,("Fi",Find.verts))
			;    FPPnew:= downdateSingK(lookups,(vd, FPPnew,Pols),
			     ("Fi",Find.verts), Pols[d][j])
			; "Fi"
	    		else "?" { FPPnew[d][j].status }
	    		fi
	    		then temp = (); FPPnewd[j]:= (result,FPPnewd[j].verts)
	    		in FPPnew[d] := FPPnewd
		     od{LOOP OVER CHOPPED PIECES}
       od{LOOP OVER L UNITARY REGIONS}; if old_facet_verbose then prints(
       	       "completed Levi ",j," using ",
	    countUp, " updates and ", countDown, " downdates and ",
	    countChopped, " chopped regions.") fi
	    ; totalChop := totalChop+countChopped
    od{LOOP OVER LEVIS}; facet_verbose := old_facet_verbose
    ; test_verbose := old_test_verbose
    ; if test_verbose then prints("total chopped regions ",totalChop) fi
    in
    (vd, FPPnew, Pols)


{ want to use PO data and downdate/update accordingly }
{Note that this does NOT insert unipotent reps; that's done by facet_statusu_reg(G) which is meant to come first.}
set facet_statusu_regPO(RealForm G, FacetDataOldKcharPO(vd,FPPQuo, OldBarys,
    Pols, eq, gr, {INUCL, }IUCL,  classListByFacet, statuses{, Ps})) = [string]:
    let () =  statuses:= facet_statusuKPO_old(G, (vd, FPPQuo, Pols, eq, gr
    	{, INUCL}, IUCL, classListByFacet, statuses{, Ps}))
    then old_facet_verbose = facet_verbose, old_test_verbose = test_verbose next
	if facet_verbose then prints("starting FPPB in facet_statusu_regPO") fi
    then allFPPB = [ratvec]: ##OldBarys,
	 allLABELS =  ##(for d:#OldBarys do for j:#OldBarys[d] do (d,j) od od),
	 maxLevis = [RealForm]: max_real_Levis(G) next facet_verbose:= false
	 ; test_verbose:=false
    {indices to convert from FPPQuo to allFPPQuo}
    then bary_lookup = index_in(allFPPB)
    	 , lookups = [(vec->int)]: { lookup functions for equidiml facets }
        for L in FPPQuo do index_in_facet_list(L) od
    then JTRs = [ [(bool,[ratvec])] ]:
	 for L in maxLevis
	 do
	 if old_facet_verbose then prints("starting JTR for Levi ",L,
	 " in facet_statusu_regPO") fi;
	 JustTheRegions(L) od
    then (rd,M,j) = cofolded(G)
    then leftM = M.left_inverse
{ update FPPQuo working through Levis }
    then totalChop = int: 0
    then temp = for L@j in maxLevis
    do{LOOP OVER LEVIS}
    if old_facet_verbose then prints(new_line,"updating status using Levi ",L);
	 prints("in facet_statusu_regPO, using ",#JTRs[j]," representations on L.") fi;
    let xL = x_open(L), rhoL = L.rho
    then countUp = int: 0, countDown = int: 0, countChopped = int: 0
    in
    for (uboolL,gammaLs) in JTRs[j] {Need first to chop}
	do{LOOP OVER L UNITARY REGIONS}
	{ bad next line: don't know how to chop using just folded root
	  datum; trouble is that L is not folded consistently with G }
	{ let gammaGs = [[ratvec]]: for w in chop_coroots(rd,
	    for v in gammaLs do leftM*v od, rd.semisimple_rank) do M*w od }
	let gammaGs = [[ratvec]]: chop_coroots(G,gammaLs,chop_bound)
	in
		countChopped := countChopped+#gammaGs;
		for gammaG {[ratvec], verts of one reg} in gammaGs
	     	     do{LOOP OVER CHOPPED PIECES}
		     let gammaLb = sum(G.rank, gammaG)/#gammaG
		     { next line converts to a barycenter of the folded datum }
		     then gammaGb = (1*real_induce_standard(
		     	  parameter(xL,rhoL,gammaLb),G)
			  ).infinitesimal_character
		     then gammaGlisted = M*facet_bary(rd, leftM*gammaGb)
		     then nG = bary_lookup(gammaGlisted)
		     then bigTrouble = if nG=-1 then prints(
		        "TROUBLE at MaxLevi #",j,
	     		"  which is ",L, ",  and gammaGb = ",gammaGb); break fi
		     then (d,k) = allLABELS[nG]
		     then m = classListByFacet[d][k]
		     in
		     let result =
	    		if statuses[m] !="?"
	    		then statuses[m]
			     {if inducing rep is unitary, so is induced,
			      and facets in closure}
	    		elif uboolL then countDown := countDown+1;
			     	    statuses:= downdateUclasses(statuses,
				    	       IUCL[m], m
					       , "indLevi"##to_string(j))
			; "TindLevi"##to_string(j)
			     {if inducing is hermitian nonunitary,
		    	     	 and induction is irreducible, then
				 induced is hermitian nonunitary,
				 along with facets in opening}
	    		elif #real_induce_irreducible(parameter(
			     x_open(L),L.rho, gammaLb),G) = 1
	    		     	    then countUp := countUp+1;
				    statuses := {updateNUclasses(statuses,
				    	       INUCL[m],m)}
					       updateNUclassesB(statuses,
					       gr, m, "indLevi"##to_string(j))
			; "FindLevi"##to_string(j)
	    		else "?" { FPPnew[d][j].status }
	    		fi
	    		in statuses[m] := result
		     od{LOOP OVER CHOPPED PIECES}
       od{LOOP OVER L UNITARY REGIONS}; if old_facet_verbose then prints(
       	       "completed Levi ",j," using ",
	    countUp, " updates and ", countDown, " downdates and ",
	    countChopped, " chopped regions.") fi
	    ; totalChop := totalChop+countChopped
    od{LOOP OVER LEVIS}; facet_verbose := old_facet_verbose
    ; test_verbose := old_test_verbose
    ; if test_verbose then prints("total chopped regions ",totalChop) fi
    in statuses
    {(vd,FPPQuo, Pols, eq, INUCL, IUCL,  classListByFacet, statuses, Ps)}

{ set facet_statusu_reg(RealForm G) = FacetDataKchar:
    let data = facet_data_fold(G)
    then (vdata, dataAct, OldBarys, Pols) =
    	 actualize_oldK(x_open(G), G.rho, data)
    then (vdata, dataActu) = facet_statusu(G, (vdata, dataAct))
    in facet_statusu_reg(G,(vdata, dataAct, OldBarys, Pols))}

{collects unipotent data, then induced data, in prep for unitarity testing}
set facet_statusu_regPO(RealForm G) = FacetDataKcharPO_old:
    let data = facet_data_fold(cofolded(G))
    then (vdata, dataAct, Pols, eq, gr, IUCL, CLBF, statuses) =
    	 actualizeKPO_old(x_open(G), G.rho, data)
    then FDKoldPO = FacetDataOldKcharPO: (vdata, dataAct, [[ratvec]]: [[]], Pols, eq, gr, IUCL, CLBF, statuses)
    , FDKPO = FacetDataKcharPO_old: (vdata, dataAct, Pols, eq, gr, IUCL, CLBF, statuses)
    then () = FDKPO.class_status := facet_statusu_regPO(G,FDKoldPO)
    in FDKPO

{.spherical unitarity data one simple factor at a time.}
set genSpherical(RealForm G) = [ FacetData ]:
for G0 in simple_factors(G) do sphericalK(G0) od


{.same as spherical using induced info.}
set spherical_ind(RealForm G) = FacetData:
    let dataIndInd = facet_statusu_ind(G)
    in spherical(G, dataIndInd)

{.same as spherical using induced info.}
{ set spherical_reg(RealForm G) = FacetData:
    let dataReg = facet_statusu_reg(G)
    in sphericalK(G, dataReg)}

set spherical_regPO(RealForm G) = [string]:
    let dataRegPO = facet_statusu_regPO(G)
    in spherical_testKPO(G, dataRegPO, default_tester@Param)

{set spherical_reg_test(RealForm G, (Param->bool) tester) = FacetData:
    let dataReg = facet_statusu_reg(G)
    in spherical_testK(G, dataReg, tester)}

set spherical_reg_testPO(RealForm G, (Param->bool) tester) = [string]:
    let dataRegPO = facet_statusu_regPO(G)
    in spherical_testKPO(G, dataRegPO, tester)

set spherical_reg_testPO_long(RealForm G, (Param->bool) tester) = FacetData:
    let dataRegPO = facet_statusu_regPO(G)
    then () = dataRegPO.class_status := spherical_testKPO(G, dataRegPO
    	      			     	, tester)
        in statuses_to_facets(G, dataRegPO)

set spherical_reg_PO_long(RealForm G) = FacetData:
    let dataRegPO = facet_statusu_regPO(G)
    then () = dataRegPO.class_status := spherical_testKPO(G, dataRegPO
    	      			     	, default_tester@Param)
        in statuses_to_facets(G, dataRegPO)

{ still need simple derived group }
{need vlist to match FPP_vertex_sets_indices}

set spherical_ind_test(RealForm G, (Param -> bool) tester) = FacetData:
    let dataInd = facet_statusu_ind(G)
    in spherical_test(G, dataInd, tester)

{
idea is in a session to say
  >> FILENAME write(FD)

Then in another session you can write
<< FILENAME
which will give you FacetData FD_saved, to which you can apply spherical.
}
set write(FacetData (vdata, FVI)) = void:
    prints("set FD_saved = FacetData:");
    prints(" let vlist_saved = ", vdata.list);
    prints("then FVI_saved = [[FacetStatusVertsIndex]]:",FVI);
    prints("in (to_vertex_data(vlist_saved),FVI_saved)")

set leq([Param] Plist) = (int i, int j) bool:
    HTA(Plist[i]) <= HTA(Plist[j])

{.given a list Plist of Params, sort it according to HTA.}
set HTA_sort([Param] Plist) = [Param]:
    let listSorter = [int]: sort(leq(Plist))(#Plist)
    in [Param]: for j:#Plist do Plist[listSorter[j]] od

set cohom_ind(KGBElt x) = KGPElt:
    let G=x.real_form, theta = x.involution
    then fund_wts=fundamental_weights(G)
    then fund_wt_lookup = index_in(fund_wts)
    then lambda = sum
        ( G.rank
	, for v in fund_wts
	  do if fund_wt_lookup(theta*v).< then [] else [v] fi
	  od.##
        )
    in parabolic_by_wt(lambda,x)

set hardKGB(RealForm G) = [KGBElt]:
     for x in KGB(G)
     do if cohom_ind(x).Levi = G then [x] else [] fi
     od.##

{.Meant to refer to a particular KGBElt x and a particular list of
FacetBary's FB[d]; (j,lr) means that there is a parameter (x,lr+rho,nu)
of infinitesimal character FB[d][j].}
set_type CandLambda = (int,vec)

{.The dth term of facet_barycenters is a complete list of barycenters of
d-dimensional facets. The dth term of candidate_lambdas is a list of
pairs (j,lr) so that the jth facet is represented at KGB_Elt
by lambda-rho = lr.}

set_type KGBFacets = (KGBElt KGB_elt, [[FacetBary]]
facet_barys, [[CandLambda]] cand_lambdas)

{.Find barycenters in FPP defining a good lambda for KGBElt x.}
{dth term in result lists which entries of FB[d][j] qualify, and gives
qualifying lambda0 = lambda-rho}

set goodFPP(KGBElt x, [[FacetBary]] FB) = KGBFacets:
    let rho = rho(x.real_form), th1 = 1+involution(x)
    in
    (x, FB, for FBd in FB
    do for v@j in FBd
       do
       case vec_solve(th1,th1*(v-rho))
       | else [(int,vec)]: [] {if no solns, this facet can't occur}
       | solution (lr): [(j,lr)]
       esac
       od.##
    od)

{. Meant to refer to a particular KGBElt x, a particular list of
FacetBary's FB[d], and the list comp_chars of elements of X*
representing chraacters of the component group of H(x).
(j,lr,v, [FacetStatus]) means that for each coordinate k@m of v, there is a
final hermitian parameter (x,lr+rho+comp_chars[k],nu) of infinitesimal
character FB[d][j], whose unitarity status is recorded by the mth
entry of [FacetStatus] .}
set_type CandLambdaTwistsStatus = (int x, vec lambda0 , vec
twists, [string] status)

{.Supplement KGBFacets by including list comp_chars of elements of X^*
representing all characters of component group of Cartan for KGB_elt;
then [[(vec,[string])]] recording for each cand_lambda (j,lr) a
twist_status (whose
entries index the twists of lr giving hermitian final Params, }

set_type KGBFacetsTwists = (KGBElt KGB_elt, [[FacetBary]]
facet_barys, [vec] comp_chars, [[CandLambdaTwistsStatus]] twist_statuses)

{.Find hermitian irrs with final param involving x, not good range
cohom induced.}
{Third coord of triple, list of elts of [0,2^n),  says which twists of lambda0
are allowed}
{cand_lambda_rho meant to come from goodFPP}

set non_cohom_herm(KGBFacets (x, FB,  CLs)) = KGBFacetsTwists:
    let all_d_zero = all_lambda_differential_0(x),
    rho=rho(x.real_form), theta = x.involution
    in (x, FB, all_d_zero,
    for CLsd@d in CLs
    do for (j,lr) in CLsd
       do let gamma = FB[d][j]
	  then twists = vec: for v@k in all_d_zero
	  do let p=parameter(x, lr+rho+v, gamma)
	  in
	  if not(is_zero(p)) and p.infinitesimal_character=gamma
	     and first_param(finalize(p)).x = x and is_hermitian(p)
	  then [k] else [] fi
	  od.##
	  in if #twists  > 0 then [(j,lr,twists, [string]: for k:#twists
	  do "?" od)] else [] fi
     od.##
    od)

{probably this is all unitary attached to x that are not cohom
induced}
set non_cohom_unitary(KGBFacetsTwists (x, FB, twists, CLTs)) =
(KGBElt,[vec],[[CandLambdaTwistsStatus]]):
    let rho = rho(x.real_form) in
    (x, twists,
    for CLTsd@d in CLTs
    do for (j,lr,which_twists, status) in CLTsd
       do let ustatus = for k@m in which_twists
	  do let p=parameter(x, lr+rho+twists[k], FB[d][j])
	  in
	  if is_unitary(p) then "T" else "F" fi
	  od
       in (j,lr,which_twists,ustatus)
       od
    od
    )

{NEED to figure out correct j in FPP_barycenters}
set non_cohom_unitary(KGBElt x) = (KGBElt,[vec],[[CandLambdaTwistsStatus]]):
    non_cohom_unitary(non_cohom_herm(goodFPP(x,
    FPP_barycenters(x.real_form,-1))))

{.goodFPP for all hard_KGB elements.}
set goodFPP(RealForm G, [[FacetBary]] FB) = [(KGBElt, [[CandLambda]])]:
    let hard_KGB = hardKGB(G) in
    for x in hard_KGB do let (,,CLs) = goodFPP(x, FB) in  (x,CLs) od


set non_cohom_herm(RealForm G, [[FacetBary]] FB, [(KGBElt,
    [[(int,vec)]])] cand_lambda_rho) = [(KGBElt,[vec],
		[[CandLambdaTwistsStatus]])]:
    let rho = rho(G) in
	for (x, CLs) in cand_lambda_rho
	do let (,,twists,candTws) =
	   non_cohom_herm(x,FB,CLs) in (x,twists,candTws) od

set non_cohom_unitary(RealForm G, [[FacetBary]] FB, [(KGBElt, [vec],
    [[CandLambdaTwistsStatus]])] candTw) = [(KGBElt,[vec],
    [[CandLambdaTwistsStatus]])]:
    for (x, twists, CLs) in candTw do non_cohom_unitary(x,FB,twists,
    CLs)  od

{NEED to work out correct FPP_barycenters}

set non_cohom_unitary(RealForm G) = [(KGBElt,[vec],
    [[CandLambdaTwistsStatus]])]:
    let FB =  FPP_barycenters(G,-1) in non_cohom_unitary(G, FB,
    non_cohom_herm(G, FB, goodFPP(G,FB)))

set non_cohom_unitaryFold(RealForm G) = [(KGBElt,[vec],
    [[CandLambdaTwistsStatus]])]:
    let FD = facet_data_fold(cofolded(G))
    then vlist = FD.v_data.list, FV = FD.facet_status_inds
    then FB = [[FacetBary]]:  for FVd in FV do for FVI in FVd do
    	 facet_bary(vlist, FVI.verts) od od
    in  non_cohom_unitary(G, FB, non_cohom_herm(G, FB, goodFPP(G,FB)))

set show(RealForm G, [[FacetBary]] FB,
[(KGBElt,[vec],[[CandLambdaTwistsStatus]])] candTW) = void:
    let rho = rho(G) in
    prints("Non-cohomologically induced unitary reps for ",G);
    for (x,twists,CLTs) in candTW
    do
    prints(new_line,x);
	for CLTsd@d in CLTs
	do
	    for (j,lr,which_twists,statuses) in CLTsd
	    do
		for k@m in which_twists
		do
		if statuses[m][0] = "T" then
		   prints(parameter(x, lr+rho+twists[k], FB[d][j]),
		   "  ",FB[d][j])
		fi
		od
	    od
	od
     od
{NEED correct j in FPP_barycenters}
set show_non_cohom_unitary(RealForm G) = void:
    let FB=FPP_barycenters(G,-1), NCU = non_cohom_unitary(G)
    in
    show(G, FB, NCU)
