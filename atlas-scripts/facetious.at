<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]) }
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<K_highest_weights.at { for LKT }
<springer_tables_reductive.at { for Springer_table }

{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])}

{ Just do this for SIMPLE root datum rd.}

{ at the end is a function "spherical" which (if G has simple derived
group) might return which facets correspond to non-cohomologically
induced spherical principal series. Haven't proven this. }

{ One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell) }

{ There are four notions of "facet":
1) a ([AffineCoroot],[AffineCoroot]) Facet of affine inequalities and
equalities defining it (NOT UNIQUE);
2) the [ratvec] FacetVerts of vertices;
3) the ratvec FacetBary, the barycenter of the facet; and
4) the [vec] FacetVertsIndex of indices of the vertices in a fixed list of vertices

I like FacetVerts the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) bu looking at all
enlargements of the vertex set. Passage from FacetVerts to FacetBary is
trivial (average the vertices) There are functions facet, facetVerts and
facetBary which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{ useful to assign this to 'true" to get information about the progress
of long calculations }
set facet_verbose=false

{.remove repetitions from list of ratvecs.}
set NoReps([ratvec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{.remove repetitions from a list of vecs.}
set NoReps([vec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum

set aff_rank(SimpleAffine Affd) = ss_rank(Affd) + 1

set_type AffineCoroot = (vec,int)

{.evaluate AffineCoroot at weight.}
set *(AffineCoroot (betav,m), vec gamma) = m+betav*gamma

{.evaluate AffineCoroot at rational weight.}
set *(AffineCoroot (betav,m), ratvec gamma) = m+betav*gamma

{.first apply w, then translate by tau.}
set_type AffineCoWeylElt = (vec tau, WeylElt w)

{.apply AffineCoWeylElt to weight.}
set *(AffineCoWeylElt (tau,w) , vec gamma) = w*gamma + tau
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = w*gamma + tau

{.compose AffineCoWeylElts.}
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = AffineCoWeylElt:
    (tau1 + w1*tau2, w1*w2)
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
    let bvw1=betav*inverse(w) in (bvw1, m-bvw1*tau)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
    let w1=inverse(w) in (-w1*tau,w1)

{.simple affine coroots: number 0 is affine, rest are simple for RootDatum.}
set aff_simple_coroots (SimpleAffine affd) = [AffineCoroot]:
    (-highest_root(dual(affd)),1) #
    for alpha_v in simple_coroots(affd) do (alpha_v,0) od

{.sum of simple affine coroots times their labels is (null(rank),1).}
set labels(SimpleAffine affd) = [int]:
    let a = coroot_index(affd,highest_root(dual(affd))) in
    1 # coroot_expression(affd,a)

{.a common denominator for all vertices of alcoves.}
set denom (SimpleAffine affd) = int:
    let lab = labels(affd), fwts=affd.fundamental_weights in
    for fw@j in fwts do denom(fw)*lab[j+1] od.lcm

{.root attached to an AffineCoroot.}
set root (AffineCoroot (betav,m),SimpleAffine affd) = root(affd,betav)

{.affine reflection through Affine coroot, applied to weight.}
set reflection(AffineCoroot Betav, SimpleAffine affd, vec v) = vec:
    v - root(Betav,affd)*(Betav*v)

set reflection(AffineCoroot Betav, SimpleAffine affd, ratvec v) = ratvec:
    reflection(Betav, affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot strict inequalities and (n-k) AffineCoRoot equalities.
The total collection of affine coroots appearing must be a set of simple coroots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE }

set_type [Facet = ([AffineCoroot] pos,[AffineCoroot] zero)]

{ at the moment this does not work, because wall_set does not work }

set facet_MVL(SimpleAffine Affd, ratvec gamma) = Facet:
    let walls = walls(Affd,gamma)
    then affcoroots = for j:#walls
    	 do
    	 let betav = Affd.coroots[walls[j]] in (betav, -floor(betav*gamma))
	 od
    then pos = for j:#affcoroots
    	 do
	 if affcoroots[j]*gamma>0
	 then [affcoroots[j]]
	 else[]
	 fi
	 od.##,
    zero = for j:#affcoroots
    	 do
	 if affcoroots[j]*gamma=0
	 then [affcoroots[j]]
	 else[]
	 fi
	 od.##
    in (pos,zero)

{.this is wrong if gamma is integral; fails to incorporate the adjustment of the "affine" affine coroot made in facet_vertsMVL.}
set alcove_MVL(SimpleAffine Affd, ratvec gamma) = [AffineCoroot]:
    let walls = walls(Affd,gamma)
    in for j:#walls
    do
    let betav = Affd.coroots[walls[j]] in (betav, -floor(betav*gamma))
    od


{ a UNIQUE characterization of a k-diml facet is as a set of
k+1 vertices }

set_type FacetVerts = [ratvec]

{ Using Marc's calculation of the defining equations of an alcove of gamma }
set facet_vertsMVL(SimpleAffine Affd, ratvec gamma) = FacetVerts:
    let coroots = mat: for j in walls(Affd,gamma) do Affd.coroots[j] od
    then M= mat: ^coroots
    then lab = kernel(coroots)[0],
    	 mu = for j:#coroots do -floor(coroots[j]*gamma) od {these are meant}
	    {to be integer parts of the coroot walls. But if gamma is integral,
	    one of them is incorrect: needs to be adjusted by 1.}
    then epsilon = lab*mu
    in if epsilon = 0 then let j = first(for k:#lab do lab[k]^2 = 1 od)
    in mu[j]:=mu[j]+lab[j]; epsilon := 1 {this is the adjustment}
    fi;
    for j:Affd.aff_rank
    do
    let muprime = mu
    in
    if coroots[j]*gamma != -mu[j]
    then let muprime = ratvec:
    	 for k:Affd.aff_rank do
	     if k=j
	     then [mu[j] - epsilon/lab[j]]
	     else [mu[k]/1]
	     fi
	     od.##
    in [solve(M,-muprime).requisition]
    else []
    fi
    od.##

set *(WeylElt w, FacetVerts FV) = FacetVerts:
    for v in FV do w*v od

set *(mat M, FacetVerts FV) = FacetVerts:
    for v in FV do M*v od

set *(AffineCoWeylElt wtilde, FacetVerts FV) = FacetVerts:
    for v in FV do wtilde*v od

{ Maybe the smallest UNIQUE characterization is the barycenter }

set_type FacetBary = ratvec

{for d-dimensional facet, entry 0 is barycenter, 1 to d+1 are vertices}
set_type FacetBaryVerts = [ratvec]

{.for d-dimensional facet, vec is barycenter, vec is d+1 indices into
      list of vertices held elsewhere.} 
set_type FacetBaryInds = (ratvec,vec)

{ actual barycenter is this divided by Bdenom(Affd) }
set_type FacetBaryNum = vec

{represents a k-diml facet as k+1 indices into a list of vertices
(held elsewhere)}
set_type FacetVertsIndex = vec

set facet_verts_index([ratvec] vert_list, FacetVerts facet) = FacetVertsIndex:
    for gammav in facet do find(vert_list,gammav) od.sort

{ creates the indexing ParamPol }
{ this only works if the list elements are distinct! }
set index([ratvec] list) = ParamPol:
    let G1=root_datum(null(#list[0],0),null(#list[0],0),true).split_form
    in sum(G1,for v@j in list do (j+1)*parameter(G1,0,G1.rho,v) od)

set indexNoRep([ratvec] list) = ([ratvec], ParamPol):
    let G1=root_datum(null(#list[0],0),null(#list[0],0),true).split_form
    then P1 = sum(G1, for v in list do parameter(G1,0,G1.rho,v) od)
    then list0 = for p@j in monomials(P1) do p.nu od
    in (list0, sum(G1,for v@j in list0 do (j+1)*parameter(G1,0,G1.rho,v) od))

set find(ParamPol Index,ratvec v) = int:
let GI = Index.real_form in
split_as_int(Index[parameter(GI,0,GI.rho,v)]) - 1

{ same as facet_verts_index using a precreated ParamPol as index set }
set facet_verts_index(ParamPol Index, FacetVerts facet) = FacetVertsIndex:
for gammav in facet do find(Index,gammav) od.sort

{.same as facet_verts_index using a precreated ParamPol as index set, starting with barycenter; or in fact any point of the facet.}
set facet_verts_index(SimpleAffine Affd, ParamPol Index, FacetBary gamma) =
    FacetVertsIndex:
    for gammav in facet_vertsMVL(Affd, gamma) do find(Index,gammav) od.sort

{.computes the Facet of a point gamma0 in the fundamental alcove.}
set facet0(SimpleAffine Affd, ratvec gamma0) = Facet:
    let S=Affd.aff_simple_coroots in
    (for j:Affd.aff_rank
    do if S[j]*gamma0 != 0
       then [S[j]]
       else []
       fi
    od.##,
    for j:Affd.aff_rank
    do if S[j]*gamma0 = 0
       then [S[j]]
       else []
       fi
    od.##)
{.simple roots corresponding to simple affine coroots: number 0 is
affine,  rest are simple for RootDatum.}
set aff_simple_roots(SimpleAffine affd) = mat:
    (-highest_root(dual(affd))) # affd.simple_roots

{.vertices of the fundamental alcove.}
{ set has aff_rank elements }
set fundamental_vertices (SimpleAffine affd) = [ratvec]:
    (ratvec:null(affd.rank)) #
    (let labs=affd.labels[1:] in
     for lab@j in labs do fundamental_weight(affd,j)/lab od)

{.numerators only; actual are divided by denom(affd).}
set fundamental_vertices_numer(SimpleAffine affd) = mat:
    null(affd.rank) #
    (let labs=affd.labels[1:], d=denom(affd) in
     for lab@j in labs do ratvec_as_vec(d*fundamental_weight(affd,j)/lab) od)

{.FacetVerts of a point gamma0 in the fundamental alcove.}
set facet_verts0(SimpleAffine affd, ratvec gamma0) = FacetVerts:
    let vert=fundamental_vertices(affd) in
    for coroot@d in affd.aff_simple_coroots
    do if =coroot*gamma0 then [] else [vert[d]] fi
    od.##

{.FacetBaryVerts of gamma0 in the fundamental alcove.}
set facet_bary_verts0(SimpleAffine Affd, ratvec gamma0) = FacetBaryVerts:
    let S=Affd.aff_simple_coroots, V=fundamental_vertices(Affd),
    	Verts=facet_verts0(Affd,gamma0)
    in
    [sum(Affd.rank, Verts)/#Verts]##Verts

{.computes the FacetBary of a point gamma0 in the fundamental alcove.}
set facet_bary0(SimpleAffine affd, ratvec gamma0) = FacetBary:
    let verts = facet_verts0(affd,gamma0) then n=#verts in
    sum(affd.rank, for v in verts do v/n od)

{.all facets in the fundamental alcove, organized by dimension.}
{ if aff_rank = n, set has 2^n - 1 elements, (n choose d+1) in dim d
for 0 \le d \le n-1. }
set fund_facets(SimpleAffine affd) = [[Facet]]:
    let n = affd.aff_rank, Sv = affd.aff_simple_coroots
    then listn = #n
    in
    for d:n
    do for S in choices_from(listn,d+1)
       do Facet:
       ( { pos  } for j in S do Sv[j] od
       , { zero } for k in complement(n,S) do Sv[k] od
       )
       od
    od

{.d-dimensional facets in the fundamental alcove.}
{ if aff_rank = n, set has (n choose d+1) elements }
set fund_facets(SimpleAffine affd,int d) = [Facet]:
    let n = affd.aff_rank, Sv = affd.aff_simple_coroots
    then listn = #n
    in
    for S in choices_from(listn,d+1)
    do Facet:
    ( { pos  } for j in S do Sv[j] od
    , { zero } for k in complement(n,S) do Sv[k] od
    )
    od

{.barycenters of facets in fundamental alcove, organized by dimension.}
set fund_barycenters(SimpleAffine affd) = [[FacetBary]]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd)
    then listn = #n
    in
    for d:n
    do for S in choices_from(listn,d+1)
       do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
       od
    od

{.barycenters of d-dimensional facets in the fundamental alcove.}
set fund_barycenters(SimpleAffine affd, int d) = [FacetBary]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd) in
    for S in choices_from(#n,d+1)
    do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
    od

{.barycenters and vertices of facets in fundamental alcove, organized by dimension.}
set fund_barycenters_verts(SimpleAffine Affd) = [[FacetBaryVerts]]:
    let  n = Affd.aff_rank, fundverts = fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for d:n do for S in choices_from(listn,d+1)
    	       do [sum(Affd.rank, for j in S do fundverts[j] od)/(d+1)] ##
	       	  for j in S do fundverts[j] od
	       od
	    od


{ a common denominator for all barycenters of facets }
set Bdenom(SimpleAffine affd) = int:
    for list in fund_barycenters(affd)
    do for fb in list do denom(fb) od.lcm
    od.lcm

{ barycenter numerators of facets in the fundamental alcove, organized by
dimension; actual barycenters are these divided by Bdenom(Affd) }
set fund_barycenters_numer(SimpleAffine Affd) = [[vec]]:
    let  n = Affd.aff_rank, LAB = Affd.labels, BDENOM = Bdenom(Affd),
    	 fundverts = fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for d:n
    	do for S in choices_from(listn,d+1)
	   do ratvec_as_vec(BDENOM*sum(Affd.rank, for j in S do fundverts[j] od)/(d+1))
	   od
	od

{ vertex sets for facets in the fundamental alcove, organized by
dimension }

set fund_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for d:n
    	do for S in choices_from(listn,d+1)
	   do for j in S
	      do Verts[j]
	      od
	   od
	od

set fund_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
    let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for S in choices_from(listn,d+1)
    	do for j in S do Verts[j] od
	od

{ vertex set numerators for facets in the fundamental alcove, organized by
dimension; actual are these divided by denom(Affd) }

set fund_vertex_sets_numer(SimpleAffine Affd) = [[[vec]]]:
    let  n = Affd.aff_rank, Verts_numer=fundamental_vertices_numer(Affd)
    then listn = for j:n do j od
    in
    for d:n
    	do for S in choices_from(listn,d+1)
	   do for j in S do Verts_numer[j] od
	   od
	od

{ integral weights to be added to gamma to land in fundamental
parallelepiped where all simple coroots take values in [0,1] }
{need to make a list of all possible tau; if g is an integer, use
either -g or -g+1.}

set FPtau(SimpleAffine Affd, ratvec gamma) = [ratvec]:
    let g=for j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od
    then INT = ##for j:#Affd.simple_coroots
    	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od
    in
    for S in power_set(#INT)
    do
    sum(Affd.rank, for j:#Affd.simple_coroots
    		   do -floor(g[j])*Affd.fundamental_weights[j] od) +
    sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od)
    od

{ sums of roots to be added to gamma to land in FPP }
set FPtauRoots(SimpleAffine Affd, ratvec gamma) = [vec]:
    let g=for j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od
    then INT = ##for j:#Affd.simple_coroots
    	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od
    in
    for S in power_set(#INT)
    do
    let tau = sum(Affd.rank, for j:#Affd.simple_coroots
    	      do -floor(g[j])*Affd.fundamental_weights[j] od) +
    	   sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od)
    in
    if(all(
	for j:Affd.ss_rank
	do is_integer((Affd.fundamental_coweights[j])*tau) od))
    then [ratvec_as_vec(tau)]
    else []
    fi
    od.##

{ numerators; to get actual values, divide by denom(Affd) }
set FPtau_numer(SimpleAffine Affd, ratvec gamma) = [vec]: let g=for
j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od, DENOM =
denom(Affd) then FW_numer = for v in Affd.fundamental_weights do
ratvec_as_vec(DENOM*v) od  then INT =
##for j:#Affd.simple_coroots do if =g[j]%DENOM then [j] else []
fi od in for S in power_set(#INT) do sum(for j:#Affd.simple_coroots do
-floor(g[j]/DENOM)*FW_numer[j] od) + if =#S then null(Affd.rank) else
sum(for j in S do FW_numer[INT[j]] od) fi od

{ numerators; to get actual values, divide by denom(Affd) }
set FPtau_numer_int(SimpleAffine Affd, vec gamma) = [vec]: let g= vec:
for j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od, DENOM =
denom(Affd) then FW_numer = for v in Affd.fundamental_weights do
ratvec_as_vec(DENOM*v) od  then INT {list of integral simple coroot
nrs} = ##for j:#Affd.simple_coroots do if =g[j]%DENOM then [j] else []
fi od in for S in power_set(#INT) do sum(for j:#Affd.simple_coroots do
-floor(g[j]/DENOM)*FW_numer[j] od) + if =#S then null(Affd.rank) else
sum(for j in S do FW_numer[INT[j]] od) fi od

{ Bnumerators; to get actual values, divide by Bdenom(Affd) }
set FPtau_Bnumer(SimpleAffine Affd, ratvec gamma) = [vec]: let g=for
j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od, DENOM =
Bdenom(Affd)  then INT =
##for j:#Affd.simple_coroots do if is_integer(g[j]) then [j] else []
fi od in for S in power_set(#INT) do ratvec_as_vec(DENOM*(sum(Affd.rank, for
j:#Affd.simple_coroots do -floor(g[j])*Affd.fundamental_weights[j]
od) + sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od))) od

{ Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove: subtract roots until gamma lands in W*A0 =
set where gamma1 is at most one on every coroot.  Precisely,
gamma - tau(gamma) is in W*(fundamental alcove).

Uses mostly integer arithmetic. First make simple root
coords smaller than 1. }

set TAU(RootDatum rd,ratvec gamma) = vec:
    let COROOTS = rd.coroots, ROOTS = rd.roots, gamma0NUM=gamma.numer,
    	DENOM = gamma.denom, m0= 0, q0=0 then d=#COROOTS
    in
    if d!=0
    then for j:#rd.fundamental_coweights
    do
    let (num,den) = (rd.fundamental_coweights[j].numer,
    	rd.fundamental_coweights[j].denom)
    in
    gamma0NUM := (gamma0NUM -
    ( ( ( num*gamma0NUM )\(DENOM*den))*DENOM*den)*rd.simple_roots[j])
    od;
    while (m0:=max_loc(for j:d do COROOTS[d-j-1]*gamma0NUM od);
    	  (q0:= COROOTS[d-m0-1]*gamma0NUM; q0 > DENOM))
    do
    gamma0NUM:= gamma0NUM - ceil(q0/(2*DENOM))*DENOM*ROOTS[d-m0-1]
    od
    fi;
    (gamma-gamma0NUM/DENOM).ratvec_as_vec

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) =
    (AffineCoWeylElt,ratvec):
    let tau = TAU(rd,gamma)
    then (w,gamma0TIMESDEN) = from_dominant(rd,gamma.numer - gamma.denom*tau)
    in
    {assert (gamma=w*gamma0 + tau,"Bad affine!");}
    ((tau,w),gamma0TIMESDEN/gamma.denom)

set facet_verts(SimpleAffine Affd, ratvec gamma) = FacetVerts:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in wtilde*facet_verts0(Affd,gamma0)

{.same as facet_verts_index using a precreated ParamPol as index set, starting with barycenter; or in fact any point of the facet.}
set facet_verts_index(SimpleAffine Affd, ParamPol Index, FacetBary gamma) =
    FacetVertsIndex:
    for gammav in facet_verts(Affd, gamma) do find(Index,gammav) od.sort

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }

set facet(SimpleAffine Affd, ratvec gamma) = Facet:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    then (F0pos,F0zero) = facet0(Affd,gamma0)
    in (for betav in F0pos do wtilde*betav od ,
       for betav in F0zero do wtilde*betav od)

{ computes the FacetBary of any ratvec }

set facet_bary(SimpleAffine Affd, ratvec gamma) = FacetBary:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in	wtilde*facet_bary0(Affd,gamma0)

{ computes the FacetVerts (vertex set) of any ratvec }

set facet_bary_verts(SimpleAffine Affd, ratvec gamma) = FacetBaryVerts:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in wtilde*facet_bary_verts0(Affd,gamma0)

{ calculates the number of vertices in W*(fundamental alcove }
set W_fund_vertices_card(SimpleAffine Affd) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    1+sum(for S in choices_from(listn,n-2) do rat_as_int(N/#W(Levi(Affd,S))) od )

{ cardinality of W_fund_vertices[d] }
set W_fund_d_facets_card(SimpleAffine Affd,int d) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    if d=n
    then N
    else sum(for T in choices_from(listn,n-d) do rat_as_int(N/#W(Levi(Affd,T))) od) +
    	 sum(for S in choices_from(listn,n-d-1) do rat_as_int(N/#W(Levi(Affd,S))) od)
    fi

{ cardinalities of all elts of W_fund_vertices }
set W_fund_facets_card(SimpleAffine Affd) = [int]:
    for d:Affd.aff_rank
    	do W_fund_d_facets_card(Affd,d)
	od

{ vertices in W*(fundamental alcove) }
set W_fund_verticesOLD(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    	do for w in stabiliser_quotient_of_dominant(Affd,gamma.numer)
	   do w*gamma od
	od.##

set W_fund_vertices2nd(SimpleAffine Affd) = [ratvec]:
    let GC=Affd.complexification, r=Affd.rank, Rho = Affd.rho
    then shift = Bdenom(Affd)*Rho, rhoCtilde=Rho##(-Rho)
    in
    for gamma in fundamental_vertices(Affd)
     	do let gammaC = shift##(gamma.numer)
	in
	    for p in block_of(parameter(GC,0,gammaC+rhoCtilde,gammaC))
	    	do let (,v) = p.LKT in ratvec: for j:r
	      	   do (v[j+r] + v[j] - shift[j])/gamma.denom
	      	   od
	   	od
	od.##

set W_fund_vertices(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do
    for gammawn in Weyl_orbit(Affd,gamma.numer)
    	do gammawn/gamma.denom od
    od.##

{.integrally dominant vertices.}
set W_fund_verticesID(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do
    for gammawn in Weyl_orbit(Affd,gamma.numer)
    	do
	if is_integrally_dominant(Affd,gammawn/gamma.denom)
	then [gammawn/gamma.denom]
	else []
	fi
	od.##
    od.##

{ vertex numers in W*(fundamental alcove); for actuals divide by denom(Affd) }
set W_fund_vertices_numer(SimpleAffine Affd) = [vec]:
    for gamma in fundamental_vertices_numer(Affd)
    	do for w in stabiliser_quotient_of_dominant(Affd,gamma)
	   do w*gamma od
	od.##

{ barycenters in W*(fundamental alcove), organized by dimension }
set W_fund_barycentersOLD(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    	do if facet_verbose
	   then prints("start dim ",d," in W_fund_barycentersOLD.")
	   fi;
	for gamma in fund_barycenters(Affd)[d]
	    do for w in stabiliser_quotient_of_dominant(Affd,gamma.numer)
	       do w*gamma od
	    od.##
	od

{ barycenters of d-dimensional facets in W*(fundamental alcove) }
set W_fund_barycentersOLD(SimpleAffine Affd,int d) = [FacetBary]:
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycentersOLD.")
    fi;
    for gamma in fund_barycenters(Affd)[d]
    	do for w in stabiliser_quotient_of_dominant(Affd,gamma.numer)
	   do w*gamma od
	od.##

{.barycenters in W*(fundamental alcove), organized by dimension.}
{ Compute W orbits using block_of command in GC. The shift
BDenom(Affd) is required to exceed the pairing of gamma.numer with any
coroot.}
set W_fund_barycenters2nd(SimpleAffine Affd) = [[FacetBary]]:
    let GC=Affd.complexification, r=Affd.rank, shift = Bdenom(Affd)*Affd.rho
    then rhoCtilde = Affd.rho##(-Affd.rho)
    in
    for d:Affd.aff_rank
       do
       if facet_verbose
       then prints("start dim ",d," in W_fund_barycenters2nd.")
       fi;
       for gamma in fund_barycenters(Affd)[d]
           do for p in block_of(parameter(GC,0,(shift##gamma.numer) + rhoCtilde,
	      shift##gamma.numer))
	      do let (,v) = p.LKT
	       	  in
	       	  ratvec: for j:r do (v[j+r] + v[j] - shift[j])/gamma.denom od
	       od
	    od.##
       od

{.same using Weyl_orbit.}
set W_fund_barycenters(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycenters.")
    fi;
           	for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    	   do gammawn/gamma0.denom
	    	   od
		od.##
	od

set W_fund_barycenters(SimpleAffine Affd) = [[FacetBary]]:
    let GC=Affd.complexification, r=Affd.rank, shift = Bdenom(Affd)*Affd.rho
    then rhoCtilde = Affd.rho##(-Affd.rho)
    in
    for d:Affd.aff_rank
       do
       if facet_verbose
       then prints("start dim ",d," in W_fund_barycenters.")
       fi;
           	for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    	   do gammawn/gamma0.denom
	    	   od
		od.##
	od

set W_fund_barycentersID(SimpleAffine Affd) = [[FacetBary]]:
    let GC=Affd.complexification, r=Affd.rank, shift = Bdenom(Affd)*Affd.rho
    then rhoCtilde = Affd.rho##(-Affd.rho)
    in
    for d:Affd.aff_rank
       do
       if facet_verbose
       then prints("start dim ",d," in W_fund_barycentersID.")
       fi;
           	for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
			do
			if is_integrally_dominant(Affd,gammawn/gamma0.denom)
	    		then [gammawn/gamma0.denom]
	    		else []
	    		fi
			od.##
		od.##
	od

{.barycenters of d-dimensional facets in W*(fundamental alcove).}
{Compute W orbits using block_of command in GC. The shift
BDenom(Affd) is required to exceed the pairing of gamma.numer with any
coroot.}
set W_fund_barycenters2nd(SimpleAffine Affd, int d) = [FacetBary]:
	let GC=Affd.complexification, r=Affd.rank, shift = Bdenom(Affd)*Affd.rho
    	then rhoC = GC.rho
    	in
    	if facet_verbose
    	then prints("start dim ",d," in W_fund_barycenters.")
    	fi;
    	for gamma in fund_barycenters(Affd)[d]
    	    do for p in block_of(parameter(GC,0,shift##gamma.numer, shift##gamma.numer))
	       do let (,v) = p.LKT in ratvec:
	       	  for j:r do (v[j+r] + v[j] - shift[j])/gamma.denom od
	       od
	    od.##

set W_fund_barycenters(SimpleAffine Affd, int d) = [FacetBary]:
    	if facet_verbose
    	then prints("start dim ",d," in W_fund_barycentersW.")
    	fi;
    	for gamma0 in fund_barycenters(Affd)[d]
	do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    do gammawn/gamma0.denom
	    od
	od.##

{ to get everything in the FPP, should use only _integrally dominant_ gammaw in WA0.}
set W_fund_barycentersID(SimpleAffine Affd, int d) = [FacetBary]:
    	if facet_verbose
    	then prints("start dim ",d," in W_fund_barycentersW.")
    	fi;
    	for gamma0 in fund_barycenters(Affd)[d]
	do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    do
	    if is_integrally_dominant(Affd,gammawn/gamma0.denom)
	    then [gammawn/gamma0.denom]
	    else []
	    fi
	    od.##
	od.##


{ barycenter numers in W*(fundamental alcove), organized by dimension }
set W_fund_barycenters_numer(SimpleAffine Affd) = [[vec]]:
for d:Affd.aff_rank do{DIM}
if facet_verbose then prints("start dim ",d,
" in W_fund_barycenters_numer.") fi;
## for gamma in fund_barycenters_numer(Affd)[d]
do{BIN} for w in stabiliser_quotient_of_dominant(Affd,gamma)
do{W} w*gamma od{W} od{BIN} od{DIM}

{.vertex sets for facets in W*(fundamental alcove), organized by dimension.}
set W_fund_vertex_setsOLD(SimpleAffine Affd) = [[FacetVerts]]:
    let n=Affd.aff_rank, Verts = fundamental_vertices(Affd) then
    listn=for j:n do j od
    in
    for d:n
    	do
	if facet_verbose
	then prints("start dim ",d," in W_fund_vertex_setsOLD.")
	fi;
	for S in choices_from(listn,d+1)
	    do for w in stabiliser_quotient_of_dominant(Affd,
	    ratvec_as_vec(sum(Affd.rank,for j in S do Verts[j].numer od)))
	       do for j in S do  w*Verts[j] od
	       od
	    od.##
	od

{.barycenters and vertices in W*(fundamental alcove), organized by dimension.}
{ Compute W orbits using block_of command in GC. The shift
BDenom(Affd) is required to exceed the pairing of gamma.numer with any
coroot. Extract Weyl group element from p.x and apply it to vertices.}
set W_fund_barycenters_verts2nd(SimpleAffine Affd) = [[FacetBaryVerts]]:
    let GC=Affd.complexification, r=Affd.rank, shift = Bdenom(Affd)*Affd.rho,
    	BaryVerts = fund_barycenters_verts(Affd)
    then rhoCtilde = Affd.rho##(-Affd.rho), listn = for j:Affd.aff_rank do j od
    in
    for d:Affd.aff_rank
       do
       if facet_verbose
       then prints("start dim ",d," in W_fund_barycenters_verts.")
       fi;
       for BV in BaryVerts[d]
           do for p in block_of(parameter(GC,0,shift##(BV[0].numer) + rhoCtilde,
	      shift##(BV[0].numer)))
	      do let INV = p.x.involution then inv = mat:
	      	 for i:r do for j:r do INV[j,i+r] od od
	       	 in inv*BV
	      od
	    od.##
	od
{.same using Weyl_orbit.}
set W_fund_barycenters_vertsID(SimpleAffine Affd) = [[FacetBaryVerts]]:
    let BaryVerts0 = fund_barycenters_verts(Affd)
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycenters_vertsID.")
    fi;
    for BV in BaryVerts0[d]
    	do let D = BV[0].denom
	   in for gammawn in Weyl_orbit(Affd,BV[0].numer)
	   do let gammaw=gammawn/D
	   in
	   if(is_integrally_dominant(Affd,gammaw))
	   then let (w,) = from_dominant(Affd,gammaw)
	   in [w*BV]
	   else []
	   fi
	   od.##
    	od.##
    od


{.vertex sets for all facets in W*(fundamental alcove).}
{ Compute W orbits using block_of command in GC. The shift
BDenom(Affd) is required to exceed the pairing of gamma.numer with any
coroot.}
set W_fund_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    let WFBC = W_fund_barycentersID(Affd)
    in
    for d:Affd.aff_rank
        do
        if facet_verbose
        then prints("start dim ",d," in W_fund_vertex_sets.")
        fi;
        for gamma in WFBC[d]
            do let (w,gamma0) = from_dominant(Affd,gamma)
	    in
	    w*facet_verts0(Affd,gamma0)
	    od
	 od

{ vertex sets for d-dimensional facets in W*(fundamental alcove) }
set W_fund_vertex_setsOLD(SimpleAffine Affd, int d) = [FacetVerts]:
let n=Affd.aff_rank, Verts = fundamental_vertices(Affd) then listn=for
j:n do j od in
if facet_verbose then prints("start dim ",d," in W_fund_vertex_sets.")
fi;
## for S in choices_from(listn,d+1) do{BIN} for w in
stabiliser_quotient_of_dominant(Affd, ratvec_as_vec(sum(Affd.rank,for
j in S do{VERTS}
Verts[j].numer od{VERTS}))) do{W} for j in S do{VERTS} w*Verts[j]
od{VERTS} od{W} od{BIN}

{ vertex set numers for facets in W*(fundamental alcove), organized by
dimension; for actuals divide by denom(Affd)}
set W_fund_vertex_sets_numer(SimpleAffine Affd) = [[[vec]]]:
let n=Affd.aff_rank, Verts_numer = fundamental_vertices_numer(Affd)
then listn=for j:n do j od in for d:n do{DIM}
if facet_verbose then prints("start dim ",d,
" in W_fund_vertex_sets_numer.") fi;
## for S in choices_from(listn,d+1) do{BIN} for w in
stabiliser_quotient_of_dominant(Affd, sum(for j in S do{VERTS}
Verts_numer[j] od{VERTS})) do{W}
for j in S do{VERTS} w*Verts_numer[j] od{VERTS} od{W} od{BIN} od{DIM}

{.this includes all vertex sets of facets in the fundamental
parallelepiped, each exactly once.}
set FPP_vertices(SimpleAffine Affd) = [ratvec]:
    if facet_verbose then prints("start FPP_vertices.")
    fi;
    for gamma in W_fund_verticesID(Affd)
    do
    for tau in FPtauRoots(Affd,gamma)
        do gamma+tau od
    od.##

{ this includes all vertices of facets in the fundamental
parallelepiped, each exactly once}
set FPP_vertices2nd(SimpleAffine Affd) = [ratvec]:
    if facet_verbose then prints("start FPP_vertices2nd.")
    fi;
    let GI = root_datum(null(Affd.rank,0), null(Affd.rank,0),true).split_form
    in
    for p in monomials(
    	sum(GI, for gamma in W_fund_vertices(Affd)
		do sum(GI, for tau in FPtau(Affd,gamma)
		   do parameter(GI,0,GI.rho,gamma+tau) od)
		od)
			)
    do p.nu
    od

set FPP_verticesOLD(SimpleAffine Affd) = [ratvec]:
if facet_verbose then prints("start FPP_vertices.") fi;
let GI = root_datum(null(Affd.rank,0),
null(Affd.rank,0),true).split_form
in for p in monomials(sum(GI, for gamma in W_fund_verticesOLD(Affd)
do{WA0} sum(GI, for tau in FPtauRoots(Affd,gamma) do{TAU}
parameter(GI,0,GI.rho,gamma+tau) od{TAU}) od{WA0})) do p.nu od


set FPP_barycenters2nd(SimpleAffine Affd) = [[FacetBary]]:
    if facet_verbose then prints("start FPP_barycenters2nd.")
    fi;
    let WBs = W_fund_barycenters(Affd), GI = root_datum(null(Affd.rank,0),
    	null(Affd.rank,0),true).split_form
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_barycenters2nd.")
    fi;
	for p in monomials(
    	sum(GI, for gamma in WBs[d]
		do
		sum(GI, for tau in FPtauRoots(Affd,gamma)
		   	   do parameter(GI,0,GI.rho,gamma+tau)
			   od)
		od))
    	do p.nu
    	od
    od


set FPP_barycenters(SimpleAffine Affd) = [[FacetBary]]:
    if facet_verbose then prints("start FPP_barycenters.")
    fi;
    let WBs = W_fund_barycentersID(Affd), GI = root_datum(null(Affd.rank,0),
    	null(Affd.rank,0),true).split_form
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_barycenters.")
    fi;
    for gamma in WBs[d]
    	do
    	for tau in FPtauRoots(Affd,gamma)
	    do gamma+tau od
    	od.##
     od

{.vertex list for FPP and list of vertices of all facets in FPP.}
set FPP_vlist_indices(SimpleAffine Affd) = ([ratvec],[[FacetVertsIndex]]):
    if facet_verbose then prints("start FPP_vlist_indices.")
    fi;
    let WBs = W_fund_barycentersID(Affd)
    then VERTS = for gamma in WBs[0]
    	do
	for tau in FPtauRoots(Affd,gamma) do gamma+tau od
	od.##
    then Index = index(VERTS)
    in (VERTS,
    [for v@j in VERTS do vec: [j] od] ##
    for d:Affd.aff_rank - 1 from 1
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_vlist_indices.")
    fi;
    for gamma in WBs[d]
    	do
    	for tau in FPtauRoots(Affd,gamma)
	    do
	    let v = gamma+tau
	    in facet_verts_index(Affd,Index,v)
	    od
    	od.##
     od)

{.all (facet barycenter, facet vertices) for facets in FPP, each once.}
set FPP_barycenters_verts(SimpleAffine Affd) = [[FacetBaryVerts]]:
    if facet_verbose then prints("start FPP_barycenters_verts.")
    fi;
    let WBVsID = W_fund_barycenters_vertsID(Affd)
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_barycenters_verts.")
    fi;
    for BV in WBVsID[d]
        do
		for tau in FPtauRoots(Affd,BV[0])
    		do
		for v in BV do v+tau od
    		od
	od.##
    od

{ convert a FacetVerts to a FacetBary }
set facet_bary(FacetVerts facet) = ratvec:
let n = #facet[0], D = #facet in sum(n, facet)/D


set FPP_vertex_sets3rd(SimpleAffine Affd) = [[FacetVerts]]:
if facet_verbose then prints("start FPP_vertex_sets3rd") fi;
let FPPBs = FPP_barycenters(Affd) in for d:Affd.aff_rank do{DIM}
if facet_verbose then prints("start dim ",d," in FPP_vertex_sets.") fi;
for b in FPPBs[d] do{FAC} facet_verts(Affd,b) od{FAC} od{DIM}



set FPP_vertex_sets2nd(SimpleAffine Affd) = [[FacetVerts]]:
if facet_verbose then prints("start FPP_vertex_sets2nd") fi;
let FPPBs = FPP_barycenters(Affd) in for d:Affd.aff_rank do{DIM}
if facet_verbose then prints("start dim ",d," in FPP_vertex_sets2nd.") fi;
for b in FPPBs[d] do{FAC} facet_verts(Affd,b) od{FAC} od{DIM}

set FPP_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    if facet_verbose
    then prints("start FPP_vertex_sets")
    fi;
    let FPPBVs = FPP_barycenters_verts(Affd)
    in for d:Affd.aff_rank
    do{DIM}
    if facet_verbose
    then prints("start dim ",d," in FPP_vertex_sets.")
    fi;
    for b in FPPBVs[d]
    	do{FAC} for j:#b-1 from 1 do b[j] od
	od{FAC}
    od{DIM}

{ computes barycenter from a facet as a vertex list }
set facet_bary([ratvec] vert_list, FacetVertsIndex facet) = FacetBary:
    sum(#vert_list[0], for k:#facet do vert_list[facet[k]] od)/(#facet) 

set FPP_vertex_sets_indicesOLD(SimpleAffine Affd) = [[FacetVertsIndex]]:
    let FPPV = FPP_vertex_sets(Affd) then vertexIndex=index(##FPPV[0])
    in for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_vertex_sets_indices")
    fi;
    for facet in FPPV[d]
    	do facet_verts_index(vertexIndex,facet)
	od
    od

set FPP_vertex_sets_indicesMVL(SimpleAffine Affd, [[FacetBary]] FPPBs) =
    [[FacetVertsIndex]]:
    let vertexIndex=index(FPPBs[0])
    in for d:#FPPBs
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_vertex_sets_indices([[FacetBary]])")
    fi;
    for v in FPPBs[d]
    	do facet_verts_index(Affd, vertexIndex, v)
	od
    od

set FPP_vertex_sets_indices(SimpleAffine Affd, [[FacetBary]] FPPBs) =
    [[FacetVertsIndex]]:
    let vertexIndex=index(FPPBs[0])
    in for d:#FPPBs
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_vertex_sets_indices([[FacetBary]])")
    fi;
    for v in FPPBs[d]
    	do facet_verts_index(Affd, vertexIndex, v)
	od
    od


{ meant to record information about unitarity for all facets }
set facet_status([[ratvec]] FPPB) = [[string]]:
    for d:#FPPB do for j:#FPPB[d] do "?" od od

{ meant to record information about unitarity for all facets }
{now marks unipotent parameters as "T[number of dual nilpotent]"}
set facet_statusu(RealForm G,[[ratvec]] FPPB) = [[string]]:
    if not(is_split(G))
    then facet_status(FPPB)
    else
    let statusQuo = for d:#FPPB do for j:#FPPB[d] do "?" od od
    then orbsnu = [ratvec]: for O in G.dual.Springer_table.orbits do (O.H)/2 od
    then Uindex = index(orbsnu)
    then status0 = for j:#statusQuo[0]
    	 do let m = find(Uindex,FPPB[0][j])
	 in
    	 if m >= 0
	 then "T"##to_string(m)
	 else statusQuo[0][j]
	 fi
	 od
    in statusQuo[0] := status0;
    statusQuo
    fi

set facet_status([[vec]] FPPind) = [[string]]:
    for d:#FPPind do for j:#FPPind[d] do "?" od od


set show([[string]] status) = void:
    for d:#status
    do
    let (countTu, countTto, countT, countF, countQ) = (0,0,0,0,0)
    in
	for j:#status[d]
	do
	if status[d][j]="T"
	then countT+:=1
	elif status[d][j]="F"
	then countF+:=1
	elif status[d][j]="?"
	then countQ+:=1
	elif status[d][j][1]="t"
	then countTto+:=1
	else countTu+:=1
	fi
	od;
	prints("Facet dimension ",d,": ", countTu, " unipotent, ",countT,
	" other unitary,  ", countTto, " unitary_to_ht, ",
	countF, " nonunitary, ", countQ, " undecided.")
    od

{dth coordinate is number of unsettled terms in status[d]}
set COUNT([[string]] status) = vec:
    for d:#status
    do
    #(for j:#status[d]
	do
	if (status[d][j]="?" or (#status[d][j] > 1 and status[d][j][1]="t")) then [true]
	else []
	fi
	od.##)
     od


{ meant to get the facets for spherical not cohom induced in
nonquasisplit G }

set pick_not_cohom(RealForm G, [[FacetBary]] FPPB,
    [[FacetVertsIndex]] FPPind) = ([[FacetBary]],[[FacetVertsIndex]]):
    let inv=x_open(G).involution
    then tworhoM = G.rho + inv*G.rho
    then FPPBnc = [[ratvec]]:
    	 for d:#FPPB
	 do for j:#FPPB[d]
	    do
	    if inv*FPPB[d][j] + FPPB[d][j] = tworhoM
	    then [FPPB[d][j]]
	    else []
	    fi
	    od.##
	 od,
	 FPPindnc = [[vec]]:
	    for d:#FPPind
	    do for j:#FPPind[d]
	       do
	       if inv*FPPB[d][j] + FPPB[d][j] = tworhoM
	       then [FPPind[d][j]]
	       else []
	       fi
	       od.##
	  od
    in (FPPBnc,FPPindnc)

{this eliminates the nonhermitian facets from the lists. Would be good
also to organize the new lists by dimension of the hermitian part,
which is d-(# unfixed vertices)/2.}
set pick_hermitian(RealForm G, [[FacetBary]] FPPB,
    [[FacetVertsIndex]] FPPind) = ([[ratvec]],[[FacetVertsIndex]]):
    let FPPBh = [[FacetBary]]:
    	for d:#FPPB
	do
		for j:#FPPB[d]
		do
		if is_hermitian(parameter(x_open(G),G.rho,FPPB[d][j]))
		then [FPPB[d][j]]
		else []
		fi
		od.##
    	od,
	FPPindh = [[vec]]:
    	for d:#FPPind
   	 do
		for j:#FPPind[d]
    	 	do
    		if is_hermitian(parameter(x_open(G),G.rho,FPPB[d][j]))
		then [FPPind[d][j]]
		else []
		fi
		od.##
	od
    in (FPPBh,FPPindh)

{ Need simple derived group }
set spherical(RealForm G, [ratvec] vlist, [[FacetVertsIndex]] FPPind) =
    ([[string]],[ratvec],[[FacetVertsIndex]]):
    let FPPB = for d:G.aff_rank
    	do{DIM}
		for j:#FPPind[d]
		do{FAC}
		facet_bary(vlist, FPPind[d][j])
		od{FAC}
	od{DIM}
    then (FPPBnc,FPPindnc) = pick_not_cohom(G,FPPB,FPPind)
    then (FPPBnch, FPPindnch) = pick_hermitian(G,FPPBnc,FPPindnc)
    then status = [[string]]: facet_statusu(G,FPPBnch)
    in

    for d:#status
    	do{DIMd}
	if facet_verbose
	then prints(); show(status); prints("start dim ",d,
	     " in spherical(G,vlist,FPPind); testing ",COUNT(status)[d]," parameters.")
	fi;
	let nsd = status[d], COUNTd = int: 0, GOALd = int: COUNT(status)[d]
	in
		for j:#status[d]
		do{FACd}
		let result =
		if{RES} nsd[j]="F" or nsd[j]="T" or (#nsd[j]>1 and nsd[1] !="t")
		then nsd[j]
		else if facet_verbose
		     then if COUNTd% (1+GOALd\10) = 0 then prints("started test #",COUNTd)
		     	  fi; COUNTd:=COUNTd+1
		     fi;
			if{NEWU}(is_unitary(first_param(
				standardize(parameter(
					x_open(G), G.rho, FPPBnch[d][j])))))
			then nsd[j]:="T"
			else{NEWU}
				for e: #status-d-1 from d+1
				do{DIMe}
				let nse=status[e]
				in for k:#nse
				   do{FACe}
				   if{SUB} is_subset_of_sorted(
				   	   FPPindnch[e][k])(FPPindnch[d][j])
				   then nse[k]:= "F"
				   fi{SUB}
				   od{FACe};
				status[e]:=nse
				od{DIMe};
			nsd[j]:="F"
			fi{NEWU}
		fi{RES}
		in result
		od{FACd};
		status[d]:=nsd
	od{DIMd};
prints(); show(status); (status,vlist,FPPindnch)

{ Meant to be applied to (G,output of spherical_to_h). Need simple
 derived group }
set spherical(RealForm G, ([[string]] status, [ratvec] vlist,
    [[FacetVertsIndex]] FPPind)) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let FPPB = for d:G.aff_rank
    do{DIM}
    for j:#FPPind[d]
    	do{FAC}
	facet_bary(vlist, FPPind[d][j])
	od{FAC}
	    od{DIM}
    	    in
    	    for d:#status
    	    do{DIMd}
    	    if facet_verbose
    	    then prints("start dim ",d, " in spherical(G,status,vlist,FPPind)")
    	    fi;
    	    let nsd = status[d]
    	    in
    	    if facet_verbose
    	    then prints(); show(status)
    	    fi;
    	    for j:#status[d]
    	    	do{FACd}
    		let result =
    		if{RES} nsd[j]="F" or nsd[j]="T" or (#nsd[j]>1 and nsd[1] !="t")
    		then nsd[j]
    		else
		if{NEWU} (is_unitary(first_param(standardize(
			 parameter(x_open(G), G.rho, FPPB[d][j])))))
		then nsd[j]:="T"
		else{NEWU}
		for e: #status-d-1 from d+1
		    do{DIMe}
		    let nse=status[e]
		    in
		    for k:#nse
	    	    	do{FACe}
	    		if{SUB} is_subset_of_sorted(FPPind[e][k])(FPPind[d][j])
	    		then nse[k]:= "F"
	    		fi{SUB}
	    		od{FACe};
		    status[e]:=nse
		    od{DIMe};
		nsd[j]:="F"
		fi{NEWU}
    		fi{RES}
    	in result
    	od{FACd};
    status[d]:=nsd
    od{DIMd};
    prints(); show(status); (status,vlist,FPPind)

{ in output, "F" is certain, "Tto[bound]" means "true to height=bound" }
set spherical_to_ht(RealForm G, [ratvec] vlist, [[FacetVertsIndex]] FPPind,
    int bound) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let FPPB = for d:G.aff_rank
    do
    for j:#FPPind[d]
    	do facet_bary(vlist, FPPind[d][j]) od
    od
    then (FPPBnc,FPPindnc) = pick_not_cohom(G,FPPB,FPPind)
    then (FPPBnch, FPPindnch) = pick_hermitian(G,FPPBnc,FPPindnc)
    then status = facet_statusu(G,FPPBnch)
    in for d:#status
    do
    if facet_verbose then prints("start dim ",d,
       " in spherical_to_ht(G,vlist,FPPind,",bound,")")
    fi;
    let nsd = status[d]
    in
    if facet_verbose
    then prints(); show(status)
    fi;
    for j:#status[d]
    do
    let result =
    	if nsd[j] = "F" or nsd[j]="T" or (#nsd[j]>1 and nsd[j][1] !="t")
	then nsd[j]
	else
		if (is_unitary_to_ht(first_param(
			 standardize(parameter(x_open(G), G.rho,
			 		FPPBnch[d][j]))),bound))
		then nsd[j]:="Tto"##to_string(bound)
		else for e: #status-d-1 from d+1
		do
		let nse=status[e]
		in for k:#nse
		   do
		   if is_subset_of_sorted(FPPindnch[e][k])(FPPindnch[d][j])
		   then nse[k]:= "F"
		   fi
		   od;
		status[e]:=nse
		od;
		nsd[j]:="F"
		fi
	fi
	in result
    od;
    status[d]:=nsd
    od;
    prints();
    show(status);
    (status,vlist,FPPindnch)

{ to be applied to result of a previous to_ht computation; FPPind is assumed
already to be cut to not cohom and hermitian }
set spherical_to_ht(RealForm G, ([[string]] status, [ratvec] vlist,
    [[FacetVertsIndex]] FPPind), int bound) =
    ([[string]],[ratvec],[[FacetVertsIndex]]):
    let FPPB = for d:G.aff_rank
    	do
	for j:#FPPind[d]
	    do
	    facet_bary(vlist, FPPind[d][j])
	    od
	od
    in
    for d:#status
    do
    if facet_verbose
    then prints("start dim ",d," in spherical(G,status,vlist,FPPind)")
    fi;
    let nsd = status[d]
    in
    if facet_verbose
    then prints(); show(status)
    fi;
    for j:#status[d]
    	do
	let result =
	    if nsd[j]="F" or nsd[j]="T" or (#nsd[j]>1 and nsd[j][1] !="t")
	    then nsd[j]
	    else
	    	 if (is_unitary_to_ht(first_param(
		 	  standardize(parameter(x_open(G), G.rho,
			  FPPB[d][j]))),bound))
		 then nsd[j]:="Tto"##to_string(bound)
		 else for e: #status-d-1 from d+1
		 do
		 let nse=status[e]
		 in for k:#nse
		    do
		    if is_subset_of_sorted(FPPind[e][k])(FPPind[d][j])
		    then nse[k]:= "F"
		    fi
		    od;
		    status[e]:=nse
		 od;
		 nsd[j]:="F"
		 fi
	    fi
	in result
	od;
	status[d]:=nsd
    od;
    prints(); show(status);
    (status,vlist,FPPind)

{ still need simple derived group }
{need vlist to match FPP_vertex_sets_indices}
set spherical(RealForm G) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let (vlist,FPPVI) = FPP_vlist_indices(G)
    in spherical(G,vlist,FPPVI)

set sphericalOLD(RealForm G) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let vlist = FPP_vertices(G)
    in spherical(G,vlist,FPP_vertex_sets_indicesOLD(G))

set sphericalMVL(RealForm G) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let FPPBs = FPP_barycenters(G)
    then FPPVI = FPP_vertex_sets_indices(G,FPPBs)
    in spherical(G,FPPBs[0],FPPVI)

set spherical_to_ht(RealForm G, int bound) =
    ([[string]],[ratvec],[[FacetVertsIndex]]):
    let (vlist,FPPVI) = FPP_vlist_indices(G)
    in spherical_to_ht(G, vlist, FPPVI,bound)

set update_status([[string]] status, [ratvec] vlist,
    [[FacetVertsIndex]] Cand) = ([[string]], [ratvec], [[FacetVertsIndex]]):
    let newCand = for d:#status
    	do assert(#Cand[d] = #status[d],
	"size mismatch between status and Cand");
	for j:#status[d]
	    do
	    if status[d][j] = "F"
	    then []
	    else [Cand[d][j]]
	    fi
	    od.##
	 od,
	 newstatus = for d:#status
	 	do
			##for j:#status[d]
			do
			if status[d][j] = "F"
			then []
			else [status[d][j]]
			fi
			od
		od

	in (newstatus,vlist,newCand)

{idea is in a session to say
  >> FILENAME write(status,vlist,Cand)

Then in another session you can write
<< FILENAME
set STN=spherical_to_ht(G,(status,vlist,Cand),N)}

set write([[string]] status, [ratvec] vlist, [[FacetVertsIndex]] Cand) = void:
    prints("set status = ",status);
    prints("set vlist = ",vlist);
    prints("set Cand = [[vec]]:",Cand)
