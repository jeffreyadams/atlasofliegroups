<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]) }
<hermitian.at { for is_unitary }

{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])}

{ Just do this for SIMPLE root datum rd.}

{ at the end is a function "spherical" which (if G has simple derived
group) might return which facets correspond to non-cohomologically
induced spherical principal series. Haven't proven this. }

{ One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell) }

{ There are three notions of "facet": a set Facet of affine equalities
and inequalities defining it (NOT UNIQUE); the set FacetV of vertices;
and the barycenter FacetB. I like FacetV the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) bu looking at all
enlargements of the vertex set. Passage from FacetV to FacetB is
trivial (average the vertices) There are functions facet, facetV and
facetB at the end which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{ remove repetitions }
set NoReps([ratvec] list) = ## for j:#list do if all(for i:j do
list[i] != list [j] od) then [list[j]] else [] fi od

{ remove repetitions from a list of SORTED vectors }
set NoReps([vec] list) = ## for j:#list do if all(for i:j do
list[i] != list [j] od) then [list[j]] else [] fi od

{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum

set aff_rank(SimpleAffine Affd) = ss_rank(Affd) + 1

set_type AffineCoroot = (vec,int)
set *(AffineCoroot (betav,m), ratvec gamma) = m+betav*gamma

{first apply w, then translate by tau}
set_type AffineCoWeylElt = (vec tau, WeylElt w)

set *(AffineCoWeylElt (tau,w) , vec gamma) = w*gamma + tau
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = w*gamma + tau
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = (w1*tau2 +
tau1, w1*w2)
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
(betav*inverse(w), m-(betav*inverse(w))*tau)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
(-inverse(w)*tau, inverse(w))

set aff_simple_coroots(SimpleAffine Affd) = [AffineCoroot]:
for j:Affd.aff_rank do
if j=0 then (-coroot(Affd, highest_short_root(Affd)),1) else
(Affd.simple_coroots[j-1],0) fi od

{compute facet of a point in fundamental alcove, where all positive
roots are in [0,1]}

set labels(SimpleAffine Affd) = [int]:
for j:Affd.aff_rank do
if j=0 then 1 else rat_as_int(Affd.fundamental_weights[j-1] *
coroot(Affd, highest_short_root(Affd))) fi od

set root(AffineCoroot (betav,m),SimpleAffine Affd) = root(Affd,betav)

set *(AffineCoroot (betav,m), vec v) = betav*v + m


set reflection(AffineCoroot Betav, SimpleAffine Affd, vec v) = v -
(Betav*v)*root(Betav,Affd)

set reflection(AffineCoroot Betav, SimpleAffine Affd, ratvec v) =
reflection(Betav, Affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot inequalities and (n-k) AffineCoRoot equalities. The total
collection of affine coroots appearing must be a set of simple roots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE }

set_type Facet = ([AffineCoroot] pos,[AffineCoroot] zero)

{ a UNIQUE characterization of a k-diml facet is as a set of
k+1 vertices }

set_type FacetV = [ratvec]

{ Maybe the smallest UNIQUE characterization is as the barycenter }

set_type FacetB = ratvec

{ computes the Facet of a point gamma0 in the fundamental alcove }
set facet0(SimpleAffine Affd, ratvec gamma0) = Facet:
let S=Affd.aff_simple_coroots in (##for j:Affd.aff_rank do if S[j]*gamma0 != 0
then [S[j]] else [] fi od, ##for j:Affd.aff_rank do if S[j]*gamma0 = 0
then [S[j]] else [] fi od)
set aff_simple_roots(SimpleAffine Affd) = for j:Affd.aff_rank do
if j=0 then -highest_short_root(Affd) else
Affd.simple_roots[j-1] fi od

{ vertices of fundamental alcove }
set fundamental_vertices(SimpleAffine Affd) = [ratvec]:
for j:Affd.aff_rank do 
if j=0 then null(Affd.rank)/1 else
Affd.fundamental_weights[j-1]/Affd.labels[j] fi od

{ computes the FacetV of a point gamma0 in the fundamental alcove }
set facetV0(SimpleAffine Affd, ratvec gamma0) = FacetV:
let S=Affd.aff_simple_coroots, V=fundamental_vertices(Affd) in
##for d:#S do if !=S[d]*gamma0 then [V[d]] else [] fi od

{ computes the FacetB of a point gamma0 in the fundamental alcove }
set facetB0(SimpleAffine Affd, ratvec gamma0) = FacetB:
let Verts = facetV0(Affd,gamma0) in sum(Affd.rank, for v in Verts do v/#Verts
od)

{ list of facets in the fundamental alcove, organized by dimension }
set fund_facets(SimpleAffine Affd) = [[Facet]]:
let n = Affd.aff_rank, Sv = Affd.aff_simple_coroots
then listn = for j:n do j od {, P = power_set(n)} in
for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN} (for j in S
do{TRMSA} Sv[j] od{TRMSA}, for k in complement(n,S) do{TRMSB} Sv[k]
od{TRMSB}) od{BIN} od{DIM}

{ for i:2^n-1 from 1 do (for j in P[i] do Sv[j] od, for
k in complement(n,P[i]) do Sv[k] od) od }

{ barycenters of facets in the fundamental alcove, organized by
dimension }
set fund_barycenters(SimpleAffine Affd) = [[FacetB]]:
let  n = Affd.aff_rank, LAB = Affd.labels,
FWts=Affd.fundamental_weights then listn = for j:n do j od
in for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN} 
sum(Affd.rank, for j in S do{VERT} if j=0 then null(Affd.rank)/1 else
FWts[j-1]/((d+1)*LAB[j]) fi od{VERT}) od{BIN} od{DIM}

{ vertex sets for facets in the fundamental alcove, organized by
dimension }

set fund_vertex_sets(SimpleAffine Affd) = [[FacetV]]:
let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
then listn = for j:n do{DIM} j od
in for d:n do{DIM} for S in choices_from(listn,d+1) do{BIN}
for j in S do{VERTS} Verts[j] od{VERTS} od{BIN} od{DIM}

{ vertices in W*(fundamental alcove) }
set W_fund_vertices(SimpleAffine Affd) = [ratvec]:
## for gamma in fundamental_vertices(Affd) do{VERT} for w in
stabiliser_quotient_of_dominant(Affd,gamma.numer) do{W} w*gamma od{W} od{VERT}

{ barycenters in W*(fundamental alcove), organized by dimension }
set W_fund_barycenters(SimpleAffine Affd) = [[FacetB]]:
for d:Affd.aff_rank do{DIM} ## for gamma in fund_barycenters(Affd)[d]
do{BIN} for w in stabiliser_quotient_of_dominant(Affd,gamma.numer)
do{W} w*gamma od{W} od{BIN} od{DIM}

{ vertex sets for facets in W*(fundamental alcove), organized by
dimension }
set W_fund_vertex_sets(SimpleAffine Affd) = [[FacetV]]:
let n=Affd.aff_rank, Verts = fundamental_vertices(Affd) then listn=for
j:n do j od in
for d:n do{DIM} ## for S in choices_from(listn,d+1) do{BIN} for w in
stabiliser_quotient_of_dominant(Affd, ratvec_as_vec(sum(Affd.rank,for
j in S do{VERTS}
Verts[j].numer od{VERTS}))) do{W} for j in S do{VERTS} w*Verts[j]
od{VERTS} od{W} od{BIN} od{DIM}

{ integral weights to be added to gamma to land in fundamental
parallelepiped where all simple coroots take values in [0,1] }
{need to make a list of all possible tau; if g is an integer, use
either -g or -g+1.}

set FPtau(SimpleAffine Affd, ratvec gamma) = [ratvec]: let g=for
j:#Affd.simple_coroots do Affd.simple_coroots[j]*gamma od then INT =
##for j:#Affd.simple_coroots do if is_integer(g[j]) then [j] else []
fi od in for S in power_set(#INT) do sum(Affd.rank, for
j:#Affd.simple_coroots do -floor(g[j])*Affd.fundamental_weights[j]
od) + sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od) od

{ this includes all vertices of facets in the fundamental
parallelepiped, with repetitions }
set FPP_vertices_rep(SimpleAffine Affd) = [ratvec]:
## for gamma in W_fund_vertices(Affd)
do{WA0} for tau in FPtau(Affd,gamma) do{TAU} gamma+tau od{TAU} od{WA0}

{ this eliminates repetition }
set FPP_vertices(SimpleAffine Affd) = [ratvec]:
NoReps(FPP_vertices_rep(Affd))

{ this includes all barycenters of facets in the fundamental
parallelepiped, organized by dimension, with repetitions }
set FPP_barycenters_rep(SimpleAffine Affd) = [[FacetB]]:
let WBs = W_fund_barycenters(Affd) in for d:Affd.aff_rank do{DIM} ##
for gamma in WBs[d] do{WA0} for tau in FPtau(Affd,gamma) do{TAU}
gamma+tau od{TAU} od{WA0} od{DIM}

{ this eliminates repetition in vertices only }
set FPP_barycenters0(SimpleAffine Affd) = [[FacetB]]:
let FPPBs = FPP_barycenters_rep(Affd) in for d:Affd.aff_rank do{DIM}
if d= 0 then NoReps(FPPBs[0]) else FPPBs[d] fi od{DIM} 

{ this eliminates repetition }
set FPP_barycenters(SimpleAffine Affd) = [[FacetB]]:
let FPPBs = FPP_barycenters_rep(Affd) in for d:Affd.aff_rank do{DIM} let
longList = FPPBs[d] in ##for j:#longList do{LIST} if all(for i:j
do{SRCH} longList[i] != longList[j] od{SRCH}) then [longList[j]] else
[] fi od{LIST} od{DIM}

{ convert a FacetV to a FacetB }
set facetB(FacetV facet) = ratvec:
let n = #facet[0], d = #facet in sum(n, facet)/(d+1)

{ vertex sets for all facets in the fundamental parallelepiped,
organized by dimension, with some repetitions }
set FPP_vertex_sets_rep(SimpleAffine Affd) = [[FacetV]]:
let WVs = W_fund_vertex_sets(Affd) in for d:Affd.aff_rank do{DIM}
##for gammas in WVs[d] do{WA0} for tau in FPtau(Affd, facetB(gammas))
do{TAU} for gamma in gammas do{GAM}
gamma+tau od{GAM} od{TAU} od{WA0} od{DIM}

{ this eliminates repetition in the vertices only }
set FPP_vertex_sets0(SimpleAffine Affd) = [[FacetV]]:
let FPPVs = FPP_vertex_sets_rep(Affd) in for d:Affd.aff_rank do{DIM}
if d=0 then (let longList = FPPVs[0] in ##(for j:#longList do{LIST} if
all(for i:j do{SRCH} longList[i][0] != longList[j][0]
od{SRCH}) then [longList[j]] else [] fi od{LIST})) else FPPVs[d] fi od{DIM}

{ this eliminates repetition }
set FPP_vertex_sets(SimpleAffine Affd) = [[FacetV]]:
let FPPVs = FPP_vertex_sets_rep(Affd) in for d:Affd.aff_rank do{DIM}
let longList = FPPVs[d] in ##for j:#longList do{LIST} if all(for i:j
do{SRCH} sum(Affd.rank,longList[i]) != sum(Affd.rank,longList[j])
od{SRCH}) then [longList[j]] else [] fi od{LIST} od{DIM}

{ computes vertex list as indices in a pre-computed vertex list }

set_type FacetVI = vec

set facetVnum([ratvec] vert_list, FacetV facet) =
FacetVI:
for gammav in facet do find(vert_list,gammav) od.sort

{ computes barycenter from a facet as a vertex list }
set facetB([ratvec] vert_list, FacetVI facet) = FacetB:
sum(#vert_list[0], for k:#facet do vert_list[facet[k]] od)/(#facet) 

set FPP_vertex_sets_indices(SimpleAffine Affd,[ratvec] vertex_list) =
[[FacetVI]]:
let FPPV = FPP_vertex_sets(Affd) in for d:Affd.aff_rank do
if d=0 then for j:#FPPV[0] do [j] od else
for facet_V in FPPV[d] do facetVnum(vertex_list,facet_V) od fi od

set FPP_vertex_sets_indices(SimpleAffine Affd) = [[FacetVI]]:
let FPPV = FPP_vertex_sets(Affd) then vertex_list = ##FPPV[0]
in for d:Affd.aff_rank do if d=0 then for j:#FPPV[0] do [j] od else
for facet_V in FPPV[d] do facetVnum(vertex_list,facet_V) od fi od

set FPP_vertex_sets_indices0(SimpleAffine Affd) = [[vec]]:
let FPPV = FPP_vertex_sets0(Affd) then vertex_list = ##FPPV[0]
in for d:Affd.aff_rank do if d=0 then for j:#vertex_list do [j] od else
for facet_V in FPPV[d] do facetVnum(vertex_list,facet_V) od fi od

{ Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove: subtract roots until gamma lands in W*A0 =
set where gamma1 is at most one on every coroot.  Precisely,
gamma - tau(gamma) is in W*(fundamental alcove).

Uses mostly integer arithmetic. First make simple root
coords smaller than 1. }

set TAU(RootDatum rd,ratvec gamma) = vec:
let COROOTS = rd.coroots, ROOTS = rd.roots, gamma0NUM=gamma.numer,
DENOM = gamma.denom, m0= 0, q0=0 then d=#COROOTS in if d!=0
then for j:#rd.fundamental_coweights do let (num,den) =
(rd.fundamental_coweights[j].numer, rd.fundamental_coweights[j].denom) in
gamma0NUM := (gamma0NUM -
( ( ( num*gamma0NUM )\(DENOM*den))*DENOM*den)*rd.simple_roots[j]) od;
while (m0:=max_loc(for j:d do COROOTS[d-j-1]*gamma0NUM od); (q0:=
COROOTS[d-m0-1]*gamma0NUM; q0 > DENOM)) do gamma0NUM:= gamma0NUM -
ceil(q0/(2*DENOM))*DENOM*ROOTS[d-m0-1] od fi;
(gamma-gamma0NUM/DENOM).ratvec_as_vec

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) = (AffineCoWeylElt,
ratvec): let tau = TAU(rd,gamma) then (w,gamma0TIMESDEN) = from_dominant
(rd,gamma.numer - gamma.denom*tau) in
{assert (gamma=w*gamma0 + tau,"Bad affine!");}
((tau,w),gamma0TIMESDEN/gamma.denom)

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }

set facet(SimpleAffine Affd, ratvec gamma) = Facet:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) then
(F0pos,F0zero) = facet0(Affd,gamma0) in (for betav in F0pos
do wtilde*betav od , for betav in F0zero
do wtilde*betav od)

{ computes the FacetB of any ratvec }

set facetB(SimpleAffine Affd, ratvec gamma) = FacetB:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) in
wtilde*facetB0(Affd,gamma0) 

{ computes the FacetV (vertex set) of any ratvec }

set facetV(SimpleAffine Affd, ratvec gamma) = FacetV:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) then
Verts = facetV0(Affd,gamma0) in for gamma0v in Verts
do wtilde*gamma0v od

{ meant to record information about unitarity for all facets }
set facet_status([[ratvec]] FPPB) = [[string]]:
for d:#FPPB do for j:#FPPB[d] do "?" od od

set show([[string]] status) = void:
for d:#status do let (countT,countF,countQ) = (0,0,0) in for
j:#status[d] do if status[d][j]="T" then countT+:=1 elif
status[d][j]="F" then countF+:=1 else countQ+:=1 fi od; 
prints("Facet dimension ",d,": ", countT, " unitary, ",
countF, " nonunitary, ", countQ, " undecided.") od

{ meant to get the facets for spherical not cohom induced in
nonquasisplit G }

set pick_not_cohom(RealForm G, [[ratvec]] FPPB, [[vec]] FPPind) =
([[ratvec]],[[vec]]):
let inv=x_open(G).involution then tworhoM = G.rho + inv*G.rho
then FPPBnc = [[ratvec]]: for d:#FPPB do ##for j:#FPPB[d] do
if inv*FPPB[d][j] + FPPB[d][j] = tworhoM then [FPPB[d][j]]
else [] fi od od,
FPPindnc = [[vec]]: for d:#FPPind do ##for j:#FPPind[d] do
if inv*FPPB[d][j] + FPPB[d][j] = tworhoM then
[FPPind[d][j]] else [] fi od od in (FPPBnc,FPPindnc)

{this eliminates the nonhermitian facets from the lists. Would be good
also to organize the new lists by dimension of the hermitian part,
which is d-(# unfixed vertices)/2.}
set pick_hermitian(RealForm G, [[ratvec]] FPPB, [[vec]] FPPind) =
([[ratvec]],[[vec]]):
let FPPBh = [[ratvec]]: for d:#FPPB do ##for j:#FPPB[d] do if
is_hermitian(parameter(x_open(G),G.rho,FPPB[d][j])) then [FPPB[d][j]]
else [] fi od od,
FPPindh = [[vec]]: for d:#FPPind do ##for j:#FPPind[d] do
if is_hermitian(parameter(x_open(G),G.rho,FPPB[d][j])) then
[FPPind[d][j]] else [] fi od od in (FPPBh,FPPindh)

{ Need simple derived group }
set spherical(RealForm G, [ratvec] vlist, [[vec]] FPPind) =
[[string]]:
let FPPB = for d:G.aff_rank do{DIM} for j:#FPPind[d] do{FAC}
facetB(vlist, FPPind[d][j]) od{FAC} od{DIM} then
(FPPBnc,FPPindnc) = pick_not_cohom(G,FPPB,FPPind) then
(FPPBnch, FPPindnch) = pick_hermitian(G,FPPBnc,FPPindnc)
then status = facet_status(FPPBnch) in for d:#status do{DIMd} let nsd
= status[d] in prints(); show(status);
for j:#status[d] do{FACd} let result = if{RES}
nsd[j]!="?" then nsd[j]
else if{NEWU}
(is_unitary(first_param(standardize(parameter(x_open(G), G.rho,
FPPBnch[d][j])))))
then nsd[j]:="T" else{NEWU} for e: #status-d-1 from d+1 do{DIMe} let
nse=status[e] in for k:#nse do{FACe} if{SUB}
is_subset_of_sorted(FPPindnch[e][k])(FPPindnch[d][j])
then nse[k]:= "F" fi{SUB} od{FACe}; status[e]:=nse od{DIMe};
nsd[j]:="F" fi{NEWU} fi{RES} in result od{FACd}; status[d]:=nsd
od{DIMd};
prints(); show(status); status

{ still need simple derived group }
set spherical(RealForm G) = [[string]]:
spherical(G,FPP_vertices(G),FPP_vertex_sets_indices(G))

set spherical0(RealForm G) = [[string]]:
spherical(G,FPP_vertices(G),FPP_vertex_sets_indices0(G))
