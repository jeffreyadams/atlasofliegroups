<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]) }
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<TWOHEIGHTS.at { for HT, HTT, HTA }
<springer_tables_reductive.at { for Springer_table }

{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])}

{ Just do this for root datum rd with simple derived datum.}

{ at the end is a function "spherical" which (if G has simple derived
group) might return which facets correspond to non-cohomologically
induced spherical principal series. Haven't proven this. }

{ One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell) }

{ There are four notions of "facet":
1) a ([AffineCoroot],[AffineCoroot]) Facet of affine inequalities and
equalities defining it (NOT UNIQUE);
2) the [ratvec] FacetVerts of vertices;
3) the ratvec FacetBary, the barycenter of the facet; and
4) the [vec] FacetVertsIndex of indices of the vertices in a fixed list of vertices

I like FacetVerts the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) bu looking at all
enlargements of the vertex set. Passage from FacetVerts to FacetBary is
trivial (average the vertices) There are functions facet, facetVerts and
facetBary which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{ORGANIZATION: Main functions are spherical@RealForm and
spherical_to_ht@(RealForm,int), defined around line 1070.

Here is a brief outline. Following Barbasch and Steve
Miller, calculate things related to the FUNDAMENTAL PARALLELEPIPED
FPP, which lies in the R-span of the roots, where all simple coroots
take values in [0,1]. The FPP is partitioned into facets of various
dimensions from 0 to the semisimple rank. Each d-dimensional facet is
determined by its barycenter (a ratvec) or by its vertices (a list of
d+1 ratvecs). The idea for computing all facets in the FPP is to
compute a list vlist of all vertices in the FPP (done by
FPP_vertices@RootDatum); then for each d-dimensional facet to store a
rank d+1 vec giving the indices of the vertices in vlist (done by
FPP_vertex_sets_indices).

What's needed to get going is a list of all barycenters of facets in
the FPP. These are calculated by

Theorem. Every [barycenter of a facet] gamma (not just in FPP) can be
written as w*gamma0 + tau, with gamma0 unique [barycenter of a facet]
in the fundamental alcove, w in W (finite Weyl group), and tau in the
root lattice. If we require

   w*gamma0 is integrally dominant

then w*gamma0 is unique, and so tau is unique.

There are 2^{semisimple rank - 1} facet barycenters gamma0 in the
fundamental alcove.; not too many. Marc kindly provided a very fast
listing of the W-orbits W*gamma0. Picking out the integrally dominant
ones is now done stupidly in functions with names like
W_fund_barycentersID: stupid in the sense that it would have been
cleverer to sort out the integrally dominant terms in the library.  }

{ useful to assign this to 'true" to get information about the progress
of long calculations }
set facet_verbose=false

{.remove repetitions from list of ratvecs.}
set NoReps([ratvec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{.remove repetitions from a list of vecs.}
set NoReps([vec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum

set aff_rank(SimpleAffine Affd) = ss_rank(Affd) + 1

set_type AffineCoroot = (vec,int)

{.evaluate AffineCoroot at weight.}
set *(AffineCoroot (betav,m), vec gamma) = m+betav*gamma

{.evaluate AffineCoroot at rational weight.}
set *(AffineCoroot (betav,m), ratvec gamma) = m+betav*gamma

{.first apply w, then translate by tau.}
set_type AffineCoWeylElt = (vec tau, WeylElt w)

{.apply AffineCoWeylElt to weight.}
set *(AffineCoWeylElt (tau,w) , vec gamma) = w*gamma + tau
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = w*gamma + tau

{.compose AffineCoWeylElts.}
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = AffineCoWeylElt:
    (tau1 + w1*tau2, w1*w2)
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
    let bvw1=betav*inverse(w) in (bvw1, m-bvw1*tau)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
    let w1=inverse(w) in (-w1*tau,w1)

{.simple affine coroots: number 0 is affine, rest are simple for RootDatum.}
set aff_simple_coroots (SimpleAffine affd) = [AffineCoroot]:
    (-highest_root(dual(affd)),1) #
    for alpha_v in simple_coroots(affd) do (alpha_v,0) od

{.sum of simple affine coroots times their labels is (null(rank),1).}
set labels(SimpleAffine affd) = [int]:
    let a = coroot_index(affd,highest_root(dual(affd))) in
    1 # coroot_expression(affd,a)

{.a common denominator for all vertices of alcoves.}
set denom (SimpleAffine affd) = int:
    let lab = labels(affd), fwts=affd.fundamental_weights in
    for fw@j in fwts do denom(fw)*lab[j+1] od.lcm

{.root attached to an AffineCoroot.}
set root (AffineCoroot (betav,m),SimpleAffine affd) = root(affd,betav)

{.affine reflection through Affine coroot, applied to weight.}
set reflection(AffineCoroot Betav, SimpleAffine affd, vec v) = vec:
    v - root(Betav,affd)*(Betav*v)

set reflection(AffineCoroot Betav, SimpleAffine affd, ratvec v) = ratvec:
    reflection(Betav, affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot strict inequalities and (n-k) AffineCoRoot equalities.
The total collection of affine coroots appearing must be a set of simple coroots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE }

set_type [Facet = ([AffineCoroot] pos,[AffineCoroot] zero)]

{ a UNIQUE characterization of a k-diml facet is as a set of
k+1 vertices }

set_type FacetVerts = [ratvec]

{for d-dimensional facet, entry 0 is barycenter, 1 to d+1 are vertices}
set_type FacetBaryVerts = [ratvec]

set *(WeylElt w, FacetVerts FV) = FacetVerts:
    for v in FV do w*v od

set *(mat M, FacetVerts FV) = FacetVerts:
    for v in FV do M*v od

set *(AffineCoWeylElt wtilde, FacetVerts FV) = FacetVerts:
    for v in FV do wtilde*v od

{ Maybe the smallest UNIQUE characterization of a facet is the barycenter }
set_type FacetBary = ratvec

{represents a k-diml facet as k+1 indices into a list of vertices
(held elsewhere)}
set_type FacetVertsIndex = vec

set facet_verts_index([ratvec] vert_list, FacetVerts facet) = FacetVertsIndex:
    for gammav in facet do find(vert_list,gammav) od.sort

{ creates the indexing ParamPol }
{ this only works if the list elements are distinct! }
set index([ratvec] list) = ParamPol:
    let G1=root_datum(null(#list[0],0),null(#list[0],0),true).split_form
    in sum(G1,for v@j in list do (j+1)*parameter(G1,0,G1.rho,v) od)

set find(ParamPol Index,ratvec v) = int:
    let GI = Index.real_form 
    in
    split_as_int(Index[parameter(GI,0,GI.rho,v)]) - 1

{.finds the indices for example of all vertices in a facet.}
set find(ParamPol Index, [ratvec] FV) = vec:
    let GI = Index.real_form 
    in
    vec: for v in FV
    do split_as_int(Index[parameter(GI,0,GI.rho,v)]) - 1 
    od

{ same as facet_verts_index using a precreated ParamPol as index set }
set facet_verts_index(ParamPol Index, FacetVerts facet) = FacetVertsIndex:
for gammav in facet do find(Index,gammav) od.sort

{.computes the Facet of a point gamma0 in the fundamental alcove.}
set facet0(SimpleAffine Affd, ratvec gamma0) = Facet:
    let S=Affd.aff_simple_coroots in
    (for j:Affd.aff_rank
    do if S[j]*gamma0 != 0
       then [S[j]]
       else []
       fi
    od.##,
    for j:Affd.aff_rank
    do if S[j]*gamma0 = 0
       then [S[j]]
       else []
       fi
    od.##)

{.simple roots corresponding to simple affine coroots: number 0 is
affine,  rest are simple for RootDatum.}
set aff_simple_roots(SimpleAffine affd) = mat:
    (-highest_root(dual(affd))) # affd.simple_roots

{.vertices of the fundamental alcove.}
{ set has aff_rank elements }
set fundamental_vertices (SimpleAffine affd) = [ratvec]:
    (ratvec:null(affd.rank)) #
    (let labs=affd.labels[1:] in
     for lab@j in labs do fundamental_weight(affd,j)/lab od)

{.FacetVerts of a point gamma0 in the fundamental alcove.}
set facet_verts0(SimpleAffine affd, ratvec gamma0) = FacetVerts:
    let vert=fundamental_vertices(affd) in
    for coroot@d in affd.aff_simple_coroots
    do if =coroot*gamma0 then [] else [vert[d]] fi
    od.##

{.computes the FacetBary of a point gamma0 in the fundamental alcove.}
set facet_bary0(SimpleAffine affd, ratvec gamma0) = FacetBary:
    let verts = facet_verts0(affd,gamma0) then n=#verts in
    sum(affd.rank, for v in verts do v/n od)

{.barycenters of facets in fundamental alcove, organized by dimension.}
set fund_barycenters(SimpleAffine affd) = [[FacetBary]]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd)
    then listn = #n
    in
    for d:n
    do for S in choices_from(listn,d+1)
       do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
       od
    od

{.barycenters of d-dimensional facets in the fundamental alcove.}
set fund_barycenters(SimpleAffine affd, int d) = [FacetBary]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd) in
    for S in choices_from(#n,d+1)
    do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
    od

{ vertex sets for facets in the fundamental alcove, organized by
dimension }

set fund_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for d:n
    	do for S in choices_from(listn,d+1)
	   do for j in S
	      do Verts[j]
	      od
	   od
	od

set fund_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
    let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for S in choices_from(listn,d+1)
    	do for j in S do Verts[j] od
	od

{.barycenters and vertices of facets in fundamental alcove, organized by dimension.}
set fund_barycenters_verts(SimpleAffine Affd) = [[FacetBaryVerts]]:
    let  n = Affd.aff_rank, fundverts = fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for d:n do for S in choices_from(listn,d+1)
    	       do [sum(Affd.rank, for j in S do fundverts[j] od)/(d+1)] ##
	       	  for j in S do fundverts[j] od
	       od
	    od

set fund_barycenters_verts(SimpleAffine Affd, int d) = [FacetBaryVerts]:
    let  n = Affd.aff_rank, fundverts = fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for S in choices_from(listn,d+1)
    do [sum(Affd.rank, for j in S do fundverts[j] od)/(d+1)] ##
       for j in S do fundverts[j] od
    od


{.FacetBaryVerts of gamma0 in the fundamental alcove.}
set facet_bary_verts0(SimpleAffine Affd, ratvec gamma0) = FacetBaryVerts:
    let S=Affd.aff_simple_coroots, V=fundamental_vertices(Affd),
    	Verts=facet_verts0(Affd,gamma0)
    in
    [sum(Affd.rank, Verts)/#Verts]##Verts

{ integral weights to be added to gamma to land in fundamental
parallelepiped where all simple coroots take values in [0,1] }
{need to make a list of all possible tau; if g is an integer, use
either -g or -g+1.}

set FPtau(SimpleAffine Affd, ratvec gamma) = [ratvec]:
    let g=for betav in Affd.simple_coroots do betav*gamma od
    then INT = ##for j:#Affd.simple_coroots
    	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od
    in
    for S in power_set(#INT)
    do
    sum(Affd.rank, for xi@j in Affd.fundamental_weights
    		   do -floor(g[j])*xi od) +
    sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od)
    od

{ sums of roots to be added to gamma to land in FPP }
set FPtauRoots(SimpleAffine Affd, ratvec gamma) = [vec]:
    let g=for betav in Affd.simple_coroots do betav*gamma od
    then INT = ##for j:#Affd.simple_coroots
    	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od
    in
    for S in power_set(#INT)
    do
    let tau = sum(Affd.rank, for xi@j in Affd.fundamental_weights
    	      do -floor(g[j])*xi od) +
    	   sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od)
    in
    if(all(
	for xiv in Affd.fundamental_coweights
	do is_integer(xiv*tau) od))
    then [ratvec_as_vec(tau)]
    else []
    fi
    od.##

{ Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove: subtract roots until gamma lands in W*A0 =
set where gamma1 is at most one on every coroot.  Precisely,
gamma - tau(gamma) is in W*(fundamental alcove).

Uses mostly integer arithmetic. First make simple root
coords smaller than 1. }

set TAU(RootDatum rd,ratvec gamma) = vec:
    let COROOTS = rd.coroots, ROOTS = rd.roots, gamma0NUM=gamma.numer,
    	DENOM = gamma.denom, m0= 0, q0=0 then d=#COROOTS
    in
    if d!=0
    then for xiv@j in rd.fundamental_coweights
    do
    let (num,den) = (xiv.numer, xiv.denom)
    in
    gamma0NUM := (gamma0NUM -
    ( ( ( num*gamma0NUM )\(DENOM*den))*DENOM*den)*rd.simple_roots[j])
    od;
    while (m0:=max_loc(for j:d do COROOTS[d-j-1]*gamma0NUM od);
    	  (q0:= COROOTS[d-m0-1]*gamma0NUM; q0 > DENOM))
    do
    gamma0NUM:= gamma0NUM - ceil(q0/(2*DENOM))*DENOM*ROOTS[d-m0-1]
    od
    fi;
    (gamma-gamma0NUM/DENOM).ratvec_as_vec

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) =
    (AffineCoWeylElt,ratvec):
    let tau = TAU(rd,gamma)
    then (w,gamma0TIMESDEN) = from_dominant(rd,gamma.numer - gamma.denom*tau)
    in
    {assert (gamma=w*gamma0 + tau,"Bad affine!");}
    ((tau,w),gamma0TIMESDEN/gamma.denom)

{ computes the FacetVerts (vertex set) of any ratvec }
set facet_verts(SimpleAffine Affd, ratvec gamma) = FacetVerts:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in wtilde*facet_verts0(Affd,gamma0)

{.same as facet_verts_index using a precreated ParamPol as index set,
starting with barycenter; or in fact any point of the facet.} 
set facet_verts_index(SimpleAffine Affd, ParamPol Index, FacetBary gamma) =
    FacetVertsIndex:
    for gammav in facet_verts(Affd, gamma) do find(Index,gammav) od.sort

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }
set facet(SimpleAffine Affd, ratvec gamma) = Facet:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    then (F0pos,F0zero) = facet0(Affd,gamma0)
    in (for betav in F0pos do wtilde*betav od ,
       for betav in F0zero do wtilde*betav od)

{ computes the FacetBary of any ratvec }
set facet_bary(SimpleAffine Affd, ratvec gamma) = FacetBary:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in	wtilde*facet_bary0(Affd,gamma0)

{.number of vertices in W*(fundamental alcove).}
set W_fund_vertices_card(SimpleAffine Affd) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    1+sum(for S in choices_from(listn,n-2) do rat_as_int(N/#W(Levi(Affd,S))) od )

{.number of d-diml facets in W*(fundamental alcove).}
set W_fund_d_facets_card(SimpleAffine Affd,int d) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    if d=n
    then N
    else sum(for T in choices_from(listn,n-d) do rat_as_int(N/#W(Levi(Affd,T))) od) +
    	 sum(for S in choices_from(listn,n-d-1) do rat_as_int(N/#W(Levi(Affd,S))) od)
    fi

{.number of facets in W*(fundamental alcove).}
set W_fund_facets_card(SimpleAffine Affd) = [int]:
    for d:Affd.aff_rank
    	do W_fund_d_facets_card(Affd,d)
	od

set W_fund_vertices(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do
    for gammawn in Weyl_orbit(Affd,gamma.numer)
    	do gammawn/gamma.denom od
    od.##

{.integrally dominant vertices.}
set W_fund_verticesID(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do
    for gammawn in Weyl_orbit(Affd,gamma.numer)
    	do
	if is_integrally_dominant(Affd,gammawn/gamma.denom)
	then [gammawn/gamma.denom]
	else []
	fi
	od.##
    od.##

{.same using Weyl_orbit.}

set W_fund_barycenters(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycenters.")
    fi;
           	for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    	   do gammawn/gamma0.denom
	    	   od
		od.##
	od

set W_fund_barycentersID(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycentersID.")
    fi;
           	for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
		   do if is_integrally_dominant(Affd,gammawn/gamma0.denom)
    	    	   then [gammawn/gamma0.denom]
		   else[]
		   fi
		   od.##
	    	od.##
     od

set W_fund_barycenters(SimpleAffine Affd, int d) = [FacetBary]:
    	if facet_verbose
    	then prints("start dim ",d," in W_fund_barycentersW.")
    	fi;
    	for gamma0 in fund_barycenters(Affd)[d]
	do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    do gammawn/gamma0.denom
	    od
	od.##

{ to get everything in the FPP, should use only _integrally dominant_ gammaw in WA0.}
set W_fund_barycentersID(SimpleAffine Affd, int d) = [FacetBary]:
    	if facet_verbose
    	then prints("start W_fund_barycentersID(Affd, ",d,").")
    	fi;
    	for gamma0 in fund_barycenters(Affd)[d]
	do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    do
	    if is_integrally_dominant(Affd,gammawn/gamma0.denom)
	    then [gammawn/gamma0.denom]
	    else []
	    fi
	    od.##
	od.##

{.same using Weyl_orbit.}
set W_fund_barycenters_vertsID(SimpleAffine Affd) = [[FacetBaryVerts]]:
    let BaryVerts0 = fund_barycenters_verts(Affd)
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycenters_vertsID.")
    fi;
    for BV in BaryVerts0[d]
    	do let D = BV[0].denom
	   in for gammawn in Weyl_orbit(Affd,BV[0].numer)
	   do let gammaw=gammawn/D
	   in
	   if(is_integrally_dominant(Affd,gammaw))
	   then let (w,) = from_dominant(Affd,gammaw)
	   in [w*BV]
	   else []
	   fi
	   od.##
    	od.##
    od

{.vertex sets for all facets in W*(fundamental alcove).}
set W_fund_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    let WFBC = W_fund_barycenters(Affd)
    in
    for d:Affd.aff_rank
        do
        if facet_verbose
        then prints("start dim ",d," in W_fund_vertex_sets.")
        fi;
        for gamma in WFBC[d]
            do let (w,gamma0) = from_dominant(Affd,gamma)
	    in
	    w*facet_verts0(Affd,gamma0)
	    od
	 od

{.vertex sets for all d-facets in W*(fundamental alcove).}
set W_fund_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
    let WFBCd = W_fund_barycenters(Affd,d)
    in
    if facet_verbose
    then prints("start W_fund_vertex_sets(Affd,",d,").")
    fi;
    for gamma in WFBCd
    do let (w,gamma0) = from_dominant(Affd,gamma)
    in
    w*facet_verts0(Affd,gamma0)
    od

{.this includes all vertex sets of facets in the fundamental
parallelepiped, each exactly once.}
set FPP_verticesOLD(SimpleAffine Affd) = [ratvec]:
    if facet_verbose then prints("start FPP_vertices.")
    fi;
    for gamma in W_fund_verticesID(Affd)
    do
    for tau in FPtauRoots(Affd,gamma)
        do gamma+tau od
    od.##

{.this includes all vertex sets of facets in the fundamental
parallelepiped, each exactly once.}
set FPP_vertices(SimpleAffine Affd) = [ratvec]:
    if facet_verbose then prints("start FPP_vertices.")
    fi;
    for gamma in W_fund_verticesID(Affd)
    do
    for tau in FPtauRoots(Affd,gamma)
        do gamma+tau od
    od.##

set FPP_barycenters(SimpleAffine Affd) = [[FacetBary]]:
    if facet_verbose then prints("start FPP_barycenters.")
    fi;
    let WBs = W_fund_barycentersID(Affd), GI = root_datum(null(Affd.rank,0),
    	null(Affd.rank,0),true).split_form
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_barycenters.")
    fi;
    for gamma in WBs[d]
    	do
    	for tau in FPtauRoots(Affd,gamma)
	    do gamma+tau od
    	od.##
     od
     
{.all (facet barycenter, facet vertices) for facets in FPP, each once.}
set FPP_barycenters_verts(SimpleAffine Affd) = [[FacetBaryVerts]]:
    if facet_verbose then prints("start FPP_barycenters_verts.")
    fi;
    let WBVsID = W_fund_barycenters_vertsID(Affd)
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_barycenters_verts.")
    fi;
    for BV in WBVsID[d]
        do
		for tau in FPtauRoots(Affd,BV[0])
    		do
		for v in BV do v+tau od
    		od
	od.##
    od
{.throw away barycenters from FacetBaryVerts}
set FPP_vertex_sets([[FacetBaryVerts]] FPPBV) = [[FacetVerts]]:
    for d:#FPPBV
    do
    	if facet_verbose then prints("start dim ",d,
	   " in FPP_vertex_sets(FPPBV.")
    	fi;
	for j:#FPPBV[d]
	    do for k:d+1 from 1 do FPPBV[d][j][k] od od
    od

set FPP_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    if facet_verbose
    then prints("starting FPP_vertex_sets")
    fi;
    let FPPBs = FPP_barycenters(Affd)
    in
    for d:Affd.aff_rank
    do
    	if facet_verbose then prints("start dim ",d," in FPP_vertex_sets.")
    	fi;
    	for b in FPPBs[d]
    	do facet_verts(Affd,b) od
    od

{ computes barycenter from a facet as a vertex list }
set facet_bary([ratvec] vert_list, FacetVertsIndex facet) = FacetBary:
    sum(#vert_list[0], for k:#facet do vert_list[facet[k]] od)/(#facet) 

set FPP_vertex_sets_indices(SimpleAffine Affd, [[FacetBary]] FPPBs) =
    [[FacetVertsIndex]]:
    let vertexIndex=index(FPPBs[0])
    in for d:#FPPBs
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_vertex_sets_indices([[FacetBary]])")
    fi;
    for v in FPPBs[d]
    	do facet_verts_index(Affd, vertexIndex, v)
	od
    od

{.this uses many times the memory of the replacement; speed is same.}
set FPP_vlist_indicesOLD(SimpleAffine Affd) =
    ([ratvec],[[FacetVertsIndex]]):
    let FPPBVs=FPP_barycenters_verts(Affd)
    then vlist = [ratvec]: for FBV in FPPBVs[0] do FBV[0] od
    then vertexIndex=index(vlist)
    in
    (vlist,for d:#FPPBVs
    do
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_vlist_indicesOLD")
    fi;
    for FBV in FPPBVs[d]
    	do for j:d+1 from 1 do find(vertexIndex, FBV[j]) od
	od
    od)

set FPP_vlist_indices(SimpleAffine Affd) =
    ([ratvec],[[FacetVertsIndex]]):
    let vlist = [ratvec]: FPP_vertices(Affd),
    fundVerts = fund_vertex_sets(Affd)
    then vertexIndex=index(vlist), N= [vec]: for j:#vlist do [j] od
    in (vlist, [[vec]]: [N]##
    for d:Affd.ss_rank from 1
    do
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_vlist_indices")
    fi;
    for FV in fundVerts[d]
    do
    let FB=FacetBary: sum(Affd.rank,FV)/(d+1)
    then WBsID= [FacetBary]:
    	for wFBn in Weyl_orbit(Affd,FB.numer)
        do
        if is_integrally_dominant(Affd,wFBn/FB.denom)
        then [wFBn/FB.denom]
	else []
        fi
        od.##
    in [FacetVertsIndex]: for wFB in WBsID
       do
       let (w,) = from_dominant(Affd,wFB)
       in
	[vec]: for tau in FPtauRoots(Affd,wFB)
       	do
       	vec: find(vertexIndex, (tau,w)*FV)
       	od
       od.## { now type [vec] }
    od.##
    od)


set FPP_vlist_indices(SimpleAffine Affd, int d, ParamPol vertexIndex) =
    [FacetVertsIndex]:
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_vlist_indices")
    fi;
    for FBV in fund_barycenters_verts(Affd)[d]
    do
    let FB = FacetBary: FBV[0]
    then WBsID= [FacetBary]:
    	for wFBn in Weyl_orbit(Affd,FB.numer)
        do
        if is_integrally_dominant(Affd,wFBn/FB.denom)
        then [wFBn/FB.denom]
	else []
        fi
        od.##
    in [FacetVertsIndex]: for wFB in WBsID
       do
       let (w,) = from_dominant(Affd,wFB)
       in
	[vec]: for tau in FPtauRoots(Affd,wFB)
       	do
       	vec: find(vertexIndex, (tau,w)*(for j:d+1 from 1 do FBV[j] od) )
       	od
       od.## { now type [vec] }
    od.##

{ meant to record information about unitarity for all facets }
set facet_status([[ratvec]] FPPB) = [[string]]:
    for d:#FPPB do for j:#FPPB[d] do "?" od od

{ meant to record information about unitarity for all facets }
{now marks unipotent parameters as "T[number of dual nilpotent]"}
{I THINK that for a simple G, all unipotent parameters must be
barycenters of facets of dimension 0 or 1. Also I THINK that dimension
1 can only happen in type A?? So this could be simplified.}
set facet_statusu(RealForm G,[[ratvec]] FPPB) = [[string]]:
    if not(is_split(G))
    then facet_status(FPPB)
    else
    let statusQuo = for d:#FPPB do for j:#FPPB[d] do "?" od od
    then orbsnu = [ratvec]: for O in G.dual.Springer_table.orbits do (O.H)/2 od
    then Uindex = index(orbsnu)
    then status0 = for j:#statusQuo[0]
    	 do let m0 = find(Uindex,FPPB[0][j])
	 in
    	 if m0 >= 0
	 then "T"##to_string(m0)
	 else statusQuo[0][j]
	 fi
	 od
    then {if #status > 0 then } status1 = for FB@j in FPPB[1]
    	 do let m1 = find(Uindex,FB)
	 in
	 if m1 >= 0
	 then "T"##to_string(m1)
	 else statusQuo[1][j]
	 fi
	 od
	 {fi}
    in statusQuo[0] := status0; {if #status > 0 then} statusQuo[1] := status1 {fi};
    statusQuo
    fi

set facet_status([[vec]] FPPind) = [[string]]:
    for d:#FPPind do for j:#FPPind[d] do "?" od od


set show([[string]] status) = void:
    for d:#status
    do
    let (countTu, countTto, countTi, countT, countF, countFi, countQ) =
    	(0, 0, 0,0,0,0,0)
    in
	for j:#status[d]
	do
	if status[d][j]="T"
	then countT+:=1
	elif status[d][j]="F"
	then countF+:=1
	elif status[d][j]="?"
	then countQ+:=1
	elif status[d][j][1]="t"
	then countTto+:=1
	elif status[d][j][0]="T" and status[d][j][1]="i"
	then countTi+:=1
	elif status[d][j][1]="i"
	then countFi+:=1
	else countTu+:=1
	fi
	od;
	prints("Facet dimension ",d,": ", countTu, " unipotent, ",countTi,
	" unitarily induced, ",countT, " other unitary,  ", countTto,
	" unitary_to_ht", new_line, "       ",countFi,
	" induced nonunitarily, ",countF, " other nonunitary, ",
	countQ, " undecided.",new_line)
    od

{list of unsettled terms in statusd}
set COUNT([string] statusd) = vec:
    for str@j in statusd
    do
    if (str="?" or (#str > 1 and str[1]="t")) then [j]
    else []
    fi
    od.##

{dth coordinate is number of unsettled terms in status[d]}
set COUNT([[string]] status) = vec:
    for d:#status
    do
    #(for j:#status[d]
        do
        if (status[d][j]="?" or (#status[d][j] > 1 and status[d][j][1]="t")) then [true]
        else []
        fi
        od.##)
     od


{ meant to get the facets for spherical not cohom induced in
nonquasisplit G }

set pick_not_cohom(RealForm G, [[FacetBary]] FPPB,
    [[FacetVertsIndex]] FPPind) = ([[FacetBary]],[[FacetVertsIndex]]):
    let inv=x_open(G).involution
    then tworhoM = G.rho + inv*G.rho
    then FPPBnc = [[ratvec]]:
    	 for FPPBd in FPPB
	 do for FB in FPPBd
	    do
	    if (1+inv)*FB = tworhoM
	    then [FB]
	    else []
	    fi
	    od.##
	 od,
	 FPPindnc = [[vec]]:
	    for FPPBd@d in FPPB
	    do for FB@j in FPPBd
	       do
	       if (1+inv)*FB= tworhoM
	       then [FPPind[d][j]]
	       else []
	       fi
	       od.##
	  od
    in (FPPBnc,FPPindnc)

set pick_not_cohom(RealForm G, [[FacetBary]] FPPB) = [[FacetBary]]:
    let inv=x_open(G).involution
    then tworhoM = G.rho + inv*G.rho
    then FPPBnc = [[FacetBary]]:
    	 for FPPBd in FPPB
	 do for FB in FPPBd
	    do
	    if (inv+1)*FB = tworhoM
	    then [FB]
	    else []
	    fi
	    od.##
	 od
    in FPPBnc

{this eliminates the nonhermitian facets from the lists. Would be good
also to organize the new lists by dimension of the hermitian part,
which is d-(# unfixed vertices)/2.}
set pick_hermitian(RealForm G, [[FacetBary]] FPPB,
    [[FacetVertsIndex]] FPPind) = ([[ratvec]],[[FacetVertsIndex]]):
    let FPPBh = [[FacetBary]]:
    	for FPPBd in FPPB
	do
		for FB in FPPBd
		do
		if is_hermitian(parameter(x_open(G),G.rho,FB))
		then [FB]
		else []
		fi
		od.##
    	od,
	FPPindh = [[vec]]:
    	for FPPindd@d in FPPind
   	 do
		for Findd@j in FPPindd
    	 	do
    		if is_hermitian(parameter(x_open(G),G.rho,FPPB[d][j]))
		then [Findd]
		else []
		fi
		od.##
	od
    in (FPPBh,FPPindh)

set pick_hermitian(RealForm G, [[FacetBary]] FPPB) = [[FacetBary]]:
    let FPPBh = [[FacetBary]]:
    	for FPPBd in FPPB
	do
		for FB in FPPBd
		do
		if is_hermitian(parameter(x_open(G),G.rho,FB))
		then [FB]
		else []
		fi
		od.##
    	od
    in FPPBh

{. The next family of functions all need simple derived group. Always vlist should be ALL vertices in the FPP. The facet lists carried by [[FacetBary]] or [[FacetVertsIndex]] may be pruned of reps not interesting for unitarity, but the indices will alway refer to a constant vlist.}

{.eliiminate nonfinal, nonhermitian parameters.}
set down_to_business(RealForm G, ([ratvec] vlist, [[FacetVertsIndex]] FPPind)) =
    ([[string]],[ratvec],[[FacetVertsIndex]]):
        let FPPB = for d:G.aff_rank
    	do
		for j:#FPPind[d]
		do
		facet_bary(vlist, FPPind[d][j])
		od
	od

    then (FPPBnc,FPPindnc) = pick_not_cohom(G,FPPB,FPPind)
    then (FPPBnch,FPPindnch) = pick_hermitian(G,FPPBnc,FPPindnc)
    then status = [[string]]: facet_statusu(G,FPPBnch)
    in
    if facet_verbose then prints("completing down_to_business"); show(status) fi;
    (status,vlist,FPPindnch)

{.eliiminate nonfinal, nonhermitian parameters for COMPLEX G.}
set down_to_businessC(RealForm G, ([ratvec] vlistL,
    [[FacetVertsIndex]] FPPindL)) = 
    ([[string]],[ratvec],[[FacetVertsIndex]]):
	let GL=simple_factors(G)[0]
	then w0L = GL.w0
        then FPPBL = [[FacetBary]]:
	for FPPindLd in FPPindL
    	do
		for FindL in FPPindLd
		do
		facet_bary(vlistL, FindL)
		od
	od
	then FPPBnch = [[FacetBary]]:
	for FPPBLd in FPPBL
	do
		for FB in FPPBLd
		do
		if w0L*FB = -FB then [FB] else [] fi
		od.##
	od
	then FPPindnch = [[FacetVertsIndex]]:
	for FPPindLd@d in FPPindL
	do
		for Find@j in FPPindLd
		do
		if w0L*FPPBL[d][j] = -FPPBL[d][j] then [Find] else [] fi
		od.##
	od
    	then status = [[string]]: facet_statusu(GL.split_form,FPPBnch)
    	in
    	if facet_verbose then prints("completing down_to_businessC"); show(status) fi;
    	(status, vlistL, FPPindnch)

{.eliiminate nonfinal, nonhermitian parameters.}
set down_to_business_bary(RealForm G, ([ratvec] vlist, [[FacetBary]] FPPB)) =
    ([[string]],[ratvec],[[FacetBary]]):
    let Index = index(vlist)
    then FPPind = for d:G.aff_rank
    	do
		for j:#FPPB[d]
		do
		facet_verts_index(G,Index, FPPB[d][j])
		od
	od
    then(FPPBnc,FPPindnc) = pick_not_cohom(G,FPPB,FPPind)
    then (FPPBnch,FPPindnch) = pick_hermitian(G,FPPBnc,FPPindnc)
    then status = [[string]]: facet_statusu(G,FPPBnch)
    in
    if facet_verbose then prints("completing down_to_business"); show(status) fi;
    (status,vlist,FPPBnch)

{ Meant to be applied to output of down_to_business (with nonhermitian eliminated). Need simple
 derived group }
set spherical(RealForm G, ([[string]] status, [ratvec] vlist,
    [[FacetVertsIndex]] FPPind)) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    for d:#status
    	do{DIMd}
	let nsd = status[d]
	then TODOd = COUNT(nsd)
	then TODOBd = for j in TODOd do facet_bary(vlist, FPPind[d][j]) od, GOALd = #TODOd;
	if facet_verbose
	then show(status); prints(); prints("start dim ",d,
	     " in spherical(G,status,vlist,FPPind); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
    		let result =
    		    if facet_verbose
		     then if k <=10 or k% (1+{GOALd}#TODOd\10) = 0
 		     	  then prints("started test #",k," of ",{GOALd}#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary(first_param(standardize(
			 parameter(x_open(G), G.rho, TODOBd[k])))))
		then nsd[j]:="T"
		else{NEWU}
		for e: #status-d-1 from d+1
		    do{DIMe}
		    let nse=status[e]
		    then TODOe = COUNT(nse)
		    in
		    for l in TODOe
	    	    	do{FACe}
	    		if{SUB} is_subset_of_sorted(FPPind[e][l])(FPPind[d][j])
	    		then nse[l]:= "F"
	    		fi{SUB}
	    		od{FACe};
		    status[e]:=nse
		    od{DIMe};
		nsd[j]:="F"
		fi{NEWU}
    	in result
    	od{FACd};
    status[d]:=nsd
    od{DIMd};
    if(facet_verbose) then show(status) fi;
    (status,vlist,FPPind)

set sphericalC(RealForm G, ([[string]] status, [ratvec] vlist,
    [[FacetVertsIndex]] FPPind)) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let xopen = x_open(G), Grho = rho(G)
    then temp = for d:#status
    	do{DIMd}
	let nsd = status[d]
	then TODOd = COUNT(nsd)
	then TODOBd = for j in TODOd do facet_bary(vlist, FPPind[d][j]) od,
	     GOALd = #TODOd;
	if facet_verbose
	then show(status); prints(); prints("start dim ",d,
	     " in spherical(G,status,vlist,FPPind); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
    		let result =
    		    if facet_verbose
		     then if k <=10 or k% (1+{GOALd}#TODOd\10) = 0
 		     	  then prints("started test #",k," of ",{GOALd}#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary(first_param(standardize(
			 parameter(xopen, G.rho, 2*TODOBd[k])))))
		then nsd[j]:="T"
		else{NEWU}
		for e: #status-d-1 from d+1
		    do{DIMe}
		    let nse=status[e]
		    then TODOe = COUNT(nse)
		    in
		    for l in TODOe
	    	    	do{FACe}
	    		if{SUB} is_subset_of_sorted(FPPind[e][l])(FPPind[d][j])
	    		then nse[l]:= "F"
	    		fi{SUB}
	    		od{FACe};
		    status[e]:=nse
		    od{DIMe};
		nsd[j]:="F"
		fi{NEWU}
    	in result
    	od{FACd};
    status[d]:=nsd
    od{DIMd};
    if(facet_verbose) then show(status) fi
    in (status,vlist,FPPind)

{.meant to be applied to facets already pruned by down_to_business.}
set spherical_to_ht(RealForm G, ([[string]] status,[ratvec] vlist, [[FacetVertsIndex]] FPPindnch), int bound) =
    ([[string]],[ratvec],[[FacetVertsIndex]]):
    for d:#status
    	do
	let nsd = status[d]
	then TODOd = COUNT(nsd)
	then TODOBd = for j in TODOd do facet_bary(vlist, FPPindnch[d][j]) od, GOALd = #TODOd;
	if facet_verbose
	then show(status); prints(); prints("start dim ",d,
	     " in spherical_to_ht(G,vlist,FPPind); testing ",#TODOd," parameters.")
	fi
	in
		for j@k in TODOd
		do
		let result = 
		    if facet_verbose
		     then if k <=  10 or k% (1+{GOALd}#TODOd\10) = 0
    		     	  then prints("started test #",k, " of ",{GOALd}#TODOd)
		     	  fi
		     fi;
			if (is_unitary_to_ht(first_param(standardize(parameter(
					x_open(G), G.rho, TODOBd[k]))),bound))
			then nsd[j]:="Tto"##to_string(bound)
			else
				for e: #status-d-1 from d+1
				do
				let nse=status[e]
				then TODOe = COUNT(nse)
				in for l in TODOe
				   do
				   if is_subset_of_sorted(FPPindnch[e][l])(FPPindnch[d][j])
				   then nse[l]:= "F"
				   fi
				   od;
				status[e]:=nse
				od;
			nsd[j]:="F"
			fi
		in result
		od;
		status[d]:=nsd
	od;
	if(facet_verbose) then show(status) fi;
	(status,vlist,FPPindnch)

{.this is for complex simple G.}
set spherical_to_htC(RealForm G, ([[string]] status,[ratvec] vlist,
    [[FacetVertsIndex]] FPPindnch), int bound) =
    ([[string]],[ratvec],[[FacetVertsIndex]]):
    let xopen = x_open(G), Grho = rho(G)
    then temp = for d:#status
    	do
	let nsd = status[d]
	then TODOd = COUNT(nsd)
	then TODOBd = for j in TODOd do facet_bary(vlist, FPPindnch[d][j]) od, GOALd = #TODOd;
	if facet_verbose
	then show(status); prints(); prints("start dim ",d,
	     " in spherical_to_htC(G,vlist,FPPind); testing ",#TODOd," parameters.")
	fi
	in
		for j@k in TODOd
		do
		let result = 
		    if facet_verbose
		     then if k <=  10 or k% (1+{GOALd}#TODOd\10) = 0
    		     	  then prints("started test #",k, " of ",{GOALd}#TODOd)
		     	  fi
		     fi;
			if (is_unitary_to_ht(first_param(standardize(parameter(
					xopen, Grho, 2*TODOBd[k]))),bound))
			then nsd[j]:="Tto"##to_string(bound)
			else
				for e: #status-d-1 from d+1
				do
				let nse=status[e]
				then TODOe = COUNT(nse)
				in for l in TODOe
				   do
				   if is_subset_of_sorted(FPPindnch[e][l])(FPPindnch[d][j])
				   then nse[l]:= "F"
				   fi
				   od;
				status[e]:=nse
				od;
			nsd[j]:="F"
			fi
		in result
		od;
		status[d]:=nsd
	od;
	if(facet_verbose) then show(status) fi
	in (status,vlist,FPPindnch)

{ still need simple derived group }
{need vlist to match FPP_vertex_sets_indices}
set spherical(RealForm G) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let (vlist,FPPVI) = FPP_vlist_indices(G)
    then (status,,FPPVInch) = down_to_business(G,(vlist,FPPVI))
    in spherical(G,(status,vlist,FPPVInch))

set sphericalC(RealForm G) =
    ([[string]],[ratvec],[[FacetVertsIndex]]):
    let GL = simple_factors(G)[0]
    then (vlistL,FPPVIL) = FPP_vlist_indices(GL)
    then (status,,FPPVInch) = down_to_businessC(G,(vlistL,FPPVIL))
    in sphericalC(G,(status,vlistL,FPPVInch))

set spherical_to_ht(RealForm G, int bound) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let (vlist,FPPVI) = FPP_vlist_indices(G)
    then (status,,FPPVInch) = down_to_business(G,(vlist,FPPVI))
    in spherical_to_ht(G,(status,vlist,FPPVInch),bound)

set spherical_to_htC(RealForm G, int bound) =
    ([[string]],[ratvec],[[FacetVertsIndex]]):
    let GL = simple_factors(G)[0], xopen = x_open(G), Grho = rho(G)
    then (vlistL,FPPVIL) = FPP_vlist_indices(GL)
    then (status,,FPPVInch) = down_to_businessC(G,(vlistL,FPPVIL))
    in spherical_to_htC(G,(status,vlistL,FPPVInch),bound)

{.forget dimension info; just (for each spherical hermitian barycenter)
whether or not unitary, inducing nu. G must have simple derived group.}
set JustTheFactsSimple(RealForm G) = [(bool,ratvec)]:
    let (statusDONE,verts,FVinds) = spherical(G)
    in
    ##(for d:#FVinds
    	 do for FVI@j in FVinds[d]
	    do (
	       if statusDONE[d][j][0]="T" then true
	       elif statusDONE[d][j][0] = "F" then false
	       else prints("ERROR at d = ",d,", j = ",j); false
	       fi,
	    	facet_bary(verts,FVI)
		)
	    od
	 od)

{.haven't accounted for COMPLEX simple factors yet.}
set real_simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor
    in
    for rd in simple_factors(G) do real_form(inner_class(rd,delta),delta,tf) od

set JustTheFacts(RealForm G) = [(bool,ratvec)]:
    let Gs = real_simple_factors(G)
    then JTFs = for Gj in Gs do JustTheFactsSimple(Gj) od
    in
    case #Gs
    	 in [(true,null(G.rank)/1)],
    	 JTFs[0],
    	 for (stat0,nu0) in JTFs[0]
    	     do for (stat1,nu1) in JTFs[1]
	     	do (stat0 and stat1, nu0+nu1)
		od
	     od.##,
	 for (stat0,nu0) in JTFs[0]
    	     do for (stat1,nu1) in JTFs[1]
	     	do for (stat2,nu2) in JTFs[2]
	     	   do (stat0 and stat1 and stat2, nu0+nu1+nu2)
		   od
	     	od.##
	     od.##
     esac

{.like facet_statusu, adding info from real induction.}
{Marks unipotent parameters as "T[number of dual nilpotent]", induced as "Ti..." or "Fi..."
FPPind should first be pruned by down_to_business}
set facet_statusu_ind(RealForm G,[[string]] statusQuo, [ratvec] vlist, [[vec]] FPPind) =
[[string]]:
    let FPPB = for d:#FPPind do for Find in FPPind[d] do facet_bary(vlist,Find) od od {,}
    then allStatusQuo = [string]: ##statusQuo, allFPPB = [ratvec]: ##FPPB,
    	 allLABELS =  ##(for d:#FPPB do for j:#FPPB[d] do (d,j) od od),
    	 maxLevis = [RealForm]: for i:G.ss_rank
    	     do real_Levi_by_wt(G.fundamental_weights[i],x_open(G)) od
{indices to convert from statusQuo to allStatusQuo}
    then Ns = for d:#statusQuo do sum(for e:d do #statusQuo[e] od) od
    then Index= ParamPol: index(allFPPB)
    then JTFLs = [ [(bool,ratvec)] ]:
    	 for L in maxLevis
	 do JustTheFacts(L) od
{ update StatusQuo working through Levis }
    then temp = for L@j in maxLevis
    do
    let xL = x_open(L), rhoL = L.rho
    in
    for (uboolL,nuL) in JTFLs[j]
    	do
	{let gammaG = dominant(G,nuL + tworhoM/2)
	in if (1+invG)*gammaG != tworhoM then []}
	let InuLstd = real_induce_standard(parameter(xL, rhoL, nuL), G)
	then nuG=first_param(InuLstd).nu
	then nG = find(Index, nuG)
	then trouble = void: if nG = -1
	     then nG := find(Index,facet_bary(G,nuG)) fi
	then bigTrouble = if nG=-1 then prints("TROUBLE: ",j,"  ",L, "  ",nuL) fi
	then (d,j)=allLABELS[nG]
	in
	let result =
	    if allStatusQuo[nG]!="?"
	    then allStatusQuo[nG]
	    else 
	    let InuL = real_induce_irreducible(parameter(x_open(L),L.rho,nuL),G)
	    in
		{if inducing rep is unitary, so is induced, and facets in closure}
	    	if(uboolL)
		     then for e:d
		     do
		     for FIe@k in FPPind[e]
		      	do{FACe}
		      	if{SUB} is_subset_of_sorted(
		      	      FPPind[d][j])(FIe) and
			      allStatusQuo[Ns[e]+k]="?"
		      	then allStatusQuo[Ns[e]+k]:= "Ticlosure"
		      	fi{SUB}
		     	od{FACe}
		     od; "Ti"
	    	{if inducing is hermitian nonunitary,
		    and induction is irreducible, then induced is hermitian nonunitary,
		    along with facets in opening}
	   	else if #InuL = 1
		     then for e: #statusQuo-d-1 from d+1
		     do
		     for FIe@k in FPPind[e]
		      	do{FACe}
		      	if{SUB} is_subset_of_sorted(
		      	      FIe)(FPPind[d][j])
		      	then allStatusQuo[Ns[e]+k]:= "Fiopen"
		      	fi{SUB}
		     	od{FACe}
		     od; "Fi"
		     else allStatusQuo[nG]
		     fi
		fi
	     fi
	     in allStatusQuo[nG]:= result
	 od
    od
{now update statusQuo}
     in
     for d:#statusQuo
     do
	for j:#statusQuo[d] from Ns[d]
	do allStatusQuo[j] od
     od

set facet_statusu_ind(RealForm G) = [[string]]:
    let (vlist, FPPind) = FPP_vlist_indices(G)
    then (statusu,,FPPind) = down_to_business(G,(vlist,FPPind))
    in facet_statusu_ind(G,statusu,vlist,FPPind)

{.spherical unitarity data one simple factor at a time.}
set genSpherical(RealForm G) = [ ([[string]],[ratvec],[[FacetVertsIndex]]) ]:
for G0 in real_simple_factors(G) do spherical(G0) od


{.same, using induced info.}
set spherical_ind(RealForm G) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let (vlist,FPPVI) = FPP_vlist_indices(G)
    then (statusu,,FPPind) = down_to_business(G,(vlist,FPPVI))
    then statusuIND = facet_statusu_ind(G,statusu,vlist,FPPind)
    in spherical(G,(statusuIND,vlist,FPPind))

{ still need simple derived group }
{need vlist to match FPP_vertex_sets_indices}

set spherical_ind_to_ht(RealForm G, int bound) = ([[string]],[ratvec],[[FacetVertsIndex]]):
    let (vlist,FPPVI) = FPP_vlist_indices(G)
    then (statusu,,FPPind) = down_to_business(G,(vlist,FPPVI))
    then statusuIND = facet_statusu_ind(G,statusu,vlist,FPPind)
    in spherical_to_ht(G, (statusuIND,vlist, FPPVI),bound)

{idea is in a session to say
  >> FILENAME write(status,vlist,Cand)

Then in another session you can write
<< FILENAME
set STN=spherical_to_ht(G,(status,vlist,Cand),N)}

set write([[string]] status, [ratvec] vlist, [[FacetVertsIndex]] Cand) = void:
    prints("set status = ",status);
    prints("set vlist = ",vlist);
    prints("set Cand = [[vec]]:",Cand)


set leq([Param] Plist) = (int i, int j) bool:
    HTA(Plist[i]) <= HTA(Plist[j])

{.given a list Plist of Params, sort it according to HTA.}
set HTA_sort([Param] Plist) = [Param]:
    let listSorter = [int]: sort(leq(Plist))(#Plist)
    in [Param]: for j:#Plist do Plist[listSorter[j]] od

