<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]), is_subset_of_sorted }
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<TWOHEIGHTS.at { for HT, HTT, HTA }
<springer_tables_reductive.at { for Springer_table }
<associated_variety_annihilator.at { for GK_dim, used in identifying unipotent reps }
{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])}

{ Just do this for root datum rd with simple derived datum.}

{ at the end is a function "spherical" which (if G has simple derived
group) might return which facets correspond to non-cohomologically
induced spherical principal series. Haven't proven this. }

{ One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell) }

{ There are four notions of "facet":
1) a ([AffineCoroot],[AffineCoroot]) Facet of affine inequalities and
equalities defining it (NOT UNIQUE);
2) the [ratvec] FacetVerts of vertices;
3) the ratvec FacetBary, the barycenter of the facet; and
4) the [vec] FacetVertsIndex of indices of the vertices in a fixed list of vertices

I like FacetVerts the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) by looking at all
enlargements of the vertex set. Passage from FacetVerts to FacetBary is
trivial (average the vertices) There are functions facet, facetVerts and
facetBary which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{ORGANIZATION: Main functions are spherical@RealForm and
spherical_to_ht@(RealForm,int), defined around line 945.

Here is a brief outline. Following Barbasch and Steve
Miller, calculate things related to the FUNDAMENTAL PARALLELEPIPED
FPP, which lies in the R-span of the roots, where all simple coroots
take values in [0,1]. The FPP is partitioned into facets of various
dimensions from 0 to the semisimple rank. Each d-dimensional facet is
determined by its barycenter (a ratvec) or by its vertices (a list of
d+1 ratvecs). The idea for computing all facets in the FPP is to
compute a list vlist of all vertices in the FPP (done by
FPP_vertices@RootDatum); then for each d-dimensional facet to store a
rank d+1 vec giving the indices of the vertices in vlist (done by
FPP_vertex_sets_indices).

What's needed to get going is a list of all barycenters of facets in
the FPP. These are calculated by

Theorem. Every [barycenter of a facet] gamma (not just in FPP) can be
written as w*gamma0 + tau, with gamma0 unique [barycenter of a facet]
in the fundamental alcove, w in W (finite Weyl group), and tau in the
root lattice. If we require

   w*gamma0 is integrally dominant

then w*gamma0 is unique, and so tau is unique.

There are 2^{semisimple rank - 1} facet barycenters gamma0 in the
fundamental alcove.; not too many. Marc kindly provided a very fast
listing of the W-orbits W*gamma0. Picking out the integrally dominant
ones is now done stupidly in functions with names like
W_fund_barycentersID: stupid in the sense that it would have been
cleverer to sort out the integrally dominant terms in the library.  }

{ useful to assign this to 'true" to get information about the progress
of long calculations }
set facet_verbose=false

{.remove repetitions from list of ratvecs.}
set NoReps([ratvec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{.remove repetitions from a list of vecs.}
set NoReps([vec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum

set aff_rank(SimpleAffine Affd) = ss_rank(Affd) + 1

set_type AffineCoroot = (vec,int)

{.evaluate AffineCoroot at weight.}
set *(AffineCoroot (betav,m), vec gamma) = m+betav*gamma

{.evaluate AffineCoroot at rational weight.}
set *(AffineCoroot (betav,m), ratvec gamma) = m+betav*gamma

{.first apply w, then translate by tau.}
set_type AffineCoWeylElt = (vec tau, WeylElt w)

{.apply AffineCoWeylElt to weight.}
set *(AffineCoWeylElt (tau,w) , vec gamma) = w*gamma + tau
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = w*gamma + tau

{.compose AffineCoWeylElts.}
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = AffineCoWeylElt:
    (tau1 + w1*tau2, w1*w2)
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
    let bvw1=betav*inverse(w) in (bvw1, m-bvw1*tau)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
    let w1=inverse(w) in (-w1*tau,w1)

{.simple affine coroots: number 0 is affine, rest are simple for RootDatum.}
set aff_simple_coroots (SimpleAffine affd) = [AffineCoroot]:
    (-highest_root(dual(affd)),1) #
    for alpha_v in simple_coroots(affd) do (alpha_v,0) od

{.sum of simple affine coroots times their labels is (null(rank),1).}
set labels(SimpleAffine affd) = [int]:
    let a = coroot_index(affd,highest_root(dual(affd))) in
    1 # coroot_expression(affd,a)

{.a common denominator for all vertices of alcoves.}
set denom (SimpleAffine affd) = int:
    let lab = labels(affd), fwts=affd.fundamental_weights in
    for fw@j in fwts do denom(fw)*lab[j+1] od.lcm

{.root attached to an AffineCoroot.}
set root (AffineCoroot (betav,m),SimpleAffine affd) = root(affd,betav)

{.affine reflection through Affine coroot, applied to weight.}
set reflection(AffineCoroot Betav, SimpleAffine affd, vec v) = vec:
    v - root(Betav,affd)*(Betav*v)

set reflection(AffineCoroot Betav, SimpleAffine affd, ratvec v) = ratvec:
    reflection(Betav, affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot strict inequalities and (n-k) AffineCoRoot equalities.
The total collection of affine coroots appearing must be a set of simple coroots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE }

set_type [Facet = ([AffineCoroot] pos,[AffineCoroot] zero)]

{ a UNIQUE characterization of a k-diml facet is as a set of
k+1 vertices }

set_type FacetVerts = [ratvec]

set *(WeylElt w, FacetVerts FV) = FacetVerts:
    for v in FV do w*v od

set *(mat M, FacetVerts FV) = FacetVerts:
    for v in FV do M*v od

set *(AffineCoWeylElt wtilde, FacetVerts FV) = FacetVerts:
    for v in FV do wtilde*v od

{ Maybe the smallest UNIQUE characterization of a facet is the barycenter }
set_type FacetBary = ratvec

{represents a k-diml facet as k+1 indices into a list of vertices
(held elsewhere)}
set_type FacetVertsIndex = vec

set_type [FacetStatusVertsIndex = (string status, vec verts)]

set_type FacetData = ([ratvec] vlist, [[FacetStatusVertsIndex]] facet_status_inds)
set facet_verts_index([ratvec] vert_list, FacetVerts facet) = FacetVertsIndex:
    for gammav in facet do find(vert_list,gammav) od.sort

{.list of unsettled terms in statusIndex.}
set to_do([FacetStatusVertsIndex] statusIndex) = vec:
    for stindj@j in statusIndex
    do
    if (stindj.status="?" or (#stindj.status > 1 and stindj.status[1]="t")) then [j]
    else []
    fi
    od.##

{.given a single nonunitary facet F, updates the status of all E with F contained in
	E-bar to nonunitary.}
set update([[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex nonUnitary) =
    [[FacetStatusVertsIndex]]:
    assert(nonUnitary.status[0] = "F","update only applies to NONunitary facets");
    let NUverts = nonUnitary.verts
    then () = for e:#StInd - #NUverts from #NUverts
    do
    let StInde = StInd[e]
    then TODOe = to_do(StInde)
    in
    for j in TODOe
    	do
	if is_subset_of_sorted(StInde[j].verts)(NUverts)
	{Still fails!	then StInde[j].status:=nonUnitary.status}
        then StInde[j] := (nonUnitary.status, StInde[j].verts)
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

{.this version REMOVES nonunitary facets from the lists.}
set updateCUT([[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex nonUnitary) =
    [[FacetStatusVertsIndex]]:
    assert(nonUnitary.status[0] = "F",
    			"update only applies to NONunitary facets");
    let NUverts=nonUnitary.verts
    then () =  for e:#StInd - #NUverts from #NUverts
    do
    let StInde = StInd[e]
    then tempe = for Find in StInde
    	do
	if is_subset_of_sorted(Find.verts)(NUverts)
        then []
	else [Find]
	fi
	od.## 
    in StInd[e]:=tempe
    od
    in StInd

{.given a single unitary (to_ht) facet F, updates the status of all E in F-bar to unitary (to_ht).}
set downdate([[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex Unitary) = [[FacetStatusVertsIndex]]:
    assert(Unitary.status[0] = "T","downdate only applies to unitary facets");
    let Uverts = Unitary.verts
    then test = is_subset_of_sorted(Uverts)
    then () = for e:#Uverts-1
    do
    let StInde = StInd[e]
    then TODOe = to_do(StInde)
    in
    for j in TODOe
    	do
	if test(StInde[j].verts) {can we assign to component?}
	then StInde[j]:=(Unitary.status, StInde[j].verts)
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

{ creates the indexing ParamPol }
{ this only works if the list elements are distinct! }
set index([ratvec] list) = ParamPol:
    let G1=root_datum(null(#list[0],0),null(#list[0],0),true).split_form
    in sum(G1,for v@j in list do (j+1)*parameter(G1,0,G1.rho,v) od)

set find(ParamPol Index,ratvec v) = int:
    let GI = Index.real_form
    in
    split_as_int(Index[parameter(GI,0,GI.rho,v)]) - 1

{.finds the indices for example of all vertices in a facet.}
set find(ParamPol Index, [ratvec] FV) = vec:
    let GI = Index.real_form
    in
    vec: for v in FV
    do split_as_int(Index[parameter(GI,0,GI.rho,v)]) - 1
    od

{ same as facet_verts_index using a precreated ParamPol as index set }
set facet_verts_index(ParamPol Index, FacetVerts facet) = FacetVertsIndex:
for gammav in facet do find(Index,gammav) od.sort

{.computes the Facet of a point gamma0 in the fundamental alcove.}
set facet0(SimpleAffine Affd, ratvec gamma0) = Facet:
    let S=Affd.aff_simple_coroots in
    (for j:Affd.aff_rank
    do if S[j]*gamma0 != 0
       then [S[j]]
       else []
       fi
    od.##,
    for j:Affd.aff_rank
    do if S[j]*gamma0 = 0
       then [S[j]]
       else []
       fi
    od.##)

{.simple roots corresponding to simple affine coroots: number 0 is
affine,  rest are simple for RootDatum.}
set aff_simple_roots(SimpleAffine affd) = mat:
    (-highest_root(dual(affd))) # affd.simple_roots

{.vertices of the fundamental alcove.}
{ set has aff_rank elements }
set fundamental_vertices (SimpleAffine affd) = [ratvec]:
    (ratvec:null(affd.rank)) #
    (let labs=affd.labels[1:] in
     for lab@j in labs do fundamental_weight(affd,j)/lab od)

{.FacetVerts of a point gamma0 in the fundamental alcove.}
set facet_verts0(SimpleAffine affd, ratvec gamma0) = FacetVerts:
    let vert=fundamental_vertices(affd) in
    for coroot@d in affd.aff_simple_coroots
    do if =coroot*gamma0 then [] else [vert[d]] fi
    od.##

{.computes the FacetBary of a point gamma0 in the fundamental alcove.}
set facet_bary0(SimpleAffine affd, ratvec gamma0) = FacetBary:
    let verts = facet_verts0(affd,gamma0) then n=#verts in
    sum(affd.rank, for v in verts do v/n od)

{.barycenters of facets in fundamental alcove, organized by dimension.}
set fund_barycenters(SimpleAffine affd) = [[FacetBary]]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd)
    then listn = #n
    in
    for d:n
    do for S in choices_from(listn,d+1)
       do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
       od
    od

{.barycenters of d-dimensional facets in the fundamental alcove.}
set fund_barycenters(SimpleAffine affd, int d) = [FacetBary]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd) in
    for S in choices_from(#n,d+1)
    do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
    od

{ vertex sets for facets in the fundamental alcove, organized by
dimension }

set fund_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for d:n
    	do for S in choices_from(listn,d+1)
	   do for j in S
	      do Verts[j]
	      od
	   od
	od

set fund_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
    let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for S in choices_from(listn,d+1)
    	do for j in S do Verts[j] od
	od

{.barycenters and vertices of facets in fundamental alcove, organized by dimension.}


{.integral weights to be added to gamma to land in fundamental
parallelepiped where all simple coroots take values in [0,1].}
{need to make a list of all possible tau; if g[j] is an integer, use
either -g[j] or -g[j]+1.}
set FPPtau(SimpleAffine Affd, ratvec gamma) = [ratvec]:
    let g=for betav in Affd.simple_coroots do betav*gamma od
    then INT = ##for j:#Affd.simple_coroots
    	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od
    in
    for S in power_set(#INT)
    do
    sum(Affd.rank, for xi@j in Affd.fundamental_weights
    		   do -floor(g[j])*xi od) +
    sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od)
    od

{ sums of roots to be added to gamma to land in FPP }
set FPPtauRoots(SimpleAffine Affd, ratvec gamma) = [vec]:
    let g=for betav in Affd.simple_coroots do betav*gamma od
    then INT = ##for j:#Affd.simple_coroots
    	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od
    in
    for S in power_set(#INT)
    do
    let tau = sum(Affd.rank, for xi@j in Affd.fundamental_weights
    	      do -floor(g[j])*xi od) +
    	   sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od)
    in
    if(all(
	for xiv in Affd.fundamental_coweights
	do is_integer(xiv*tau) od))
    then [ratvec_as_vec(tau)]
    else []
    fi
    od.##

{.Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove.}
{Goal is to subtract roots until gamma lands in

W*A0 = set where gamma1 is at most one on every coroot.

Precisely,

gamma - TAU(gamma) is in W*(fundamental alcove).

Uses mostly integer arithmetic.

First loop, over all fundamental coweights, makes all the simple root
coordinates of gamma smaller than 1.

Second loop, over all coroots, reduces the largest pairing of gamma
with a coroot betavee (number d-m0-1) by subtracting an appropriate
integer multiple of beta (which puts the pairing with betavee in
[-1,1], but may leave other coroots bigger) unti the maximum is at
most 1.}
set tauRoots(RootDatum rd,ratvec gamma) = vec:
    let COROOTS = rd.coroots, ROOTS = rd.roots, gamma0NUM=gamma.numer,
    	DENOM = gamma.denom, m0= 0, q0=0 then d=#COROOTS
    in
    if d!=0
    then for xiv@j in rd.fundamental_coweights
    do
    let (num,den) = (xiv.numer, xiv.denom)
    in
    gamma0NUM := (gamma0NUM -
    ( ( ( num*gamma0NUM )\(DENOM*den))*DENOM*den)*rd.simple_roots[j])
    od;
    while (m0:=max_loc(for j:d do COROOTS[d-j-1]*gamma0NUM od);
    	  (q0:= COROOTS[d-m0-1]*gamma0NUM; q0 > DENOM))
    do
    gamma0NUM:= gamma0NUM - ceil(q0/(2*DENOM))*DENOM*ROOTS[d-m0-1]
    od
    fi;
    (gamma-gamma0NUM/DENOM).ratvec_as_vec

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) =
    (AffineCoWeylElt,ratvec):
    let tau = tauRoots(rd,gamma)
    then (w,gamma0TIMESDEN) = from_dominant(rd,gamma.numer - gamma.denom*tau)
    in
    {assert (gamma=w*gamma0 + tau,"Bad affine!");}
    ((tau,w),gamma0TIMESDEN/gamma.denom)

{ computes the FacetVerts (vertex set) of any ratvec }
set facet_verts(SimpleAffine Affd, ratvec gamma) = FacetVerts:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in wtilde*facet_verts0(Affd,gamma0)

{.same as facet_verts_index using a precreated ParamPol as index set,
starting with barycenter; or in fact any point of the facet.} 
set facet_verts_index(SimpleAffine Affd, ParamPol Index, FacetBary gamma) =
    FacetVertsIndex:
    for gammav in facet_verts(Affd, gamma) do find(Index,gammav) od.sort

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }
set facet(SimpleAffine Affd, ratvec gamma) = Facet:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    then (F0pos,F0zero) = facet0(Affd,gamma0)
    in (for betav in F0pos do wtilde*betav od ,
       for betav in F0zero do wtilde*betav od)

{ computes the FacetBary of any ratvec, for possibly nonsimple rd}
set facet_bary(RootDatum rd, ratvec gamma) = FacetBary:
    sum(rd.rank, for Affd in simple_factors(rd)
    		 do
    		 let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    		 in	wtilde*facet_bary0(Affd,gamma0)
		 od)

{.number of vertices in W*(fundamental alcove).}
set W_fund_vertices_card(SimpleAffine Affd) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    1+sum(for S in choices_from(listn,n-2) do rat_as_int(N/#W(Levi(Affd,S))) od )

{.number of d-diml facets in W*(fundamental alcove).}
set W_fund_d_facets_card(SimpleAffine Affd,int d) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    if d=n
    then N
    else sum(for T in choices_from(listn,n-d) do rat_as_int(N/#W(Levi(Affd,T))) od) +
    	 sum(for S in choices_from(listn,n-d-1) do rat_as_int(N/#W(Levi(Affd,S))) od)
    fi

{.number of facets in W*(fundamental alcove).}
set W_fund_facets_card(SimpleAffine Affd) = [int]:
    for d:Affd.aff_rank
    	do W_fund_d_facets_card(Affd,d)
	od
{.integrally dominant vertices.}
set W_fund_verticesID(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do
    for gammawn in Weyl_orbit(Affd,gamma.numer)
    	do
	if is_integrally_dominant(Affd,gammawn/gamma.denom)
	then [gammawn/gamma.denom]
	else []
	fi
	od.##
    od.##

set W_fund_barycentersID(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycentersID.")
    fi;
           	for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
		   do if is_integrally_dominant(Affd,gammawn/gamma0.denom)
    	    	   then [gammawn/gamma0.denom]
		   else[]
		   fi
		   od.##
	    	od.##
     od

{ to get everything in the FPP, should use only _integrally dominant_ gammaw in WA0.}
set W_fund_barycentersID(SimpleAffine Affd, int d) = [FacetBary]:
    	if facet_verbose
    	then prints("start W_fund_barycentersID(Affd, ",d,").")
    	fi;
    	for gamma0 in fund_barycenters(Affd)[d]
	do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    do
	    if is_integrally_dominant(Affd,gammawn/gamma0.denom)
	    then [gammawn/gamma0.denom]
	    else []
	    fi
	    od.##
	od.##

{.this includes all vertex sets of facets in the fundamental
parallelepiped, each exactly once.}
set FPP_vertices(SimpleAffine Affd) = [ratvec]:
    if facet_verbose then prints("start FPP_vertices.")
    fi;
    for gamma in W_fund_verticesID(Affd)
    do
    for tau in FPPtauRoots(Affd,gamma)
        do gamma+tau od
    od.##

set FPP_barycenters(SimpleAffine Affd) = [[FacetBary]]:
    if facet_verbose then prints("start FPP_barycenters.")
    fi;
    let WBs = W_fund_barycentersID(Affd)
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_barycenters.")
    fi;
    for gamma in WBs[d]
    	do
    	for tau in FPPtauRoots(Affd,gamma)
	    do gamma+tau od
    	od.##
     od

set FPP_barycenters(SimpleAffine Affd, int d) = [FacetBary]:
    if facet_verbose then prints("start dim ",d, " in FPP_barycenters(Affd,d).")
    fi;
    let WBsd = W_fund_barycentersID(Affd, d)
    in
    for gamma in WBsd
    	do
    	for tau in FPPtauRoots(Affd,gamma)
	    do gamma+tau od
    	od.##

set FPP_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    if facet_verbose
    then prints("starting FPP_vertex_sets(Affd).")
    fi;
    let FPPBs = FPP_barycenters(Affd)
    in
    for d:Affd.aff_rank
    do
    	if facet_verbose then prints("start dim ",d," in FPP_vertex_sets.")
    	fi;
    	for b in FPPBs[d]
    	do facet_verts(Affd,b) od
    od


set FPP_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
    if facet_verbose
    then prints("starting dim = ",d, " in FPP_vertex_sets(Affd,d).")
    fi;
    let FPPBsd = FPP_barycenters(Affd,d)
    in
    	for b in FPPBsd
    	do facet_verts(Affd,b) od

{ computes barycenter from a facet as a vertex list }
set facet_bary([ratvec] vert_list, FacetVertsIndex facet) = FacetBary:
    sum(#vert_list[0], for k:#facet do vert_list[facet[k]] od)/(#facet) 

set FPP_vertex_sets_indices(SimpleAffine Affd, [[FacetBary]] FPPBs) =
    [[FacetVertsIndex]]:
    let vertexIndex=index(FPPBs[0])
    in for d:#FPPBs
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_vertex_sets_indices([[FacetBary]])")
    fi;
    for v in FPPBs[d]
    	do facet_verts_index(Affd, vertexIndex, v)
	od
    od

set FPP_vlist_indices(SimpleAffine Affd) =
    ([ratvec],[[FacetVertsIndex]]):
    let vlist = [ratvec]: FPP_vertices(Affd),
    fundVerts = fund_vertex_sets(Affd)
    then vertexIndex=index(vlist), N= [vec]: for j:#vlist do [j] od
    in (vlist, [[vec]]: [N]##
    for d:Affd.ss_rank from 1
    do
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_vlist_indices")
    fi;
    for FV in fundVerts[d]
    do
    let FB=FacetBary: sum(Affd.rank,FV)/(d+1)
    then WBsID= [FacetBary]:
    	for wFBn in Weyl_orbit(Affd,FB.numer)
        do
        if is_integrally_dominant(Affd,wFBn/FB.denom)
        then [wFBn/FB.denom]
	else []
        fi
        od.##
    in [FacetVertsIndex]: for wFB in WBsID
       do
       let (w,) = from_dominant(Affd,wFB)
       in
	[vec]: for tau in FPPtauRoots(Affd,wFB)
       	do
       	vec: find(vertexIndex, (tau,w)*FV)
       	od
       od.## { now type [vec] }
    od.##
    od)

set FPP_vlist_indices_status(SimpleAffine Affd) =
    ([ratvec],[[FacetStatusVertsIndex]]):
    let vlist = [ratvec]: FPP_vertices(Affd),
    fundVerts = fund_vertex_sets(Affd)
    then vertexIndex=index(vlist), N= [(string,vec)]: for j:#vlist do ("?",[j]) od
    in (vlist, [[(string,vec)]]: [N]##
    for d:Affd.ss_rank from 1
    do
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_vlist_indices")
    fi;
    for FV in fundVerts[d]
    do
    let FB=FacetBary: sum(Affd.rank,FV)/(d+1)
    then WBsID= [FacetBary]:
    	for wFBn in Weyl_orbit(Affd,FB.numer)
        do
        if is_integrally_dominant(Affd,wFBn/FB.denom)
        then [wFBn/FB.denom]
	else []
        fi
        od.##
    in [FacetStatusVertsIndex]: for wFB in WBsID
       do
       let (w,) = from_dominant(Affd,wFB)
       in
	[(string, vec)]: for tau in FPPtauRoots(Affd,wFB)
       	do
       	("?", vec: find(vertexIndex, (tau,w)*FV))
       	od
       od.##{ now type [string,vec] }
    od.##
    od)

{.facet vertex indices for all d-diml facets in FPP.}
set FPP_indices(SimpleAffine Affd, [ratvec] vlist, int d) =
    [FacetVertsIndex]:
    let fundVertsd = fund_vertex_sets(Affd,d)
    then vertexIndex=index(vlist)
    in
    if facet_verbose
    then prints("start dim ",d, "in FPP_vlist_indices(Affd,vlist,d)")
    fi;
    for wFB in W_fund_barycentersID(Affd,d)
    do
    let (w,gamma0) = from_dominant(Affd,wFB)
    then FV0 = facet_verts0(Affd,gamma0)
    in
	[vec]: for tau in FPPtauRoots(Affd,wFB)
       	do
       	vec: find(vertexIndex, (tau,w)*FV0)
       	od
    od.## { now type [vec] }

set FPP_indices(SimpleAffine Affd, ParamPol vertexIndex, int d) =
    [FacetVertsIndex]:
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_indices(Affd,vertexIndex, d)")
    fi;
    for wFB in W_fund_barycentersID(Affd,d)
    do
    let (w,gamma0) = from_dominant(Affd,wFB)
    then FV0 = facet_verts0(Affd,gamma0)
    in
	[vec]: for tau in FPPtauRoots(Affd,wFB)
       	do
       	vec: find(vertexIndex, (tau,w)*FV0)
       	od
    od.## { now type [vec] }

{ meant to record information about unitarity for all facets }
set facet_status([[ratvec]] FPPB) = [[string]]:
    for FPPBd in FPPB do for FB in FPPBd do "?" od od

set facet_status([[vec]] FPPind) = [[string]]:
    for FPPindd in FPPind do for Find in FPPindd do "?" od od

{ meant to record information about unitarity for all facets }
{now marks unipotent parameters as "T[number of dual nilpotent]"}
{I THINK that for a simple G, all unipotent parameters must be
barycenters of facets of dimension 0 or 1. Also I THINK that dimension
1 can only happen in type A?? So this could be simplified.}
set facet_statusu(RealForm G, [ratvec] vlist, [[FacetStatusVertsIndex]] 
    FPPstInd) = FacetData:
    let FPPstIndQuo = FPPstInd, VIndex0 =
    	index(for (,Find) in FPPstInd[0] do vlist[Find[0]] od) {,
    	VIndex1 = ParamPol: if #FPPind <= 1 then 0*Vindex0
		else index(for ind in FPPind[1] do
		(vlist(ind[0]) + vlist(ind[1]))/2 od)}
    then FPPstInd0 = FPPstIndQuo[0]
    then () = if not(is_split(G))
    	 then
	 let st= G.dual.Springer_table in
	 for O@j in st.orbits
	 do
	 let gamma = O.H/2
	 then m0 = find(VIndex0,gamma)
	 in if m0 >= 0 and GK_dim(parameter(x_open(G),G.rho,gamma)) =
	    dim(st.dual_map(O))/2
	    then FPPstInd0[m0] :=  ("T"##to_string(j),FPPstInd0[m0].verts)
	    fi
	 od; FPPstIndQuo[0] := FPPstInd0
    	 else
	 for O@j in G.dual.Springer_table.orbits
	 do
	 let gamma = O.H/2
	 then m0 = find(VIndex0,gamma)
	 in if m0 >= 0 then FPPstInd0[m0] :=
	    ("T"##to_string(j),FPPstInd0[m0].verts)
	      { else let m1 = find(VIndex1,gamma)
	      	   in
	      	   if m1 >= 0 then status1[m1] := "T"##to_string(j) fi }
	    fi
	 od; FPPstIndQuo[0] := FPPstInd0
	 fi
    in (vlist, FPPstIndQuo)


set facet_status([[vec]] FPPind) = [[string]]:
    for d:#FPPind do for j:#FPPind[d] do "?" od od

set show([[FacetStatusVertsIndex]] FPPstInd) = void:
    for FPPstIndd@d in FPPstInd
    do
    let (countTu, countTto, countTi, countT, countF, countFi, countQ) =
    	(0, 0, 0,0,0,0,0)
    in
	for stFind in FPPstIndd
	do
	if stFind.status="T"
	then countT+:=1
	elif stFind.status="F"
	then countF+:=1
	elif stFind.status="?"
	then countQ+:=1
	elif stFind.status[1]="t"
	then countTto+:=1
	elif stFind.status[0]="T" and stFind.status[1]="i"
	then countTi+:=1
	elif stFind.status[1]="i"
	then countFi+:=1
	else countTu+:=1
	fi
	od;
	prints("Facet dimension ",d,": ", countTu, " unipotent, ",countTi,
	" unitarily induced, ",countT, " other unitary,  ", countTto,
	" unitary_to_ht", new_line, "       ",countFi,
	" induced nonunitarily, ",countF, " other nonunitary, ",
	countQ, " undecided.",new_line)
    od

set show(FacetData FD) = show(FD.facet_status_inds)

{.picks the facets for hermitian, final parameters.}
{This eliminates a lot more than pick_not_cohom used to in the nonquasisplit case,
 but maybe it's OK.}

set pick(RealForm G, [ratvec] vlist, [[FacetStatusVertsIndex]] FPPstInd) =
    ([ratvec], [[FacetStatusVertsIndex]]):
    let xopen = x_open(G), Grho = G.rho
    in (vlist,
    for FPPstIndd in FPPstInd
    do
	for FstInd in FPPstIndd
	do
	let FB = facet_bary(vlist, FstInd.verts)
	then p = parameter(xopen, Grho, FB)
	in if (is_final(p) and is_hermitian(p) and
	   (p.infinitesimal_character = FB)) then [FstInd] else [] fi
	od.##
    od)


{. The next family of functions all need simple derived group. Always vlist should be ALL vertices in the FPP. The facet lists carried by [[FacetBary]] or [[FacetVertsIndex]] may be pruned of reps not interesting for unitarity, but the indices will alway refer to a constant vlist.}

set down_to_business(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd)) = FacetData:
    let (,FPPstIndFinalH) = pick(G, vlist, FPPstInd)
    in
    if facet_verbose then prints("completing down_to_business"); show(FPPstIndFinalH) fi;
    facet_statusu(G, vlist, FPPstIndFinalH)

set down_to_businessC(RealForm G, ([ratvec] vlistL,
    [[FacetStatusVertsIndex]] FPPstIndL)) = FacetData:
	let GL=simple_factors(G)[0], one_minus_theta =
	    (1-x_open(G).involution)
	then vlistC = for gammaL in vlistL
	     do one_minus_theta*gammaL od
	then w0L = matrix(GL.w0)
	then FPPstIndnch = [[FacetStatusVertsIndex]]:
	for FPPstIndLd in FPPstIndL
	do
		for Find in FPPstIndLd
		do
		let FBL = facet_bary(vlistL,Find.verts)
		in if =(w0L+1)*FBL then [Find] else [] fi
		od.##
	od
	then FPPstIndu = facet_statusu(GL.split_form,vlistL, FPPstIndnch)
    	in
    	if facet_verbose then prints("completing down_to_businessC");
	show(FPPstIndu) fi;
    	(vlistC, FPPstIndu.facet_status_inds)

{.Meant to be applied to output of down_to_business (with nonhermitian
  eliminated). Need simple derived group.}
set spherical(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd)) = FacetData:
    let xopen = x_open(G), Grho = G.rho
    then temp = 
    for d:#FPPstInd
    	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then temp = (); if facet_verbose
	then show(FPPstInd); prints(); prints("start dim ",d,
	     " in spherical(G,status,vlist,FPPind); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
		let Find = FPPstIndd[j]
    		then result =
    		    if facet_verbose
		     then if k <=10 or k% (1+#FPPstIndd\10) = 0
 		     	  then prints("started test #",k," of ",#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary(first_param(standardize(
			 parameter(xopen, Grho,
			 facet_bary(vlist,Find.verts))))))
		then FPPstIndd[j]:=("T",Find.verts)
		else{NEWU}
		{dammit why can't I do this?
		FPPstIndd[j]:=("F",FPPstIndd[j].verts)}
		FPPstInd:=update(FPPstInd,("F",Find.verts));
		FPPstIndd[j]:=("F",Find.verts)
		fi
    	in result
    	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in (vlist,FPPstInd)

set sphericalC(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd)) = ([ratvec],[[FacetStatusVertsIndex]]):
    let xopen = x_open(G), Grho = rho(G)
    then temp =
    for d:#FPPstInd
    	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then TODOBd = for j in TODOd
	     	      do facet_bary(vlist, FPPstIndd[j].verts) od,
	     	      GOALd = #TODOd;
	if facet_verbose
	then show(FPPstInd); prints(); prints("start dim ",d,
	     " in sphericalC(G,status,(vlist,FPPstInd)); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
    		let result =
    		    if facet_verbose
		     then if k <=10 or k% (1+{GOALd}#TODOd\10) = 0
 		     	  then prints("started test #",k," of ",{GOALd}#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary(first_param(standardize(
			 parameter(xopen, Grho, TODOBd[k])))))
		then FPPstIndd[j]:=("T",FPPstIndd[j].verts)
		else{NEWU}
		FPPstInd:=update(FPPstInd,("F",FPPstIndd[j].verts));
		FPPstIndd[j]:=("F",FPPstIndd[j].verts)
		fi{NEWU}
    	in result
    	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in (vlist,FPPstInd)

set spherical_to_ht(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd), int bound) = ([ratvec],[[FacetStatusVertsIndex]]):
    let xopen = x_open(G), Grho = G.rho
    then temp =
    for d:#FPPstInd
    	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then TODOBd = for j in TODOd
	     	      do facet_bary(vlist, FPPstIndd[j].verts) od,
	     	      GOALd = #TODOd;
	if facet_verbose
	then show(FPPstInd); prints(); prints("start dim ",d,
	     " in spherical_to_ht(G,vlist,FPPstInd); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
    		let result =
    		    if facet_verbose
		     then if k <=10 or k% (1+{GOALd}#TODOd\10) = 0
 		     	  then prints("started test #",k," of ",{GOALd}#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary_to_ht(first_param(standardize(
			 parameter(xopen, Grho, TODOBd[k]))),bound))
		then FPPstIndd[j]:=("Tto"##to_string(bound), FPPstIndd[j].verts)
		else{NEWU}
		{dammit why can't I do this?
		FPPstIndd[j]:=("F",FPPstIndd[j].verts)}
		FPPstInd:=update(FPPstInd,("F",FPPstIndd[j].verts));
		FPPstIndd[j]:=("F",FPPstIndd[j].verts)
		fi
    	in result
    	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in (vlist,FPPstInd)

set spherical_to_htC(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd), int bound) = ([ratvec],[[FacetStatusVertsIndex]]):
    let xopen = x_open(G), Grho = rho(G)
    then temp =
    for d:#FPPstInd
    	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then TODOBd = for j in TODOd
	     	      do facet_bary(vlist, FPPstIndd[j].verts) od,
	     	      GOALd = #TODOd;
	if facet_verbose
	then show(FPPstInd); prints(); prints("start dim ",d,
	     " in spherical_to_htC(G,status,(vlist,FPPstInd)); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
    		let result =
    		    if facet_verbose
		     then if k <=10 or k% (1+{GOALd}#TODOd\10) = 0
 		     	  then prints("started test #",k," of ",{GOALd}#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary_to_ht(first_param(standardize(
			 parameter(xopen, Grho, TODOBd[k]))),bound))
		then FPPstIndd[j]:=("Tto"##to_string(bound),FPPstIndd[j].verts)
		else{NEWU}
		FPPstInd:=update(FPPstInd,("F",FPPstIndd[j].verts));
		FPPstIndd[j]:=("F",FPPstIndd[j].verts)
		fi{NEWU}
    	in result
    	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in (vlist,FPPstInd)

set spherical(RealForm G) = ([ratvec],[[FacetStatusVertsIndex]]):
    let data = FPP_vlist_indices_status(G)
    then dataIndncH = down_to_business(G,data)
    in spherical(G,dataIndncH)

set sphericalC(RealForm G) =
    ([ratvec],[[FacetStatusVertsIndex]]):
    let GL = simple_factors(G)[0]
    then dataL = FPP_vlist_indices_status(GL)
    then dataC = down_to_businessC(G,dataL)
    in sphericalC(G,dataC)

set spherical_to_ht(RealForm G, int bound) = ([ratvec],[[FacetStatusVertsIndex]]):
    let data = FPP_vlist_indices_status(G)
    then dataIndncH = down_to_business(G,data)
    in spherical_to_ht(G,dataIndncH,bound)

set spherical_to_htC(RealForm G, int bound) =
    ([ratvec],[[FacetStatusVertsIndex]]):
    let GL = simple_factors(G)[0]
    then dataL = FPP_vlist_indices_status(GL)
    then dataC = down_to_businessC(G,dataL)
    in spherical_to_htC(G,dataC,bound)

{.forget dimension info; just (for each spherical hermitian barycenter)
whether or not unitary, inducing nu. G must have simple derived group.}
set JustTheFacts_R_simple(RealForm G) = [(bool,ratvec)]:
    let (vlist,FVstInd) = spherical(G)
    in
    ##(for d:#FVstInd
    	 do for FVI@j in FVstInd[d]
	    do (
	       if FVI.status[0]="T" then true
	       elif FVI.status[0] = "F" then false
	       else prints("ERROR at d = ",d,", j = ",j); false
	       fi,
	    	facet_bary(vlist,FVI.verts)
		)
	    od
	 od)

{.forget dimension info; just (for each spherical hermitian barycenter)
whether or not unitary, inducing nu. G must be simple derived group.}
set JustTheFacts_C_simple(RealForm G) = [(bool,ratvec)]:
    let (vlist,FVstInd) = sphericalC(G)
    in
    ##(for d:#FVstInd
    	 do for FVI@j in FVstInd[d]
	    do (
	       if FVI.status[0]="T" then true
	       elif FVI.status[0] = "F" then false
	       else prints("ERROR at d = ",d,", j = ",j); false
	       fi,
	    	facet_bary(vlist,FVI.verts)
		)
	    od
	 od)

{.doesn't account for COMPLEX simple factors.}
set real_simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor
    in
    for rd in simple_factors(G) do real_form(inner_class(rd,delta),delta,tf) od

{.lists(absolutely simple factors,locally complex simple factors.}
set real_and_complex_simple_factors(RealForm G) = ([RealForm],[RealForm]):
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
    	simpleFactors = simple_factors(RootDatum: G),
    	RealFactors = [RealForm]:[], ComplexFactors = [RealForm]:[]
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
    	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex),
    	 newDiagram = diagram_component(G,newSimpleRootIndex)
    in  if diagram=newDiagram then RealFactors##:=
    	 [real_form(inner_class(rd,delta), delta, tf)]
	 else if diagram[0] < newDiagram[0] then ComplexFactors##:=
	 [real_form(inner_class(sub_datum(G,diagram##newDiagram),
		delta), delta, tf)]
	      fi
	fi
    od; (RealFactors,ComplexFactors)

set max_real_Levis(RealForm G) = [RealForm]:
    let xopen=x_open(G), Grho = G.rho
    then inv=xopen.involution
    then tworhoM = (1+inv)*Grho
     then MRL= [RealForm]: []
    in for xi@j in G.fundamental_weights
    do
    let restrFund = (1-inv)*xi
    in if all(for i:j do restrFund*G.simple_coroots[i] = 0 od)
       then MRL##:= [real_Levi_by_wt(restrFund, xopen)]
       fi
    od; MRL

{restricted to L having three simple factors; meant to be applied to a
maximal Levi in a simple G. [ratvec] is infinitesimal chars for spherical reps of L;
[bool] whether unitary}
set JustTheFacts(RealForm L) = [(bool,ratvec)]:
    let (LRs,LCs) = real_and_complex_simple_factors(L)
    then JTFs = for LRj in LRs do JustTheFacts_R_simple(LRj) od ##
    	 for LCk in LCs do JustTheFacts_C_simple(LCk) od

    in
    case #LRs + #LCs
    	 in [(true,null(L.rank)/1)],
    	 JTFs[0],
    	 for (stat0,nu0) in JTFs[0]
    	     do for (stat1,nu1) in JTFs[1]
	     	do (stat0 and stat1, nu0+nu1)
		od
	     od.##,
	 for (stat0,nu0) in JTFs[0]
    	     do for (stat1,nu1) in JTFs[1]
	     	do for (stat2,nu2) in JTFs[2]
	     	   do (stat0 and stat1 and stat2, nu0+nu1+nu2)
		   od
	     	od.##
	     od.##
     esac


{.like facet_statusu, adding info from real induction.}
{Marks unipotent parameters as "T[number of dual nilpotent]", induced
as "Ti..." or "Fi..." FPPQuo should first be pruned by down_to_business}
set facet_statusu_ind(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPQuo)) = FacetData:
    let old_facet_verbose = facet_verbose next
    	if facet_verbose then prints("starting FPPB in facet_status_ind") fi
    then FPPB = for d:#FPPQuo do for Find in FPPQuo[d] do
    	facet_bary(vlist,Find.verts) od od next facet_verbose := false
    then allFPPQuo = [FacetStatusVertsIndex]: ##FPPQuo, allFPPB = [ratvec]: ##FPPB,
    	 allLABELS =  ##(for d:#FPPB do for j:#FPPB[d] do (d,j) od od),
    	 maxLevis = [RealForm]: max_real_Levis(G)
{indices to convert from FPPQuo to allFPPQuo}
    then Ns = for d:#FPPQuo do sum(for e:d do #FPPQuo[e] od) od
    then Index= ParamPol: index(allFPPB)
    then JTFLs = [ [(bool,ratvec)] ]:
    	 for L in maxLevis
	 do
	 if old_facet_verbose then prints("starting JTF for Levi ",L,
	 " in facet_statusu_ind") fi;
	 JustTheFacts(L)
	 od
{ update FPPQuo working through Levis }
    then temp = for L@j in maxLevis
    do
    if old_facet_verbose then prints("updating status using Levi ",L,
	 " in facet_status_ind") fi;
    let xL = x_open(L), rhoL = L.rho
    in
    for (uboolL,gammaL) in JTFLs[j]
    	do
	let IgammaLstd = real_induce_standard(parameter(xL, rhoL, gammaL), G)
	then gammaG=first_param(IgammaLstd).infinitesimal_character
	then nG = find(Index, gammaG)
	then trouble = void: if nG = -1
	     then nG := find(Index,facet_bary(G,gammaG)) fi
	then bigTrouble = if nG=-1 then prints("TROUBLE at MaxLevi #",j,
	     "  which is ",L, ",  and gammaL = ",gammaL, ", gammaG = ",
	     	gammaG); break fi
	then (d,j) = allLABELS[nG]
	in
	let result =
	    if allFPPQuo[nG].status!="?"
	    then allFPPQuo[nG].status
	    else
	    let IgammaL = real_induce_irreducible(parameter(x_open(L),L.rho,
							gammaL),G)
	    in
		{if inducing rep is unitary, so is induced, and facets
		    in closure}
	    	if(uboolL)
		     then for e:d
		     do
		     for FIe@k in FPPQuo[e]
		      	do{FACe}
		      	if{SUB} is_subset_of_sorted(
		      	      FPPQuo[d][j].verts)(FIe.verts) and
			      allFPPQuo[Ns[e]+k].status="?"
		      	then allFPPQuo[Ns[e]+k]:= ("Ticlosure",allFPPQuo[Ns[e]+k].verts)
		      	fi{SUB}
		     	od{FACe}
		     od; "Ti"
	    	{if inducing is hermitian nonunitary,
		    and induction is irreducible, then induced is hermitian
		    nonunitary, along with facets in opening}
	   	else if #IgammaL = 1
		     then for e: #FPPQuo-d-1 from d+1
		     do
		     for FIe@k in FPPQuo[e]
		      	do{FACe}
		      	if{SUB} is_subset_of_sorted(
		      	      FIe.verts)(FPPQuo[d][j].verts)
		      	then allFPPQuo[Ns[e]+k]:= ("Fiopen",allFPPQuo[Ns[e]+k].verts)
		      	fi{SUB}
		     	od{FACe}
		     od; "Fi"
		     else allFPPQuo[nG].status
		     fi
		fi
	     fi
	     in allFPPQuo[nG]:= (result,allFPPQuo[nG].verts)
	 od
    od; facet_verbose := old_facet_verbose
{now update statusQuo}
     in
     (vlist,for d:#FPPQuo
     do
	for j:#FPPQuo[d] from Ns[d]
	do allFPPQuo[j] od
     od)

set facet_statusu_ind(RealForm G) = FacetData:
    let data_ind = FPP_vlist_indices_status(G)
    then data_indncH = down_to_business(G,data_ind)
    in facet_statusu_ind(G,data_indncH)

{.spherical unitarity data one simple factor at a time.}
set genSpherical(RealForm G) = [ ([ratvec],[[FacetStatusVertsIndex]]) ]:
for G0 in real_simple_factors(G) do spherical(G0) od


{.same as spherical using induced info.}
set spherical_ind(RealForm G) = FacetData:
    let dataIndInd = facet_statusu_ind(G)
    in spherical(G, dataIndInd)

{ still need simple derived group }
{need vlist to match FPP_vertex_sets_indices}

set spherical_ind_to_ht(RealForm G, int bound) = FacetData:
    let dataIndInd = facet_statusu_ind(G)
    in spherical_to_ht(G, dataIndInd, bound)

{.version for complex simple G.}
set spherical_indC(RealForm G) = FacetData:
    let GL = simple_factors(G)[0]
    then dataGL = FPP_vlist_indices_status(GL)
    then dataC = down_to_businessC(G,dataGL)
    then dataCuind = facet_statusu_ind(G,dataC)
    in sphericalC(G,dataCuind)

set spherical_ind_to_htC(RealForm G, int bound) = ([ratvec],[[FacetStatusVertsIndex]]):
    let GL = simple_factors(G)[0]
    then dataGL = FPP_vlist_indices_status(GL)
    then dataC = down_to_businessC(G,dataGL)
    then dataCuind = facet_statusu_ind(G,dataC)
    in spherical_to_htC(G, dataCuind, bound)

{idea is in a session to say
  >> FILENAME write(status,vlist,Cand)

Then in another session you can write
<< FILENAME
set STN=spherical_to_ht(G,(status,vlist,Cand),N)}

set write([[string]] status, [ratvec] vlist, [[FacetVertsIndex]] Cand) = void:
    prints("set status = ",status);
    prints("set vlist = ",vlist);
    prints("set Cand = [[vec]]:",Cand)


set leq([Param] Plist) = (int i, int j) bool:
    HTA(Plist[i]) <= HTA(Plist[j])

{.given a list Plist of Params, sort it according to HTA.}
set HTA_sort([Param] Plist) = [Param]:
    let listSorter = [int]: sort(leq(Plist))(#Plist)
    in [Param]: for j:#Plist do Plist[listSorter[j]] od

