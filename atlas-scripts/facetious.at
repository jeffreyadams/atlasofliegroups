<simple_factors.at { for simple_factors }
<affine.at { to try to avoid conflicting definitions }
<basic.at { for power_set, choices_from, sum@(int,[ratvec]), is_subset_of_sorted }
<hermitian.at { for is_unitary }
<to_ht.at { for is_unitary_to_ht }
<TWOHEIGHTS.at { for HT, HTT, HTA }
<springer_tables_reductive.at { for Springer_table }
<associated_variety_annihilator.at { for GK_dim, used in identifying unipotent reps }
<lietypes.at { for simple_type }
<parabolics.at {for parabolic_by_wt}
<K_highest_weights.at {for all_parameters_x_gamma}
<lattice.at {for vec_solve}

{ Goal is to write representatives of all affine facets in the
fundamental parallelepiped
  gamma in X*_Q,  0 \le betav[i]*gamma \le 1 (all simple coroots betav[i])}

{ Just do this for root datum rd with simple derived datum.}

{ at the end is a function "spherical" which (if G has simple derived
group) might return which facets correspond to non-cohomologically
induced spherical principal series. Haven't proven this. }

{ One problem is that there are TWO affine Weyl groups. The one
considered here uses translation by ROOTS and acts on X^*. In this
group the "simple affine root" involves the highest COROOT. The other
possibility, which I'll try not to use in this file, uses translation
by COROOTS and acts on X_*. That is the one considered in DV notes
alcoves.pdf, and useful for understanding elements of finite order in
G. I think it's the primary topic in affine.at.

Write simple coroots as betav[1]...betav[ell-1], lowest coroot as

   betav[0] = -(rd.dual).highest_root
   betav[j] = rd.simple_coroots[j-1] (1 \le j \le ell) }

{ There are four notions of "facet":
1) a ([AffineCoroot],[AffineCoroot]) Facet of affine inequalities and
equalities defining it (NOT UNIQUE);
2) the [ratvec] FacetVerts of vertices;
3) the ratvec FacetBary, the barycenter of the facet; and
4) the [vec] FacetVertsIndex of indices of the vertices in a fixed list of vertices

I like FacetVerts the best: you can take the
closure of F just by looking at subsets of the vertices; and the
"opening" (all facets having F in their closure) by looking at all
enlargements of the vertex set. Passage from FacetVerts to FacetBary is
trivial (average the vertices) There are functions facet, facetVerts and
facetBary which compute each of these three representations of
the facet containing a given ratvec gamma in X^*_Q. }

{ORGANIZATION: Main functions are spherical@RealForm and
spherical_to_ht@(RealForm,int), defined around line 945.

Here is a brief outline. Following Barbasch and Steve
Miller, calculate things related to the FUNDAMENTAL PARALLELEPIPED
FPP, which lies in the R-span of the roots, where all simple coroots
take values in [0,1]. The FPP is partitioned into facets of various
dimensions from 0 to the semisimple rank. Each d-dimensional facet is
determined by its barycenter (a ratvec) or by its vertices (a list of
d+1 ratvecs). The idea for computing all facets in the FPP is to
compute a list vlist of all vertices in the FPP (done by
FPP_vertices@RootDatum); then for each d-dimensional facet to store a
rank d+1 vec giving the indices of the vertices in vlist (done by
FPP_vertex_sets_indices).

What's needed to get going is a list of all barycenters of facets in
the FPP. These are calculated by

Theorem. Every [barycenter of a facet] gamma (not just in FPP) can be
written as w*gamma0 + tau, with gamma0 unique [barycenter of a facet]
in the fundamental alcove, w in W (finite Weyl group), and tau in the
root lattice. If we require

   w*gamma0 is integrally dominant

then w*gamma0 is unique, and so tau is unique.

There are 2^{semisimple rank - 1} facet barycenters gamma0 in the
fundamental alcove.; not too many. Marc kindly provided a very fast
listing of the W-orbits W*gamma0. Picking out the integrally dominant
ones is now done stupidly in functions with names like
W_fund_barycentersID: stupid in the sense that it would have been
cleverer to sort out the integrally dominant terms in the library.  }

{ useful to assign this to 'true" to get information about the progress
of long calculations }
set facet_verbose=false

{.remove repetitions from list of ratvecs.}
set NoReps([ratvec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{.remove repetitions from a list of vecs.}
set NoReps([vec] list) =
    for elt@j in list
    do if all(j, (int i): list[i] != elt) then [elt]
       else []
       fi
    od.##

{ An affine root datum is a root datum rd (which in atlas means with
chosen pos_roots), and a list of the lowest coroots betav[j] in each
rd[j] in simple_factors(rd). Since I want to use this to look for
unitary reps, simple rd is the most important case }
set_type SimpleAffine = RootDatum

set aff_rank(SimpleAffine Affd) = ss_rank(Affd) + 1

set_type AffineCoroot = (vec,int)

{.evaluate AffineCoroot at weight.}
set *(AffineCoroot (betav,m), vec gamma) = m+betav*gamma

{.evaluate AffineCoroot at rational weight.}
set *(AffineCoroot (betav,m), ratvec gamma) = m+betav*gamma

{.first apply w, then translate by tau.}
set_type AffineCoWeylElt = (vec tau, WeylElt w)

{.apply AffineCoWeylElt to weight.}
set *(AffineCoWeylElt (tau,w) , vec gamma) = w*gamma + tau
set *(AffineCoWeylElt (tau,w) , ratvec gamma) = w*gamma + tau

{.compose AffineCoWeylElts.}
set *(AffineCoWeylElt(tau1,w1) , AffineCoWeylElt(tau2,w2)) = AffineCoWeylElt:
    (tau1 + w1*tau2, w1*w2)
set *(AffineCoWeylElt(tau,w) , AffineCoroot(betav,m)) = AffineCoroot:
    let bvw1=betav*inverse(w) in (bvw1, m-bvw1*tau)
set inverse(AffineCoWeylElt(tau,w)) = AffineCoWeylElt:
    let w1=inverse(w) in (-w1*tau,w1)

{.simple affine coroots: number 0 is affine, rest are simple for RootDatum.}
set aff_simple_coroots (SimpleAffine affd) = [AffineCoroot]:
    (-highest_root(dual(affd)),1) #
    for alpha_v in simple_coroots(affd) do (alpha_v,0) od

{.sum of simple affine coroots times their labels is (null(rank),1).}
set labels(SimpleAffine affd) = [int]:
    let a = coroot_index(affd,highest_root(dual(affd))) in
    1 # coroot_expression(affd,a)

{.a common denominator for all vertices of alcoves.}
set denom (SimpleAffine affd) = int:
    let lab = labels(affd), fwts=affd.fundamental_weights in
    for fw@j in fwts do denom(fw)*lab[j+1] od.lcm

{.root attached to an AffineCoroot.}
set root (AffineCoroot (betav,m),SimpleAffine affd) = root(affd,betav)

{.affine reflection through Affine coroot, applied to weight.}
set reflection(AffineCoroot Betav, SimpleAffine affd, vec v) = vec:
    v - root(Betav,affd)*(Betav*v)

set reflection(AffineCoroot Betav, SimpleAffine affd, ratvec v) = ratvec:
    reflection(Betav, affd, v.numer)/v.denom

{ a k-diml facet in n-diml simplex is cut out by a collection of
(k+1) AffineCoroot strict inequalities and (n-k) AffineCoRoot equalities.
The total collection of affine coroots appearing must be a set of simple coroots
for the affine datum. IF THE FACET IS NOT AN ALCOVE, THIS
REPRESENTATION IS NOT UNIQUE }

set_type Facet = ([AffineCoroot] pos,[AffineCoroot] zero)

{ a UNIQUE characterization of a k-diml facet is as a set of
k+1 vertices }

set_type FacetVerts = [ratvec]

set *(WeylElt w, FacetVerts FV) = FacetVerts:
    for v in FV do w*v od

set *(mat M, FacetVerts FV) = FacetVerts:
    for v in FV do M*v od

set *(AffineCoWeylElt wtilde, FacetVerts FV) = FacetVerts:
    for v in FV do wtilde*v od

{ Maybe the smallest UNIQUE characterization of a facet is the barycenter }
set_type FacetBary = ratvec

{represents a k-diml facet as k+1 indices into a list of vertices
(held elsewhere)}
set_type FacetVertsIndex = vec

set_type [FacetStatusVertsIndex = (string status, vec verts)]

set_type FacetData = ([ratvec] vlist, [[FacetStatusVertsIndex]] facet_status_inds)

set facet_verts_index([ratvec] vert_list, FacetVerts facet) = FacetVertsIndex:
    for gammav in facet do find(vert_list,gammav) od.sort

{.list of unsettled terms in statusIndex.}
set to_do([FacetStatusVertsIndex] statusIndex) = vec:
    for stindj@j in statusIndex
    do
    if (stindj.status="?" or (#stindj.status > 1 and stindj.status[1]="t")) then [j]
    else []
    fi
    od.##

{.given a single nonunitary facet F, updates the status of all E with F contained in
	E-bar to nonunitary.}
set update([[FacetStatusVertsIndex]] StInd, FacetStatusVertsIndex nonUnitary) =
    [[FacetStatusVertsIndex]]:
    assert(nonUnitary.status[0] = "F","update only applies to NONunitary facets");
    let NUverts = nonUnitary.verts
    then () = for e:#StInd - #NUverts from #NUverts
    do
    let StInde = StInd[e]
    then TODOe = to_do(StInde)
    in
    for j in TODOe
    	do
	if is_subset_of_sorted(StInde[j].verts)(NUverts) and StInde[j].status = "?"
	{Still fails!	then StInde[j].status:=nonUnitary.status}
        then StInde[j] := (nonUnitary.status, StInde[j].verts)
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

set update([FacetStatusVertsIndex] allInd, FacetStatusVertsIndex nonUnitary,int START) =
    [FacetStatusVertsIndex]:
    assert(nonUnitary.status[0] = "F","update only applies to NONunitary facets");
    let NUverts = nonUnitary.verts
    then newAllInd = allInd
    then temp = for Find@j in allInd[START:]
    	do
	if is_subset_of_sorted(Find.verts)(NUverts) and newAllInd[j+START].status = "?"
	{Still fails!	then StInde[j].status:=nonUnitary.status}
        then newAllInd[j+START] := (nonUnitary.status, Find.verts)
	fi
	od
    in newAllInd

 {.this version REMOVES nonunitary facets from the lists.}
set updateCUT([[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex nonUnitary) =
    [[FacetStatusVertsIndex]]:
    assert(nonUnitary.status[0] = "F",
    			"update only applies to NONunitary facets");
    let NUverts=nonUnitary.verts
    then () =  for e:#StInd - #NUverts from #NUverts
    do
    let StInde = StInd[e]
    then tempe = for Find in StInde
    	do
	if is_subset_of_sorted(Find.verts)(NUverts)
        then []
	else [Find]
	fi
	od.## 
    in StInd[e]:=tempe
    od
    in StInd

{.given a single unitary (to_ht) facet F, updates the status of all E in F-bar to unitary (to_ht).}
set downdate([[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex Unitary) = [[FacetStatusVertsIndex]]:
    assert(Unitary.status[0] = "T","downdate only applies to unitary facets");
    let Uverts = Unitary.verts
    then test = is_subset_of_sorted(Uverts)
    then () = for e:#Uverts-1
    do
    let StInde = StInd[e]
    then TODOe = to_do(StInde)
    in
    for j in TODOe
    	do
	if test(StInde[j].verts) and StInde[j].status = "?" {can we assign to component?}
	then StInde[j]:=(Unitary.status, StInde[j].verts)
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

{.given a single unitary (to_ht) facet F, updates the status of all E in F-bar to unitary (to_ht).}
set downdate([FacetStatusVertsIndex] allInd,FacetStatusVertsIndex Unitary, int END) =
    [FacetStatusVertsIndex]:
    assert(Unitary.status[0] = "T","downdate only applies to unitary facets");
    let Uverts = Unitary.verts
    then test = is_subset_of_sorted(Uverts)
    then newAllInd = allInd
    then temp =for Find@j in allInd[:END]
    	do
	if test(Find.verts) and Find.status = "?" {can we assign to component?}
	then newAllInd[j]:=(Unitary.status, Find.verts)
	fi
	od
    in newAllInd

{ creates the indexing ParamPol }
{ this only works if the list elements are distinct! }
set index([ratvec] list) = ParamPol:
    let G1=root_datum(null(#list[0],0),null(#list[0],0),true).split_form
    in sum(G1,for v@j in list do (j+1)*parameter(G1,0,G1.rho,v) od)

set find(ParamPol Index,ratvec v) = int:
    let GI = Index.real_form
    in split_as_int(Index[parameter(GI,0,GI.rho,v)]) - 1

{.finds the indices for example of all vertices in a facet.}
set find(ParamPol Index, [ratvec] FV) = vec:
    let GI = Index.real_form
    in
    vec: for v in FV
    do split_as_int(Index[parameter(GI,0,GI.rho,v)]) - 1
    od

{.assumes all verts are same size.}
set index([FacetStatusVertsIndex] FVSI) = ParamPol:
    let G1=root_datum(null(#FVSI[0].verts,0),null(#FVSI[0].verts,0),true).split_form
    in sum(G1,for (,V)@j in FVSI do (j+1)*parameter(G1,0,G1.rho,V/1) od)

set find(ParamPol Index, vec verts) = int:
    let GI = Index.real_form
    in split_as_int(Index[parameter(GI,0,GI.rho,verts/1)]) - 1

{set RC_verts(RealForm G, [ratvec] vlist, FacetVertsIndex FInd) = (vec,vec):
    let xopen = x_open(G), Grho = G.rho
    then theta = x_open(G).involution
    then tworhoM = Grho + theta*Grho
{all vertices v should satisfy (1+theta)*v = tworhoM}
    then for ind in Find do facet_bary(
}

{ same as facet_verts_index using a precreated ParamPol as index set }
set facet_verts_index(ParamPol Index, FacetVerts facet) = FacetVertsIndex:
for gammav in facet do find(Index,gammav) od.sort

{.computes the Facet of a point gamma0 in the fundamental alcove.}
set facet0(SimpleAffine Affd, ratvec gamma0) = Facet:
    let S=Affd.aff_simple_coroots in
    (for j:Affd.aff_rank
    do if S[j]*gamma0 != 0
       then [S[j]]
       else []
       fi
    od.##,
    for j:Affd.aff_rank
    do if S[j]*gamma0 = 0
       then [S[j]]
       else []
       fi
    od.##)

{.simple roots corresponding to simple affine coroots: number 0 is
affine,  rest are simple for RootDatum.}
set aff_simple_roots(SimpleAffine affd) = mat:
    (-highest_root(dual(affd))) # affd.simple_roots

{.vertices of the fundamental alcove.}
{ set has aff_rank elements }
set fundamental_vertices (SimpleAffine affd) = [ratvec]:
    (ratvec:null(affd.rank)) #
    (let labs=affd.labels[1:] in
     for lab@j in labs do fundamental_weight(affd,j)/lab od)

{.FacetVerts of a point gamma0 in the fundamental alcove.}
set facet_verts0(SimpleAffine affd, ratvec gamma0) = FacetVerts:
    let vert=fundamental_vertices(affd) in
    for coroot@d in affd.aff_simple_coroots
    do if =coroot*gamma0 then [] else [vert[d]] fi
    od.##

{.computes the FacetBary of a point gamma0 in the fundamental alcove.}
set facet_bary0(SimpleAffine affd, ratvec gamma0) = FacetBary:
    let verts = facet_verts0(affd,gamma0) then n=#verts in
    sum(affd.rank, for v in verts do v/n od)

{.barycenters of facets in fundamental alcove, organized by dimension.}
set fund_barycenters(SimpleAffine affd) = [[FacetBary]]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd)
    then listn = #n
    in
    for d:n
    do for S in choices_from(listn,d+1)
       do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
       od
    od

{.barycenters of d-dimensional facets in the fundamental alcove.}
set fund_barycenters(SimpleAffine affd, int d) = [FacetBary]:
    let  n = affd.aff_rank, fundverts = fundamental_vertices(affd) in
    for S in choices_from(#n,d+1)
    do sum(affd.rank, for j in S do fundverts[j] od)/(d+1)
    od

{ vertex sets for facets in the fundamental alcove, organized by
dimension }

set fund_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for d:n
    	do for S in choices_from(listn,d+1)
	   do for j in S
	      do Verts[j]
	      od
	   od
	od

set fund_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
    let  n = Affd.aff_rank, Verts=fundamental_vertices(Affd)
    then listn = for j:n do j od
    in
    for S in choices_from(listn,d+1)
    	do for j in S do Verts[j] od
	od

{.integral weights to be added to gamma to land in fundamental
parallelepiped where all simple coroots take values in [0,1].}
{need to make a list of all possible tau; if g[j] is an integer, use
either -g[j] or -g[j]+1.}
set FPPtau(SimpleAffine Affd, ratvec gamma) = [ratvec]:
    let g=for betav in Affd.simple_coroots do betav*gamma od
    then INT = ##for j:#Affd.simple_coroots
    	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od
    in
    for S in power_set(#INT)
    do
    sum(Affd.rank, for xi@j in Affd.fundamental_weights
    		   do -floor(g[j])*xi od) +
    sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od)
    od

{ sums of roots to be added to gamma to land in FPP }
set FPPtauRoots(SimpleAffine Affd, ratvec gamma) = [vec]:
    let g=for betav in Affd.simple_coroots do betav*gamma od
    then INT = ##for j:#Affd.simple_coroots
    	 do
	 if is_integer(g[j]) then [j] else []
	 fi
	 od
    in
    for S in power_set(#INT)
    do
    let tau = sum(Affd.rank, for xi@j in Affd.fundamental_weights
    	      do -floor(g[j])*xi od) +
    	   sum(Affd.rank,for j in S do Affd.fundamental_weights[INT[j]] od)
    in
    if(all(
	for xiv in Affd.fundamental_coweights
	do is_integer(xiv*tau) od))
    then [ratvec_as_vec(tau)]
    else []
    fi
    od.##

{.Computes translation part of affine Weyl group element moving gamma
to the fundamental alcove.}
{Goal is to subtract roots until gamma lands in

W*A0 = set where gamma1 is at most one on every coroot.

Precisely,

gamma - TAU(gamma) is in W*(fundamental alcove).

Uses mostly integer arithmetic.

First loop, over all fundamental coweights, makes all the simple root
coordinates of gamma smaller than 1.

Second loop, over all coroots, reduces the largest pairing of gamma
with a coroot betavee (number d-m0-1) by subtracting an appropriate
integer multiple of beta (which puts the pairing with betavee in
[-1,1], but may leave other coroots bigger) unti the maximum is at
most 1.}
set tauRoots(RootDatum rd,ratvec gamma) = vec:
    let COROOTS = rd.coroots, ROOTS = rd.roots, gamma0NUM=gamma.numer,
    	DENOM = gamma.denom, m0= 0, q0=0 then d=#COROOTS
    in
    if d!=0
    then for xiv@j in rd.fundamental_coweights
    do
    let (num,den) = (xiv.numer, xiv.denom)
    in
    gamma0NUM := (gamma0NUM -
    ( ( ( num*gamma0NUM )\(DENOM*den))*DENOM*den)*rd.simple_roots[j])
    od;
    while (m0:=max_loc(for j:d do COROOTS[d-j-1]*gamma0NUM od);
    	  (q0:= COROOTS[d-m0-1]*gamma0NUM; q0 > DENOM))
    do
    gamma0NUM:= gamma0NUM - ceil(q0/(2*DENOM))*DENOM*ROOTS[d-m0-1]
    od
    fi;
    (gamma-gamma0NUM/DENOM).ratvec_as_vec

{ Computes INVERSE OF a (nonunique) aff Weyl gp elt wtilde moving
gamma to the fundamental alcove, and the (unique) image of gamma in that
fundamental alcove, trying to do integer arithmetic. }
set from_fundamental_alcove(RootDatum rd, ratvec gamma) =
    (AffineCoWeylElt,ratvec):
    let tau = tauRoots(rd,gamma)
    then (w,gamma0TIMESDEN) = from_dominant(rd,gamma.numer - gamma.denom*tau)
    in
    {assert (gamma=w*gamma0 + tau,"Bad affine!");}
    ((tau,w),gamma0TIMESDEN/gamma.denom)

{.restored from 3/30/22 version for use in computing bigger facets with
same unitarity status.}
set facet(SimpleAffine Affd, ratvec gamma) = Facet:
let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma) then
(F0pos,F0zero) = facet0(Affd,gamma0) in (for betav in F0pos
do wtilde*betav od , for betav in F0zero
do wtilde*betav od)

{.This (over) counts the integral hyperplanes that have a chance to
contribute to reducibility of p. p is assumed final. Maybe this means
that if alpha is not real, then both dots with gamma MUST be positive?}
set NumRedHyps(Param p) = int:
    let id = integrality_datum(p), theta = (p.x).involution, gamma =
    p.infinitesimal_character, rhoR = (p.x).rho_r
    in sum(for alpha@ell in id.posroots
       	       do let em = root_index(id, -theta*alpha)
	       in if
	       	  em >= 0
		  and {complex integral roots changing sign under
		  theta are automatically nonsingular in final case}
		  (em != ell
		  {id.poscoroots[ell] * gamma > 0
	       	  and id.poscoroots[em] * gamma > 0}
	       	  or (em = ell and rat_as_int(id.poscoroots[ell] * (gamma
		  -p.lambda -rhoR)) % 2 = 1))
		  {is_parity is defined only for simple roots}
		  {maybe should count singular real parity roots as reducible?}
	       then 1 else 0 fi
	       od)

{this is meant to be a crude version for the spherical case only}
set NumRedHyps(RealForm G, Facet (A,B)) = int:
    let corootsInt = G.rank # for (v,m) in B do v od,
    coroots0 = G.rank # for (v,m) in B do if m = 0 then [v] else [] fi od.##
    then rootsInt = G.rank # for v in corootsInt do root(G,v) od,
    roots0 = G.rank # for v in coroots0 do root(G,v) od
    then rdInt = root_datum(rootsInt, corootsInt), rd0 = root_datum(roots0,
    coroots0)
    in #rdInt.posroots - #rd0.posroots

{.if the bigger facet arises by relaxing pos AffineCoroot's that are NOT reducibility
hyperplanes, then unitarity IS inherited by the bigger facet. This assumes all facets
in StInd are hermitian.}
set updateTrue(RealForm G, [[FacetStatusVertsIndex]] StInd,
[[FacetBary]] FBs, FacetStatusVertsIndex Unitary, FacetBary FB) =
    [[FacetStatusVertsIndex]]:
    assert(Unitary.status[0] = "T","update only applies to unitary facets");
    let Uverts = Unitary.verts, p = parameter(x_open(G),G.rho,FB)
    then NRHF = NumRedHyps(p)
    then () = for e:#StInd - #Uverts from #Uverts
    do
    let StInde = StInd[e]
    then TODOe = to_do(StInde)
    in
    for j in TODOe
    	do
	if is_subset_of_sorted(StInde[j].verts)(Uverts) and
	   StInde[j].status = "?"
{need to test that pos AffineCoroot's for j which are zero on the
barycenter of F (# = codim of F in E) are NOT reducibility
hyperplanes}
{need to count reducibility affine coroots in Ezero, hope it's equal
to number in Fzero}
        then let NRHE = NumRedHyps(parameter(x_open(G),G.rho, FBs[e][j]))
	in if NRHE = NRHF then StInde[j] := (Unitary.status,
	   StInde[j].verts) fi
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd

{.computes the collection of vertex sets of alcoves containing gamma in their closures.}
set openure(SimpleAffine Affd, ratvec gamma) = [FacetVerts]:
    let rdI = integrality_datum(Affd, gamma), FVS = fund_vertex_sets(Affd, Affd.ss_rank)[0]
    then (fromFund,) = (AffineCoWeylElt,ratvec): from_fundamental_alcove(Affd,gamma)
    then shakers = [AffineCoWeylElt]: for x in W(rdI)
    	 do (ratvec_as_vec(gamma - x*gamma),x) od
    in for wtilde in shakers do wtilde*(fromFund*FVS) od

{ computes the FacetVerts (vertex set) of any ratvec }
set facet_verts(SimpleAffine Affd, ratvec gamma) = FacetVerts:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    in wtilde*facet_verts0(Affd,gamma0)

{.same as facet_verts_index using a precreated ParamPol as index set,
starting with barycenter; or in fact any point of the facet.} 
set facet_verts_index(SimpleAffine Affd, ParamPol Index, FacetBary gamma) =
    FacetVertsIndex:
    for gammav in facet_verts(Affd, gamma) do find(Index,gammav) od.sort

{ computes the (that is, a non-unique representation of the) facet of
any ratvec }
set facet(SimpleAffine Affd, ratvec gamma) = Facet:
    let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    then (F0pos,F0zero) = facet0(Affd,gamma0)
    in (for betav in F0pos do wtilde*betav od ,
       for betav in F0zero do wtilde*betav od)

{ computes the FacetBary of any ratvec, for possibly nonsimple rd}
set facet_bary(RootDatum rd, ratvec gamma) = FacetBary:
    sum(rd.rank, for Affd in simple_factors(rd)
    		 do
    		 let (wtilde,gamma0) = from_fundamental_alcove(Affd, gamma)
    		 in	wtilde*facet_bary0(Affd,gamma0)
		 od)

{.number of vertices in W*(fundamental alcove).}
set W_fund_vertices_card(SimpleAffine Affd) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    1+sum(for S in choices_from(listn,n-2) do rat_as_int(N/#W(Levi(Affd,S))) od )

{.number of d-diml facets in W*(fundamental alcove).}
set W_fund_d_facets_card(SimpleAffine Affd,int d) = int:
    let n=Affd.ss_rank, N=#W(Affd)
    then listn=for j:n do j od
    in
    if d=n
    then N
    else sum(for T in choices_from(listn,n-d) do rat_as_int(N/#W(Levi(Affd,T))) od) +
    	 sum(for S in choices_from(listn,n-d-1) do rat_as_int(N/#W(Levi(Affd,S))) od)
    fi

{.number of facets in W*(fundamental alcove).}
set W_fund_facets_card(SimpleAffine Affd) = [int]:
    for d:Affd.aff_rank
    	do W_fund_d_facets_card(Affd,d)
	od
{.integrally dominant vertices.}
set W_fund_verticesID(SimpleAffine Affd) = [ratvec]:
    for gamma in fundamental_vertices(Affd)
    do
    for gammawn in Weyl_orbit(Affd,gamma.numer)
    	do
	if is_integrally_dominant(Affd,gammawn/gamma.denom)
	then [gammawn/gamma.denom]
	else []
	fi
	od.##
    od.##

set W_fund_barycentersID(SimpleAffine Affd) = [[FacetBary]]:
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in W_fund_barycentersID.")
    fi;
           	for gamma0 in fund_barycenters(Affd)[d]
		do for gammawn in Weyl_orbit(Affd,gamma0.numer)
		   do if is_integrally_dominant(Affd,gammawn/gamma0.denom)
    	    	   then [gammawn/gamma0.denom]
		   else[]
		   fi
		   od.##
	    	od.##
     od

{ to get everything in the FPP, should use only _integrally dominant_ gammaw in WA0.}
set W_fund_barycentersID(SimpleAffine Affd, int d) = [FacetBary]:
    	if facet_verbose
    	then prints("start W_fund_barycentersID(Affd, ",d,").")
    	fi;
    	for gamma0 in fund_barycenters(Affd)[d]
	do for gammawn in Weyl_orbit(Affd,gamma0.numer)
    	    do
	    if is_integrally_dominant(Affd,gammawn/gamma0.denom)
	    then [gammawn/gamma0.denom]
	    else []
	    fi
	    od.##
	od.##

{.this includes all vertex sets of facets in the fundamental
parallelepiped, each exactly once.}
set FPP_vertices(SimpleAffine Affd) = [ratvec]:
    if facet_verbose then prints("start FPP_vertices.")
    fi;
    for gamma in W_fund_verticesID(Affd)
    do
    for tau in FPPtauRoots(Affd,gamma)
        do gamma+tau od
    od.##

set FPP_barycenters(SimpleAffine Affd) = [[FacetBary]]:
    if facet_verbose then prints("start FPP_barycenters.")
    fi;
    let WBs = W_fund_barycentersID(Affd)
    in
    for d:Affd.aff_rank
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_barycenters.")
    fi;
    for gamma in WBs[d]
    	do
    	for tau in FPPtauRoots(Affd,gamma)
	    do gamma+tau od
    	od.##
     od

set FPP_barycenters(SimpleAffine Affd, int d) = [FacetBary]:
    if facet_verbose then prints("start dim ",d, " in FPP_barycenters(Affd,d).")
    fi;
    let WBsd = W_fund_barycentersID(Affd, d)
    in
    for gamma in WBsd
    	do
    	for tau in FPPtauRoots(Affd,gamma)
	    do gamma+tau od
    	od.##

set FPP_vertex_sets(SimpleAffine Affd) = [[FacetVerts]]:
    if facet_verbose
    then prints("starting FPP_vertex_sets(Affd).")
    fi;
    let FPPBs = FPP_barycenters(Affd)
    in
    for d:Affd.aff_rank
    do
    	if facet_verbose then prints("start dim ",d," in FPP_vertex_sets.")
    	fi;
    	for b in FPPBs[d]
    	do facet_verts(Affd,b) od
    od


set FPP_vertex_sets(SimpleAffine Affd, int d) = [FacetVerts]:
    if facet_verbose
    then prints("starting dim = ",d, " in FPP_vertex_sets(Affd,d).")
    fi;
    let FPPBsd = FPP_barycenters(Affd,d)
    in
    	for b in FPPBsd
    	do facet_verts(Affd,b) od

{ computes barycenter from a facet as a vertex list }
set facet_bary([ratvec] vert_list, FacetVertsIndex facet) = FacetBary:
    sum(#vert_list[0], for k:#facet do vert_list[facet[k]] od)/(#facet) 


set FPP_vertex_sets_indices(SimpleAffine Affd, [[FacetBary]] FPPBs) =
    [[FacetVertsIndex]]:
    let vertexIndex=index(FPPBs[0])
    in for d:#FPPBs
    do
    if facet_verbose
    then prints("start dim ",d," in FPP_vertex_sets_indices([[FacetBary]])")
    fi;
    for v in FPPBs[d]
    	do facet_verts_index(Affd, vertexIndex, v)
	od
    od

set FPP_vlist_indices(SimpleAffine Affd) =
    ([ratvec],[[FacetVertsIndex]]):
    let vlist = [ratvec]: FPP_vertices(Affd),
    fundVerts = fund_vertex_sets(Affd)
    then vertexIndex=index(vlist), N= [vec]: for j:#vlist do [j] od
    in (vlist, [[vec]]: [N]##
    for d:Affd.ss_rank from 1
    do
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_vlist_indices")
    fi;
    for FV in fundVerts[d]
    do
    let FB=FacetBary: sum(Affd.rank,FV)/(d+1)
    then WBsID= [FacetBary]:
    	for wFBn in Weyl_orbit(Affd,FB.numer)
        do
        if is_integrally_dominant(Affd,wFBn/FB.denom)
        then [wFBn/FB.denom]
	else []
        fi
        od.##
    in [FacetVertsIndex]: for wFB in WBsID
       do
       let (w,) = from_dominant(Affd,wFB)
       in
	[vec]: for tau in FPPtauRoots(Affd,wFB)
       	do
       	vec: find(vertexIndex, (tau,w)*FV)
       	od
       od.## { now type [vec] }
    od.##
    od)

set FPP_vlist_indices_status(SimpleAffine Affd) =
    ([ratvec],[[FacetStatusVertsIndex]]):
    let vlist = [ratvec]: FPP_vertices(Affd),
    fundVerts = fund_vertex_sets(Affd)
    then vertexIndex=index(vlist), N= [(string,vec)]: for j:#vlist do ("?",[j]) od
    in (vlist, [[(string,vec)]]: [N]##
    for d:Affd.ss_rank from 1
    do
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_vlist_indices_status")
    fi;
    for FV in fundVerts[d]
    do
    let FB=FacetBary: sum(Affd.rank,FV)/(d+1)
    then WBsID= [FacetBary]:
    	for wFBn in Weyl_orbit(Affd,FB.numer)
        do
        if is_integrally_dominant(Affd,wFBn/FB.denom)
        then [wFBn/FB.denom]
	else []
        fi
        od.##
    in [FacetStatusVertsIndex]: for wFB in WBsID
       do
       let (w,) = from_dominant(Affd,wFB)
       in
	[(string, vec)]: for tau in FPPtauRoots(Affd,wFB)
       	do
       	("?", vec: find(vertexIndex, (tau,w)*FV))
       	od
       od.##{ now type [string,vec] }
    od.##
    od)

{.facet vertex indices for all d-diml facets in FPP.}
set FPP_indices(SimpleAffine Affd, [ratvec] vlist, int d) =
    [FacetVertsIndex]:
    let fundVertsd = fund_vertex_sets(Affd,d)
    then vertexIndex=index(vlist)
    in
    if facet_verbose
    then prints("start dim ",d, "in FPP_indices(Affd,vlist,d)")
    fi;
    for wFB in W_fund_barycentersID(Affd,d)
    do
    let (w,gamma0) = from_dominant(Affd,wFB)
    then FV0 = facet_verts0(Affd,gamma0)
    in
	[vec]: for tau in FPPtauRoots(Affd,wFB)
       	do
       	vec: find(vertexIndex, (tau,w)*FV0)
       	od
    od.## { now type [vec] }

set FPP_indices(SimpleAffine Affd, ParamPol vertexIndex, int d) =
    [FacetVertsIndex]:
    if facet_verbose
    then prints("start dim ",d,
    	 " in FPP_indices(Affd,vertexIndex, d)")
    fi;
    for wFB in W_fund_barycentersID(Affd,d)
    do
    let (w,gamma0) = from_dominant(Affd,wFB)
    then FV0 = facet_verts0(Affd,gamma0)
    in
	[vec]: for tau in FPPtauRoots(Affd,wFB)
       	do
       	vec: find(vertexIndex, (tau,w)*FV0)
       	od
    od.## { now type [vec] }

{.output is the indices in FPPInd~[0] to alcoves containing Base in their closures.}
set FPPopenureAlcoves([[FacetStatusVertsIndex]] FPPInd, FacetVertsIndex Base) = vec:
    for Find@j in FPPInd~[0]
    do
    if is_subset_of_sorted(Find.verts)(Base) then [j] else [] fi
    od.##

{.allow for the possibility that not all alcoves are indexed. Finds all alcoves in FPP containing Base in closure, even if not indexed.}
set FPPopenureAllAlcoves(SimpleAffine Affd, [ratvec] vlist, ParamPol Index,
    FacetVertsIndex Base) = [FacetVertsIndex]:
    for FV in openure(Affd, facet_bary(vlist, Base))
    do let FVI = facet_verts_index(Index,FV)
    in if FVI.>= then [FVI] else [] fi
    od.##

{.Given a list of alcoves represented as FacetVertsIndex, and a base
FacetVertsIndex Base, finds all indexed facets E having Base in closure
Indices[e] should index verts in e-dimensional facets in FPPInd. If
Base has dimension d (d+1 vertices) then output[m] indexes facets of
dimension d+1+m with Base in closure.}
set FPPopenureFacets([FacetVertsIndex] Alcoves, [ParamPol] Indices,
    FacetVertsIndex Base) = [vec]:
    let BaseComps = [FacetVertsIndex]:
    	 for A in Alcoves
	 do  for j in A do if isnt_member(Base)(j) then [j] else [] fi od.##
	 od
    in [vec]: for m:#BaseComps[0]
	   do vec:
	       ##(for BC in BaseComps
	       do vec:
	   	  for S in choices_from(BC, m+1)
		  do let j = find(Indices[#Base+m], vec: sort(Base##S))
		  in if j>=0 then [j] else [] fi
		  od.##
	       od)
	    od

set FPPopenureFacets([[FacetStatusVertsIndex]] FPPInd, [ParamPol] Indices,
    FacetVertsIndex Base) = [vec]:
    let Alcoves = [FacetVertsIndex]: for j in FPPopenureAlcoves(FPPInd, Base)
    	do FPPInd~[0][j].verts od
    in FPPopenureFacets(Alcoves, Indices, Base)

{.given a single nonunitary facet F, updates the status of all E with F contained in
	E-bar to nonunitary. Uses Indices into the FacetVerts sets}
set update([vec] OpenureFacets, [ParamPol] Indices, [[FacetStatusVertsIndex]] StInd,
    FacetStatusVertsIndex nonUnitary) = [[FacetStatusVertsIndex]]:
    assert(nonUnitary.status[0] = "F","update only applies to NONunitary facets");
    let NUverts = nonUnitary.verts, newStInd = StInd
    then temp = for e:#StInd - #NUverts from #NUverts
    	 do let opene = OpenureFacets[e-#NUverts], StInde= newStInd[e]
	    in for j in opene
    	    do let stej = StInde[j].status
	    in
	    if stej = "?" or (#stej > 1
	       and stej[1]="t")
	    {Still fails!	then StInde[j].status:=nonUnitary.status}
            then StInde[j] := (nonUnitary.status, StInde[j].verts)
	    fi
	    od;
    	    StInd[e]:=StInde
    	 od
    in StInd

set update([ParamPol] Indices, [[FacetStatusVertsIndex]] StInd,
    FacetStatusVertsIndex nonUnitary) = [[FacetStatusVertsIndex]]:
    update(FPPopenureFacets(StInd, Indices, nonUnitary.verts), Indices,
    StInd, nonUnitary)

{.given a single unitary (to_ht) facet F, updates the status of all E in F-bar to unitary (to_ht).}
set downdate([ParamPol] Indices, [[FacetStatusVertsIndex]] StInd,FacetStatusVertsIndex Unitary) =
    [[FacetStatusVertsIndex]]:
    assert(Unitary.status[0] = "T","downdate only applies to unitary facets");
    let Uverts = Unitary.verts
    then () = for e:#Uverts-1
    do
    let StInde = StInd[e]
    in
    for S in choices_from(Uverts,e+1)
    	do
	let j = find(Indices[e], S)
	in
	if j >= 0 then
	   let stej = StInde[j].status
	   in
	   if stej = "?" or (#stej > 1 and stej[1]="t")
	   then StInde[j]:=(Unitary.status, StInde[j].verts)
	   fi
	fi
	od;
    StInd[e]:=StInde
    od
    in StInd


{ meant to record information about unitarity for all facets }
set facet_status([[ratvec]] FPPB) = [[string]]:
    for FPPBd in FPPB do for FB in FPPBd do "?" od od

set facet_status([[vec]] FPPind) = [[string]]:
    for FPPindd in FPPind do for Find in FPPindd do "?" od od

{ meant to record information about unitarity for all facets }
{now marks unipotent parameters as "T[number of dual nilpotent]"}
{I THINK that for a simple G, all unipotent parameters must be
barycenters of facets of dimension 0 or 1. Also I THINK that dimension
1 can only happen in type A?? So this could be simplified.}
set facet_statusu(RealForm G, ([ratvec] vlist, [[FacetStatusVertsIndex]] 
    FPPstInd)) = FacetData:
    let FBs = [[FacetBary]]: for Findd in FPPstInd do for Find in
    Findd do facet_bary(vlist, Find.verts) od od
    then FPPstIndQuo = FPPstInd, VIndex0 =
    	index(for (,Find) in FPPstInd[0] do vlist[Find[0]] od) ,
    	VIndex1 = ParamPol: if #FPPstInd=0 then index([vlist[0]])
		  	    else index(for (,ind) in FPPstInd[1] do (vlist[ind[0]] + vlist[ind[1]])/2 od)
			    fi,
			    (X,r) = simple_type(G.derived),  st= G.dual.Springer_table
    then FPPstInd0 = FPPstInd[0], FPPstInd1 = if #FPPstInd>0 then FPPstInd[1] else FPPstInd[0] fi
    then () = if not(is_split(G))
    	 then for O@j in st.orbits
	 do
	 let gamma = O.H/2
	 then m0 = find(VIndex0,gamma)
	 in if m0 >= 0 and GK_dim(parameter(x_open(G),G.rho,gamma)) =
	    dim(st.dual_map(O))/2
	    then FPPstInd0[m0] :=
	    ("T"##to_string(j),FPPstInd0[m0].verts);
	    FPPstIndQuo := updateTrue(G, FPPstIndQuo, FBs,
	    ("Tdef"##to_string(j),FPPstInd0[m0].verts), FBs[0][m0])
	    fi
	 od
    	 else
	 for O@j in st.orbits
	 do
	 let gamma = O.H/2
	 then m0 = find(VIndex0,gamma)
	 in if m0 >= 0 then FPPstInd0[m0] :=
	    ("T"##to_string(j),FPPstInd0[m0].verts);
	     FPPstIndQuo := updateTrue(G, FPPstIndQuo, FBs,
	    ("Tdef"##to_string(j),FPPstInd0[m0].verts), FBs[0][m0])
	    fi
	 od
	 fi; FPPstIndQuo[0] := FPPstInd0
 { ODD TYPE A NILPOTENTS GIVE FACETS OF DIM 1 }
       	then () = if X = "A" and r > 1
	     then let FPPstInd1 = FPPstIndQuo[1]
	     then VIndex1 = ParamPol:
	     	  index(for (,ind) in FPPstIndQuo[1] do (vlist[ind[0]]
		  	    + vlist[ind[1]])/2 od)
	     in if not(is_split(G)) then
	     	for O@j in st.orbits
	     	do
	     	let gamma = O.H/2
	     	then m1 = find(VIndex1,gamma)
	     	in if m1 >= 0 and GK_dim(parameter(x_open(G),G.rho,gamma)) =
	     	   dim(st.dual_map(O))/2
	    	   then FPPstInd1[m1] :=
		   ("T"##to_string(j),FPPstInd1[m1].verts);
		   FPPstIndQuo := updateTrue(G, FPPstIndQuo, FBs,
	    	   ("Tdef"##to_string(j),FPPstInd0[m1].verts), FBs[1][m1])
	    	   fi
	     	od
	     	else
	     	for O@j in st.orbits
	     	do
	     	let gamma = O.H/2
	     	then m1 = find(VIndex1,gamma)
	     	in if m1 >= 0 then FPPstInd1[m1] :=
	     	   ("T"##to_string(j),FPPstInd1[m1].verts);
		   FPPstIndQuo := updateTrue(G, FPPstIndQuo, FBs,
	    	   ("Tdef"##to_string(j),FPPstInd0[m1].verts), FBs[1][m1])
		   fi
	     	od
	     	fi; FPPstIndQuo[1] := FPPstInd1
	     fi
    in (vlist, FPPstIndQuo)


set facet_status([[vec]] FPPind) = [[string]]:
    for d:#FPPind do for j:#FPPind[d] do "?" od od

set show([[FacetStatusVertsIndex]] FPPstInd) = void:
    for FPPstIndd@d in FPPstInd
    do
    let (countTu, countTto, countTi, countTdef, countT,
    countFi, countFdef, countF, countQ) = 
    	(0, 0, 0,0,0,0,0, 0, 0)
    in
	for stFind in FPPstIndd
	do
	if stFind.status="T"
	then countT+:=1
	elif stFind.status[0]="F"
	then countF+:=1
	elif stFind.status="?"
	then countQ+:=1
	elif stFind.status[1]="t"
	then countTto+:=1
	elif stFind.status[0]="T" and stFind.status[1]="i"
	then countTi+:=1
	elif stFind.status[1]="i"
	then countFi+:=1
	elif stFind.status[0] = "T" and stFind.status[1]="d"
	then countTdef+:=1
	elif stFind.status[0] = "F" and stFind.status[1]="d"
	then countFdef+:=1
	else countTu+:=1
	fi
	od;
	prints("Facet dimension ",d,": ", countTu, " unipotent, ",countTi,
	" unitarily induced, ",countTdef, " deformed from unitary, ",
    	countT, " other unitary,  ", countTto, 
	" unitary_to_ht", new_line, "       ",countFi,
	" induced nonunitarily, ",countFdef,
	" deformed from nonunitary, ",countF, " other nonunitary, ",
	countQ, " undecided.",new_line)
    od

set show(FacetData FD) = show(FD.facet_status_inds)

set look_up_vertices ([ratvec] vertices, [int] facet)=[ratvec]:
   for n in facet do vertices[n] od

set unitary_facets ([FacetStatusVertsIndex] FSVI)=[vec]:
   ##for (u,fac) in FSVI
   do if u[0]!="F" then [fac] else [] fi od

set remove_closure ([vec] short,[vec] long) =[vec]:
   ##for v in short do if none (for w in long do all(for k in v do find(w,k)!=-1 od) od)
                     then [v] else [] fi od

set remove_closure ([[vec]] all, int k) =[[vec]]:
   for level@i in all do if i<k
               then remove_closure (level,all[k])
	       else level
	       fi od

set show_long ([ratvec] vertices,[[FacetStatusVertsIndex]] FSVIlist)=void:
   let n=#FSVIlist-1
   then ulist= for facets in FSVIlist
               do unitary_facets(facets) od
   in for i:n do ulist:=remove_closure(ulist,n-i) od;
   for i:n+1
    do prints(new_line,"Unitary facets of dimension ",i,":",new_line);
        for fac in ulist[i]
	do  prints(look_up_vertices(vertices,fac))
        od
    od


{.picks the facets for hermitian, final parameters.}
{This eliminates a lot more than pick_not_cohom used to in the nonquasisplit case,
 but maybe it's OK.}

set pick(RealForm G, [ratvec] vlist, [[FacetStatusVertsIndex]] FPPstInd) =
    ([ratvec], [[FacetStatusVertsIndex]]):
    let xopen = x_open(G), Grho = G.rho
    in (vlist,
    for FPPstIndd in FPPstInd
    do
	for FstInd in FPPstIndd
	do
	let FB = facet_bary(vlist, FstInd.verts)
	then p = parameter(xopen, Grho, FB)
	in if (is_final(p) and is_hermitian(p) and
	   (p.infinitesimal_character = FB)) then [FstInd] else [] fi
	od.##
    od)


{. The next family of functions all need simple derived group. Always vlist should be ALL vertices in the FPP. The facet lists carried by [[FacetBary]] or [[FacetVertsIndex]] may be pruned of reps not interesting for unitarity, but the indices will alway refer to a constant vlist.}

set down_to_business(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd)) = FacetData:
    let (,FPPstIndFinalH) = pick(G, vlist, FPPstInd)
    in
    if facet_verbose then prints("completing down_to_business"); show(FPPstIndFinalH) fi;
    facet_statusu(G, (vlist, FPPstIndFinalH))

set down_to_businessC(RealForm G, ([ratvec] vlistL,
    [[FacetStatusVertsIndex]] FPPstIndL)) = FacetData:
	let GL=simple_factors(G)[0], one_minus_theta =
	    (1-x_open(G).involution)
	then vlistC = for gammaL in vlistL
	     do one_minus_theta*gammaL od
	then w0L = matrix(GL.w0)
	then FPPstIndnch = [[FacetStatusVertsIndex]]:
	for FPPstIndLd in FPPstIndL
	do
		for Find in FPPstIndLd
		do
		let FBL = facet_bary(vlistL,Find.verts)
		in if =(w0L+1)*FBL then [Find] else [] fi
		od.##
	od
	then FPPstIndu = facet_statusu(GL.split_form,(vlistL, FPPstIndnch))
    	in
    	if facet_verbose then prints("completing down_to_businessC");
	show(FPPstIndu) fi;
    	(vlistC, FPPstIndu.facet_status_inds)

{.Meant to be applied to output of down_to_business (with nonhermitian
  eliminated). Need simple derived group.}
set spherical(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd)) = FacetData:
    let xopen = x_open(G), Grho = G.rho, FBs = [[FacetBary]]:
    	for FPPstIndd in FPPstInd
	    do for Find in FPPstIndd
	       do facet_bary(vlist, Find.verts) od
	    od,
	Indices = [ParamPol]:
    	for FPPstIndd in FPPstInd do index(FPPstIndd) od
    then temp =
    for d:#FPPstInd
    	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then temp = (); if facet_verbose
	then prints(); show(FPPstInd); prints("start dim ",d,
	     " in spherical(G,status,vlist,FPPind); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
		let Find = FPPstIndd[j]
    		then result =
    		    if facet_verbose
		     then if k <=5 or k% (1+#FPPstIndd\10) = 0
 		     	  then prints("started test #",k," of ",#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary(first_param(standardize(
			 parameter(xopen, Grho, FBs[d][j])))))
			 {facet_bary(vlist,Find.verts)}
		then FPPstInd:=updateTrue(G, FPPstInd, FBs, ("Tdef", Find.verts), FBs[d][j]);
 		FPPstIndd[j]:=("T",Find.verts)
		else{NEWU}
		FPPstInd:=update(Indices, FPPstInd, ("Fdef",Find.verts));
		FPPstIndd[j]:=("F",Find.verts)
		fi
    	in result
    	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in (vlist,FPPstInd)

set sphericalC(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd)) = ([ratvec],[[FacetStatusVertsIndex]]):
    let xopen = x_open(G), Grho = rho(G),
    	FBs = [[FacetBary]]:
    	for FPPstIndd in FPPstInd
	    do for Find in FPPstIndd
	       do facet_bary(vlist, Find.verts) od
	    od,
	Indices = [ParamPol]:
    	for FPPstIndd in FPPstInd
	    do index(FPPstIndd) od,
    GL = simple_factors(G)[0]
    then vlistL = FPP_vertices(GL) {should pass from down_to_businessC}
    then temp =
    for d:#FPPstInd
    	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then GOALd = #TODOd;
	if facet_verbose
	then prints(); show(FPPstInd); prints("start dim ",d,
	     " in sphericalC(G,status,(vlist,FPPstInd)); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
		let Find = FPPstIndd[j]
    		then result =
    		    if facet_verbose
		     then if k <=5 or k% (1+{GOALd}#TODOd\10) = 0
 		     	  then prints("started test #",k," of ",{GOALd}#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary(first_param(standardize(
			 parameter(xopen, Grho, FBs[d][j])))))
		then FPPstInd:=updateTrue(G, FPPstInd, FBs, ("Tdef",
    		     Find.verts),  FBs[d][j]);
		FPPstIndd[j]:=("T",FPPstIndd[j].verts)
		else{NEWU} {alcoves containing Find.verts may have gone}
		FPPstInd:=update(Indices, FPPstInd, ("F",Find.verts));
		FPPstIndd[j]:=("F",FPPstIndd[j].verts)
		fi{NEWU}
    	in result
    	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in (vlist,FPPstInd)

set spherical_to_ht(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd), int bound) =
    ([ratvec],[[FacetStatusVertsIndex]]):
    let xopen = x_open(G), Grho = G.rho, FBs = [[FacetBary]]:
    	      for FPPstIndd in FPPstInd
	      do for Find in FPPstIndd
	       	 do facet_bary(vlist, Find.verts) od
	      od,
	Indices = [ParamPol]:
        	for FPPstIndd in FPPstInd do index(FPPstIndd) od
    then temp =
    for d:#FPPstInd
    	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then TODOBd = for j in TODOd
	     	      do facet_bary(vlist, FPPstIndd[j].verts) od,
	     	      GOALd = #TODOd;
	if facet_verbose
	then prints(); show(FPPstInd); prints("start dim ",d,
	     " in spherical_to_ht(G,vlist,FPPstInd); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
		let Find = FPPstIndd[j]
    		then result =
    		    if facet_verbose
		     then if k <=5 or k% (1+{GOALd}#TODOd\10) = 0
 		     	  then prints("started test #",k," of ",{GOALd}#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary_to_ht(first_param(standardize(
			 parameter(xopen, Grho, TODOBd[k]))),bound))
		then FPPstInd:=updateTrue(G, FPPstInd, FBs, ("Tdef",
    		     Find.verts),  FBs[d][j]);
		FPPstIndd[j]:=("Tto"##to_string(bound), FPPstIndd[j].verts)
		else{NEWU}
		{dammit why can't I do this?
		FPPstIndd[j]:=("F",FPPstIndd[j].verts)}
		FPPstInd:=update(Indices, FPPstInd, ("F",Find.verts));
                FPPstIndd[j]:=("F",Find.verts)
		fi
    	in result
    	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in (vlist,FPPstInd)

set spherical_to_htC(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPstInd), int bound) = ([ratvec],
    [[FacetStatusVertsIndex]]):
    let xopen = x_open(G), Grho = rho(G),
    	FBs = [[FacetBary]]:
    	    for FPPstIndd in FPPstInd
	    	do for Find in FPPstIndd
	       	   do facet_bary(vlist, Find.verts) od
	    	od,
	Indices = [ParamPol]:
            for FPPstIndd in FPPstInd do index(FPPstIndd) od,
        GL = simple_factors(G)[0]
    then vlistL = FPP_vertices(GL) {should pass from down_to_businessC}
    then temp =
    for d:#FPPstInd
    	do{DIMd}
	let FPPstIndd = FPPstInd[d]
	then TODOd = to_do(FPPstIndd)
	then GOALd = #TODOd;
	if facet_verbose
	then prints(); show(FPPstInd); prints("start dim ",d,
	     " in spherical_to_htC(G,status,(vlist,FPPstInd)); testing ",
	       #TODOd," parameters.")
	fi
    	in
		for j@k in TODOd
    	    	do{FACd}
    		let Find = FPPstIndd[j]
		then result =
    		    if facet_verbose
		     then if k <=5 or k% (1+{GOALd}#TODOd\10) = 0
 		     	  then prints("started test #",k," of ",{GOALd}#TODOd)
		     	  fi
		     fi;
		if{NEWU} (is_unitary_to_ht(first_param(standardize(
			 parameter(xopen, Grho, FBs[d][j]))),bound))
		then FPPstInd:=updateTrue(G, FPPstInd, FBs, (
		     "Tto"##to_string(bound), Find.verts),  FBs[d][j]);
		FPPstIndd[j]:=("Tto"##to_string(bound),FPPstIndd[j].verts)
		else{NEWU}
		FPPstInd:= update(Indices, FPPstInd, ("F",Find.verts)); Find;
		FPPstIndd[j]:=("F",Find.verts)
		fi{NEWU}
    	in result
    	od{FACd};
    FPPstInd[d]:=FPPstIndd
    od{DIMd};
    if(facet_verbose) then show(FPPstInd) fi
    in (vlist,FPPstInd)

set spherical(RealForm G) = ([ratvec],[[FacetStatusVertsIndex]]):
    let data = FPP_vlist_indices_status(G)
    then dataIndncH = down_to_business(G,data)
    in spherical(G,dataIndncH)

set sphericalC(RealForm G) =
    ([ratvec], [[FacetStatusVertsIndex]]):
    let GL = simple_factors(G)[0]
    then dataL = FPP_vlist_indices_status(GL)
    then dataC = down_to_businessC(G,dataL)
    in sphericalC(G,dataC)

set spherical_to_ht(RealForm G, int bound) = ([ratvec],
    [[FacetStatusVertsIndex]]):
    let data = FPP_vlist_indices_status(G)
    then dataIndncH = down_to_business(G,data)
    in spherical_to_ht(G,dataIndncH,bound)

set spherical_to_htC(RealForm G, int bound) =
    ([ratvec],[[FacetStatusVertsIndex]]):
    let GL = simple_factors(G)[0]
    then dataL = FPP_vlist_indices_status(GL)
    then dataC = down_to_businessC(G,dataL)
    in spherical_to_htC(G,dataC,bound)

{.forget dimension info; just (for each spherical hermitian barycenter)
whether or not unitary, inducing nu. G must have simple derived group.}
set JustTheFacts_R_simple(RealForm G) = [(bool,ratvec)]:
    let (vlist,FVstInd) = spherical(G)
    in
    ##(for d:#FVstInd
    	 do for FVI@j in FVstInd[d]
	    do (
	       if FVI.status[0]="T" then true
	       elif FVI.status[0] = "F" then false
	       else prints("ERROR at d = ",d,", j = ",j); false
	       fi,
	    	facet_bary(vlist,FVI.verts)
		)
	    od
	 od)

{.forget dimension info; just (for each spherical hermitian barycenter)
whether or not unitary, inducing nu. G must be simple derived group.}
set JustTheFacts_C_simple(RealForm G) = [(bool,ratvec)]:
    let (vlist,FVstInd) = sphericalC(G)
    in
    ##(for d:#FVstInd
    	 do for FVI@j in FVstInd[d]
	    do (
	       if FVI.status[0]="T" then true
	       elif FVI.status[0] = "F" then false
	       else prints("ERROR at d = ",d,", j = ",j); false
	       fi,
	    	facet_bary(vlist,FVI.verts)
		)
	    od
	 od)

{.doesn't account for COMPLEX simple factors.}
set real_simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor
    in
    for rd in simple_factors(G) do real_form(inner_class(rd,delta),delta,tf) od

{.lists(absolutely simple factors,locally complex simple factors.}
set real_and_complex_simple_factors(RealForm G) = ([RealForm],[RealForm]):
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
    	simpleFactors = simple_factors(RootDatum: G),
    	RealFactors = [RealForm]:[], ComplexFactors = [RealForm]:[]
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
    	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex),
    	 newDiagram = diagram_component(G,newSimpleRootIndex)
    in  if diagram=newDiagram then RealFactors##:=
    	 [real_form(inner_class(rd,delta), delta, tf)]
	 else if diagram[0] < newDiagram[0] then ComplexFactors##:=
	 [real_form(inner_class(sub_datum(G,diagram##newDiagram),
		delta), delta, tf)]
	      fi
	fi
    od; (RealFactors,ComplexFactors)

set max_real_Levis(RealForm G) = [RealForm]:
    let xopen=x_open(G), Grho = G.rho
    then inv=xopen.involution
    then tworhoM = (1+inv)*Grho
     then MRL= [RealForm]: []
    in for xi@j in G.fundamental_weights
    do
    let restrFund = (1-inv)*xi
    in if all(for i:j do restrFund*G.simple_coroots[i] = 0 od)
       then MRL##:= [real_Levi_by_wt(restrFund, xopen)]
       fi
    od; MRL

{restricted to L having three simple factors; meant to be applied to a
maximal Levi in a simple G. [ratvec] is infinitesimal chars for spherical reps of L;
[bool] whether unitary}
set JustTheFacts(RealForm L) = [(bool,ratvec)]:
    let (LRs,LCs) = real_and_complex_simple_factors(L)
    then JTFs = for LRj in LRs do JustTheFacts_R_simple(LRj) od ##
    	 for LCk in LCs do JustTheFacts_C_simple(LCk) od

    in
    case #LRs + #LCs
    	 in [(true,null(L.rank)/1)],
    	 JTFs[0],
    	 for (stat0,nu0) in JTFs[0]
    	     do for (stat1,nu1) in JTFs[1]
	     	do (stat0 and stat1, nu0+nu1)
		od
	     od.##,
	 for (stat0,nu0) in JTFs[0]
    	     do for (stat1,nu1) in JTFs[1]
	     	do for (stat2,nu2) in JTFs[2]
	     	   do (stat0 and stat1 and stat2, nu0+nu1+nu2)
		   od
	     	od.##
	     od.##
     esac


{.like facet_statusu, adding info from real induction.}
{Marks unipotent parameters as "T[number of dual nilpotent]", induced
as "Ti..." or "Fi..." FPPQuo should first be pruned by down_to_business}
set facet_statusu_ind(RealForm G, ([ratvec] vlist,
    [[FacetStatusVertsIndex]] FPPQuo)) = FacetData:
    let old_facet_verbose = facet_verbose next
    	if facet_verbose then prints("starting FPPB in facet_statusu_ind") fi
    then FPPB = for d:#FPPQuo do for Find in FPPQuo[d] do
    	facet_bary(vlist,Find.verts) od od next facet_verbose := false
    then allFPPB = [ratvec]: ##FPPB, FPPnew = FPPQuo,
    	 allLABELS =  ##(for d:#FPPB do for j:#FPPB[d] do (d,j) od od),
    	 maxLevis = [RealForm]: max_real_Levis(G)
{indices to convert from FPPQuo to allFPPQuo}
    then Index= ParamPol: index(allFPPB), Indices = [ParamPol]:
    	 for FPPQuod in FPPQuo do index(FPPQuod) od
    then JTFLs = [ [(bool,ratvec)] ]:
    	 for L in maxLevis
	 do
	 if old_facet_verbose then prints("starting JTF for Levi ",L,
	 " in facet_statusu_ind") fi;
	 JustTheFacts(L)
	 od
{ update FPPQuo working through Levis }
    then temp = for L@j in maxLevis
    do
    if old_facet_verbose then prints(new_line,"updating status using Levi ",L);
	 prints("in facet_statusu_ind, using ",#JTFLs[j]," representations on L.") fi;
    let xL = x_open(L), rhoL = L.rho
    then countUp = int: 0, countDown = int: 0
    in
    for (uboolL,gammaL) in JTFLs[j]
    	do
	let IgammaLstd = real_induce_standard(parameter(xL, rhoL, gammaL), G)
	then gammaG=first_param(IgammaLstd).infinitesimal_character
	then nG = find(Index, gammaG)
	then trouble = void: if nG = -1
	     then nG := find(Index,facet_bary(G,gammaG)) fi
	then bigTrouble = if nG=-1 then prints("TROUBLE at MaxLevi #",j,
	     "  which is ",L, ",  and gammaL = ",gammaL, ", gammaG = ",
	     	gammaG); break fi
	then (d,j) = allLABELS[nG]
	then FPPnewd = FPPnew[d], Find = FPPnew[d][j]
	in
	let result =
	    if FPPnew[d][j].status!="?"
	    then FPPnew[d][j].status
		{if inducing rep is unitary, so is induced, and facets
		    in closure}
	    elif uboolL then countDown := countDown+1;
	    	{FPPnew := downdate(Indices,
		FPPnew,("Ticlosure",FPPnew[d][j].verts));}
		updateTrue(G, FPPnew, FPPB, ("Tiopen",Find.verts), FPPB[d][j]); "Ti"
	    	{if inducing is hermitian nonunitary,
		    and induction is irreducible, then induced is hermitian
		    nonunitary, along with facets in opening}
	    elif #real_induce_irreducible(parameter(x_open(L),L.rho, gammaL),G) = 1
		     then countUp := countUp+1; FPPnew:= update(Indices, FPPnew, ("Fiopen",Find.verts)); "Fi"
	    else "?" { FPPnew[d][j].status }
	    fi
	    then temp = (); FPPnewd[j]:= (result,FPPnewd[j].verts)
	    in FPPnew[d] := FPPnewd
	od; if old_facet_verbose then prints("completed Levi ",j," using ",
	    countUp, " updates and ", countDown, " downdates") fi
    od; facet_verbose := old_facet_verbose
    in
    (vlist, FPPnew)

set facet_statusu_ind(RealForm G) = FacetData:
    let data_ind = FPP_vlist_indices_status(G)
    then data_indncH = down_to_business(G,data_ind)
    in facet_statusu_ind(G,data_indncH)

{.spherical unitarity data one simple factor at a time.}
set genSpherical(RealForm G) = [ ([ratvec],[[FacetStatusVertsIndex]]) ]:
for G0 in real_simple_factors(G) do spherical(G0) od


{.same as spherical using induced info.}
set spherical_ind(RealForm G) = FacetData:
    let dataIndInd = facet_statusu_ind(G)
    in spherical(G, dataIndInd)

{ still need simple derived group }
{need vlist to match FPP_vertex_sets_indices}

set spherical_ind_to_ht(RealForm G, int bound) = FacetData:
    let dataIndInd = facet_statusu_ind(G)
    in spherical_to_ht(G, dataIndInd, bound)

{.version for complex simple G.}
set spherical_indC(RealForm G) = FacetData:
    let GL = simple_factors(G)[0]
    then dataGL = FPP_vlist_indices_status(GL)
    then dataC = down_to_businessC(G,dataGL)
    then dataCuind = facet_statusu_ind(G,dataC)
    in sphericalC(G,dataCuind)

set spherical_ind_to_htC(RealForm G, int bound) = ([ratvec],[[FacetStatusVertsIndex]]):
    let GL = simple_factors(G)[0]
    then dataGL = FPP_vlist_indices_status(GL)
    then dataC = down_to_businessC(G,dataGL)
    then dataCuind = facet_statusu_ind(G,dataC)
    in spherical_to_htC(G, dataCuind, bound)

{idea is in a session to say
  >> FILENAME write(status,vlist,Cand)

Then in another session you can write
<< FILENAME
set STN=spherical_to_ht(G,(status,vlist,Cand),N)}

set write([[string]] status, [ratvec] vlist, [[FacetVertsIndex]] Cand) = void:
    prints("set status = ",status);
    prints("set vlist = ",vlist);
    prints("set Cand = [[vec]]:",Cand)


set leq([Param] Plist) = (int i, int j) bool:
    HTA(Plist[i]) <= HTA(Plist[j])

{.given a list Plist of Params, sort it according to HTA.}
set HTA_sort([Param] Plist) = [Param]:
    let listSorter = [int]: sort(leq(Plist))(#Plist)
    in [Param]: for j:#Plist do Plist[listSorter[j]] od

set cohom_ind(KGBElt x) = KGPElt:
    let G=x.real_form, theta = x.involution
    then fund_wts=fundamental_weights(G)
    then lambda = sum(G.rank, for v in fund_wts do
    	 if find(fund_wts,theta*v) =-1 then [] else [v] fi od.##)
    in parabolic_by_wt(lambda,x)

set hardKGB(RealForm G) = [KGBElt]:
     for x in KGB(G)
     do if cohom_ind(x).Levi = G then [x] else [] fi
     od.##

{.Meant to refer to a particular KGBElt x and a particular list of
FacetBary's FB[d]; (j,lr) means that there is a parameter (x,lr+rho,nu)
of infinitesimal character FB[d][j].}
set_type CandLambda = (int,vec)

{.The dth term of facet_barycenters is a complete list of barycenters of
d-dimensional facets. The dth term of candidate_lambdas is a list of
pairs (j,lr) so that the jth facet is represented at KGB_Elt
by lambda-rho = lr.} 

set_type KGBFacets = (KGBElt KGB_elt, [[FacetBary]]
facet_barys, [[CandLambda]] cand_lambdas)

{.Find barycenters in FPP defining a good lambda for KGBElt x.}
{dth term in result lists which entries of FB[d][j] qualify, and gives
qualifying lambda0 = lambda-rho}

set goodFPP(KGBElt x, [[FacetBary]] FB) = KGBFacets:
    let rho = rho(x.real_form), th1 = 1+involution(x)
    in
    (x, FB, for FBd in FB
    do for v@j in FBd
       do
       case vec_solve(th1,th1*(v-rho))
       | else [(int,vec)]: [] {if no solns, this facet can't occur}
       | solution (lr): [(j,lr)]
       esac
       od.##
    od)

{.Meant to refer to a particular KGBElt x, a particular list of
FacetBary's FB[d], and the list comp_chars of elements of X*
representing chraacters of the component group of H(x).
(j,lr,v, NRH, [FacetStatus]) means that for each coordinate k@m of v, there is a
final hermitian parameter (x,lr+rho+comp_chars[k],nu) of infinitesimal
character FB[d][j], whose unitarity status is recorded by the mth
entry of [FacetStatus]. The mth entry of NRH is the number of
reducibility hyperplanes for this facet at
(x,lr+rho+comp_chars[k],*). }
set_type CandLambdaTwistsStatus = (int x, vec lambda0 , vec
twists, vec NRH, [string] status)

{.Supplement KGBFacets by including list comp_chars of elements of X^*
representing all characters of component group of Cartan for KGB_elt;
then [[(vec,[string])]] recording for each cand_lambda (j,lr) a
twist_status (whose
entries index the twists of lr giving hermitian final Params, }

set_type KGBFacetsTwists = (KGBElt KGB_elt, [[FacetBary]]
facet_barys, [vec] comp_chars, [[CandLambdaTwistsStatus]] twist_statuses)

{.Find hermitian irrs with final param involving x, not good range
cohom induced.}
{Third coord of triple, list of elts of [0,2^n),  says which twists of lambda0
are allowed}
{cand_lambda_rho meant to come from goodFPP}

set non_cohom_herm(KGBFacets (x, FB,  CLs)) = KGBFacetsTwists:
    let all_d_zero = all_lambda_differential_0(x),
    rho=rho(x.real_form), theta = x.involution
    in (x, FB, all_d_zero,
    for CLsd@d in CLs
    do for (j,lr) in CLsd
       do let gamma = FB[d][j]
       	  then twists = vec: for v@k in all_d_zero
       	  do let p=parameter(x, lr+rho+v, gamma)
       	  in
       	  if not(is_zero(p)) and p.infinitesimal_character=gamma
	     and first_param(finalize(p)).x = x and is_hermitian(p)
	  then [k] else [] fi
       	  od.##
       	  then NRH = vec: for k in twists
	       	     do NumRedHyps(parameter(x,lr+rho+all_d_zero[k], gamma))
    		     od
       	  in if #twists  > 0 then [(j,lr,twists, NRH, [string]: for k:#twists
       	  do "?" od)] else [] fi
     od.##
    od)

{probably this is all unitary attached to x that are not cohom
induced}
set non_cohom_unitary(KGBFacetsTwists (x, FB, twists, CLTs)) =
(KGBElt,[vec],[[CandLambdaTwistsStatus]]):
    let rho = rho(x.real_form) in 
    (x, twists,
    for CLTsd@d in CLTs
    do for (j,lr,which_twists, NRH, status) in CLTsd
       do let ustatus = for k@m in which_twists
       	  do let p=parameter(x, lr+rho+twists[k], FB[d][j])
	  in
	  if is_unitary(p) then "T" else "F" fi
	  od
       in (j,lr,which_twists,NRH,ustatus)
       od
    od
    )

set non_cohom_unitary(KGBElt x) = (KGBElt,[vec],[[CandLambdaTwistsStatus]]):
    non_cohom_unitary(non_cohom_herm(goodFPP(x,
    FPP_barycenters(x.real_form))))

{.goodFPP for all hard_KGB elements.}
set goodFPP(RealForm G, [[FacetBary]] FB) = [(KGBElt, [[CandLambda]])]:
    let hard_KGB = hardKGB(G) in
    for x in hard_KGB do let (,,CLs) = goodFPP(x, FB) in  (x,CLs) od


set non_cohom_herm(RealForm G, [[FacetBary]] FB, [(KGBElt,
    [[(int,vec)]])] cand_lambda_rho) = [(KGBElt,[vec],
		[[CandLambdaTwistsStatus]])]:
    let rho = rho(G) in
	for (x, CLs) in cand_lambda_rho
	do let (,,twists,candTws) =
    	   non_cohom_herm(x,FB,CLs) in (x,twists,candTws) od

set non_cohom_unitary(RealForm G, [[FacetBary]] FB, [(KGBElt, [vec],
    [[CandLambdaTwistsStatus]])] candTw) = [(KGBElt,[vec],
    [[CandLambdaTwistsStatus]])]:
    for (x, twists, CLs) in candTw do non_cohom_unitary(x,FB,twists,
    CLs) od

set non_cohom_unitary(RealForm G) = [(KGBElt,[vec],
    [[CandLambdaTwistsStatus]])]:
    let FB =  FPP_barycenters(G) in non_cohom_unitary(G, FB,
    non_cohom_herm(G, FB, goodFPP(G,FB)))

set show(RealForm G, [[FacetBary]] FB,
[(KGBElt,[vec],[[CandLambdaTwistsStatus]])] candTW) = void:
    let rho = rho(G) in 
    prints("Non-cohomologically induced unitary reps for ",G);
    for (x,twists,CLTs) in candTW
    do
    prints(new_line,x);
    	for CLTsd@d in CLTs
	do
	    for (j,lr,which_twists,NRH,statuses) in CLTsd
	    do
		for k@m in which_twists
	    	do
		if statuses[m][0] = "T" then
		   prints(parameter(x, lr+rho+twists[k], FB[d][j]),
		   "  ",FB[d][j])
		fi
		od
	    od
	od
     od

set show_non_cohom_unitary(RealForm G) = void:
    let FB=FPP_barycenters(G), NCU = non_cohom_unitary(G)
    in
    show(G, FB, NCU)


