<structure_constants.at

set st_verbose=false

{delta(epsilon,w,alpha) defined by:
 (epsilon is an orientation function taking simple roots to \pm 1)
 we're given {X_\alpha|alpha simple}, this also defines {X_{-alpha}| alpha simple}
 also given epsilon => X_\beta is defined for all roots beta
 these satisfy:
  suppose \beta=w\alpha (alpha simple)
  define a sign delta(epsilon,w,alpha0 by:
    X_beta=delta(epsilon,w,alpha) Ad(sigma_w)(X_alpha)  (we know X_beta = Ad(sigma_w)(X_alpha) up to a sign)
  the signs delta(epsilon,w,alpha) can be computed inductively:

1) delta(epsilon,s_i,alpha)=-(-1)^{m_i^-(alpha)}epsilon(i)^{<alpha,alpha_i^v>}
     here m_i^-(alpha) = m_{alpha_i}^-(alpha) (see structure_constants.at) is defined as in Geck (for alpha\ne\pm \alpha_i)
     and = 1 if alpha=\pm alpha_i.
2) delta(epsilon,xs_i,alpha)=delta(epsilon,s_i,alpha)delta(epsilon,x,s_i\alpha)   if length(xs_i)=l(x)+1

So we define delta(epsilon,w,alpha) by this formula, and use it to define X_beta for all beta}

{delta_simple(epsilon,s_i,alpha)=-(-1)^[m^-_i(alpha)]epsilon(i)^[-<alpha,alpha_i^v>]}
set delta_simple(RootDatum G,orientation epsilon,int i, vec alpha)=
  (-1)*(-1)^(m_minus(G,i,alpha))*(epsilon(i)^(-alpha*G.simple_coroots[i]))

set delta_simple(orientation epsilon,WeylElt s {must be a simple reflection},vec alpha)=
assert(length(s)=1,"s is not a simple reflectionn");
let i=word(s)[0] in delta_simple(s.root_datum,epsilon,i,alpha) 

set chop_right(WeylElt w)=(WeylElt,WeylElt):
let rd=w.root_datum in 
if length(w)=0
  then (id_W(rd),id_W(rd))
elif length(w)=1
  then (id_W(rd),w)
else
  let word=word(w) in
(W_elt(rd,word[:#word-1]),W_elt(rd,[word~[0]]))
fi



{inductive computation of delta(epsilon,x,alpha)}
set delta(orientation epsilon,WeylElt w,vec alpha)=int:
(rec_fun f(orientation epsilon,WeylElt w,vec alpha) int:
let ()=if st_verbose then prints("calling f: ", "w=", w, " alpha=", alpha)  fi in 
  let rd=w.root_datum in 
  if length(w)=0
   then let ()=if st_verbose then prints("length 0") fi in 1
  elif length(w)=1
   then let ()=if st_verbose then prints("length 1:", " w=",w, " alpha=", alpha, new_line,"delta(w,alpha): ", delta_simple(epsilon,w,alpha)) fi in delta_simple(epsilon,w,alpha)
  else
   let ()= if st_verbose then prints("3rd case", " w=", w, " alpha=", alpha) fi  in
   let (x,y)=chop_right(w) in
   let ()=if st_verbose then prints("*w=",w, " alpha=",alpha," y*alpha=",y*alpha,"  x=",x," y=",y," delta(y,alpha)=",delta_simple(epsilon,y,alpha), " f(x,y*alpha)=", f(epsilon,x,y*alpha)) fi in
   let df=delta_simple(epsilon,y,alpha)*f(epsilon,x,y*alpha) in 
   let ()= if st_verbose then prints("w:", w, " alpha:", alpha, "  delta(w,alpha): ", df) fi in
   df
fi) (epsilon,w,alpha)

set delta(orientation epsilon,WeylElt w,int i)=int:delta(epsilon,w,w.root_datum.simple_roots[i])

set test(RootDatum G,orientation epsilon,WeylElt w, int i)=bool:
let alpha=G.simple_roots[i] in 
delta(epsilon,w,alpha)*delta(epsilon,w,-alpha)*(-1)^(height(G)(w*alpha))=-1

set signtest(RootDatum G)=
 for w in G.W do for i:ss_rank(G) do test(G,orientation_function(G),w,i) od od

{this function is needed when consdering subgroups}

{we're given a pinning, defining the Tits group, generated by sigma_i=sigma(s_i)  s_i a simple reflection
 also given epsilon we have defined X_beta for all beta
 Note that [X_beta,X_{-beta}] = (-1)^{ht(beta)}h_beta (see Geck Theorem 5.7)
 this implies we need to define
 tau^epsilon_beta=tau_beta=exp(X_beta)exp(-(-1)^{ht(beta)}X_{-beta})exp(X_beta)
 because then [X_beta, (-1)^{ht(beta)}X_{-beta}]= h_beta as needed for this to make sense


 tau^epsilon_beta = sigma^epsilon_{s_i}  (= sigma^epsilon_i) if beta is the i^th simple root

otherwise write beta=w\alpha_i then

tau^epsilon_beta=sigma_w\sigma_i\sigma_w^{-1}*h

where h = 1 if delta(epsilon,w,alpha)=1 or h_alpha if delta(epsilon,w,alpha)=-1
}

set tau(RootDatum G,orientation epsilon, vec beta)=Tits_elt:
if is_simple_root(G,beta)
 then tits_simple_reflection(G,beta)
else
 let w=conjugate_to_simple(G,beta) then  {w*simple=beta}
 alpha=inverse(w)*beta then
 i=root_index(G,alpha) then
 ()=prints(i) then
 sigma=tits_element(G,w) then
 delta=delta(epsilon,w,i) then
 torus_factor=
  if delta=1
     then null(rank(G))
  else 
     G.simple_coroots[i]
  fi
 in tits_element(G,torus_factor,w)
fi

set tau(RootDatum G, vec beta)=Tits_elt:tau(G,orientation_function(G),beta)


{   embedding of Tits group of equal rank subgroups }
{assumption: roots of H are a subset of those of G}

{map_tits_simple_reflection(H,G,epsilon,v,alpha_H)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,orientation epsilon,ratvec v,vec alpha_H)=Tits_elt:
assert(is_simple_root(H,alpha_H),"alpha_H is not simple for H");
tau(G,epsilon,alpha_H)

{map_tits_simple_reflection(H,G,epsilon,alpha_H)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,orientation epsilon,vec alpha_H)=Tits_elt:
map_tits_simple_reflection(H,G,epsilon,null(rank(G)),alpha_H)

{i is the index in H of a simple root: alpha_H =H.simple_roots[i] (might not be simple for G)}
{map_tits_simple_reflection(H,G,epsilon,v,i)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,orientation epsilon,int index_H)=Tits_elt:
assert(0<=index_H and index_H<H.ss_rank,"i is not the index of a simple root for H");
map_tits_simple_reflection(H,G,epsilon,null(rank(G)),H.simple_roots[index_H])

{map_tits_simple_reflection(H,G,alpha_H)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,vec alpha_H)=Tits_elt:map_tits_simple_reflection(H,G,orientation_function(G),alpha_H)

{map_tits_simple_reflection(H,G,i)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,int i)=Tits_elt:map_tits_simple_reflection(H,G,H.simple_roots[i])

{map_tits_simple_reflection(H,G,epsilon,w)}
set map_tits_element(RootDatum H,RootDatum G, orientation epsilon,WeylElt w_H)=Tits_elt:
let rv=tits_identity(G) in
for i in word(w_H) do rv*:=map_tits_simple_reflection(H,G,epsilon,i) od;
rv

{map_tits_simple_reflection(H,G,w)}
set map_tits_element(RootDatum H,RootDatum G,WeylElt w_H)=Tits_elt:map_tits_element(H,G,orientation_function(G),w_H)

{map_tits_simple_reflection(H,G,epsilon,theta)}
set map_tits_element(RootDatum H,RootDatum G, orientation epsilon,mat theta_H)=Tits_elt:
map_tits_element(H,G,epsilon,W_elt(H,theta_H))

{map_tits_simple_reflection(H,G,epsilon,sigma_H}
set map_tits_element(RootDatum H,RootDatum G,orientation epsilon,Tits_elt sigma_H)=Tits_elt:
let product=simple_expression(sigma_H) then   {sigma_H=product of tits simple reflections}
rv=tits_identity(G) in
for sigma in product do prints("rv=",rv);rv*:=sigma od;rv




{set map_tits_simple_reflection(RootDatum H,RootDatum G,int i)=Tits_elt:map_tits_simple_reflection(H,G,orientation_function(G),i)
set map_tits_element(RootDatum H,RootDatum G,WeylElt w)=Tits_elt:map_tits_element(H,G,orientation_function(G),w)



{Suppose H\subset G is an equal rank subgroup, so WLOG the fixed torus T\subset H
 let S_H be the simple roots of H}
 


