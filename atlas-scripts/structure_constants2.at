<structure_constants.at

set st_verbose=false

{delta(epsilon,w,alpha) defined by:
 (epsilon is an orientation function taking simple roots to \pm 1)
 we're given {X_\alpha|alpha simple}, this also defines {X_{-alpha}| alpha simple}
 also given epsilon => X_\beta is defined for all roots beta
 these satisfy:
  suppose \beta=w\alpha (alpha simple)
  define a sign delta(epsilon,w,alpha0 by:
    X_beta=delta(epsilon,w,alpha) Ad(sigma_w)(X_alpha)  (we know X_beta = Ad(sigma_w)(X_alpha) up to a sign)
  the signs delta(epsilon,w,alpha) can be computed inductively:

1) delta(epsilon,s_i,alpha)=-(-1)^{m_i^-(alpha)}epsilon(i)^{<alpha,alpha_i^v>}
     here m_i^-(alpha) = m_{alpha_i}^-(alpha) (see structure_constants.at) is defined as in Geck (for alpha\ne\pm \alpha_i)
     and = 1 if alpha=\pm alpha_i.
2) delta(epsilon,xs_i,alpha)=delta(epsilon,s_i,alpha)delta(epsilon,x,s_i\alpha)   if length(xs_i)=l(x)+1

So we define delta(epsilon,w,alpha) by this formula, and use it to define X_beta for all beta}

{delta_simple(epsilon,s_i,alpha)=-(-1)^[m^-_i(alpha)]epsilon(i)^[-<alpha,alpha_i^v>]}
set delta_simple(RootDatum G,orientation epsilon,int i, vec alpha)=
  (-1)*(-1)^(m_minus(G,i,alpha))*(epsilon(i)^(-alpha*G.simple_coroots[i]))

set delta_simple(orientation epsilon,WeylElt s {must be a simple reflection},vec alpha)=
assert(length(s)=1,"s is not a simple reflectionn");
let i=word(s)[0] in delta_simple(s.root_datum,epsilon,i,alpha) 

set chop_right(WeylElt w)=(WeylElt,WeylElt):
let rd=w.root_datum in 
if length(w)=0
  then (id_W(rd),id_W(rd))
elif length(w)=1
  then (id_W(rd),w)
else
  let word=word(w) in
(W_elt(rd,word[:#word-1]),W_elt(rd,[word~[0]]))
fi



{inductive computation of delta(epsilon,x,alpha)}
set delta(orientation epsilon,WeylElt w,vec alpha)=int:
(rec_fun f(orientation epsilon,WeylElt w,vec alpha) int:
let ()=if st_verbose then prints("calling f: ", "w=", w, " alpha=", alpha)  fi in 
  let rd=w.root_datum in 
  if length(w)=0
   then let ()=if st_verbose then prints("length 0") fi in 1
  elif length(w)=1
   then let ()=if st_verbose then prints("length 1:", " w=",w, " alpha=", alpha, new_line,"delta(w,alpha): ", delta_simple(epsilon,w,alpha)) fi in delta_simple(epsilon,w,alpha)
  else
   let ()= if st_verbose then prints("3rd case", " w=", w, " alpha=", alpha) fi  in
   let (x,y)=chop_right(w) in
   let ()=if st_verbose then prints("*w=",w, " alpha=",alpha," y*alpha=",y*alpha,"  x=",x," y=",y," delta(y,alpha)=",delta_simple(epsilon,y,alpha), " f(x,y*alpha)=", f(epsilon,x,y*alpha)) fi in
   let df=delta_simple(epsilon,y,alpha)*f(epsilon,x,y*alpha) in 
   let ()= if st_verbose then prints("w:", w, " alpha:", alpha, "  delta(w,alpha): ", df) fi in
   df
fi) (epsilon,w,alpha)

set delta(orientation epsilon,WeylElt w,int i)=int:delta(epsilon,w,w.root_datum.simple_roots[i])

set test(RootDatum G,orientation epsilon,WeylElt w, int i)=bool:
let alpha=G.simple_roots[i] in 
delta(epsilon,w,alpha)*delta(epsilon,w,-alpha)*(-1)^(height(G)(w*alpha))=-1

set signtest(RootDatum G)=
 for w in G.W do for i:ss_rank(G) do test(G,orientation_function(G),w,i) od od

{this function is needed when consdering subgroups}

{we're given a pinning, defining the Tits group, generated by sigma_i=sigma(s_i)  s_i a simple reflection
 also given epsilon we have defined X_beta for all beta
 Note that [X_beta,X_{-beta}] = (-1)^{ht(beta)}h_beta (see Geck Theorem 5.7)
 this implies we need to define
 tau^epsilon_beta=tau_beta=exp(X_beta)exp(-(-1)^{ht(beta)}X_{-beta})exp(X_beta)
 because then [X_beta, (-1)^{ht(beta)}X_{-beta}]= h_beta as needed for this to make sense


 tau^epsilon_beta = sigma^epsilon_{s_i}  (= sigma^epsilon_i) if beta is the i^th simple root

otherwise write beta=w\alpha_i then

tau^epsilon_beta=sigma_w\sigma_i\sigma_w^{-1}*h

where h = 1 if delta(epsilon,w,alpha)=1 or h_alpha if delta(epsilon,w,alpha)=-1
}

set tau(RootDatum G,orientation epsilon, vec beta)=Tits_elt:
if is_simple_root(G,beta)
 then tits_simple_reflection(G,beta)
else
 let conj=conjugate_to_simple(G,beta) then  {conj*simple=beta}
 alpha=inverse(conj)*beta then
 i=root_index(G,alpha) then
 sigma=tits_element(G,conj)*tits_simple_reflection(G,alpha)*inverse(tits_element(G,conj)) then
 delta=delta(epsilon,conj,i) then
 torus_factor=
  if delta=1
     then null(rank(G))
  else 
     G.simple_coroots[i]
  fi
 in left(torus_factor,sigma)
fi

set tau(RootDatum G, vec beta)=Tits_elt:tau(G,orientation_function(G),beta)


{   embedding of Tits group of equal rank subgroups }
{assumption: roots of H are a subset of those of G}

{map_tits_simple_reflection(H,G,epsilon,v,alpha_H)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,orientation epsilon,ratvec v,vec alpha_H)=Tits_elt:
assert(is_simple_root(H,alpha_H),"alpha_H is not simple for H");
tau(G,epsilon,alpha_H)

{map_tits_simple_reflection(H,G,epsilon,alpha_H)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,orientation epsilon,vec alpha_H)=Tits_elt:
map_tits_simple_reflection(H,G,epsilon,null(rank(G)),alpha_H)

{i is the index in H of a simple root: alpha_H =H.simple_roots[i] (might not be simple for G)}
{map_tits_simple_reflection(H,G,epsilon,v,i)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,orientation epsilon,int index_H)=Tits_elt:
assert(0<=index_H and index_H<H.ss_rank,"i is not the index of a simple root for H");
map_tits_simple_reflection(H,G,epsilon,null(rank(G)),H.simple_roots[index_H])

{map_tits_simple_reflection(H,G,alpha_H)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,vec alpha_H)=Tits_elt:map_tits_simple_reflection(H,G,orientation_function(G),alpha_H)

{map_tits_simple_reflection(H,G,i)}
set map_tits_simple_reflection(RootDatum H,RootDatum G,int i)=Tits_elt:map_tits_simple_reflection(H,G,H.simple_roots[i])

{map_tits_simple_reflection(H,G,epsilon,w)}
set map_tits_element(RootDatum H,RootDatum G, orientation epsilon,WeylElt w_H)=Tits_elt:
let rv=tits_identity(G) in
for i in word(w_H) do rv*:=map_tits_simple_reflection(H,G,epsilon,i) od;
rv

{map_tits_simple_reflection(H,G,w)}
set map_tits_element(RootDatum H,RootDatum G,WeylElt w_H)=Tits_elt:map_tits_element(H,G,orientation_function(G),w_H)

{map_tits_simple_reflection(H,G,epsilon,theta)}
set map_tits_element(RootDatum H,RootDatum G, orientation epsilon,mat theta_H)=Tits_elt:
map_tits_element(H,G,epsilon,W_elt(H,theta_H))

{sigma_H must be tits element of a simple reflection}
set map_tits_element_simple(RootDatum H,RootDatum G,orientation epsilon,Tits_elt sigma_H)=Tits_elt:
let w=w(sigma_H) in 
assert(length(w(sigma_H))=1,"not the tits element of a simple reflection");
tits_element(left(sigma_H.torus_part,map_tits_simple_reflection(H,G,epsilon,w.word[0])))

set map_tits_element(RootDatum H,RootDatum G,orientation epsilon,Tits_elt sigma_H)=Tits_elt:
if length(sigma_H.w)=0 then
 left(sigma_H.torus_part,tits_identity(G))
else
 let product=simple_expression(sigma_H) then   {sigma_H=product of tits simple reflections}
 ()=prints("product=", product) then
 {rv=left(sigma_H.torus_part,tits_identity(G)) in}
 rv=tits_identity(G) in
 let ()=prints("rv starting: ", rv) in 
 for sigma@j in product do prints("j=",j,new_line,"rv=",rv,"  sigma=",sigma);rv*:=map_tits_element_simple(H,G,epsilon,sigma) od;prints("got rv: ", rv);rv
fi

set embed_tits_group(RootDatum H,RootDatum G,orientation epsilon)=[Tits_elt]:
for w in H.W do map_tits_element(H,G,epsilon,sigma(H,w)) od

set embed_tits_group(RootDatum H,RootDatum G)=[Tits_elt]:
embed_tits_group(H,G,orientation_function(G))



set test_tits_braid(RootDatum G)=
let ops=for i:ss_rank(G) do tits_simple_reflection(G,i) od in 
let results=##for i:G.ss_rank do
 for j:G.ss_rank do
  if i=j then (i,j,ops[i]^4=tits_identity(G))
 else
  let m=m(G,i,j) in
   let ()=prints("i ", i, " ", j) in
   if m=0 then (i,j,ops[i]*ops[j]=ops[j]*ops[i]) 
   elif m=1 then (i,j,ops[i]*ops[j]*ops[i]=ops[j]*ops[i]*ops[j])
   elif m=2 then (i,j,ops[i]*ops[j]*ops[i]*ops[j]=ops[j]*ops[i]*ops[j]*ops[i])
   elif m=3 then (i,j,ops[i]*ops[j]*ops[i]*ops[j]*ops[i]*ops[j]=ops[j]*ops[i]*ops[j]*ops[i]*ops[j]*ops[i])
   else error("m>3???")
  fi
fi
od od
then all=all(for (,,tf) in results do tf od) in
if not all then prints(results) fi ;all

set test_tits_braid(RootDatum H,RootDatum G)=
let ops=for i:ss_rank(H) do map_tits_simple_reflection(H,G,i) od in 
let results=##for i:H.ss_rank do
 for j:H.ss_rank do
  if i=j then (i,j,ops[i]^4=tits_identity(G))
 else
  let m=m(G,H.simple_roots[i],H.simple_roots[j]) in
   let ()=prints("i ", i, " ", j, " ", m) in
   if m=0 then (i,j,ops[i]*ops[j]=ops[j]*ops[i]) 
   elif m=1 then (i,j,ops[i]*ops[j]*ops[i]=ops[j]*ops[i]*ops[j])
   elif m=2 then (i,j,ops[i]*ops[j]*ops[i]*ops[j]=ops[j]*ops[i]*ops[j]*ops[i])
   elif m=3 then (i,j,ops[i]*ops[j]*ops[i]*ops[j]*ops[i]*ops[j]=ops[j]*ops[i]*ops[j]*ops[i]*ops[j]*ops[i])
   else error("m>3???")
  fi
fi
od od
then all=all(for (,,tf) in results do tf od) in
if not all then prints(results) fi ;all 

set tits(KGBElt x)=Tits_elt:(x.real_form,x.unnormalized_torus_factor,x.involution)
set KGB_elt (Tits_elt t)=KGB_elt(t.root_datum,t.theta,2*t.torus_part-t.root_datum.rho_check)

set embed_KGB_tits(RealForm Gd, orientation epsilon, KGBElt x_Hd)=KGBElt:
let Hd=x_Hd.real_form then
sigma_Hd=tits(x_Hd) {this has unnormalized torus factor} then
 sigma_Gd=map_tits_element(Hd,Gd,epsilon,sigma_Hd) {uses unnormalized torus factor from Hd} then
 x_Gd=KGB_elt(sigma_Gd) {when making x_Gd, input sigma_Gd has unnormalized torus factor, x get normalized torus_factor} in
 x_Gd

set embed_KGB_tits(RealForm Gd,KGBElt x_Hd)=KGBElt:embed_KGB_tits(Gd,orientation_function(Gd),x_Hd)

set embed_KGB_tits(RealForm Hd,RealForm Gd, orientation epsilon)=[KGBElt]:
for x in KGB(Hd) do embed_KGB_tits(Gd,epsilon,x) od

set embed_KGB_tits(RealForm Hd,RealForm Gd)=[KGBElt]:
for x in KGB(Hd) do embed_KGB_tits(Gd,x) od

