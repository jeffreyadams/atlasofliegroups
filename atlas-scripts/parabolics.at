<W_orbit.at

{! See "Parabolic Subgroups and Induction", in dropbox, ultimately on atlas web site.

  Fix a subset S of the simple roots, defining the complex standard
  parabolic $P_S$ of type S. We define a set KGP(S) (a
  quotient of KGB) such that (roughly) KGP(S) <-> $K\backslash G/P_S$.

  More precisely, for any $x\in$ KGB and $p(\xi)=x$,
  KGP(S) is canonically in bijection with $K_{\xi}\backslash G/P_S$; i.e.,
  $K_{\xi}$ conjugacy classes of parabolics of type S.

  K orbits on $G/P_S$, equivalently K-conjugacy classes of parabolics of type S:
  Given a RealForm and a subset S of the simple roots,
  S -> partial order on KGB, generated by ascents in S
    -> equivalence relation generated by this
  KGB/equivalence <-> $K\backslash G/P_S$
  Define KGP to be KGB modulo this equivalence.

  Data: ([int],KGBElt)=(S,x) where S lists the indices of a subset of the
  simple roots of root_datum(x)

  Equivalence: (S,x)=(S',y) if these correspond to the same K orbit on $G/P_S$,
  which means:
   real_form(x)=real_form(y), S=S'  (i.e. same complex parabolic), and
   x=y in the equivalence defined by S.
  In particular, given (S,x), taking x itself for the strong real form,
  (S,x) goes to the $K_x$-conjugacy class of the standard parabolic $P_S$.

  The data type is KGPElt or Parabolic (synonyms).

  Given (S,x),
  write $[x_1,...,x_n]$ for the S-equivalence class of $x\subset$ KGB.

  The last element $x_n$ is maximal, and is uniquely determined.
  This orbit of K on $G/P_S$ is closed <=> $x_1$ is closed in KGB.

  ComplexParabolic data type:
  (RootDatum rd,[int] S) <->  G-conjugacy class of standard parabolic with
  Levi factor given by subset S of simple roots

More topics addressed in this file:
  parabolics with $\theta$-stable Levi factor;
  $\theta$-stable parabolics;
  real parabolics.
!}

<misc.at { for is_simple_root }
<sort.at { for inv_standardisation }
<Weylgroup.at { for |cross@(WeylElt,KGBElt)| }
<group_operations { for is_relatively_split }


set_type
[
  {. Data type for a K_orbit on G/P_S, equivalently a K-conjugacy class of
    parabolics of type S, where S is a list of simple root indices. .}
  KGPElt    = ([int] S, KGBElt x)
,
  {. Data type for a complex standard parabolic subgroup .}
  ComplexParabolic = (RootDatum root_datum,[int] S)
]

{. Data type for a K_orbit on G/P_S (synonym for KGPElt). .}
set_type Parabolic = KGPElt
{. Data type for a complex Levi=pair of root data.}
set_type ComplexLevi  = (RootDatum rd,RootDatum rd_Levi)
{ assumption:
  the set of simple roots/coroots of rd_Levi is a subset of those of rd_G }


{. choose from a list of KGB elements one with the smallest index number. .}
set min ([KGBElt] list)= KGBElt:
  let m=list[0] in for x in list do if #x<#m then m:=x fi od; m

{. choose from a list of KGB elements one with the greatest index number. .}
set max ([KGBElt] list) = KGBElt:
  let m=list[0] in for x in list do if #x>#m then m:=x fi od; m

{. the root datum of the RealForm G of a KGP element. .}
set root_datum (KGPElt(,x)) = RootDatum: root_datum(x)

{. the RealForm G of a KGP element. .}
set real_form  (KGPElt(,x)) = RealForm:  real_form(x)

{. ascents of |x| by generators in |S|; there may be duplicates. .}
set ascents ([int] S, KGBElt x) = [KGBElt]:
##for s in S
  do case status(s,x)
     in [], [], [] { descents }, { nc } [Cayley(s,x)], { C+ } [cross(s,x)]
     esac
  od

{. all descents of |x| by generators in |S|; there may be duplicates. .}
set down_neighbors ([int] S,KGBElt x) = [KGBElt]:
##for s in S
  do case status(s,x)
     in { C- } [cross(s,x)]
     , { ic } []
     , { r } let y=Cayley(s,x) in [y,cross(s,y)]
     , { nc } []
     , { C+ } []
     esac
  od

{. decide whether x is maximal in the partial order defined by S. .}
set is_maximal_for ([int] S,KGBElt x) = bool: =#ascents(S,x)

{. list maximal KGB elements in the partial order defined by S. .}
set maxima_for ([int] S,RealForm G) = [KGBElt]:
##for x in KGB(G)
  do if is_maximal_for(S,x) then [x] else [] fi od

{. (Unique) maximal element in equivalence class of x. .}
set maximal ([int] S, KGBElt x) = KGBElt:
  while let r=ascents(S,x) in (#r).> do x:=r[0] od; x

{. a minimal KGB element from an equivalence class defined by S
   (unlike |maximal(S,x)|, it is not unique). .}
set x_min (KGPElt(S,x)) = KGBElt:
  while let D=down_neighbors(S,x) in (#D).> do x:=D[0] od; x


{. build KGBElt (with canonical representative) from |S| and |x|. .}
set KGP_elt_for (KGPElt(S,):S_x) = KGPElt: (S,maximal(S_x))

{. (Unique) maximal KGB element representing a KGP element. .}
set representative = (KGPElt->KGBElt): maximal@KGPElt

{. equality of KGP elements: whether they share a K-orbit of parabolics. .}
set = (KGPElt (S,x):S_x,KGPElt (T,y):T_y)=bool:
  real_form(x)=real_form(y) and S=T and maximal(S_x)=maximal(T_y)

{. the equivalence class of a KGB element in partial order defined by S. .}
set equivalence_class_of (KGPElt(S,x):S_x) = [KGBElt]:
  let G=real_form(x), x_max=maximal(S_x)
  then todo=[x_max], seen=0, in_class = for :#x_max do false od # true
  in
  while seen < #todo
  do
    for x in down_neighbors(S,todo[seen]) next seen +:= 1
    do if not in_class[#x] then in_class[#x] := true; todo #:= x fi od
  od; { return |todo.(sort_by(#@KGBElt))|, but maybe more efficiently: }
  ## for present@i in in_class do if present then [KGB(G,i)] else [] fi od

set is_in_class_of (KGBElt x, KGPElt(S,):P) = bool:
   maximal(S,x) = maximal(P)

{. the set of KGP elements associated to a RealForm and a set of
simple roots S; KGP(G,S) is in bijection with $K\backslash G/P_S$. .}
set KGP (RealForm G,[int] S) = [KGPElt]:
  for x in maxima_for(S,G) do KGPElt:(S,x) od

{. just the index numbers (maximal x) of KGP(G,S). .}
set KGP_numbers (RealForm G,[int] S) =[int]: for (,x) in KGP(G,S) do #x od

{. whether y in $K\backslash G/P_S$ is open (maximal(y) is final in KGB). .}
set is_open (KGPElt y) = bool:
  is_maximal_for(all_simples(y.root_datum),maximal(y))

{. test whether y in $K\backslash G/P_S$ is closed (length(first element)=0). .}
set is_closed (KGPElt P) = bool: length(x_min(P)).=

{. parabolic determined by (the stabilizer in W of) a weight lambda. .}
set KGP_elt (ratvec lambda,KGBElt x) = KGPElt:
  let rd=root_datum(x)
  then (w,lambda_dom)=from_dominant(rd,lambda.numer)
  then P = list(semisimple_rank(rd),(int i)bool: =coroot(rd,i)*lambda_dom)
  in KGPElt:(P,cross(inverse(w),x))

{. the complex parabolic underlying P=(S,x). .}
set complex_parabolic (KGPElt(S,x)) = ComplexParabolic: (root_datum(x),S)


{			Complex Levi subgroups				}

{. auxiliary function .}
set complex_Levi (RootDatum rd, (int->bool) select) = RootDatum:
  root_datum(columns_with(select,simple_roots(rd))
                ,columns_with(select,simple_coroots(rd)))

{. Root datum of the Levi factor of a complex parabolic. .}
set complex_Levi (RootDatum rd,[int] S) =RootDatum:
  complex_Levi(rd,is_member(S))

{. Test if a complex Levi defined by a set of simple roots $S$ is
  $\theta_x$-stable;
  algorithm: H=sum of fundamental coweights with index not in S,
  test whether $<\theta_x(\alpha),H>=0$ for all $\alpha$ in S. .}
set has_theta_stable_Levi (Parabolic(S,x)) = bool:
  let rd=root_datum(x)
  then H = { coweight measuring level of roots alpha[t] not in the Levi factor }
    sum(for t in complement(rd.semisimple_rank,S)
        do fundamental_coweight(rd,t) od, rd.rank)
  in = H*involution(x)*columns_with(is_member(S),simple_roots(rd))

{. Make a real Levi factor from P=(S,x); the complex Levi of S must
be theta-stable. .}
set Levi (Parabolic(S,x):P) = RealForm:
  assert(has_theta_stable_Levi(P),"Levi factor is not theta-stable");
  let x_min=x_min(P) then theta=involution(x_min)
  then ic_Levi=inner_class(complex_Levi(root_datum(x),S),theta)
  in { synthetic } real_form(ic_Levi,theta,torus_factor(x_min))

{. Test if parabolic P=(S,x) is theta-stable: <=>
   the complex Levi factor L is theta-stable, P is closed, and for
   alpha simple, not in S => alpha is imaginary or C+ wrt maximal(P). .}
set is_parabolic_theta_stable (Parabolic(S,x):P) = bool:
  has_theta_stable_Levi(P) and is_closed(P) and
  ( let x_max=maximal(P) in
    none(for j in complement(semisimple_rank(root_datum(x)),S)
         do is_strict_descent(j,x_max) { C- or real }
         od)
  )

{. Test if parabolic P=(S,x) is real: <=> L is theta-stable, P is open, and
   for alpha simple, not in S => alpha is real or C- wrt a maximal(P). .}
set is_parabolic_real(Parabolic(S,x):P) = bool:
  has_theta_stable_Levi(P) and is_open(P) and
  ( let x_max=maximal(P) in
    all(for j in complement(semisimple_rank(root_datum(x)),S)
        do is_strict_descent(j,x_max) { C- or real }
        od)
  )


{------------  unipotent radical of P ------------------}
{ see K.pdf, Section 4
  P=(S,x)
  if x=x_0:=KGB(G,0) then P is the standard parabolic P_S with simple roots S,
  and nilrad(P) is contained in the basic Borel
  in general P=(S,x) -> gP_Sg^{-1} where gxg^{-1}=x_0
  if the G-orbit of P is closed, equivalently if L contains the fundamental
  Cartan, then we can replace x with x=x_min(P) which is on the fundamental
  Cartan and then find w so that w*x=x_0
}
{. Half sum of positive roots not in the Levi (L must be theta-stable). .}
set rho_u (ComplexParabolic P) = ratvec:
  rho(root_datum(P))-rho(complex_Levi(P))

{. Half sum of positive roots not in the Levi (L must be theta-stable). .}
set rho_u (Parabolic P) = ratvec: rho(real_form(P)) - rho(Levi(P))

{. Half sum of positive roots in the Levi (L must be theta-stable). .}
set rho_l (Parabolic P) = ratvec: rho(Levi(P))

{. Positive coroots in the nilradical u of P (L must be theta-stable). .}
set nilrad (Parabolic P) = mat: { columns are coweights, in fact poscoroots }
  let rd=root_datum(P), rho_u=rho_u(P)
  in columns_with((vec alpha_v) bool: > alpha_v*rho_u ,poscoroots(rd))

{. Positive roots in the nilradical u of P (L must be theta-stable). .}
set nilrad_roots (Parabolic P) = mat: { columns are posroots }
  let rd=root_datum(P), nil_coroots = nilrad(P) in
  if =nil_coroots then nil_coroots { empty matrix is self_dual }
  else { convert non-empty set of coroots }
    for alpha_v in nil_coroots do root(rd,alpha_v) od
  fi

{ ----------------- alternative method to define a parabolic --------------- }
{ it is convenient to be able to define a parabolic in terms of a semisimple
  element either in \h or \h^*
}

{. Simple coroots on which weight lambda (in $\mathfrak h^*$) is zero. .}
set zero_simple_coroots (RootDatum rd, vec lambda) = [int]:
  let result = [int]:[] in
  for alpha_v@j in simple_coroots(rd)
  do if alpha_v*lambda=0 then result #:= j fi od; result

{. Parabolic defined by weight lambda; message whether parabolic is real
  or theta-stable. .}
set parabolic_by_wt_verbose (ratvec lambda,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (w,lambda_dom)=from_dominant(rd,numer(lambda)) in
  let P=
  Parabolic:(zero_simple_coroots(rd,lambda_dom), cross(inverse(w),x)) in
  if is_parabolic_theta_stable(P) then prints("Parabolic is theta-stable.")
  else if is_parabolic_real(P) then prints("Parabolic is real.")
  else prints("The parabolic is neither real nor theta-stable.") fi fi;
  P

{. Parabolic defined by weight lambda; NO message whether parabolic is real
  or theta-stable. .}
set parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (w,lambda_dom)=from_dominant(rd,numer(lambda)) in
  let P=
  Parabolic:(zero_simple_coroots(rd,lambda_dom), cross(inverse(w),x)) in
  P

{. Theta-stable parabolic defined by weight lambda. .}
set theta_stable_parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
   let theta=involution(x) in parabolic_by_wt((1+theta)*lambda,x)

{. Real parabolic defined by weight lambda. .}
set real_parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
   let theta=involution(x) in parabolic_by_wt((1-theta)*lambda,x)

{. Levi factor of parabolic defined by weight lambda. .}
set Levi_by_wt (ratvec lambda,KGBElt x) = RealForm:
   Levi(parabolic_by_wt(lambda,x))

{. Levi factor of theta-stable parabolic defined by weight lambda. .}
set theta_stable_Levi_by_wt (ratvec lambda, KGBElt x) = RealForm:
   Levi(theta_stable_parabolic_by_wt(lambda,x))

{. Levi factor of real parabolic defined by weight lambda. .}
set real_Levi_by_wt (ratvec lambda, KGBElt x) = RealForm:
   Levi(real_parabolic_by_wt(lambda,x))

{. Positive coroots in nilradical of P defined by weight lambda
  (if L theta-stable). .}
set nilrad_by_wt (ratvec lambda,KGBElt x) = mat:
   nilrad(parabolic_by_wt(lambda,x))

{. Positive roots in nilradical of P defined by weight lambda
  (if L theta-stable). .}
set nilrad_roots_by_wt (ratvec lambda,KGBElt x) = mat:
  nilrad_roots(parabolic_by_wt(lambda,x))

{. Half sum of positive roots in nilradical of P defined by weight lambda (if L
theta-stable). .}
set rho_u_by_wt (ratvec lambda,KGBElt x) = ratvec:
   sum(nilrad_roots_by_wt(lambda,x)) / 2

{. Simple roots which are zero on coweight H (in $\mathfrak h$). .}
set zero_simple_roots(RootDatum rd, vec cowt) = [int]:
  let result = [int]:[] in
  for alpha@j in simple_roots(rd)
  do if cowt*alpha=0 then result #:= j fi od; result

{. Parabolic defined by coweight H; message whether parabolic is real
   or theta-stable. .}
set parabolic_by_cwt_verbose (ratvec H,KGBElt x) = Parabolic:
  let rd=root_datum(x)
  then (H_dom,w)=from_dominant(numer(H),rd)
  then P= Parabolic:(zero_simple_roots(rd,H_dom), cross(w,x))
  in
  if is_parabolic_theta_stable(P) then prints("Parabolic is theta-stable.")
  else if is_parabolic_real(P) then prints("Parabolic is real.")
  else prints("The parabolic is neither real nor theta-stable.") fi fi;
  P

{. Parabolic defined by coweight H; no message .}
set parabolic_by_cwt (ratvec H,KGBElt x) = Parabolic:
  let rd=root_datum(x)
  then (H_dom,w)=from_dominant(numer(H),rd)
  then P= Parabolic:(zero_simple_roots(rd,H_dom), cross(w,x))
  in P

{. Levi factor of parabolic defined by coweight H. .}
set Levi_by_cwt (ratvec H,KGBElt x) = RealForm: Levi(parabolic_by_cwt(H,x))

{. Positive coroots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set nilrad_by_cwt (ratvec H,KGBElt x) = mat: nilrad(parabolic_by_cwt(H,x))

{. Positive roots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set nilrad_roots_by_cwt (ratvec H,KGBElt x) = mat:
  nilrad_roots(parabolic_by_cwt(H,x))

{. Half sum of roots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set rho_u_by_cwt (ratvec H,KGBElt x)= ratvec:
  sum(nilrad_roots_by_cwt(H,x)) /2

{. $\rho(L)$ for Levi of P defined by coweight H (if L theta-stable). .}
set rho_Levi_by_cwt (ratvec H,KGBElt x) = ratvec: rho(Levi_by_cwt(H,x))


{ ----------------------(real) cuspidal parabolics------------------- }

{. Real parabolic defined by x has Levi factor M=centralizer(A),
  $\mathfrak u$=positive roots not in M;
  for M to be stable: x must have no C+ roots. .}
set real_parabolic (KGBElt x) = Parabolic:
  assert(no_Cplus_roots(x),"x has some C+ roots");
  parabolic_by_wt((1-involution(x))*rho(root_datum(x)),x)

{. Levi factor of real parabolic defined by x (must have no C+ roots). .}
set real_Levi (KGBElt x) = RealForm: Levi(real_parabolic(x))

{ ---------------------theta-stable split parabolics---------------- }

{. Theta-stable parabolic defined by x has Levi factor L=centralizer(T),
  $\mathfrak u$=positive roots not in L;
  for this to be stable: no C- roots. .}
set theta_stable_parabolic (KGBElt x) = Parabolic:
  assert(no_Cminus_roots(x),"x has some C- roots");
  parabolic_by_wt((1+involution(x))*rho(root_datum(x)),x)

{. Levi factor of theta-stable parabolic defined by x
  (must have no C- roots). .}
set theta_stable_Levi (KGBElt x) = RealForm: Levi(theta_stable_parabolic(x))

{. Check whether a Levi subgroup L is standard in G
  (simple roots of L are simple for G). .}
set is_standard_Levi (RealForm L,RealForm G)=bool:
   let rd=root_datum(G) in let lroots=posroots(L) in
   let lcoroots=poscoroots(L) in
   let (lsimple,)=simple_system_from_positive(lroots,lcoroots) in
   all(for alpha in lsimple do is_simple_root(rd,alpha) od)

{ -------------- auxiliary routines------------------}

{. List of K-conjugacy classes of given ComplexParabolic (as KGP elts). .}
set KGP (RealForm G,ComplexParabolic (rd,S)) = [KGPElt]:
  for x in maxima_for(S,G) do KGPElt:(S,x) od

{. List K-conjugacy classes of given ComplexParabolic (as Parabolics). .}
set parabolics (RealForm G,ComplexParabolic (rd,S)) = [Parabolic]:
  for x in maxima_for(S,G) do Parabolic:(S,x) od

{. List K-conjugacy classes of given ComplexParabolic that are theta-stable. .}
set theta_stable_parabolics (RealForm G,ComplexParabolic P) = [Parabolic]:
  let result=[Parabolic]:[] in
  for Q in parabolics(G,P)
  do if is_parabolic_theta_stable(Q) then result#:=Q fi od; result

{. List all theta-stable parabolics for G. .}
set theta_stable_parabolics (RealForm G) = [Parabolic]:
## { concatenate all loop bodies }
  for S in power_set(semisimple_rank(G))
  do theta_stable_parabolics(G,ComplexParabolic:(G,S))
  od

{. List all theta-stable parabolics of G, of type S. .}
set theta_stable_parabolics_type (RealForm G,[int] P) = [Parabolic]:
  let result=[Parabolic]:[] in
  for (Q,y) in theta_stable_parabolics(G) do if Q=P then result#:=(Q,y) fi od;
  result

{. List all theta-stable parabolics of G with relatively split L. .}
set all_rel_split_theta_stable_parabolics (RealForm G) = [Parabolic]:
  let parabolics=theta_stable_parabolics(G) then result=[Parabolic]: [] in
  for P in parabolics do
    if is_relatively_split(Levi(P)) then result#:=P fi
  od; result

set all_real_parabolics(RealForm G)=
let subsets=generate_all_subsets(for i:semisimple_rank(G) do i od) then
rv=[] in
for S in subsets do
for P in parabolics(G,(G,S)) do if is_parabolic_real(P) then rv#:=P fi od od;rv

{. For each theta-stable parabolic of G, print S, Levi factor, and maximal x. .}
set print_theta_stable_parabolics (RealForm G) = void:
  let all = theta_stable_parabolics(G) in
  for (S,x):P in all do prints("S=", S, " L= ", Levi(P), "  x=",x) od;
  prints("Total: ",#all)

{. The smallest list of simple roots such that descents lead to the
  distinguished fiber. .}
set support (KGBElt x) = [int]:
  let rd=root_datum(x), delta=distinguished_involution(real_form(x)) in
  list(semisimple_rank(rd),W_elt(rd,involution(x)*delta).word.is_member)

{. Auxiliary function. .}
set support_alt(KGBElt x)=[int]:
  let rd=root_datum(x), delta=distinguished_involution(real_form(x)) in
  list(semisimple_rank(rd),W_elt(rd,delta*involution(x)).word.is_member)

{for use in find_lambda}
set random=[31220,11647,37379,76487,42281,99983,92672,35013,50289,79830,47810,82416,92150,84570,70610,35366,44981,21161,42049,94355,96801,10070,71505,21696,42096,7832,75988,26509,62156,67549,67781,54376,72296,43134,4383,66728,64236,65212,24116,12466,13033,85636,71449,80515,11480,88335,39381,66618,35975,10896,5825,95823,18001,63961,14564,44737,3903,51896,99125,74288,88299,14793,26802,44113]

{.find lambda so L=L(lambda)={alpha| <lambda,alpha^vee>=0}.}
set findlambda (RootDatum rd, RootDatum L) = vec:
   let k=kernel(^simple_coroots(L)) { generators intersection hyperplanes of L }
   in k* random[:n_columns(k)] { weight hopefully not on any other hyperplanes }

{ coset representatives for W(rd)/W(rd_L); with L non standard Levi subsystem.
  If L=L(lambda) the W-orbit of lambda is in bijection with this quotient}
set coset_reps (RootDatum rd, RootDatum rd_L) = [WeylElt]:
  let lambda=findlambda(rd,rd_L) in let (,elts)=generate_from(rd,lambda) in elts

{test the coset_reps function}
{set test_coset_reps(RootDatum rd,RootDatum rd_L)=
let co=coset_reps(rd,rd_L) then
WL=generate_W(rd_L) then
prods=##for w@i in co do for x@j in WL do (i,j,w*promote(x,rd)) od od then
failures=##for i:#prods do for j:#prods do
  let (,,w)=prods[i] then
  (,,x)=prods[j] in
  if i!=j  and x=w then [(i,j)] else [] fi od od in (prods,##failures)
}
