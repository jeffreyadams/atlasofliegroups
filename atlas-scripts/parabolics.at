{! See "Parabolic Subgroups and Induction", in dropbox, ultimately on atlas web site.

  Fix a subset S of the simple roots, defining the complex standard
  parabolic $P_S$ of type S. We define a set KGP(S) (a
  quotient of KGB) such that (roughly) KGP(S) <-> $K\backslash G/P_S$.

  More precisely, for any $x\in$ KGB and $p(\xi)=x$,
  KGP(S) is canonically in bijection with $K_{\xi}\backslash G/P_S$; i.e.,
  $K_{\xi}$ conjugacy classes of parabolics of type S.

  K orbits on $G/P_S$, equivalently K-conjugacy classes of parabolics of type S:
  Given a RealForm and a subset S of the simple roots,
  S -> partial order on KGB, generated by ascents in S
    -> equivalence relation generated by this
  KGB/equivalence <-> $K\backslash G/P_S$
  Define KGP to be KGB modulo this equivalence.

  Data: ([int],KGBElt)=(S,x) where S lists the indices of a subset of the
  simple roots of root_datum(x)

  Equivalence: (S,x)=(S',y) if these correspond to the same K orbit on $G/P_S$,
  which means:
   real_form(x)=real_form(y), S=S'  (i.e. same complex parabolic), and
   x=y in the equivalence defined by S.
  In particular, given (S,x), taking x itself for the strong real form,
  (S,x) goes to the $K_x$-conjugacy class of the standard parabolic $P_S$.

  The data type is KGPElt or Parabolic (synonyms).

  Given (S,x),
  write $[x_1,...,x_n]$ for the S-equivalence class of $x\subset$ KGB.

  The last element $x_n$ is maximal, and is uniquely determined.
  This orbit of K on $G/P_S$ is closed <=> $x_1$ is closed in KGB.

  ComplexParabolic data type:
  (RootDatum rd,[int] S) <->  G-conjugacy class of standard parabolic with
  Levi factor given by subset S of simple roots

More topics addressed in this file:
  parabolics with $\theta$-stable Levi factor;
  $\theta$-stable parabolics;
  real parabolics.
!}

<misc.at { for is_simple_root }
<sort.at { for inv_standardisation }
<Weylgroup.at
<group_operations { for is_relatively_split }


{. Data type for a K_orbit on G/P_S, equivalently a K-conjugacy class of
   parabolics of type S. .}
: KGPElt    = ([int], KGBElt)

{. Data type for a K_orbit on G/P_S (synonym for KGPElt). .}
: Parabolic = ([int], KGBElt)  { synonym }

{. given a list of KGB elements and a function f assigning integers to them,
sort the list by weakly increasing value of f.  .}
set sort_by((KGBElt -> int) f)= ([KGBElt] v) [KGBElt]:
  for index in inv_standardisation(for x in v do f(x) od) do v[index] od

{. sort a list of KGB elements by their index numbers, in increasing order.  .}
set sort = ([KGBElt] -> [KGBElt]): sort_by((KGBElt x) int: #x)

{. choose from a list of KGB elements the one (only unique if all associated
to the same RealForm) with the smallest index number. .}
set min ([KGBElt] list)=sort(list)[0]

{. choose from a list of KGB elements one with greatest index number.  .}
set max ([KGBElt] list)=sort(list)~[0]


set KGP_elt (KGPElt pair) = KGPElt: pair { identity; prefer cast KGPElt:(S,x) }

{. the list S of simple roots of a KGP element. .}
set S (KGPElt(S,)) = [int]: S

{. the root datum of the RealForm G of a KGP element. .}
set root_datum (KGPElt(,x)) = RootDatum: root_datum(x)

{. the RealForm G of a KGP element. .}
set real_form  (KGPElt(,x)) = RealForm:  real_form(x)

{. an ascent of x by a generator in S, if any exist. .}
set find_ascent ([int] S, KGBElt x) = [KGBElt]:
  let f = first(#S,(int i)bool: is_ascent(S[i],x)) in
  if <f then []
  else let s=S[f] in
    [if is_noncompact(s,x) then Cayley(s,x) else cross(s,x) fi]
  fi

{. all descents of x by generators in S; there may be duplicates. .}
set down_neighbors ([int] S,KGBElt x) = [int]:
  ##
  for i in list(#S,(int i): is_strict_descent(S[i],x))
  do let s=S[i] in
    if is_real(s,x)
    then let y=Cayley(s,x) in [#y,#cross(s,y)]
    else [#cross(s,x)]
    fi
  od

{. decide whether x is maximal in the partial order defined by S. .}
set is_maximal_in_partial_order ([int] S,KGBElt x) = bool: #find_ascent(S,x)=0

{. list maximal KGB elements in the partial order defined by S. .}
set maxima_in_partial_order (RealForm G,[int] S) = [KGBElt]:
  let result=[KGBElt]:[] in
  for x in KGB(G)
  do if is_maximal_in_partial_order(S,x) then result #:= x fi od; result

{. (Unique) maximal element in equivalence class of x. .}
set maximal ([int] S, KGBElt x) = KGBElt:
  let r=[KGBElt]: [] in { variable needed to cross 'do' boundary }
  while r:=find_ascent(S,x); #r>0 do x:=r[0] od; x

{. the representative of a KGP element with maximal x. .}
set canonical_representative (KGPElt y) = KGPElt: (S(y),maximal(y))

{. (Unique) maximal KGB element representing a KGP element. .}
set x = (KGPElt->KGBElt): maximal@KGPElt

{. equality of KGP elements: (S,x)=(T,y) if these give the same
K-orbit of parabolics. .}
set = (KGPElt (S,x),KGPElt (T,y))=bool:
  real_form(x)=real_form(y) and S=T and maximal(S,x)=maximal(S,y)

{. the equivalence class of a KGB element in partial order defined by S. .}
set equivalence_class_of (KGPElt(S,x)) = [KGBElt]:
  let x_max=maximal(S,x)
  then G=real_form(x_max), !last=#x_max
  then result=[last], done=0, present = for :last do false od
  in
  while done < #result
  do
    for i in down_neighbors(S,KGB(G,result[done])) next done +:= 1
    do if not present[i] then result #:= i; present[i] := true fi od
  od;
  for i in sort(result) do KGB(G,i) od

{. a minimal KGB element from an equivalence class defined by S
   (unlike x_max, it is not unique). .}
set rec_fun x_min (KGPElt P) = KGBElt:
   let (S,x)=P in if #down_neighbors(P)=0 then x else
   x_min(S,KGB(real_form(x),down_neighbors(P)[0]))  fi

{. the set of KGP elements associated to a RealForm and a set of
simple roots S; KGP(G,S) is in bijection with $K\backslash G/P_S$. .}
set KGP (RealForm G,[int] S) = [KGPElt]:
  for x in maxima_in_partial_order(G,S) do KGPElt:(S,x) od

{. just the index numbers (maximal x) of KGP(G,S). .}
set KGP_numbers (RealForm G,[int] S) =[int]: for (,x) in KGP(G,S) do #x od

{. test whether y in $K\backslash G/P_S$ is open: <=> last element of y is last
element of KGB. .}
set is_open (KGPElt y) = bool: #maximal(y) = KGB_size(real_form(y))-1

{. test whether y in $K\backslash G/P_S$ is closed: <=> length(first element)=0. .}
set is_closed (KGPElt P) = bool: length(x_min(P))=0

{. parabolic determined by (the stabilizer in W of) a weight lambda. .}
set KGP_elt (ratvec lambda,KGBElt x) = KGPElt:
  let rd=root_datum(x)
  then (lambda_dom,w)=make_dominant(rd,lambda), P=[int]:[]
  in for a@i in simple_coroots(rd) do if a*lambda_dom=0 then P#:=i fi od;
  KGPElt:(P,cross(inverse(w),x))

{. Data type for a complex parabolic subrgoup .}
: ComplexParabolic = (RootDatum,[int])

{. the complex parabolic underlying P=(S,x). .}
set complex_parabolic (Parabolic(S,x)) = ComplexParabolic: (root_datum(x),S)

{. auxiliary function .}
set complex_Levi (RootDatum rd, (int->bool) select) = RootDatum:
  root_datum(columns_with(select,  simple_roots(rd))
            ,columns_with(select,simple_coroots(rd)))

{. Root datum of the Levi factor of a complex parabolic. .}
set complex_Levi (RootDatum rd,[int] S) = complex_Levi(rd,is_member(S))

{. Test if a complex Levi defined by a set of simple roots S is $\theta_x$-stable;
  algorithm: H=sum of fundamental coweights with index not in S,
  test whether $<\theta_x(\alpha),H>=0$ for all $\alpha$ in S. .}
set is_Levi_theta_stable (Parabolic (S,x)) = bool:
  let G=root_datum(x)
  then H = { coweight measuring level of roots alpha[t] not in the Levi factor }
    let sum= ratvec: null(rank(G)) in
    for t in complement(semisimple_rank(G),S)
    do sum + := fundamental_coweight(G,t) od; sum
  , theta=involution(x)
  , alpha=simple_roots(G)
  in all(for s in S do = H*(theta*alpha[s]) od)

{. Make a real Levi factor from P=(S,x); the complex Levi of S must
be theta-stable. .}
set Levi (Parabolic(S,x):P) = RealForm:
  assert(is_Levi_theta_stable(P),"Levi factor is not theta-stable");
  let x_min=x_min(P) then theta=involution(x_min)
  then ic_Levi=inner_class(complex_Levi(root_datum(x),S),theta)
  in { synthetic } real_form(ic_Levi,theta,torus_factor(x_min))

{. Test if parabolic P=(S,x) is theta-stable: <=>
   the complex Levi factor L is theta-stable, P is closed, and for
   alpha simple, not in S => alpha is imaginary or C+ wrt maximal(P). .}
set is_parabolic_theta_stable (Parabolic (S,x):P) = bool:
  is_Levi_theta_stable(P) and
  is_closed(P) and
  ( let x_max=maximal(P) in
    none(for j in complement(semisimple_rank(root_datum(x)),S)
         do is_strict_descent(j,x_max) { C- or real }
         od)
  )

{. Test if parabolic P=(S,x) is real: <=> L is theta-stable, P is open, and
   for alpha simple, not in S => alpha is real or C- wrt a maximal(P). .}
set is_parabolic_real(Parabolic (S,x):P) = bool:
  is_Levi_theta_stable(P) and
  is_open(P) and
  ( let x_max=maximal(P) in
    all(for j in complement(semisimple_rank(root_datum(x)),S)
        do is_strict_descent(j,x_max) { C- or real }
        od)
  )


{------------  unipotent radical of P ------------------}
{ see K.pdf, Section 4
  P=(S,x)
  if x=x_0:=KGB(G,0) then P is the standard parabolic P_S with simple roots S,
  and nilrad(P) is contained in the basic Borel
  in general P=(S,x) -> gP_Sg^{-1} where gxg^{-1}=x_0
  if the G-orbit of P is closed, equivalently if L contains the fundamental
  Cartan, then we can replace x with x=x_min(P) which is on the fundamental
  Cartan and then find w so that w*x=x_0
}
{. Half sum of positive roots not in the Levi (L must be theta-stable). .}
set rho_u(ComplexParabolic P)=ratvec: rho(root_datum(P))-rho(complex_Levi(P))

{. Half sum of positive roots not in the Levi (L must be theta-stable). .}
set rho_u (Parabolic P) = ratvec: rho(real_form(P)) - rho(Levi(P))

{. Half sum of positive roots in the Levi (L must be theta-stable). .}
set rho_l (Parabolic P) = ratvec: rho(Levi(P))

{. Positive coroots in the nilradical u of P (L must be theta-stable). .}
set nilrad (Parabolic P) = mat: { columns are coweights, in fact poscoroots }
  let rd=root_datum(P), rho_u=rho_u(P)
  in columns_with((vec alpha_v) bool: > alpha_v*rho_u ,poscoroots(rd))

{. Positive roots in the nilradical u of P (L must be theta-stable). .}
set nilrad_roots (Parabolic P) = mat: { columns are posroots }
  let rd=root_datum(P), nil_coroots = nilrad(P) in
  if =nil_coroots then nil_coroots { empty matrix is self_dual }
  else { convert non-empty set of coroots }
    for alpha_v in nil_coroots do root(rd,alpha_v) od
  fi

{ ----------------- alternative method to define a parabolic --------------- }
{ it is convenient to be able to define a parabolic in terms of a semisimple
  element either in \h or \h^*
}

{. Simple coroots on which weight lambda (in $\mathfrak h^*$) is zero. .}
set zero_simple_coroots (RootDatum rd, vec lambda) = [int]:
  let result = [int]:[] in
  for alpha_v@j in simple_coroots(rd)
  do if alpha_v*lambda=0 then result #:= j fi od; result

{. Parabolic defined by weight lambda; message whether parabolic is real
  or theta-stable. .}
set parabolic (ratvec lambda,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (lambda_dom,w)=make_dominant(rd,numer(lambda)) in
  let P=
  Parabolic:(zero_simple_coroots(rd,lambda_dom), cross(inverse(w),x)) in
  if is_parabolic_theta_stable(P) then prints("Parabolic is theta-stable.")
  else if is_parabolic_real(P) then prints("Parabolic is real.")
  else prints("The parabolic is neither real nor theta-stable.") fi fi;
  P

{. Parabolic defined by weight lambda; NO message whether parabolic is real
  or theta-stable. .}
set parabolic_mute (ratvec lambda,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (lambda_dom,w)=make_dominant(rd,numer(lambda)) in
  let P=
  Parabolic:(zero_simple_coroots(rd,lambda_dom), cross(inverse(w),x)) in
  P

{. Theta-stable parabolic defined by weight lambda. .}
set theta_stable_parabolic (ratvec lambda,KGBElt x) = Parabolic:
   let theta=involution(x) in parabolic_mute((1+theta)*lambda,x)

{. Real parabolic defined by weight lambda. .}
set real_parabolic (ratvec lambda,KGBElt x) = Parabolic:
   let theta=involution(x) in parabolic_mute((1-theta)*lambda,x)

{. Levi factor of parabolic defined by weight lambda. .}
set Levi (ratvec lambda,KGBElt x) = RealForm: Levi(parabolic_mute(lambda,x))

{. Levi factor of theta-stable parabolic defined by weight lambda. .}
set theta_stable_Levi (ratvec lambda, KGBElt x) = RealForm:
   Levi(theta_stable_parabolic(lambda,x))

{. Levi factor of real parabolic defined by weight lambda. .}
set real_Levi (ratvec lambda, KGBElt x) = RealForm:
   Levi(real_parabolic(lambda,x))

{. Positive coroots in nilradical of P defined by weight lambda
  (if L theta-stable). .}
set nilrad (ratvec lambda,KGBElt x) = mat: nilrad(parabolic_mute(lambda,x))

{. Positive roots in nilradical of P defined by weight lambda
  (if L theta-stable). .}
set nilrad_roots (ratvec lambda,KGBElt x) = mat:
  nilrad_roots(parabolic_mute(lambda,x))

{. Half sum of positive roots in nilradical of P defined by weight lambda (if L
theta-stable). .}
set rho_u (ratvec lambda,KGBElt x) = ratvec: sum(nilrad_roots(lambda,x)) / 2

{. Simple roots which are zero on coweight H (in $\mathfrak h$). .}
set zero_simple_roots(RootDatum rd, vec cowt) = [int]:
  let result = [int]:[] in
  for alpha@j in simple_roots(rd)
  do if cowt*alpha=0 then result #:= j fi od; result

{. Parabolic defined by coweight H; message whether parabolic is real
   or theta-stable. .}
set parabolic_alt (ratvec H,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (H_dom,w)=dual_make_dominant(rd,numer(H)) in
  let P=
  Parabolic:(zero_simple_roots(rd,H_dom), cross(inverse(w),x)) in
{  if is_parabolic_theta_stable(P) then prints("Parabolic is theta-stable.")
  else if is_parabolic_real(P) then prints("Parabolic is real.")
  else prints("The parabolic is neither real nor theta-stable.") fi fi;}
  P

{. Levi factor of parabolic defined by coweight H. .}
set Levi_alt (ratvec H,KGBElt x) = RealForm: Levi(parabolic_alt(H,x))

{. Positive coroots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set nilrad_alt (ratvec H,KGBElt x) = mat: nilrad(parabolic_alt(H,x))

{. Positive roots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set nilrad_roots_alt (ratvec H,KGBElt x) = mat:
  nilrad_roots(parabolic_alt(H,x))

{. Half sum of roots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set rho_u_alt (ratvec H,KGBElt x)= ratvec: sum(nilrad_roots_alt(H,x)) /2

{. $\rho(L)$ for Levi of P defined by coweight H (if L theta-stable). .}
set rho_Levi_alt (ratvec H,KGBElt x) = ratvec: rho(Levi_alt(H,x))


{ ----------------------(real) cuspidal parabolics------------------- }

{. Real parabolic defined by x has Levi factor M=centralizer(A),
  $\mathfrak u$=positive roots not in M;
  for M to be stable: x must have no C+ roots. .}
set real_parabolic (KGBElt x) = Parabolic:
  assert(no_Cplus_roots(x),"x has some C+ roots");
  parabolic_mute((1-involution(x))*rho(root_datum(x)),x)

{. Levi factor of real parabolic defined by x (must have no C+ roots). .}
set real_Levi (KGBElt x) = RealForm: Levi(real_parabolic(x))

{ ---------------------theta-stable split parabolics---------------- }

{. Theta-stable parabolic defined by x has Levi factor L=centralizer(T),
  $\mathfrak u$=positive roots not in L;
  for this to be stable: no C- roots. .}
set theta_stable_parabolic (KGBElt x) = Parabolic:
  assert(no_Cminus_roots(x),"x has some C- roots");
  parabolic_mute((1+involution(x))*rho(root_datum(x)),x)

{. Levi factor of theta-stable parabolic defined by x
  (must have no C- roots). .}
set theta_stable_Levi (KGBElt x) = RealForm: Levi(theta_stable_parabolic(x))

{. Check whether a Levi subgroup L is standard in G
  (simple roots of L are simple for G). .}
set is_standard_Levi (RealForm L,RealForm G)=bool:
   let rd=root_datum(G) in let lroots=posroots(L) in
   let lcoroots=poscoroots(L) in
   let (lsimple,)=simple_from_positive(lroots,lcoroots) in
   all(for alpha in lsimple do is_simple_root(rd,alpha) od)

{ -------------- auxiliary routines------------------}

{. List of K-conjugacy classes of given ComplexParabolic (as KGP elts). .}
set KGP (RealForm G,ComplexParabolic (rd,S)) = [KGPElt]:
  for x in maxima_in_partial_order(G,S) do KGPElt:(S,x) od

{. List K-conjugacy classes of given ComplexParabolic (as Parabolics). .}
set parabolics (RealForm G,ComplexParabolic (rd,S)) = [Parabolic]:
  for x in maxima_in_partial_order(G,S) do Parabolic:(S,x) od

{. List K-conjugacy classes of given ComplexParabolic that are theta-stable. .}
set theta_stable_parabolics (RealForm G,ComplexParabolic P) = [Parabolic]:
  let result=[Parabolic]:[] in
  for Q in parabolics(G,P)
  do if is_parabolic_theta_stable(Q) then result#:=Q fi od; result

{. List all theta-stable parabolics for G. .}
set theta_stable_parabolics (RealForm G) = [Parabolic]:
## { concatenate all loop bodies }
  for S in power_set(semisimple_rank(G))
  do theta_stable_parabolics(G,ComplexParabolic:(G,S))
  od

{. List all theta-stable parabolics of G, of type S. .}
set theta_stable_parabolics_type (RealForm G,[int] P) = [Parabolic]:
  let result=[Parabolic]:[] in
  for (Q,y) in theta_stable_parabolics(G) do if Q=P then result#:=(Q,y) fi od;
  result

{. List all theta-stable parabolics of G with relatively split L. .}
set all_rel_split_theta_stable_parabolics (RealForm G) = [Parabolic]:
  let parabolics=theta_stable_parabolics(G) then result=[Parabolic]: [] in
  for P in parabolics do
    if is_relatively_split(Levi(P)) then result#:=P fi
  od; result

set all_real_parabolics(RealForm G)=
let subsets=generate_all_subsets(for i:semisimple_rank(G) do i od) then
rv=[] in
for S in subsets do
for P in parabolics(G,(G,S)) do if is_parabolic_real(P) then rv#:=P fi od od;rv

{. For each theta-stable parabolic of G, print S, Levi factor, and maximal x. .}
set print_theta_stable_parabolics (RealForm G) = void:  let all = theta_stable_parabolics(G) in
  for (S,x):P in all do prints("S=", S, " L= ", Levi(P), "  x=",x) od;
  prints("Total: ",#all)

{. The smallest list of simple roots such that descents lead to the
  distinguished fiber. .}
set support(KGBElt x)=[int]:
  let rd=root_datum(x) in
  let delta=distinguished_involution(real_form(x)) in
  let W=word(word(rd,involution(x)*delta)) in
  let result=[] in for i:semisimple_rank(rd) do
  if is_member(W)(i) then result#:=i fi od;
  result

{. Auxiliary function. .}
set support_alt(KGBElt x)=[int]:
  let rd=root_datum(x) in
  let delta=distinguished_involution(real_form(x)) in
  let W=word(word(rd,delta*involution(x))) in
  let result=[] in for i:semisimple_rank(rd) do
  if is_member(W)(i) then result#:=i fi od;
  result
