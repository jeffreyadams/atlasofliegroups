<W_orbit.at

{! See "Parabolic Subgroups and Induction", in dropbox, ultimately on the
  Atlas web site.

  Fix a subset S of the simple roots, defining the complex standard
  parabolic $P_S$ of type S. We define a set KGP(S) (a
  quotient of KGB) such that (roughly) KGP(S) <-> $K\backslash G/P_S$.

  More precisely, for any KGB element $x$ and $\xi$ with $p(\xi)=x$, the set
  KGP(S) is canonically in bijection with $K_{\xi}\backslash G/P_S$; i.e.,
  $K_{\xi}$ conjugacy classes of parabolics of type S.

  S defines a partial order on KGB, generated by applying ascents in S
  Symmetrized, this generates an equivalence relation, KGB/this equivalence is
  in bijection with $K\backslash G/P_S$, so define the quotient to be KGP.

  Data: ([int],KGBElt)=(S,x) where S lists the indices of a subset of the
  simple roots of root_datum(x)

  Equivalence: (S,x)=(S',y) if these correspond to the same K orbit on $G/P_S$,
  which means:
   real_form(x)=real_form(y), S=S'  (i.e. same complex parabolic), and
   x=y in the equivalence defined by S.
  In particular, given (S,x), taking x itself for the strong real form,
  (S,x) goes to the $K_x$-conjugacy class of the standard parabolic $P_S$.

  The data type is KGPElt or Parabolic (synonyms).

  Given (S,x),
  write $[x_1,...,x_n]$ for the S-equivalence class of $x\subset$ KGB.

  The last element $x_n$ is maximal, and is uniquely determined.
  This orbit of K on $G/P_S$ is closed <=> $x_1$ is closed in KGB.

  ComplexParabolic data type:
  (RootDatum rd,[int] S) <->  G-conjugacy class of standard parabolic with
  Levi factor given by subset S of simple roots

More topics addressed in this file:
  parabolics with $\theta$-stable Levi factor;
  $\theta$-stable parabolics;
  real parabolics.
!}

<misc.at { for is_simple_root }
<Weylgroup.at { for |cross@(WeylElt,KGBElt)| }
<group_operations { for is_relatively_split }

set_type
[
  {. Data type for a K_orbit on G/P_S, equivalently a K-conjugacy class of
    parabolics of type S, where S is a list of simple root indices. .}
  KGPElt    = ([int] S, KGBElt x)
,
  {. Data type for a complex standard parabolic subgroup .}
  ComplexParabolic = (RootDatum root_datum,[int] S)
]

{. Data type for a K_orbit on G/P_S (synonym for KGPElt). .}
set_type Parabolic = KGPElt
{. Data type for a complex Levi=pair of root data.}

{. choose from a nonempty list of KGB elements one with the smallest index. .}
set min ([KGBElt] list)= KGBElt:
  let m=list[0] in for x in list do if #x<#m then m:=x fi od; m

{. choose from a nonempty list of KGB elements one with the greatest number. .}
set max ([KGBElt] list) = KGBElt:
  let m=list[0] in for x in list do if #x>#m then m:=x fi od; m

{. the root datum of the RealForm G of a KGP element. .}
set root_datum (KGPElt(,x)) = RootDatum: root_datum(x)

{. the RealForm G of a KGP element. .}
set real_form  (KGPElt(,x)) = RealForm:  real_form(x)

{. ascents of |x| by generators in |S|; there may be duplicates. .}
set ascents ([int] S, KGBElt x) = [KGBElt]:
  for s in S
  do case status(s,x)
     in [], [], [] { descents }, { nc } [Cayley(s,x)], { C+ } [cross(s,x)]
     esac
  od.##

{. all descents of |x| by generators in |S|; there may be duplicates. .}
set down_neighbors ([int] S,KGBElt x) = [KGBElt]:
  for s in S
  do case status(s,x)
     in { C- } [cross(s,x)]
     , { ic } []
     , { r } let y=Cayley(s,x) in [y,cross(s,y)]
     , { nc } []
     , { C+ } []
     esac
  od.##

{. decide whether x is maximal in the partial order defined by S. .}
set is_maximal_for ([int] S,KGBElt x) = bool: =#ascents(S,x)

{. list maximal KGB elements in the partial order defined by S. .}
set maxima_for ([int] S,RealForm G) = [KGBElt]:
  for x in KGB(G) if is_maximal_for(S,x) do x fi od

{. (Unique) maximal element in equivalence class of x. .}
set maximal ([int] S, KGBElt x) = KGBElt:
  while let r=ascents(S,x) in (#r).> do x:=r[0] od; x

{. a minimal KGB element from an equivalence class defined by S
   (unlike |maximal(S,x)|, it is not unique). .}
set x_min (KGPElt(S,x)) = KGBElt:
  while let D=down_neighbors(S,x) in (#D).> do x:=D[0] od; x


{. build KGBElt (with canonical representative) from |S| and |x|. .}
set KGP_elt_for (KGPElt(S,):S_x) = KGPElt: (S,maximal(S_x))
{ alternative implementation:
  |set KGP_elt_for (KGPElt S_x) = KGPElt: S_x.x:=maximal(S_x); S_x|
}

{. (Unique) maximal KGB element representing a KGP element. .}
set representative = (KGPElt->KGBElt): maximal@KGPElt

{. equality of KGP elements: whether they share a K-orbit of parabolics. .}
set = (KGPElt (S,x):S_x,KGPElt (T,y):T_y) = bool:
  real_form(x)=real_form(y) and S=T and maximal(S_x)=maximal(T_y)

{. the equivalence class of a KGB element in partial order defined by S. .}
set equivalence_class_of (KGPElt(S,x):S_x) = [KGBElt]:
  let G=real_form(x), x_max=maximal(S_x)
  then todo=[x_max], seen=0, in_class = for :#x_max do false od # true
  in
  while seen < #todo
  do
    for x in down_neighbors(S,todo[seen]) next seen +:= 1
    do if not in_class[#x] then in_class[#x] := true; todo #:= x fi od
  od; { return |todo.(sort_by(#@KGBElt))|, but maybe more efficiently: }
  for present@i in in_class if present do KGB(G,i) fi od

set is_in_class_of (KGBElt x, KGPElt(S,):P) = bool:
   maximal(S,x) = maximal(P)

{. the set of KGP elements associated to a RealForm and a set of
simple roots S; KGP(G,S) is in bijection with $K\backslash G/P_S$. .}
set KGP (RealForm G,[int] S) = [KGPElt]:
  for x in maxima_for(S,G) do KGPElt:(S,x) od

{. just the index numbers (maximal x) of KGP(G,S). .}
set KGP_numbers (RealForm G,[int] S) =[int]: for (,x) in KGP(G,S) do #x od

{. whether y in $K\backslash G/P_S$ is open (maximal(y) is final in KGB). .}
set is_open (KGPElt y) = bool:
  is_maximal_for(all_simples(y.root_datum),maximal(y))

{. test whether y in $K\backslash G/P_S$ is closed (length(first element)=0). .}
set is_closed (KGPElt P) = bool: length(x_min(P)).=

{. parabolic determined by (the stabilizer in W of) a weight lambda. .}
set KGP_elt (ratvec lambda,KGBElt x) = KGPElt:
  let rd=root_datum(x)
  then (w,lambda_dom)=from_dominant(rd,lambda.numer)
  then P = list(semisimple_rank(rd),(int i)bool: =coroot(rd,i)*lambda_dom)
  in KGPElt:(P,cross(inverse(w),x))

{. the complex parabolic underlying P=(S,x). .}
set complex_parabolic (Parabolic(S,x)) = ComplexParabolic: (root_datum(x),S)


{			Complex Levi subgroups				}

{. auxiliary function .}
set complex_Levi (RootDatum rd, (int->bool) select) = RootDatum:
  root_datum(columns_with(select,simple_roots(rd))
            ,columns_with(select,simple_coroots(rd))
            )

{. Root datum of the Levi factor of a complex parabolic. .}
set complex_Levi (RootDatum rd,[int] S) = RootDatum:
  complex_Levi(rd,is_member(S))

{. coweight vanishing on all roots of the Levi, positive on other posroots .}
set Levi_coweight (ComplexParabolic(rd,S)) = vec:
  ( rd.rank
  , for t in complement(rd.semisimple_rank,S) do fundamental_coweight(rd,t) od
  ).sum.numer

{. weight vanishing on all coroots of the Levi, positive on other poscoroots .}
set Levi_weight (ComplexParabolic(rd,S)) = vec:
  ( rd.rank
  , for t in complement(rd.semisimple_rank,S) do fundamental_weight(rd,t) od
  ).sum.numer

{. Test if a complex Levi defined by a set of simple roots $S$ is
   $\theta_x$-stable; .}
{ algorithm: test whether the Levi_coweight for the complex parabolic
  vanishes on all $\theta_x$-images of Levi roots }
set has_theta_stable_Levi (Parabolic(S,x)) = bool:
  let rd=root_datum(x) then H = Levi_coweight(rd,S) in
  = H*involution(x)*columns_with(is_member(S),simple_roots(rd))

{. Make a real Levi factor from P=(S,x); the complex Levi of S must
be theta-stable. .}
set Levi (Parabolic(S,x):P) = RealForm:
  assert(has_theta_stable_Levi(P),"Levi factor is not theta-stable");
  let x_min=x_min(P) then theta=involution(x_min)
  then ic_Levi=inner_class(complex_Levi(root_datum(x),S),theta)
  in { synthetic } real_form(ic_Levi,theta,torus_factor(x_min))

{. Test whether parabolic P=(S,x) is theta-stable: this means that
   the complex Levi factor L is theta-stable, P is closed, and for all
   alpha simple not in S one has alpha is imaginary or C+ wrt maximal(P). .}
set is_parabolic_theta_stable (Parabolic(S,x):P) = bool:
  has_theta_stable_Levi(P) and is_closed(P) and
  ( let x_max=maximal(P) in
    none(for j in complement(semisimple_rank(root_datum(x)),S)
         do is_strict_descent(j,x_max) { C- or real }
         od)
  )

{. Test if parabolic P=(S,x) is real: this means that L is theta-stable, P is
   open, and for all alpha simple not in S one has alpha is real or C-
   with respect to a maximal(P). .}
set is_parabolic_real(Parabolic(S,x):P) = bool:
  has_theta_stable_Levi(P) and is_open(P) and
  ( let x_max=maximal(P) in
    all(for j in complement(semisimple_rank(root_datum(x)),S)
        do is_strict_descent(j,x_max) { C- or real }
        od)
  )


{------------  unipotent radical of P ------------------}
{ see K.pdf, Section 4
  P=(S,x)
  if x=x_0:=KGB(G,0) then P is the standard parabolic P_S with simple roots S,
  and nilrad(P) is contained in the basic Borel
  in general P=(S,x) -> gP_Sg^{-1} where gxg^{-1}=x_0
  if the G-orbit of P is closed, equivalently if L contains the fundamental
  Cartan, then we can replace x with x=x_min(P) which is on the fundamental
  Cartan and then find w so that w*x=x_0
}

{. Positive coroots in the nilradical u of P (L must be theta-stable). .}
set nilrad (ComplexParabolic(rd,):P) = mat: { columns are poscoroots }
  let mu = Levi_weight(P) in
  columns_with((vec alpha_v) bool: >alpha_v*mu, poscoroots(rd))

{. Positive roots in the nilradical u of P (L must be theta-stable). .}
set nilrad_roots (ComplexParabolic(rd,):P) = mat: { columns are posroots }
  let H = Levi_coweight(P) in
  columns_with((vec alpha) bool: >H*alpha, posroots(rd))

set nilrad (Parabolic P) = mat:       nilrad(complex_parabolic(P))
set nilrad_roots (Parabolic P) = mat: nilrad_roots(complex_parabolic(P))

{. Half sum of positive roots not in the Levi (L must be theta-stable). .}
set rho_u (ComplexParabolic P) = ratvec: { P.root_datum.rho-complex_Levi.rho }
  P.nilrad_roots.sum/2

{. Half sum of positive roots not in the Levi (L must be theta-stable). .}
set rho_u (Parabolic P) = ratvec: { rho_u(complex_parabolic(P)), which is: }
  rho_u(complex_parabolic(P))

{. Half sum of positive roots in the Levi (L must be theta-stable). .}
set rho_l (ComplexParabolic(rd,):P) = ratvec: { rho(Levi(P)) }
  let H = Levi_coweight(P) in
  columns_with((vec alpha) bool: =H*alpha, posroots(rd)).sum/2

set rho_l (Parabolic P) = ratvec: rho_l(complex_parabolic(P))

{ ----------------- alternative method to define a parabolic --------------- }
{ it is convenient to be able to define a parabolic in terms of a semisimple
  element either in \h or \h^*
}

{. Simple coroots on which weight lambda (in $\mathfrak h^*$) is zero. .}
set zero_simple_coroots (RootDatum rd, vec lambda) = [int]:
  for alpha_v@j in simple_coroots(rd) if =alpha_v*lambda do j fi od

{. Parabolic defined by weight lambda .}
set parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (w,lambda_dom)=from_dominant(rd,numer(lambda)) in
  Parabolic:(zero_simple_coroots(rd,lambda_dom), cross(inverse(w),x))

{. Parabolic defined by weight lambda; message whether parabolic is real
  or theta-stable. .}
set parabolic_by_wt_verbose ((ratvec,KGBElt) lambda_x) = Parabolic:
  let P = parabolic_by_wt(lambda_x) in
  if is_parabolic_theta_stable(P) then "Parabolic is theta-stable."
  elif is_parabolic_real(P) then "Parabolic is real."
  else "The parabolic is neither real nor theta-stable."
  fi.prints; P

{. Theta-stable parabolic defined by weight lambda. .}
set theta_stable_parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
   let theta=involution(x) in parabolic_by_wt((1+theta)*lambda,x)

{. Real parabolic defined by weight lambda. .}
set real_parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
   let theta=involution(x) in parabolic_by_wt((1-theta)*lambda,x)

{. Levi factor of parabolic defined by weight lambda. .}
set Levi_by_wt ((ratvec,KGBElt) lambda_x) = RealForm:
   Levi(parabolic_by_wt(lambda_x))

{. Levi factor of theta-stable parabolic defined by weight lambda. .}
set theta_stable_Levi_by_wt ((ratvec,KGBElt) lambda_x) = RealForm:
   Levi(theta_stable_parabolic_by_wt(lambda_x))

{. Levi factor of real parabolic defined by weight lambda. .}
set real_Levi_by_wt ((ratvec,KGBElt) lambda_x) = RealForm:
   Levi(real_parabolic_by_wt(lambda_x))

{. Positive coroots in nilradical of P defined by weight lambda
  (if L theta-stable). .}
set nilrad_by_wt ((ratvec,KGBElt) lambda_x) = mat:
   nilrad(parabolic_by_wt(lambda_x))

{. Positive roots in nilradical of P defined by weight lambda
  (if L theta-stable). .}
set nilrad_roots_by_wt ((ratvec,KGBElt) lambda_x) = mat:
  nilrad_roots(parabolic_by_wt(lambda_x))

{. Half sum of positive roots in nilradical of P defined by weight lambda (if L
theta-stable). .}
set rho_u_by_wt ((ratvec,KGBElt)  lambda_x) = ratvec:
   nilrad_roots_by_wt(lambda_x).sum / 2


{. Simple roots which are zero on coweight H (in $\mathfrak h$). .}
set zero_simple_roots (RootDatum rd, vec cowt) = [int]:
  for alpha@j in simple_roots(rd) if =cowt*alpha do j fi od

{. Parabolic defined by coweight H .}
set parabolic_by_cwt (ratvec H,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (H_dom,w)=from_dominant(numer(H),rd) in
  Parabolic:(zero_simple_roots(rd,H_dom), cross(w,x))

{. Parabolic defined by coweight H; message whether parabolic is real
   or theta-stable. .}
set parabolic_by_cwt_verbose ((ratvec,KGBElt) H_x) = Parabolic:
  let P = parabolic_by_cwt(H_x)
  in
  if is_parabolic_theta_stable(P) then "Parabolic is theta-stable."
  elif is_parabolic_real(P) then "Parabolic is real."
  else "The parabolic is neither real nor theta-stable."
  fi.prints; P

{. Levi factor of parabolic defined by coweight H. .}
set Levi_by_cwt ((ratvec,KGBElt) H_x) = RealForm: Levi(parabolic_by_cwt(H_x))

{. Positive coroots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set nilrad_by_cwt ((ratvec,KGBElt) H_x) = mat: nilrad(parabolic_by_cwt(H_x))

{. Positive roots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set nilrad_roots_by_cwt ((ratvec,KGBElt) H_x) = mat:
  nilrad_roots(parabolic_by_cwt(H_x))

{. Half sum of roots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set rho_u_by_cwt ((ratvec,KGBElt) H_x)= ratvec:
  nilrad_roots_by_cwt(H_x).sum /2

{. $\rho(L)$ for Levi of P defined by coweight H (if L theta-stable). .}
set rho_Levi_by_cwt ((ratvec,KGBElt) H_x) = ratvec: rho(Levi_by_cwt(H_x))


{ ----------------------(real) cuspidal parabolics------------------- }

{. Real parabolic defined by x has Levi factor M=centralizer(A),
  $\mathfrak u$=positive roots not in M;
  for M to be stable: x must have no C+ roots. .}
set real_parabolic (KGBElt x) = Parabolic:
  assert(no_Cplus_roots(x),"x has some C+ roots");
  parabolic_by_wt((1-involution(x))*rho(root_datum(x)),x)

{. Levi factor of real parabolic defined by x (must have no C+ roots). .}
set real_Levi (KGBElt x) = RealForm: Levi(real_parabolic(x))

{ ---------------------theta-stable split parabolics---------------- }

{. Theta-stable parabolic defined by x has Levi factor L=centralizer(T),
  $\mathfrak u$=positive roots not in L;
  for this to be stable: no C- roots. .}
set theta_stable_parabolic (KGBElt x) = Parabolic:
  assert(no_Cminus_roots(x),"x has some C- roots");
  parabolic_by_wt((1+involution(x))*rho(root_datum(x)),x)

{. Levi factor of theta-stable parabolic defined by x
  (must have no C- roots). .}
set theta_stable_Levi (KGBElt x) = RealForm: Levi(theta_stable_parabolic(x))

{. Check whether a Levi subgroup L is standard in G
  (simple roots of L are simple for G). .}
set is_standard_Levi (RealForm L,RealForm G)=bool:
   let rd=root_datum(G) in
   all(for alpha in simple_roots(L) do is_simple_root(rd,alpha) od)

{ -------------- auxiliary routines------------------}

{. List of K-conjugacy classes of given ComplexParabolic (as KGP elts). .}
set KGP (RealForm G,ComplexParabolic (,S)) = [KGPElt]:
  for x in maxima_for(S,G) do KGPElt:(S,x) od

{ This is identical to the previous function, since |Parabolic| is |KGBElt| }
{. List K-conjugacy classes of given ComplexParabolic (as Parabolics). .}
set parabolics (RealForm G,ComplexParabolic (,S)) = [Parabolic]:
  for x in maxima_for(S,G) do Parabolic:(S,x) od

{. List K-conjugacy classes of given ComplexParabolic that are theta-stable. .}
set theta_stable_parabolics (RealForm G,ComplexParabolic P) = [Parabolic]:
  for Q in parabolics(G,P) if is_parabolic_theta_stable(Q) do Q fi od

{. List all theta-stable parabolics for G. .}
set theta_stable_parabolics (RealForm G) = [Parabolic]:
  for S in power_set(semisimple_rank(G))
  do theta_stable_parabolics(G,ComplexParabolic:(G,S))
  od.## { concatenate all loop bodies }

{. List all theta-stable parabolics of G, of type S. .}
set theta_stable_parabolics_type (RealForm G,[int] P) = [Parabolic]:
  let result=[Parabolic]:[] in
  for (Q,y) in theta_stable_parabolics(G) do if Q=P then result#:=(Q,y) fi od;
  result

{. List all theta-stable parabolics of G with relatively split L. .}
set all_rel_split_theta_stable_parabolics (RealForm G) = [Parabolic]:
  for P in theta_stable_parabolics(G) if is_relatively_split(Levi(P)) do P fi od

set all_real_parabolics (RealForm G) = [Parabolic]:
  for S in power_set(semisimple_rank(G))
    for P in parabolics(G,(G,S))
       if is_parabolic_real(P) do P fi
    od
  od

set parabolics_with_theta_stable_Levi (RealForm G,[int] S) = [Parabolic]:
  for P in parabolics(G,(G,S)) if has_theta_stable_Levi(P) do P fi od

set all_parabolics_with_theta_stable_Levi (RealForm G) = [KGPElt]:
  for S in power_set(semisimple_rank(G))
    for P in parabolics(G,(G,S))
       if has_theta_stable_Levi(P) do P fi
    od
  od

{. For each theta-stable parabolic of G, print S, Levi factor, and maximal x. .}
set print_theta_stable_parabolics (RealForm G) = void:
  let all = theta_stable_parabolics(G) in
  for (S,x):P in all do prints("S=", S, " L= ", Levi(P), "  x=",x) od;
  prints("Total: ",#all)

{. The smallest list of simple roots such that descents lead to the
  distinguished fiber. .}
set support (KGBElt x) = [int]:
  let rd=root_datum(x), delta=distinguished_involution(real_form(x)) in
  list(semisimple_rank(rd),W_elt(rd,involution(x)*delta).word.is_member)

{. Auxiliary function. .}
set support_alt(KGBElt x)=[int]:
  let rd=root_datum(x), delta=distinguished_involution(real_form(x)) in
  list(semisimple_rank(rd),W_elt(rd,delta*involution(x)).word.is_member)

{ for use in find_lambda; 64 (uniformly?) random integers between 0 and 10^5 }
set random = [int]:
  [31220,11647,37379,76487,42281,99983,92672,35013,50289,79830,47810,82416
  ,92150,84570,70610,35366,44981,21161,42049,94355,96801,10070,71505,21696
  ,42096,07832,75988,26509,62156,67549,67781,54376,72296,43134,04383,66728
  ,64236,65212,24116,12466,13033,85636,71449,80515,11480,88335,39381,66618
  ,35975,10896,05825,95823,18001,63961,14564,44737,03903,51896,99125,74288
  ,88299,14793,26802,44113]

{.find lambda so L=L(lambda)={alpha| <lambda,alpha^vee>=0}.}
set findlambda (RootDatum rd, RootDatum L) = vec:
   let k=kernel(^simple_coroots(L)) { generators intersection hyperplanes of L }
   in k* random[:n_columns(k)] { weight hopefully not on any other hyperplanes }

{ coset representatives for W(rd)/W(rd_L); with L non standard Levi subsystem.
  If L=L(lambda) the W-orbit of lambda is in bijection with this quotient}
set coset_reps (RootDatum rd, RootDatum rd_L) = [WeylElt]:
  let lambda=findlambda(rd,rd_L) in let (,elts)=generate_from(rd,lambda) in elts

{test the coset_reps function}
{
set test_coset_reps(RootDatum rd,RootDatum rd_L)=
   let co=coset_reps(rd,rd_L)
   then WL=generate_W(rd_L)
   then prods =
      for w@i in co for x@j in WL do (i,j,w*promote(x,rd)) od od
   then failures =
      for i:#prods for j:#prods
        do let (,,w)=prods[i] then (,,x)=prods[j]
        in if i!=j and x=w do (i,j) fi
      od od
   in (prods,##failures)
}
