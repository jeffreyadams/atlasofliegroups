<basic.at
<W_orbit.at
<Levi_subgroups.at
<misc.at { for is_simple_root }
<sort.at { for inv_standardisation }
<Weylgroup.at { for |cross@(WeylElt,KGBElt)| }
<group_operations { for |is_relatively_split| }


{! See "Parabolic Subgroups and Induction", in dropbox, ultimately on the
  Atlas web site.

  Fix a subset S of the simple roots, defining the complex standard
  parabolic $P_S$ of type S. We define a set KGP(S) (a
  quotient of KGB) such that (roughly) KGP(S) <-> $K\backslash G/P_S$.

  More precisely, for any KGB element $x$ and $\xi$ with $p(\xi)=x$, the set
  KGP(S) is canonically in bijection with $K_{\xi}\backslash G/P_S$; i.e.,
  $K_{\xi}$ conjugacy classes of parabolics of type S.

  S defines a partial order on KGB, generated by applying ascents in S
  Symmetrized, this generates an equivalence relation, KGB/this equivalence is
  in bijection with $K\backslash G/P_S$, so define the quotient to be KGP.

  Data: ([int],KGBElt)=(S,x) where S lists the indices of a subset of the
  simple roots of root_datum(x)

  Equivalence: (S,x)=(S',y) if these correspond to the same K orbit on $G/P_S$,
  which means:
   real_form(x)=real_form(y), S=S'  (i.e. same complex parabolic), and
   x=y in the equivalence defined by S.
  In particular, given (S,x), taking x itself for the strong real form,
  (S,x) goes to the $K_x$-conjugacy class of the standard parabolic $P_S$.

  The data type is KGPElt or Parabolic (synonyms).

  Given (S,x),
  write $[x_1,...,x_n]$ for the S-equivalence class of $x\subset$ KGB.

  The last element $x_n$ is maximal, and is uniquely determined.
  This orbit of K on $G/P_S$ is closed <=> $x_1$ is closed in KGB.

  ComplexParabolic data type:
  (RootDatum rd,[int] S) <->  G-conjugacy class of standard parabolic with
  Levi factor given by subset S of simple roots

More topics addressed in this file:
  parabolics with $\theta$-stable Levi factor;
  $\theta$-stable parabolics;
  real parabolics.
!}

set_type
[
  {. Data type for a K_orbit on G/P_S, equivalently a K-conjugacy class of
    parabolics of type S, where S is a list of simple root indices. .}
  KGPElt    = ([int] S, KGBElt x)
,
  {. Data type for a complex standard parabolic subgroup .}
  ComplexParabolic = (RootDatum root_datum,[int] S)
]

{. Data type for a K_orbit on G/P_S (synonym for KGPElt). .}
set_type Parabolic = KGPElt

{. choose from a nonempty list of KGB elements one with the smallest index. .}
set min ([KGBElt] list)= KGBElt:
  let m=list[0] in for x in list do if #x<#m then m:=x fi od; m

{. choose from a nonempty list of KGB elements one with the greatest number. .}
set max ([KGBElt] list) = KGBElt:
  let m=list[0] in for x in list do if #x>#m then m:=x fi od; m

{. the root datum of the RealForm G of a KGP element. .}
set root_datum (KGPElt(,x)) = RootDatum: root_datum(x)

{. the RealForm G of a KGP element. .}
set real_form  (KGPElt(,x)) = RealForm:  real_form(x)

{. ascents of |x| by generators in |S|; there may be duplicates. .}
set ascents ([int] S, KGBElt x) = [KGBElt]:
##for s in S
  do case status(s,x)
     in [], [], [] { descents }, { nc } [Cayley(s,x)], { C+ } [cross(s,x)]
     esac
  od

{. all descents of |x| by generators in |S|; there may be duplicates. .}
set down_neighbors ([int] S,KGBElt x) = [KGBElt]:
##for s in S
  do case status(s,x)
     in { C- } [cross(s,x)]
     , { ic } []
     , { r } let y=Cayley(s,x) in [y,cross(s,y)]
     , { nc } []
     , { C+ } []
     esac
  od

{. decide whether x is maximal in the partial order defined by S. .}
set is_maximal_for ([int] S,KGBElt x) = bool: =#ascents(S,x)

{. list maximal KGB elements in the partial order defined by S. .}
set maxima_for ([int] S,RealForm G) = [KGBElt]:
##for x in KGB(G)
  do if is_maximal_for(S,x) then [x] else [] fi od

{. (Unique) maximal element in equivalence class of x. .}
set maximal ([int] S, KGBElt x) = KGBElt:
  while let r=ascents(S,x) in (#r).> do x:=r[0] od; x

{. a minimal KGB element from an equivalence class defined by S
   (unlike |maximal(S,x)|, it is not unique). .}
set x_min (KGPElt(S,x)) = KGBElt:
  while let D=down_neighbors(S,x) in (#D).> do x:=D[0] od; x


{. build KGBElt (with canonical representative) from |S| and |x|. .}
set KGP_elt_for (KGPElt(S,):S_x) = KGPElt: (S,maximal(S_x))
{ alternative implementation:
  |set KGP_elt_for (KGPElt S_x) = KGPElt: S_x.x:=maximal(S_x); S_x|
}

{. (Unique) maximal KGB element representing a KGP element. .}
set representative = (KGPElt->KGBElt): maximal@KGPElt

{. equality of KGP elements: whether they share a K-orbit of parabolics. .}
set = (KGPElt (S,x):S_x,KGPElt (T,y):T_y) = bool:
  real_form(x)=real_form(y) and S=T and maximal(S_x)=maximal(T_y)

{. the equivalence class of a KGB element in partial order defined by S. .}
set equivalence_class_of (KGPElt(S,x):S_x) = [KGBElt]:
  let G=real_form(x), x_max=maximal(S_x)
  then todo=[x_max], seen=0, in_class = for :#x_max do false od # true
  in
  while seen < #todo
  do
    for x in down_neighbors(S,todo[seen]) next seen +:= 1
    do if not in_class[#x] then in_class[#x] := true; todo #:= x fi od
  od; { return |todo.(sort_by(#@KGBElt))|, but maybe more efficiently: }
  ## for present@i in in_class do if present then [KGB(G,i)] else [] fi od

set is_in_class_of (KGBElt x, KGPElt(S,):P) = bool:
   maximal(S,x) = maximal(P)

{. the set of KGP elements associated to a RealForm and a set of
simple roots S; KGP(G,S) is in bijection with $K\backslash G/P_S$. .}
set KGP (RealForm G,[int] S) = [KGPElt]:
  for x in maxima_for(S,G) do KGPElt:(S,x) od

{. just the index numbers (maximal x) of KGP(G,S). .}
set KGP_numbers (RealForm G,[int] S) =[int]: for (,x) in KGP(G,S) do #x od

{. whether y in $K\backslash G/P_S$ is open (maximal(y) is final in KGB). .}
set is_open (KGPElt y) = bool:
  is_maximal_for(all_simples(y.root_datum),maximal(y))

{. test whether y in $K\backslash G/P_S$ is closed (length(first element)=0). .}
set is_closed (KGPElt P) = bool: length(x_min(P)).=

{. parabolic determined by (the stabilizer in W of) a weight lambda. .}
set KGP_elt (ratvec lambda,KGBElt x) = KGPElt:
  let rd=root_datum(x)
  then (w,lambda_dom)=from_dominant(rd,lambda.numer)
  then P = list(semisimple_rank(rd),(int i)bool: =coroot(rd,i)*lambda_dom)
  in KGPElt:(P,cross(inverse(w),x))

{. the complex parabolic underlying P=(S,x). .}
set complex_parabolic (Parabolic(S,x)) = ComplexParabolic: (root_datum(x),S)


{			Complex Levi subgroups				}

{ like |Levi_datum| in Levi_subgroups.at, provide some aliases for |sub_datum| }
set complex_Levi = sub_datum@(RootDatum,[int]) { defined in basic.at }

{ contrary to |sub_datum@(RootDatum,(int->bool)|, select from simples only: }
set complex_Levi (RootDatum rd,(int->bool) select) = RootDatum:
   complex_Levi(rd,list(rd.semisimple_rank,select))

{ a synonm for |complex_Levi|, and yet another one for |sub_datum| }
set Levi = complex_Levi@ComplexParabolic { that's the first one above! }

set simple_root_indices (RootDatum rd,RootDatum rd_L) = [int]:
  for alpha in rd_L.simple_roots
  do let i=root_index(rd,alpha) in i { return |i|, but check if a simple root: }
     next assert(i<rd.semisimple_rank,"Not a standard Levi")
  od

{ a complex (standard) Levi determines a complex (standard) parabolic }
set complex_parabolic((RootDatum,RootDatum) (rd,):pair)=ComplexParabolic:
  (rd,simple_root_indices(pair))

{all (complex) parabolics of a RootDatum}
set parabolics(RootDatum rd)=[ComplexParabolic]:
for S in generate_all_subsets(#ss_rank(rd)) do (rd,S) od

{. coweight vanishing on all roots of the (standard) Levi, positive on other posroots .}
set Levi_coweight (RootDatum rd,RootDatum rd_L) = vec:
  ( rd.rank
  , for t in complement(rd.semisimple_rank,simple_root_indices(rd,rd_L))
    do fundamental_coweight(rd,t) od
  ).sum.numer
set Levi_coweight (ComplexParabolic P) = vec:Levi_coweight(P.root_datum,P.Levi)

{. weight vanishing on all roots of the (standard) Levi, positive on other posroots .}
set Levi_weight (RootDatum rd,RootDatum rd_L) = vec:
  ( rd.rank
  , for t in complement(rd.semisimple_rank,simple_root_indices(rd,rd_L))
    do fundamental_weight(rd,t) od
  ).sum.numer
set Levi_weight (ComplexParabolic P) = vec:Levi_weight(P.root_datum,P.Levi)

{coset representatives for W/W(L)
 see coset_reps@(RootDatum,RootDatum) below for more general case
}
set coset_reps_Levi (RootDatum rd,RootDatum rd_L) = [WeylElt]:
   stabiliser_quotient_of_dominant(rd, Levi_weight(rd,rd_L))

set bounded_coset_reps_Levi (RootDatum rd,RootDatum rd_L,int bound) =
      [WeylElt]:
   for (,w) in bounded_generate(rd, Levi_weight(rd,rd_L),bound) do w od

{. Test if a complex Levi defined by a set of simple roots $S$ is
   $\theta_x$-stable; .}
{ algorithm: test whether the Levi_coweight for the complex parabolic
  vanishes on all $\theta_x$-images of Levi roots }
set has_theta_stable_Levi (Parabolic(S,x)) = bool:
  let rd=root_datum(x) then H = Levi_coweight(rd,S) in
  = H*involution(x)*columns_with(is_member(S),simple_roots(rd))

{. Make a real Levi factor from P=(S,x); the complex Levi of S must
be theta-stable. .}
set Levi (Parabolic(S,x):P) = RealForm:
  assert(has_theta_stable_Levi(P),"Levi factor is not theta-stable");
  let x_min=x_min(P) then theta=involution(x_min)
  then ic_Levi=inner_class(complex_Levi(root_datum(x),S),theta)
  in { synthetic } real_form(ic_Levi,theta,torus_factor(x_min))

{. Test whether parabolic P=(S,x) is theta-stable: this means that
   the complex Levi factor L is theta-stable, P is closed, and for all
   alpha simple not in S one has alpha is imaginary or C+ wrt maximal(P). .}
set is_parabolic_theta_stable (Parabolic(S,x):P) = bool:
  has_theta_stable_Levi(P) and is_closed(P) and
  ( let x_max=maximal(P) in
    none(for j in complement(semisimple_rank(root_datum(x)),S)
         do is_strict_descent(j,x_max) { C- or real }
         od)
  )

{. Test if parabolic P=(S,x) is real: this means that L is theta-stable, P is
   open, and for all alpha simple not in S one has alpha is real or C-
   with respect to a maximal(P). .}
set is_parabolic_real(Parabolic(S,x):P) = bool:
  has_theta_stable_Levi(P) and is_open(P) and
  ( let x_max=maximal(P) in
    all(for j in complement(semisimple_rank(root_datum(x)),S)
        do is_strict_descent(j,x_max) { C- or real }
        od)
  )


{------------  unipotent radical of P ------------------}
{ see K.pdf, Section 4
  P=(S,x)
  if x=x_0:=KGB(G,0) then P is the standard parabolic P_S with simple roots S,
  and nilrad(P) is contained in the basic Borel
  in general P=(S,x) -> gP_Sg^{-1} where gxg^{-1}=x_0
  if the G-orbit of P is closed, equivalently if L contains the fundamental
  Cartan, then we can replace x with x=x_min(P) which is on the fundamental
  Cartan and then find w so that w*x=x_0
}

{. Positive coroots in the nilradical u of P (L must be theta-stable). .}
set nilrad (ComplexParabolic(rd,):P) = mat: { columns are poscoroots }
  let mu = Levi_weight(P) in
  columns_with((vec alpha_v) bool: >alpha_v*mu, poscoroots(rd))

{. Positive roots in the nilradical u of P (L must be theta-stable). .}
set nilrad_roots (ComplexParabolic(rd,):P) = mat: { columns are posroots }
  let H = Levi_coweight(P) in
  columns_with((vec alpha) bool: >H*alpha, posroots(rd))

set nilrad (Parabolic P) = mat:       nilrad(complex_parabolic(P))
set nilrad_roots (Parabolic P) = mat: nilrad_roots(complex_parabolic(P))

{nilrad roots only depend on the Levi}
set nilrad_roots(RootDatum rd,RootDatum rd_L)=mat:nilrad_roots(complex_parabolic(rd,rd_L))

{. Half sum of positive roots not in the Levi (L must be theta-stable). .}
set rho_u (ComplexParabolic P) = ratvec: { P.root_datum.rho-complex_Levi.rho }
  P.nilrad_roots.sum/2

{. Half sum of positive roots not in the Levi (L must be theta-stable). .}
set rho_u (Parabolic P) = ratvec: { rho_u(complex_parabolic(P)), which is: }
  rho_u(complex_parabolic(P))

{. Half sum of positive roots in the Levi (L must be theta-stable). .}
set rho_l (ComplexParabolic(rd,):P) = ratvec: { rho(Levi(P)) }
  let H = Levi_coweight(P) in
  columns_with((vec alpha) bool: =H*alpha, posroots(rd)).sum/2

set rho_l (Parabolic P) = ratvec: rho_l(complex_parabolic(P))

{ ----------------- alternative method to define a parabolic --------------- }
{ it is convenient to be able to define a parabolic in terms of a semisimple
  element either in \h or \h^*
}

{. Simple coroots on which weight lambda (in $\mathfrak h^*$) is zero. .}
set zero_simple_coroots (RootDatum rd, vec lambda) = [int]:
##for alpha_v@j in simple_coroots(rd)
  do if =alpha_v*lambda then [j] else [] fi
  od

{. Parabolic defined by weight lambda .}
set parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (w,lambda_dom)=from_dominant(rd,numer(lambda)) in
  Parabolic:(zero_simple_coroots(rd,lambda_dom), cross(inverse(w),x))

{. Parabolic defined by weight lambda; message whether parabolic is real
  or theta-stable. .}
set parabolic_by_wt_verbose ((ratvec,KGBElt) lambda_x) = Parabolic:
  let P = parabolic_by_wt(lambda_x) in
  if is_parabolic_theta_stable(P) then "Parabolic is theta-stable."
  elif is_parabolic_real(P) then "Parabolic is real."
  else "The parabolic is neither real nor theta-stable."
  fi.prints; P

{. Theta-stable parabolic defined by weight lambda. .}
set theta_stable_parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
   let theta=involution(x) in parabolic_by_wt((1+theta)*lambda,x)

{. Real parabolic defined by weight lambda. .}
set real_parabolic_by_wt (ratvec lambda,KGBElt x) = Parabolic:
   let theta=involution(x) in parabolic_by_wt((1-theta)*lambda,x)

{. Levi factor of parabolic defined by weight lambda. .}
set Levi_by_wt ((ratvec,KGBElt) lambda_x) = RealForm:
   Levi(parabolic_by_wt(lambda_x))

{. Levi factor of theta-stable parabolic defined by weight lambda. .}
set theta_stable_Levi_by_wt ((ratvec,KGBElt) lambda_x) = RealForm:
   Levi(theta_stable_parabolic_by_wt(lambda_x))

{. Levi factor of real parabolic defined by weight lambda. .}
set real_Levi_by_wt ((ratvec,KGBElt) lambda_x) = RealForm:
   Levi(real_parabolic_by_wt(lambda_x))

{. Positive coroots in nilradical of P defined by weight lambda
  (if L theta-stable). .}
set nilrad_by_wt ((ratvec,KGBElt) lambda_x) = mat:
   nilrad(parabolic_by_wt(lambda_x))

{. Positive roots in nilradical of P defined by weight lambda
  (if L theta-stable). .}
set nilrad_roots_by_wt ((ratvec,KGBElt) lambda_x) = mat:
  nilrad_roots(parabolic_by_wt(lambda_x))

{. Half sum of positive roots in nilradical of P defined by weight lambda (if L
theta-stable). .}
set rho_u_by_wt ((ratvec,KGBElt)  lambda_x) = ratvec:
   nilrad_roots_by_wt(lambda_x).sum / 2


{. Simple roots which are zero on coweight H (in $\mathfrak h$). .}
set zero_simple_roots (RootDatum rd, vec cowt) = [int]:
##for alpha@j in simple_roots(rd) do if =cowt*alpha then [j] else [] fi od

{. Parabolic defined by coweight H .}
set parabolic_by_cwt (ratvec H,KGBElt x) = Parabolic:
  let rd=root_datum(x) then (H_dom,w)=from_dominant(numer(H),rd) in
  Parabolic:(zero_simple_roots(rd,H_dom), cross(w,x))

{. Parabolic defined by coweight H; message whether parabolic is real
   or theta-stable. .}
set parabolic_by_cwt_verbose ((ratvec,KGBElt) H_x) = Parabolic:
  let P = parabolic_by_cwt(H_x)
  in
  if is_parabolic_theta_stable(P) then "Parabolic is theta-stable."
  elif is_parabolic_real(P) then "Parabolic is real."
  else "The parabolic is neither real nor theta-stable."
  fi.prints; P

{. Levi factor of parabolic defined by coweight H. .}
set Levi_by_cwt ((ratvec,KGBElt) H_x) = RealForm: Levi(parabolic_by_cwt(H_x))

{. Positive coroots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set nilrad_by_cwt ((ratvec,KGBElt) H_x) = mat: nilrad(parabolic_by_cwt(H_x))

{. Positive roots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set nilrad_roots_by_cwt ((ratvec,KGBElt) H_x) = mat:
  nilrad_roots(parabolic_by_cwt(H_x))

{. Half sum of roots in nilradical of P defined by coweight H
  (if L theta-stable). .}
set rho_u_by_cwt ((ratvec,KGBElt) H_x)= ratvec:
  nilrad_roots_by_cwt(H_x).sum /2

{. $\rho(L)$ for Levi of P defined by coweight H (if L theta-stable). .}
set rho_Levi_by_cwt ((ratvec,KGBElt) H_x) = ratvec: rho(Levi_by_cwt(H_x))


{ ----------------------(real) cuspidal parabolics------------------- }

{. Real parabolic defined by x has Levi factor M=centralizer(A),
  $\mathfrak u$=positive roots not in M;
  for M to be stable: x must have no C+ roots. .}
set real_parabolic (KGBElt x) = Parabolic:
  assert(no_Cplus_roots(x),"x has some C+ roots");
  parabolic_by_wt((1-involution(x))*rho(root_datum(x)),x)

{. Levi factor of real parabolic defined by x (must have no C+ roots). .}
set real_Levi (KGBElt x) = RealForm: Levi(real_parabolic(x))

{ ---------------------theta-stable split parabolics---------------- }

{. Theta-stable parabolic defined by x has Levi factor L=centralizer(T),
  $\mathfrak u$=positive roots not in L;
  for this to be stable: no C- roots. .}
set theta_stable_parabolic (KGBElt x) = Parabolic:
  assert(no_Cminus_roots(x),"x has some C- roots");
  parabolic_by_wt((1+involution(x))*rho(root_datum(x)),x)

{. Levi factor of theta-stable parabolic defined by x
  (must have no C- roots). .}
set theta_stable_Levi (KGBElt x) = RealForm: Levi(theta_stable_parabolic(x))

{. Check whether a Levi subgroup L is standard in G
  (simple roots of L are simple for G). .}
set is_standard_Levi (RealForm L,RealForm G)=bool:
   let rd=root_datum(G) in
   all(for alpha in simple_roots(L) do is_simple_root(rd,alpha) od)

{ -------------- auxiliary routines------------------}

{. List of K-conjugacy classes of given ComplexParabolic (as KGP elts). .}
set KGP (RealForm G,ComplexParabolic (,S)) = [KGPElt]:
  for x in maxima_for(S,G) do KGPElt:(S,x) od

{ This is identical to the previous function, since |Parabolic| is |KGBElt| }
{. List K-conjugacy classes of given ComplexParabolic (as Parabolics). .}
set parabolics (RealForm G,ComplexParabolic (,S)) = [Parabolic]:
  for x in maxima_for(S,G) do Parabolic:(S,x) od

{. List K-conjugacy classes of given ComplexParabolic that are theta-stable. .}
set theta_stable_parabolics (RealForm G,ComplexParabolic P) = [Parabolic]:
##for Q in parabolics(G,P)
  do if is_parabolic_theta_stable(Q) then [Q] else [] fi
  od

{. List all theta-stable parabolics for G. .}
set theta_stable_parabolics (RealForm G) = [Parabolic]:
## { concatenate all loop bodies }
  for S in power_set(semisimple_rank(G))
  do theta_stable_parabolics(G,ComplexParabolic:(G,S))
  od

{. List all theta-stable parabolics of G, of type S. .}
set theta_stable_parabolics_type (RealForm G,[int] P) = [Parabolic]:
  let result=[Parabolic]:[] in
  for (Q,y) in theta_stable_parabolics(G) do if Q=P then result#:=(Q,y) fi od;
  result

{. List all theta-stable parabolics of G with relatively split L. .}
set all_rel_split_theta_stable_parabolics (RealForm G) = [Parabolic]:
##for P in theta_stable_parabolics(G)
  do if is_relatively_split(Levi(P)) then [P] else [] fi
  od

set all_real_parabolics (RealForm G) = [Parabolic]:
##for S in power_set(semisimple_rank(G))
  do
  ##for P in parabolics(G,(G,S))
    do if is_parabolic_real(P) then [P] else [] fi
    od
  od

set parabolics_with_theta_stable_Levi (RealForm G,[int] S) = [Parabolic]:
##for P in parabolics(G,(G,S))
  do if has_theta_stable_Levi(P) then [P] else [] fi
  od

set minimal_real_parabolic(RealForm G)=Parabolic:real_parabolic(G.x_open)
set minimal_real_Levi(RealForm G)=RealForm:G.minimal_real_parabolic.Levi

set maximal_parabolics(RootDatum rd)=[ComplexParabolic]:
for i:rd.ss_rank do (rd,delete(#rd.ss_rank,i)) od

{Find equivalence classes of non-imaginary simple roots w.r.t. max. x, for
alpha \cong alpha' if (1-theta)(alpha)=(1-theta(alpha')}
set classes_for_real_parabolics (RealForm G)=[[int]]:
   let theta=trivial(G).x.involution, sr=simple_roots(G) then list=[int]:
   ##for alpha@i in sr do if not is_imaginary(theta)(alpha) then [i] else []  fi od
   then result=[[int]]:[] in
   for i in list do if is_real(theta)(sr[i]) then result#:=[i] else
    let temp=[int]:
    ##for j in list do if j >= i and (1-theta)*sr[i]=(1-theta)*sr[j]
     and all(for v in result do all(for n in v do j!=n od) od) then [j] else [] fi od in
    result#:=temp fi od;
    ##for v in result do if #v>0 then [v] else [] fi od

{Find equivalence classes of non-imaginary simple roots w.r.t. max. x, for
alpha \cong alpha' if (1-theta)(alpha)=(1-theta(alpha')}
set classes_for_theta_parabolics (RealForm G)=[[int]]:
   let theta=distinguished_involution(G), sr=simple_roots(G) then list=[int]:
   ##for alpha@i in sr do if not is_real(theta)(alpha) then [i] else []  fi od
   then result=[[int]]:[] in
   for i in list do if is_imaginary(theta)(sr[i]) then result#:=[i] else
    let temp=[int]:
    ##for j in list do if j >= i and (1+theta)*sr[i]=(1+theta)*sr[j]
     and all(for v in result do all(for n in v do j!=n od) od) then [j] else [] fi od in
    result#:=temp fi od;
    ##for v in result do if #v>0 then [v] else [] fi od


{maximal parabolics among all real parabolics of G=G(R)
not the same as real forms of maximal parabolics of G(C)
}
set maximal_real_parabolics(RealForm G)=[KGPElt]:
   let x=trivial(G).x in let theta=x.involution then sr=simple_roots(G) in
   let S=[int]: ##for i:#sr do if is_imaginary(theta)(sr[i]) then [i] else [] fi od
   in let list=classes_for_real_parabolics(G) then n=#list in
   for i:n do let RS=S in for v in delete(list,i) do RS:=RS##v od; (RS,x) od

{theta_stable parabolics, maximal among all such
unlike the real_parabolic case, these have different x-values}
set maximal_theta_parabolics(RealForm G)=[KGPElt]:
   let theta= distinguished_involution(inner_class(G))
   then sr=simple_roots(G) in
   let S=[int]: ##for i:#sr do if is_real(theta)(sr[i]) then [i] else [] fi od
   in let list=classes_for_theta_parabolics(G) then n=#list in
   ## for i:n do let RS=S in for v in delete(list,i) do RS:=RS##v od;
   theta_stable_parabolics (G,(root_datum(G),RS)) od


{theta_stable parabolics, maximal among all such
unlike the real_parabolic case, these have different x-values
this is a brute force search, it can be improved along the lines of
maximal_real_parabolics}
{set maximal_theta_parabolics(RealForm G)=
let theta_parabolics=theta_stable_parabolics(G) then
proper_theta_parabolics=##for P in theta_parabolics do if #P.S<G.ss_rank then [P] else [] fi od in
##for P in proper_theta_parabolics do
 if any(for Q in proper_theta_parabolics do  P.x=Q.x and is_proper_subset(P.S,Q.S) od) then [] else [P] fi od

set all_parabolics_with_theta_stable_Levi (RealForm G) = [KGPElt]:
##for S in power_set(semisimple_rank(G))
  do
  ##for P in parabolics(G,(G,S))
    do if has_theta_stable_Levi(P) then [P] else [] fi
    od
  od
}
{. For each theta-stable parabolic of G, print S, Levi factor, and maximal x. .}
set print_theta_stable_parabolics (RealForm G) = void:
  let all = theta_stable_parabolics(G) in
  for (S,x):P in all do prints("S=", S, " L= ", Levi(P), "  x=",x) od;
  prints("Total: ",#all)

{. The smallest list of simple roots such that descents lead to the
  distinguished fiber. .}
set support (KGBElt x) = [int]:
  {note: x.w has the distinguished involution in it}
  list(x.root_datum.semisimple_rank,x.w.word.is_member)

set support_dual (KGBElt x) = [int]:
let w_long=x.root_datum.w0 in 
  list(x.root_datum.semisimple_rank,(w_long*x.w.word).is_member)

{. Auxiliary function. .}
set support_alt(KGBElt x)=[int]:
  let rd=root_datum(x), delta=distinguished_involution(real_form(x)) in
  list(semisimple_rank(rd),W_elt(rd,delta*involution(x)).word.is_member)

{ for use in find_lambda; 64 (uniformly?) random integers between 0 and 10^5 }
set random = [int]:
  [31220,11647,37379,76487,42281,99983,92672,35013,50289,79830,47810,82416
  ,92150,84570,70610,35366,44981,21161,42049,94355,96801,10070,71505,21696
  ,42096,07832,75988,26509,62156,67549,67781,54376,72296,43134,04383,66728
  ,64236,65212,24116,12466,13033,85636,71449,80515,11480,88335,39381,66618
  ,35975,10896,05825,95823,18001,63961,14564,44737,03903,51896,99125,74288
  ,88299,14793,26802,44113]

{.find lambda so L=L(lambda)={alpha| <lambda,alpha^vee>=0}.}
set findlambda (RootDatum rd, RootDatum L) = vec:
   let k=kernel(^simple_coroots(L)) { generators intersection hyperplanes of L }
   in k* random[:n_columns(k)] { weight hopefully not on any other hyperplanes }


{ coset representatives for W(rd)/W(rd_L); with L non standard Levi subsystem.
  If L=L(lambda) the W-orbit of lambda is in bijection with this quotient}
set coset_reps (RootDatum rd, RootDatum rd_L) = [WeylElt]:
   stabiliser_quotient_of_dominant(rd,findlambda(rd,rd_L))



{test the coset_reps function}
{set test_coset_reps(RootDatum rd,RootDatum rd_L)=
let co=coset_reps(rd,rd_L) then
WL=generate_W(rd_L) then
prods=##for w@i in co do for x@j in WL do (i,j,w*convert_to(rd,x)) od od then
failures=##for i:#prods do for j:#prods do
  let (,,w)=prods[i] then
  (,,x)=prods[j] in
  if i!=j  and x=w then [(i,j)] else [] fi od od in (prods,##failures)
}

{. If L is a theta-stable Levi factor in G,  KGB for L embeds in KGB for G. .}
set embed_KGB (KGBElt x_L,RealForm G) = KGBElt:
  KGB_elt(G,involution(x_L), torus_factor(x_L))

{. Given a KGB element of G, find one for the theta-stable Levi L which maps to it. .}
set inverse_embed_KGB (KGBElt x_G,RealForm L) = KGBElt:
  KGB_elt(L,involution(x_G), torus_factor(x_G))

{. Given an involution theta and a root datum, return the set S of complex roots
   containing the first positive representative of each quadruple
   ($\pm$ alpha,$\pm$ theta(alpha)). .}

set makeS (mat theta,RootDatum rd) = mat:
  columns_with((int j,vec alpha):posroot_index(rd,theta*alpha)>j,posroots(rd))

{. As the previous function, with argument a KGB element x determining the
   involution and root datum .}
set makeS (KGBElt x) = mat: makeS(involution(x),root_datum(x))

{. Half sum of roots in chosen set S of complex roots, described above. .}
set rho_S ((mat,RootDatum)pair) = ratvec: sum(makeS(pair))/2

{. As previous function, with argument KGB element x. .}
set rho_S (KGBElt x)            = ratvec: sum(makeS(x))/2

{. Given a Levi subgroup L of G, construct the parabolic with Levi L
  (this reverses Levi(P) defined in parabolics.at). .}
set make_parabolic (RealForm L,RealForm G)=Parabolic:
   assert(is_standard_Levi(L,G),"L is not standard in G");
   let rdl=root_datum(L) in
   let S=[int]:[] in for alpha@i in simple_roots(G) do
   if is_posroot((rdl,alpha)) then S #:= i fi od; (S,embed_KGB(KGB(L,0),G))
