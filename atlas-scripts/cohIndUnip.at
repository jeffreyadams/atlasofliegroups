< misc.at {for simple_root_index}
< Dirac.at {for thetaStable}
< weak_packets.at {for unipotent_representations}
< time.at {for print_time_string}

{enumerate weakly fair cohomologically induced from unipotent reps in
the FPP}

{delta-fixed wts for G}

set complex_simple(InnerClass ic) = [int]:
    for j:ic.semisimple_rank
    do if  simple_root_index(ic,
       (distinguished_involution(ic)*ic.simple_roots[j])) > j
       then [j]
       else []
       fi
    od.##

set imag_simple(InnerClass ic) = [int]:
    for j:ic.semisimple_rank
    do if =(distinguished_involution(ic)-1)*ic.simple_roots[j]
       then [j]
       else []
       fi
    od.##

{either fundamental weight xi or sum of a pair (xi, delta*xi)}
set delta_fixed_fund_wts(InnerClass ic) = [ratvec]:
    let delta = distinguished_involution(ic)
    then listcplx = complex_simple(ic)
    then listimag = imag_simple(ic)
    in for j in listimag do ic.fundamental_weights[j] od ##
       for j in listcplx do (1+delta)*ic.fundamental_weights[j] od

set delta_fixed_sums(InnerClass ic) = [ratvec]:
    let list = delta_fixed_fund_wts(ic)
    then B = box(2,#list)
    in for j:#B-1 from 1
    	do sum(ic.rank, for ell@k in list
	   	       do B[j][k]*ell
		       od)
	od

{this is all theta-stable Q}
set Qs(RealForm G) = [KGPElt]:
    let X = thetaStable(G)
    in for ell in delta_fixed_sums(G)
       do let repQs = for x in X
       	      	      do parabolic_by_wt(ell,x)
		      od
	  in for Q@j in repQs
	     do if any(for k:j do repQs[k] = Q od)
		then []
		else [Q]
		fi
             od.##
       od.##

{Levis of all theta-stable Q}
set Ls(RealForm G) = [RealForm]:
    for Q in Qs(G) do Q.Levi od

{all the central-for-L weights that can be subtracted from a
unipotent on L = Q.Levi, shifted by a [not nec dominant?] central for
L ratvec v, to get a weakly fair induction for G, with a chance to be FPP}

set shifts(KGPElt Q,ratvec v) = [vec]:
    let G = Q.real_form, tworhou = two_rho_u(Q) {, S = Q.S}
    {then T = complement(G.semisimple_rank, Q.S)}
    then mups = null(G.semisimple_rank), mdowns = null(G.semisimple_rank)
    then () = for j:G.semisimple_rank
    	 do mups[j] := ((tworhou + 2*v)*(G.simple_coroots[j]))\2 +1;
	 {upper bound is the weakly fair condition}
	    mdowns[j] := v*(G.simple_coroots[j])\1
	 {lower bound is the chance of FPP condition}
	 od
    then terms = delta_fixed_fund_wts(G)
    then mcplxups = for j in complex_simple(G) do mups[j] od
    then mimagups = for k in imag_simple(G) do mups[k] od
    then mcplxdowns = for j in complex_simple(G) do mdowns[j] od
    then mimagdowns = for k in imag_simple(G) do mdowns[k] od
    then mcplx = mcplxups - mcplxdowns
    then mimag = mimagups - mimagdowns
    then Qbox = box(mimag##mcplx)
    then Qboxshifted = for b in Qbox do b + mimagdowns##mcplxdowns od
    in for b in Qboxshifted
       do let ell = sum(G.rank, for k@j in b
       	  	      		do k*terms[j]
		      		od)
	  in if ell.denom = 1
	     then [ratvec_as_vec(ell)]
	     else []
	     fi
       od.##

{all the weights that can be subtracted from a unipotent on L to get a weakly
fair induction for G}
set shifts(KGPElt Q) = [vec]:
    shifts(Q, null(Q.real_form.rank)/1)

{to be used as shift in unipotent_representations(Levi, shift)}
set offsets(KGPElt Q) = [ratvec]:
    let G = Q.real_form, tworhou = two_rho_u(Q)
    then ks = [int]:
    	 for j@k in (imag_simple(G)##complex_simple(G))
	 do if tworhou*G.simple_coroots[j] > 0 then [k]
	    else []
	    fi
	 od.##
    then terms = delta_fixed_fund_wts(G)
    then shiftBox = box(2,#ks)
    in for b in shiftBox
       do sum(G.rank, for k@i in ks
       	  	      do b[i]*terms[k]
		      od)/2
       od

set is_FPP(RootDatum rd, ratvec gamma) = bool:
    all(for alphavee in rd.simple_coroots
    	do gamma*alphavee <= 1 and gamma*alphavee >= 0
	od)

{assume v is {G-dominant and?} central for L}
set coh_ind_unip(KGPElt Q, Param_hash Uhash, ratvec v) = void:
    let L = Q.Levi, G = Q.real_form
    then uLs = unipotent_representations(L,v)
    then Qshifts = shifts(Q,v)
    in void: for pL in uLs
       	     do for tau in Qshifts
       	     	do let P = theta_induce_irreducible(parameter(pL.x,
				pL.lambda - tau, pL.nu), G)
	     	   in void:
		      for @q in P
		      do if is_FPP(G,q.infinitesimal_character)
	     	       	       then Uhash.match(q)
			       else -1
			       fi
		      od
		 od
	     od

set coh_ind_unip(KGPElt Q, Param_hash Uhash) = void:
    coh_ind_unip(Q, Uhash, null(Q.real_form.rank)/1)

set coh_ind_unip_long(RealForm G, Param_hash Uhash) = void:
    let startTime = elapsed_ms(), oldSize = Uhash.size()
    then () = for Q in Qs(G)
    	      do for v in offsets(Q)
    	      	 do coh_ind_unip(Q,Uhash,v) od
	      od
    then () = prints("Found ",Uhash.size() - oldSize, " new unitary reps.")
    then () = prints("Total time for coh_ind_unip_long = ",
    	      	  print_time_string(elapsed_ms() - startTime))
    in ()

set coh_ind_unip(RealForm G, Param_hash Uhash) = void:
    let startTime = elapsed_ms(), oldSize = Uhash.size()
    then () = for Q in Qs(G) do coh_ind_unip(Q,Uhash) od
    then () = prints("Found ",Uhash.size() - oldSize, " new unitary reps.")
    then () = prints("Total time for coh_ind_unip = ",
    	      	  print_time_string(elapsed_ms() - startTime))
    in ()
