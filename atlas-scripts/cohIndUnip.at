< misc.at {for simple_root_index}
< Dirac.at {for thetaStable}
< weak_packets.at {for unipotent_representations}
< time.at {for print_time_string}
{enumerate weakly fair cohomologically induced from unipotent reps in
the FPP}

{delta-fixed wts for G}


set is_dom_FPP(RootDatum rd, ratvec gamma) = bool:
    all(for alphavee in rd.simple_coroots
    	do gamma*alphavee <= 1 and gamma*alphavee >= 0
	od)

set is_FPP(RootDatum rd, ratvec gamma) = bool:
    is_dom_FPP(rd,dominant(rd,gamma))

set imag_simple(InnerClass ic) = [int]:
    for j:ic.semisimple_rank
    do if =(distinguished_involution(ic)-1)*ic.simple_roots[j]
       then [j]
       else []
       fi
    od.##

set complex_simple(InnerClass ic) = [int]:
    for j:ic.semisimple_rank
    do if  simple_root_index(ic,
       (distinguished_involution(ic)*ic.simple_roots[j])) > j
       then [j]
       else []
       fi
    od.##

set delta_fixed(InnerClass ic) = [int]:
    imag_simple(ic)##complex_simple(ic)

{either fundamental weight xi or sum of a pair (xi, delta*xi)}
set delta_fixed_fund_wts(InnerClass ic) = [ratvec]:
    let delta = distinguished_involution(ic)
    in for j in imag_simple(ic) do ic.fundamental_weights[j] od ##
       for j in complex_simple(ic) do (1+delta)*ic.fundamental_weights[j] od

set delta_fixed_sums(InnerClass ic) = [ratvec]:
    let list = delta_fixed_fund_wts(ic)
    then B = box(2,#list)
    in for j:#B-1 from 1
    	do sum(ic.rank, for ell@k in list
	   	       do B[j][k]*ell
		       od)
	od

{this is all theta-stable Q}
set Qs(RealForm G) = [KGPElt]:
    let X = thetaStable(G)
    in for ell in delta_fixed_sums(G)
       do let repQs = for x in X
       	      	      do parabolic_by_wt(ell,x)
		      od
	  in for Q@j in repQs
	     do if any(for k:j do repQs[k] = Q od)
		then []
		else [Q]
		fi
             od.##
       od.##

{Levis of all theta-stable Q}
set Ls(RealForm G) = [RealForm]:
    for Q in Qs(G) do Q.Levi od

{all the central-for-L weights that can be subtracted from a
unipotent on L = Q.Levi, shifted by a [not nec dominant?] central for
L ratvec v, to get a weakly fair induction for G, with a chance to be FPP}
set shifts(KGPElt Q,ratvec v) = [vec]:
    let G = Q.real_form, tworhou = two_rho_u(Q) {, S = Q.S}
    {then T = complement(G.semisimple_rank, Q.S)}
    then mups = for j:G.semisimple_rank
    	 do ((tworhou + 2*v)*(G.simple_coroots[j]))\2 +1
	 {upper bound is the weakly fair condition}
	 od
    {then () = prints("mups = ",mups)}
    then mdowns = for j:G.semisimple_rank
    	 	  do v*(G.simple_coroots[j])\1
	 	  {lower bound is the chance of FPP condition}
	 	  od
    {then () = prints("mdowns = ",mdowns)}
    then ms = mups - mdowns
   { then () = prints("ms = ",ms)}
    then terms = delta_fixed_fund_wts(G)
    then Qbox = box(ms) {Qbox = box(mimag##mcplx)}
    then Qboxshifted = for b in Qbox do b + mdowns {mimagdowns##mcplxdowns} od
    in for b in Qboxshifted
       do let ell = sum(G.rank, for k@j in b
       	  	      		do k*terms[j]
		      		od)
	  in if ell.denom = 1
	     then [ratvec_as_vec(ell)]
	     else []
	     fi
       od.##

{Weakly good range allows some NEGATIVE shifts from rho_u. Include those as well.}
set more_shifts(KGPElt Q, ratvec v) = [vec]:
    let G = Q.real_form, rhou = rho_u(Q), S = Q.S
    then T = complement(G.semisimple_rank, Q.S)
    then Qdeltafixed = set_bit_positions(AND(to_bitset(T),to_bitset(delta_fixed(G))))
    then mups = for j in Qdeltafixed
    	      	do ((rhou+v)*(G.simple_coroots[j]))\1 +1
		od
	 {upper bound is the weakly fair condition}
    then mdowns = for j in Qdeltafixed
    	 	  do 1- ((dominant(G.simple_coroots[j],G))*G.rho)\1
		  od
 	 {lower bound is the chance of FPP condition}
	 {maybe mdowns should depend on v??}
    then ms = mups - mdowns
    then terms = delta_fixed_fund_wts(G)
    then Qbox = box(ms)
    then Qboxshifted = for b in Qbox do b + mdowns od
    in for b in Qboxshifted
       do let ell = sum(G.rank, for j@k in Qdeltafixed
       	  	      		do b[k]*terms[j]
		      		od)
	  in if ell.denom = 1
	     	{and is_FPP(G,ell)}
	     then [ratvec_as_vec(ell)]
	     else []
	     fi
       od.##

{all the weights that can be subtracted from a unipotent on L to get a weakly
fair induction for G}
set shifts(KGPElt Q) = [vec]:
    shifts(Q, null(Q.real_form.rank)/1)

set more_shifts(KGPElt Q) = [vec]:
    more_shifts(Q, null(Q.real_form.rank)/1)

{Each is to be used as a shift in unipotent_representations(Levi, offset). Each is central in L.}
set offsets(KGPElt Q) = [ratvec]:
    let G = Q.real_form, tworhou = two_rho_u(Q)
    then terms = delta_fixed_fund_wts(G)
    then ks = [int]: {these are the simple coroots positive on rhou,
    up to distinguished involution delta}
    	 for j@k in (imag_simple(G)##complex_simple(G))
	 do if tworhou*G.simple_coroots[j] > 0 then [k]
	    else []
	    fi
	 od.##
    then terms = delta_fixed_fund_wts(G)
    then shiftBox = box(2,#ks)
    in for b in shiftBox
       do sum(G.rank, for k@i in ks
       	  	      do b[i]*terms[k]
		      od)/2
       od
{this is broken because of unipotent_representations2}
{set coh_ind_unip2(KGPElt Q, Param_hash Uhash) = void:
    let L = Q.Levi, G = Q.real_form
    then uLs = unipotent_representations2(L)
    then radRat = radical_rat(L)
    in void: for pL in uLs
       	     do for tau in shifts(Q, radRat*(pL.lambda))
       	     	do let P = theta_induce_irreducible(parameter(pL.x,
				pL.lambda - tau, pL.nu), G)
	     	   in void:
		      for @q in P
		      do if is_FPP(G,q.infinitesimal_character)
	     	       	       then Uhash.match(q)
			       else -1
			       fi
		      od
		 od
	     od}

{assume v is {G-dominant and?} central for L}
set coh_ind_unip(KGPElt Q, Param_hash Uhash, ratvec v) = void:
    let L = Q.Levi, G = Q.real_form
    then uLs = unipotent_representations(L,v)
    then Qshifts = shifts(Q,v)
    in void: for pL in uLs
       	     do for tau in Qshifts
       	     	do let P = theta_induce_irreducible(parameter(pL.x,
				pL.lambda - tau, pL.nu), G)
	     	   in void:
		      for @q in P
		      do if is_FPP(G,q.infinitesimal_character)
	     	       	       then Uhash.match(q)
			       else -1
			       fi
		      od
		 od
	     od

{assume v is {G-dominant and?} central for L}
set coh_ind_unip_more(KGPElt Q, Param_hash Uhash,ratvec v) = void:
    let L = Q.Levi, G = Q.real_form
    then uLs = unipotent_representations(L,v), rhou = rho_u(Q)
    then Qshifts = more_shifts(Q,v)
    in void: for pL in uLs
       	     do for tau in Qshifts
       	     	do let gamma = pL.infinitesimal_character + rhou -tau
		   in if is_FPP(G,gamma)
		      then let P = theta_induce_irreducible(parameter(pL.x,
				pL.lambda - tau, pL.nu), G)
	     	   	   in void: for @q in P
		      	     	    do Uhash.match(q)
		      		    od
		      fi
		 od
	     od

set coh_ind_unip(KGPElt Q, Param_hash Uhash) = void:
    coh_ind_unip(Q, Uhash, null(Q.real_form.rank)/1)

set coh_ind_unip_verbose = false
set coh_ind_unip_long(RealForm G, [KGPElt] Qs, Param_hash Uhash) = void:
    let startTime = elapsed_ms(), oldSize = Uhash.size()
    then () = for Q@j in Qs
    	      do for v in offsets(Q)
    	      	 do coh_ind_unip(Q,Uhash,v)
		 od;
		 if coh_ind_unip_verbose and
		    j%(max(#Qs\20,2)) = 0
		 then prints("finished parabolic #", j,
		    " after ",print_time_string(elapsed_ms() - startTime),
		    "; found ",Uhash.size() - oldSize, " reps.")
		 fi
	      od
    then () = if time_verbose
    	 then prints("Found ",Uhash.size() - oldSize, " new unitary reps.");
    	      prints("Total time for coh_ind_unip_long = ",
    	      	  print_time_string(elapsed_ms() - startTime))
         fi
    in ()

set coh_ind_unip_more(RealForm G, [KGPElt] Qs, Param_hash Uhash) = void:
    let startTime = elapsed_ms(), oldSize = Uhash.size()
    then () = for Q@j in Qs
    	      do for v in offsets(Q)
    	      	 do coh_ind_unip_more(Q,Uhash,v)
		 od;
		 if coh_ind_unip_verbose and
		    j%(max(#Qs\20,2)) = 0
		 then prints("finished parabolic #", j,
		    " after ",print_time_string(elapsed_ms() - startTime),
		    "; found ",Uhash.size() - oldSize, " reps.")
		 fi
	      od
    then () = if time_verbose
    	 then prints("Found ",Uhash.size() - oldSize, " new unitary reps.");
    	      prints("Total time for coh_ind_unip_long = ",
    	      	  print_time_string(elapsed_ms() - startTime))
         fi
    in ()


{just induced from proper Q}
set coh_ind_unip_long(RealForm G, Param_hash Uhash) = void:
    coh_ind_unip_long(G,Qs(G),Uhash)

set coh_ind_unip_more(RealForm G, Param_hash Uhash) = void:
    coh_ind_unip_more(G,Qs(G),Uhash)

{include unip reps of G}
set coh_ind_unip_long_G(RealForm G, Param_hash Uhash) = void:
    coh_ind_unip_long(G,Qs(G)#parabolic_by_wt(null(G.rank),KGB(G,0)),Uhash)

set coh_ind_unip_more_G(RealForm G, Param_hash Uhash) = void:
    coh_ind_unip_more(G,Qs(G)#parabolic_by_wt(null(G.rank),KGB(G,0)),Uhash)
{broken because of dependence on unipotent_representations2}
{set coh_ind_unip_long2(RealForm G, Param_hash Uhash) = void:
    let startTime = elapsed_ms(), oldSize = Uhash.size(), Qs = Qs(G)
    then () = for Q@j in Qs
              do coh_ind_unip2(Q,Uhash);
	      	 if j%(max(#Qs\20,2)) = 0 then prints("finished parabolic #", j,
		    " after ",print_time_string(elapsed_ms() - startTime),
		    "; found ",Uhash.size() - oldSize, " reps.") fi
	      od
    then () = prints("Found ",Uhash.size() - oldSize, " new unitary reps.")
    then () = prints("Total time for coh_ind_unip_long2 = ",
    	      	  print_time_string(elapsed_ms() - startTime))
    in ()}

set coh_ind_unip(RealForm G, Param_hash Uhash) = void:
    let startTime = elapsed_ms(), oldSize = Uhash.size(), Qs = Qs(G)
    then () = for Q@j in Qs
    	      do coh_ind_unip(Q,Uhash);
	         if coh_ind_unip_verbose
		    and j%(max(#Qs\20,2)) = 0
		 then prints("finished parabolic #", j,
		    " after ",print_time_string(elapsed_ms() - startTime),
		    "; found ",Uhash.size() - oldSize, " reps.");
		 oldSize := Uhash.size()
		 fi
    	      od
    then () = if time_verbose
    	 then prints("Found ",Uhash.size() - oldSize, " new unitary reps.");
    	      prints("Total time for coh_ind_unip = ",
    	      	  print_time_string(elapsed_ms() - startTime))
	      fi
    in ()
