<basic.at
<combinatorics.at { for partitions@int }
<character_tables.at
<character_table_B.at  {loads type C also}
<character_table_D.at
<character_table_F.at
<character_table_G.at

{now for the individual types}

{  type A }

set test_type_A (RootDatum rd) = [int]:
(  let  (lt,map)=Cartan_matrix_type(rd.Cartan_matrix)
   then factors=simple_factors(lt) then nf=#factors
in assert(nf=1,"Root datum diagram is not connected ("+ nf +" components)")
;  let (type,rank)=factors[0] then n=rank+1
in assert(type="A","Not a type A root datum")
;  map
)

{ get an actual WeylElt from a partition <-> conjugacy class in W}
set conjugacy_class_S(Partition P) = WeylElt:  {for GL(n)}
(  assert(is_positive(P), "P is not a partition (has non-positive entries)")
;  let n=sum(P)
   , bars= let sum=-1 in for p in P do sum+:=p od { W generators to suppress }
in W_elt(if =n then trivial_group else GL(n) fi,complement(n,bars))
)

{ for other type A root data like SL(n), we need to work a bit harder }
set conjugacy_class_A(RootDatum rd) = (Partition->WeylElt):
   let map = test_type_A(rd) then n=#map+1 in
   (Partition P) WeylElt:
(  assert(is_positive(P), "P is not a partition (has non-positive entries)")
;  let bars= let sum=-1 in for p in P do sum+:=p od { W generators to suppress }
in assert(!=#bars and bars~[0]=#map
         ,"Partition is of "+(bars~[0]+1)+" rather than "+n)
;  W_elt(rd,for s in complement(n,bars) do map[s] od)
)

{ The inverse operation, find cycle type of a WeylElt for GL(n). This could be
  done using |classic_permutation| and |cycle_type| from combinatorics.at, but
  knowing that we have a GL(n) element, we can be a bit more efficient.
}
set cycle_type_GL(WeylElt w) = Partition:
  let n=w.root_datum.rank in cycle_type((vec:#n)*w)

{ somtimes we can avoid sorting the cycles into decreasing length order }
set unsorted_cycle_type_GL(WeylElt w) = [int]:
  let n=w.root_datum.rank in
  for cycle in permutation_cycles((vec:#n)*w) do #cycle od

set class_table_S(int n) = WeylClassTable:
  let rd=GL(n), reps = [A_class]: partitions(n)
  in W_class_table(rd, for rep in reps do conjugacy_class_S(rep) od
		  , (WeylElt w)int:
		    cycle_class_order(unsorted_cycle_type_GL(w))
		  , (WeylElt w0) (WeylElt->bool): let lambda=cycle_type_GL(w0) in
		    (WeylElt w)bool: cycle_type_GL(w)=lambda
		  )

set class_table_A(RootDatum rd) = WeylClassTable:
  let partitions = [A_class]: partitions(rd.semisimple_rank+1)
  , type(WeylElt w) = Partition: cycle_type(classic_permutation(w))
  , class_rep = (Partition->WeylElt): conjugacy_class_A(rd)
  in W_class_table( rd, for lambda in partitions do class_rep(lambda) od
		  , (WeylElt w)int: cycle_class_order(type(w))
		  , (WeylElt w0) (WeylElt->bool):
		     let lambda=type(w0) in (WeylElt w)bool: type(w)=lambda
		  )

set character_table_S(int n) = CharacterTable:
  let partitions_n = partitions(n)
  then classes = [WeylElt,classical_class,string]:
    for lambda in partitions_n
    do (conjugacy_class_S(lambda),lambda.class_A,lambda.to_string)
    od
  , irreps = [classical_irrep,string,[int]]:
    for lambda in partitions_n ~ { reversal to go from trivial to sign }
    do (irrep_A(lambda),lambda.to_string
       ,for cyc_type in partitions_n do Murnaghan_Nakayama(lambda,cyc_type) od
       )
    od
  in character_table(class_table_S(n),classes,irreps)

set character_table_A(RootDatum rd) = CharacterTable:
  let partitions = [A_class]: partitions(rd.semisimple_rank+1)
  , class_rep = (Partition->WeylElt): conjugacy_class_A(rd)
  then classes = [WeylElt,classical_class,string]:
    for lambda in partitions
    do (class_rep(lambda),lambda.class_A,lambda.to_string)
    od
  , irreps = [classical_irrep,string,[int]]:
    for lambda in partitions ~ { reversal to go from trivial to sign }
    do (irrep_A(lambda),lambda.to_string
       ,for cyc_type in partitions do Murnaghan_Nakayama(lambda,cyc_type) od
       )
    od
  in character_table(class_table_A(rd),classes,irreps)

set simple_character_table(LieType lt) = CharacterTable:
(  let (letter,rank)=lt.simple_type { this also asserts that |lt| is simple }
in case char_index(letter,"ABCDEFG")
   in character_table_A(SL(rank+1))
   ,  character_table_B(rank)
   ,  character_table_C(rank)
   ,  character_table_D(rank)
   ,  error("Type E simple character table not implemented here")
   ,  character_table_F4()
   ,  character_table_G2()
   else error("Classification of simple types exploded!")
   esac
)

{ to be rewitten, but used in reductive_character_table.at: }
set simple_character_table(RootDatum rd) = CharacterTable:
  simple_character_table(rd.Lie_type)
