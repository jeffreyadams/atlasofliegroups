<nilpotent_orbits.at
<character_tables.at
<character_table_tensor.at

{tables encoding the Springer correspondence}

set_type [SpringerTable=
  (CharacterTable ct,
  [ComplexNilpotent] orbits,
  (ComplexNilpotent->ComplexNilpotent) dual_map,
  (ComplexNilpotent->ComplexNilpotent) dual_map_i,
  (ComplexNilpotent->int) springer
  )]

set root_datum(SpringerTable st)=RootDatum: st.ct.root_datum
set root_datum_parent(SpringerTable st)=RootDatum: st.ct.root_datum_parent
set characters(SpringerTable st)=[[int]]:st.ct.characters
set fake_degrees(SpringerTable st)=[int]:st.ct.fake_degrees
set character_table(SpringerTable st)=CharacterTable: st.ct

{equality of normalized diagrams}
set equal([[int]] a,[[int]] b)=bool:
if #a != #b then false else
all(for i:#a do a[i]=b[i] od) fi

set orbit_index(SpringerTable st,ComplexNilpotent orbit)=int:
let diagram=orbit.diagram_normalized in 
first(for O in st.orbits do equal(O.diagram_normalized,diagram) od)

{ComplexNilpotent given by diagram}
set orbit_by_diagram([ComplexNilpotent] orbits,[vec] diagram)=ComplexNilpotent:
let index=first(for i:#orbits do equal(orbits[i].diagram_normalized,diagram) od) in orbits[index]

set orbit_by_diagram(SpringerTable st,[vec] diagram)=ComplexNilpotent:
orbit_by_diagram(st.orbits,diagram)

set orbit_by_diagram(RootDatum rd,[vec] diagram)=ComplexNilpotent:
let index=first(for i:#rd.orbits do equal(rd.orbits[i].diagram_normalized,diagram) od) in
rd.orbits[index]

set dual_orbit_by_diagram(SpringerTable st,[vec] diagram)=ComplexNilpotent:
let index=first(for i:#st.root_datum.dual.orbits do
equal(st.root_datum.dual.orbits[i].diagram_normalized,diagram) od) in
st.root_datum.dual.orbits[index]

{dual_map_i(dual_map(O))}
set special_closure(SpringerTable st,ComplexNilpotent O)=ComplexNilpotent:
{O.root_datum here: need this to be an orbit O.root_datum}
orbit_by_diagram(O.root_datum,st.dual_map_i(st.dual_map(O)).diagram_normalized)
set special_closure(SpringerTable st)=(ComplexNilpotent->ComplexNilpotent):(ComplexNilpotent O):special_closure(st,O)

{orbit is special if O=special_closure(O)}
set is_special(SpringerTable st,ComplexNilpotent O)=bool:
if is_even(O) then true else {st.special_closure(O)=O this is slow}
st.dual_map_i(st.dual_map(O)).diagram_normalized=O.diagram_normalized
fi

set is_special(SpringerTable st)=(ComplexNilpotent->bool): (ComplexNilpotent O):
is_special(st,O)

{all special orbits, including numbering from list of all orbits}
set special_orbits_indexed(SpringerTable st)=([int],[ComplexNilpotent]):
let indices=[int]:[] then
orbits=##for O@i in st.ct.root_datum.orbits do if st.is_special(O) then indices#:=i;[O] else [] fi od
in (indices,orbits)
set special_orbits(SpringerTable st)=[ComplexNilpotent]:let (,orbits)=special_orbits_indexed(st) in orbits

{often we want special orbits for G, in which the coordinates might be
different than those in G.springer_table}
set special_orbits_indexed(RootDatum G,SpringerTable st)=([int],[ComplexNilpotent]):
let (indices,orbits)=st.special_orbits_indexed in
(indices, for orbit in orbits do orbit_by_diagram(G,orbit.diagram_normalized) od)
set special_orbits(RootDatum G,SpringerTable st)=[ComplexNilpotent]:let (,orbits)=special_orbits_indexed(G,st) in orbits

set special_representations_indexed(SpringerTable st)=([int],[[int]]):
let (indices,orbits)=st.special_orbits_indexed in
(indices, for orbit in orbits do st.ct.characters[st.springer(orbit)] od)

set special_representations(SpringerTable st)=[[int]]:
let (,chars)=special_representations_indexed(st) in chars

{st is the Springer table for RootDatum rd
 O is an orbit for rd
 special_piece(st,O)=list of orbits for rd:
 all orbits satisfying d(orbit)=d(O)}

set special_piece(SpringerTable st, ComplexNilpotent O)=[ComplexNilpotent]:
{first make sure O has the right root datum}
let O=orbit_by_diagram(st,O.diagram_normalized) then
O_check=st.dual_map(O) then
O_special=orbit_by_diagram(st,st.dual_map_i(O_check).diagram_normalized) in  {put special orbit first}
O_special#
##for i:#st.orbits do
  let orbit=st.orbits[#st.orbits-i-1] in {reverse order}
   if not orbit = O_special and st.dual_map(orbit)=O_check
    then [orbit]
    else []
   fi
  od

{all orbits satisfying d_inverse(orbit^v)=d_inverse(O^v)}
set dual_special_piece(SpringerTable st, ComplexNilpotent O_check)=[ComplexNilpotent]:
{make sure O_check has the correct root datum}
let O_check=dual_orbit_by_diagram(st,O_check.diagram_normalized) then
O_special=st.dual_map_i(O_check) then
O_check_special=st.dual_map(O_special) then
dual_orbits=st.root_datum.dual_orbits in
O_check_special#
##for i:#st.root_datum.dual_orbits do
  let orbit_check=dual_orbits[#dual_orbits-i-1] in {reverse order}
   if not orbit_check = O_check_special and st.dual_map_i(orbit_check)=O_special 
    then [orbit_check]
    else []
   fi
  od

{complex nilpotent of product group}
set tensor(ComplexNilpotent O1,ComplexNilpotent O2)=ComplexNilpotent:
let (rd1,(),H1)=O1,(rd2,(),H2)=O2 in (rd1*rd2,(),H1##H2)

set factor(ComplexNilpotent O,RootDatum rd1,RootDatum rd2)=(ComplexNilpotent,ComplexNilpotent):
let H1=O.H[:rd1.rank] then
H2=O.H[rd2.rank~:] then
O1=(rd1,(),H1), O2=(rd2,(),H2) in
(O1,O2)

{
set factor_new(ComplexNilpotent O,RootDatum rd1,RootDatum rd2)=(
let diag_1=O.H*rd1.simple_roots then
diag_2=O.H*rd2.simple_roots in (diag_1,diag_2)
}

{write rd.derived as rd_1 x rd_2 where
rd_1 is semisimple, rd_2 is simple
also return [indices_1,indices_2]
where indices_i is the list of simple roots of rd in rd_i
}
set split_last_factor(RootDatum rd)=(RootDatum,RootDatum,[[int]]):
let factors=simple_factors(rd) then
rv=factors[0].derived then
()= for i:#factors-2 from 1 do rv*:=factors[i].derived od in
(rv,factors~[0].derived, [##for i:#factors-1 do simple_factor_indices(rd,i) od, simple_factor_indices(rd,#factors-1)])

{tensor product of springer tables
st1.root_datum can be anything semisimple,
st2.root_datum must be simple
}
set tensor(SpringerTable st1,SpringerTable st2)=SpringerTable:
let ct=tensor(st1.ct,st2.ct) then
rd1=st1.root_datum, rd2=st2.root_datum then
rd=rd1*rd2 then
orbits=
 ##for O1 in st1.orbits do
  for O2 in st2.orbits do
   tensor(O1,O2)
  od
 od
then factor_orbit(ComplexNilpotent O_0)=
 {O may be an orbit for G, not st.root_datum,
  need to identify O with an orbit for st.root_datum
  using diagram_normalized
  example:
  set G=([0,1,2,3,4,6],trivial(E7_s).x).Levi
  then G.root_datum and springer_table(G).root_datum are not the same
  set O=G.orbits[3]
  in orbit_by_diagram calls below, pass orbits (precomputed)
  rather than rd
 }
 let O=orbit_by_diagram(orbits,O_0.diagram_normalized) then
 (O1_0,O2_0)=factor(O,rd1,rd2) in
{ let ()=prints("O1_0:", O1_0, " ", O1_0.diagram_normalized) then
 ()=prints("O2_0:", O2_0, " ", O2_0.diagram_normalized) in}
 (orbit_by_diagram(st1,O1_0.diagram_normalized),orbit_by_diagram(st2,O2_0.diagram_normalized))
then dual_map(ComplexNilpotent O_0)=
 let O=orbit_by_diagram(orbits,O_0.diagram_normalized) then
 (O1,O2)=factor_orbit(O) in
 tensor(st1.dual_map(O1),st2.dual_map(O2))
then springer(ComplexNilpotent O_0)=int:
 let O=orbit_by_diagram(orbits,O_0.diagram_normalized) then
 (O1,O2)=factor_orbit(O) then
 i=springer(st1)(O1),j=springer(st2)(O2)
 in i*(st2.ct.n_classes)+j
then dual_map_i(ComplexNilpotent O_check)=
{O_check is for st.root_datum.dual,
not the same as rd.dual}
{st1: all but last factor of rd (n-1 factors)
 st2: last factor
 diagram: O_check.diagram_normalized, has n factors
 diagram_1: first n-1 factors of diagram
 diagram_2: last factor of diagram
 then st1.dual_map_i(O_check_1)
 st2.dual_map_i(O_check_2)
 tensor these two to get dual_map_i(O_check)
}
let diagram=O_check.diagram_normalized then
{()=prints("diagram: ", diagram) then}
diagram_1=[vec]:for i:#diagram-1 do diagram[i] od then
diagram_2=[vec]:[diagram~[0]] then
{()=prints("diagram_1: ", diagram_1) then
()=prints("diagram_2: ", diagram_2) then}
O1_check=dual_orbit_by_diagram(st1,diagram_1) then
O2_check=dual_orbit_by_diagram(st2,diagram_2) then 
{()=prints("O1_check: ", O1_check) then
()=prints("O2_check: ", O2_check) then}
 O1=st1.dual_map_i(O1_check), O2=st2.dual_map_i(O2_check) in
 tensor(O1,O2)
in (ct,orbits,dual_map,dual_map_i,springer)

set springer_character(SpringerTable st)=(ComplexNilpotent->[int]):(ComplexNilpotent orbit):
st.ct.characters[st.springer(orbit)]

{inverse Springer map: try to find an orbit (not necessarily special) such
 that springer(orbit)=given character
if the character is special this succeeds and gives a special orbit
otherwise it might fail, in which case it returns (false,0-orbit)
}
set springer_inverse(SpringerTable st,int special_character_number)=(bool,ComplexNilpotent):
let index=first(for i:#st.orbits do st.springer(st.orbits[i])=special_character_number od)
 in if index=-1 then (false,st.orbits[0]) else (true,st.orbits[index]) fi
set springer_inverse(SpringerTable st)=(int->(bool,ComplexNilpotent)):(int j):springer_inverse(st,j)

{case of special orbit don't need the boolean}
set springer_inverse_special(SpringerTable st,int special_character_number)=ComplexNilpotent:
let (,orbit)=springer_inverse(st,special_character_number) in orbit
set springer_inverse_special(SpringerTable st)=(int->ComplexNilpotent):(int j):springer_inverse_special(st,j)

set special_star(SpringerTable st,ComplexNilpotent O)=string:
if is_special(st,O) then "*" else "" fi

set special_star(SpringerTable st)=(ComplexNilpotent ->string):
(ComplexNilpotent O):special_star(st,O)


{all special representations}
set special_representations(SpringerTable st)=[int]:
sort(for orbit in st.special_orbits do st.springer(orbit) od)
set is_special_representation(SpringerTable st,int i)=in_list(st.special_representations,i)
set is_special_representation(SpringerTable st)=(int->bool):(int i):is_special_representation(st,i)
set special_representation_star(SpringerTable st)=(int->string):(int i):
if is_special_representation(st,i) then "*" else "" fi


{ this version of integral_descent is used in weak_packets.at
  this uses a permutation, which we return since it is needed later
}
set integral_descent (SpringerTable st_int,ComplexNilpotent O_check) =
      (ComplexNilpotent,mat):
   let rd = {the original root datum on the group side} O_check.root_datum.dual
   , O_check_rd_int = {orbit for rd_int_dual} O_check.integral_descent
   then rd_int = {integrality datum on group side}
                 integrality_datum(rd,O_check.H/2)
   then {P is the permutation relating rd_int.derived and st_int.root_datum}
        (,P)=nice_order(rd_int.derived)
   then permutation=P.permutation_matrix
in {by definition permutation should relate the Cartan matrices}
   assert(permutation*st_int.root_datum.Cartan_matrix =
          rd_int.Cartan_matrix*permutation
         ,"permutation does not relate the Cartan matrices");
{ Note: st_int.root_datum.dual is *adjoint*,
  so O_check_rd_int.diagram = O_check_rd_int.H }
  ((st_int.root_datum.dual,(),O_check_rd_int.diagram*permutation) , permutation)


set show(SpringerTable st)=void:
tabulate(
["diagram","dim","rep#","dim","deg", "fdeg","char"]#
for orbit in st.orbits do
let j=st.springer(orbit) in
[orbit.diagram.to_string+st.special_star(orbit),
orbit.dim_nilpotent.to_string,
j.to_string,
st.ct.dimension(j).to_string,
st.ct.degree(j).to_string,
if #st.fake_degrees>0 then st.fake_degrees[j].to_string else "" fi,
 st.ct.characters[j].to_string] od)

set show_long(SpringerTable st)=void:
tabulate(
["#orbit","diagram","dim","dual","dual-dim","rep#","dim","deg", "fdeg","char"]#
for orbit@i in st.orbits do
let  dual_orbit=st.dual_map(orbit) then
j=st.springer(orbit) in
[i.to_string,
orbit.diagram.to_string+st.special_star(orbit),
orbit.dim_nilpotent.to_string,
dual_orbit.diagram.to_string,
dual_orbit.dim_nilpotent.to_string,
j.to_string,
st.ct.dimension(j).to_string,
st.ct.degree(j).to_string,
if #st.fake_degrees>0 then st.fake_degrees[j].to_string else "" fi,
 st.ct.characters[j].to_string] od)

set show_reps(SpringerTable st)=void:
let springer_reps=for orbit@i in st.orbits do st.springer(orbit) od  in 
tabulate(
["rep#","orbit","dim","deg", "fdeg","char"]#
for j:st.ct.n_classes do 
[j.to_string,
 let orbit_index=find(springer_reps,j) in
  if orbit_index>=0 then
   let orbit=st.orbits[orbit_index] in orbit.diagram.to_string + st.special_star(orbit)
  else ""
  fi,
st.ct.dimension(j).to_string,
st.ct.degree(j).to_string,
if #st.fake_degrees>0 then
  if st.fake_degrees[j]>=0 then st.fake_degrees[j].to_string else "" fi
  else "" fi,
 st.ct.characters[j].to_string] od)