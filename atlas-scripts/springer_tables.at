<basic.at
<nilpotent_orbits.at { type |ComplexNilpotent|, |diagram_normalized|, |orbits| }
<character_tables.at
<character_table_tensor.at

{tables encoding the Springer correspondence}

set_type [SpringerTable=
  (CharacterTable ct,
  [ComplexNilpotent] orbits,
  (ComplexNilpotent->ComplexNilpotent) dual_map,
  (ComplexNilpotent->ComplexNilpotent) dual_map_i,
  (ComplexNilpotent->int) springer
  )]

set character_table = ct@SpringerTable { longer name for the projector }
set root_datum (SpringerTable st) = RootDatum: st.ct.root_datum
set characters (SpringerTable st) = [[int]]: st.ct.characters
set orbit (SpringerTable st) = (int i) ComplexNilpotent: st.orbits[i]
set generic_degree (SpringerTable st) = (int->int): st.ct.generic_degree

set n_orbits (SpringerTable st) = int: #st.orbits

{equality of normalized diagrams}
set equal([[int]] a,[[int]] b)=bool: #a = #b and all(#a,(int i)bool: a[i]=b[i])

set orbit_index(SpringerTable st,ComplexNilpotent orbit) = int:
  let diagram = [[int]]: orbit.diagram_normalized
  in first(st.n_orbits,(int i): equal(st.orbits[i].diagram_normalized,diagram))
  { equivalently: first(st.n_orbits,(int i): orbit = st.orbits[i]) }

{ select ComplexNilpotent matching given |diagram| }
set orbit_by_diagram([ComplexNilpotent] orbits,[vec] diagram) = ComplexNilpotent:
  let index=first(#orbits,(int i):equal(orbits[i].diagram_normalized,diagram))
  in orbits[index]

set orbit_by_diagram(SpringerTable st,[vec] diagram) = ComplexNilpotent:
  orbit_by_diagram(st.orbits,diagram)

{ given just a root datum, we can generate its orbits on the fly; expensive! }
set orbit_by_diagram(RootDatum rd,[vec] diagram) = ComplexNilpotent:
  let orbits = orbits(rd) { generate }
  then index=first(#orbits,(int i): equal(orbits[i].diagram_normalized,diagram))
  in orbits[index]

set dual_orbit_by_diagram(SpringerTable st,[vec] diagram) = ComplexNilpotent:
  let orbits = orbits(dual(st.root_datum)) in orbit_by_diagram(orbits,diagram)

{dual_map_i(dual_map(O))}
set special_closure(SpringerTable st,ComplexNilpotent O) = ComplexNilpotent:
{O.root_datum here: need this to be an orbit O.root_datum}
  orbit_by_diagram(O.root_datum
		  ,diagram_normalized(st.dual_map_i(st.dual_map(O)))
		  )

set special_closure (SpringerTable st) = (ComplexNilpotent->ComplexNilpotent):
  (ComplexNilpotent O) ComplexNilpotent: special_closure(st,O)

{orbit is special if O=special_closure(O)}
set is_special (SpringerTable st,ComplexNilpotent O) = bool:
  is_even(O) or {st.special_closure(O)=O, but this is slow}
  st.dual_map_i(st.dual_map(O)).diagram=O.diagram


set is_special(SpringerTable st)=(ComplexNilpotent->bool): (ComplexNilpotent O):
is_special(st,O)

{all special orbits, including numbering from list of all orbits}
set special_orbits_indexed(SpringerTable st)=([int],[ComplexNilpotent]):
let indices=[int]:[] then
orbits=##for O@i in st.ct.root_datum.orbits do if st.is_special(O) then indices#:=i;[O] else [] fi od
in (indices,orbits)
set special_orbits(SpringerTable st)=[ComplexNilpotent]:let (,orbits)=special_orbits_indexed(st) in orbits

{often we want special orbits for G, in which the coordinates might be
different than those in G.springer_table}
set special_orbits_indexed(RootDatum G,SpringerTable st)=([int],[ComplexNilpotent]):
let (indices,orbits)=st.special_orbits_indexed in
(indices, for orbit in orbits do orbit_by_diagram(G,orbit.diagram_normalized) od)
set special_orbits(RootDatum G,SpringerTable st)=[ComplexNilpotent]:let (,orbits)=special_orbits_indexed(G,st) in orbits

set special_representations_indexed(SpringerTable st)=([int],[[int]]):
let (indices,orbits)=st.special_orbits_indexed in
(indices, for orbit in orbits do st.ct.characters[st.springer(orbit)] od)

set special_representations(SpringerTable st)=[[int]]:
let (,chars)=special_representations_indexed(st) in chars

{st is the Springer table for RootDatum rd
 O is an orbit for rd
 special_piece(st,O)=list of orbits for rd:
 all orbits satisfying d(orbit)=d(O)}

set special_piece(SpringerTable st, ComplexNilpotent O)=[ComplexNilpotent]:
{first make sure O has the right root datum}
let O=orbit_by_diagram(st,O.diagram_normalized) then
O_check=st.dual_map(O) then
O_special=orbit_by_diagram(st,st.dual_map_i(O_check).diagram_normalized) in  {put special orbit first}
O_special#
##for i:#st.orbits do
  let orbit=st.orbits[#st.orbits-i-1] in {reverse order}
   if not orbit = O_special and st.dual_map(orbit)=O_check
    then [orbit]
    else []
   fi
  od

{all orbits satisfying d_inverse(orbit^v)=d_inverse(O^v)}
set dual_special_piece(SpringerTable st, ComplexNilpotent O_check)=[ComplexNilpotent]:
{make sure O_check has the correct root datum}
let O_check=dual_orbit_by_diagram(st,O_check.diagram_normalized) then
O_special=st.dual_map_i(O_check) then
O_check_special=st.dual_map(O_special) then
dual_orbits=st.root_datum.dual_orbits in
O_check_special#
##for i:#st.root_datum.dual_orbits do
  let orbit_check=dual_orbits[#dual_orbits-i-1] in {reverse order}
   if not orbit_check = O_check_special and st.dual_map_i(orbit_check)=O_special
    then [orbit_check]
    else []
   fi
  od

{complex nilpotent of product group}
set tensor(ComplexNilpotent O1,ComplexNilpotent O2)=ComplexNilpotent:
let (rd1,(),H1)=O1,(rd2,(),H2)=O2 in (rd1*rd2,(),H1##H2)

set factor(ComplexNilpotent O,RootDatum rd1,RootDatum rd2)=(ComplexNilpotent,ComplexNilpotent):
let H1=O.H[:rd1.rank] then
H2=O.H[rd2.rank~:] then
O1=(rd1,(),H1), O2=(rd2,(),H2) in
(O1,O2)

{
set factor_new(ComplexNilpotent O,RootDatum rd1,RootDatum rd2)=(
let diag_1=O.H*rd1.simple_roots then
diag_2=O.H*rd2.simple_roots in (diag_1,diag_2)
}

{write rd.derived as rd_1 x rd_2 where
rd_1 is semisimple, rd_2 is simple
also return [indices_1,indices_2]
where indices_i is the list of simple roots of rd in rd_i
}
set split_last_factor(RootDatum rd)=(RootDatum,RootDatum,[[int]]):
let factors=simple_factors(rd) then
rv=factors[0].derived then
()= for i:#factors-2 from 1 do rv*:=factors[i].derived od in
(rv,factors~[0].derived, [##for i:#factors-1 do diagram_component(rd,i) od, diagram_component(rd,#factors-1)])

{tensor product of springer tables
st1.root_datum can be anything semisimple,
st2.root_datum must be simple
}
set tensor (SpringerTable st1,SpringerTable st2) = SpringerTable:
let ct=tensor(st1.ct,st2.ct), rd1=st1.root_datum, rd2=st2.root_datum
, orbits =
  for O1 in st1.orbits do for O2 in st2.orbits do tensor(O1,O2) od od.##
{ then rd=rd1*rd2 }
then factor_orbit(ComplexNilpotent O_0) = (ComplexNilpotent,ComplexNilpotent):
 {used for |dual_map| and for the |springer| map
  O may be an orbit for G, not st.root_datum,
  need to identify O with an orbit for |rd|
  using diagram_normalized
  example:
  set G=([0,1,2,3,4,6],trivial(E7_s).x).Levi
  then G.root_datum and springer_table(G).root_datum are not the same
  set O=G.orbits[3]
  in orbit_by_diagram calls below, pass orbits (precomputed)
  rather than rd
 }
  let O=orbit_by_diagram(orbits,O_0.diagram_normalized)
  then (O1_0,O2_0)=factor(O,rd1,rd2)
   { ()=prints("O1_0:", O1_0, " ", O1_0.diagram_normalized) then
     ()=prints("O2_0:", O2_0, " ", O2_0.diagram_normalized) }
  in { factor_orbit = }
  ( orbit_by_diagram(st1,O1_0.diagram_normalized)
  , orbit_by_diagram(st2,O2_0.diagram_normalized))
then dual_map(ComplexNilpotent O_0) =
  let O=orbit_by_diagram(orbits,O_0.diagram_normalized)
  then (O1,O2)=factor_orbit(O)
  in tensor(st1.dual_map(O1),st2.dual_map(O2))
then springer(ComplexNilpotent O_0) = int:
  let O=orbit_by_diagram(orbits,O_0.diagram_normalized)
  then (O1,O2)=factor_orbit(O)
  then  i=springer(st1)(O1),j=springer(st2)(O2)
  in i*(st2.ct.n_irreps)+j
then dual_map_i(ComplexNilpotent O_check) =
  {O_check is for st.root_datum.dual,
  not the same as rd.dual}
  {st1: all but last factor of rd (n-1 factors)
   st2: last factor
   diagram: O_check.diagram_normalized, has n factors
   diagram_1: first n-1 factors of diagram
   diagram_2: last factor of diagram
   then st1.dual_map_i(O_check_1)
   st2.dual_map_i(O_check_2)
   tensor these two to get dual_map_i(O_check)
  }
  let diagram=O_check.diagram_normalized
  then {()=prints("diagram: ", diagram) then}
    diagram_1 = [vec]: diagram[:1~], diagram_2 = [vec]: [diagram~[0]]
  then
  {()=prints("diagram_1: ", diagram_1);prints("diagram_2: ", diagram_2) then}
    O1_check=dual_orbit_by_diagram(st1,diagram_1)
  , O2_check=dual_orbit_by_diagram(st2,diagram_2)
  then {()=prints("O1_check: ", O1_check); prints("O2_check: ", O2_check) then}
    O1=st1.dual_map_i(O1_check), O2=st2.dual_map_i(O2_check)
  in tensor(O1,O2)
in (ct,orbits,dual_map,dual_map_i,springer)

set springer_character(SpringerTable st)=(ComplexNilpotent->[int]):(ComplexNilpotent orbit):
st.ct.characters[st.springer(orbit)]

{inverse Springer map: try to find an orbit (not necessarily special) such
 that springer(orbit)=given character
if the character is special this succeeds and gives a special orbit
otherwise it might fail, in which case it returns (false,0-orbit)
}
set springer_inverse(SpringerTable st,int special_character_number)=(bool,ComplexNilpotent):
let index=first(for i:#st.orbits do st.springer(st.orbits[i])=special_character_number od)
 in if index=-1 then (false,st.orbits[0]) else (true,st.orbits[index]) fi
set springer_inverse(SpringerTable st)=(int->(bool,ComplexNilpotent)):(int j):springer_inverse(st,j)

{case of special orbit don't need the boolean}
set springer_inverse_special(SpringerTable st,int special_character_number)=ComplexNilpotent:
let (,orbit)=springer_inverse(st,special_character_number) in orbit
set springer_inverse_special(SpringerTable st)=(int->ComplexNilpotent):(int j):springer_inverse_special(st,j)

set special_star(SpringerTable st,ComplexNilpotent O)=string:
if is_special(st,O) then "*" else "" fi

set special_star(SpringerTable st)=(ComplexNilpotent ->string):
(ComplexNilpotent O):special_star(st,O)


{all special representations}
set special_representations(SpringerTable st)=[int]:
sort(for orbit in st.special_orbits do st.springer(orbit) od)
set is_special_representation(SpringerTable st,int i)=in_list(st.special_representations,i)
set is_special_representation(SpringerTable st)=(int->bool):(int i):is_special_representation(st,i)
set special_representation_star(SpringerTable st)=(int->string):(int i):
if is_special_representation(st,i) then "*" else "" fi


{ this version of integral_descent is used in weak_packets.at
  this uses a permutation, which we return since it is needed later
}
set integral_descent (SpringerTable st_int,ComplexNilpotent O_check) =
      (ComplexNilpotent,mat):
   let rd = {the original root datum on the group side} O_check.root_datum.dual
   , O_check_rd_int = {orbit for rd_int_dual} O_check.integral_descent
   then rd_int = {integrality datum on group side}
                 integrality_datum(rd,O_check.H/2)
   then {P is the permutation relating rd_int.derived and st_int.root_datum}
        (,P)=Cartan_matrix_type(Cartan_matrix(rd_int))
   then permutation=P.permutation_matrix
in {by definition permutation should relate the Cartan matrices}
   assert(permutation*st_int.root_datum.Cartan_matrix =
          rd_int.Cartan_matrix*permutation
         ,"permutation does not relate the Cartan matrices");
{ Note: st_int.root_datum.dual is *adjoint*,
  so O_check_rd_int.diagram = O_check_rd_int.H }
  ((st_int.root_datum.dual,(),O_check_rd_int.diagram*permutation) , permutation)


set show (SpringerTable st) = void:
   let npr = st.root_datum.nr_of_posroots in
tabulate (
   [ "diagram"
   , "dim(O)"
   , "rep#"
   , "dim(rep)"
   , "deg"
   , "gdeg"
   , "char"
   ]
#  for orbit in st.orbits
   do let j=st.springer(orbit), dim=orbit.dim_nilpotent
      then deg=st.ct.degree(j)
   in if dim\2 + deg != npr then prints("Problem at ",orbit,": ",dim\2+deg) fi
   ;  [ orbit.diagram.to_string+st.special_star(orbit)
      , dim.to_string
      , j.to_string
      , dimension(st.ct,j).to_string
      , deg.to_string
      , st.ct.generic_degree_string(j)
      , st.ct.characters[j].to_string
      ]
   od
)

set show_long(SpringerTable st)=void:
   let npr = st.root_datum.nr_of_posroots in
tabulate (
   [ "#orbit"
   , "diagram"
   , "dim(O)"
   , "dual(O)"
   , "dim(dual(O))"
   , "rep#"
   , "dim(rep)"
   , "deg"
   , "gdeg"
   , "char"
   ]
#  for orbit@i in st.orbits
   do let j=st.springer(orbit), dim=orbit.dim_nilpotent
      , dual_orbit = st.dual_map(orbit)
      then deg=st.ct.degree(j)
   in if dim\2 + deg != npr then prints("Problem at ",j,": ",dim\2+deg) fi
   ;  [ i.to_string
      , orbit.diagram.to_string+st.special_star(orbit)
      , orbit.dim_nilpotent.to_string
      , dual_orbit.diagram.to_string
      , dual_orbit.dim_nilpotent.to_string
      , j.to_string
      , dimension(st.ct,j).to_string
      , st.ct.degree(j).to_string
      , st.ct.generic_degree_string(j)
      , st.ct.characters[j].to_string
      ]
   od
)

set show_reps(SpringerTable st)=void:
let springer_reps=for orbit@i in st.orbits do st.springer(orbit) od  in
tabulate(
["rep#","orbit","dim","deg", "fdeg","char"]#
for j:st.ct.n_irreps do
[j.to_string,
 let orbit_index=find(springer_reps,j) in
  if orbit_index>=0 then
   let orbit=st.orbits[orbit_index] in orbit.diagram.to_string + st.special_star(orbit)
  else ""
  fi,
dimension(st.ct,j).to_string,
st.ct.degree(j).to_string,
st.ct.generic_degree_string(j),
st.ct.characters[j].to_string] od)
