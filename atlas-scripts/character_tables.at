<basic.at
<combinatorics.at

{ Character table structure for Weyl groups (integer valued characters) }

{ The structure below was inspired by the way GAP represents character tables }

set_type
[ character_table =
  ( int order { of the finite group }
  , (int->string) class_label
  , (int->int) class_element_order
  , (int,int->int) class_power
  , [int] centralizer_orders
  , [int] class_sizes
  , (int->string) irreducible_label
  , mat table { by row=character }
  )
]

set n_classes (character_table t) = int: #t.class_sizes
set irrep_dimension (character_table t) = (int i) int: t.table[i,0]

set scalar_product (character_table t) = (int i0, int i1) rat:
   let tab=t.table in
   for j: t.n_classes do tab[i0,j]*tab[i1,j]*t.class_sizes[j] od.sum/t.order

set check_orthogonality (character_table t) = bool:
   let n=t.n_classes, dot=t.scalar_product in
   for i:n do for j:n do dot(i,j) = #(i=j) od.all od.all

set parts_string (Partition lambda) = string: lambda.to_string[1:1~]
set cycles_string ([int] cycles) = string:
   (  "[", cycles.parts_string ,  "]" ).to_string
set irred_string ([int] cycles) = string:
   (  "{", cycles.parts_string ,  "}" ).to_string


set character_table_S(int n) = character_table:
  let order=n.fac, partitions_n = partitions(n)
  then index = index_partition(partitions_n)
  , c_orders=for lambda in partitions_n do cycle_centralizer_order(lambda) od
in
  ( order
  , (int j) string: partitions_n[j].cycles_string
  , (int j) int: partitions_n[j].cycle_type_order
  , (int j, int p) int: cycle_power(partitions_n[j],p).index
  , c_orders
  , for co in c_orders do order\co od
  , (int j) string: partitions_n~[j].irred_string
  , #partitions_n ^ { gather rows of this size: }
    for lambda in partitions_n
   ~do for cycles in partitions_n do Murnaghan_Nakayama(lambda,cycles) od
    od
  )

set sign_string (bool s) = string: if s then "-" else "+" fi
set cycles_string ([int,bool] cycles) = string:
(  "["
## for (l,s)@pos in cycles
   do if =pos then l.to_string##s.sign_string
      else "," ##  l.to_string##s.sign_string
      fi
   od.##
## "]"
)
set irred_string(BiPartition(mu,lambda)) = string:
   ("{", mu.parts_string,"-|+",lambda.parts_string, "}").to_string

set character_table_H(int n) = character_table:
  let order=n.fac*2^n, pairs = partition_pairs(n)
  then class = for pair in pairs do pair.to_cycles od
  , irred = pairs_of_total_sum(n,(int k):partitions(k)~[:]) { [k],..,ones(k) }
  , lookup = index_bipartition(pairs)
  then index(Signed_cycles cyc) = int: cyc.to_partition_pair.lookup
  , c_orders = for type in class do type.cycle_centralizer_order od
  , sign(bool s) = string: if s then "-" else "+" fi
  in
  ( order
  , (int j) string: { class_label } class[j].cycles_string
  , (int j) int: class[j].cycle_type_order
  , (int j, int p) int: cycle_power(class[j],p).index
  , c_orders
  , for co in c_orders do order\co od
  , (int i) string: { irreducible representation label } irred[i].irred_string
  , #class ^ { gather rows of this size: }
    for pair in irred
    do for cycle_type in class do hyperoctahedral_character(pair,cycle_type) od
    od
  )


set cycles_string (Dn_class c) = string:
    case c
    | cycles.unsplit_class: cycles.cycles_string
    | (alpha,s).split_class: (alpha,sign(s)).to_string
    esac
set irred_string(Dn_irrep chi) = string:
  case chi
  | (mu,lambda).unsplit_irr: { here we keep the stored order of partitions }
    ("{",mu.parts_string,"|",lambda.parts_string,"}").to_string
  | (mu,s).split_irr:
    ("{",mu.parts_string,"|",mu.parts_string,"}",s.sign_string).to_string
  esac

set character_table_D(int n) = character_table:
( let order=n.fac*2^(n-1)
  , irred = Dn_irreducibles(n)
  , class = Dn_classes(n)
  then unsplits = [Signed_cycles]:
    for c in class do case c | cyc.unsplit_class:[cyc] | else [] esac od.##
  , unsplit_indices = [int]:
    for c@i in class do case c | cycles.unsplit_class:[i] | else [] esac od.##
  , splits =
    for c in class do case c | (mu,).split_class:[mu] | else [] esac od.##
  , split_indices =
    for c@i in class do case c | (,).split_class:[i] | else [] esac od.##
  then index_unsplit(Signed_cycles cyc) = int:
     for c@i in unsplits do if c=cyc then unsplit_indices[i] fi od; minus_1
  , index_split = index_partition(splits) { |splits| is born in sorted order }
  then index(Dn_class C) = int:
     case C
     | cycles.unsplit_class: cycles.index_unsplit
     | (alpha,neg).split_class: split_indices[alpha.index_split]+#neg
     esac
  , c_orders = for C in class do C.centralizer_order od
  , sign(bool s) = string: if s then "-" else "+" fi
in
  ( order
  , (int j) string: { class_label } class[j].cycles_string
  , (int j) int: class[j].cycle_type_order
  , (int j, int p) int: cycle_power(class[j],p).index
  , c_orders
  , for co in c_orders do order\co od
  , (int i) string: { irreducible representation label } irred[i].irred_string
  , #class ^ { gather rows of this size: }
    for chi in irred do for C in class do character(chi,C) od od
  )
)
