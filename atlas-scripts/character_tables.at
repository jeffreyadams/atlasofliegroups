<basic.at
<class_tables.at
<classical_W_classes_and_reps.at { for |classical_class|, |classical_irrep| }
<nilpotent_orbits.at
<isomorphism.at

set ct_verbose=false

{define sum and product of [int] corresponding to direct
sum and tensor product of characters}
set sum([int] v,[int] w)=
assert(#v=#w,"not same size");for i:#v do v[i]+w[i] od

set product([int] v,[int] w)=
assert(#v=#w,"not same size");for i:#v do v[i]*w[i] od
set tensor=product@([int],[int])

set tensor_power([int] v,int power)=[int]: for x in v do x^power od

set Cartesian_power([int] x,int n)=[int]:  for v in x do n*v od

{ Character table structure for Weyl groups (integer valued characters) }

{ The structure below was inspired by the way GAP represents character tables }

set_type
[ CharacterTable =
  ( WeylClassTable class_table
  {conjugacy classes}
  , [WeylElt] class_reps  { should be made function } {list of class reps }
  , (int->string) class_label {derived from partitions in classical case}
  , (int ->classical_class) classes
  {irreducible characters}
  , (int->classical_irrep) classical_reps
  , (int->string) irreducible_label
  , [int] degrees { should be made function }
  , (int->int) generic_degree
  , (int,(->int),bool->int) set_generic_degree
  , (int->bool) has_generic_degree
  , mat table { should be made function } { by row=character }
  )
]

set character_table ( WeylClassTable Wct
    		    , [WeylElt,classical_class,string] class_reps
		    , [classical_irrep,string,[int]] chars
		    ) =  CharacterTable:
(  let rd  = Wct.root_datum, n = Wct.n_classes
   , reps = for (w,,) in class_reps do w od
in Wct:=reorder(Wct,reps) { henceforth |Wct| has class order we imposed }
;  let irreps = [classical_irrep]: for (ci,,) in chars do ci od
,  labels = [string]: for (,s,) in chars do s od
,  character_table = mat: n^for (,,char) in chars do char od { |char| is a row }
,  sizes = Wct.class_sizes
,  degrees = [int]:
   for i:n
   do
     let (,,char)=chars[i] in
     first(rd.nr_of_posroots+1
          ,(int k) bool: !=Wct.inner(char,Wct.sym_power_refl(k)))
   od
   , generic_degrees = vec: -ones(n)
then get_generic_degree(int i) = int:
   if generic_degrees[i].<
   then error("Generic degree of irrep "+i+" was not set")
   else generic_degrees[i]
   fi
,  set_generic_degree(int i,(->int) d, bool check) = int:
   if generic_degrees[i].<
   then generic_degrees[i]:=d()
   else
     if check then assert(generic_degrees[i]=d(),"Generic degree change") fi
   ; generic_degrees[i]
   fi
in
   ( { class_table } WeylClassTable: Wct
     {conjugacy classes}
   , { class_reps } reps
   , { class_label } (int i)string: let (,,cl)=class_reps[i] in cl
   , { classes } (int i)classical_class: let (,cc,)=class_reps[i] in cc
     {irreducible characters}
   , { classical_reps } (int i)classical_irrep: irreps[i]
   , { irreducible_label } (int i)string: labels[i]
   , { degrees } [int]: degrees
   , { generic_degree } (int->int): get_generic_degree
   , { set_generic_degree } (int,(->int),bool->int): set_generic_degree
   , { has_generic_degree } (int i) bool: generic_degrees[i].>=
   , { table } mat: character_table
   )
)

set character_table ( RootDatum rd
		    , [WeylElt,classical_class,string] class_reps
		    , [classical_irrep,string,[int]] chars
		    ) =  CharacterTable:
    character_table ( class_table(rd), class_reps, chars )

{ A valid character table that can be used to initialise local variables }
set !trivial_character_table = CharacterTable:
   let Wct = trivial_class_table, id(int i)=int: i
   then e=id_W(Wct.root_datum)
in (Wct,[e],(int i):"e",(int i)classical_class: null_class()
   ,(int i)classical_irrep: null_irrep(),(int i):"triv",[0]
   ,(int i)int: 0, ((int,(->int),bool).)int:0, (int i)bool:true, [[1]]
   )

{ attributes inhereited from the |class_table| component }
set root_datum (CharacterTable ct) = RootDatum: ct.class_table.root_datum
set rank (CharacterTable ct) = ct.root_datum.rank
set order_W (CharacterTable ct) = ct.root_datum.order_W
set n_classes (CharacterTable ct) = ct.class_table.n_classes
set n_irreps = n_classes@CharacterTable { alias, for readability }

set class_representatives = class_reps@CharacterTable {synonym}
set class_rep(CharacterTable ct,int i) = WeylElt: ct.class_reps[i]
set class_rep(CharacterTable ct) = (int->WeylElt): (int i):ct.class_reps[i]
set class_of(CharacterTable ct) = ct.class_table.class_of

set class_order(CharacterTable ct) = (int i) int:
  order(class_rep(ct,i)) {element order}
set class_sizes(CharacterTable ct) = ct.class_table.class_sizes
set class_size(CharacterTable ct) = (int i) int: ct.class_sizes[i]
set centralizer_order(CharacterTable ct) = (int i) int:
  ct.order_W\ct.class_sizes[i]
set class_power(CharacterTable ct) = (int,int->int): ct.class_table.class_power

set character_value(CharacterTable ct, int class) = (int i) int:
  ct.table[i,class]

set id_class(CharacterTable ct) = ct.class_of(ct.root_datum.id_W)
set dimension (CharacterTable ct) = ([int] chi) int: chi[ct.id_class]
set dimension (CharacterTable ct,int i) = int: ct.table[i,ct.id_class]

set character(CharacterTable t) = (int i) [int]: row(t.table,i)
set characters(CharacterTable ct)=[[int]]: rows(ct.table)

set character_index(CharacterTable ct) = ([int] char) int:
  first(ct.n_irreps,(int i): ct.characters[i]=char)
set index(CharacterTable ct,vec char) = int: ct.character_index(char)

set inner(CharacterTable ct) = ([int],[int]->int): ct.class_table.inner
set norm2(CharacterTable ct)= ([int] x)int: ct.class_table.inner(x,x)

set degree(CharacterTable ct) = (int i)int: ct.degrees[i]
set generic_degree_string(CharacterTable ct)  = (int i)string:
   if ct.has_generic_degree(i) then ct.generic_degree(i).to_string else "" fi

set sum(CharacterTable ct) = ([int],[int]->[int]): ct.class_table.direct_sum
set product(CharacterTable ct) = (([int],[int])->[int]): ct.class_table.tensor

set power_map(CharacterTable ct) = (int i) [int]: { powers of class |i| }
   let Wct=ct.class_table
   , order = ct.class_rep(i).order { or |Wct.class_representatives()[ii].order }
   in for k: order do Wct.class_power(i,k) od

set sym_power_refl(CharacterTable ct) = ct.class_table.sym_power_refl

set degree(CharacterTable ct) = (int i): ct.degrees[i]

set trivial(CharacterTable ct) = [int]: ct.class_table.trivial
set sign(CharacterTable ct) = [int]: ct.class_table.sign
set reflection (CharacterTable ct) = [int]: ct.class_table.reflection

{tensor_sign: [int] -> [int]}
set tensor_sign(CharacterTable ct) = ([int]->[int]):
   let sign=ct.sign in ([int] char): tensor(sign,char) { "free" |tensor| above }
set tensor_sign(CharacterTable ct,[int] char) = [int]: ct.tensor_sign(char)

{tensor_sgn: int->int}
set tensor_sign_index(CharacterTable ct) = (int->int):
   let ts = ct.tensor_sign in
   (int index) int: ct.character_index(ts(ct.character(index)))
set tensor_sign_index(CharacterTable ct, int index) = int:
   ct.tensor_sign_index(index)


{tensor product of two rows of character table}
set tensor(CharacterTable t) = (int i,int j)[int]:
   product(t.character(i),t.character(j)) { "free" |product| = |tensor| above }
set tensor_power(CharacterTable t) = (int i,int k)[int]:
   tensor_power(t.character(i),k)

set Cartesian_power(CharacterTable ct) = ([int] x,int n)[int]:
   assert(#x=ct.n_irreps,"Wrong size"); for v in x do n*v od

set scalar_product (CharacterTable ct) = (int i0, int i1) int:
   ct.inner(ct.character(i0),ct.character(i1))

{different name for use with [int],[int] arguments}
set inner_product = (CharacterTable->([int],[int]->int)):
   inner@CharacterTable { we already had that function }

set check_orthogonality (CharacterTable ct) = bool:
   let n=ct.n_irreps in matrix((n,n),ct.scalar_product) = id_mat(n)

{ The following few functions assume |ct| has a simple root datum }

{ find index j of the conjugacy class of a long root reflection, or -1 if none }
set index_long_reflection(CharacterTable ct) = int:
   let rd=ct.root_datum
   then inx = first(rd.semisimple_rank,(int i)bool: is_long_root(rd,i))
in if inx.< then { there is no long root } minus_1
   else ct.class_of(W_elt(rd,[inx]))
   fi

set index_short_reflection(CharacterTable ct) = int:
   let rd=ct.root_datum
   then inx = first(rd.semisimple_rank,(int i)bool: not is_long_root(rd,i))
in ct.class_of(W_elt(rd,[inx]))

{ character values at two or three special elements:
  identity, long root reflection, and if different short root reflection }
set signature(CharacterTable ct,[int] char) = [int]:
   let i_long=ct.index_long_reflection, i_short=ct.index_short_reflection
in if i_long.< then { single root length } [char[ct.id_class],char[i_short]]
   else [char[ct.id_class],char[i_long],char[i_short]]
   fi

set signature(CharacterTable ct) = ([int] char)[int]: signature(ct,char)

set decompose(CharacterTable ct) = (vec v)[int]: { list of irrep multiplicities }
   for i:#ct.table do ct.inner_product(v,ct.character(i)) od


{ symmetric power of a character }
set sym_power (CharacterTable tab) = tab.class_table.sym_power
set ext_power (CharacterTable tab) = tab.class_table.ext_power

{mults is a vector of multiplicities of the irreducible characters,
return a list (without multiplicities) of the irreducible characters
of smallest degree occuring}
set smallest_degree_summands(CharacterTable ct,[int] mults) = [int]:
   let degrees = for m@j in mults do if m.> then [ct.degree(j)] else [] fi od.##
in if =#degrees then [] { no multiplicities, empty result }
   else let min = min(degrees)
   in for m@j in mults do if m.> and ct.degree(j)=min then [j] else [] fi od.##
   fi


{ convenience functions }

set show_classes(CharacterTable ct) = void:
tabulate (
   ["i"
   ,"order"
   ,"class_size"
   ,"|cent|"
   ,"sgn(w)"
   ,"chi_refl(w))"
   ,"name"
   ]
#  for i:#ct.table
   do [i.to_string
      ,ct.class_order(i).to_string
      ,ct.class_size(i).to_string
      , ct.centralizer_order(i).to_string
      ,ct.sign[i].to_string
      ,ct.reflection[i].to_string
      ,ct.class_label(i)
      ]
   od
)
set irred_string(BiPartition(mu,lambda)) = string:
   ("{", mu.parts_string,"-|+",lambda.parts_string, "}").to_string

set show_classes_long(CharacterTable ct) = void:
tabulate (
    ["i"
    ,"order"
    ,"class_size"
    ,"|cent|"
    ,"sgn(w)"
    ,"chi_refl(w))"
    ,"name"
    ,"class rep"
    ]
#  for i:#ct.table
   do [i.to_string
      ,ct.class_order(i).to_string
      ,ct.class_size(i).to_string
      , ct.centralizer_order(i).to_string
      ,ct.sign[i].to_string
      ,ct.reflection[i].to_string
      ,ct.class_label(i)
      ,ct.class_rep(i).to_string
      ]
   od
)

set show_reps(CharacterTable ct) = void:
let id_class=ct.id_class in
tabulate (
   ["i"
   ,"dim"
   , "deg"
   ,"gdeg"
   ,"name"
   ]
#  for i:ct.n_irreps
   do [i.to_string
      ,character_value(ct,id_class)(i).to_string
      ,ct.degree(i).to_string
      ,ct.generic_degree_string(i)
      ,ct.irreducible_label(i).to_string
      ]
   od
)

set show(CharacterTable ct) = void:
   prints("Classes:"); ct.show_classes;
   prints("Representations:"); ct.show_reps

set show_long(CharacterTable ct) = void:
   prints("Classes:"); ct.show_classes_long;
   prints("Representations:"); ct.show_reps

set show_very_long(CharacterTable ct) = void:
   prints("Classes:"); ct.show_classes_long;
   prints("Representations:"); ct.show_reps;
   prints("Character Table:"); prints(ct.table)

set view_multiplicities (CharacterTable ct,vec v {multiplicities}) = void:
   let table =
      for mult@i in v
      do if mult>0 else []
	 then
	 [  [i.to_string
	    ,mult.to_string
	    ,dimension(ct,i).to_string
	    ,ct.degrees[i].to_string
	    ,ct.generic_degree_string(i)
	    ]
	 ]
	 fi
      od.##
 in tabulate(["#","mult","dim","deg","gdeg"]#table)

set view_char(CharacterTable ct,vec character) = void:
   view_multiplicities(ct,ct.decompose(character))

set view_char(CharacterTable ct) = (vec v)void: view_char(ct,v)
