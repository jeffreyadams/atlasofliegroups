<basic.at
<kl.at { for |composition_series| }
<parameters.at { for |param_pol| }

{ This file concerns the order relation on parameters generated by

q \le SIG p if there is an r in reducibility_points(p) with q a
            composition factor of p*r

and also

p*0 \le SIG p

}
{ change from #P to #alcove_center(P) is gain from alcove_center }

set alcove_count = bool: false

set alcove_center(ParamPol P) = sum(P.real_form,for p in monomials(P)
do alcove_center(p) od)

{ All the parameters p*r, with r in reducibility_points(p), and p a
term of P}
set red_lineOLD(ParamPol P) = ParamPol:
let G=P.real_form, zero = 0*P in P + sum(G, for p in monomials(P) do sum(G,for r
in reducibility_points(p) do if r<1 then 1*(p*r) else zero fi od) od)

set red_line(ParamPol P) = ParamPol:
let G=P.real_form, zero = 0*P, one=1+0*s in P + ##for @p in P do ##for r
in reducibility_points(p) do if r<1 then [(one,p*r)] else [] fi od od


{ Implements iterative construction of all terms that can appear in the
  deformation calculation. During the iteration...
  P0 is the sum of real tempered parameters that might appear in computed deformation
  formulas (initialized as 0*p);
  P1 is the sum of all possibly nontempered parameters considered, and
  already deformed (initialized as 0*p);
  Pw is the sum of possibly nontempered parameters yet to be
  deformed (initialized as 1*p). Idea is to apply this function repeatedly,
  starting at (1*p,0*p,0*p) }

set_type PP3 = (ParamPol,ParamPol, ParamPol)


set sig_down(RealForm G, (Param->ParamPol) gen) = (PP3->PP3):
(  let !zero = null_module(G)
in (PP3 (Pw,P1,P0)) PP3:
   let redPw = Pw+red_line(Pw)
   , max_den = max
     (([1]##for @p in Pw do denom(nu(p)) od).max, ([1]##for @p in P1 do denom(nu(p)) od).max)
   in prints("cardinalities for (Pw,P1,P0) are ("
      	,#Pw,",",#P1,",",#P0,"); largest denominator = ", max_den);
   P0 := (P0 next P0:=zero) + Pw*0;
   Pw :=(let list = [Param]:
         for @p in redPw
	 do if =P1[p] else []
	    then let P = gen(p) then c=P[p] in monomials((P next P:=zero)-c*p)
	    fi { P[p]:=0 }
	 od.## in zero+list);
   (Pw,(P1 next P1:=zero)+redPw,P0)
)

set sig_down_3(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
sig_down(Pw.real_form,composition_series@Param)(Pw,P1,P0)

{ same thing, but tries to speed up computation by replacing
composition_series(p) by partial_block(p). This should be a weakly
larger set, and in the present iterative setting should lead to
_nearly_ the same (slightly larger?) full_sig_down }


set partial_block_pol(Param p) = param_pol(partial_block(p), p.real_form)

set sig_down_partial(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
sig_down(Pw.real_form,partial_block_pol@Param)(Pw,P1,P0)


set sig_down_partial2(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol, ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = Pw+red_line(Pw), max_den = max
     (([1]##for @p in Pw do denom(nu(p)) od).max, ([1]##for @p in P1 do denom(nu(p)) od).max) in
prints("cardinalities for (Pw,P1,P0) are (",#Pw,",",#P1,",",#P0,
"); largest denominator = ", max_den);
  (param_pol(##for p in monomials(redPw) do if P1[p] = 0 then
  partial_block(p)[:1~] else [] fi od,G),P1+redPw, P0+Pw*0)

{ same thing, but replacing each parameter q encountered by
alcove_center(q). This version is to illustrate the memory savings and
smaller denominators provided by using alcove-center }

set sig_down_alcove(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = alcove_center(Pw+red_line(Pw)), max_den = max
     (([1]##for @p in Pw do denom(nu(p)) od).max, ([1]##for @p in P1 do denom(nu(p)) od).max) in
prints("cardinalities for (Pw,P1,P0) are (",#Pw,",",#P1,",",#P0,
"); largest denominator = ", max_den);
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  alcove_center(composition_series(p) - p) else zero fi od),P1+redPw,
  P0+Pw*0)

{ same thing, replacing composition_series by (faster to compute)
character_formula. Again, in present iterative setting, should lead to
a very similar full_sig_down. }

set sig_down_inv(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = Pw+red_line(Pw), denoms =
for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0) are (",#Pw,",",#P1,",",#P0,
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  sum(G, for (,q,) in KL_column(p) do 1*q od)-p else zero fi od),
  P1+redPw, P0+Pw*0)

{ replace composition_series by character_formula AND alcove_center }

set sig_down_inv_alcove(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = alcove_center(Pw+red_line(Pw)),
denoms = for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0) are (",#Pw,",",#P1,",",#P0,
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  alcove_center(character_formula(p) - p) else zero fi od),P1+redPw,
  P0+Pw*0)

{ replace composition_series by partial_block and
alcove_center. Should give a slightly larger full_sig_down than
sig_down_alcove }

set sig_down_partial_alcove(ParamPol Pw, ParamPol P1, ParamPol P0) = (ParamPol,
ParamPol, ParamPol):
let G=Pw.real_form , zero = 0*Pw, redPw = alcove_center(Pw+red_line(Pw)),
denoms = for p in monomials(Pw+P1) do denom(nu(p)) od in
prints("cardinalities for (Pw,P1,P0) are (",#Pw,",",#P1,",",#P0,
"); largest denominator = ", max(denoms));
  (sum(G,for p in monomials(redPw) do if P1[p] = 0 then
  alcove_center(param_pol(partial_block(p)[:1~],G)) else zero fi od),P1+redPw,
  P0+Pw*0)

{size of to-be-computed part}
set to_do(ParamPol Pw, ParamPol P1, ParamPol P0) = #Pw

{ PROCEDURE: fix parameter p. Start with triple = (1*p,0*p,0*p). Apply
sig_down_* to triple repeatedly, until first term is zero. Then the
second term is more or less all the parameters that needed to be
deformed, and the third is the list of all the possible tempered real
terms that could appear. }

{ this implements PROCEDURE. }
set full_sig_down(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_3(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0) are (",#P1,",",#P0,
"); largest denominator = ", max(denoms)) ;
if alcove_count = true then prints("number of alcoves = ",#alcove_center(P1)) fi

set full_sig_down_partial(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_partial(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0) are (",#P1,",",#P0,
"); largest denominator = ", max(denoms));
if alcove_count = true then prints("number of alcoves = ",#alcove_center(P1)) fi

set full_sig_down_partial2(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_partial2(triple) od;
let (,P1,P0) = triple then denoms = for @p in P1 do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0) are (",#P1,",",#P0,
"); largest denominator = ", max(denoms));
if alcove_count = true then prints("number of alcoves = ",#alcove_center(P1)) fi

set full_sig_down_alcove(Param p) = void: let triple = (1*p,0*p,0*p)
in while to_do(triple) >0 do triple:=sig_down_alcove(triple) od; let
(,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0) are (",#P1,",",#P0,
"); largest denominator = ",max(denoms))

set full_sig_down_inv(Param p) = void: let triple = (1*p,0*p,0*p) in while
to_do(triple) >0 do triple:=sig_down_inv(triple) od;
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0) are (",#P1,",",#P0,
"); largest denominator = ", max(denoms));
if alcove_count = true then prints("number of alcoves = ",#alcove_center(P1)) fi

set full_sig_down_inv_alcove(Param p) = void: let triple = (1*p,0*p,0*p)
in while to_do(triple) >0 do triple:=sig_down_inv_alcove(triple) od; let
(,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0) are (",#P1,",",#P0,
"); largest denominator = ", max(denoms))

set full_sig_down_partial_alcove(Param p) = void: let triple = (1*p,0*p,0*p)
in while to_do(triple) >0 do triple:=sig_down_partial_alcove(triple) od; 
let (,P1,P0) = triple then denoms = for p in monomials(P1) do denom(nu(p)) od in
prints("Final cardinalities for (P1,P0) are (",#P1,",",#P0,
"); largest denominator = ", max(denoms))

