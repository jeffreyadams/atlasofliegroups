<basic.at
<classical_W_classes_and_reps.at { for |test_simple_type| }
<character_tables.at

set ! G2_class_words = [[],[0],[1],[0,1],[0,1,0,1],[0,1,0,1,0,1]]

set class_table_G(RootDatum rd) = WeylClassTable:
  let map=test_simple_type("G",rd)
  then magic_coweight = 5*coroot(rd,map[0])+9*coroot(rd,map[1]), rho=rho(rd)\1
  then type(WeylElt w) = int:
    case magic_coweight*(w*rho) { mod 15; all collisions are conjugate }
    in die, 5, 2, die, 1, die, die, 3, 4, die, die, 2, die, 1, 0
    esac
  , reps =
      for word in G2_class_words do W_elt(rd,for bit in word do map[bit] od) od
  in W_class_table( rd, reps
		  , (int i) int: {class size} case i in 1,3,3,2,2,1 esac
		  , {classify |w|} type
		  , (int i,int k) int: {class powers}
		    case i-3 else { order 2 } case k in 0,i esac
		    in {i=3} case k in 0,3,4,5,4,3 esac
		    ,  {i=4} case k in 0,4,4 esac
		    esac
		  )

set class_table_G (int n) = WeylClassTable:
   assert(n=2,"Inexistent type G"+n); class_table_G(simply_connected("G2"))

set character_table_G = (RootDatum -> CharacterTable):
   let class_names = ["e", "S_short", "S_long", "R/6", "R/3", "R/2"]
   , irreps = [classical_irrep,string,[int]]:
     [( null_irrep(), "trivial"   , [1,1,1,1,1,1]   )
     ,( null_irrep(), "short sign", [1,-1,1,-1,1,-1])
     ,( null_irrep(), "long sign" , [1,1,-1,-1,1,-1])
     ,( null_irrep(), "full sign" , [1,-1,-1,1,1,1] )
     ,( null_irrep(),  "triangular reflection", [2,0,0,-1,-1,2])
     ,( null_irrep(),  "hexagonal reflection",  [2,0,0,1,-1,-2])
     ]
in (RootDatum rd) CharacterTable:
   let class_table = class_table_G(rd)
   then classes = [WeylElt,classical_class,string]:
      for w@i in class_table.class_representatives
      do (w,null_class(),class_names[i])
      od
   in character_table(class_table,classes,irreps)

set character_table_G(int n) = CharacterTable:
   character_table_G(simply_connected("G2"))
