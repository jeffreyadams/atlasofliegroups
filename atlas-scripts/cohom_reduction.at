< basic.at
< induction.at {for theta-stable parabolics}

set any (maybe_a_mat M) = bool:
   case M  | solution: true | no_mat: false esac
set mat_requisition (string message) = (maybe_a_mat->mat):
   (maybe_a_mat M) mat:
    case M  | solution(s): s | else error(message) esac
set requisition = mat_requisition("No solution found; having one was required")
{system (A,B) means solving AX = B}
set required_solution ((mat,mat) system) = mat: system.solve.requisition
set required_solution ((mat,mat) system) = mat:system.solve.requisition

{ lists real and/or complex simple factors }
set simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
	simpleFactors = simple_factors(RootDatum: G),
	Factors = [RealForm]:[]
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex),
	 newDiagram = diagram_component(G,newSimpleRootIndex)
    in  if diagram=newDiagram then Factors##:=
	 [real_form(inner_class(rd,delta), delta, tf)]
	 else if diagram[0] < newDiagram[0] then Factors##:=
	 [real_form(inner_class(sub_datum(G,diagram##newDiagram),
		delta), delta, tf)]
	      fi
	fi
    od; Factors

{ lists real and/or complex simple factors }
set simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
	simpleFactors = simple_factors(RootDatum: G),
	Factors = [RealForm]:[]
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex),
	 newDiagram = diagram_component(G,newSimpleRootIndex)
    in  if diagram=newDiagram then Factors##:=
	 [real_form(inner_class(rd,delta), delta, tf)]
	 else if diagram[0] < newDiagram[0] then Factors##:=
	 [real_form(inner_class(sub_datum(G,diagram##newDiagram),
		delta), delta, tf)]
	      fi
	fi
    od; Factors

{for this built-in version, I don't know how to construct the
KGBElts. If G is U(2,1) and D is SU(2,1), any reasonable construction
of torus factors seems to have denominators of 3, but those don't
appear in derived(U(2,1)).}
set derived_simple_factors_easy(RealForm G) = [RealForm]:
    for S in simple_factors(G) do derived(S) od

{(M,N): M is natural restriction from X^*(S) onto X^*(D).
 N is right inverse of M.}
set derived_infos(RealForm G) = [(mat,mat)]:
    for S in simple_factors(G) 
    do let (,M) = derived_info(S)
    in (M,required_solution(M, id_mat(S.semisimple_rank)))
    od

{projection from ratl coweight of G to coweight of S, respecting
values on roots of S}
set cowt_inclusions(RealForm G) = [(ratvec->ratvec)]:
    for S in simple_factors(G)
    do (ratvec->ratvec):
    (ratvec v) : sum(G.rank,
      for xi@j in fundamental_coweights(S) do (v*S.simple_roots[j])*xi od)
    od

{now suppose x is a KGBElt for G. Want to project it on the derived
simple factors}
set derived_thetas(KGBElt x) = [mat]:
    let theta = x.involution, G=x.real_form
    in  for (M,N) in derived_infos(G)
       	do M*theta*N
       	od

set derived_torus_factors(KGBElt x) = [ratvec]:
    let G = x.real_form
    then tf0 = torus_factor(x), DSFs = derived_simple_factors_easy(G)
    in for DSF@j in DSFs
       do let (M,N) = derived_infos(G)[j]
       	  in ^N*(cowt_inclusions(G)[j](tf0))
       od

set derived_KGBs(KGBElt x) = [KGBElt]:
    let G = x.real_form, thetas = derived_thetas(x),
    	tfs = derived_torus_factors(x)
    then DSF = derived_simple_factors_easy(G)
    in for DS@j in DSF
    do KGB_elt(inner_class(DS), thetas[j], tfs[j])
    od

set derived_simple_factors(RealForm G) = [RealForm]:
    for xD in derived_KGBs(x_open(G))
    do xD.real_form
    od

set weak_support(Param p) = [int]:
    support(p.x)

set weakly_good(Param p) = Parabolic: (support(p.x), p.x)

set good_support(Param p) = [int]:
    let S = support(p.x), gamma=p.infinitesimal_character, G = p.real_form
    in for j: G.semisimple_rank
       do if (is_member(S)(j) or (G.simple_coroots[j]*gamma) = 0)
       	  then [j]
	  else []
	  fi
       od.##

set good(Param p) = Parabolic: (good_support(p), p.x)

set descents(Param p, [int] S) = [Param]:
    let  x = p.x, G = p.real_form, lambda = p.lambda, nu = p.nu,
    	 gamma = p.infinitesimal_character
    then P = Parabolic: (S, x)
    then () = assert(is_parabolic_theta_stable(P),"Designated P is not theta-stable")
    then L = P.Levi
    then lambdaL = lambda - G.rho + L.rho, nuL = nu, xL = inverse_embed_KGB(x,L)
    then DSF = derived_simple_factors_easy(L), DSFinfos = derived_infos(L)
    then xDSs = derived_KGBs(xL)
    then nuDSs = for (M,) in DSFinfos do M*nu od
    in for DS@j in DSF
       do let (M,) = DSFinfos[j]
       	  in parameter(xDSs[j], M*lambda, M*nu)
       od



{the reps from which p is cohomologically induced in the weakly
     good range}
set weak_descents(Param p) = [Param]:
    descents(p, weak_support(p))

{the reps from which p is cohomologically induced in the good range.}
set good_descents(Param p) = [Param]:
    descents(p, good_support(p))

set is_unitary_good(Param p) = bool:
    for q in good_descents(p)
    do if not(is_unitary(q))
       then return false
       fi
    od;
    true


set is_unitary_weak(Param p) = bool:
    if all (for q in weak_descents(p)
       	    do is_unitary(q)
	    od)
    then return true
    else if weakly_good(p).Levi = p.real_form
    	 then return false
    	 else return all (for r in good_descents(p)
    	      	     	  do is_unitary(r)
	      	     	  od)
    	 fi

     fi
