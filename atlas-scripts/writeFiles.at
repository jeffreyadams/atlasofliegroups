< basic.at {for x}
<groups.at {for GL(1,R)}
{These functions are meant for writing .at files that can later be
read by atlas. For files of type [vec], such writing can be done ad
hoc very easily; but the ad hoc files, which might look like

set data = [vec]: [
[0,1,2],
[3,4],
[5,6,7,8]
]

turn out to be difficult to read when #[vec] is large; for example,
reading such a file of size 100 million takes more than 5 gigabytes of
memory. The write_vecs functions avoid this difficulty.

Other atlas data types, like RealForm KTypePol and ParamPol, are not
displayed in a fashion that atlas can read; so it is not so easy to
write them to a file. These difficulties are addressed by
write_real_form, write_K_type_pols, and write_p_pols.}

set default_vecs_name = string:"vecs_saved"

set write_vecs([vec] list, string VecsName) = void:
    begin
	 prints("set ",VecsName," = [vec]: for i:",#list," do [] od")
	 ; for i:#list
	   do prints("void:",VecsName,"[",i,"]:=",[int]: list[i])
	   od
    end

set write_vecs([vec] list) = void:
    write_vecs(list, default_vecs_name)

set write_append([int] list, string listname) = void:
    begin
	 for M in list do prints("void:",listname,"#:=",M) od
    end

set default_ic_name = string:"ic_saved"
set default_group_name = string:"G_saved"

set write_inner_class(InnerClass ic, string ICName) = void:
    begin
	prints("set rd_saved = RootDatum: root_datum(mat: ")
	; prints( for alpha in ic.simple_roots do alpha od, ", mat:")
	; prints( for betavee in ic.simple_coroots do betavee od)
	; prints(",",ic.prefers_coroots,")")
	; prints("set DI_saved = mat: ")
    	; prints(for col in ic.distinguished_involution do col od)
        ; prints( "set ",ICName, " = inner_class(rd_saved, DI_saved)")
    end

set write_inner_class(InnerClass ic) = void:
    write_inner_class(ic,default_ic_name)

set write_ic_list([InnerClass] ics, string list_name) = void:
     begin
	prints("set ",list_name, " = [InnerClass] : [], temp_ic = InnerClass:GL(1,R)")
	; for ic in ics
	  do write_inner_class(ic, "temp_ic");
	     prints(list_name,"#:= temp_ic")
	  od
     end

set append_inner_class(InnerClass ic, string list_name) = void:
    begin
    write_inner_class(ic,"ic_temp")
    ; prints(list_name,"#:= ic_temp")
    end

set write_real_form(RealForm G, string GroupName) = void:
    begin
	 prints("set rd_saved = RootDatum: root_datum(mat: ")
    	 ; prints( for alpha in G.simple_roots do alpha od, ", mat:")
	 ; prints( for betavee in G.simple_coroots do betavee od)
	 ; prints(",",G.prefers_coroots,")")
         ; prints("set DI_saved = mat: ")
    	 ; prints(for col in G.distinguished_involution do col od)
         ; prints( "set IC_saved = inner_class(rd_saved, DI_saved)")
    	 ; prints("set ",GroupName,"= real_form(IC_saved, DI_saved,",
	   	       KGB(G,0).torus_factor,")")
    end

set write_real_form(RealForm G) = void:
    write_real_form(G,default_group_name)

{#KGBElt extracts its number}
set data(KType mu) = (int, vec):
    (mu.x.#, mu.lambda_rho)

{first coord is coefficient, second is KGBElt, rest are lambda-rho}
set_type KPolTermDatum = vec

set K_data(KTypePol P) = [KPolTermDatum]:
    for c@mu in P do [int_part(c)]##[mu.x.#]##mu.lambda_rho od

set K_pol(RealForm G, [KPolTermDatum] KData) = KTypePol:
    sum(G, for d in KData do d[0]*K_type(KGB(G,d[1]),d[2:]) od)

set default_K_type_pols_name = string:"KPols_saved"
{ If you say

> FILE.at write_K_type_pols(G, KPols, FileName )

then in a later session

<< FILE.at

will give you FileName = [KTypePol]: KPols .}

set write_K_type_pols(RealForm G, [KTypePol] KPols, string KPolsName) = void:
    begin
         write_real_form(G,"G_temp")
         ; prints("set Null = null_K_module(G_temp)")
     	 ; prints("set ",KPolsName,"= [KTypePol]: for i:",#KPols,
	   	       " do Null od")
	 ; for i:#KPols
	   do let d = K_data(KPols[i])
	      in prints("void:",KPolsName,"[",i,"]:=K_pol(G_temp,[vec]:",
			[[int]]: d,")")
	   od
   end

set write_K_type_pols(RealForm G, [KTypePol] KPols) = void:
    write_K_type_pols(G,KPols,default_K_type_pols_name)


{ same thing, reading in Pols already converted to Kdata }

set write_K_type_pols(RealForm G, [[KPolTermDatum]] KPolsData,
    			       string KPolsName) = void:
    begin
	 write_real_form(G,"G_temp")
         ; prints("set Null = null_K_module(G_temp)")
     	 ; prints("set ",KPolsName,"= [KTypePol]: for i:",#KPolsData,
	   	       " do Null od")
	 ; for d@i in KPolsData
	   do prints("void:",KPolsName,"[",i,"]:=K_pol(G_temp,[vec]:",
			[[int]]: d,")")
	   od
   end

set write_K_type_pols(RealForm G, [[KPolTermDatum]] KPolsData) = void:
    write_K_type_pols(G,KPolsData,default_K_type_pols_name)


set write_K_type_pols(RealForm G, [[KPolTermDatum]] KPolsData) = void:
     write_K_type_pols(G, KPolsData, default_K_type_pols_name)

set default_K_type_pols_data_name = "KPols_saved_data"

{. Same thing, writing only data and not KTypePol's.}

set write_K_type_pols_data(RealForm G, [KTypePol] KPols,
    			string KPolsDataName) = void:
    begin
         write_real_form(G)
     	 ; prints("set ",KPolsDataName,"= [[vec]]: for i:",#KPols,
	   	       " do [] od")
	 ; for P@i in KPols
	   do prints("void:",KPolsDataName,"[",i,"]:=",
			[[int]]: K_data(KPols[i]))
	   od
     end

set write_K_type_pols_data(RealForm G, [KTypePol] KPols) = void:
     write_K_type_pols(G, KPols, default_K_type_pols_name)


{. Same thing, reading and writing only data and not KTypePol's.}

set write_K_type_pols_data(RealForm G, [[KPolTermDatum]] KPolsData,
    			string KPolsDataName) = void:
    begin
         write_real_form(G)
     	 ; prints("set ",KPolsDataName,"= [[vec]]: for i:",#KPolsData,
	   	       " do [] od")
	 ; for d@i in KPolsData
	   do prints("void:",KPolsDataName,"[",i,"]:=",
	   [[int]]: d)
	   od
     end

set write_K_type_pols_data(RealForm G, [[KPolTermDatum]] KPolsData) = void:
     write_K_type_pols_data(G, KPolsData, default_K_type_pols_data_name)

set_type ParamPolTermDatum = (vec,ratvec)

set p_data(Param p) = (int, vec, ratvec):
    (p.x.#, ratvec_as_vec(p.lambda - p.real_form.rho), p.nu)

set p_data(ParamPol P) = [ParamPolTermDatum]:
    for c@p in P do let (x,lr,nu) = %p in ([int_part(c)]##[x.#]##lr,nu) od

set p_pol(RealForm G, [ParamPolTermDatum] data) = ParamPol:
    sum(G, for (d,nu) in data do d[0]*param(KGB(G,d[1]),d[2:],nu) od)

set default_p_pols_name = string:"ParamPols_saved"
{ If you say

> FILE.at write_p_pols(G, pPols, FileName )

then in a later session

<< FILE.at

will give you FileName = [ParamPol]: pPols .}

set write_p_pols(RealForm G, [ParamPol] pPols, string pPolsName) = void:
    begin
         write_real_form(G,"G_temp")
         ; prints("set Null = null_module(G_temp)")
     	 ; prints("set ",pPolsName,"= [ParamPol]: for i:",#pPols,
	   	       " do Null od")
	 ; for i:#pPols
	   do let d = p_data(pPols[i])
	      in
    prints("void:",pPolsName,"[",i,"]:=p_pol(G_temp,[(vec,ratvec)]:",d,")")
	   od
   end

set write_p_pols(RealForm G, [ParamPol] pPols) = void:
    write_p_pols(G,pPols,default_p_pols_name)

{to write a list of Param's for a single RealForm}
set write_param_list([Param] list, string listName) = void:
    begin
	let G_temp = GL(1,R)
	then () = if #list > 0 then G_temp := list[0].real_form
	fi
	; write_real_form(G_temp, "G_temp")
	; prints("set Nullp = U(1,0).trivial")
	; prints("set ",listName,"=[Param]: for i:",#list,
	  	      " do Nullp od")
        in for p@i in list
	  do let (,x) = %p.x
	     in prints("void:",listName,"[",i,"]:=parameter(KGB(G_temp,",
	     	x,"),",p.lambda,",",p.nu,")")
	  od
    end

{
add an additional list of params to append to a previously written
file of Param's for G_temp. REQUIRE all the lists to be for the same
real form.

If LIST1 and LIST2 are lists of Param's for G in atlas, you can type

atlas> > file.at write_real_form (G,"G_temp")
atlas> >> file.at write_append_param_list(LIST1,"LIST1")
atlas> >> file.at write_append_param_list(LIST2,"LIST2")

or alternatively (creates a functionally equivalent file.at)

atlas> > file.at write_param_list(LIST1,"LIST1")
atlas> >> file.at write_append_param_list(LIST2,"LIST2")

When file.at is loaded into atlas, you'll recover LIST1 and LIST2. The
lines above can be separated by other code.

Wouldn't be so hard actually to append to LIST1, but I haven't done that.
}

set write_append_param_list([Param] list, string listName) = void:
    begin
	prints("set Nullp = U(1,0).trivial")
	; prints("set ",listName,"=[Param]: for i:",#list,
	  	      " do Nullp od")
        ; for p@i in list
	  do let (,x) = %p.x
	     in prints("void:",listName,"[",i,"]:=parameter(KGB(G_temp,",
	     	x,"),",p.lambda,",",p.nu,")")
	  od
    end

{
This is exactly like write_param_list, except that when the file is
loaded it creates [Param] by successive concatenation rather than by
creating a dummy list of the right size and modifying its entries. The
advantage is that you can just add lines to this file to add more
Param's. If you create the original file with
> orig.at write_cat_param_list(MyFirstList,"listname")
then you can add Params with
>> orig.at write_append_cat_param_list(MySecondList,"listname")
Only requirement is that all the Param's are for the same group.
}
set write_cat_param_list([Param] list, string listName) = void:
    begin
    	let G_temp = GL(1,R)
	then () = if #list > 0 then G_temp := list[0].real_form
	fi
	; write_real_form(G_temp, "G_temp")
	; prints("set ",listName,"=[Param]:[]")
	in for p@i in list
	   do let (,x) = %p.x
	      in prints("void:",listName,"#:=parameter(KGB(G_temp,",
	     	x,"),",p.lambda,",",p.nu,")")
	   od
    end

set write_append_cat_param_list([Param] list, string listName, string groupName) = void:
    begin
	 for p@i in list
	 do prints("void:",listName,"#:=parameter(KGB(",groupName,",",
	     	p.x.number,"),",p.lambda,",",p.nu,")")
	 od
    end

set write_append_cat_param_list([Param] list, string listName) = void:
    write_append_cat_param_list(list, listName,"G_temp")

{How to write a list}
{
set write_Item(Item item, string temp_item) = void:
    begin
    prints(temp_item," := ",item)
    end


set write_list([Item] items, string list_name) = void:
    begin
	prints("set ",list_name, " = [Item] : [], temp_item = NullItem")
	; for item@j in items
	  do write_Item(item, "temp_item");
	     prints(list_name,"#:= Item_saved")
	  od
}
{
set write_vec(vec v, string vec_name) = void:
    begin
    prints(vec_name," := ",v)
    end


set write_vec_list([vec] vecs, string list_name) = void:
    begin
	prints("set ",list_name, " = [vec] : [], vec_temp = vec: []")
	; for v in vecs
	  do write_vec(v, "vec_temp");
	     prints("void:",list_name,"#:= vec_temp")
	  od
    end
}