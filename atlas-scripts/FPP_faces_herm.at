{this file concerns (local) facets of parameters, in preparation of analysis of their unitarity.}

<FPP_faces_geom.at
<goodroots.at { for is_pos_on_LKTs }
<Dirac.at
<hermitian.at
<K_highest_weights.at {for all_lambda_differential_0}
<unity.at {for deform_hts}
<red_count.at {for red_count@Param}
<face_classes.at {for coords}
<cohom_reductionND.at {for glue_sigs}
<up_mu.at {for up_mu_hash}
<Vogan-dual.at {for dual@Param}
<FPP_lambdas.at
{BREAK HERE?}

{lowest level (index in hts[]) to start testing}
{1 gives small improvement over 2 in E6; haven't tested bigger G}
{3 is slight improvement over 2 in E7}
{set edge_offset = int: 1}

{how much to increase index in hts[] for testing at various levels}
{1 improves E6_s and E6_q time by almost 10% }
set edge_skip = int: 1

{sort KTypes uniquely}
set temp_sort_u ([KType] K_types) = [KType]:
  if =#K_types then []
  else
     for @t in K_types[0].null_K_module+for Kt in K_types do (1,Kt) od do t od
  fi

{collection of lookup functions for faces of various dimensions}
{defined in face_classes.at}
{set lookups([[vec]] LFD) = [(vec->int)]:
    for L@d in LFD do index_in(for v in L do v[:d+1] od) od}

{tail is how many coords follow the vertex indices}
set sort(RealForm G, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH, int tail) = [[FaceVertsKHash]]:
    if #LFDKH = 0 or #LFDKH[0]=0 then return LFDKH fi;
    if sort_LFD_flag
       then let tworhocheck = G.two_rho_check
	    then f(vec v) = int:
		 let (num,den) = %((face_bary(Lvd,v[:#v - tail])*tworhocheck)*1000)
		 in num\den
	    in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
       else LFDKH
       fi

set sort(RealForm G, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH) = [[FaceVertsKHash]]:
    if #LFDKH = 0 or #LFDKH[0]=0 then return LFDKH fi;
    let tail = #LFDKH[0][0]-1
    in sort(G, Lvd, LFDKH, tail)

set anti_sort(RealForm G, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH) = [[FaceVertsKHash]]:
    if #LFDKH = 0 or #LFDKH[0]=0 then return LFDKH fi;
    let tail = #LFDKH[0][0]-1
    in if sort_LFD_flag
       then let tworhocheck = G.two_rho_check
	    then f(vec v) = int:
		 let (num,den) = %((face_bary(Lvd,v[:#v - tail])*tworhocheck)*1000)
		 in -num\den
	    in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
       else LFDKH
       fi

{set tensor_height(K_type mu) = int:
    let G = mu.real_form
    then x0 = KGB(G,0)
    then K0 = K_0(x0)}

{whether frequently to invoke the following function}
set check_pols_flag = false

set check_pols(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH,
    int HT, KTypePol_hash pol_hash) = void:
    if not check_pols_flag then return () fi;
    let red_shift = int: if red_count_flag
			 then 1
			 else 0
			 fi
    in {prints("checking pols at (",x.number,",",lambda,")");}
       for list@d in LFDKH
       do for v in list
	  do let p = parameter(x,lambda,face_bary(Lvd,v[:d+1]))
	     then P = K_type_pol(character_formula_to_height(1*p,HT))
	     in assert(@:P = to_ht(pol_hash.index(v[d+red_shift+1]),HT), "wrong K_char")
	  od
       od

{if the zero parameter at (x,lambda) has invariant form indefinite on
LKTs, then no irreducible Langlands quotient can be unitary. We used
to record the cases when all the LQs were unitary, but no
longer. Setting this flag to "false" restores the old calculation.}
set fewer_reducible_unitary_flag = true

{. If "true," then print number of invocations of a unitarity test .}
set test_verbose = true

{. If "true," then print a little info about invocations of a unitarity test .}
set test_slightly_verbose = true

set nullint(int N) = [int]:
    for n:N do 0 od

{whether to record nonunitary reps as well as unitary}
set nuhash_flag = true

{whether to use this hashed branch function as often as possible}
set branch_hash_flag = true

{whether to include KGB numbers in output files. True makes them more human-readable, sometimes longer}
set write_x_flag = false

{whether to include known (x,lambda) maps in output files.}
set write_x_lambda_flag = false

{whether to use the script branching code instead of library}
set my_branch_flag = true

{whether to use the script hash of K_type_formula instead of library}
set my_formula_flag = false

{The result of cohomological induction on the level of K}
set theta_induce_K(KTypePol QL, RealForm G) = KTypePol:
K_type_pol(sum(G, for c@pL in QL do c*theta_induce_standard(param(pL),G) od))

{decide NOT to hash nonunitary...well, UNdecided 1/14/25}
{try to incorporate RF_sig_table 1/18/25}
{sig_height = height(p)-1 means full signature
phash always contains uhash and nuhash}
set_type
[big_unitary_hash_table =
( ( -> int) real_form_size {number of real forms included}
  , ( -> vec) uhash_sizes {for every real form, the number of unitary reps}
  , (RealForm -> int) uhash_size {for one real form, number of unitary reps}
  , ( -> vec) nuhash_sizes {for every real form, the number of nonunitary reps}
  , (RealForm -> int) nuhash_size {for one real form, number of nonunitary reps}
  , ( -> vec) K_type_size {number of LKTs for each real form}
  , ( -> vec) K_type_pol_size
  , (KType -> KTypePol) K_type_formula
  , (KTypePol -> KTypePol) mult_K_type_formula
  , ((KType,int) -> KTypePol) K_type_formula_to_ht
  , ((KType, int) -> KTypePol) branch_entry {branch std to height}
  , ((KTypePol, int) -> KTypePol) branch {branch pol of stds to height}
  , ((KTypePol, int, int) -> maybe_KTP) branch_interrupt {branch pol of stds to height if possible in bounded time}
  , (KTypePol -> int) KTypePol_lookup {number in our hash}
  , (KTypePol -> int) KTypePol_match {put into hash, return number}
  , ((RealForm, int) -> KTypePol) KType_pol_index {return specified KTypePol}
  , ((Param,int) -> KTypePol) sig_entry {signature to height}
  , ((Param,int,int) -> maybe_KTP) sig_entry_interrupt {signature to height interrupted}
  , (int, int -> int) branch_height {largest ht to which K type j on real form i has been branched}
  , (int, int -> int) sig_height {largest ht to which param j on real form i has had sig computed}
  , ( -> ) clear
  , (RealForm -> ) clearG
  , (RealForm -> int) rf_number {number of real form in list}
  , (int -> RealForm) rf_index {jth real form in list}
  , (RealForm -> [int]) xl_known {for each x, bitmap of lambda for which FPP unitary dual is known}
  , (RealForm -> int) x_known {bitmap of x for which entire FPP dual is known}
  , (RealForm -> int) x_partial {bitmap of x for which some lambda have FPP dual known}
  , ((KGBElt,int) -> ) finish {add bitmap of new known (x,lambda) to xl_known}
  , ((RealForm,int,int) -> ) finish_num {add bitmap of new known (x,lambda) to xl_known}
  , (KGBElt -> ) finishx {add x to x_known}
  , ((RealForm,int) -> ) finishx_num {add x to x_known}
  , ((RealForm,int) ->) finishxmap {OR int with x_known(RealForm)}
  , (KGBElt -> ) partialx {add x to x_partial}
  , ((RealForm,int) -> ) partialx_num {add x to x_partial}
  , ((RealForm,[int]) -> ) finishall {add bitmaps of all new known (x,lambda) to xl_known}
  , (RealForm -> Param_hash) phash {hash table of all indexed parameters}
  , (RealForm -> Param_hash) uhash {hash table of known unitary}
  , (RealForm -> Param_hash) nuhash {hash table of known nonunitary}
  , (RealForm -> vec) nu_heights {list of heights to which nu reps are known non-unitary}
  , (Param -> (int,int)) long_plookup {(rf_index(p.real_form), location of p in its phash)}
  , (Param -> (int,int)) long_ulookup {(rf_index(p.real_form), location of p in its uhash)}
  , (Param -> int) plookup {(location of p in its phash)}
  , (Param -> int) ulookup {(location of p in its uhash)}
  , (Param -> int) nulookup {(location of p in its nuhash)}
  , (Param -> int) nu_height_lookup {smallest height at which p is known to be nonunitary}
  , ((Param,int) -> bool) nu_height_lookup_bool {true or false if that is the KNOWN result
    		    	  			of is_unitary_to_ht(p,HT); otherwise true}
		 				{whether p is known to be nonunitary to int}
  , (Param -> bool) check {check whether p is unitary, and add to appropriate hash table}
  , ((Param,int) -> bool) check_to_ht {check whether p is unitary to height}
  , ((Param,int) -> int) check_interrupt {check whether p is unitary, and add to appropriate hash table}
    	       	    {1 means unitary, -1 nonunitary, 0 timed_out}
  , ((Param,int,int) -> int) check_to_ht_interrupt {check whether p is unitary to height}
  , (Param -> int) umatch {add p to its uhash table}
  , ((Param,int) -> int) numatch_height {add p known nonunitary to int to its hash table}
  , (Param -> int) numatch {add p to its nuhash table}
  , ((Param,int) -> int) long_umatch {add p to ith uhash table}
{  , ((int,ratvec,ratvec,int) -> int) long_umatch_coords {add p to ith uhash table}}
  , ((Param,int) -> int) long_match {add p to ith uhash table} {included for back compatibility}
  , ( -> ) write {output unitary data for file}
  , (RealForm -> ) writeG {output data for one group to file}
  , (RealForm -> ) writeG_nu {output known nonunitary for G to file}
  , ((RealForm, int, int) -> ) writeGrange {output data for KGB(G)[low,high]}
  , ((KGBElt, ratvec) -> ) writexlam {output data for one x,lambda}
  , (([KGBElt,ratvec]) -> ) writexlams {output data for list of (x,lambda)}
  , ((KGBElt, ratvec) -> ) writexlam_no_G {output data for one x,lambda; without writing G}
)
]

{function that will be properly defined in K_types.at}

set branch_std (KTypePol P, int cut_off) = KTypePol:
    let start = elapsed_ms()
    then ans = branch(P,cut_off)
    in branch_builtin_time +:= elapsed_ms() - start; ans

{set branch_std (KType mu, int cut_off) = KTypePol:
    branch_std(1*mu,cut_off)}

set finish_time = int:0
set is_finished_time = int:0
set branch_script_time = int:0

set make_big_unitary_hash() = big_unitary_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then uhashes = [Param_hash]: [] {one for each real form}
    then nuhashes = [Param_hash]: [] {one for each real form}
    then phashes = [Param_hash]: []
    {then status_strings = [[string]]: [] {one for each real form; "" is unknown, "T..." is unitary, "F..." nonunitary}}
    then K_type_hashes = [KType_hash] : [] {one for each real form; list of LKTs of params}
    then K_type_pol_hashes = [KTypePol_hash] : []  {one for each real form}
    then formulas = [vec]:[] {size of K_type_hash; entry in K_type_pol_hash recording K_type_formula}
    then formula_heights = [vec]:[] {size that of K_type_hash; largest height to which formula computed}
    then branches = [vec] : [] {one vec for each real form, of size #K types;
			      ith entry is index of branching KTypePol for KType #i}
    then sigs = [vec]: [] {one vec for each real form, of size #params;
			  jth entry is index of signature KTypePol for Param #j}
    then branch_heights = [vec]: [] {one list for each real form; jth entry is vec with ith entry the height
				   to which branch(param i) is known}
    then sig_heights = [vec]: [] {one list for each real form; jth entry is vec with ith entry
				 the height to which sig(param i) is known}
    then nu_heights = [vec]: [] {one list for each real form; jth entry is height to which jth entry of nuhash
				 is known to be nonunitary}
    then xl_known = [[int]]: [] {one bitmap of known (x,lambda) for each real form and x}
    then x_known = [int]: [] {one bitmap of known x for each real form}
    then x_partial = [int]: [] {one bitmap of partially known x for each real form}
    then clearBUH() = void:
	 let () = real_form_hash.clear()
	 then () = uhashes := []
	 then () = nuhashes := []
	 then () = phashes := []
	 {then () = status_strings := []}
	 then () = K_type_hashes := []
	 then () = K_type_pol_hashes := []
	 then () = formulas := []
	 then () = formula_heights := []
	 then () = branches := []
	 then () = sigs := []
	 then () = branch_heights := []
	 then () = sig_heights := []
	 then () = nu_heights := []
	 then () = xl_known := []
	 then () = x_known := []
	 then () = x_partial := []
	 in ()
    then add_real_form(RealForm rf) = int:
	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
	 then () = if i = I {haven't seen this real form before}
		   then	let empty = [int]: nullint(#KGB(rf))
			then () = K_type_hashes #:= make_KType_hash();
			     K_type_pol_hashes #:= make_KTypePol_hash();
			     formulas #:= null(0);
			     formula_heights #:= null(0);
			     branches #:= null(0);
			     sigs #:= null(0);
			     branch_heights #:= null(0);
			     sig_heights #:= null(0);
			     nu_heights #:= null(0)
			then () = xl_known #:= empty {null(#KGB(rf))}
			then () = x_known #:= 0
			then () = x_partial #:= 0
			{then () = status_strings #:= []}
			then () = uhashes #:= make_Param_hash()
			then () = nuhashes #:= make_Param_hash()
			then () = phashes #:= make_Param_hash()
			in ()
		   fi
	  then () = assert(@:real_form_hash.size() = #phashes and #phashes = #xl_known
						 and #uhashes = #phashes and #nuhashes = #phashes
						 and #phashes = #x_known {and #phashes = #status_strings}
						 and #x_partial = #x_known
						 and #K_type_hashes = #x_known and #K_type_pol_hashes = #x_known
						 and #branches = #x_known and #sigs = #x_known
						 and #sig_heights = #x_known and #nu_heights = #x_known,
						 "big_unitary_hash damaged")
	  in i
    then add_K_type(KType mu) = (int, int): {real form index, K type index}
	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf,1*mu))}
	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then ktypenum = K_type_hashes[rfnum].match(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
		   then let pol = 1*mu
			then m = K_type_pol_hashes[rfnum].match(pol)
			{then () = if KTYPENUM = 26 then prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum], ", fs = ",formulas[rfnum],", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum]) fi}
			then () = formulas[rfnum] #:= m
			then () = formula_heights[rfnum] #:= height(mu)
			then () = branches[rfnum] #:= m
			then () = branch_heights[rfnum] #:= height(mu)
			then () = assert(@:real_form_hash.size() = #K_type_pol_hashes,"big_unitary_hash damaged")
			then () = assert(@:real_form_hash.size() = #K_type_hashes,"big_unitary_hash damaged")
			then () = assert(@:#branches[rfnum] = K_type_hashes[rfnum].size() and
				  #branch_heights[rfnum] = #branches[rfnum], "branch_hash_table damaged")
			then () = assert(@:#branches[rfnum] = #formula_heights[rfnum] and
				#branches[rfnum]  = #formulas[rfnum], "branch_hash_table damagedAKTFTH")
			in ()
		   fi
	in (rfnum, ktypenum)
    then add_K_type_formula(KType mu) = (int, int, int): {rfnum, ktypenum, index(formula)}
	 let (rfnum,ktypenum) = add_K_type(mu), h = height(mu)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu :=  K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf,1*mu))}
	 then () = if formula_heights[rfnum][ktypenum] != h-1
		   then let m = K_type_pol_hashes[rfnum].match({regroup(rf,} K_type_formula(mu)){)}
			then formsrf = formulas[rfnum], formhsrf = formula_heights[rfnum]
			then () = formsrf[ktypenum] := m
			then () = formhsrf[ktypenum] :=h-1
			{then () = formulas[rfnum][ktypenum] :=m}
			{then () formula_heights[rfnum][ktypenum] :=h-1}
			then () = formulas[rfnum] := formsrf
			then () = formula_heights[rfnum] := formhsrf
			in ()
		   fi
	 {then () = prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum], ", fs = ",formulas[rfnum],", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum])}
	 then() = assert(@:K_type_hashes[rfnum].size() = #branches[rfnum] and #branches[rfnum] = #formulas[rfnum]
			and #branches[rfnum] = #branch_heights[rfnum]
			and #branches[rfnum] = #formula_heights[rfnum], "branch_hash_table damagedAKTF")
	 in (rfnum, ktypenum, formulas[rfnum][ktypenum])
    then add_K_type_formula_to_ht(KType mu, int D) = (int,int,int): {rfn, ktypen, index_to_ht(formula)}
	 let (rfnum,ktypenum) = add_K_type(mu), h = height(mu)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu :=  K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf, 1*mu))}
	 then () = assert(@:D >= h, "too-low height argument for K_type_formula")
	 then () = if (formula_heights[rfnum][ktypenum] < D and formula_heights[rfnum][ktypenum] >= h)
		   then let m = K_type_pol_hashes[rfnum].match({regroup(rf,}K_type_formula(mu,D)){)}
			then formsrf = formulas[rfnum], formhsrf = formula_heights[rfnum]
			then () = formsrf[ktypenum] := m
			then () = formhsrf[ktypenum] := D
			{then () = formulas[rfnum][ktypenum] :=m}
			{then () formula_heights[rfnum][ktypenum] :=h-1}
			then () = formulas[rfnum] := formsrf
			then () = formula_heights[rfnum] := formhsrf
			in ()
		   fi
	 {then () = if ktypenum = 13 then prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum],
	      ", fs = ",formulas[rfnum], ", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum]) fi}
	 then() = assert(@:K_type_hashes[rfnum].size() = #branches[rfnum] and #branches[rfnum] = #formulas[rfnum]
			 and #branches[rfnum] = #branch_heights[rfnum]
			 and #branches[rfnum] = #formula_heights[rfnum], "branch_hash_table damagedAKTFTH")
	 in (rfnum, ktypenum, formulas[rfnum][ktypenum])
    then add_K_type_branch(KType mu, int D) = (int, int, int):
	 {this time add to height; D should be >= height(mu)}
	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {now mu is attached to rf}
	 {first_K_type(regroup(rf,1*mu))}
	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then (,ktypenum) = add_K_type(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
		   then {let start_branch = elapsed_ms()}
			let pol = {regroup(rf,} branch_std(1*mu,D){)}
			then m = K_type_pol_hashes[rfnum].match(pol)
			then tempbranchhts = branch_heights[rfnum]
			then tempbranches = branches[rfnum]
			then () = tempbranches[ktypenum] := m
			then () = tempbranchhts[ktypenum] := D
			then () = branch_heights[rfnum] := tempbranchhts
			then () = branches[rfnum] := tempbranches
			then () = assert(@:real_form_hash.size() = #K_type_pol_hashes,"big_unitary_hash damaged")
			then () = assert(@:real_form_hash.size() = #K_type_hashes,"big_unitary_hash damaged")
			then () = assert(@:#branches[rfnum] = K_type_hashes[rfnum].size(), "big_unitary_hash damaged")
			   in ()
		   else {we've seen mu before}
		       if branch_heights[rfnum][ktypenum] < D
		       then let tempbranchhts = branch_heights[rfnum]
			    then tempbranches = branches[rfnum]
			    then pol = {regroup(rf,} branch_std(1*mu, D){)}
			    then m = K_type_pol_hashes[rfnum].match(pol)
			    then () = tempbranches[ktypenum]:=m
			    then () = tempbranchhts[ktypenum] :=  D
			    then () = branch_heights[rfnum] := tempbranchhts
			    then () = branches[rfnum] := tempbranches
			    in()
			fi {branch_heights[rfnum][ktypenum] < D}
		    fi {ktypenum = KTYPENUM}
	in (rfnum, ktypenum, branches[rfnum][ktypenum])

    then add_K_type_my_branch(KType mu, int D) = (int, int, int):
	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu :=  K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
		   {now mu is attached to rf}
		   {first_K_type(regroup(rf,1*mu))}
	 then () = assert(@:D>=height(mu),"branch to D below height(mu)")
	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then (,ktypenum) = add_K_type(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
		   then let start = elapsed_ms()
			then ans = null_K_module(rf)
			then undone = 1*mu {guaranteed on rf}
			then () = while undone.!=
			     do let (c,tau) = first_term(undone)
				then corr = if my_formula_flag
					    then let (,,t) = add_K_type_formula_to_ht(tau,D)
						 in c*to_ht(K_type_pol_hashes[rfnum].list()[t],D)
						 {c*regroup(rf, to_ht(K_type_pol_hashes[rfnum].list()[t],D))}
					    else c*{regroup(rf,} K_type_formula(tau,D){)}
					    fi
				{then (,,t) = add_K_type_formula_to_ht(tau,D)}
				then () = undone-:= corr {c*regroup(rf, to_ht(K_type_pol_hashes[rfnum].list()[t],D))}
				in ans+:=c*tau
			     od
			then m = K_type_pol_hashes[rfnum].match(ans)
			then () = branch_script_time +:= elapsed_ms() - start
			then tempbranchhts = branch_heights[rfnum]
			then tempbranches = branches[rfnum]
			then () = tempbranches[ktypenum] := m
			then () = tempbranchhts[ktypenum] := D
			then () = branch_heights[rfnum] := tempbranchhts
			then () = branches[rfnum] := tempbranches
			then () = assert(@:real_form_hash.size() = #K_type_pol_hashes,"big_unitary_hash damaged")
			then () = assert(@:real_form_hash.size() = #K_type_hashes,"big_unitary_hash damaged")
			then () = assert(@:#branches[rfnum] = K_type_hashes[rfnum].size(), "big_unitary_hash damaged")
			in ()
		   else {we've seen mu before}
		       let Dold = branch_heights[rfnum][ktypenum]
		       then () = if Dold < D
			       then let ans = to_ht(K_type_pol_hashes[rfnum].list()[branches[rfnum][ktypenum]],Dold)
				    then undone = mu - sum(rf, for c@tau in ans
					     do let (,,Kft) = add_K_type_formula_to_ht(tau,D)
						in c*{regroup(rf,} to_ht(K_type_pol_hashes[rfnum].list()[Kft],D){)}
					     od)
				    then () = while undone.!=
					      do let (c,tau) = first_term(undone)
						 then corr = if my_formula_flag
							     then let (,,t) = add_K_type_formula_to_ht(tau,D)
								  in c*{regroup(rf,} to_ht(K_type_pol_hashes[rfnum].list()[t],D){)}
							     else c*regroup(rf, K_type_formula(tau,D))
							     fi
						 {then (,,t) = add_K_type_formula_to_ht(tau,D)}
						 then () = undone-:= corr {c*regroup(rf,
						      to_ht(K_type_pol_hashes[rfnum].list()[t],D))}
						 in ans+:=c*tau
					      od
			       then m = K_type_pol_hashes[rfnum].match(ans)
			       then tempbranches = branches[rfnum]
			       then tempbranchhts = branch_heights[rfnum]
			       then () = tempbranches[ktypenum]:=m
			       then () = tempbranchhts[ktypenum]:=  D
			       then () = branch_heights[rfnum] := tempbranchhts
			       then () = branches[rfnum] := tempbranches
			       in()
			       fi {Dold < D}
			in ()
		     fi {ktypenum = KTYPENUM}
	in (rfnum, ktypenum, branches[rfnum][ktypenum])

    then add_param_inf(Param p) = (int, int, int): {add a param, full herm form}
	let  rfnum = add_real_form(p.real_form)
	then PNUM = phashes[rfnum].size(), rf = real_form_hash.index(rfnum)
	{then () = p := regroup(rf, herm_center(p))}
	then list = global_vertices(rf, p.infinitesimal_character)
	{then phc = herm_center(p)}
	then () = p:=parameter(rf, p.x.number, p.lambda, sum(#list[0],list)/#list)
	then pnum = phashes[rfnum].match(p)
	then () = if pnum = PNUM {haven't computed with p before}
		  then let sig = if uhashes[rfnum].lookup(p).>=
				 then K_type_pol(character_formula(p))
				 else hermitian_form_irreducible(p) {insert computation from good?}
				 fi
		       then sig_ind = K_type_pol_hashes[rfnum].match(sig)
		       then () = sigs[rfnum] #:= sig_ind
		       then () = sig_heights[rfnum] #:= {height(p)} - 1
		       then N = nuhashes[rfnum].size()
		       then H = impure_height(sig)
		       then () = if H = - 1
				 then uhashes[rfnum].match(p)
				 else let n = nuhashes[rfnum].match(p)
				      in if n=N
					 then nu_heights[rfnum] #:=H
					 elif nu_heights[rfnum][n] > H
					 then let nuheightsrf = nu_heights[rfnum]
					      in nuheightsrf[n] :=H;
						 nu_heights[rfnum]:= nuheightsrf
					fi {n=N}
				 fi {H = -1}
		       then () = assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged")
		       then () = assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged")
		       then () = assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
		       then () = assert(@:#sig_heights[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
		       then () = assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(), "big_unitary_hash damaged")
		       in ()
		  else {we've seen p before}
		       if sig_heights[rfnum][pnum] >= height(p)
		       then let tempsigs = sigs[rfnum], tempsights = sig_heights[rfnum]
			    then sigD = if uhashes[rfnum].lookup(p).>=
					then K_type_pol(character_formula(p))
					else hermitian_form_irreducible(p)
					fi
			    then N = nuhashes[rfnum].size()
			    then H = impure_height(sigD)
			    then () = if H = -1
				      then uhashes[rfnum].match(p)
				      else let n = nuhashes[rfnum].match(p)
					   in if n=N
					      then nu_heights[rfnum] #:= H
					      elif nu_heights[rfnum][n] > H
					      then let nuheightsrf = nu_heights[rfnum]
						   in nuheightsrf[n] :=H;
						      nu_heights[rfnum]:= nuheightsrf
					      fi {n=N}
				      fi {H = -1}
			    then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			    then () = tempsigs[pnum] := sigD_ind
			    then () = tempsights[pnum]:= {height(p)} - 1
			    then () = sigs[rfnum] := tempsigs
			    then () = sig_heights[rfnum] := tempsights
			    in()
		       fi {sigheights >= height(p)}
		  fi {pnum = PNUM}
	 in (rfnum, pnum, sigs[rfnum][pnum])
   then add_param(Param p, int D) = (int, int, int): {add a param, form to ht D; assume D >= ht(p)}
	let  rfnum = add_real_form(p.real_form)
	then rf = real_form_hash.index(rfnum)
	then PNUM = phashes[rfnum].size()
	{then () = p:=regroup(rf,herm_center(p))}
	then list = global_vertices(rf, p.infinitesimal_character)
	{then phc = herm_center(p)}
	then () = p:=parameter(rf, p.x.number, p.lambda, sum(#list[0],list)/#list)
	then pnum = phashes[rfnum].match(p)
	then () = if pnum = PNUM {haven't computed with p before}
		  then let sigD = if uhashes[rfnum].lookup(p).>=
				  then let ans = K_type_pol(character_formula(p))
				       then () = D:={height(p)}-1
				       in ans
				  elif strict_low(p,D) {added strict 12/13/25}
     	  			  then let ans =  hermitian_form_irreducible_to_ht(p,D)
				       then N = nuhashes[rfnum].size()
				       then H = impure_height(ans)
				       then () = if H = -1 {is_pure(ans)}
						 then ()
						 else let n = nuhashes[rfnum].match(p)
						      in if n=N
							 then nu_heights[rfnum]#:=H
							 elif nu_heights[rfnum][n] > H
							 then let nuheightsrf = nu_heights[rfnum]
							      in nuheightsrf[n] :=H;
								 nu_heights[rfnum]:= nuheightsrf
							 fi {n=N}
						 fi {H = -1}
				       in ans
				  else let ans = hermitian_form_irreducible(p)
				       then () = D:={height(p)} -1
				       then N = nuhashes[rfnum].size()
				       then H = impure_height(ans)
				       then () = if H = -1
						 then uhashes[rfnum].match(p)
						 else let n = nuhashes[rfnum].match(p)
						      in if n=N
							 then nu_heights[rfnum]#:=H
							 elif nu_heights[rfnum][n] > H
							 then let nuheightsrf = nu_heights[rfnum]
							      in nuheightsrf[n] :=H;
								 nu_heights[rfnum]:= nuheightsrf
							 fi {n=N}
						 fi {H = -1}
				       in ans {this records full sig!}
				   fi {uhashes[rfnum].lookup(p).>=}
		       then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
		       then () = sigs[rfnum] #:= sigD_ind
		       then () = sig_heights[rfnum] #:= D
		       then () = assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged")
		       then () = assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged")
		       then () = assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
		       then () = assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(),
				 "big_unitary_hash nu_heights damaged")
		       in ()
		   else {we've seen p before}
		       if sig_heights[rfnum][pnum] >= height(p) and sig_heights[rfnum][pnum] < D
		       then let tempsigs = sigs[rfnum], tempsights = sig_heights[rfnum]
			    {then start_sig = elapsed_ms()}
			    then sigD = if uhashes[rfnum].lookup(p).>=
					then let ans = K_type_pol(character_formula(p))
					     then () = D:={height(p)}-1
					     in ans
					elif strict_low(p,D) {strict 12/13/25}{low(p.x,p.lambda,N)}
					then let ans = hermitian_form_irreducible_to_ht(p,D)
					     then N = nuhashes[rfnum].size()
					     then H = impure_height(ans)
					     then () = if H = -1
						       then ()
						       else let n = nuhashes[rfnum].match(p)
							    in if n=N
							       then nu_heights[rfnum]#:=H
							       elif nu_heights[rfnum][n] > H
							       then let nuheightsrf = nu_heights[rfnum]
							       in nuheightsrf[n] :=H;
								    nu_heights[rfnum]:= nuheightsrf
							       fi {n=N}
						       fi {H = -1}
					     in ans
					else let ans = hermitian_form_irreducible(p)
					     then N = nuhashes[rfnum].size()
					     then H = impure_height(ans)
					     then () = D:={height(p)}-1
					     then () = if H = -1
						       then uhashes[rfnum].match(p)
						       else let n = nuhashes[rfnum].match(p)
							    in if n=N
							       then nu_heights[rfnum]#:=H
							       elif nu_heights[rfnum][n] > H
							       then let nuheightsrf = nu_heights[rfnum]
							       in nuheightsrf[n] :=H;
								    nu_heights[rfnum]:= nuheightsrf
							       fi {n=N}
						       fi {H=-1}
					     in ans
					fi
			    then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			    then () = tempsigs[pnum] := sigD_ind
			    then () = tempsights[pnum]:=D
			    then () = sigs[rfnum] := tempsigs
			    then () = sig_heights[rfnum] := tempsights
			    then () = assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged")
			    then () = assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged")
			    then () = assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
			    then () = assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(),
				 "big_unitary_hash nu_heights damaged B")
			    in()

		       fi
		   fi
	 in (rfnum, pnum, sigs[rfnum][pnum])
    then add_param_inf_interrupt(Param p, int time) = (int, int, int,bool): {add a param, full herm form;
    	 			       	  false if not finished}
	let  rfnum = add_real_form(p.real_form)
	then PNUM = phashes[rfnum].size(), rf = real_form_hash.index(rfnum)
	{then () = p := regroup(rf, herm_center(p))}
	then list = global_vertices(rf, p.infinitesimal_character)
	{then phc = herm_center(p)}
	then () = p:=parameter(rf, p.x.number, p.lambda, sum(#list[0],list)/#list)
	then pnum = phashes[rfnum].lookup(p) {MATCH WAS WRONG!}
	then () = if pnum = -1 {haven't computed with p before}
		  then let m_sig = if uhashes[rfnum].lookup(p).>=
				 then K_type_pol(character_formula(p)).done
				 else hermitian_form_irreducible(p,time) {insert computation from good?}
				 fi
		       then sig = case m_sig
		       	       	  | timed_out: return (-1,-1,-1,false); 0*K_type_pol(p)
				  | done (sig): sig
				  esac
		       then () = pnum:= phashes[rfnum].match(p) {must be PNUM}
		       then sig_ind = K_type_pol_hashes[rfnum].match(sig)
		       then () = sigs[rfnum] #:= sig_ind
		       then () = sig_heights[rfnum] #:= {height(p)} - 1
		       then N = nuhashes[rfnum].size()
		       then H = impure_height(sig)
		       then () = if H = - 1
				 then uhashes[rfnum].match(p)
				 else let n = nuhashes[rfnum].match(p)
				      in if n=N
					 then nu_heights[rfnum] #:=H
					 elif nu_heights[rfnum][n] > H
					 then let nuheightsrf = nu_heights[rfnum]
					      in nuheightsrf[n] :=H;
						 nu_heights[rfnum]:= nuheightsrf
					fi {n=N}
				 fi {H = -1}
		       then () = assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged")
		       then () = assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged")
		       then () = assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
		       then () = assert(@:#sig_heights[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
		       then () = assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(), "big_unitary_hash damaged")
		       in ()
		  else {we've seen p before}
		       if sig_heights[rfnum][pnum] >= height(p)
		       then let tempsigs = sigs[rfnum], tempsights = sig_heights[rfnum]
			    then m_sigD = if uhashes[rfnum].lookup(p).>=
					then K_type_pol(character_formula(p)).done
					else hermitian_form_irreducible(p,time)
					fi
			    then sigD = case m_sigD
			    	      	| timed_out: return (-1,-1,-1,false); 0*K_type_pol(p)
					| done(sigD): sigD
					esac
			    then N = nuhashes[rfnum].size()
			    then H = impure_height(sigD)
			    then () = if H = -1
				      then uhashes[rfnum].match(p)
				      else let n = nuhashes[rfnum].match(p)
					   in if n=N
					      then nu_heights[rfnum] #:= H
					      elif nu_heights[rfnum][n] > H
					      then let nuheightsrf = nu_heights[rfnum]
						   in nuheightsrf[n] :=H;
						      nu_heights[rfnum]:= nuheightsrf
					      fi {n=N}
				      fi {H = -1}
			    then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			    then () = tempsigs[pnum] := sigD_ind
			    then () = tempsights[pnum]:= {height(p)} - 1
			    then () = sigs[rfnum] := tempsigs
			    then () = sig_heights[rfnum] := tempsights
			    in()
		       fi {sigheights >= height(p)}
		  fi {pnum = PNUM}
	 in (rfnum, pnum, sigs[rfnum][pnum],true)
    then add_param_interrupt(Param p, int D, int time) = (int, int, int,bool): {add a param, form to ht D;
    	 			      	  assume D >= ht(p); false if not finished}
	let  rfnum = add_real_form(p.real_form)
	then rf = real_form_hash.index(rfnum)
	then PNUM = phashes[rfnum].size()
	{then () = p:=regroup(rf,herm_center(p))}
	then list = global_vertices(rf, p.infinitesimal_character)
	{then phc = herm_center(p)}
	then () = p:=parameter(rf, p.x.number, p.lambda, sum(#list[0],list)/#list)
	then pnum = phashes[rfnum].lookup(p)
	then () = if pnum = -1 {haven't computed with p before}
		  then let m_sigD = if uhashes[rfnum].lookup(p).>=
				  then D:= -1;
				       K_type_pol(character_formula(p)).done
				  elif strict_low(p,D) {added strict 12/13/25}
     	  			  then hermitian_form_irreducible_to_ht_MvL(p,D,time)
				  else D:= -1;
				       hermitian_form_irreducible(p,time)
				  fi
		        then sigD = case m_sigD
		       	       	    | timed_out: return (-1,-1,-1,false); 0*K_type_pol(p)
				    | done (sigD): sigD
				    esac
			then () = pnum := phashes[rfnum].match(p) {must be PNUM}
			then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			then N = nuhashes[rfnum].size()
			then H = impure_height(sigD)
			in if H = -1 {is_pure(ans)}
			   then ()
			   else let n = nuhashes[rfnum].match(p)
				in if n=N
				   then nu_heights[rfnum]#:=H
				   elif nu_heights[rfnum][n] > H
				   then let nuheightsrf = nu_heights[rfnum]
					in nuheightsrf[n] :=H;
					   nu_heights[rfnum]:= nuheightsrf
				   fi {n=N}
			   fi; {H = -1}
			   sigs[rfnum] #:= sigD_ind;
		       	   sig_heights[rfnum] #:= D;
		       	   assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged");
		       	   assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged");
		       	   assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged");
		       	   assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(),
				 "big_unitary_hash nu_heights damaged")
		   else {we've seen p before}
		       if sig_heights[rfnum][pnum] >= height(p) and sig_heights[rfnum][pnum] < D
		       then let tempsigs = sigs[rfnum], tempsights = sig_heights[rfnum]
			    {then start_sig = elapsed_ms()}
			    then m_sigD = if uhashes[rfnum].lookup(p).>=
					  then D:= -1;
					       K_type_pol(character_formula(p)).done
					  elif strict_low(p,D) {strict 12/13/25}{low(p.x,p.lambda,N)}
					  then hermitian_form_irreducible_to_ht_MvL(p,D,time)
					  else D:=-1;
					     hermitian_form_irreducible(p,time)
					fi
		             then sigD = case m_sigD
		       	       	       	 | timed_out: return (-1,-1,-1,false); 0*K_type_pol(p)
				    	 | done (sigD): sigD
				    	 esac
			     then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			     then N = nuhashes[rfnum].size()
			     then H = impure_height(sigD)
			     in if H = -1
				then ()
				else let n = nuhashes[rfnum].match(p)
				       in if n=N
				       	  then nu_heights[rfnum]#:=H
				       	  elif nu_heights[rfnum][n] > H
				       	  then let nuheightsrf = nu_heights[rfnum]
					       in nuheightsrf[n] :=H;
					       	  nu_heights[rfnum]:= nuheightsrf
				       	  fi {n=N}
				 fi {H = -1};
			    	  tempsigs[pnum] := sigD_ind;
			    	  {prints("#tempsigs = ",#tempsigs);}
			    	  tempsights[pnum]:=D;
			    	  sigs[rfnum] := tempsigs;
			    	  sig_heights[rfnum] := tempsights;
			    	  assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged");
			    	  assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged");
			    	  assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged");
			    	  assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(),
				 "big_unitary_hash nu_heights damaged B")
		       fi {sig_heights[rfnum][pnum] >= height(p) and sig_heights[rfnum][pnum] < D}
		   fi {pnum = PNUM}
	 in (rfnum, pnum, sigs[rfnum][pnum],true)

    then clearG(RealForm rf) =
	 let i = real_form_hash.lookup(rf)
	 in if i >= 0
	    then {prints(i);}
		 uhashes[i].clear();
		 nuhashes[i].clear();
		 phashes[i].clear();
		 {status_strings[i]:=[];}
		 K_type_hashes[i].clear();
		 K_type_pol_hashes[i].clear();
		 formulas[i]:=[];
		 formula_heights[i]:=[];
		 branches[i] := [];
		 sigs[i] := [];
		 branch_heights[i] := [];
		 sig_heights[i] := [];
		 nu_heights[i] := [];
		 {prints("i = ",i, ", x_partial = ",x_partial);}
		 x_partial[i] := 0;
		 xl_known[i] := nullint(#KGB(rf));
		 x_known[i] := 0
	    fi
    in
    ( (->int): {real_form_size} @int: real_form_hash.size()
    , ( -> vec): {uhash_sizes} @vec: for uhash in uhashes
				     do uhash.size()
				     od
    , (RealForm -> int): {uhash_size} (RealForm rf) int:
     let rfnum = add_real_form(rf)
     in uhashes[rfnum].size()
    , ( -> vec): {nuhash_sizes} @vec: for nuhash in nuhashes
				      do nuhash.size()
				      od
    , (RealForm -> int): {nuhash_size} (RealForm rf) int:
     let rfnum = add_real_form(rf)
     in uhashes[rfnum].size()
    , ( -> vec): {K_type_size} @vec: for hash in K_type_hashes do hash.size() od
    , ( -> vec): {K_type_pol_size} @vec: for hash in K_type_pol_hashes do hash.size() od
    , (KType -> KTypePol): {K_type_formula} (KType mu) KTypePol:
    begin
     if not my_formula_flag then return K_type_formula(mu) fi;
     let (rfnum,,m) = add_K_type_formula(mu)
     in regroup(mu.real_form, K_type_pol_hashes[rfnum].index(m))
    end
    , (KTypePol -> KTypePol): {mult_K_type_formula} (KTypePol pol) KTypePol:
    begin
     if pol.= then return pol fi;
     let rfnum = add_real_form(pol.real_form)
     then terms = [(Split,int)]:
     	  for c@tau in pol
     	  do let (,,m) = add_K_type_formula(tau)
	     in (c,m)
	  od
     in sum(pol.real_form, for (c,m) in terms do c*K_type_pol_hashes[rfnum].index(m) od)
    end
    , ((KType,int) -> KTypePol): {K_type_formula_to_ht} (KType mu, int D) KTypePol:
    begin
      if not my_formula_flag then return K_type_formula(mu,D) fi;
      let (rfnum,,m) = add_K_type_formula_to_ht(mu,D)
      in regroup(mu.real_form, to_ht(K_type_pol_hashes[rfnum].index(m), D))
    end
    , ((KType, int) -> KTypePol): {branch_entry} (KType mu, int D) KTypePol:
     begin
	let (rf, ktypenum,m) = if my_branch_flag
			       then add_K_type_my_branch(mu,D)
			       else add_K_type_branch(mu,D)
			       fi
	in regroup(mu.real_form, to_ht(K_type_pol_hashes[rf].index(m), D))
     end

    , ((KTypePol, int) -> KTypePol): {branch} (KTypePol pol, int D) KTypePol:
      let G = pol.real_form
      then rfnum = add_real_form(G)
      then rf = real_form_hash.index(rfnum)
      then () = pol := regroup(rf,pol)
      then terms = [(Split, KType)]: for c@mu in to_ht(pol,D)
				    do (c,mu)
				    od
      in regroup(G, to_ht(sum(rf, for (c,mu) in terms
				   do let (,,m) = if my_branch_flag
						    then add_K_type_my_branch(mu,D)
						    else add_K_type_branch(mu,D)
						    fi
				      in c*K_type_pol_hashes[rfnum].index(m)
				   od) , D))
      {for the next one assume my_branch; there is a built in interruptible}
    , ((KTypePol, int, int) -> maybe_KTP): {branch_interrupt} (KTypePol pol, int D, int time) maybe_KTP:
      let G = pol.real_form
      then rfnum = add_real_form(G), start_time = elapsed_ms()
      then rf = real_form_hash.index(rfnum)
      then () = pol := regroup(rf,pol)
      then terms = [(Split, KType)]: for c@mu in to_ht(pol,D)
				    do (c,mu)
				    od
      then ans = null_K_module(rf)
      then () = for (c,mu) in terms
		do if elapsed_ms() - start_time >= time then return timed_out() fi;
		   let (,,m) = add_K_type_my_branch(mu,D)
		   in ans +:= c*K_type_pol_hashes[rfnum].index(m)
		od
      in done(regroup(G, to_ht(ans, D)))
    , (KTypePol -> int): {KTypePol_lookup} (KTypePol pol) int:
      let G = pol.real_form
      then rfnum = add_real_form(G)
      then rf = real_form_hash.index(rfnum)
      in pol := regroup(rf,pol);
      	 K_type_pol_hashes[rfnum].lookup(pol)
    , (KTypePol -> int): {KTypePol_match} (KTypePol pol) int:
      let G = pol.real_form
      then rfnum = add_real_form(G)
      then rf = real_form_hash.index(rfnum)
      in pol := regroup(rf,pol);
      	 K_type_pol_hashes[rfnum].match(pol)
    , ((RealForm, int) -> KTypePol): {KTypePol_index} (RealForm G, int pol_index): KTypePol:
      let  rfnum = add_real_form(G)
      then rf = real_form_hash.index(rfnum)
      in  K_type_pol_hashes[rfnum].index(pol_index)
    , ((Param,int) -> KTypePol): {sig_entry} (Param p, int D) KTypePol:
     begin
	let (rfnum,pnum,sig_ind) = if D < height(p)
				then add_param_inf(p)
				else add_param(p,D)
				fi
	then G = p.real_form, rf = real_form_hash.index(rfnum)
	in if D < height(p)
	   then regroup(G, K_type_pol_hashes[rfnum].index(sig_ind))
	   else regroup(G, to_ht(K_type_pol_hashes[rfnum].index(sig_ind), D))
	   fi
     end
    , ((Param,int,int) -> maybe_KTP): {sig_entry_interrupt} (Param p, int HT, int time): maybe_KTP:
     begin
	let (rfnum,pnum,sig_ind, finished) = if HT < height(p)
				   then add_param_inf_interrupt(p,time)
				   else add_param_interrupt(p,HT,time)
				   fi
	in if finished
	   then let G = p.real_form, rf = real_form_hash.index(rfnum)
	   	in if HT < height(p)
	   	   then regroup(G, K_type_pol_hashes[rfnum].index(sig_ind)).done
	   	   else regroup(G, to_ht(K_type_pol_hashes[rfnum].index(sig_ind), HT)).done
		   fi
	   else timed_out()
	   fi
     end
    , (int, int -> int): {branch_height} (int rfnum, int ktypenum): branch_heights[rfnum][ktypenum]
    , (int, int -> int): {sig_height} (int rfnum, int pnum): sig_heights[rfnum][pnum]
    , ( -> ): {clear} clearBUH
    , (RealForm -> ): {clearG} (RealForm rf):
      clearG(rf)
    , (RealForm -> int): {rf_number} (RealForm rf) int:
      add_real_form(rf)
    , (int -> RealForm): {rf_index} (int i) RealForm:
      real_form_hash.index(i)
    , (RealForm -> [int]): {xl_known} (RealForm rf) [int]:
      let i = add_real_form(rf)
      in xl_known[i]
    , (RealForm -> int): {x_known} (RealForm rf) int:
      let i = add_real_form(rf)
      in x_known[i]
    , (RealForm -> int): {x_partial} (RealForm rf) int:
      let i = add_real_form(rf)
      in x_partial[i]
    , ((KGBElt,int) -> ): {finish} (KGBElt x, int M):
      let start = elapsed_ms()
      then i = add_real_form(x.real_form)
      then xl_knowni = [int]: xl_known[i]
      then () = xl_knowni[x.number] OR:= M
      then () = xl_known[i] := xl_knowni
      {then () = x_partial[i] := OR(to_bitset([x.number]),x_partial[i])
      then () = if xl_known[i][x.number] + 1 = to_bitset([#FPP_lambdas(x)])
		then x_known[i] := OR(to_bitset([x.number]),x_known[i])
		fi}
      then () = finish_time+:= elapsed_ms() - start
      in ()
    , ((RealForm, int,int) -> ): {finish_num} (RealForm G, int x_num, int M):
      let start = elapsed_ms()
      then i = add_real_form(G)
      then xl_knowni = [int]: xl_known[i]
      then () = xl_knowni[x_num] OR:= M
      then () = xl_known[i] := xl_knowni
      {then () = x_partial[i] := OR(to_bitset([x.number]),x_partial[i])
      then () = if xl_known[i][x.number] + 1 = to_bitset([#FPP_lambdas(x)])
		then x_known[i] := OR(to_bitset([x.number]),x_known[i])
		fi}
      then () = finish_time+:= elapsed_ms() - start
      in ()
    , (KGBElt -> ): {finishx} (KGBElt x):
      let i = add_real_form(x.real_form)
      then M = to_bitset([x.number])
      then () = x_known[i] OR:= M
      then () = x_partial[i] OR:= M
      in ()
    , ((RealForm,int) -> ): {finishx_num} (RealForm G,int x_num):
      let i = add_real_form(G)
      then M = to_bitset([x_num])
      then () = x_known[i] OR:= M
      then () = x_partial[i] OR:= M
      in ()
    , ((RealForm,int) ->): {finishxmap} (RealForm G, int M):
      let i = add_real_form(G)
      then () = x_known[i] := OR(M,x_known[i])
      in ()
    , (KGBElt -> ): {partialx}  (KGBElt x):
      let i = add_real_form(x.real_form)
      then M = to_bitset([x.number])
      then () = x_partial[i] := OR(M,x_partial[i])
      in ()
    , ((RealForm,int) -> ): {partialx_num}  (RealForm G, int x_num):
      let i = add_real_form(G)
      then M = to_bitset([x_num])
      then () = x_partial[i] OR:= M
      in ()
    , ((RealForm,[int]) -> ): {finishall} (RealForm rf, [int] Ms):
      let start = elapsed_ms()
      then i = add_real_form(rf)
      then xl_knowni = [int]: xl_known[i]
      then () = for n:#KGB(rf)
		do xl_knowni[n] := OR(Ms[n],xl_knowni[n])
		od
      then () = xl_known[i] := xl_knowni
      then v = vec: for M@j in Ms do if M.= then [] else [j] fi od.##
      then () = x_partial[i] := OR(x_partial[i], to_bitset(v))
      in finish_time+:= elapsed_ms() - start
    , (RealForm -> Param_hash): {phash} (RealForm rf) Param_hash:
      phashes[add_real_form(rf)]
    , (RealForm -> Param_hash): {uhash} (RealForm rf) Param_hash:
      uhashes[add_real_form(rf)]
    , (RealForm -> Param_hash): {nuhash} (RealForm rf) Param_hash:
      nuhashes[add_real_form(rf)]
    , (RealForm -> vec): {nu_heights} (RealForm rf) vec:
      nu_heights[add_real_form(rf)]
    , (Param -> (int,int)): {long_plookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      then j = phashes[i].lookup(p)
      in (i,j)
    , (Param -> (int,int)): {long_ulookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      then j = uhashes[i].lookup(p)
      in (i,j)
    , (Param -> int): {plookup} (Param p) int:
       phashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> int): {ulookup} (Param p) int:
       uhashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> int): {nulookup} (Param p) int:
       nuhashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> int): {nu_height_lookup} (Param p) int:
      let i = add_real_form(p.real_form)
      then j = nuhashes[i].lookup(p)
      in if j = -1
	 then -1
	 else nu_heights[i][j]
	 fi
      {next is what is_unitary_to_ht(p,H) returns, or true if we don't know}
    , ((Param,int) -> bool): {nu_height_lookup_bool} (Param p, int H) bool:
      let i = add_real_form(p.real_form)
      then j = nuhashes[i].lookup(p)
      in if j.< then true {henceforth p is in nuhash}
      	 elif  H < 0 then false {henceforth H >= 0}
	 elif H <= height(p) then true
	 else let H0 = nu_heights[i][j]
	      in if H0 < 0
	      	 then true
		 else H < H0
		 fi
	 fi
    , (Param -> bool): {check} (Param p) bool:
      let (i,,sigD) = add_param_inf(p)
      in is_pure(K_type_pol_hashes[i].list()[sigD])
    , ((Param,int) -> bool): {check_to_ht} (Param p, int N) bool:
      let (i,,sigD) = add_param(p,N)
      in is_pure(to_ht(K_type_pol_hashes[i].list()[sigD], N))
    , ((Param,int) -> int): {check_interrupt} (Param p, int time) int:
      let (i,,sig,boo) = add_param_inf_interrupt(p,time)
      in if boo
      	 then let booHoo = is_pure(K_type_pol_hashes[i].list()[sig])
	      in if booHoo then 1 else -1 fi
	 else 0
	 fi
    , ((Param,int,int) -> int): {check_to_ht_interrupt} (Param p, int HT, int time) int:
      let (i,,sigHT,boo) = add_param_interrupt(p,HT,time)
      in if boo
      	 then let booHoo = is_pure(to_ht(K_type_pol_hashes[i].list()[sigHT], HT))
	      in if booHoo then 1 else -1 fi
	 else 0
	 fi
{
      let i = add_real_form(p.real_form)
      {then () = prints("bitmap for ",p.x.number," is ",xl_known[i][p.x.number])}
      then () = p := herm_center(p)
      then j = add_param_inf(p)
      then ju = uhashes[i].lookup(p)
      in if ju.>= then true
	 else let jn = nuhashes[i].lookup(p)
	      in if jn.>= then false
		 elif {now p was not found in either} is_member_bitset(p.x.number, x_known[i])
		 then nuhashes[i].match(p); false
		 elif {now x not completely known} position(p.x, p.lambda).>=
		      and is_member_bitset(position(p.x, p.lambda), xl_known[i][p.x.number])	 then false
		 else let sig = add_param
		 chk = is_unitary(p)
		      then () = if chk
				then uhashes[i].match(p)
				else if nuhash_flag
				     then nuhashes[i].match(p)
				     fi
				fi
		      in chk
		 fi
	 fi
}
    , (Param -> int): {umatch} (Param p):
      let i = add_real_form(p.real_form)
      in uhashes[i].match(p)
    , ((Param,int) -> int): {numatch_height} (Param p, int H):
      let i = add_real_form(p.real_form)
      then N = nuhashes[i].size()
      in if nuhash_flag
	 then let n = nuhashes[i].match(p)
	 in if n=N
	    then nu_heights[i] #:= H; n
	    else if H >= 0 {if H<0, we're adding no info, so do nothing}
	    	 then let Hold = nu_heights[i][n]
		      in if Hold > H or Hold < 0
		      	 then let nuhtsi = nu_heights[i]
		      	      in nuhtsi[n]:=H;
			      	 nu_heights[i]:=nuhtsi
		 	 fi
		  fi; n
	    fi {n=N}
	 else -1
	 fi
    , (Param -> int): {numatch} (Param p):
      let i = add_real_form(p.real_form)
      then N = nuhashes[i].size()
      in if nuhash_flag
	 then let n = nuhashes[i].match(p)
	 in if n=N
	    then nu_heights[i]#:= -1; n
	    else n
	    fi
	 else -1
	 fi
    , ((Param,int) -> int): {long_umatch} (Param p, int i):
      uhashes[i].match(p)
    , ((Param,int) -> int): {long_match} (Param p, int i):
      uhashes[i].match(p)
    , ( -> ): {write} @void:
    let rf_list = real_form_hash.list()
    in for rf@i in rf_list
       do let Gname = "G"+to_string(i)
	  then listname = Gname+"_list"
	  {then intlistname = Gname+"_XLK"}
	  then plist = uhashes[i].list()
	  {then bitmapintlist = xl_known[i]}
	  then donemap = x_known[i]
	  then done_list = [int]:[]
	  then () = if write_x_flag then done_list :=
		for x in KGB(rf)
		       do if is_member_bitset(x.number, donemap)
			  then [x.number]
			  else []
			  fi
		       od.##
		 fi
	  in write_real_form(rf,Gname);
	     prints("set j = big_unitary_hash.rf_number(",Gname,")");
	     for p in plist
	     do let xnum = p.x.number
		in prints("void: big_unitary_hash.long_match(parameter(",Gname,",",xnum,",",p.lambda,",",p.nu,"),j)")
	     od;
	     if write_x_flag
	     then for xnum in done_list
		  do prints("void: big_unitary_hash.finishx_num(",Gname,",",xnum,")")
		  od
	     else prints("void: big_unitary_hash.finishxmap(",Gname,",",donemap,")")
	     fi
	     {prints("set ",intlistname,"=[int]:[]");
	     write_append(bitmapintlist,intlistname);
	     prints("big_unitary_hash.finishall(",Gname,",",intlistname,")")}
	od
    , (RealForm -> ): {writeG} (RealForm G):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      {then intlistname = Gname+"_XLK"}
      then plist = uhashes[i].list()
      {then bitmapintlist = xl_known[i]}
      then donemap = x_known[i]
      then done_list = [int]:[]
      then () = if write_x_flag then done_list := set_bit_positions(donemap)
		fi
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do let xnum = p.x.number
	    in prints("void:  big_unitary_hash.long_match(parameter(",Gname,",",xnum,",",p.lambda,",",p.nu,"),j)")
	 od;
	 {prints("void: big_unitary_hash.finishall(",Gname,",",xl_known[i],")");} {this has length #KGB(G), which is a lot; not worth including}
	 if write_x_flag
	 then for xnum in done_list
	      do prints("void: big_unitary_hash.finishx_num(",Gname,xnum,")")
	      od
	 else prints("void: big_unitary_hash.finishxmap(G_temp,",donemap,")")
	 fi;
	 if write_x_lambda_flag
	 then for N@j in xl_known[i]
	      do if N.!=
	      	 then prints("void: big_unitary_hash.finish(KGB(G_temp,j),N")
		 fi
	      od
	 fi

    , (RealForm -> ): {writeG_nu} (RealForm G):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_nu_list"
      then nu_list = nuhashes[i].list()
      then nu_hts = nu_heights[i]
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p@j in nu_list
	 do let xnum = p.x.number
	    in prints("void:  big_unitary_hash.numatch_height(parameter(",Gname,",",xnum,",",p.lambda,",",p.nu,"),"
	       ,nu_hts[j],")")
	 od
{NOTE: next function records whether a given x is finished, but NOT whether
some lambdas for that x might be finished.}
    , ((RealForm, int, int) -> ): {writeGrange} (RealForm G, int low, int high):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list_"+to_string(low)+"_"+to_string(high)
      {then intlistname = Gname+"_XLK_"+to_string(low)+"_"+to_string(high)}
      then longlist = uhashes[i].list()
      then plist = for p in longlist
		   do if p.x.number >= low and p.x.number < high
		      then [p]
		      else []
		      fi
		   od.##
      then donemap = x_known[i] {bitmap of completed x for real form #i}
      then donerangemap = AND(donemap, 2^high - 2^low)
      then done_list = set_bit_positions(donerangemap)
	   {these are the x's being written for which list is complete}
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")"); {, ptemp = GL(1,R).trivial");}
	 for p in plist
	 do let xnum = p.x.number
	    in prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",p.lambda,",",p.nu,"),j)")
	 od;
	 if write_x_flag
	 then for xnum in done_list
	      do prints("void: big_unitary_hash.finishx_num(",Gname,",",xnum,")")
	      od
	 else prints("void: big_unitary_hash.finishxmap(",Gname,",",donerangemap,")")
	 fi
    , ((KGBElt,ratvec) -> ): {writexlam} (KGBElt x, ratvec lambda):
      let G = x.real_form
      then xnum = x.number
      then i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then longlist = uhashes[i].list()
      then plist = for p in longlist
		   do if p.x = x and p.lambda = lambda
		      then [p]
		      else []
		      fi
		   od.##
      then N = to_bitset([position(x,lambda)])
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",lambda,",",p.nu,"),j)")
	 od;
	 if is_member_bitset(position(x,lambda), xl_known[i][xnum])
	 then prints("big_unitary_hash.finish_num(",Gname,",",xnum,",",to_string(N),")")
	 fi {this adds the location of lambda to the bitset of known lambdas at x}
    , (([KGBElt,ratvec]) -> ): {writexlams} ([(KGBElt,ratvec)] xls):
      if #xls = 0 then return () fi;
      let (x0,lambda0) = xls[0]
      then G = x0.real_form
      then i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then xlhash = make_xlambda_hash()
      then () = for xl in xls do xlhash.match(xl) od
      then longlist = uhashes[i].list()
      then plist = for p in longlist
		   do if xlhash.lookup(p.x,p.lambda).>=
		      then [p]
		      else []
		      fi
		   od.##
      then Ns = xl_known[i]
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do prints("void: big_unitary_hash.long_match(parameter(G_temp,",
	    p.x.number,",",p.lambda,",",p.nu,"),j)")
	 od;
	 for N@xnum in Ns
	 do if N.>
	    then prints("big_unitary_hash.finish_num(",Gname,",",xnum,",",to_string(N),")")
	    fi {this adds the location of lambda to the bitset of known lambdas at x}
	 od
    , ((KGBElt,ratvec) -> ): {writexlam_no_G} (KGBElt x, ratvec lambda):
      let G = x.real_form
      then xnum = x.number
      then i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then longlist = uhashes[i].list()
      then plist = for p in longlist
		   do if p.x = x and p.lambda = lambda
		      then [p]
		      else []
		      fi
		   od.##
      then N = to_bitset([position(x,lambda)])
      in {write_real_form(G,Gname);}
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",lambda,",",p.nu,"),j)")
	 od;
	 if is_member_bitset(position(x,lambda), xl_known[i][xnum])
	 then prints("big_unitary_hash.finish_num(",Gname,",",xnum,",",to_string(N),")")
	 fi
    )
)


set big_unitary_hash = make_big_unitary_hash()

{uses the results stored in big_unitary_hash.}
set branch_irr_hash(Param p, int D) = KTypePol:
    let CF = character_formula_to_height(p,D)
    in big_unitary_hash.branch(K_type_pol(CF),D)



{. The next family of functions all need simple derived group. Always
|vd.list| should be ALL vertices in the FPP; Lvd.list will be all infl
chars in the FPP for a parameter (x,lambda,*), with x and lambda
fixed. The face lists carried by [[FaceBary]] or [[FaceVertsIndex]]
may be pruned of reps not interesting for unitarity, but the indices
will always refer to a constant vlist.}

set two_to_position(KGBElt x, ratvec lambda) = int:
    let pos = position(x,lambda)
    in if pos.>=
       then to_bitset([position(x,lambda)])
       else -1
       fi

{set a bit in xl_known}
set finish(KGBElt x, ratvec lambda) = void:
    let pos = two_to_position(x,lambda)
    in if pos.>=
       then big_unitary_hash.finish(x, pos)
       fi

set finish(KGBElt x) = void:
    {let lambdas = FPP_lambdas(x)
    then m = #lambdas
    then M = (to_bitset([m]) - 1)
    in} big_unitary_hash.finishx(x)

{check whether a bit in xl_known is set}
set is_finished_old(KGBElt x, ratvec lambda) = bool:
    let start = elapsed_ms(), Mx_known = big_unitary_hash.x_known(x.real_form),
	Mx_partial = big_unitary_hash.x_partial(x.real_form), M = big_unitary_hash.xl_known(x.real_form)[x.number]
    {then () = prints("Mx_known = ",Mx_known,", Mx_partial = ",Mx_partial,", M = ",M)}
    then answer = if is_member_bitset(x.number,Mx_known)
		  then true
		  elif {is_member_bitset(x.number,Mx_partial)
		  then} let pos = position(x,lambda)
			in if pos.>=
			   then is_member_bitset(pos,M)
			   else false
			   fi
		  then true
		  else false
		  fi
    then () = is_finished_time +:= elapsed_ms() - start
    in answer

{check whether a bit in xl_known is set}
set is_finished(KGBElt x, ratvec lambda) = bool:
    let start = elapsed_ms(), M = big_unitary_hash.xl_known(x.real_form)[x.number]
    {then () = prints("Mx_known = ",Mx_known,", Mx_partial = ",Mx_partial,", M = ",M)}
    then answer = let pos = FPP_lam_table.position(x,lambda)
		  in if pos.>=
		     then is_member_bitset(pos,M)
		     else false
		     fi
    in is_finished_time +:= elapsed_ms() - start;
       answer

{list of all pairs (x,lambda) for which complete FPP-unitary dual is present in big_unitary_hash}
set list_all_finished(RealForm G) = [(KGBElt,ratvec)]:
    let list = for x in KGB(G)
	       do set_bit_positions(big_unitary_hash.xl_known(G)[x.number])
	       od
    in for x in KGB(G)
       do let poss = list[x.number]
	  in for pos in poss
	     do (x, FPP_lambdas(x)[pos])
	     od
       od.##
{how much to scale semisimple rank to get ht trial jump}

{these functions were in unity.at; give useful heights to which to try unitarity}

{. gives (one of) the K-types of lowest height above mu in the
standard of LKT mu .} {NEED USEFUL BOUND in K_type_formula.}
set next_to_lowest_old(KType mu, int step) = KType:
    let form = null_K_module(mu.real_form)
    then m = height(mu)
    then () = for j:60 from 1
	      do let () = form :=
		     if my_branch_flag
		     then big_unitary_hash.branch(mu, m+j*step)-mu
		     else branch(mu,m+j*step) - mu
		     fi
		 in if form.!= then break fi
	      od
    in last_K_type(form)

set next_to_lowest(KType mu) = KType:
    let HT = height(mu)+1
    then NTL = null_K_module(mu)
    then () = while NTL.=
	      do NTL := big_unitary_hash.K_type_formula_to_ht(mu,HT) - mu;
		 HT+:=1
	      od
    in first_K_type(NTL)

{SHOULD MAKE A FORMULA USING irr p restricted to K}

{. height of a smallest non-lowest K_type of standard with LKT mu .}
set next_height(KType mu)  = int:
    height(next_to_lowest(mu))

{. next height AFTER HT at which p has a K-type}
set next_height(Param p, int HT) = int:
    if HT < height(p) then return height(p) fi;
    let PK = K_type_pol(character_formula(p))
    then PKH = big_unitary_hash.branch(PK,HT)
    then PKplus = PK - sum(p.real_form,for c@m in PKH do c*big_unitary_hash.K_type_formula(m) od)
    in if PKplus.=
       then -1
       else height(first_K_type(PKplus))
       fi

{. height of a smallest non-lowest K_type of p .}
set next_height(Param p) = int:
    min(for mu in LKTs(p) do height(next_to_lowest(mu)) od)

set next_taus(KType mu, int D) = [KType]:
    if D.<= then return [] fi;
    let tau = mu
    in for j:D do tau := next_to_lowest(tau) od

set next_heights(KType mu, int D) = [int]:
    for tau in next_taus(mu,D) do height(tau) od

set next_taus(Param p, int D) = [KType]:
    for mu in LKTs(p) do next_taus(mu, D) od.##.temp_sort_u[:D]

{if this produces -1, then the (hermitian) p is automatically unitary}
set next_heightB(Param p) = int:
    let mu = LKTs(p)[0]
    then M = if my_branch_flag
	     then big_unitary_hash.K_type_formula_to_ht(mu, height(p) +
		  height(p.root_datum, p.nu)) - mu
	     else K_type_formula(mu, height(p) + height(p.root_datum, p.nu)) - mu
	     fi
    in
    if =M then -1
    else
    let tau = first_K_type(M) in height(tau)
    fi

{sum of the lowest height terms of P}
set next_taus(KTypePol P) = KTypePol:
    if P.=
    then return P
    else let HT = height(first_K_type(P))
    	 then (below,) = height_split(P,HT)
	 in below
    fi
{whether to use following function}
set next_heightC_flag = false

{returns the height of the next K-type > HT, or -1 if none exists}
set next_heightC_old = ((Param,int) -> int):
    let p = Param: SL(2,R).trivial
    then current_height = int: -1
    then taus_so_far = KTypePol: null_K_module(p.real_form) {meant to be all branch_irr UP TO current height}
    then KCF = KTypePol: K_type_pol(character_formula(p)) {meant to be K-char(p) MINUS formulas of taus_so_far}
    then new_taus = KTypePol: null_K_module(p.real_form) {most recent additions to taus_so_far}
 in ((Param,int) -> int): (Param q, int HT):
    if not p=q
    then p:=q;
    	 prints("about to compute K-char of ",p);
    	 KCF:=  K_type_pol(character_formula(p));
	 current_height:=height(q)-1;
	 taus_so_far:= null_K_module(p.real_form);
	 new_taus := null_K_module(p.real_form)
    fi;
    if taus_so_far.!= and height(taus_so_far) > HT
    then let (,above) = height_split(taus_so_far,HT)
    	 in return height(first_K_type(above))
    fi;
    while KCF.!= and (taus_so_far.= or height(taus_so_far) <= HT)
    do prints("current_height = ",current_height, ", new_taus = ",new_taus);
       new_taus := next_taus(KCF); {nonzero of ht > current height, <=HT}
       current_height:= height(new_taus);
       prints("new current_height = ", current_height,", new_taus = ",new_taus);
       prints("about to correct KCF by new_taus");
       KCF := KCF - sum(p.real_form, for c@tau in new_taus do c*
       big_unitary_hash.K_type_formula(tau) od);
       taus_so_far +:= new_taus
    od; {now KCF is zero, or starts > HT}
    if new_taus.=
    then -1
    elif height(new_taus) <= HT
    then -1
    else height(new_taus)
    fi

set next_heightC_verbose = false

{returns the height of the next K-type > HT, or -1 if none exists}
set next_heightC = ((Param,int) -> int):
    let p = Param: SL(2,R).trivial, start_time = int:0
    then HT_bound = let (,,GAM) = low(p) in GAM {to_ht to HT_bound is is_unitary}
    then current_tau_bound = tensor_p_big(LKTs(p)[0])
    then current_bound = height(current_tau_bound)
    then current_height = int: -1
    then taus_so_far = KTypePol: null_K_module(p.real_form) {meant to be all branch_irr UP TO current height}
    then KCF = KTypePol: K_type_pol(character_formula_to_height(1*p,current_bound)) {meant to be K-char(p)
    	 to current_bound MINUS formulas of taus_so_far}
	 {need 1*p in case p is not final}
    then new_taus = KTypePol: null_K_module(p.real_form) {most recent additions to taus_so_far}
 in ((Param,int) -> int): (Param q, int HT):
    start_time:=elapsed_ms();
    if not p=q
    then {p:=q;}
    	 HT_bound := (let (,,GAM) = low(p:=q) in GAM); {to_ht to HT_bound is is_unitary}
	 current_tau_bound := tensor_p_big(LKTs(q)[0]);
	 current_bound := height(current_tau_bound);
	 if current_bound > HT_bound
	 then if next_heightC_verbose
	      then prints("cutting bound from ",current_bound," to ",HT_bound)
	      fi;
	      current_bound:=HT_bound
	 fi;
    	 if next_heightC_verbose
	 then prints("about to compute K-char to height ",current_bound) fi;
    	 KCF:=  K_type_pol(character_formula_to_height(1*p,current_bound));
	 current_height:=height(q)-1;
	 taus_so_far:= null_K_module(q.real_form);
	 new_taus := null_K_module(q.real_form)
    fi;
    if taus_so_far.!= and height(taus_so_far) > HT
    then let (,above) = height_split(taus_so_far,HT)
    	 in next_heightC_time+:=elapsed_ms()-start_time;
	    return height(first_K_type(above))
    fi;
    while HT >= current_bound
    do current_tau_bound:=tensor_p_big(current_tau_bound);
       current_bound := height(current_tau_bound);
       if next_heightC_verbose
       then prints("about to compute K-char to height ",current_bound) fi;
       KCF := K_type_pol(character_formula_to_height(1*p,current_bound));
       if next_heightC_verbose
       then prints("about to correct KCF by taus_so_far") fi;
       KCF -:= for c@tau in taus_so_far
       	       do c*big_unitary_hash.K_type_formula_to_ht(tau,current_bound)
	       od
    od;
    while KCF.!= and (taus_so_far.= or height(taus_so_far) <= HT)
    do if next_heightC_verbose
       then prints("current_height = ",current_height, ", new_taus = ",new_taus) fi;
       new_taus := next_taus(KCF); {nonzero of ht > current height, <=HT}
       current_height:= height(new_taus);
       if next_heightC_verbose
       then prints("new current_height = ", current_height,", new_taus = ",new_taus);
       	    prints("about to correct KCF by new_taus") fi;
       KCF := KCF - sum(p.real_form, for c@tau in new_taus do c*
       big_unitary_hash.K_type_formula_to_ht(tau,current_bound) od);
       taus_so_far +:= new_taus
    od; {now KCF is zero, or starts > HT}
    next_heightC_time+:=elapsed_ms()-start_time;
    if new_taus.=
    then -1
    elif height(new_taus) <= HT
    then -1
    else height(new_taus)
    fi

set next_heightC_zero_flag = true

set next_heights(Param p, int D) = [int]:
    if next_heightC_flag
    then let p0 = p*0, ht = height(p)
    	 in for j:D do ht:=next_heightC(p0,ht) od
    else for tau in LKTs(p) do next_heights(tau, D) od.##.sort_u[:D]
    fi

set UHBS_time = int: 0


{assume p = u_to_ht_hash.list()[j], h = u_to_ht_hts[j] gives
is_unitary_to_ht(p,h) = true}
set u_to_ht_hash = make_Param_hash()
set u_to_ht_hts = [int]:[]

set add_to_u_to_ht(Param p,int h) = void:
    if h < 0 then big_unitary_hash.umatch(p); return () fi;
    let M = u_to_ht_hash.size()
    then m = u_to_ht_hash.match(p)
    in if m = M
       then u_to_ht_hts #:= h
       else u_to_ht_hts[m] := max(u_to_ht_hts[m],h)
       fi

set add_to_u_to_ht([(Param,int)] data) = void:
    for d in data do add_to_u_to_ht(d) od

set u_to_ht_clear() = void:
    u_to_ht_hash.clear();
    u_to_ht_hts := ([int]: [])

set is_known_u_to_ht(Param p, int HT) = bool:
    let j = u_to_ht_hash.lookup(p)
    in if j.<
       then false
       elif u_to_ht_hts[j] < 0 then false
       else (HT >= 0) and (u_to_ht_hts[j] >= HT)
       fi

{return 1 if is_unitary_to_ht(p,HT) known true, -1 if known false, 0 else}
set status(Param p, int HT) = int:
    if not is_hermitian(p) then return -1 fi;
    let start_st = elapsed_ms(), ans = int:0
    then GAM = (p.infinitesimal_character* p.inner_class.two_rho_check)\1
    in
    if HT >= GAM then HT:=-1 fi;
    ans := if big_unitary_hash.ulookup(p) >= 0
    then {assert(@:is_unitary_to_ht(p,HT));} 1
    elif not big_unitary_hash.nu_height_lookup_bool(p,HT)
    then {assert(@:not is_unitary_to_ht(p,HT));} -1
    elif is_known_u_to_ht(p,HT)
    then {assert(@:is_unitary_to_ht(p,HT));} 1
    elif is_finished(p.x, p.lambda) and HT < 0
    then -1 {otherwise we'd have found it in ulookup}
    else 0
    fi;
    status_time +:= elapsed_ms() - start_st;
    status_count +:= 1;
    ans

{assume p is hermitian, FPP}
set hermitian_form_irreducible_big_SIMPLE(Param p) = KTypePol:
    big_unitary_hash.sig_entry(p,-1)
    {let () = p:=herm_center(p)
    then stat = status(p,-1)
    in if stat > 0
       then K_type_pol(character_formula(p))
       else big_unitary_hash.sig_entry(p,-1) {hermitian_form_irreducible(p)}
       fi}

set stat_holder = int:0

{this version is only for G simple, p FPP hermitian and centered}
{First weakly good, then Lucas}
set is_unitary_hash_big_SIMPLE_weak_Lucas(Param p) = bool:
    if (stat_holder := status(p,-1)).!= then return stat_holder > 0 fi;
    let (,pL) = wkgood_Q(p), G = p.real_form {first try weakly good induction}
    then L = pL.real_form
    then goodL = good_L(p)
    then answer = if L !=G
		  then let derpLs = for qLj in derived_factor_params0(pL)
				    do monomials(finalize(qLj))
				    od.##
		       in if #derpLs = 0
			  then true
			  else
			   let statuses = for derpL in derpLs
					  do big_unitary_hash.check(derpL)
					  od
			   in if all(statuses) or goodL = L
			      then all(statuses)
			      else {some derpL is not unitary, but the induction is not trivial}
				is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
					    do c*theta_induce_standard(param(qL), goodL)
					    od))
			     fi {all(statuses}
			  fi{#derpLs = 0}
		   else    {now start Lucas test}
		    let gamma = p.infinitesimal_character, rd = p.root_datum
		    then rdi = integrality_datum(rd,gamma)
		    then alphavs = for alphav@j in rd.simple_coroots
				   do if gamma*alphav < 1
				      then [j]
				      else let ji = coroot_index(rdi,alphav)
				      in if not is_member_sorted(tau(p))(ji)
					 then []
					 else [j]
					 fi {not is_member}
				      fi {gamma*alphav < 1}
				   od.##
		   then Q = KGPElt: (alphavs, p.x)
		   then rhou = Q.rho_u
		   in if((p.x.involution-1)*rhou).!=
		      then false
		      else
			let LL = Q.Levi
			in if LL != G {Lucas test gives a reduction}
			   then let xLL = inverse_embed_KGB(p.x,LL)
				then pLL = parameter(xLL,p.lambda - rhou, p.nu)
				{then () = assert(p = first_param(theta_induce_standard(pL,G)),
				"screwed up pL!")}
				then derpLLs = derived_factor_params0(pLL)
				in all(for derpLL in derpLLs
				       do @bool: big_unitary_hash.check(derpLL)
				       od)
			   else big_unitary_hash.check(p)
			   fi {LL != G}
			fi {Q theta-stable}
		 fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{this version is only for G simple, FPP hermitian and herm center p}
{tries first Lucas, then weakly good}
set is_unitary_hash_big_SIMPLE_Lucas_weak(Param p) = bool:
    stat_holder :=status(p,-1);
    if stat_holder.!= then return stat_holder > 0 fi;
    let gamma = p.infinitesimal_character, rd = p.root_datum, G = p.real_form
    then rdi = integrality_datum(rd,gamma)
    then alphavs = for alphav@j in rd.simple_coroots
		  do if gamma*alphav < 1
		     then [j] {else must be = 1 since we're in FPP}
		     else let ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
    then Q = KGPElt: (alphavs, p.x)
    then rhou = Q.rho_u
    then () = if((p.x.involution-1)*rhou).!=
	      then big_unitary_hash.numatch(p); return false
	      fi
    then L = Q.Levi
    then answer = if L != G {Lucas test gives a reduction}
		  then
		   let xL = inverse_embed_KGB(p.x,L)
		   then pL = parameter(xL,p.lambda - rhou, p.nu)
		   {then () = assert(p = first_param(theta_induce_standard(pL,G)),
			"screwed up pL!")}
		   then derpLs = derived_factor_params0(pL)
		   in all(for derpL in derpLs
			  do @bool: big_unitary_hash.check(derpL)
			  od)
		  else
		   let (,pL) = wkgood_Q(p) {else try weakly good induction}
		   then derpLs = for qLj in derived_factor_params0(pL)
				 do monomials(finalize(qLj))
				 od.##
		   then goodL = good_L(p)
		   in if #derpLs = 0
		      then big_unitary_hash.umatch(p); true
		      else
		       let statuses = for derpL in derpLs
				      do big_unitary_hash.check(derpL)
				      od
		       in if all(statuses) or goodL = pL.real_form
			  then all(statuses)
			  else {some derpL is not unitary, but the induction is not trivial}
			       is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
					    do c*theta_induce_standard(param(qL), goodL)
					    od))
			 fi {all(statuses}
		       fi{#derpLs = 0}
		    fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{this version is only for G simple}
set is_unitary_hash_big_SIMPLE_Lucas(Param p) = bool:
    stat_holder :=status(p,-1);
    if stat_holder.!= then return stat_holder > 0 fi;
    let gamma = p.infinitesimal_character, rd = p.root_datum, G=p.real_form
    then rdi = integrality_datum(rd,gamma)
    then alphavs = for alphav@j in rd.simple_coroots
		  do if gamma*alphav < 1
		     then [j]
		     else let ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
    then Q = KGPElt: (alphavs, p.x)
    then rhou = Q.rho_u
    then () = if((p.x.involution-1)*rhou).!=
	      then big_unitary_hash.numatch(p); return false
	      fi
    then L = Q.Levi
    then answer = if L != G {Lucas test gives a reduction}
		  then
		   let xL = inverse_embed_KGB(p.x,L)
		   then pL = parameter(xL,p.lambda - rhou, p.nu)
		   {then () = assert(p = first_param(theta_induce_standard(pL,G)),
			"screwed up pL!")}
		   then derpLs = derived_factor_params0(pL)
		   in all(for derpL in derpLs
			  do @bool: big_unitary_hash.check(derpL)
			  od)
		  else
		   big_unitary_hash.check(p)
		  fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer


{this version is only for G simple and hermitian FPP params}
{does weakly good induction}
set is_unitary_hash_big_SIMPLE_weak(Param p) = bool:
    stat_holder :=status(p,-1);
    if stat_holder.!= then return stat_holder > 0 fi;
    let (,pL) = wkgood_Q(p), G = p.real_form
    then derpLs = for qLj in derived_factor_params0(pL)
		  do monomials(finalize(qLj))
		  od.##
    then () = if #derpLs = 0 then big_unitary_hash.umatch(p); return true fi
    then statuses = for derpL in derpLs
		    do big_unitary_hash.check(derpL)
		    od
    then goodL = good_L(p)
    then answer =
       if all(statuses) or goodL = pL.real_form
       then all(statuses)
       else {some derpL is not unitary, but the induction is not trivial}
	    is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
				   goodL)
			      od))
       fi{all(statuses)}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{tiny evidence that wk_Lucas is best, or at least not very bad}
set u_Lucas_flag = false
set u_wk_flag = false
set u_wk_Lucas_flag = true
set u_Lucas_wk_flag = false

{this version is only for G simple}
set is_unitary_hash_big_SIMPLE(Param p) = bool:
    {stat_holder :=status(p,-1);
    if stat_holder.!= then return stat_holder > 0 fi;
    if not is_hermitian(p) then return false fi;} {save 12 reports/7000 in Spin(4,4)}
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
	      then return is_unitary(p) {prints("FPP DANGER at ",p)}
	      fi
    then () = p := herm_center(p)
    then () = if u_Lucas_flag then return is_unitary_hash_big_SIMPLE_Lucas(p) fi
    then () = if u_wk_flag then return is_unitary_hash_big_SIMPLE_weak(p) fi
    then () = if u_Lucas_wk_flag then return is_unitary_hash_big_SIMPLE_Lucas_weak(p) fi
    then () = if u_wk_Lucas_flag then return is_unitary_hash_big_SIMPLE_weak_Lucas(p) fi
    in big_unitary_hash.check(p)

{this version is only for G simple}
{return 1 means true, -1 false, 0 interrupted}
set is_unitary_hash_big_SIMPLE(Param p, int TIME) = int:
    {stat_holder :=status(p,-1);
    if (stat_holder:=status(p,-1)).!= then return stat_holder fi;} {save nothing in Spin(4,4)}
    if not is_hermitian(p) then return -1 fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then return is_unitary(p,TIME) {prints("FPP DANGER at ",p)}
	      fi
    then () = p := herm_center(p)
    in big_unitary_hash.check_interrupt(p,TIME)

set is_unitary_hash_big(Param p) = bool:
    stat_holder :=status(p,-1);
    if stat_holder.!= then return stat_holder > 0 fi;
    if not is_hermitian(p) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_hash_big_SIMPLE(pd) od)

set HOWMANY = int:0

set hermitian_form_irreducible_big(Param p) = KTypePol:
    if is_unitary_hash_big(p)
    then let ans = K_type_pol(character_formula(p))
	 in ans
    else let G = p.real_form
     	  then () = HOWMANY +:= 1
	  {in hermitian_form_irreducible(p)}
	  then derps = derived_factor_params0(p)
	  then mu0 = LKTs(p)[0]
	  {then ans = }
	  in glue_sigs(for derp in derps do hermitian_form_irreducible_big_SIMPLE(derp) od, mu0)
     fi

set print_int_flag = false

{assume p is hermitian}
set hermitian_form_irreducible_to_ht_big_SIMPLE(Param p,int HT) = KTypePol:
  let GAM = (p.infinitesimal_character* p.inner_class.two_rho_check)\1
  in if (HT >= GAM) or (HT < 0) then return hermitian_form_irreducible_big_SIMPLE(p) fi;
  {if status(p,HT) > 0 then return K_type_pol(character_formula_to_height(p,HT)) fi;}
  {save nothing in Spin(4,4)}
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return hermitian_form_irreducible_to_ht(p,HT) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  in big_unitary_hash.sig_entry(p,HT) {this uses low(p,HT) to decide how to compute}

set HOWMTH = int:0

set hermitian_form_irreducible_to_ht_big(Param p,int HT) = KTypePol:
    HOWMTH +:= 1;
    if strict_low(p,HT) {added strict 12/13/25}
    then {let answer =} hermitian_form_irreducible_to_ht(p,HT)
    	 {then D = first_impure_height(answer)
	 in if D<0
	    then big_unitary_hash...}
    else to_ht(hermitian_form_irreducible(p),HT)
    fi

set is_unitary_to_ht_big_SIMPLE_old(Param p, int HT) = bool:
     {{stat_holder :=status(p,HT);}  {save nothing in Spin(4,4)}
     if (stat_holder:=status(p,HT)).!= 0
     then stat_holder > 0
     else} big_unitary_hash.sig_entry(p,HT){hermitian_form_irreducible_to_ht_big_SIMPLE(p,HT)}.is_pure
     {fi}

set is_unitary_to_ht_big_SIMPLE_interrupt(Param p, int HT, int time) = int: {1 means true, -1 false, 0 interrupted}
  {{stat_holder :=status(p,HT);}
  if (stat_holder:=status(p,HT)).!= then return stat_holder fi;} {save 400/7200 in Spin(4,4))}
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return -1 fi;
  if HT.< then return is_unitary_hash_big_SIMPLE(p,time) fi;
  if HT < height(p) then return 1 fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if (not FPP_flag)
       	    then return hermitian_form_irreducible_to_ht_MvL(p, HT, time).is_pure
	    fi
  then () = p := herm_center(p)
  then (,,GAM) = low(p) {unitary to HT >= GAM means unitary}
       ,deformed_flag_hold = deformed_hash_flag
  in let P = if HT >= GAM
     	     then big_unitary_hash.sig_entry_interrupt(p, -1, time)
	     else deformed_hash_flag:=true;
		  big_unitary_hash.sig_entry_interrupt(p, HT, time)
	     fi
     in deformed_hash_flag:=deformed_flag_hold;
     	case P
     	| timed_out: 0
	| done(r): let D = impure_height(r)
	  	   in if D >= 0
		      then -1
		      else add_to_u_to_ht(p,HT); 1
		      fi
	esac

{if low(p,HT) suggests it's worthwhile (false; big HT) try is_unitary with time limit time}
set is_unitary_to_ht_big_SIMPLE(Param p, int HT, int time) = bool:
    {stat_holder :=status(p,HT);
    if (stat_holder:= status(p,HT)).!= then return stat_holder > 0 fi;}
    {save nothing in Spin(4,4)}
    if HT.< then return is_unitary_hash_big_SIMPLE(p) fi;
    if not strict_low(p,HT)
    then let deformed_flag_hold = deformed_hash_flag
    	 in deformed_hash_flag:=true;
	    let ans = hermitian_form_irreducible(p,time)
	    in deformed_hash_flag :=deformed_flag_hold;
    	    case hermitian_form_irreducible(p,time) {maybe_KTP}
	    | timed_out: is_unitary_to_ht_big_SIMPLE_old(p, HT)
	    | done(r): let D = impure_height(r)
	  	   in if D >= 0
		      then big_unitary_hash.numatch_height(p, D);
		      	   D<=HT
		      else big_unitary_hash.umatch(p);
		      	   true
		      fi
	    esac
    else is_unitary_to_ht_big_SIMPLE_old(p, HT)
    fi

{false tries is_unitary intermittently}
set old_to_ht_flag = true

set avtime_frac = rat: 1{16/1 changed 11/3/25}

{how long to_ht has been taking}
set av_to_ht_time() = rat:
    let N_hts = #tested_pos_to_ht_times
    then prevtimes = (for j:N_hts do tested_pos_to_ht_times[j] od
     	 	   ##for j:N_hts do tested_neg_to_ht_times[j] od).##
    in if #prevtimes = 0
       then interrupt_base_time
       else sum(prevtimes)/#prevtimes
       fi

{how long is_unitary has been taking}
set av_u_time() = rat:
    let prevtimes = tested_pos_times ## tested_neg_times
    in if #prevtimes = 0
       then interrupt_base_time
       else sum(prevtimes)/#prevtimes
       fi

set is_unitary_to_ht_big_SIMPLE(Param p, int HT) = bool:
    {{stat_holder :=status(p,HT);} {save nothing in Spin(4,4)}
    if (stat_holder:=status(p,HT)).!= then return stat_holder > 0 fi;}
    if old_to_ht_flag then return is_unitary_to_ht_big_SIMPLE_old(p, HT) fi;
    if HT < height(p) then return true fi;
    let N_hts = min(#tested_pos_to_ht_times, HT - height(p))
    then prevtimes = (for j:N_hts do tested_pos_to_ht_times[j] od
    	 	   ##for j:N_hts do tested_neg_to_ht_times[j] od).##
    then () = if #prevtimes = 0
	      then return is_unitary_to_ht_big_SIMPLE(p,HT,floor(avtime_frac*100))
	      fi
    then avtime = sum(prevtimes)/#prevtimes
    in is_unitary_to_ht_big_SIMPLE(p, HT, floor(avtime_frac*avtime))

{deform to walls of face, check lower comp factors for nonunitarity there}
{false if parameter is proven nonunitary, true if cannot decide}
set is_unitary_to_ht_wiggle_big_SIMPLE(KGBElt x, ratvec lambda, vec verts,
					int HT, LocalVertexData Lvd) = bool:
    if #verts <= 1 then return true fi;
    let p=parameter(x,lambda,face_bary(Lvd,verts)), d = #verts
    then H0 = height(p), short_verts = for i:d+1 do delete(verts,i) od
    then CF = character_formula_to_height(1*p,HT)
    then pdef1 = for sv in short_verts
		 do monomials(composition_series_to_ht(wiggle(CF, face_bary(Lvd,sv)), HT - 1))
		 od.##
    in not any(for q in pdef1
	   do @bool: height(q)>H0 and not is_unitary_to_ht_big_SIMPLE(q,HT)
	   od)

{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big(Param p,int HT) = bool:
  {{stat_holder :=status(p,HT);}
  if (stat_holder:=status(p,HT)).!= then return stat_holder > 0 fi;}
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  {if (big_unitary_hash.ulookup(p)).>= then return true fi;} {this function is meant for nonsimple G}
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_to_ht_big_SIMPLE(pd,HT) od)

set test_interrupt_verbose=false
set old_test_interrupt_flag = false
set Ufirst_flag = false

{"step" is how many steps up in to_ht list to start}
set is_unitary_test_big_SIMPLE_interrupt_old(Param p, int step) = bool:
  {{stat_holder :=status(p,-1);} {save nothing in Spin(4,4)}
  if (stat_holder:=status(p,-1)).!= then return stat_holder > 0 fi;}
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if step.<= then step:=1 fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_test_big_SIMPLE_interrupt_old, p = ",p)
  fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p), start = elapsed_ms()
  then ht_bound = (GAM - LAM) * diff_frac {NU/low_frac}
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, mu = LKTs(p)[0], deformed_flag_hold = deformed_hash_flag
  then () = deformed_hash_flag := true
  then taus = next_taus(p,step)
  then tau_bd = taus~[0]
  then ht = min(height(tau_bd),GAM)
  then old_ht = ht
  then {tau_bd = next_taus(mu,step)~[0],} top_ht = GAM {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then times_to_ht = [int]: [], time_to_ht = int:0
  {then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi}
  then () = while result = 0 and ht < ht_bound
       	    do let  start_to_ht = elapsed_ms()
	       then () = old_ht:=ht
	       then to_ht_ans = is_unitary_to_ht_big_SIMPLE(p,ht)
	       then () = time_to_ht:=elapsed_ms() - start_to_ht
	       then () = if test_interrupt_verbose
			 then prints("time to ht ",ht," = ",print_time_string(time_to_ht))
			 fi
	       then () = times_to_ht #:= time_to_ht
	       then () = tau_bd := next_to_lowest(tau_bd);
	       	       	 old_ht:=ht;
		    	 ht:= height(tau_bd)
	       then u_time = mu_time_mult*max(times_to_ht)
	       {then () = push_deform_flag:=true}
	       in result := if not to_ht_ans
			    then big_unitary_hash.numatch_height(p,old_ht); -1
			    elif old_ht >= top_ht
			    then big_unitary_hash.umatch(p); 1
			    else let startu = elapsed_ms()
				 then r = is_unitary(p,floor(u_time))
				 then () = if test_interrupt_verbose
				      	   then prints("result ",r," from is_unitary, in time ",
					   	print_time_string(elapsed_ms() - startu))
					   fi
				 in r
			    fi
	    od
   in if test_interrupt_verbose
      then prints("Finish is_unitary_test_big_SIMPLE_interrupt_Ufirst, time ",
      	   print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      deformed_hash_flag:=deformed_flag_hold;
      if result > 0 then true
      elif result < 0 then big_unitary_hash.numatch(p); false
      else is_unitary_hash_big_SIMPLE(p)
      fi

{increase the interruptible times by this}
set to_ht_factor = int: 5
set u_factor = int: 1

{"step" is how many steps up in to_ht list to start}
set is_unitary_test_big_SIMPLE_interrupt_Ufirst(Param p, int step) = bool:
  {{stat_holder :=status(p,-1);} {save nothing in Spin(4,4)}
  if (stat_holder:=status(p,-1)).!= then return stat_holder > 0 fi;}
  if old_test_interrupt_flag then return is_unitary_test_big_SIMPLE_interrupt_old(p,step) fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if step.<= then step:=1 fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_test_big_SIMPLE_interrupt_Ufirst, p = ",p)
  fi;
  let G = p.real_form, (,,GAM) = low(p)
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, mu = LKTs(p)[0], ht = height(p),
       deformed_flag_hold = deformed_hash_flag
  then taus = [KType]:[]
  then tau_bd = KType:mu
  then ht = int: height(p) {(tau_bd)}
  then () = if next_heightC_flag
       	    then for j:step
	    	 do ht := next_heightC(p,ht)
		 od
       	    else taus := next_taus(p,step);
	    	 tau_bd := taus~[0];
  		 ht := height(tau_bd)
	    fi;
	    deformed_hash_flag:=true;
	    ht := min(GAM,height(tau_bd))
  then () = if ht < 0 {p is finite-dimensional; we're in FPP, so 1-diml}
       	    then return true
	    fi
  then old_ht = ht
  then top_ht = GAM
       {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then u_time = int: u_predictor(p,-1), {interrupt_base_time,}
       to_ht_time = int: u_predictor(p,ht),{interrupt_base_time,}
       test_time = int:0,
       start = elapsed_ms()
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi
  then () = while result = 0
       	    do if{A} u_time < to_ht_time
	       then let start_u = elapsed_ms()
	       	    then () = result := is_unitary_hash_big_SIMPLE(p, u_factor*u_time)
		    in test_time:= elapsed_ms() - start_u;
		       if test_interrupt_verbose
		       then prints("result ",result," from is_unitary, in time ",
				      print_time_string(test_time),
				     "; total = ", print_time_string(elapsed_ms() - start))
		       fi;
		       if result!=0
		       then break
		       else u_time:=u_predictor(p,-1)
		       fi
	        fi{A}; {u_time < {5*}to_ht_time}
	       	if{B} to_ht_time < 5*u_time
	       	then let start_to_ht = elapsed_ms()
	       	     in result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,to_ht_factor*to_ht_time);
	       	    	test_time:=elapsed_ms() - start_to_ht;
	       		if test_interrupt_verbose
	       	       	then prints("result ", result, " from to_ht ",ht,", in time ",
			      	   print_time_string(test_time),
				   "; total = ", print_time_string(elapsed_ms() - start))
			fi;
		     	if result.<
		     	then big_unitary_hash.numatch_height(p,ht);
			      break
			fi;
	       	        if result.> {got a result for this ht}
	       	       	then if ht >= top_ht
			     then big_unitary_hash.umatch(p);
			     	  break
			     else result:=0;
			     	  add_to_u_to_ht(p,ht)
			     fi;
			     if next_heightC_flag
			     then old_ht := ht;
			     	  ht:= next_heightC(p,ht)
			     else tau_bd := next_to_lowest(tau_bd);
			     	  old_ht := ht;
			     	  ht:= {if elapsed_ms() - start <1000
			     	       then} min(GAM,height(tau_bd))
				       {else next_height(p,ht)
				       fi}
				   {if ht < 0 then return true fi} {one-diml case}
			      fi
			 fi{result.>};
			 to_ht_time:=u_predictor(p,ht);
			 if test_interrupt_verbose
			 then prints("  Predicted to_ht_time now ",print_time_string(to_ht_time))
			 fi
	           fi{B} {to_ht_time < 5*u_time}
	    od
   in deformed_hash_flag:=deformed_flag_hold;
      if test_interrupt_verbose
      then prints("Finish is_unitary_test_big_SIMPLE_interrupt_Ufirst, time ",
      	   print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      result > 0

{"step" is how many steps up in to_ht list to start}
set is_unitary_test_big_SIMPLE_interrupt(Param p, int step) = bool:
  {{stat_holder :=status(p,-1);} {save 80/7200 in Spin(4,4)}
  if (stat_holder:=status(p,-1)).!= then return stat_holder > 0 fi;}
  if old_test_interrupt_flag then return is_unitary_test_big_SIMPLE_interrupt_old(p,step) fi;
  if Ufirst_flag then return is_unitary_test_big_SIMPLE_interrupt_Ufirst(p,step) fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if step.<= then step:=1 fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_test_big_SIMPLE_interrupt, p = ",p)
  fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p)
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, mu = LKTs(p)[0], deformed_flag_hold = deformed_hash_flag
  then taus = [KType]: [] {next_taus(p,step)}
  then tau_bd = KType: mu {taus~[0]}
  then ht = int: height(p) {(tau_bd)}
  then () = if next_heightC_flag
       	    then for j:step
	    	 do ht := next_heightC(p,ht)
		 od
       	    else taus := next_taus(p,step);
	    	 tau_bd := taus~[0];
  		 ht := height(tau_bd)
	    fi;
	    ht:=min(ht,GAM);
	    deformed_hash_flag:=true
  then () = if ht < 0 {p is finite-dimensional; we're in FPP, so 1-diml}
       	    then return true
	    fi
  then old_ht = ht
  then top_ht = GAM
       {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then u_time = int: u_predictor(p,-1), {interrupt_base_time,}
       to_ht_time = int: u_predictor(p,ht), {interrupt_base_time,}
       test_time = int:0,
       start = elapsed_ms()
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi
  then () = while result = 0 
       	    do if{A} to_ht_time < 5*u_time
	       then let start_to_ht = elapsed_ms()
	       	    in 	result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,to_ht_factor*to_ht_time);
	       	    	test_time:=elapsed_ms() - start_to_ht;
	       		if test_interrupt_verbose
			then prints("result ", result, " from to_ht ",ht,", in time ",
			     		    print_time_string(test_time),
			      		    "; total = ", print_time_string(elapsed_ms() - start))
			fi;
		     	if result.< then break fi;
			if result.> and ht >= top_ht then break fi;
		     	if result.> {got a (useless) positive result at ht; move up} 
			then result:=0;
			     if next_heightC_flag
			     then ht:= next_heightC(p,ht)
			     else old_ht:=ht;
			     	  tau_bd := next_to_lowest(tau_bd);
				  ht := height(tau_bd)
			     fi;
			     ht :=min(ht,GAM)
			fi;
			to_ht_time := u_predictor(p,ht);
			if test_interrupt_verbose
			then prints("  Predicted to_ht_time for ht = ",ht," is ",
			     print_time_string(to_ht_time))
			 fi
	        fi{A};  {to_ht_time < 5*u_time}
		if{B} u_time < {5*}to_ht_time
		then let startu = elapsed_ms()
		     then () = result := is_unitary_hash_big_SIMPLE(p, u_factor*u_time)
		     in test_time:= elapsed_ms() - startu;
		     	if test_interrupt_verbose {and result != 0}
		        then prints("result ",result," from is_unitary, in time ",
			    	   print_time_string(test_time), "; total = ",
				   print_time_string(elapsed_ms() - start))
			fi;
			if result != 0
			then break
			else u_time := u_predictor(p,-1);
			     if test_interrupt_verbose
			     then prints("  Predicted u_time is now ", print_time_string(u_time))
			     fi
			fi
		 fi{B}; {u_time < {5*}to_ht_time}
		 if result = 1 and old_ht >= top_ht
		 then big_unitary_hash.umatch(p)
		 else if result = 1 then result:=0 fi
		 fi
	     od
   in deformed_hash_flag:=deformed_flag_hold;
      if test_interrupt_verbose
      then prints("Finish is_unitary_test_big_SIMPLE_interrupt, time ",
      	   print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      if result > 0
      then big_unitary_hash.umatch(p); true
      elif result < 0
      then big_unitary_hash.numatch(p);
      false
      else is_unitary_hash_big_SIMPLE(p) {shouldn't come to here}
      fi

set default_interrupt_start = int: 1 {2}

set is_unitary_test_big_SIMPLE_interrupt(Param p) = bool:
    is_unitary_test_big_SIMPLE_interrupt(p, default_interrupt_start)

{Hasn't yet got u_predictor; SHOULDN'T USE}
{hts should be increasing string of heights > height(p). Check those, then switch to above}
set is_unitary_test_big_SIMPLE_interrupt(Param p, [int] hts) = bool:
  {if (stat_holder:=status(p,-1)).!= then return stat_holder > 0 fi;} {save nothing Spin(4,4)}
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if #hts = 0 then return is_unitary_test_big_SIMPLE_interrupt(p, 1) fi;
  if hts~[0] <= height(p) then return is_unitary_test_big_SIMPLE_interrupt(p) fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_test_big_SIMPLE_interrupt, p = ",p,", hts = ",hts)
  fi;
  let G = p.real_form, (,{NU},GAM) = low(p)
  then ht_bound = GAM*gamma_frac {NU*nu_frac}
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, mu = LKTs(p)[0], top_ht = floor((p.infinitesimal_character)*G.two_rho_check)
       {unitary to top_ht implies unitary}
  then times_to_ht = int: 0, start = elapsed_ms(), deformed_flag_hold = deformed_hash_flag
  then i0 = first(for ht in hts do ht > height(p) od)
  then () = hts:= hts[i0:]; deformed_hash_flag:=true
  then () = for ht in hts
	    do let start_to_ht = elapsed_ms()
	       then to_ht_ans = is_unitary_to_ht_big_SIMPLE(p,ht)
	       then () = times_to_ht +:= elapsed_ms() - start_to_ht
	       {then () = if time_to_ht > 10000 and test_verbose
			 then prints("ht ",ht," of SIMPLE_interrupt took ",print_time_string(time_to_ht))
			 fi}
	       {then () = push_deform_flag:=true}
	       in result := if not to_ht_ans
			    then {big_unitary_hash.numatch_height(p,ht);} -1
			    elif ht >= top_ht
			    then big_unitary_hash.umatch(p); 1
			    else is_unitary(p,floor(mu_time_mult*times_to_ht))
			    fi
	    od
   then () = if result < 0
   	     then big_unitary_hash.numatch(p);
	     	  if test_interrupt_verbose
      		  then prints("Finish is_unitary_test_big_SIMPLE_interrupt, time ",
      	   	  print_time_string(elapsed_ms() - start), " result ",result,new_line)
      		  fi;
		  return false fi
   then taus = next_taus(mu,#hts), last_ht = hts~[0]
   then N = if height(taus~[0])> last_ht
	    then first(for tau in taus do height(tau)> last_ht od)
	    else #hts
	    fi
   in deformed_hash_flag:=deformed_flag_hold;
      is_unitary_test_big_SIMPLE_interrupt(p, N)

{try for time milliseconds; return 1 if true, -1 if false, 0 if run out of time}
set is_unitary_test_big_SIMPLE_interrupted_Ufirst(Param p, int time) = int:
  {if (stat_holder:=status(p,-1)).!= then return stat_holder fi;}
  if (not is_hermitian(p)) then return -1 fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return -1 fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_test_big_SIMPLE_interrupted_Ufirst, p = ",p)
  fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p), start = elapsed_ms()
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary(p,time) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, mu = LKTs(p)[0], ht = height(p), top_ht = GAM,
       deformed_flag_hold = deformed_hash_flag
        {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then tau_bd = KType: mu
  then () = if next_heightC_flag
       	    then ht := next_heightC(p,ht)
       	    else tau_bd := next_to_lowest(mu);
  		 ht := height(tau_bd)
	    fi;
	    deformed_hash_flag:=true;
	    ht := min(ht,GAM)
  then u_time = int:  u_predictor(p,-1), test_time = int:0,
       to_ht_time = int: u_predictor(p,ht)
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi
  then () = while result = 0 and elapsed_ms() - start < time
       	    do if{A} u_time < to_ht_time
	       then let start_u = elapsed_ms()
	       	     in result := is_unitary_hash_big_SIMPLE(p, u_factor*u_time);
		       	 test_time:= elapsed_ms() - start_u;
	       		 if test_interrupt_verbose
		       	 then prints("result ",result," from is_unitary, in time ",
				      	 print_time_string(test_time),
				 "; total = ", print_time_string(elapsed_ms() - start))
			 fi;
	       		 if result.!=
	       	  	 then break
		  	 else u_time := u_predictor(p,-1);
		       	      if test_interrupt_verbose
		       	      then prints("  Predicted u_time now ",print_time_string(u_time))
		       	      fi
		  	 fi {result.!=}
	       fi; {A} {u_time < {5*}to_ht_time}
	       if{B} to_ht_time < u_time
	       then let start_to_ht = elapsed_ms()
		    in result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,to_ht_factor*to_ht_time);
	       	       test_time:=elapsed_ms() - start_to_ht;
	       	       if test_interrupt_verbose
	       	       then prints("result ", result, " from to_ht ",ht,", in time ",
			      	   print_time_string(test_time),
				   "; total = ", print_time_string(elapsed_ms() - start))
		       fi;
		       if result.<
		       then {big_unitary_hash.numatch_height(p,ht);}
		       break
		   elif result.> and ht >= top_ht
		   then big_unitary_hash.umatch(p);
		   	break
	       	   elif result.> {got a useless result from to_ht}
	       	   then if next_heightC_flag
			then {old_ht := ht;}
			     ht:= next_heightC(p,ht)
			else tau_bd := next_to_lowest(tau_bd);
			     {old_ht := ht;}
			     ht:= height(tau_bd)
			fi;
			ht:=min(ht,GAM);
			to_ht_time := u_predictor(p,ht);
			result := 0;
			if test_interrupt_verbose
			then prints("  Predicted to_ht_time now ",print_time_string(to_ht_time))
			fi
		   fi {result.<}
		 fi{B}  {to_ht_time < 5*u_time}
	    od
   in deformed_hash_flag :=deformed_flag_hold;
      if test_interrupt_verbose
      then prints("Finish is_unitary_test_big_SIMPLE_interrupted_Ufirst, time ",
      	   	  print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      if result > 0
      then big_unitary_hash.umatch(p)
      elif result < 0
      then big_unitary_hash.numatch(p)
      fi;
      result

set is_unitary_test_big_SIMPLE_interrupted(Param p, int time) = int:
  {if (stat_holder:=status(p,-1)).!= then return stat_holder fi;} {nothing in Spin(4,4)}
  if Ufirst_flag then return is_unitary_test_big_SIMPLE_interrupted_Ufirst(p,time) fi;
  if (not is_hermitian(p)) then return -1 fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return -1 fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_test_big_SIMPLE_interrupted, p = ",p)
  fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p), start = elapsed_ms()
  {then ht_bound = (GAM - LAM) * diff_frac} {NU/low_frac}
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary(p,time) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, ht = height(p), top_ht = GAM, tau_bd = LKTs(p)[0],
       deformed_flag_hold = deformed_hash_flag
       {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then () = if next_heightC_flag
       	    then ht := next_heightC(p,ht)
       	    else tau_bd := next_to_lowest(tau_bd);
  	    	 ht := height(tau_bd)
	    fi;
	    deformed_hash_flag:=true
  then u_time = int:  u_predictor(p,-1), test_time = int:0,
       to_ht_time = int: u_predictor(p,ht)
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi
  then () = while result = 0 and elapsed_ms() - start < time
       	    do if{A} to_ht_time < 5*u_time
	       then let start_to_ht = elapsed_ms()
	       	    in result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,to_ht_factor*to_ht_time);
	       	       test_time:=elapsed_ms() - start_to_ht;
	       	       if test_interrupt_verbose
	       	       then prints("result ", result, " from to_ht ",ht,", in time ",
			     print_time_string(test_time),
			      "; total = ", print_time_string(elapsed_ms() - start))
		       fi;
	       	       if result.<
	       	       then {big_unitary_hash.numatch_height(p,ht);}
		       break
		       elif result.> and ht >= top_ht
		       then big_unitary_hash.umatch(p);
		       	    break
		       elif result.> {got a useless result}
	       	       then if next_heightC_flag
		       	    then ht:= next_heightC(p,ht)
		       	    else tau_bd := next_to_lowest(tau_bd);
			    	 ht := height(tau_bd)
		            fi;
		       	    result:=0;
		       	    to_ht_time := u_predictor(p,ht)
		  fi {result.<}
	       fi; {A} {to_ht_time < 5*u_time}
	       if{B} u_time < {5*}to_ht_time
	       then let start_u = elapsed_ms()
	       then () = result := is_unitary_hash_big_SIMPLE(p, u_factor*u_time);
			 {is_unitary(p, u_factor*u_time);}
		       	 test_time:= elapsed_ms() - start_u;
	       		 if test_interrupt_verbose
		       	 then prints("result ",result," from is_unitary, in time ",
				      	 print_time_string(test_time),
				 "; total = ", print_time_string(elapsed_ms() - start))
			 fi
	       in if result.!=
	       	  then break
		  else u_time := u_predictor(p,-1)
		  fi {result.!=}
	       fi {B} {u_time < {5*}to_ht_time}
	    od
   in deformed_hash_flag:=deformed_flag_hold;
   if test_interrupt_verbose
      then prints("Finish is_unitary_test_big_SIMPLE_interrupted, time ",
      	   	  print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      if result > 0
      then big_unitary_hash.umatch(p)
      elif result < 0
      then big_unitary_hash.numatch(p)
      fi;
      result

{use is_unitary_to_ht_big_SIMPLE instead of interrupted version}
set old_testing_flag = false

set is_unitary_to_ht_big_SIMPLE_interrupt_Ufirst(Param p, int HT) = bool:
  {if (stat_holder:=status(p,HT)).!= then return stat_holder > 0 fi;} {nothing in Spin(4,4)}
  if old_testing_flag then return is_unitary_to_ht_big_SIMPLE(p,HT) fi;
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_to_ht_big_SIMPLE_interrupt_Ufirst, p = ",p, ", HT = ",HT)
  fi;
  let G = p.real_form, start = elapsed_ms()
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary_to_ht(p,HT) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, to_ht_time = int: u_predictor(p,HT), u_time = int: u_predictor(p,-1),
       test_time = int:0, deformed_flag_hold = deformed_hash_flag
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi;
	    deformed_hash_flag:=true
  then () = while result = 0
       	    do if{A} u_time < {5*}to_ht_time
	       then let start_u = elapsed_ms()
	       	    then form = hermitian_form_irreducible(p,u_factor*u_time)
	       	    {then () = push_deform_flag:=true;}
		    in result := is_pure(to_ht(form,HT));
		       test_time:= elapsed_ms() - start_u;
	       	       if test_interrupt_verbose
		       then prints("result ",result," from is_unitary, in time ",
				   print_time_string(test_time), "; total = ",
				   print_time_string(elapsed_ms() - start))
		       fi;
	       	       if is_pure(form).> {from here result.!=}
		       then big_unitary_hash.umatch(p)
		       elif is_pure(form).<
		       then big_unitary_hash.numatch(p)
		       fi;
	       	       if result.<
		       then {big_unitary_hash.numatch_height(p,HT);}
		       	    break
		       elif result.>
		       then add_to_u_to_ht(p,HT)
		       else u_time := u_predictor(p,-1)
		       fi {result.<}
	       fi; {A} {u_time < {5*}to_ht_time}
	       if{B} to_ht_time < 5*u_time
	       then let start_to_ht = elapsed_ms()
	       	    {then () = push_deform_flag:=true;}
		    in result := is_unitary_to_ht_big_SIMPLE_interrupt(p,HT,to_ht_factor*to_ht_time);
	       	       test_time:=elapsed_ms() - start_to_ht;
	       	       if test_interrupt_verbose
	       	       then prints("result ", result, " from to_ht ",HT,", in time ",
			      print_time_string(test_time),
			      "; total = ", print_time_string(elapsed_ms() - start))
		       fi;
	       	       if result.<
	       	       then {big_unitary_hash.numatch_height(p,HT)}
			     break
		       elif result.>
		       then add_to_u_to_ht(p,HT)
		       else to_ht_time:= u_predictor(p,HT)
			     {if test_interrupt_verbose
	       	       	     then prints("  to_ht_time now ", print_time_string(to_ht_time))
			     fi}
		  	fi { result.<}
		fi {B} {to_ht_time < 5*u_time}
	    od
   in deformed_hash_flag:=deformed_flag_hold;
      if test_interrupt_verbose
      then prints("Finish is_unitary_to_ht_big_SIMPLE_interrupt_Ufirst, time ",
      	   	  print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      if result > 0
      then true
      elif result < 0
      then false
      else is_unitary_to_ht_big_SIMPLE(p,HT) {shouldn't come to here}
      fi

{set is_unitary_to_ht_big_SIMPLE_interrupt_Ufirst_new(Param p, int HT) = bool:
  if status(p,HT).!= then return status(p,HT) > 0 fi;
  if old_testing_flag then return is_unitary_to_ht_big_SIMPLE(p,HT) fi;
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_to_ht_big_SIMPLE_interrupt_Ufirst, p = ",p, ", HT = ",HT)
  fi;
  let G = p.real_form, start = elapsed_ms()
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary_to_ht(p,HT) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then ht = int: height(p)
  then () = if next_heightC_flag
       	    then min(HT,next_heightC(p,ht))
       	    else HT
	    fi
  then result = 0, to_ht_time = int: u_predictor(p,ht), u_time = int: u_predictor(p,-1),
       test_time = int:0, deformed_flag_hold = deformed_hash_flag
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi;
	    deformed_hash_flag:=true
  then () = while result = 0
       	    do if{A} u_time < {5*}to_ht_time
	       then let start_u = elapsed_ms()
	       	    then form = big_unitary_hash.sig_entry_interrupt({hermitian_form_irreducible(}p,-1,u_factor*u_time)
	       	    {then () = push_deform_flag:=true;}
		    in result := is_pure(to_ht(form,HT));
		       test_time:= elapsed_ms() - start_u;
	       	       if test_interrupt_verbose
		       then prints("result ",result," from is_unitary, in time ",
				    print_time_string(test_time), "; total = ",
				    print_time_string(elapsed_ms() - start))
		       fi;
	       	       { if is_pure(form).> {from here result.!=}
		       then big_unitary_hash.umatch(p)
		       elif is_pure(form).<
		       then big_unitary_hash.numatch(p)
		       fi;}
	       	       if result.<
		       then {big_unitary_hash.numatch_height(p,HT);}
		       	    break
		       elif result.>
		       then add_to_u_to_ht(p,HT)
		       else u_time := u_predictor(p,-1)
		       fi {result.<}
	       fi; {A} {u_time < {5*}to_ht_time}
	       if{B} to_ht_time < 5*u_time
	       then let start_to_ht = elapsed_ms()
	       	    {then () = push_deform_flag:=true;}
		    in result := is_pure(big_unitary_hash.sig_entry_interrupt(p,HT,u_factor*u_time));
	       	       test_time:=elapsed_ms() - start_to_ht;
	       	       if test_interrupt_verbose
	       	       then prints("result ", result, " from to_ht ",ht,", in time ",
			        print_time_string(test_time), "; total = ",
				print_time_string(elapsed_ms() - start))
		       fi;
	       	       if result.<
	       	       then {big_unitary_hash.numatch_height(p,ht);} break
		       elif result.>
		       then add_to_u_to_ht(p,ht);
		       	    if ht < HT
			    then ht:= min(HT,next_heightC(p,ht));
			     	 result:=0;
				 to_ht_time:= u_predictor(p,ht)
			    else break
			    fi
			else to_ht_time:= u_predictor(p,ht)
		  	fi { result.<}
		fi {B} {to_ht_time < 5*u_time}
	    od
   in if test_interrupt_verbose
      then prints("Finish is_unitary_to_ht_big_SIMPLE_interrupt_Ufirst, time ",
      	   	  print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      if result > 0
      then true
      elif result < 0
      then false
      else is_unitary_to_ht_big_SIMPLE(p,HT) {shouldn't come to here}
      fi}

set is_unitary_to_ht_big_SIMPLE_interrupt_TOHTfirst(Param p, int HT) = bool:
  if (stat_holder:=status(p,HT)).!= then return stat_holder > 0 fi;
  {save 100/7200 Spin(4,4)}
  if old_testing_flag then return is_unitary_to_ht_big_SIMPLE(p,HT) fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_to_ht_big_SIMPLE_interrupt_TOHTfirst, p = ",p, ", HT = ",HT)
  fi;
  let G = p.real_form, start = elapsed_ms() {, (LAM,NU,GAM) = low(p)}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary_to_ht(p,HT) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, to_ht_time = int: u_predictor(p,HT), deformed_flag_hold = deformed_hash_flag,
       u_time = int: u_predictor(p,-1), test_time = int:0
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi;
	    deformed_hash_flag:=true
  then () = while result = 0
       	    do if{A} to_ht_time < 5*u_time
	       then let start_to_ht = elapsed_ms()
	       	    then () = result := is_unitary_to_ht_big_SIMPLE_interrupt(p,HT,to_ht_factor*to_ht_time);
	       	              test_time:=elapsed_ms() - start_to_ht;
	       	    	      if test_interrupt_verbose
	       	       	      then prints("result ", result, " from to_ht ",HT,", in time ",
			      	   print_time_string(test_time),
				   "; total = ", print_time_string(elapsed_ms() - start))
			      fi
	       	    in if result.<
		       then {big_unitary_hash.numatch_height(p,HT);}
		       	    break
		       elif result.>
		       then add_to_u_to_ht(p,HT);
		       	    break
		       else to_ht_time := u_predictor(p,HT);
			    if test_interrupt_verbose
			    then prints("  Predicted to_ht_time now ",print_time_string(to_ht_time))
			    fi
		       fi
	       fi{A}; {to_ht_time < 5*u_time}
	       if{C} u_time < {5*}to_ht_time
	       then let start_u = elapsed_ms()
	       	    then form = big_unitary_hash.sig_entry_interrupt{hermitian_form_irreducible}
		    	 (p, -1, u_factor*u_time)
		    then () = {push_deform_flag:=true;}
		    	      result := is_pure(to_ht(form,HT));
		       	      test_time:= elapsed_ms() - start_u;
	       		 if test_interrupt_verbose
		       	 then prints("result ",result," from is_unitary, in time ",
			      print_time_string(test_time),
				   "; total = ", print_time_string(elapsed_ms() - start))
			 fi
	       	    in if result.= {no result from is_unitary}
	       	       then u_time:=u_predictor(p,-1);
			    	 if test_interrupt_verbose
			      	 then prints("  Predicted u_time now ",print_time_string(u_time))
			      	 fi
			elif is_pure(form).> {from here result \ne 0}
			then {big_unitary_hash.umatch(p);}
			     break
			elif is_pure(form).<
			then {big_unitary_hash.numatch(p);}
			     break
			fi;
			if result.<
			then {big_unitary_hash.numatch_height(p,HT);}
			     break
			elif result.>
			then add_to_u_to_ht(p,HT);
			     break
			fi
	       fi{C}{;} {u_time < {5*}to_ht_time}
	       {if result = -1
	       then big_unitary_hash.numatch_height(p,HT)
	       elif result = 1
	       then add_to_u_to_ht(p,HT)
	       else ()
	       fi}
	    od
   in deformed_hash_flag := deformed_flag_hold;
      if test_interrupt_verbose
      then prints("Finish is_unitary_to_ht_big_SIMPLE_interrupt_TOHTfirst, time ",
      	   	  print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      if result > 0
      then true
      elif result < 0
      then false
      else is_unitary_to_ht_big_SIMPLE(p,HT) {shouldn't come to here}
      fi

{turns out to be slower than original??}
{set is_unitary_to_ht_big_SIMPLE_interrupt_TOHTfirst_new(Param p, int HT) = bool:
  if status(p,HT).!= then return status(p,-1) > 0 fi;
  if old_testing_flag then return is_unitary_to_ht_big_SIMPLE(p,HT) fi;
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_to_ht_big_SIMPLE_interrupt_TOHTfirst, p = ",p, ", HT = ",HT)
  fi;
  let G = p.real_form, start = elapsed_ms() {, (LAM,NU,GAM) = low(p)}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary_to_ht(p,HT) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then ht = int: height(p), deformed_flag_hold = deformed_hash_flag
  then () = if next_heightC_flag
       	    then min(HT,next_heightC(p,ht))
       	    else HT
	    fi;
	    deformed_hash_flag:=true
  then result = 0, to_ht_time = int: u_predictor(p,ht),
       u_time = int: u_predictor(p,-1), test_time = int:0
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi
  then () = while result = 0
       	    do if{A} to_ht_time < 5*u_time
	       then let start_to_ht = elapsed_ms()
	       	    {then () = push_deform_flag:=true;}
		    in result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,to_ht_factor*to_ht_time);
	       	       test_time:=elapsed_ms() - start_to_ht;
	       	       if test_interrupt_verbose
	       	       then prints("result ", result, " from to_ht ",ht,", in time ",
			      	   print_time_string(test_time), "; total = ",
				   print_time_string(elapsed_ms() - start))
		       fi;
	       	       if result.<
		       then {big_unitary_hash.numatch_height(p,ht);} break
		       elif result.>
		       then add_to_u_to_ht(p,HT);
		       	    if ht < HT
			    then ht:= min(HT,next_heightC(p,ht));
			       	 result:=0;
			       	 to_ht_time:= u_predictor(p,ht)
			    else break
			    fi
		       else to_ht_time := u_predictor(p,ht);
			    if test_interrupt_verbose
			    then prints("  Predicted to_ht_time now ",print_time_string(to_ht_time))
			    fi
		       fi
	       fi{A}; {to_ht_time < 5*u_time}
	       if{C} u_time < {5*}to_ht_time
	       then let start_u = elapsed_ms()
	       	    then form =big_unitary_hash.sig_entry_interrupt{hermitian_form_irreducible}
		    (p, -1, u_factor*u_time)
		    then () = {push_deform_flag:=true;}
		    	      result := is_pure(to_ht(form,HT));
		       	      test_time:= elapsed_ms() - start_u;
	       		 if test_interrupt_verbose
		       	 then prints("result ",result," from is_unitary, in time ",
			      print_time_string(test_time),
				   "; total = ", print_time_string(elapsed_ms() - start))
			 fi
	       	    in if result.= {no result from is_unitary}
	       	       then u_time:=u_predictor(p,-1);
			    if test_interrupt_verbose
			    then prints("  Predicted u_time now ",print_time_string(u_time))
			    fi
			elif is_pure(form).> {from here result \ne 0}
			then {big_unitary_hash.umatch(p);}
			     break
			elif is_pure(form).<
			then {big_unitary_hash.numatch(p);}
			     break
			fi;
			if result.<
			then {big_unitary_hash.numatch_height(p,HT);}
			     break
			elif result.>
			then add_to_u_to_ht(p,HT);
			     break
			fi
	       fi{C}{;} {u_time < {5*}to_ht_time}
	       {if result = -1
	       then big_unitary_hash.numatch_height(p,HT)
	       elif result = 1
	       then add_to_u_to_ht(p,HT)
	       else ()
	       fi}
	    od
   in deformed_hash_flag:=deformed_flag_hold;
      if test_interrupt_verbose
      then prints("Finish is_unitary_to_ht_big_SIMPLE_interrupt_TOHTfirst, time ",
      	   	  print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      if result > 0
      then true
      elif result < 0
      then false
      else is_unitary_to_ht_big_SIMPLE(p,HT) {shouldn't come to here}
      fi}


set is_unitary_to_hts_big_SIMPLE_interrupt_TOHTfirst(Param p, [int] HTs) = bool:
  if (stat_holder:=status(p,HTs~[0])).!= then return stat_holder > 0 fi;
  {remove  status saves 200/7200 Spin(4,4), but requires repeating tests in Spin(5,5).
  Better kept.}
  if old_testing_flag then return is_unitary_to_hts{_big_SIMPLE}(p,HTs) fi; {should reorder to use big_simple}
  let (,,GAM) = low(p) in HTs:= for ht in HTs do if ht <= GAM do ht fi od.##;
  if #HTs = 0 then return is_unitary_hash_big_SIMPLE(p) fi;
  if #HTs = 1 then return is_unitary_to_ht_big_SIMPLE_interrupt_TOHTfirst(p, HTs[0]) fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if test_interrupt_verbose
  then prints(new_line,"Starting is_unitary_to_hts_big_SIMPLE_interrupt_TOHTfirst, p = ",p, ", HTs = ",HTs)
  fi;
  let G = p.real_form, start = elapsed_ms()
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary_to_hts(p,HTs) {prints("FPP DANGER TO HTs at ",p)}
	    fi
  then () = p := herm_center(p)
  then result = 0, HTfirst = HTs[0], HTlast = HTs~[0], deformed_flag_hold = deformed_hash_flag
  then to_ht_time = int: u_predictor(p,HTfirst), u_time = int: u_predictor(p,-1), test_time = int:0
  then level = 0, HT = HTfirst
  then () = if test_interrupt_verbose
       	    then prints("starting to_ht_time = ", print_time_string(to_ht_time),
	    	        ", u_time = ", print_time_string(u_time))
	    fi
  then () = while result = 0 {or (result = 1 and HT < HTlast)}
       	    do if{A} to_ht_time < 5*u_time
	       then let start_to_ht = elapsed_ms()
	       	    then () = {push_deform_flag:=true;}
			      result := is_unitary_to_ht_big_SIMPLE_interrupt(p,HT,to_ht_factor*to_ht_time);
	       		      test_time:=elapsed_ms() - start_to_ht;
	       		      if test_interrupt_verbose
	       	       	      then prints("result ", result, " from to_ht ",HT,", in time ",
			      	   print_time_string(test_time),
				   "; total = ", print_time_string(elapsed_ms() - start))
			      fi
	       	    in if result.>
	       	       then add_to_u_to_ht(p,HT);
		       	    if HT=HTlast
			    then break
			    else level +:= 1;
			      	 HT :=HTs[level];
				 result:=0;
				 to_ht_time:= u_predictor(p,HT);
				 if test_interrupt_verbose
			      	 then prints("  Predicted to_ht_time now ",
					     print_time_string(to_ht_time))
			      	 fi
			     fi {HT=HTLAST}
			elif result.<
	       	        then big_unitary_hash.numatch_height(p,HT);
			     break
			fi {result.>}
		fi; {A} {to_ht_time < 5*u_time}
	        if {B} u_time < {5*}to_ht_time
		then let start_u = elapsed_ms()
		     {then () = push_deform_flag:=true}
		     {then depth = is_unitary_depth(p,u_factor*u_time)}
		     then form = big_unitary_hash.sig_entry_interrupt(p,-1 ,u_factor*u_time)
		     {then form = hermitian_form_irreducible(p,u_factor*u_time)}
	       	     in test_time:= elapsed_ms() - start_u;
	       		if test_interrupt_verbose
		       	then prints("result ",result:=is_pure(to_ht(form,HTlast))," from is_unitary, in time ",
				      	 print_time_string(test_time),
				   "; total = ", print_time_string(elapsed_ms() - start))
			fi;
			if result != 0 then break fi;
			u_time:=u_predictor(p,-1);
			if test_interrupt_verbose
			then prints("  Predicted u_time now ",print_time_string(u_time))
			fi
		 fi{B} {u_time < {5*}to_ht_time}
	    od
   in deformed_hash_flag := deformed_flag_hold;
      if test_interrupt_verbose
      then prints("Finish is_unitary_to_hts_big_SIMPLE_interrupt_TOHTfirst, time ",
      	   	  print_time_string(elapsed_ms() - start), " result ",result,new_line)
      fi;
      if result > 0
      then true
      elif result < 0
      then false
      else is_unitary_to_ht_big_SIMPLE(p,HTlast) {shouldn't come to here}
      fi


{This was in FPP_lambdas.at; moved here to use recording is_unitary tests}
{1 means unitary, -1 nonunitary, 0 no test}
set ind_test(Param p) = int:
    let icp = ind_cand_params(p).##, G = p.real_form
    then () = for pL in icp
       	      do if real_induce_irreducible(pL,G) = 1*p
       	  	 then if all(for dpL in derived_factor_params0(pL) do @bool:
		 is_unitary_test_big_SIMPLE_interrupt(dpL) od)
		 {is_unitary_hash_big_SIMPLE_weak(dpL) od)}
		 {is_unitary(dpL) od)}
		      then return 1
		      else return -1
		      fi
	  	 else if all(for dpL in derived_factor_params0(pL) do @bool:
		 is_unitary_test_big_SIMPLE_interrupt(dpL) od)
		 {is_unitary_hash_big_SIMPLE_weak(dpL) od)}
		 {is_unitary(dpL) od)}
		      then return 1
		      else 0
		      fi
		 fi
	      od
   in 0

set is_u_ind(Param p) = bool:
    let icpd = ind_cand_paramsD(p), G = p.real_form
    in any(for list in icpd do @bool: all(for dpL in list do is_unitary(dpL) od) od)

{list is meant to be a not large collection of Param's with the same unitarity
status; test interruptibly in succession until something gives}
set mult_is_unitary([Param] list) = bool:
    if #list = 0 then return true fi;
    if #list = 1 then return is_unitary_test_big_SIMPLE_interrupt(list[0]) fi;
    let next_time = interrupt_base_time
    then answer = int:0
    then () = while answer = 0
    	      do for p in list
	      	 do let this = is_unitary_test_big_SIMPLE_interrupted(p, next_time)
		    in if this.!=
		       then answer := this;
		       	    break
		       fi
		 od;
		 if answer.= then next_time:=2*next_time fi;
		 if next_time > 100000
		 then return any (for p in list
		      	     	  do @bool: is_unitary_test_big_SIMPLE_interrupt(p)
				  od)
		 fi
	      od
    in answer.>

set wiggle_is_unitary(Param p, KGBElt x, ratvec lambda, LocalVertexData Lvd) = bool:
    {if (stat_holder:=status(p,-1))!= 0 then return stat_holder > 0 fi;} {none Spin(4,4)}
    p:= herm_center(p);
    let theta = p.x.involution, G = p.real_form
    then delta = G.distinguished_involution, gamma = p.infinitesimal_character
    then lamthlam = ratvec_as_vec((1+theta)*lambda)
    then Aff_theta(ratvec v) =  -theta*v + lamthlam
    then FV = for v in face_verts(G,gamma) do (v+delta*v)/2 od
    then local_vert_nums = [int]:
    	 for v in FV
    	 do Lvd.lookup((v+Aff_theta(v))/2)
	 od.sort_u
    then d = #local_vert_nums - 1
    then () = assert(@:gamma = face_bary(Lvd,local_vert_nums),
	       	    		 "bad Lvd or local_vert_nums")
    then vert_subs = power_set(local_vert_nums)[1:2^(d+1)] {omit empty, include full set}
    then deform_cands = [ratvec]:
	 for sub in vert_subs
	 do face_bary(Lvd,sub)
	 od
    then CF = character_formula(p)
    then defs = [[Param]]:
	 for gammabd in deform_cands
	 do  monomials(composition_series(wiggle(CF, gammabd)))
	 od
    then helpers = [Param]:
	 for list in defs
	 do if #list = 1
	    do list[0]
	    fi
	 od.##
	     {these are Params whose unitarity is equivalent to that of p}
    then () = assert(@:#helpers > 0,"missing p from helpers?")
    then result = false
    then () = if any(for q in helpers do big_unitary_hash.uhash(G).lookup(q).>= od)
	      then result :=true
	      elif any(for list in defs
		       do any(for q in list do @bool: big_unitary_hash.nuhash(G).lookup(q).>= od)
		       od)
	      then result := false
	      else result := mult_is_unitary(helpers)
	      fi
     in if result
	then for list in defs
	     do for q in list
	     	do big_unitary_hash.uhash(G).match(q)
	     	od
	     od
	 else big_unitary_hash.numatch(p)
	 fi;
	 result

set wiggle_is_unitary(Param p) = bool:
    let x = p.x, lambda = p.lambda
    then Lvd = Lvd(x,lambda)
    in wiggle_is_unitary(p,x,lambda,Lvd)

set to_hts_count_mat = null(10,10)
set to_hts_count = null(10)

{Ns should be increasing string of heights > height(p).}
set is_unitary_to_hts_big_SIMPLE_interrupt(Param p,[int] Ns, int time) = bool:
    if print_int_flag then prints("N = ",Ns, " p = ",p) fi;
    if #Ns = 0 or Ns~[0] < height(p) then return true fi;
    {if not big_unitary_hash.nu_height_lookup_bool(p, Ns~[0]) then return false fi;}
    {if (stat_holder:=status(p, Ns~[0]))!= 0 then return stat_holder > 0 fi;} {none Spin(4,4)}
    let k = u_to_ht_hash.lookup(p) in if k.>= and u_to_ht_hts[k] >= Ns~[0] then return true fi;
    let j0 = first(for N in Ns do N>= height(p) od)
    then () = Ns:=Ns[j0:]
    then () = for N@i in Ns
	     do let result = 0, which_flag = low(p,N), start = elapsed_ms()
		then () = while result = 0
			  do {push_deform_flag:=true;}
			     result:= if which_flag
				     then is_unitary_to_ht_MvL(p,N,time)
				     else case hermitian_form_irreducible(p,time)
					  | timed_out: 0
					  | done(result):
					    if is_pure((to_ht(result,Ns~[0])))
					    then 1
					    else -1
					    fi
					  esac
				     fi;
				if print_int_flag then prints("in to_hts, time = ", time, ", which_flag = ",
				which_flag, ", elapsed = ", elapsed_ms() - start) fi;
			     {unitary_test_counter.use(); this is done in the calls above}
			     if not which_flag and not result.= then break fi;
			     if which_flag then time := 2*time fi;
			     which_flag := not which_flag
			  od {while result}
		in if result<0
		   then big_unitary_hash.numatch_height(p,Ns~[0]); return false
		   fi
	     od
     in true

{meant to be used for G simple}
{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big_SIMPLE(Param p,[int] Ns) = bool:
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if #Ns = 0 or Ns~[0] < height(p) then return true fi;
  {if (stat_holder:=status(p, Ns~[0])).!= then return stat_holder > 0 fi;}
  let j0 = first(for N in Ns do N>= height(p) od)
  then () = Ns:=Ns[j0:]
  then G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary_to_hts(p,Ns) {prints("FPP DANGER TO HT at ",p)}
	    fi
  in is_unitary_to_hts_big_SIMPLE_interrupt(p, Ns, interrupt_base_time)


{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big (Param p,[int] Ns) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if #Ns = 0 then return is_unitary_hash_big(p) fi;
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_to_hts_big_SIMPLE(pd,Ns) od)


{ONLY for G simple}
{ compute Hermitian form to height N; if it's positive, then compute full form }
set is_unitary_test_big_SIMPLE(Param p, int N) = bool:
    {if (stat_holder:=status(p,N)).!= then return stat_holder > 0 fi;}
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    if N < height(p) then return is_unitary_hash_big_SIMPLE(p) fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
	      then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	      fi
    in let P = big_unitary_hash.sig_entry(p,N)
       in if not is_pure(P)
	  then false
	  else is_unitary_hash_big_SIMPLE(p)
	  fi

{ONLY for G simple}
{ like previous, with list of heights }
set is_unitary_test_big_SIMPLE (Param p, [int] Ns) = bool:
  if #Ns = 0 then return is_unitary_hash_big_SIMPLE(p) fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  {if (stat_holder:=status(p,Ns~[0])).!= then return stat_holder > 0 fi;}
  {nothing Spin(4,4)}
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then  return is_unitary{_test}(p{,Ns}) {prints("FPP DANGER TEST at ",p)}
	    fi
  in for N in Ns
     do if not is_pure(big_unitary_hash.sig_entry(p,N))
	then return false
	fi
     od;
     is_unitary_hash_big_SIMPLE(p)

set is_unitary_test_big(Param p, int N) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_test_big_SIMPLE(pd,N) od)

set is_unitary_test_big(Param p, [int] Ns) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_test_big_SIMPLE(pd,Ns) od)

{ONLY for G simple}
{use the first m heights from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p,int m) = bool:
  {if (stat_holder:=status(p,-1)) != 0 then return stat_holder > 0 fi;} {none Spin(4,4)}
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
	      then return is_unitary(p) {prints("FPP DANGER DEF TEST at ",p)}
	      fi
    in if low(p, height(p))
       then let (def,flag)= deform_hts(p,m)
	    in if flag
	       then (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) and
		    is_unitary_to_hts_big_SIMPLE(p,def)
	       else is_unitary_test_big_SIMPLE(p,def)
	       fi
       else is_unitary_hash_big_SIMPLE(p)
       fi

set is_unitary_def_test_big(Param p,int m) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_def_test_big_SIMPLE(pd,m) od)

{ONLY for G simple}
{use the first height from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p) = bool:
    is_unitary_def_test_big_SIMPLE(p,1)

set is_unitary_def_test_big(Param p) = bool:
    is_unitary_def_test_big(p,1)

{ONLY for G simple}
set is_unitary_next_big_SIMPLE(Param p) = bool:
    if (not is_hermitian(p)) then return false fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let G = p.real_form
    then (LAM,NU,) = low(p)
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
	      then if NU > LAM*nu_frac
		   then let n=next_heightB(p)
			in if (n+1).=
			   then return true
			   elif is_unitary_to_ht_big(p,n)
			   then return is_unitary_hash_big_SIMPLE(p)
			   else big_unitary_hash.numatch(p); return false {NOT unitary_to_ht}
			   fi {n=-1}
		   else return is_unitary_hash_big_SIMPLE(p)
		   fi {NU > LAM}
	       fi {not FPP_flag}
    {then () = p := herm_center(p)}
    in if NU > LAM*nu_frac
       then let n=next_heightB(p)
	    in  if (n+1).=
		then true
		elif is_unitary_to_ht_big_SIMPLE(p,n)
		then is_unitary_hash_big_SIMPLE(p)
		else big_unitary_hash.numatch(p); false {NOT unitary_to_ht}
		fi {n=-1}
	else is_unitary_hash_big_SIMPLE(p)
	fi {NU > LAM}

set is_unitary_next_big(Param p) = bool:
    if (not is_hermitian(p)) then return false fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_next_big_SIMPLE(pd) od)

set theta_induce_signature(Param pL, RealForm G) = KTypePol:
    theta_induce_K(hermitian_form_irreducible_big(pL),G)

set theta_induce_signature_to_ht(Param pL, int DL, RealForm G) = KTypePol:
    theta_induce_K(hermitian_form_irreducible_to_ht_big(pL,DL),G)

{whether to use the new Davis/Mason-Brown criterion saying FPP reps on an outside
face of FPP might have to be coh ind}
set is_FPP_unitary_flag = false

{IF using test, whether to stop after easy part}
set Lucas_fast_flag = true


{Use Davis/Mason-Brown criterion. First bool says whether the test applies; second gives
result of test. Second is meaningful only if first is true; I guess make result (false,false)
otherwise?}
set is_FPP_unitary(Param p) = (bool,bool):
    if not is_FPP_unitary_flag then return (false,false) fi;
    if (not is_hermitian(p)) then return (true,false) fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return (true,false) fi;
    let G = (p:= herm_center(p)).real_form
    then gamma = p.infinitesimal_character
    then alphavs = for alphav@j in G.simple_coroots
		  do if gamma*alphav < 1
		     then [j]
		     elif gamma*alphav > 1
		     then []
		     else let rdi = integrality_datum(G,gamma)
			  then ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
     then () = if #alphavs = G.semisimple_rank
	       then return (false,false) {say we don't know}
	       fi
     then Q = KGPElt:(alphavs, p.x) {p now must be good range coh ind from Q}
     then rhou = Q.rho_u
     then () = if((p.x.involution-1)*rhou).!=
	       then return (true,false)
	       fi
     then () = if Lucas_fast_flag
	       then return (false,false)
	       {in this case question reduces to L, but we choose not to do
	       calculation on L}
	       fi
     then L = Q.Levi
     then xL = inverse_embed_KGB(p.x,L)
     then pL = parameter(xL,p.lambda - rhou, p.nu)
     then () = assert(@:p = first_param(theta_induce_standard(pL,G)),"screwed up pL!")
     then derpLs = derived_factor_params0(pL)
     in (true, all(for derpL in derpLs
		   do @bool:
		      {let () = FPP_unitary_hash_bottom_layer([(pL.x,pL.lambda)])
		      in} is_unitary_hash_big_SIMPLE(derpL)
		   od))

{First bool says whether the test applies; second gives result of
test. Second is meaningful only if first is true; make result
(false,false) otherwise}
{Can allow fancy_tester to use FPP_unitary_hash}
set is_FPP_unitary(Param p, (Param -> bool) fancy_tester ) = (bool,bool):
    if not is_FPP_unitary_flag then return (false,false) fi;
    if (not is_hermitian(p)) then return (true,false) fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return (true,false) fi;
    let G = (p:= herm_center(p)).real_form
    then gamma = p.infinitesimal_character
    then rdi = integrality_datum(G,gamma)
    then alphavs = for alphav@j in G.simple_coroots
		  do if gamma*alphav < 1
		     then [j]
		     elif gamma*alphav > 1
		     then []
		     else let ji = coroot_index(rdi,alphav)
			  in if is_member_sorted(tau(p))(ji)
			     do j
			     fi
		     fi
		  od.##
     then () = if #alphavs = G.semisimple_rank
	       then return (false,false) {say we don't know}
	       fi
     then Q = KGPElt:(alphavs, p.x) {p now must be good range coh ind from Q}
     {then ()= prints("have Q = ",Q," in is_FPP_unitary")}
     then rhou = Q.rho_u
     then () = if((p.x.involution-1)*rhou).!=
	       then return (true,false)
	       fi
     then () = if Lucas_fast_flag
	       then return (false,false) {say we don't know}
	       fi
     then L = Q.Levi
     {then () = prints("in isfppu(fancy) at line 1834, p = ",p)}
     then xL = inverse_embed_KGB(p.x,L)
     then pL = parameter(xL,p.lambda - rhou, p.nu)
     then () = assert(@:p = first_param(theta_induce_standard(pL,G)),"screwed up pL!")
     then derpLs = derived_factor_params0(pL)
     in (true, all(for derpL in derpLs
		   do @bool: fancy_tester(derpL)
		   od))

set KUKU_flag = true

{if false, suppress printing of report after an FPP_unitary_hash* job}
{need this here for recursive application of smaller FPP's in fancy_tester}
set FPP_report_flag = true

{For each list of faces in FVKH, indices of faces for which the corresponding parameter is known
(by Uhash) to be unitary}
set KU(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] FVKH, Param_hash Uhash,
 (Param->bool) fancy_tester) = [vec]:
    {prints("in KU",fancy_tester);}
    let FPP_report_flag_hold = FPP_report_flag
    then () = FPP_report_flag :=false
    then answer =
	 for FVKHd@d in FVKH
	 do for vlong@j in FVKHd
	    do let verts = vlong[:d+1], G = x.real_form
	       then ps = monomials(finalize(parameter(x,lambda, face_bary(Lvd,verts))))
	       in if all(for p in ps do (Uhash.lookup(p)).>= od)
		  then [j]
		  elif all(for p in ps
			   do let (x,y) = is_FPP_unitary(p, fancy_tester)
			      then () = if x {whether the FPP test is applicable}
					then if y {result of FPP test}
					     then big_unitary_hash.uhash(G).match(p)
					     else big_unitary_hash.numatch(p)
					     fi
					fi
			      in x and y
			  od)
		  then [j]
		  else []
		  fi
	    od.##
	 od
    then () = FPP_report_flag:=FPP_report_flag_hold
    in answer

set KU(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] FVKH, Param_hash Uhash) =
[vec]:
    KU(x,lambda,Lvd,FVKH,Uhash, is_unitary_hash_big_SIMPLE@Param)

{takes the known unitaries from unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, (Param->bool) fancy_tester) = [vec]:
    if KUKU_flag then return KU(x,lambda, Lvd, LFDKH, Uhash, fancy_tester) fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1])))}
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
	  do if p.nu.=
	     then [j]
	     else let qs = monomials(finalize(p)) {save 2900/7200 in Spin(4,4)}
		  in if all(for q in qs do @bool: {status(q,-1) > 0} Uhash.lookup(q).>= od)
		     then [j]
		     else []
		     fi
	     fi
	  od.##
       od

set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
   known_unitaries(Uhash, x, lambda, Lvd, LFDKH, is_unitary_hash_big_SIMPLE@Param)


{Here UhashLocal is assumed to consist of Param's at (x,lambda)}
{this misses (in local_testK_level) unitary Param's that finalize to different x;
those are caught by local_testK_hash}
set known_unitaries(Param_hash UhashLocal, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
					      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = UhashLocal.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
	 do let p = UhashLocal.index(k)
	    then list = local_vertices(p)
	    in if #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
		    then m = lookups[#list-1](local_verts)
		    then () = assert(@:m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]#:=m
		    in ()
	       fi
	 od
     in out

{takes the known non-unitaries from non-unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
{set known_non_unitaries(Param_hash NUhash, KGBElt x, ratvec lambda, VertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let qs = monomials(finalize(p))
	     in if all(for q in qs do @bool: NUhash.lookup(q).>= od)
		then [j]
		else []
		fi
	  od.##
       od}
{whether to use deformation in looking for evidence that a Param is not unitary}
{TRUE fails in E6_q one_level at x = 723, lambda = [1,1,0,1,1,1]/1}
set wiggle_flag = false

{whether Param's appearing by deforming the irreducible at the face defined by verts to its
 codimension one faces give nonunitarity}
{set nu_wiggle(KGBElt x, ratvec lambda, vec verts, LocalVertexData Lvd, int HT) = bool:
    if #verts = 1 then return [] fi;
    let p = parameter(x,lambda,face_bary(Lvd,verts)), d = #verts -1
    then CF = character_formula_to_height(1*p,HT)
    then qs = monomials(composition_series_to_ht(( sum(x.real_form,
						for k:d+1
						do wiggle(CF, face_bary(Lvd,verts[:k]##verts[k+1:]))
						od)), HT - 1))
    in any(for q in qs
	   do @bool: not is_unitary_to_ht_big_SIMPLE(q,HT)
	   od)}

{list locations in LFDKH of reps known to be non-unitary to HTs}
set known_non_unitaries_wiggle_old(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, [int] HTs) = [vec]:
    if #LFDKH = 0 or #LFDKH[0] = 0 then return [] fi;
    let ps = for d: #LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    then answer = [vec]: for v:#LFDKH do vec: [] od
    then HT = HTs~[0], H0 = height(ps[0][0])
    then lookups = lookups(LFDKH) {dth term finds a d-face in LFDKH[d]}
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let pdef =
		 if not is_final(p) or d=0
		 then monomials(p)
		 else let CF = character_formula_to_height(1*p,HT)
		      then verts = LFDKH[d][j][:d+1]
		      in  monomials(composition_series_to_ht((sum(x.real_form,
					    for k:d+1
					    do wiggle(CF, face_bary(Lvd,verts[:k]##verts[k+1:]))
					    od)), HT - 1))
		     {to have an interesting test to HT, terms should have strictly smaller HT}
		 fi {now pdef consists of final Params that must be unitary to HT if p is}
	     in if any(for q in pdef
		       do @bool: (status(q,HT) < 0)
		       {not big_unitary_hash.nu_height_lookup_bool(q,HT))}
			  {or (height(q) > H0 and  status(q,HT) = 0
			      and (not is_unitary_to_hts_big_SIMPLE(q,HTs)))}
		       od) {CONCERN if HTs[0] < H0?}
		then [j]
		else []
		fi
	  od.## {for p@j in ps[d]; this is vec of known nonunitary j for dim d}
       od {for d:#LFDKH}

{
set wiggle_test(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH,
		int d, int j, [int] HTs) = bool:
    if d = 0 then return true fi;
    let p = parameter(x,lambda,face_bary(Lvd, v[:d+1]))
    then lookup = lookups(LFDKH)[d-1], HT HTs~[0]
    then CF = character_formula_to_height(1*p,HT)
    then verts = LFDKH[d][j][:d+1]
    then short_verts = for k:d+1
		       do verts[:k]##verts[k+1:]
		       od {list of vertex sets for faces}
    then short_js = for sv in short_verts
		    do lookup(sv)
		    od
    in if red_count_flag
       then let redjis = [int]:
		for ji in short_js
		do if LFDKH[d-1][ji][d-1] > LFDKH[d][j][d]
		   then [ji]
		   else []
		   fi {rcs don't match}
		od
       then if #redjis > 0
	    then all(for ji in red_jis
	       do LFDKH[d-1][ji][d] = LFDKH[
		 in for sv in short_verts
		     do let pdefi = monomials(composition_series_to_ht(
					 wiggle(CF, face_bary(Lvd,sv)) , HT - 1))
			in if any (for q in pdefi
				  do @bool: big_unitary_hash.nu_height_lookup_bool(q,HT)
				      or (height(q) > H0 and not is_unitary_to_hts_big_SIMPLE(q,HTs))
				  od) {CONCERN if HTs[0] < H0?}
			   then answer[d]#:= j;
				for ji in short_js
				do if {to_ht(pol_hash.index(LFDKH[d][j][d+red_shift+1]),HT) =
				      to_ht(pol_hash.index(LFDKH[d-1][ji][d+red_shift]),HT)}
				      LFDKH[d][j][d+red_shift+1:d+red_shift+3] =
				      LFDKH[d-1][ji][d+red_shift:d+red_shift+2]
				      {same K-char, # Langlands quos}
				   then answer[d-1] #:= ji
				   fi {to_ht}
				od
			   fi {any q}
		      od {sv@i in short_verts}
}

set known_non_unitaries_wiggle(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, [int] HTs) = [vec]:
    if #LFDKH = 0 or #LFDKH[0] = 0 then return [] fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    then answer = [vec]: for v:#LFDKH do vec: [] od
    then HT = HTs~[0], H0 = height(ps[0][0])
    then lookups = lookups(LFDKH) {dth term finds a d-face in LFDKH[d]},
	 red_shift = if red_count_flag then 1 else 0 fi
    then () = for d:#LFDKH
       do for p@j in ps[d]
	  do if (not is_final(p)) or d=0
	     then let pdef = monomials(p)
		  in if any(for q in pdef
			    do @bool: status(q,HT) < 0
			    {big_unitary_hash.nu_height_lookup_bool(q,HT)}
			    od)
		     then answer[d]#:= j
		     fi
	     else {now p is final and d > 0}
		  let CF = character_formula_to_height(1*p,HT)
		  then verts = LFDKH[d][j][:d+1]
		  then short_verts = for k:d+1
				     do verts[:k]##verts[k+1:]
				     od {list of vertex sets for faces}
		  then short_js = for sv in short_verts
				  do lookups[d-1](sv)
				  od
		  in for sv in short_verts
		     do let pdefi = monomials(composition_series_to_ht(
					 wiggle(CF, face_bary(Lvd,sv)) , HT - 1))
			in if any (for q in pdefi
				  do @bool: (status(q,HT)<0 
				  {big_unitary_hash.nu_height_lookup_bool(q,HT))}
				   or (height(q) > H0 and not is_unitary_to_hts_big_SIMPLE(q,HTs)))
				  od) {CONCERN if HTs[0] < H0?}
			   then answer[d]#:= j;
				for ji in short_js
				do if {to_ht(pol_hash.index(LFDKH[d][j][d+red_shift+1]),HT) =
				      to_ht(pol_hash.index(LFDKH[d-1][ji][d+red_shift]),HT)}
				      LFDKH[d][j][d+red_shift+1:d+red_shift+3] =
				      LFDKH[d-1][ji][d+red_shift:d+red_shift+2]
				      {same K-char, # Langlands quos}
				   then answer[d-1] #:= ji
				   fi {to_ht}
				od
			   fi {any q}
		      od {sv@i in short_verts}
	       fi {not is_final(p)}
	  od {for p@j in ps[d]; this is vec of known nonunitary j for dim d}
       od {for d:#LFDKH}
   in for list in answer do sort_u(list) od

{list locations in LFDKH of reps known to be non-unitary to HT}
set known_non_unitaries_wiggle(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, int HT) = [vec]:
known_non_unitaries_wiggle(x,lambda,Lvd,LFDKH,[HT])

{list locations in LFDKH of reps known to be non-unitary}
set known_non_unitaries_wiggle_old(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    if #LFDKH[0] = 0 then return [] fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    then H0 = height(ps[0][0])
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let pdef =
		 if not is_final(p) or d=0
		 then monomials(finalize(p))
		 else let CF = character_formula(finalize(p))
		      then verts = LFDKH[d][j][:d+1]
		      in  monomials(composition_series((sum(x.real_form,
					    for j:d+1
					    do wiggle(CF, face_bary(Lvd,verts[:j]##verts[j+1:]))
					    od))))
		 fi {now pdef consists of reps that must be unitary if p is}
	     in if any(for q in pdef
		       do @bool: (big_unitary_hash.nulookup(q)).>=
			  or (height(q) > H0 and not is_unitary_test_big_SIMPLE_interrupt(q))
		       od)
		then [j]
		else []
		fi
	  od.## {for p@j in ps[d]; this is vec of known nonunitary j for dim d}
       od {for d:#LFDKH}

set known_non_unitaries_wiggle(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    if #LFDKH[0] = 0 then return [] fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    then answer = [vec]: for v:#LFDKH do vec: [] od
    then H0 = height(ps[0][0])
    then lookups = lookups(LFDKH) {dth term finds a d-face in LFDKH[d]},
	 red_shift = if red_count_flag then 1 else 0 fi
    then () = for d:#LFDKH
       do for p@j in ps[d]
	  do if (not is_final(p)) or d=0
	     then let pdef = monomials(p)
		  in if any(for q in pdef
			    do @bool: status(q,-1) < 0 {(big_unitary_hash.nulookup(q)).>=}
			    od)
		     then answer[d]#:= j
		     fi
	     else {now p is final and d > 0}
		  let CF = character_formula(1*p)
		  then verts = LFDKH[d][j][:d+1]
		  then short_verts = for k:d+1
				     do verts[:k]##verts[k+1:]
				     od {list of vertex sets for (d-1)-diml faces}
		  then short_js = for sv in short_verts
				  do lookups[d-1](sv)
				  od
		  in for sv in short_verts {run over the d+1 (d-1)-diml faces}
		     do let pdefi = monomials(composition_series(wiggle(CF, face_bary(Lvd,sv))))
			in if any (for q in pdefi
				  do @bool: status(q,-1) < 0 {(big_unitary_hash.nulookup(q)).>=}
				      {or (height(q) > H0 and not
				      is_unitary_test_big_SIMPLE_interrupt(q))}
				  od)
			   then answer[d]#:= j;
				for ji in short_js
				do if LFDKH[d][j][d+red_shift+1] = LFDKH[d-1][ji][d+red_shift]
				      {same K-char}
				      and LFDKH[d][j][d+red_shift+2] =
					  LFDKH[d-1][ji][d+red_shift+1] {same # Langlands quos}
				   then answer[d-1] #:= ji
				   fi {to_ht}
				od
			   fi {any q}
		      od {sv@i in short_verts}
	       fi {not is_final(p)}
	  od {for p@j in ps[d]; this is vec of known nonunitary j for dim d}
       od {for d:#LFDKH}
   in for list in answer do sort_u(list) od

{list locations in LFDKH of reps known to be non-unitary at height HT}
set known_non_unitaries(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, int HT) = [vec]:
    if wiggle_flag
    then return known_non_unitaries_wiggle(x,lambda,Lvd,LFDKH,HT)
    fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let qs = monomials(finalize(p))
	     in if any(for q in qs
		       do @bool: status(p,HT) < 0 { big_unitary_hash.nu_height_lookup_bool(q,HT)}
		       od)
		then [j]
		else []
		fi
	  od.##
       od

{wiggle is quite slow without a height bound, so for now just don't do it here}
{list locations in LFDKH of reps known to be non-unitary}
set known_non_unitaries(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    {if wiggle_flag
    then return known_non_unitaries_wiggle(x,lambda,Lvd,LFDKH)
    fi;}
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let qs = monomials(finalize(p))
	     in if any(for q in qs
		       do @bool: status(q,-1) < 0 {(big_unitary_hash.nulookup(q)).>=}
		       od)
		then [j]
		else []
		fi
	  od.##
       od

set localize(Param_hash Uhash, KGBElt x, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
	      do let p = Uhash.index(k)
		 in if p.x = x and p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc

set localize(Param_hash Uhash, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
	      do let p = Uhash.index(k)
		 in if p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc


{this is the Q(infinitesimal character) bound provided by Dirac inequality on all LKTs}
set DiracBD(KGBElt x, ratvec lambda) = rat:
    let G = x.real_form
    in min(for mu in LKTs(parameter(x,lambda,0*lambda))
	   do DiracBD(mu)
	   od)

{"true" means unitarity is possible in light of Dirac}
{avoid using is_hermitian defined in hermitian.at}
set DiracTest(Param p) = bool:
    let G=p.real_form
    then ans = bool: if not all(for q in monomials(finalize(p)) do is_hermitian(q) od) then false
       else let gamma = p.infinitesimal_character
	    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
	    then bound = DiracBD(p.x, p.lambda)
	    in Q(gamma,gamma) <= bound
       fi
    then () = if not ans then DTcount +:= 1 fi
    in ans

set DiracTest(KGBElt x, ratvec lambda, ratvec gamma) = bool:
    let Q = {Dirac_easy_hash.invt_form(x.real_form)} invariant_form(x.real_form)
    then bound = DiracBD(x, lambda)
    in Q(gamma,gamma) <= bound

{to be used in DiracBestTest. If the branch is too long, give up}
set protected_occurrence(KTypePol KC, KType tau, int time) = bool:
    case if my_branch_flag
	 then big_unitary_hash.branch_interrupt(KC,height(tau),time)
	 else branch(KC, height(tau), time)
	 fi
       | timed_out: false
       | done(B): B[tau].!=
    esac

{whether to use the time-protected versions of DiracBestTest}
set Dirac_pro_flag = true

set protected_occurrence(KTypePol KC, KType tau) = bool:
    let T = max(4000#tested_neg_times)\4
    in protected_occurrence(KC,tau,T)

{Kchar is mean to be the K-character, to height at least HT, of some subquotients
of p to which Dirac ineq is applied.}
set DiracBestTest_pro(int steps, Param p, int HT, KTypePol Kchar, int time) = bool:
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = best_Dirac_bound_cap(mu,steps)
    then j0 = first(for h in hts do h > HT od)
    then () = if j0<0 then j0:=#hts fi
    {now we only look up at [:j0]}
    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds[:j0] do b<psize od)
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p with hts bdded by HT}
       else let j2 = first(for tau@j in taus[j1:j0] {these taus would exclude p}
			    do @bool: protected_occurrence(Kchar, tau,time)
{
			       if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi
}
			    od)
	    in j2.< {if the bound at j0+j corresponds to a tau
		     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest_pro(int steps, Param p, int HT, KTypePol Kchar) = bool:
    let T = max(10000#tested_neg_times)
    in DiracBestTest_pro(steps, p, HT, Kchar, T)

{Kchar is mean to be the K-character, of some subquotients of p to which Dirac ineq is applied.}
set DiracBestTest_pro(int steps, Param p, KTypePol Kchar, int time) = bool:
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = best_Dirac_bound_cap(mu,steps)
    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds do b<psize od)
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p}
       else let j2 = first(for tau@j in taus[j1:] {these taus would exclude p}
			    do @bool: protected_occurrence(Kchar,tau,time)
			    {if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi}
			    od)
	    in j2.< {if the bound at j corresponds to a tau
		     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest_pro(int steps, Param p, KTypePol Kchar) = bool:
    let T = max(10000#tested_neg_times)\4
    in DiracBestTest_pro(steps, p, Kchar, T)

set DiracBestTest_pro(Param p, KTypePol Kchar) = bool:
    DiracBestTest_pro(Dirac_best_steps, p, Kchar)

{Kchar is mean to be the K-character, to height at least HT, of some subquotients
of p to which Dirac ineq is applied.}
set DiracBestTest(int steps, Param p, int HT, KTypePol Kchar) = bool:
    if Dirac_pro_flag then return DiracBestTest_pro(steps, p, HT, Kchar) fi;
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = truncate(best_Dirac_bound_cap(mu,steps),HT) {now all hts are <= HT}
    {then () = prints(taus," ",hts," ",bds)}
    {then j0 = first(for h in hts do h > HT od)
    then () = if j0<0 then j0:=#hts fi}
    {now we only look up at [:j0]}
    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds do b<psize od)
    {then () = prints("j1 = ",j1)}
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p with hts bdded by HT}
       else let j2 = first(for tau@j in taus[j1:] {these taus would exclude p}
			    do @bool: if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi
			    od)
	    in {prints("j2 = ",j2,", bad K_type = ",taus[j1 + j2]);}
	       j2.< {if the bound at j0+j corresponds to a tau
		     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest(int steps, Param p, KTypePol Kchar) = bool:
    if Dirac_pro_flag then return DiracBestTest_pro(steps, p, Kchar) fi;
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = best_Dirac_bound_cap(mu,steps)
    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds do b < psize od)
    {then () = prints("j1 = ",j1)}
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p with hts bdded by HT}
       else let j2 = first(for tau@j in taus[j1:] {these taus would exclude p}
			    do @bool: if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi
			    od)
	    in {prints("j2 = ",j2,", bad K_type = ",taus[j1 + j2]);}
	    j2.< {if the bound at j1+j corresponds to a tau
		     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest(Param p, int HT, KTypePol Kchar) = bool:
    DiracBestTest(Dirac_best_steps, p, HT, Kchar)

set DiracBestTest(Param p, KTypePol Kchar) = bool:
    DiracBestTest(Dirac_best_steps, p, Kchar)

{here p must be irr for branch_irr to work}
set DiracBestTest(int steps, Param p, int HT) = bool:
    DiracBestTest(steps, p, HT, K_type_pol(character_formula_to_height(1*p,HT)))

{here p must be irr for branch_irr to work}
set DiracBestTest(int steps, Param p) = bool:
    DiracBestTest(steps, p, K_type_pol(character_formula(1*p)))

{here p must be irr for branch_irr to work}
set DiracBestTest(Param p, int HT) = bool:
    DiracBestTest(Dirac_best_steps, p, HT, K_type_pol(character_formula_to_height(1*p,HT)))

set DiracBestTest(Param p) = bool:
    DiracBestTest(Dirac_best_steps, p, K_type_pol(character_formula(1*p)))

{creates LVD, map Perm on FPPverts at (x,lambda), {mapAct from FPPverts to local verts}}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.
parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}

set localFD_Lvd2 \
  (InnerClass ic, mat theta, ratvec lambda, {VertexData vd,} [(ratvec->int)] edge_lookups) =
  (LocalVertexData, PermOrderTwo{, vec}):
(   let Perm2 = thetaAct2(ic, theta, lambda, {vd,} edge_lookups)
    then vlist = {vd.list}FPP_vertices(ic)
    then vlistAct = [ratvec]:
	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
	 {def of Perm2 forces this to be an actual edge?}
    then Lvd = (vlistAct,#Perm2.fixed).to_vertex_data
    then Llookup = Lvd.lookup
    {then mapAct = vec: for j:#vlist do minus_1 od}
    {maps FPP vertex indices from vd to local indices from Lvd}
    {then () = for i@k in Perm2.fixed do mapAct[i]:= k od}
    {then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
					      mapAct[j]:=#Perm2.fixed + ell od}
    in (Lvd, Perm2{, mapAct})
)

set localFD_Lvd2 \
  ( KGBElt x, ratvec lambda, {VertexData vd,} [(ratvec->int)] edge_lookups) =
  localFD_Lvd2(x.inner_class, x.involution, lambda, {vd,} edge_lookups)

set localFD_Lvd2 \
  ( InnerClass ic, mat theta, ratvec lambda, {VertexData vd,} (vec->int) FlippedEdgeLookup) =
  (LocalVertexData, PermOrderTwo{, vec}):
(   let start = elapsed_ms(), Perm2 = thetaAct2(ic, theta, lambda, {vd,} FlippedEdgeLookup)
    then vlist = {vd.list} FPP_vertices(ic)
    then vlistAct = [ratvec]:
	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans
	 do if FlippedEdgeLookup([i,j]) >= 0
	    then [(vlist[i] + vlist[j])/2]
	    else []
	    fi
	 od.##
    then Lvd = (vlistAct,#Perm2.fixed).to_vertex_data
    then Llookup = Lvd.lookup
    {then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
					      mapAct[j]:=#Perm2.fixed + ell od}
    in (Lvd, Perm2{, mapAct})
)

set localFD_Lvd2 \
  (KGBElt x, ratvec lambda, {VertexData vd,} (vec->int) FlippedEdgeLookup) = (LocalVertexData, PermOrderTwo{, vec}):
  localFD_Lvd2(x.inner_class, x.involution, lambda, {vd,} FlippedEdgeLookup)

set FD12Time = int: 0

{takes local data and low global faces and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2) = [[FaceVertsIndex]]:
(   if face_verbose
    then prints(new_line,"start localFD_1Dirac2")
    fi;
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = ((ratvec,ratvec)->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_local_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then LF0 = [FaceVertsIndex]:
	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if Q(v,v) > DiracBD
	       then DTcount +:=1; []
	       elif not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       elif red_count_flag
	       then [[j, red_count(p,HT)]]
	       else [[j]]
	       fi
	  od.##
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then () = if #LF0 <= 1
    	      then FD12Time +:= elapsed_ms() - start;
	      	   return [LF0,[]]
	      fi
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
	 let EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
	     then for v in FPP_edges(G)
		  do if not(Llookup(v[0]) and Llookup(v[1])) then []
		     else let m = locate_sorted(Perm2.fixed, v[0]), n = locate_sorted(Perm2.fixed, v[1])
			  in if m< #Perm2.fixed and n < #Perm2.fixed and Perm2.fixed[m] = v[0]
				and Perm2.fixed[n] = v[1]
			     then [[m,n].sort]
			     else []
			     fi
		      fi
		  od.##
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesFixTrans = [vec]:
	      if #Perm2.fixed > 0 and #Perm2.trans > 0
	      then for v in FPP_flippable_triangles(G)
		   do let m = locate_sorted(Perm2.fixed, v[0]), n = trans_hash.lookup([v[1],v[2]])
		   in if m < #Perm2.fixed and Perm2.fixed[m]=v[0] and n.>=
		      then [[m,#Perm2.fixed+n]]
		      else []
		      fi
		   od.##
		else []
		fi
	   {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = ([vec]:
	      if #Perm2.trans > 1
	      then for v in FPP_flippable_tetrahedra(G)
		   do let m = trans_hash.lookup([v[0],v[1]]), n = trans_hash.lookup([v[2],v[3]])
		      in if m.>= and n.>=
			 then [[#Perm2.fixed + m, #Perm2.fixed + n].sort]
			 else []
			 fi
		    od.##
	       else []
	       fi)
	  {then () = prints("after TransTrans, time is ",print_time_string(elapsed_ms() - start))}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     { then () = prints("after Edges, time is ",print_time_string(elapsed_ms() - start))}
     then LF1 = [FaceVertsIndex]:
	 for v in Edges
	 do let nu = face_bary(Lvd, v)
	    then p = parameter(x,lambda,nu)
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v))}
	    in  if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
		then [] {from now on p is pos_on_LKTs}
		elif Q(nu,nu) > DiracBD
		then DTcount +:=1; {prints("GOT HERE!");} []
		elif red_count_flag
		then [v#red_count(p,HT)]
		else [v]
		fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = [LF0]##[LF1]
    then () = FD12Time +:= elapsed_ms() - start
    in if face_verbose then prints("After localFD_1Dirac2, face counts are [",#LF0,
				  ",",#LF1,"]") fi;
       {if time_verbose then prints("     ",print_time_string(elapsed_ms() - start),
					  " for localFD_1Dirac2") fi;}
       if sort_LFD_flag
       then sort(G, Lvd, answer)
       else answer
       fi
)

set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) = [[FaceVertsIndex]]:
  localFD_1Dirac2(x, lambda, next_heights(parameter(x,lambda,0*lambda),edge_offset +1)~[0], Lvd, Perm2)

set FD12bzTime = int:0
set FD12bzFFTime = int:0
set FD12bzFTTime = int:0
set FD12bzTTTime = int:0

{edge-finding tests are performed by (Test B) for vertex set smaller than BoundB,}
{NOT ANY MORE: A1 is always slower than C, by quite a bit?}
     {(Test A1) for vertex sets smaller than BoundA1,}
{and (Test C) for larger vertex sets. I don't really have a clue how these
 should be computed}
set BoundB = int: 600

{takes local data and low global faces and computes local vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}

{If red_count_flag, add an extra coordinate recording red_count(p, next_heights[edge_offset])}
set localFD_1Dirac2_by_zero\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsIndex]]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1Dirac2_by_zero")
    fi;
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1, start = elapsed_ms()
    then () = if Dirac_local_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then length = #(Lvd.list)
    then freq = max(length\10,1)
    then LF0 = [FaceVertsIndex]:
    	 for v@j in Lvd.list
	 do if fund_face_verbose and red_count_flag and (j%freq).=
	    then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start))
	    fi;
	    let p = parameter(x,lambda,v)
	    in if Q(v,v) > DiracBD
	       then DTcount +:=1; []
	       elif not (fewer_reducible_unitary_flag or all(for q in monomials(finalize(p))
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       elif red_count_flag
	       then [[j, red_count(p,HT)]]
	       else [[j]]
	       fi
	 od.## {list of j for which vertex j is a candidate}
    {then () = if time_verbose
	      then prints("for LF0, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    {then () = if #LF0 = 0
	      then return [[],[]]
	      fi}
    then () = if #LF0 <= 1
    	      then FD12bzTime +:= elapsed_ms() - start;
	      	   return [LF0,[]]
	      fi
    then FixedList = [int]: for v in LF0
			    do let j = v[0]
			       in if j < #Perm2.fixed
				  then [j]
				  else break
				  fi
			    od.##
    then f = #FixedList, f0 = #Perm2.fixed
    then TranList = [int]: for v in LF0[f:] do v[0] od
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
		   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
	 Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
	 let startFF = elapsed_ms()
	 then EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
			{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
		    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
		       do for k in FixedList[i+1:f]
			  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
			     then [[j,k]]
			     else []
			     fi
			  od.## {list of edges starting with j}
		       od.##
	       {
	       elif f < BoundA1 {TEST A1}
		      {2*(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then for j in FixedList
		    do for w in FPP_edges_by_zero_unsorted(G)[Perm2.fixed[j]]
		       do if is_member_bitset(w[1],Glookup)
			  then [[j,locate_sorted(Perm2.fixed, w[1])]]
			  else []
			  fi
		       od.## {list of edges starting with j}
		    od.##

	       }
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
		    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
		       do for w@m in FPPEBZ[Perm2.fixed[j]]
			  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
			     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
			     else []
			     fi
			  od.##
		       od.##
	       fi {f < 2}
	   then () = FD12bzFFTime +:=elapsed_ms() - startFF
	   {then () = if time_verbose
		     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   then startFT = elapsed_ms()
	   then EdgesFixTrans = [vec]:
		if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
				do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
				od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   then () = FD12bzFTTime +:= elapsed_ms() - startFT
	   {then () = if time_verbose
		     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   then startTT = elapsed_ms()
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
		   in for k@m in TranList[:#TranList - 1] {k is the number of a midpoint local vertex}
			  {(i,j)@m in Perm2.trans}
		      do let (i,j) = Perm2.trans[k-f0]
			 then a = FEL([i,j]) {this is m + f0?}
			 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
			 in if {#Perm2.trans > m+1 and} #cands > 0
			    then for v in cands
				 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0
					  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT!");} [[k,n].sort]
				       else []
				       fi
				 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   then () = FD12bzTTTime +:= elapsed_ms() - startTT
	   {then () = if time_verbose
		     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
	    {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
     then length = #Edges
     then freq = max(length\10,1)
     then LF1 = [FaceVertsIndex]:
    	 for v@j in Edges
	 do if fund_face_verbose and red_count_flag and (j%freq).=
	    then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start))
	    fi;
	    let nu = face_bary(Lvd,v)
	    then p = parameter(x,lambda,nu)
	    in {if Q(nu,nu) > DiracBD
	       then DTcount +:=1; []} {can't happen}
	       if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       elif red_count_flag
	       then [v#red_count(p,HT)]
	       else [v]
	       fi
	 od.##
    {then () = if time_verbose
	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    then answer = [LF0]##[LF1]
    then () = FD12bzTime +:= elapsed_ms() - start
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero, face counts are [",#LF0,
				  ",",#LF1,"]") fi;
       if sort_LFD_flag
       then sort(G, Lvd, answer)
       else answer
       fi
)


set localFD_1Dirac2_by_zero\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsIndex]]:
    localFD_1Dirac2_by_zero(x,lambda, next_heights(parameter(x,lambda,0*lambda),edge_offset+1)~[0], Lvd, Perm2)

set localFD_1Dirac2_by_zero(KGBElt x, ratvec lambda, int HT) = [[FaceVertsIndex]]:
    let theta = x.involution, ic = x.inner_class
    then lamthlam = ((1+theta)*lambda).numer
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic,theta,lamthlam)
    in localFD_1Dirac2_by_zero(x,lambda,HT, Lvd,Perm2)

set localFD_1Dirac2_by_zero(KGBElt x, ratvec lambda) = [[FaceVertsIndex]]:
    let theta = x.involution, ic = x.inner_class
    then lamthlam = ((1+theta)*lambda).numer
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic,theta,lamthlam)
    in localFD_1Dirac2_by_zero(x,lambda,Lvd,Perm2)

{add red_count while checking pos on LKTs, Dirac}
set localFD_1Dirac2_add_red(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsIndex]] LF) =
    [[FaceVertsIndex]]:
    let G = x.real_form
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_local_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    in for d:#LF
       do for v in LF[d]
	  do let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     then qs = monomials(p)
	     in if Q(nu,nu) > DiracBD
		then DTcount +:=1; []
		elif not (fewer_reducible_unitary_flag or all(for q in qs
			    do @bool: is_pos_on_LKTs(q)
			    od))
		then []
		elif red_count_flag
		then [v#red_count(p,HT)] {HT = -1 means infinity}
		else [v]
		fi
	  od.##
       od

{If red_count_flag needed to height > next_heights[edge_offset], update here}
set localFD_1Dirac2_red_update\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsIndex]] LF) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    if next_heights(parameter(x,lambda,0*lambda),edge_offset+1)~[0] >= HT
    then return LF
    fi;
    let G = x.real_form, start = elapsed_ms()
    in for LFd@d in LF
       do for v in LFd
	  do let w = v, p = parameter(x,lambda,face_bary(Lvd, v[:d+1]))
	     then () = w[d+1]:=red_count(p,HT)  {HT = -1 means infinity}
	     in w
	  od
       od
)

{No extra coordinates and no Dirac; meant for use in blob, so red_count and Dirac
are only done once for repeated parameters}
set localFD_by_zero_short\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then LF0 = [FaceVertsIndex]:
	 for j:#Lvd.list
	 do [j]
	 od
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    {then Llookup = is_member_sorted((for v in LF0 do v[0] od))}
    then Edges = [vec]:
	 let startFF = elapsed_ms()
	 then EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
	     then for j@m in Perm2.fixed[:#Perm2.fixed - 1]
		  do let cands = FPP_edges_by_zero_unsorted(G)[j] {list of edges beginning j}
		     in if {Llookup(m{mloc}) and} #cands > 0
			then for v in cands {global edges with v[0] = j}
			     do let n = locate_sorted(Perm2.fixed, v[1])
				in if n< #Perm2.fixed and Perm2.fixed[n] = v[1] {and Llookup(n)}
				   then [[m,n].sort]
				   else []
				   fi
			     od.## {this is the list of edges starting with m}
			 else []
			 fi {#cands > 0}
		   od.## {all FixFix edges}
	       else []
	       fi
	    then () = FD12bzFFTime +:=elapsed_ms() - startFF
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
	   then startFT = elapsed_ms()
	   then EdgesFixTrans = [vec]:
		if #Perm2.fixed > 0 and #Perm2.trans >0
		then for j@m in Perm2.fixed
		     do {let mloc = mapAct[j]} {this is m?}
			let cands = FPP_flippable_triangles_by_zero_unsorted(G)[j]
			in if {Llookup(m) and} #cands > 0
			   then for v in cands
				do let n = #Perm2.fixed + trans_hash.lookup(v[1:])
				   in if n >= #Perm2.fixed {and Llookup(n)}
				      then [[m,n]]
				      else []
				      fi
				od.## {[vec], all starting with m}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all m}
		  else []
		  fi
	   then () = FD12bzFTTime +:= elapsed_ms() - startFT
	   then startTT = elapsed_ms()
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #Perm2.trans > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
		   in for (i,j)@m in Perm2.trans
		      do let a = FEL([i,j]) {, mloc = mapAct[i]} {this is m+#Perm2.fixed?}
			 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
			 in if {Llookup(m+#Perm2.fixed) and} #Perm2.trans > m+1 and #cands > 0
			    then for v in cands
				 do let n = #Perm2.fixed + trans_hash.lookup(v[2:])
				    in if n >= #Perm2.fixed
				    {and Llookup(n) and Llookup(m+#Perm2.fixed)}
				       then [[m+#Perm2.fixed,n].sort]
				       else []
				       fi
				 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	    then () = FD12bzTTTime +:= elapsed_ms() - startTT
	    {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FaceVertsIndex]:
	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in  if fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od)
		then [v]
		else []
		fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = [LF0]##[LF1]
    then () = FD12bzTime +:= elapsed_ms() - start
    {then () = if elapsed_ms() - start > 10{FD12bzTime}
	      then prints("(fixed,trans) = (",#Perm2.fixed, ",",#Perm2.trans, "), face counts (",#LF0,",",Edges,") took ",print_time_string(elapsed_ms() - start))
	      fi}
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero_short, face counts are [",#LF0,
				  ",",#LF1,"]") fi;
       {if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
					  " for localFD_1Dirac2_by_zero") fi;}
       if sort_LFD_flag
       then sort(G, Lvd, answer)
       else answer
       fi
)


set localFD_1Dirac2_by_zero_old\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2, vec mapAct) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_local_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then LF0 = [FaceVertsIndex]:
	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if  Q(v,v) > DiracBD
	       then DTcount+:=1; []
	       elif not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       else [[j]]
	       fi
	 od.##{list of j for which vertex j is a candidate}
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
	 let EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
	     then for j in Perm2.fixed
		  do let mloc = mapAct[j]
		     in if Llookup(mloc)
			then for v in FPP_edges_by_zero(G)[j] {global edges with v[0] = j}
			     do if is_member_sorted(Perm2.fixed)(v[1])
				then let nloc =  mapAct[v[1]]
				     in if nloc > mloc and Llookup(nloc)
					then [[mloc,nloc]]
					else []
					fi
				else []
				fi
			     od.## {this is the list of edges starting with j}
			 else []
			 fi
		   od.## {all FixFix edges}
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesFixTrans = [vec]:
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
		    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
	   {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = [vec]:
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
		    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FaceVertsIndex]:
	 for v in Edges
	 do let nu = face_bary(Lvd, v)
	    then p = parameter(x,lambda,nu)
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in if Q(nu,nu) > DiracBD
	       then DTcount+:=1; []
	       elif not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       else [v]
	       fi
	  od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = [LF0]##[LF1]
    then () = FD12bzTime +:= elapsed_ms() - start
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero, face counts are [",#LF0,
				  ",",#LF1,"]") fi;
       {if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
					  " for localFD_1Dirac2_by_zero") fi;}
       if sort_LFD_flag
       then sort(G, Lvd, answer)
       else answer
       fi
)

{takes local data and low global faces and computes local vertices, imposing
hermitian, pos on LKTs. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
set localFD_1Steve\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1Steve")
    fi;
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then length = #(Lvd.list)
    then freq = max(length\10,1)
    in for v@j in Lvd.list
       do if fund_face_verbose and (j%freq).=
	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start))
	  fi;
	  let p = parameter(x,lambda,v)
	  in if not (fewer_reducible_unitary_flag or all(for q in monomials(finalize(p))
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	     then []
	     else [[j]]
	     fi
	od.## {list of j for which vertex j is a candidate}
)

{takes local data and low global faces and local vertices and computes local edges, imposing
hermitian, pos on LKTs.}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_2Steve\
( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_2Steve")
    fi;
    let G = x.real_form, {start = elapsed_ms(),} trans_hash = make_vec_hash()
    {then () = if time_verbose
    	      then prints("for LF0, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    then () = if #LF0 = 0
    	      then return []
	      fi
    then FixedList = [int]: for v in LF0
    	 	     	    do let j = v[0]
			       in if j < #Perm2.fixed
			       	  then [j]
				  else break
				  fi
			    od.##
    then f = #FixedList, f0 = #Perm2.fixed
    then TranList = [int]: for v in LF0[f:] do v[0] od
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       {
	       elif f < BoundA1 {TEST A1}
	       	      {2*(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then for j in FixedList
    	       	    do for w in FPP_edges_by_zero_unsorted(G)[Perm2.fixed[j]]
		       do if is_member_bitset(w[1],Glookup)
		          then [[j,locate_sorted(Perm2.fixed, w[1])]]
		       	  else []
		       	  fi
		       od.## {list of edges starting with j}
	       	    od.##

	       }
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is m + f0?}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	    {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
     then length = #Edges
     then freq = max(length\10,1)
     then LF1 = [FaceVertsIndex]:
    	 for v@j in Edges
	 do if fund_face_verbose and red_count_flag and (j%freq).=
	    then prints("at edge ",j," of ",length{,
	    	       " at time ", print_time_string(elapsed_ms() - start)})
	    fi;
	    let nu = face_bary(Lvd,v)
	    then p = parameter(x,lambda,nu)
	    in {if Q(nu,nu) > DiracBD
	       then DTcount +:=1; []} {can't happen}
	       if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       else [v]
	       fi
	 od.##
    {then () = if time_verbose
    	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    {then () = FD12bzTime +:= elapsed_ms() - start}
    in if(face_verbose) then prints("After localFD_2Steve, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if sort_LFD_flag
       then sort(G, Lvd, [LF1])[0]
       else LF1
       fi
)

{set left_good = int:0, left_bad = int:0, right_good = int:0, right_bad = int:0, LR_no_info = int:0}
{takes 0 and 1-diml local faces and adds K-char index}
{having K-char, take opportunity to apply Dirac ineq deeper }
{No height bound here; need red_count to infinity}
set localFD_KHash_01 (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), ht = height(parameter(x,lambda,0*lambda)), startDBTcount = DBTcount
    {then HT = next_heights(parameter(x,lambda,0*lambda),edge_offset+1)~[0]}
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not Dirac_best_local_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = {Dirac_easy_hash.invt_form(x.real_form)} invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
				do bs~[0]
				od)
	     then index = first(for v in Lvd.list
				do @bool: QG(v,v) > bestbd
				od)
	     in if index.>=
		then DiracBestBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    then answer0 = for v@k in LF[0]
		   ~do if k%(max(#LF[0]\10,2))=0 and fund_face_verbose
		      then prints("calculating K-character on vertex ",k,
		      " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		      fi;
		      let gamma = Lvd.list[v[0]]
		      then p0 = parameter(x, lambda, gamma)
		      then P = finalize(p0)
		      then KCF = K_type_pol(character_formula(P))
		      then m = ktp_hash.match(KCF)
		      in if (not temp_Dirac_best_flag) or (Q(gamma,gamma) <= DiracBestBD)
			    or DiracBestTest(p0,KCF)
			 then [v##[m,#monomials(P)]]
			 else []
			 fi
		   od.##
    then lookup0D = index_in(for v in answer0
			     do v[:1]
			     od)
    then answer1 = for v@k in LF[1] {if red_count_flag, has red_count as coor#2}
		   ~do if k%(max(#LF[1]\10,2))=0 and fund_face_verbose
		      then prints("calculating K-character on edge ",k,
			    " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		      fi;
		      let i = lookup0D([v[0]]), j = lookup0D([v[1]])
		      in if i < 0 or j < 0 {one edge endpoint has been removed already}
			 then []
			 else let nu = face_bary(Lvd,v[:2])
			      then p0 = parameter(x, lambda, nu)
			      then P = finalize(p0)
			      in if red_count_flag
				 then if answer0[i][1] = v[2] {Kchars match}
				      then [v##[answer0[i][2],#monomials(P)]]
				      elif answer0[j][1] = v[2]
				      then [v##[answer0[j][2], #monomials(P)]]
				      else let m = ktp_hash.match(K_type_pol(character_formula(P)))
				      in [v##[m,#monomials(P)]]
				      fi {answer = v[2]}
				 else let m = ktp_hash.match(K_type_pol(character_formula(P)))
				      in [v##[m, #monomials(P)]]
				 fi{red_count_flag}
			 fi{i<0}
		     od.##
    then time = elapsed_ms() - start
    then () = if time_verbose then prints(" ", print_time_string(time),
			     " for localFD_KHash_01 (vertex/edge K-chars)");
			     prints(" face counts to dim 1: [",#answer0,",",#answer1,
			     "]; Dirac_best eliminated ", DBTcount - startDBTcount)
			     fi
    in if sort_LFD_flag
       then sort(x.real_form, Lvd, [answer0,answer1])
       else [answer0,answer1]
       fi

set to_htB_flag = false

{takes 0 and 1-diml local faces and adds K-char index to height HT}
set localFD_KHash_01 (KGBElt x, ratvec lambda, LocalVertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda), startDBTcount = DBTcount
    then ht = height(p0), HT0= next_heights(p0,edge_offset+1)~[0]
    then () = if HT > HT0 and red_count_flag
	      then LF := localFD_1Dirac2_red_update(x, lambda, HT, Lvd, LF)
	      fi
    then Q = (ratvec,ratvec ->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not Dirac_best_local_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = invariant_form(x.real_form)
	      then best_bounds = for mu in mus
	      	   	       	 do let (taus,hs,bs) = truncate(best_Dirac_bound(mu),HT)
				    in if #bs > 0
				       then [(taus,hs,bs)]
				       else []
				       fi
				  od.##
	      then bestbd = if #best_bounds = 0
	      	   	    then 0/1
			    else min(for (,hs,bs) in best_bounds
				do bs~[0]
				od)
			    fi
	     {then () = prints("best_bounds = ",best_bounds)}
	     then index = first(for v in Lvd.list
				do @bool: QG(v,v) > bestbd
				od)
	     in if index.>=
		then DiracBestBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    {then () = prints("starting LF0 = ",LF[0]); prints("starting LF1 = ",LF[1])}
    {then () = if to_htB_flag then LF[0] :=~LF[0] fi}
    then answer0 = for v@k in LF[0]
		   ~do if k%(max(#LF[0]\10,2))=0 and fund_face_verbose {E7_s sph: 3 times slower without tilde}
		      then prints("calculating K-character on vertex ",k,
		      " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		      fi;
		      let gamma = Lvd.list[v[0]]
		      then p0 = parameter(x, lambda, gamma)
		      then P = finalize(p0)
		      then KCF = K_type_pol(if to_htB_flag
					    then composition_series_to_heightB(P,HT)
					    else character_formula_to_height(P,HT)
					    fi)
		      then m = ktp_hash.match(KCF)
		      in if (Q(gamma,gamma) > DiracBestBD)
			    and not DiracBestTest(p0,HT,KCF)
			 then {prints("lose param at p0 = ",p0, ", vert = ",v[0], " tests = ",
			       not temp_Dirac_best_flag," ", (Q(gamma,gamma) <= DiracBestBD)," ",
			       DiracBestTest(p0,HT));}
			       [] 
			 else  {prints("gain param at p0 = ",p0, ", vert = ",v[0]," tests = ",
			      not temp_Dirac_best_flag," ", (Q(gamma,gamma) <= DiracBestBD)," ",
			      DiracBestTest(p0,HT,KCF));}
			      [v##[m,#monomials(P)]]
			 fi
		   od.##
    {then () = prints("answer0 = ",answer0)}
    {then candps = for v in answer0 do parameter(x,lambda,Lvd.list[v[0]]) od}
    {then () = prints("down to ",count(for p in candps do is_unitary(Finalize(p)) od)," unitary verts")}
    then lookup0D = index_in(for v in answer0
			     do v[:1]
			     od)
     {then () = if to_htB_flag then LF[1] :=~LF[1] fi}
    then answer1 = [vec]: for v@k in LF[1]
		  ~do if k%(max(#LF[1]\10,2))=0 and fund_face_verbose {E7_s spherical: 20% slower without tilde}
		      then prints("calculating K-character on edge ",k,
			   " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		      fi;
		      let i = lookup0D([v[0]]), j = lookup0D([v[1]])
		      in [vec]: if i < 0 or j < 0 {one edge endpoint has been removed already}
			 then []
			 else let nu = face_bary(Lvd,v[:2])
			      then p0 = parameter(x, lambda, nu)
			      then P = finalize(p0)
			      in if red_count_flag and answer0[i][1] = v[2] {red_counts match}
				 then [v##[answer0[i][2],#monomials(P)]]
				 elif red_count_flag and answer0[j][1] = v[2] {red_counts match}
				 then [v##[answer0[j][2], #monomials(P)]]
				 else let KCF = K_type_pol(
				      	   if to_htB_flag
				      	   then composition_series_to_heightB(P,HT)
					   else character_formula_to_height(P,HT)
					   fi)
				      then m = ktp_hash.match(KCF)
		      		      in if (Q(nu,nu) > DiracBestBD)
			    	      	     and not DiracBestTest(p0,HT,KCF)
			 		 then
					 {prints("lose param at p0 = ",p0, ", vert = ",v[0], " tests = ",
			       		 not temp_Dirac_best_flag," ", (Q(gamma,gamma) <= DiracBestBD)," ",
			       		 DiracBestTest(p0,HT));}
					      []
			 		 else
					 {prints("gain param at p0 = ",p0, ", vert = ",v[0]," tests = ",
			      		 not temp_Dirac_best_flag," ", (Q(gamma,gamma) <= DiracBestBD)," ",
			      		 DiracBestTest(p0,HT,KCF));}
					       [v##[m,#monomials(P)]]
			 		 fi {Q >}
				 fi{red_count_flag}
			 fi{i<0}
		     od.##
    then time = elapsed_ms() - start
    then () = if time_verbose then prints(" ", print_time_string(time),
			     " for localFD_KHash_01 to ht = ",HT," (vertex/edge K-chars)");
			     prints(" face counts to dim 1: [",#answer0,",",#answer1,
			     "]; Dirac_best eliminated ", DBTcount - startDBTcount)
			     fi
    in if sort_LFD_flag
       then sort(x.real_form, Lvd, [answer0,answer1])
       else [answer0,answer1]
       fi

{same as above, using graph of K-relations}
{takes 0 and 1-diml local faces and adds K-char index}
{only called when red_count_flag = true. In element of LF[d], first d+1 coords are vertices;
next and last is red_count. Adjoin two more: K-char, and #Langlands quotients}
set localFD_KHash_01_graph (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), startDBTcount = DBTcount
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not Dirac_best_local_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = {Dirac_easy_hash.invt_form(x.real_form)} invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
				do bs~[0]
				od)
	     then index = first(for v in Lvd.list
				do @bool: QG(v,v) > bestbd
				od)
	     in if index.>=
		then DiracBestBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    then NumClasses = #eq
    then () = if test_verbose
	      then prints("     Examining ",NumClasses," classes in localFD_hash_01_graph.")
	      fi
    then polNums = [int]: {one for each class}
	 for C in eq
	 ~do let (d,j) = coords(LF,C~[0]) {the tilde chooses a
	 representative on largest possible face, so least integral}
	    then verts = vec: LF[d][j][:d+1]
	    then gamma = face_bary(Lvd,verts)
	    then pC = parameter(x,lambda,gamma)
	    then PC = finalize(pC)
	    then KCF = K_type_pol(character_formula(PC))
	    in if (not temp_Dirac_best_flag) or (Q(gamma,gamma) <= DiracBestBD)
		  or DiracBestTest(pC,KCF)
	       then ktp_hash.match(KCF)
	       else -1
	       fi
	 od
    then () = polNums := ~polNums {since they were computed in reverse order}
    then nLKT = #LKTs(parameter(x,lambda,0*lambda))
    then answer = for LFd@d in LF
		  do for v@j in LFd
		     do let N = polNums[classListByFace[d][j]]
			then m = if nLKT = 1 or N.<
				 then 1
				 else #monomials(finalize(parameter(x,lambda,face_bary(Lvd,v[:d+1]))))
				 fi
			in if N.>=
			   then [v##[N,m]]
			   else []
			   fi
		     od.##
		  od
    then time = elapsed_ms() - start
    then () = if time_verbose then prints(" ", print_time_string(time),
			     " for localFD_KHash_01_graph (vertex/edge K-chars)");
			     prints(" face counts to dim 1: [",#answer[0],",",#answer[1],
			     "]; Dirac_best eliminated ", DBTcount - startDBTcount)
			     fi
    {then () = if time_verbose then prints("     ", print_time_string(time),
			     " for localFD_KHash_01_graph (vertex/edge K-chars)") fi}
    in answer

{same as above, using graph of K-relations}
{takes 0 and 1-diml local faces and adds K-char index}
{only called when red_count_flag = true. In element of LF[d], first d+1 coords are vertices;
next and last is red_count. Adjoin two more: K-char, and #Langlands quotients}
set localFD_KHash_01_graph (KGBElt x, ratvec lambda, LocalVertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), startDBTcount = DBTcount
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not Dirac_best_local_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do truncate(best_Dirac_bound(mu),HT) od
	      then bestbd = min(for (,hs,bs) in best_bounds
				do bs~[0]
				od)
	     {then () = prints("bestbd = ",bestbd,", QG(rho) = ",QG(x.real_form.rho,x.real_form.rho))}
	     then index = first(for v in Lvd.list
				do @bool: QG(v,v) > bestbd
				od)
	     in if index.>=
		then DiracBestBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    then NumClasses = #eq
    then () = if test_verbose
	      then prints("     Examining ",NumClasses," classes in localFD_hash_01_graph to ht ",HT)
	      fi
    then () = for C@k in eq
     	      do if #C > 1
	      	 then let (d0,j0) = coords(LF, C[0])
	    	      then r0 = LF[d0][j0][d0+1]
		      in for m in C[1:]
		      	 do let (d,j) = coords(LF,m)
			    in assert(@:r0 = LF[d][j][d+1],"problem with red_count graph")
			 od
		  fi
	       od
    then polNums = [int]:
	 for C@k in eq
	 ~do if k%(max(#eq\10,2))=0 and fund_face_verbose
	    then prints("calculating K-character on class ",k,
		 " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
	    fi;
	    let (d,j) = coords(LF,C~[0]) {the tilde chooses a
		representative on largest possible face, so least integral}
	    then verts = vec: LF[d][j][:d+1]
	    then gamma = face_bary(Lvd,verts)
	    then pC = parameter(x,lambda,gamma)
	    then PC = finalize(pC)
	    then KCF = if to_htB_flag
		       then K_type_pol(composition_series_to_heightB(PC,HT))
		       else K_type_pol(character_formula_to_height(PC,HT))
		       fi
	    in if (not temp_Dirac_best_flag) or (Q(gamma,gamma) <= DiracBestBD)
		  or DiracBestTest(pC,HT)
	       then ktp_hash.match(KCF)
	       else -1
	       fi
	 od
    then () =  polNums := ~polNums {because they were calculated in reverse order}
    then nLKT = #LKTs(parameter(x,lambda,0*lambda))
    then answer0 = for v@j in LF[0]
		   do let N = polNums[classListByFace[0][j]]
		      then m = if nLKT = 1 or N.<
			       then 1
			       else #monomials(finalize(parameter(x,lambda,Lvd.list[v[0]])))
			       fi
		      in if N.>=
			 then [v##[N,m]]
			 else []
			 fi
		    od.##
    then lookup0D = index_in(for v in answer0
			     do v[:1]
			     od)
    then answer1 = for v@k in LF[1]
		   do let i = lookup0D([v[0]]), j = lookup0D([v[1]])
		      in if i < 0 or j < 0 {one edge endpoint has been removed already}
			 then []
			 else let N = polNums[classListByFace[1][k]]
				then m = if nLKT = 1 or N.<
					 then 1
					 else #monomials(finalize(parameter(x,lambda,face_bary(Lvd,v[:2]))))
					 fi
				in if N.>=
				   then [v##[N,m]]
				   else []
				   fi
			   fi
		     od.##
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
			     " for localFD_KHash_01_graph (vertex/edge K-chars)");
		   prints(" face counts to dim 1: [",#answer0,",",#answer1,
			     "]; Dirac_best eliminated ", DBTcount - startDBTcount)
	       fi
    in if sort_LFD_flag
       then sort(x.real_form,Lvd,[answer0,answer1])
       else [answer0,answer1]
       fi

{don't compute K_chars, just use red_count}
set localFD_KHash_01_graph_dry (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    assert(@:red_count_flag,"localFD_KHash_01_graph_dry requires red_count_flag :=true");
    let start = elapsed_ms(), startDBTcount = DBTcount
    then NumClasses = #eq
    then () = if test_verbose
	      then prints("     Examining ",NumClasses," classes in localFD_hash_01_graph_dry")
	      fi
    then mu = LKT(x.real_form.trivial)
    then nLKT = #LKTs(parameter(x,lambda,0*lambda))
    then answer = for LFd@d in LF
		  do for v@j in LFd
		     do let KCF = v[d+1]*mu
			then N = ktp_hash.match(KCF)
			then m = if nLKT = 1
				 then 1
				 else #monomials(finalize(parameter(x,lambda,face_bary(Lvd,v[:d+1]))))
				 fi
			in v##[N,m]
		     od
		  od
    then time = elapsed_ms() - start
    then () = if time_verbose then prints("     ", print_time_string(time),
			     " for localFD_KHash_01_graph_dry (vertex/edge K-chars)") fi
    in answer

{takes list of 0- and d-diml faces, with d \ge 1, and builds all
d+1-diml faces having all faces in the d-diml list. The int e is the
number of extra coords in each face.}
set superFaces([vec] L0, [vec] Ld, int e) =
    [vec]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [vec]:
   for v in L0
   do let m0 = v[0] {first vertex in new face}
      in [vec]:
	 for small in Ld
	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    elif any(for k:d+1 do lookupsd( m0#(small[:k]##small[k+1:d+1])) = -1 od)
	    then [] {require all d-faces to be in Ld}
	    else [m0#small[:d+1]] {now m0##small is a candidate face}
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFaces was ",
			print_time_string(elapsed_ms() - start))
	  fi}
in answer
fi

{record also the locations in Ld of the d+2 faces in Ld from which each d+1 superface arises}
{e is the number of non-vertex coords in the vec's}
set superFaces_plus([vec] L0, [vec] Ld, int e) =
    [(vec,vec)]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()} {dimension of the faces to be extended}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [(vec,vec)]:
   for v in L0
   do let m0 = v[0] {first vertex in new face}
      in [(vec,vec)]:
	 for small@look0 in Ld
	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    else let look = vec:
		     for k:d+1
		     do lookupsd(m0#(small[:k]##small[k+1:d+1]))
		     od
		 in if look.>=
		    then [(m0#small[:d+1], look0#look)] {now m0##small is a candidate face}
		    else []
		    fi
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFaces was ",
			print_time_string(elapsed_ms() - start))
	  fi}
in answer
fi

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
(   {if face_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;}
    if #LFKH = 0 or #LFKH[0] = 0 then return [] fi;
    let G = x.real_form, start=elapsed_ms()
    then e = if red_count_flag {red_shift+2}
	     then 3
	     else 2
	     fi
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2; dim is the new bigger dim}
	      do let lookup = if red_count_flag
			      then index_in(for v in LFKH[dim-1] do v[:dim] od)
			      else index_in([vec]:[])
			      fi
		 in LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],e)
				   in [vec]:
				      for (actual,locs) in acts {vec of size dim+1, coords of subs}
				      do let p0 = parameter(x,lambda, face_bary(Lvd, actual))
					 then P = finalize(p0)
					 then midreds = vec: if red_count_flag
							then [red_count(p0)]
							else []
							fi
					 then subs = if red_count_flag
						     then for k:dim
							  do delete(actual,k) {vec of size dim}
							  od
						     else []
						     fi
					 then k = if red_count_flag
						  then first(for i in locs
							do [LFKH[dim-1][i][dim]] = midreds
							od)
						  else -1
						  fi
					 then ms = monomials(P)
					 in if fewer_reducible_unitary_flag or all(for q in ms
									    do @bool: is_pos_on_LKTs(q)
									    od)
					    then if k.>= {so red_count_flag is true}
						 then {prints(p0, ktp_hash.list()[LFKH[dim-1][locs[k]][dim]]);}
						      [actual##midreds##[LFKH[dim-1][locs[k]][dim+1], #ms]]
						 else {let startCF = elapsed_ms()}
						      let m = {char_counter.use();} ktp_hash.match(
							   K_type_pol(character_formula(P)))
						      {then () = charTime +:= elapsed_ms() - startCF}
						      in [actual##midreds##[m, #ms]]
						 fi {K-char matches a face}
					     else []
					     fi {pos on LKTs}
				   od.## {[FaceVertsKHash]})
	 od
    then () = LFKH := if sort_LFD_flag
		      then sort(G, Lvd, LFKH)
		      else LFKH
		      fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
				" for localFD_Khashbt to dim ",t-1,
				"; face counts = ", for list in LFKH do #list od) fi
    in if sort_LFD_flag
       then sort(G,Lvd,LFKH)
       else LFKH
       fi

)

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t). This time
just calculate K characters to HT. ASSUME red_counts are at least to HT.

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t, int HT, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
(   if #LFKH = 0 or #LFKH[0] = 0 then return [] fi;
    if face_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;
    let G = x.real_form, start=elapsed_ms()
    then e = if red_count_flag {number of LFKH coords after vertices}
	     then 3
	     else 2
	     fi
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
	      do let lookup = if red_count_flag
			      then index_in(for v in LFKH[dim-1] do v[:dim] od)
			      else index_in([vec]:[])
			      fi
	      in LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],e)
				in [vec]:
				   for (actual,locs) in acts
				   do let p0 = parameter(x,lambda, face_bary(Lvd, actual))
				      then P = finalize(p0)
				      then midreds = vec: if red_count_flag
						     then [red_count(p0,HT)]
						     else []
						     fi
				      then subs = if red_count_flag
						  then for k:dim+1
						       do delete(actual, k) {vec of size dim}
						       od
						  else []
						  fi
				      then k = if red_count_flag
						  then first(for i in locs
							do [LFKH[dim-1][i][dim]] = midreds
							od)
						  else -1
						  fi
				      then ms = monomials(P)
				      in if fewer_reducible_unitary_flag or all(for q in ms
									 do @bool: is_pos_on_LKTs(q)
									 od)
					 then if k.>= {so red_count_flag is true}
					      then [actual##midreds##[ LFKH[dim-1][locs[k]][dim+1], #ms]]
					      else let m = ktp_hash.match(
						       if to_htB_flag
						       then K_type_pol(composition_series_to_heightB(P,HT))
						       else K_type_pol(character_formula_to_height(P,HT))
						       fi)
						   in [actual##midreds##[m, #ms]]
					       fi {K-char matches a face}
					  else []
					  fi {pos on LKTs}
				   od.## {[FaceVertsKHash]})
	 od
    {then () = LFKH := sort(G, Lvd, LFKH)}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	       " for localFD_Khashbt to height ", HT, " and dim ",t-1,
	       "; face counts = ", for list in LFKH do #list od) fi
    in if sort_LFD_flag
       then sort(G,Lvd,LFKH)
       else LFKH
       fi
)

set extend_character_verbose = false

set extend_K_characters(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
    if fund_face_verbose
    then prints(new_line,"start extend_K_characters for ", [int]: for list in LFKH do #list od, " faces")
    fi;
    let G = x.real_form, start = elapsed_ms(), red_shift = if red_count_flag then 1 else 0 fi
    then answer =
       for d:#LFKH
       do [vec]: if extend_character_verbose then prints(new_line, "start to extend ",#LFKH[d],
			     " K-characters in dimension ",d,
			     " in extend_K_characters")
	  fi; for v@k in LFKH[d]
	      ~do if k%(max(#LFKH[d]\10,2))=0 and extend_character_verbose {try tilde}
		 then prints("calculating K-character on face ",k,
		      " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		 fi;
		 let nu = face_bary(Lvd, v[:d+1]), w=v
		 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
		 then p0 = parameter(x, lambda, nu)
		 then P = finalize(p0)
		 {then startCF = elapsed_ms()}
		 then m = ktp_hash.match(K_type_pol(character_formula(P)))
		 {then () = charTime +:= elapsed_ms() - startCF}
		 then () = w[d+red_shift+1] := m
		 then () = if red_count_flag
			   then w[d+1]:= red_count(p0)
			   fi
		 in w
	      od
      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
		  " for extend_K_characters") fi
     in answer {sort(G,Lvd,answer)}

set extend_K_characters(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, int HT, KTypePol_hash ktp_hash) =
	[[FaceVertsKHash]]:
    if fund_face_verbose
    then prints(new_line,"start extend_K_characters to height ",HT, " for ",
	 [int]: for list in LFKH do #list od, " faces")
    fi;
    let G = x.real_form, start = elapsed_ms(), red_shift = if red_count_flag then 1 else 0 fi
    then answer =
       for d:#LFKH
	do [vec]: if extend_character_verbose then prints(new_line, "start to extend ",#LFKH[d], {try tilde}
			     " K-characters in dimension ",d, " to height ",HT)
	  fi;   for v@k in LFKH[d]
		do if k%(max(#LFKH[d]\10,2))=0 and extend_character_verbose {try tilde}
		 then prints("calculating K-character on face ",k,
		      " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		 fi;
		 let nu = face_bary(Lvd, v[:d+1]), w=v
		 then p0 = parameter(x, lambda, nu)
		 then P = finalize(p0)
		 then m = ktp_hash.match(if to_htB_flag
					 then K_type_pol(composition_series_to_heightB(P,HT))
					 else K_type_pol(character_formula_to_height(P,HT))
					 fi)
		 then () = w[d+red_shift+1] := m
		 then () = if red_count_flag
			   then w[d+1]:= red_count(p0,HT)
			   fi
		 in w
	      od
       od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
		  " for extend_K_characters to ht ", HT) fi
     in answer

set extend_K_characters_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, KTypePol_hash ktp_hash, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    if fund_face_verbose
    then prints(new_line,"start extend_K_characters_graph for ", [int]:
	 for list in LFKH do #list od, " faces")
    fi;
    let G = x.real_form, start = elapsed_ms(), NumClasses = #eq
    then polNums = [int]: {these are indices in ktp_hash of new K-characters}
       for C in eq
       do let (d,j) = coords(LFKH,C~[0]) {the tilde chooses a
	  representative on largest possible face, so least integral}
	  then verts = vec: LFKH[d][j][:d+1]
	  then pC = parameter(x,lambda,face_bary(Lvd,verts))
	  then PC = finalize(pC)
	  {then startCF = elapsed_ms()}
	  then m = {char_counter.use();} ktp_hash.match(K_type_pol(character_formula(PC)))
	  {then () = charTime +:= elapsed_ms() - startCF}
	  in m
       od {C in eq}
     then answer = for LFd@d in LFKH
		   do [vec]: for j:#LFd
		      do let v = LFd[j]
			 then () = v[d+2] := polNums[classListByFace[d][j]]
			 in v
		      od {fix d-diml faces}
		   od {fix all faces}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
		  " for extend_K_characters_graph") fi
     in sort(x.real_form, Lvd, answer)

set extend_K_characters_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, int HT, KTypePol_hash ktp_hash, [[int]] eq, [vec] classListByFace) =
	[[FaceVertsKHash]]:
    if fund_face_verbose
    then prints(new_line,"start extend_K_characters_graph to height ",HT, " for ",
    [int]: for list in LFKH do #list od, " faces")
    fi;
    let G = x.real_form, start = elapsed_ms(), NumClasses = #eq
    then polNums = [int]: {these are indices in ktp_hash of new K-characters}
       for C in eq
       do let (d,j) = coords(LFKH,C~[0]) {the tilde chooses a
	  representative on largest possible face, so least integral}
	  then verts = vec: LFKH[d][j][:d+1]
	  then pC = parameter(x,lambda,face_bary(Lvd,verts))
	  then PC = finalize(pC)
	  then m = ktp_hash.match(if to_htB_flag
				  then K_type_pol(composition_series_to_heightB(PC,HT))
				  else K_type_pol(character_formula_to_height(PC,HT))
				  fi)
	  in m
       od {C in eq}
     then answer = for LFd@d in LFKH
		   do [vec]: for j:#LFd
		      do let v = LFd[j]
			 then () = v[d+2] := polNums[classListByFace[d][j]]
			 in v
		      od {fix d-diml faces}
		   od {fix all faces}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
		  " for extend_K_characters_graph") fi
     in answer
