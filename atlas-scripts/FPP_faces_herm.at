{this file concerns (local) facets of parameters, in preparation of analysis of their unitarity.}
<FPP_faces_geom.at
<goodroots.at { for is_pos_on_LKTs }
<Dirac.at
<hermitian.at
<K_highest_weights.at {for all_lambda_differential_0}
<unity.at {for deform_hts}
{BREAK HERE?}


{takes the known unitaries from unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let ps = for d:#LFDKH
    	     do for v in LFDKH[d]
	     	do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1])))}
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
       	  do if p.nu.=
	     then [j]
	     else let qs = monomials(finalize(p))
	     	  in if all(for q in qs do @bool: Uhash.lookup(q).>= od)
	     	     then [j]
		     else []
		     fi
	     fi
	  od.##
       od

{Here UhashLocal is assumed to consist of Param's at (x,lambda)}
{this misses (in local_testK_level) unitary Param's that finalize to different x;
those are caught by local_testK_hash}
set known_unitaries(Param_hash UhashLocal, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
    	      	  	    	     	      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = UhashLocal.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
       	 do let p = UhashLocal.index(k)
       	    then list = local_vertices(p)
            in if #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
	     	    then m = lookups[#list-1](local_verts)
		    then () = assert(m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]#:=m
		    in ()
	       fi
	 od
     in out

{takes the known non-unitaries from non-unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
{set known_non_unitaries(Param_hash NUhash, KGBElt x, ratvec lambda, VertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let ps = for d:#LFDKH
    	     do for v in LFDKH[d]
	     	do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
       	  do let qs = monomials(finalize(p))
	     in if all(for q in qs do @bool: NUhash.lookup(q).>= od)
	     	then [j]
		else []
		fi
	  od.##
       od}


set localize(Param_hash Uhash, KGBElt x, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.x = x and p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc

set localize(Param_hash Uhash, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc
{collection of lookup functions for faces of various dimensions}
set lookups([[vec]] LFD) = [(vec->int)]:
    for L@d in LFD do index_in(for v in L do v[:d+1] od) od

{assume LFDKH has tail coords referring to K-char}
set sort(RealForm G, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH, int tail) = [[FaceVertsKHash]]:
    if sort_LFD_flag
    then let tworhocheck = G.two_rho_check
    	 then f(vec v) = int:
    	      let (num,den) = %(sum(for j in v[:#v - tail] do Lvd.list[j]*tworhocheck od)*1000)
	      in num\den
    	 in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
    else LFDKH
    fi

{this is the Q(infinitesimal character) bound provided by Dirac inequality on all LKTs}
set DiracBD(KGBElt x, ratvec lambda) = rat:
    let G = x.real_form
    then Q = invariant_form(G)
    in if not(Dirac_flag and is_equal_rank(G))
       then Q(G.rho,G.rho)
       else let mus = LKTs(parameter(x,lambda,0*lambda))
       	    then ics = for mu in mus do DiracIC(mu) od
    	    in min(for ic in ics do Q(ic,ic) od)
       fi

{"true" means unitarity is possible in light of Dirac}
{avoid using is_hermitian defined in hermitian.at}
set DiracTest(Param p) = bool:
    let G=p.real_form
    then () = Dirac_flag:=true
    in if not is_equal_rank(G) then return equivalent(twist(p),p) {is_hermitian(p)}
       else let gamma = p.infinitesimal_character
    	    then Q = invariant_form(G)
	    then bound = DiracBD(p.x, p.lambda)
	    in Q(gamma, gamma) <= bound
       fi

{creates LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local verts}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.
parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}

set localFD_Lvd2 \
  (InnerClass ic, mat theta, ratvec lambda, {VertexData vd,} [(ratvec->int)] edge_lookups) =
  (LocalVertexData, PermOrderTwo, vec):
(   let Perm2 = thetaAct2(ic, theta, lambda, {vd,} edge_lookups)
    then vlist = {vd.list}FPP_vertices(ic)
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
	 {def of Perm2 forces this to be an actual edge?}
    then Lvd = (vlistAct,#Perm2.fixed).to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)
)

set localFD_Lvd2 \
  ( KGBElt x, ratvec lambda, {VertexData vd,} [(ratvec->int)] edge_lookups) =
  localFD_Lvd2(x.inner_class, x.involution, lambda, {vd,} edge_lookups)

set localFD_Lvd2 \
  ( InnerClass ic, mat theta, ratvec lambda, {VertexData vd,} (vec->int) FlippedEdgeLookup) =
  (LocalVertexData, PermOrderTwo, vec):
(   let start = elapsed_ms(), Perm2 = thetaAct2(ic, theta, lambda, {vd,} FlippedEdgeLookup)
    then vlist = {vd.list} FPP_vertices(ic)
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans
	 do if FlippedEdgeLookup([i,j]) >= 0
	    then [(vlist[i] + vlist[j])/2]
	    else []
	    fi
	 od.##
    then Lvd = (vlistAct,#Perm2.fixed).to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)
)

set localFD_Lvd2 \
  (KGBElt x, ratvec lambda, {VertexData vd,} (vec->int) FlippedEdgeLookup) = (LocalVertexData, PermOrderTwo, vec):
  localFD_Lvd2(x.inner_class, x.involution, lambda, {vd,} FlippedEdgeLookup)

set FD12Time = int: 0

{takes local data and low global faces and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2, vec mapAct{,
    [[FaceVertsIndex]] globalFaces}) = [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1Dirac")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FaceVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
 	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
 	     then for v in FPP_edges(G){globalFaces[1]}
	       	  do if is_member_sorted(Perm2.fixed)(v[0]) and #Perm2.fixed > mapAct[v[0]]+1
		       	      and is_member_sorted(Perm2.fixed[mapAct[v[0]]+1:])(v[1])
		     then let mloc = mapAct[v[0]], nloc = mapAct[v[1]]
		       	  in if Llookup(mloc) and Llookup(nloc)
			     then [[mloc,nloc]{.sort}]
			     else []
			     fi
		      else []
		      fi
		   od.##
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
      	   then EdgesFixTrans = [vec]:
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
	      	    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
           {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = ([vec]:
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
	      	    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
	          fi
	       od.##)
	  {then () = prints("after TransTrans, time is ",print_time_string(elapsed_ms() - start))}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     { then () = prints("after Edges, time is ",print_time_string(elapsed_ms() - start))}
     then LF1 = [FaceVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v))}
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    then () = FD12Time +:= elapsed_ms() - start
    in if face_verbose then prints("After localFD_1Dirac2, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if time_verbose then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2") fi;
       answer
)

set FD12bzTime = int:0
set FD12bzFFTime = int:0
set FD12bzFTTime = int:0
set FD12bzTTTime = int:0

{takes local data and low global faces and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
{This time assume that globalFaces[d] is list of size
#globalFaces[d-1] of d-faces, the jth list being all global faces that
begin with the jth global (d-1)-face.}
set localFD_1Dirac2_by_zero\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2, vec mapAct) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FaceVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
 	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##{list of j for which vertex j is a candidate}
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let startFF = elapsed_ms()
    	 then EdgesFixFix = [vec]:
             if #Perm2.fixed > 1
	     then for j@k in Perm2.fixed
	     	  do let mloc = mapAct[j] {this is k??}
		     {then () = if k != mloc then prints("(k,mloc) = (",k,",",mloc,")") fi}
		     then cands = FPP_edges_by_zero_unsorted(G)[j]
		     in if Llookup(mloc) and #cands > 0 and #Perm2.fixed>mloc+1
		     	then for v in cands {global edges with v[0] = j}
			     do if is_member_sorted(Perm2.fixed[k+1:])(v[1])
			     	then let nloc =  mapAct[v[1]]
				     in if {nloc > mloc and} Llookup(nloc)
				     	then [[mloc,nloc]]
             				else []
					fi
				else []
				fi
			     od.## {this is the list of edges starting with j}
	     		 else []
			 fi
		   od.## {all FixFix edges}
	       else []
	       fi
	    then () = FD12bzFFTime +:=elapsed_ms() - startFF
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
	   then startFT = elapsed_ms()
      	   then EdgesFixTrans = [vec]:
	   	if #Perm2.fixed > 0 and #Perm2.trans >0
		then for j@k in Perm2.fixed
		     do let mloc = mapAct[j] {this is k?}
		     	then cands = FPP_flippable_triangles_by_zero_unsorted(G)[j]
			in if Llookup(mloc) and #cands > 0
			   then for v in cands
			      	do if trans_hash.lookup(v[1:]).>=
			      	   then let nloc = mapAct[v[1]] {= mapAct[v[2]]}
				      	in if Llookup(nloc)
				      	   then [[mloc,nloc].sort]
					   else []
					   fi
				    else []
				    fi {trans_hash.lookup}
			       	od.## {[vec], all starting with j}
			    else []
			    fi {Llookup(mloc)}
		      od.## {[vec], all j}
		  else []
		  fi
	   then () = FD12bzFTTime +:= elapsed_ms() - startFT
	   then startTT = elapsed_ms()
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #Perm2.trans > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for (i,j)@m in Perm2.trans
	      	      do let a = FEL([i,j]), mloc = mapAct[i] {this is m+#Perm2.fixed?}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if Llookup(mloc) and #cands > 0
		      	    then for v in cands
			      	 do if trans_hash.lookup(v[2:]).>=
			      	    then let nloc = mapAct[v[2]] {equal to lookup?}
				      	 in if Llookup(nloc)
				      	    then [[mloc,nloc].sort]
					    else []
					    fi
				    else []
				    fi {trans_hash.lookup}
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {Llookup(mloc)}
		       od.## {[vec], all mloc}
		 else []
		 fi
	    then () = FD12bzTTTime +:= elapsed_ms() - startTT
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FaceVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    then () = FD12bzTime +:= elapsed_ms() - start
    {then () = if elapsed_ms() - start > 10{FD12bzTime}
    	      then prints("(fixed,trans) = (",#Perm2.fixed, ",",#Perm2.trans, "), face counts (",#LF0,",",#LF1,") took ",print_time_string(elapsed_ms() - start))
	      fi}
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2_by_zero") fi;
       answer
)


set localFD_1Dirac2_by_zero_old\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2, vec mapAct) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FaceVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
 	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##{list of j for which vertex j is a candidate}
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let EdgesFixFix = [vec]:
             if #Perm2.fixed > 1
	     then for j in Perm2.fixed
	     	  do let mloc = mapAct[j]
		     in if Llookup(mloc)
		     	then for v in FPP_edges_by_zero(G)[j] {global edges with v[0] = j}
			     do if is_member_sorted(Perm2.fixed)(v[1])
			     	then let nloc =  mapAct[v[1]]
				     in if nloc > mloc and Llookup(nloc)
				     	then [[mloc,nloc]]
             				else []
					fi
				else []
				fi
			     od.## {this is the list of edges starting with j}
	     		 else []
			 fi
		   od.## {all FixFix edges}
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
      	   then EdgesFixTrans = [vec]:
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
	      	    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
           {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = [vec]:
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
	      	    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
	          fi
	       od.##
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FaceVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    then () = FD12bzTime +:= elapsed_ms() - start
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2_by_zero") fi;
       answer
)

{takes 0 and 1-diml local faces and adds K-char index}
set localFD_KHash_01 (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF) = [[FaceVertsKHash]]:
    let start = elapsed_ms()
    then answer = for d:#LF
    	 do if fund_face_verbose then prints(new_line, "start to compute ",#LF[d],
       	  		     " K-characters in dimension ",d,
			     " in localFD_KHash_01")
       	     fi;
	     for v@k in LF[d]
       	     do if k%(max(#LF[d]\10,2))=0 and fund_face_verbose
	      	then prints("examining face ",k,
	      	   "; #ktp_hash = ",ktp_hash.size())
	      	fi;
		let nu = face_bary(Lvd, v)
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v))}
       	      	then p0 = parameter(x, lambda, nu)
	      	then P = finalize(p0)
		then () = char_counter.use()
		then startCF = elapsed_ms()
	      	then Q = K_type_pol(character_formula(P))
		then () = charTime +:= elapsed_ms() - startCF
	      	in v##[ktp_hash.match(Q), #monomials(P)]
       	     od
    	od
   {then () = answer:= sort(x.real_form, Lvd, answer, 2)} {ARGUMENT ALREADY SORTED}
   then time = elapsed_ms() - start
   then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01 (vertex/edge K-chars)") fi
   in answer

{takes 0 and 1-diml local faces and adds K-char index to height HT}
set localFD_KHash_01 (KGBElt x, ratvec lambda, LocalVertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF) = [[FaceVertsKHash]]:
    let start = elapsed_ms()
    then answer = for d:#LF
    	 do if fund_face_verbose then prints(new_line, "start to compute ",#LF[d],
       	  		     " K-characters to height ",HT, " in dimension ",d,
			     " in localFD_KHash_01")
       	    fi; for v@k in LF[d]
       	   do if k%(max(#LF[d]\10,2))=0 and fund_face_verbose
	      then prints("examining face ",k,
	      	   "; #ktp_hash = ",ktp_hash.size())
	      fi;
	      let nu = {face_bary_ic(x.inner_class, face_bary(Lvd.list, v))}face_bary(Lvd, v)
       	      then p0 = parameter(x, lambda, nu)
	      then P = finalize(p0)
	      then () = char_counter.use()
	      then startCF = elapsed_ms()
	      then Q = K_type_pol(character_formula_to_height(P,HT))
	      then () = charTime +:= elapsed_ms() - startCF
	      in v##[ktp_hash.match(Q), #monomials(P)]
       	    od
    	  od
   {then () = answer:= sort(x.real_form, Lvd, answer, 2)} {argument already sorted}
   then time = elapsed_ms() - start
   then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01 (vertex/edge K chars) to height ", HT) fi
   in answer

{takes list of 0- and d-diml faces, with d \ge 1, and builds all
d+1-diml faces having all faces in the d-diml list. The int e is the
number of extra coords in each face.}
set superFaces([vec] L0, [vec] Ld, int e) =
    [vec]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [vec]:
   for v in L0
   do let m0 = v[0] {first vertex in new face}
      in [vec]:
      	 for small in Ld
      	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    elif any(for k:d+1 do lookupsd( m0#(small[:k]##small[k+1:d+1])) = -1 od)
	    then [] {require all d-faces to be in Ld}
	    else [m0#small[:d+1]] {now m0##small is a candidate face}
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFaces was ",
		      	print_time_string(elapsed_ms() - start))
          fi}
in answer
fi

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
(   {if face_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;}
    let G = x.real_form, start=elapsed_ms()
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFaces(LFKH[0],LFKH[dim-1],2)
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then let () = char_counter.use()
					      then startCF = elapsed_ms()
					      then Q = character_formula(P)
					      then () = charTime +:= elapsed_ms() - startCF
					      in [actual##[ktp_hash.match(
				              K_type_pol(Q)), #ms]]
		       		    	 else []
				    	 fi
		    	      	   od.## {[FaceVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, 2)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt to dim ",t-1) fi
    in if(face_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, face counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)


{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t). This time
just calculate K characters to HT

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t, int HT, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
(   if face_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;
    let G = x.real_form, start=elapsed_ms()
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFaces(LFKH[0],LFKH[dim-1],2)
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then let startCF = elapsed_ms()
					      then () = char_counter.use()
					      then Q = character_formula_to_height(P,HT)
					      then () = charTime +:= elapsed_ms() - startCF
					      in [actual##[ktp_hash.match(
				              K_type_pol(Q)), #ms]]
		       		    	 else []
				    	 fi
		    	      	   od.## {[FaceVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, 2)
    {then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	       " for localFD_Khashbt to height ", HT, " and dim ",t-1) fi}
    in if(face_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, face counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)

set extend_K_characters(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
    {if face_verbose
    then prints(new_line,"start extend_K_characters")
    fi;}
    let G = x.real_form, start = elapsed_ms()
    then answer =
       for d:#LFKH
       do if fund_face_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_face_verbose
	      	 then prints("examining face ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = face_bary(Lvd, v[:d+1]), w=v
		 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
		 then () = char_counter.use()
		 then startCF = elapsed_ms()
	  	 then Q = K_type_pol(character_formula(P))
		 then () = charTime +:= elapsed_ms() - startCF
	  	 then () = w[d+1] := ktp_hash.match(Q)
		 in w
              od
      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters") fi
     in answer

set extend_K_characters(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, int ht, KTypePol_hash ktp_hash) =
    	[[FaceVertsKHash]]:
    if face_verbose
    then prints(new_line,"start extend_K_characters to height ",ht)
    fi;
    let G = x.real_form, start = elapsed_ms()
    then answer =
       for d:#LFKH
       do if fund_face_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_face_verbose
	      	 then prints("examining face ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = face_bary(Lvd, v[:d+1]), w=v
		 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
		 then () = char_counter.use()
		 then startCF = elapsed_ms()
	  	 then Q = K_type_pol(character_formula_to_height(P,ht))
		 then () = charTime +:= elapsed_ms() - startCF
	  	 then () = w[d+1] := ktp_hash.match(Q)
		 in w
              od
       od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters to ht ", ht) fi
     in answer

{version of solve from basic using precomputed echelon form, to speed repeated calcs}
set solve(vec b, mat M, mat C, [int] s) = maybe_a_vec:
(    let (n,k)=shape(M)
     then j=0 { runs up to k, used to index backwards }, sol=null(k)
     in assert(#b=n,"equation mismatch");
     	for i:n
       ~do if j<#s and i=s~[j] { then it is a pivot row, with pivot at M[j][i] }
       	   then let Mj=M~[j]
	   	then (q,r)=b[i]\%Mj[i]
		in if !=r then return ().no_vec { because inexact division} fi;
       		   sol~[j]:=q;
		   b-:=Mj*q; { correct for contribution from sol[j~] }
       		   j+:=1
       	    elif !=b[i] then return ().no_vec { because no pivot available }
       	    fi
   	 od;
	 (C[:k]*sol).solution
)

{these are the possible lambda+theta*lambda for x.involution = theta. First
vec hash includes all candidate lamthlam (for which a lambda in X* + rho exists).
For each lamthlam there is a Perm2 in the second list.}
set cands_hash(InnerClass ic, mat theta, vec_hash lamthlam_hash) = [PermOrderTwo]:
    let th1 = 1+theta, verts = FPP_vertices(ic), FEs = FPP_flippable_edges(ic),
    	Perm2s = [PermOrderTwo]: [], empty = [(int,int)]: []
    then shift = (-th1*ic.rho).numer
    then () = for v@j in verts
       	      do let w = th1*v
       	      	 in if w.denom = 1 and any(vec_solve(th1, w.numer + shift))
	       	    then let M = lamthlam_hash.size()
	       	    then m = lamthlam_hash.match(w.numer)
	       	    in if m = M
	     	       then let () = Perm2s #:= (vec: [j],empty)
		       	    in ()
		       else let Perm2sm = Perm2s[m]
			    then () = Perm2sm.fixed #:= j
			    then () = Perm2s[m] := Perm2sm
			    in ()
		       fi
	            fi
               od
    then () = for pair in FEs
    	      do  let a = verts[pair[0]], b = verts[pair[1]]
	      	  then w = a+theta*b
	      	  in if theta*w = w and w.denom = 1
		     and any(vec_solve(th1, w.numer + shift))
		     then let M = lamthlam_hash.size()
	             then m = lamthlam_hash.match(w.numer)
	             in if m = M
		     	then let () = Perm2s #:= (null(0),[(pair[0],pair[1])])
			     in ()
			else let Perm2sm = Perm2s[m]
			     then () = Perm2sm.trans #:= (pair[0],pair[1])
			     then () = Perm2s[m] := Perm2sm
			     in ()
			fi
		     fi
	       od
     in Perm2s

set Lnu(Param p) = RealForm:
    let p1 = to_no_Cplus(p), G=p.real_form
    then rhoi1 = rho_i(p1.x)
    then rdnu = centralizer(G,[rhoi1.numer])
    in quasisplit_form(inner_class(rdnu, p1.x.involution))


set Wnu(Param p) = [WeylElt]:
    let Lnu = Lnu(p), p1 = to_no_Cplus(p), rho = p.real_form.rho
    then theta1 = p1.x.involution
    in for w1 in Weyl_orbit_ws(Lnu,(p1.infinitesimal_character).numer)
       do if w1*theta1 = theta1*w1 and parameter(p1.x, w1*(p1.lambda - rho)+rho, 0*rho) = p1*0
       	  then [w1]
	  else [] fi
       od.##

set maxPR_cowts(Param p) = [vec]:
    let p1 = to_no_Cplus(p), G = p.real_form
    then theta = p1.x.involution {, xo = x_open(G)}
    then coweights = for xi in G.fundamental_coweights
    	 	   do (xi - xi*theta).numer
		   od.no_reps
    then M = null(rank(G),0)
    then () = for tau in coweights
       	      do if rank(M#tau) = rank(M) + 1
       	      	 then M#:=tau
	  	 fi
       	      od
    in M

{result is tuples ([dpLs]) with pL hermitian and p = Ind_P^G(pL); so pL and p are unitary iff all the dpLs are}
set ind_cand_params = (Param -> [Param]):
    let param_hash = make_Param_hash()
    then answers = [[Param]]: [] {one for each Param known}
    in (Param -> [Param]): (Param p) [Param]:
       if not is_hermitian(p) then return [] fi;
       let I = param_hash.size()
       then i = param_hash.match(p)
       then () = if i=I
       	       	 then let G = p.real_form, p1 = to_no_Cplus(p)
    		      then xo = x_open(G)
    		      then lists = for tau in maxPR_cowts(p)
    	 	      	   	   do let Q = parabolic_by_cwt(tau, xo)
	    		      	      then L = Q.Levi
	    		      	      then x1L = inverse_embed_KGB(p1.x, L)
	    		      	      then lambda1L = p1.lambda - rho_u(Q)
	    		      	      then list = [Param]: []
	    		      	      then () =  for w1 in Wnu(p)
	       	       	      	      	   do let p1L = first_param(finalize(
					      parameter(x1L, lambda1L, w1*p1.nu)))
		       	  		      in if is_hermitian(p1L)
		      	     		     	    {and is_FPP(L, p1L.infinitesimal_character)}
		     	    			    and real_induce_irreducible(p1L,G) = p
	       	     	     		          then list := for q in derived_factor_params0((p1L))										  do herm_center(q)
						       	       od
	       		    			  fi
	 	        		    od
	    		      	      in list
	 		    	    od
		       then j = first(for list in lists do #list >0 od)
		       in if j.>=
		       	  then answers#:= lists[j]
			  else answers#:= []
		   	  fi
		   fi

	then ()= assert(#answers = param_hash.size(),"ind_cand_params hash damaged")
	in answers[i]

set_type Lvd_Perm2_mapAct = (LocalVertexData Lvd, PermOrderTwo Perm2, vec mapAct)

set Perm2_to_LPm(InnerClass ic, PermOrderTwo Perm2) = Lvd_Perm2_mapAct:
    let verts = FPP_vertices(ic)
    then FEs = FPP_flippable_edges(ic)
    then vlist = (for f in Perm2.fixed do verts[f] od)## (for (p,q) in Perm2.trans do face_bary(verts,[p,q]) od)
    then Lvd = to_vertex_data(vlist,#Perm2.fixed)
    then mapAct = vec: for j:#verts do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for f@k in Perm2.fixed do mapAct[f]:= k od
    then () = for (p,q)@ell in Perm2.trans do mapAct[p]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[q]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)

{Record for each inner class a list of some involutions in inner class; and for each such involution,
 some possible lambdas; and for each such lambda, a list of (local vertex data, Perm2, mapAct)}
set_type
[Lvd_Perm2_mapAct_table =

( (->int) inner_class_size {number of inner classes included}
  , ( -> vec) ic_vlist_size {for each inner class, the number of FPP-vertices}
  , ( -> ) clear
  , ( -> vec) involution_size {for each inner class, number of involutions so far considered}
  , ( -> [vec]) lamthlam_size {for each inner class and involution, number of d_lambdas (actually lambda+theta*lambda)
      	 		       so far considered}
{  , ( -> [vec]) cands_size {for each inner class and involution, number of candidate lambda+theta*lambda
      	 		       so far considered}}
  , ( -> [[vec]]) Lvd_list_size {for each inner class and involution and d_lambda, size of Lvd.list}
  , (InnerClass -> VertexData) FPP_vertex_data {one for each inner class}
  , (InnerClass -> (vec -> int)) flippable_edge_lookup
  {, (InnerClass -> [FaceVertsIndex]) FPP_flip_tet}
  , (InnerClass -> [ratvec]) FPP_local_vertices {one for each inner class}
{  , ((InnerClass, mat) -> [vec]) cands {for each involution, a list of candidates for lambda+theta_lambda}}
  , ((InnerClass, mat) -> [vec]) lamthlams {for each involution, list of allowed lambda+theta_lambda}
  , ((InnerClass, mat, vec) -> int) lamthlam_number {for each involution, number of lambda+theta_lambda in list}
  , ((InnerClass, mat) -> [ratvec]) lambda0s {for each involution, list of allowed lambda mod twists}
  , ((InnerClass, mat,vec) -> PermOrderTwo) Perm2 {for each involution and lamthlam, corresponding Perm2}
  , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2_mapAct)]) LPm_entries {allowed lambda mod twists, corr entry}
    		       	  	    {like output of old FPP_lambdas_big_new}
  , ((InnerClass, mat, vec) -> LocalVertexData) Lvd {local vertex data, one for each theta and lambda+theta*lambda}
  , ((InnerClass, mat, vec) -> Lvd_Perm2_mapAct) LPm_entry {one for each theta and lambda+theta*lambda}
{  , ((InnerClass, mat, vec) -> ) append {just compute, don't report LPm entry}}
  , (int -> InnerClass) inner_class_index
  , (int -> VertexData) vd_index {vertex data for inner class}
  , ((int,int,int) -> Lvd_Perm2_mapAct) Lvd_Perm2_mapAct_index {one for each inner class, involution,
    		      					       lambda + theta*lambda}
)
]

set make_Lvd_Perm2_mapAct_table() = Lvd_Perm2_mapAct_table:
(   let inner_class_hash = make_InnerClass_hash()
    then inv_hashes = [mat_hash]: [] {one for each inner class}
    then vertex_datas = [VertexData]: [] {one for each inner class}
    then FELs = [(vec->int)]: [] {one for each inner class}
    then FPP_local_verts = [[ratvec]]: [] {one list for each inner class}
{    then cands = [[[vec]]]: [] {one [vec] for each inner class and involution}}
    then lamthlam_hashess = [[vec_hash]]: [] {one for each inner class and involution}
    	 {entries are vecs of size ic.rank: lamba+theta*lambda, for a
	 	  certain choice of lambda (defined up to twist and equivalence}
    then Perm2s = [[[PermOrderTwo]]]: [] {one for each involution and cand lamthlam}
    then entries = [[[Lvd_Perm2_mapAct]]]: [] {one list for each involution and cand lamthlam}
    then clear() = void:
    	 let () = inner_class_hash.clear()
	 then () = inv_hashes := []
	 then () = vertex_datas := []
	 then () = FELs := []
	 then () = FPP_local_verts := []
{	 then () = cands := []}
	 then () = lamthlam_hashess := []
	 then () = Perm2s := []
	 then () = entries := []
	 in ()
    then add_inner_class(InnerClass ic) = int:
    	 let I = inner_class_hash.size()
	 then i = inner_class_hash.match(ic)
    	 then () = if i = I {haven't seen this inner class before}
	      	   then inv_hashes #:= make_mat_hash();
	    	   	vertex_datas #:= FPP_vertex_data(ic);
			FELs #:= FPP_flippable_edge_lookup(ic);
	    	   	FPP_local_verts #:= FPP_local_vertices(ic, vertex_datas[i].list, FELs[i]);
{			cands #:= [];}
	    	   	lamthlam_hashess #:= [];
			Perm2s #:= [];
	    	   	entries #:= []
	    	   fi
	  in i
     then add_involution(InnerClass ic, mat theta) = (int, int):
    	 let i = add_inner_class(ic)
	 then J = inv_hashes[i].size()
      	 then j = inv_hashes[i].match(theta)
     	 then () = if j = J {haven't seen this involution before}
      	      	   then {cands[i] #:= [];}
			lamthlam_hashess[i] #:= make_vec_hash();
			Perm2s[i] #:= [];
		   	entries[i] #:= []
		   fi
	 in (i, j)
    then add_cands(InnerClass ic, mat theta) = (int, int):
    	 let (i,j) = add_involution(ic,theta)
	 then tempPerm2si = Perm2s[i]
	 then entriesi = entries[i]
	 then () = if {#cands[i][j] > 0} lamthlam_hashess[i][j].size() > 0
	 	   then return (i,j)
	 	   else let Perm2cands = cands_hash(ic,theta, lamthlam_hashess[i][j]) {this  writes to the hash table the possible lamthlam}
			then () = tempPerm2si[j] := Perm2cands
			then () = entriesi[j] := for lamthlam@k in lamthlam_hashess[i][j].list()
			     	       	    do let Perm2 = Perm2cands[k]
				     	       in Perm2_to_LPm(ic,Perm2)
					    od
			then () = Perm2s[i] :=tempPerm2si
			then () = entries[i] := entriesi
			in ()
		    fi
	 in (i,j)
    then add_KGBElt(KGBElt x) = (int,int):
    	 let i = add_inner_class(x.inner_class)
    	 then n = x.number
	 in (i,n)
    in
    ( ( -> int): {inner_class_size} @int: inner_class_hash.size()
    , ( -> vec): {ic_vlist_size} @vec: for vd in vertex_datas do #vd.list od
    , ( -> ): {clear} clear
    , ( -> vec): {involution_size} @vec: for inv_hash in inv_hashes do inv_hash.size() od
    , ( -> [vec]): {lamthlam_size} @[vec]:
      for lamthlam_hashes in lamthlam_hashess {ith inner class}
      do for lamthlam_hash in lamthlam_hashes    {jth involution}
      	 do lamthlam_hash.size()
	 od
      od
    , ( -> [[vec]]): {Lvd_list_size} @[[vec]]:
      for i: #entries
      do for j: #entries[i]
	 do for k: #entries[i][j]
	    do #(entries[i][j][k].Lvd.list)
	    od {vec for involution}
	 od {[vec] for inner class}
      od
    , (InnerClass -> VertexData): {FPP_vertex_data}  (InnerClass ic) VertexData:
      let i = add_inner_class(ic)
      in vertex_datas[i]
    , (InnerClass -> (vec -> int)): {flippable_edge_lookup} (InnerClass ic) (vec -> int):
      let i = add_inner_class(ic)
      in FELs[i]
    , (InnerClass -> [ratvec]): {FPP_local_vertices} (InnerClass ic)  [ratvec]:
      let i = add_inner_class(ic)
       in FPP_local_verts[i]
{    , ((InnerClass, mat) -> [vec]): {cands} (InnerClass ic, mat theta) [vec]:
      let (i,j) = add_cands(ic,theta)
      in cands[i][j]}
    , ((InnerClass, mat) -> [vec]): {lamthlams} (InnerClass ic, mat theta) [vec]:
      let (i,j) = add_cands(ic,theta)
      in lamthlam_hashess[i][j].list()
     , ((InnerClass, mat, vec) -> int): {lamthlam_number} (InnerClass ic, mat theta, vec lamthlam) int:
      let (i,j) = add_cands(ic,theta), th1 = theta+1
      in lamthlam_hashess[i][j].lookup(lamthlam)
    , ((InnerClass, mat) -> [ratvec]): {lambda0s} (InnerClass ic, mat theta) [ratvec]:
      let (i,j) = add_cands(ic,theta), th1 = 1+theta
      in for lamthlam in lamthlam_hashess[i][j].list()  {k:lamthlam_hashess[i][j].size()}
      	 do let lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
      	    in lr+ic.rho
	 od
    , ((InnerClass, mat,vec) -> PermOrderTwo): {Perm2} (InnerClass ic, mat theta, vec lamthlam):
      let (i,j) = add_cands(ic,theta)
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in Perm2s[i][j][k]
    , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2_mapAct)]): {LPm_entries} (InnerClass ic, mat theta)
      [(ratvec, Lvd_Perm2_mapAct)]:
      let (i,j) = add_cands{lamthlam_hash}(ic,theta), th1 = theta+1
      in for lamthlam@k in lamthlam_hashess[i][j].list()
	 do let lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
	    in (lr+ic.rho, entries[i][j][k])
	 od
    , ((InnerClass, mat, vec) -> LocalVertexData): {Lvd} (InnerClass ic, mat theta, vec lamthlam)
      		    LocalVertexData:
      let (i,j) = add_cands{lamthlam_hash}(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k].Lvd
      {the next function FAILS in U(3,3), called inside FPP_unitary_hash(U(3,3))}
    , ((InnerClass, mat, vec) -> Lvd_Perm2_mapAct): {LPm_entry} (InnerClass ic, mat theta, vec lamthlam)
    Lvd_Perm2_mapAct:
      let (i,j) = add_cands(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k]
    , (int -> InnerClass): {inner_class_index} (int i) InnerClass: inner_class_hash.index(i)
    , (int -> VertexData): {vd_index} (int i) VertexData: vertex_datas[i]
    , ((int,int,int) -> Lvd_Perm2_mapAct): {Lvd_Perm2_mapAct_index} (int i, int j, int k): Lvd_Perm2_mapAct:
      entries[i][j][k]
)
)

set LPm_table = make_Lvd_Perm2_mapAct_table()

{this is the list of all possible lambda + theta*lambda for ic and theta}
set FPP_lamthlams(InnerClass ic, mat theta) = [vec]:
    LPm_table.lamthlams(ic,theta)

{list of lambdas up to twist by differential zero}
set FPP_lambda0s(InnerClass ic, mat theta) = [ratvec]:
    LPm_table.lambda0s(ic, theta)

set_type
[FPP_lambda_table =

( (->int) real_form_size {number of RealForms included}
  , ( -> ) clear
  , (KGBElt -> int) add_KGBElt
  , (KGBElt -> [ratvec]) FPP_lambdas {for each inner class, the number of FPP-vertices}
  , ((KGBElt,ratvec) -> int) position {location of lambda in FPP_lambdas(x)}
)
]

set make_FPP_lambda_table() = FPP_lambda_table:
(   let real_form_hash = make_RealForm_hash()
    then lambda_hashess = [[ratvec_hash]]: [] {one ratvec_hash for each real form and KGBElt}
    then clear() = void:
    	 let () = real_form_hash.clear()
	 then () = lambda_hashess := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then lambda_hashess #:= for x in KGB(rf) do make_ratvec_hash() od
	    	   fi
	  in i
    then add_KGBElt(KGBElt x) = int:
    	 let i = add_real_form(x.real_form)
    	 then n = x.number
	 then () = if lambda_hashess[i][n].size() = 0 {haven't computed FPP_lambdas(x)}
	      	   then let zeroPol = null_module(x.real_form), zeroNu = null(x.real_form.rank)/1
		   	then longlist = LPm_table.lambda0s(x.inner_class, x.involution),
			     twists = all_lambda_differential_0(x.involution)
			then list0 = for lambda0 in longlist
			     	     do let q = parameter(x, lambda0, zeroNu)
				     	in if q!= zeroPol
				     	then [q.lambda]
					else []
					fi
				     od.##
			in for l0 in list0
			   do for tau in twists
			      do lambda_hashess[i][n].match(parameter(x,l0+tau,zeroNu).lambda)
	  		      od
       			   od.##
		     fi
	  in n
     in
( (->int): {real_form_size} @int: real_form_hash.size()
  , ( -> ): clear
  , (KGBElt -> int): {add_KGBElt} (KGBElt x) int: add_KGBElt(x)
  , (KGBElt -> [ratvec]): {FPP_lambdas} (KGBElt x) [ratvec]:
    let i = add_real_form(x.real_form)
    then n = add_KGBElt(x)
    in lambda_hashess[i][n].list()
  , ((KGBElt,ratvec) -> int): {position} (KGBElt x, ratvec lambda) int:
    let i = add_real_form(x.real_form)
    then n = add_KGBElt(x)
    in lambda_hashess[i][n].lookup(lambda)
)
)

set FPP_lam_table = make_FPP_lambda_table()

{list of lambdas for x up to twist by differential zero}
set FPP_lambda0s(KGBElt x) = [ratvec]:
    let longlist = LPm_table.lambda0s(x.inner_class, x.involution), G=x.real_form
    then zeroPol = null_module(G), zeroNu = null(G.rank)/1
    in for lambda0 in longlist
       do if 1*parameter(x, lambda0, zeroNu) != zeroPol
       	  then [lambda0]
	  else []
	  fi
       od.##

set FPP_lambda_table_flag = true

set FPP_lambdas(KGBElt x) = [ratvec]:
    if FPP_lambda_table_flag
    then FPP_lam_table.FPP_lambdas(x)
    else let list0 = FPP_lambda0s(x), G=x.real_form
    	 then twists = all_lambda_differential_0(x.involution)
	 then zeroNu = null(G.rank)/1
	 in for ell0 in list0
	    do for tau in twists
	       do parameter(x,ell0+tau,zeroNu).lambda
	       od
       	     od.##
    fi

set position_time = int:0

{location of lambda in FPP_lambdas(x)}
set position(KGBElt x, ratvec lambda) = int:
    let start = elapsed_ms()
    then lambdaNorm = parameter(x,lambda,0*lambda).lambda
    then N = FPP_lam_table.position(x,lambdaNorm)
    {then () = if N=-1 then prints("WARNING: at G = ",x.real_form,", x = ",x.number,", lambda = ",
    	 lambdaNorm," is not attached to x.") fi}
    then () = position_time +:= elapsed_ms() - start
    in N

set FPP_lambdas([KGBElt] xs) = [[ratvec]]:
    for x in xs
    do FPP_lambdas(x)
    od

set nullint(int N) = [int]:
    for n:N do 0 od
{whether to include KGB numbers in output files. True makes them more human-readable, sometimes longer}
set write_x_flag = false
{decide NOT to hash nonunitary}
set_type
[big_unitary_hash_table =
( ( -> int) real_form_size {number of real forms included}
  , ( -> vec) uhash_sizes {for every real form, the number of unitary reps}
  , (RealForm -> int) uhash_size {for one real form, number of unitary reps}
  , ( -> ) clear
  , (RealForm -> ) clearG
  , (RealForm -> int) rf_number {number of real form in list}
  , (int -> RealForm) rf_index {jth real form in list}
  , (RealForm -> [int]) xl_known {for each x, bitmap of lambda for which FPP unitary dual is known}
  , (RealForm -> int) x_known {bitmap of x for which entire FPP dual is known}
  , (RealForm -> int) x_partial {bitmap of x for which some lambda have FPP dual known}
  , ((KGBElt,int) -> ) finish {add bitmap of new known (x,lambda) to xl_known}
  , (KGBElt -> ) finishx {add x to x_known}
  , ((RealForm,int) ->) finishxmap {OR int with x_known(RealForm)}
  , (KGBElt -> ) partialx {add x to x_partial}
  , ((RealForm,[int]) -> ) finishall {add bitmaps of all new known (x,lambda) to xl_known}
  , (RealForm -> Param_hash) uhash {hash table of known unitary}
  , (Param -> (int,int)) long_lookup {(rf_index(p.real_form), location of p in its uhash)}
  , (Param -> int) lookup {(location of p in its uhash)}
  , (Param -> bool) check {check whether p is unitary, and if so add to its hash table}
  , (Param -> int) match {add p to its hash table}
  , ((Param,int) -> int) long_match {add p to ith hash table}
  , ( -> ) write {output unitary data for file}
  , (RealForm -> ) writeG {output data for one group to file}
  , ((RealForm, int, int) -> ) writeGrange {output data for KGB(G)[low,high]}
  , ((KGBElt, ratvec) -> ) writexlam {output data for one x,lambda}
)
]

set finish_time = int:0
set is_finished_time = int:0

set make_big_unitary_hash() = big_unitary_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then uhashes = [Param_hash]: [] {one for each real form}
    {then nuhashes = [Param_hash]: [] {one for each real form}}
    then xl_known = [[int]]: [] {one bitmap of known (x,lambda) for each real form and x}
    then x_known = [int]: [] {one bitmap of known x for each real form}
    then x_partial = [int]: [] {one bitmap of partially known x for each real form}
    then clearBUH() = void:
    	 let () = real_form_hash.clear()
	 then () = uhashes := []
	 {then () = nuhashes := []}
	 then () = xl_known := []
	 then () = x_known := []
	 then () = x_partial := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then	let empty = [int]: nullint(#KGB(rf))
		   	then () = xl_known #:= empty {null(#KGB(rf))}
			then () = x_known #:= 0
			then () = x_partial #:= 0
			in uhashes #:= make_Param_hash()
	    	   fi
	  then () = assert(real_form_hash.size() = #uhashes and #uhashes = #xl_known
	       	    				 and #uhashes = #x_known
						 and #x_partial = #x_known, "big_unitarity_hash damaged")
	  in i
    then clearG(RealForm rf) =
    	 let i = real_form_hash.lookup(rf)
	 in if i >= 0
	    then {prints(i);}
	    	 uhashes[i].clear();
	    	 {prints("i = ",i, ", x_partial = ",x_partial);}
	    	 x_partial[i] := 0;
		 xl_known[i] := nullint(#KGB(rf));
		 x_known[i] := 0
	    fi
    in
    ( (->int): {real_form_size} @int: real_form_hash.size()
    , ( -> vec): {uhash_sizes} @vec: for uhash in uhashes do uhash.size() od
    , (RealForm -> int): {uhash_size} (RealForm rf) int:
      uhashes[add_real_form(rf)].size()
    , ( -> ): {clear} clearBUH
    , (RealForm -> ): {clearG} (RealForm rf):
      clearG(rf)
    , (RealForm -> int): {rf_number} (RealForm rf) int:
      add_real_form(rf)
    , (int -> RealForm): {rf_index} (int i) RealForm:
      real_form_hash.index(i)
    , (RealForm -> [int]): {xl_known} (RealForm rf) [int]:
      let i = add_real_form(rf)
      in xl_known[i]
    , (RealForm -> int): {x_known} (RealForm rf) int:
      let i = add_real_form(rf)
      in x_known[i]
    , (RealForm -> int): {x_partial} (RealForm rf) int:
      let i = add_real_form(rf)
      in x_partial[i]
    , ((KGBElt,int) -> ): {finish} (KGBElt x, int M):
      let start = elapsed_ms()
      then i = add_real_form(x.real_form)
      then xl_knowni = [int]: xl_known[i]
      then () = xl_knowni[x.number] := OR(M,xl_knowni[x.number])
      then () = xl_known[i] := xl_knowni
      {then () = x_partial[i] := OR(to_bitset([x.number]),x_partial[i])
      then () = if xl_known[i][x.number] + 1 = to_bitset([#FPP_lambdas(x)])
      	      	then x_known[i] := OR(to_bitset([x.number]),x_known[i])
		fi}
      then () = finish_time+:= elapsed_ms() - start
      in ()
    , (KGBElt -> ): {finishx} (KGBElt x):
      let i = add_real_form(x.real_form)
      then M = to_bitset([x.number])
      then () = x_known[i] := OR(M,x_known[i])
      then () = x_partial[i] := OR(M,x_partial[i])
      in ()
    , ((RealForm,int) ->): {finishxmap} (RealForm G, int M):
      let i = add_real_form(G)
      then () = x_known[i] := OR(M,x_known[i])
      in ()
    , (KGBElt -> ): {partialx}  (KGBElt x):
      let i = add_real_form(x.real_form)
      then M = to_bitset([x.number])
      then () = x_partial[i] := OR(M,x_partial[i])
      in ()
    , ((RealForm,[int]) -> ): {finishall} (RealForm rf, [int] Ms):
      let start = elapsed_ms()
      then i = add_real_form(rf)
      then xl_knowni = [int]: xl_known[i]
      then () = for n:#KGB(rf)
      	      	do xl_knowni[n] := OR(Ms[n],xl_knowni[n])
		od
      then () = xl_known[i] := xl_knowni
      then v = vec: for M@j in Ms do if M.= then [] else [j] fi od.##
      then () = x_partial[i] := OR(x_partial[i], to_bitset(v))
      in finish_time+:= elapsed_ms() - start
    , (RealForm -> Param_hash): {uhash} (RealForm rf) Param_hash:
      uhashes[add_real_form(rf)]
    , (Param -> (int,int)): {long_lookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      in (i, uhashes[i].lookup(p))
    , (Param -> int): {lookup} (Param p) int:
      let i = add_real_form(p.real_form)
      in uhashes[i].lookup(p)
    , (Param -> bool): {check} (Param p) bool:
      let i = add_real_form(p.real_form)
      {then () = prints("bitmap for ",p.x.number," is ",xl_known[i][p.x.number])}
      then () = p := herm_center(p)
      then j = uhashes[i].lookup(p)
      in if j.>=
      	 then true
      	 elif {now p was not found} is_member_bitset(p.x.number, x_known[i])
	 then false
	 elif {now x not completely known} position(p.x, p.lambda).>=
	 and is_member_bitset(position(p.x, p.lambda), xl_known[i][p.x.number])	 then false
	 else {now nothing complete} let chk = is_unitary(p)
	      	   then () = if chk
	      		     then uhashes[i].match(p)
	      		     {else nuhashes[i].match(p)}
			     fi
	      	   in chk
	  fi
    , (Param -> int): {match} (Param p):
      let i = add_real_form(p.real_form)
      in uhashes[i].match(p)
    , ((Param,int) -> int): {long_match} (Param p, int i):
      uhashes[i].match(p)
    , ( -> ): {write} @void:
    let rf_list = real_form_hash.list()
    in for rf@i in rf_list
       do let Gname = "G"+to_string(i)
	  then listname = Gname+"_list"
	  then intlistname = Gname+"_XLK"
	  then plist = uhashes[i].list()
	  {then bitmapintlist = xl_known[i]}
	  then donemap = x_known[i]
	  then done_list = [int]:[]
	  then () = if write_x_flag then done_list :=
	        for x in KGB(rf)
      	   	       do if is_member_bitset(x.number, donemap)
			  then [x.number]
			  else []
			  fi
		       od.##
		 fi
	  in write_real_form(rf,Gname);
	     prints("set j = big_unitary_hash.rf_number(",Gname,")");
	     for p in plist
	     do let xnum = p.x.number
	     	in prints("void: big_unitary_hash.long_match(parameter(Gname,",xnum,",",p.lambda,",",p.nu,"),j)")
	     od;
	     if write_x_flag
	     then for xnum in done_list
	      	  do prints("void: big_unitary_hash.finishx(KGB(Gname)[",xnum,"])")
	      	  od
	     else prints("void: big_unitary_hash.finishxmap(Gname,",donemap,")")
	     fi
	     {prints("set ",intlistname,"=[int]:[]");
	     write_append(bitmapintlist,intlistname);
	     prints("big_unitary_hash.finishall(",Gname,",",intlistname,")")}
	od
    , (RealForm -> ): {writeG} (RealForm G):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then intlistname = Gname+"_XLK"
      then plist = uhashes[i].list()
      {then bitmapintlist = xl_known[i]}
      then donemap = x_known[i]
      then done_list = [int]:[]
      then () = if write_x_flag then done_list :=
      	      	       for x in KGB(G)
      	   	       do if is_member_bitset(x.number, donemap)
			  then [x.number]
			  else []
			  fi
		       od.##
		 fi
      in write_real_form(G,Gname);
      	 prints("set j = big_unitary_hash.rf_number(",Gname,")"); 
	 for p in plist
	 do let xnum = p.x.number
	    in prints("void:  big_unitary_hash.long_match(parameter(G_temp,",xnum,",",p.lambda,",",p.nu,"),j)")
	 od;
	 {prints("void: big_unitary_hash.finishall(",Gname,",",xl_known[i],")");} {this has length #KGB(G), which is a lot; not worth including}
	 if write_x_flag
	 then for xnum in done_list
	      do prints("void: big_unitary_hash.finishx(KGB(G_temp)[",xnum,"])")
	      od
	 else prints("void: big_unitary_hash.finishxmap(G_temp,",donemap,")")
	 fi
    , ((RealForm, int, int) -> ): {writeGrange} (RealForm G, int low, int high):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list_"+to_string(low)+"_"+to_string(high)
      then intlistname = Gname+"_XLK_"+to_string(low)+"_"+to_string(high)
      then longlist = uhashes[i].list()
      then plist = for p in longlist
      	   	   do if p.x.number >= low and p.x.number < high
		      then [p]
		      else []
		      fi
		   od.##
      then donemap = x_known[i]
      then donerangemap = AND(donemap, 2^high - 2^low)
      then done_list = [int]: []
      then () = if write_x_flag then done_list :=
      	      	       for x in KGB(G)[low:high]
      	   	       do if is_member_bitset(x.number, donemap)
			  then [x.number]
			  else []
			  fi
		       od.##
		fi
      	   {these are the x's being written for which list is complete}
      in write_real_form(G,Gname);
      	 prints("set j = big_unitary_hash.rf_number(",Gname,")"); {, ptemp = GL(1,R).trivial");}
	 for p in plist
	 do let xnum = p.x.number
	    in prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",p.lambda,",",p.nu,"),j)")
	 od;
	 if write_x_flag
	 then for xnum in done_list
	      do prints("void: big_unitary_hash.finishx(KGB(G_temp)[",xnum,"])")
	      od
	 else prints("void: big_unitary_hash.finishxmap(G_temp,",donerangemap,")")
	 fi
    , ((KGBElt,ratvec) -> ): {writexlam} (KGBElt x, ratvec lambda):
      let G = x.real_form
      then xnum = x.number
      then i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then longlist = uhashes[i].list()
      then plist = for p in longlist
      	   	   do if p.x = x and p.lambda = lambda
		      then [p]
		      else []
		      fi
		   od.##
      then N = to_bitset([position(x,lambda)])
      in write_real_form(G,Gname);
         prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",lambda,",",p.nu,"),j)")
	 od;
	 if is_member_bitset(position(x,lambda), xl_known[i][xnum])
	 then prints("big_unitary_hash.finish(KGB(G_temp)[",xnum,"],",to_string(N),")")
	 fi
    )
)

set big_unitary_hash = make_big_unitary_hash()

{. The next family of functions all need simple derived group. Always
|vd.list| should be ALL vertices in the FPP; Lvd.list will be all infl
chars in the FPP for a parameter (x,lambda,*), with x and lambda
fixed. The face lists carried by [[FaceBary]] or [[FaceVertsIndex]]
may be pruned of reps not interesting for unitarity, but the indices
will always refer to a constant vlist.}

set two_to_position(KGBElt x, ratvec lambda) = int:
    to_bitset([position(x,lambda)])

{set a bit in xl_known}
set finish(KGBElt x, ratvec lambda) = void:
    big_unitary_hash.finish(x, two_to_position(x,lambda))

set finish(KGBElt x) = void:
    {let lambdas = FPP_lambdas(x)
    then m = #lambdas
    then M = (to_bitset([m]) - 1)
    in} big_unitary_hash.finishx(x)

{check whether a bit in xl_known is set}
set is_finished(KGBElt x, ratvec lambda) = bool:
    let start = elapsed_ms(), Mx_known = big_unitary_hash.x_known(x.real_form),
    	Mx_partial = big_unitary_hash.x_partial(x.real_form), M = big_unitary_hash.xl_known(x.real_form)[x.number]
    {then () = prints("Mx_known = ",Mx_known,", Mx_partial = ",Mx_partial,", M = ",M)}
    then answer = if is_member_bitset(x.number,Mx_known)
    	 	  then true
		  elif {is_member_bitset(x.number,Mx_partial)
		  then} is_member_bitset(position(x,lambda),M)
		  then true
		  else false
		  fi
    then () = is_finished_time +:= elapsed_ms() - start
    in answer

{list of all pairs (x,lambda) for which complete FPP-unitary dual is present in big_unitary_hash}
set all_finished(RealForm G) = [(KGBElt,ratvec)]:
    let list = for x in KGB(G)
    	       do set_bit_positions(big_unitary_hash.xl_known(G)[x.number])
	       od
    in for x in KGB(G)
       do let poss = list[x.number]
       	  in for pos in poss
       	     do (x, FPP_lambdas(x)[pos])
       	     od
       od.##

set UHBS_time = int: 0

{assume p is hermitian}
set hermitian_form_irreducible_big_SIMPLE(Param p) = KTypePol:
    let L = big_unitary_hash.lookup(p)
    in if L.>= then K_type_pol(character_formula(p))
       else hermitian_form_irreducible(p)
       fi

{this version is only for G simple and hermitian FPP params}
set is_unitary_hash_big_SIMPLE(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let start = elapsed_ms(), G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then return is_unitary(p) {prints("FPP DANGER at ",p)}
	      fi
    {then () = p := herm_center(p)}
    then L = big_unitary_hash.lookup(p)
    {then () = prints("p = ", p, ". L = ",L, ", is_finished = ",is_finished(p.x, p.lambda))}
    then () = if L.>= then return true fi
    then () = if is_finished(p.x, p.lambda) then return L.>= fi
    then (,pL) = wkgood_Q(p)
    then derpLs = for qLj in derived_factor_params0(pL)
    	 	  do monomials(finalize(qLj))
		  od.##
    then () = if #derpLs = 0 then return true fi
    {then () = for derpL in derpLs do big_unitary_hash.rf_index(derpL.real_form) od}
    then statuses = for derpL in derpLs
    		    do big_unitary_hash.check(derpL)
		    od
    then answer =
       if all(statuses) or #statuses = 1 or (all(statuses) and good_L(p) = pL.real_form)
       then statuses[0]
       else {some derpL is not unitary, but the induction is not trivial}
       	    let goodL = good_L(p)
	    in is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
			           goodL)
			      od))
       fi
    then () = UHBS_time+:= elapsed_ms() - start
    in answer

set is_unitary_hash_big(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_hash_big_SIMPLE(pd) od)

{If NU (nu part) > LAM (lambda part) *low_frac, then figure to_ht could work better}
set low_frac = 1/1

{low refers to small lambda}
{"true" should mean nu is large, so these elts are near the
"top" of their blocks, and is_unitary_to_ht is fast.
"false" should mean  nu is small, and is_unitary is fast.}
{N is meant to be a height bound (bigger than height(parameter)}
{set low(KGBElt x, ratvec lambda, int N) = bool:
    let G = x.inner_class
    then theta = x.involution
    then Lvd = LPm_table.Lvd(G, theta, (1+theta)*lambda.numer)
    then LAM = dominant(G, (1+theta)*lambda)*G.two_rho_check + 2*N
    then NU = max(for gamma in Lvd.list do dominant(G, (1-theta)*gamma) *G.two_rho_check od)
    {then R = G.two_rho * G.two_rho_check}
    in NU > low_frac*LAM}

{whether to use to_height in computing to height N}
{true means large nu, so to_ht could be better}
set low(Param p, int N) = bool:
    let (,NU,) = low(p)
    in NU > 2*N*low_frac

{if true, then try is_unitary during is_unitary_to_ht}
set interrupt_flag = false {KGB(E7_s,20895), lambda = rho is HORRIBLE with "true"}
set print_int_flag = false

{initial time to give interruptible command}
set interrupt_base_time = int:200

{START with full is_unitary tests, because those are actually interruptable}
{ meant to be used for G simple }
{ compute Hermitian form to ht on p, report if it is unitary}
set hermitian_form_irreducible_to_ht_big_SIMPLE_interrupt(Param p,int N, int time) = KTypePol:
  let which_flag = low(p,N), start = elapsed_ms(), (LAM,NU,) = low(p), empty = p.real_form.null_K_module
  then () = if print_int_flag then prints("N = ",N, ", p = ",p) fi
  then result = empty
  then () = while result.=
       	    do let maybe = if which_flag
     	       	       	   then hermitian_form_irreducible_to_ht_MvL(p,N,time)
	      	       	   else hermitian_form_irreducible(p,time)
	      	       	   fi
	       then () = result := case maybe
	      	       	 	   | timed_out: empty
		  		   | done(ans): to_ht(ans,N)
		  		   esac
      	        then () = if which_flag then time := 2*time fi
	        then () = which_flag := not which_flag;
		if print_int_flag then prints("in form_to_ht, time = ", time, ", which_flag = ", which_flag,
		", elapsed = ",elapsed_ms() - start) fi
		in ()
  	     od
  in result

{assume p is hermitian}
set hermitian_form_irreducible_to_ht_big_SIMPLE(Param p,int N) = KTypePol:
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return hermitian_form_irreducible_to_ht(p,N) {prints("FPP DANGER TO HT at ",p)}
	    fi
  {then () = p := herm_center(p)}
  then L = big_unitary_hash.lookup(p)
  then () = if L.>= then return K_type_pol(character_formula_to_height(p,N)) fi
  in if interrupt_flag
     then hermitian_form_irreducible_to_ht_big_SIMPLE_interrupt(p,N, interrupt_base_time)
     else if low(p,N) {low(p.x,p.lambda,N)}
     	  then hermitian_form_irreducible_to_ht(p,N)
     	  else to_ht(hermitian_form_irreducible(p),N)
     	  fi
     fi
{assume p is hermitian}
{ compute Hermitian form to ht on p, report if it is unitary}
set hermitian_form_irreducible_to_ht_big(Param p,int N) = KTypePol:
    if low(p,N) {low(p.x,p.lambda,N)}
    then hermitian_form_irreducible_to_ht(p,N)
    else to_ht(hermitian_form_irreducible(p),N)
    fi

{START with full is_unitary tests, because those are actually interruptable}
{ meant to be used for G simple }
{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big_SIMPLE_interrupt(Param p,int N, int time) = bool:
  let which_flag = low(p,N), result = 0, start = elapsed_ms(), (LAM,NU,) = low(p)
  then () = if print_int_flag then prints("N = ",N, ", p = ",p) fi
  {then () = if NU > 8*N*low_frac
       	    then return is_pure(hermitian_form_irreducible_to_ht(p,N))
      	    elif NU < N*low_frac/2
      	    then return is_pure(to_ht(hermitian_form_irreducible(p),N))
      	    else}
  then () = while result.=
       	    do result := if which_flag
     	       	      	 then is_unitary_to_ht_MvL(p,N,time)
	      		 else case hermitian_form_irreducible(p,time)
	      	   	      | timed_out: 0
		   	      | done(result): if is_pure(to_ht(result,N))
		     		   	      then 1
				   	      else -1
					      fi
		   	      esac
	      		 fi;
      		if which_flag then time := 2*time fi;
	        which_flag := not which_flag;
		if print_int_flag then prints("in to_ht, time = ", time, ", which_flag = ", which_flag,
		", elapsed = ",elapsed_ms() - start) fi
      		{unitary_test_counter.use() done in calls above}
  	     od
  in result.>

{ meant to be used for G simple }
{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big_SIMPLE(Param p,int N) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary_to_ht(p,N) {prints("FPP DANGER TO HT at ",p)}
	    fi
  {then () = p := herm_center(p)}
  then L = big_unitary_hash.lookup(p)
  then () = if L.>= then return true fi
  in if interrupt_flag
     then is_unitary_to_ht_big_SIMPLE_interrupt(p,N, interrupt_base_time)
     else {unitary_test_counter.use(); done in calls below}
     	  if low(p,N) {low(p.x,p.lambda,N)}
     	  then is_pure(hermitian_form_irreducible_to_ht(p,N))
     	  else is_pure(to_ht(hermitian_form_irreducible(p),N))
     	  fi
     fi

{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big(Param p,int N) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_to_ht_big_SIMPLE(pd,N) od)

set to_hts_count_mat = null(10,10)
set to_hts_count = null(10)

set is_unitary_to_hts_big_SIMPLE_interrupt(Param p,[int] Ns, int time) = bool:
    if print_int_flag then prints("N = ",Ns, " p = ",p) fi;
    let () = for N@i in Ns
       	     do let result = 0, which_flag = low(p,N), start = elapsed_ms()
     	        then () = while result = 0
	     	       	  do result:= if which_flag
		     	      	     then is_unitary_to_ht_MvL(p,N,time)
			      	     else case hermitian_form_irreducible(p,time)
	     	      	      	     	  | timed_out: 0
		      		   	  | done(result):
					    if is_pure((to_ht(result,Ns~[0])))
					    then 1
					    else -1
					    fi
		      	      	   	  esac
			      	     fi;
			     	if print_int_flag then prints("in to_hts, time = ", time, ", which_flag = ",
				which_flag, ", elapsed = ", elapsed_ms() - start) fi;
                	     {unitary_test_counter.use(); this is done in the calls above}
			     if not which_flag and not result.= then break fi;
		       	     if which_flag then time := 2*time fi;
		       	     which_flag := not which_flag
     	      		  od {while result}
		in if result.< then return false fi
	     od
     in true

{meant to be used for G simple}
{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big_SIMPLE(Param p,[int] Ns) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary_to_hts(p,Ns) {prints("FPP DANGER TO HT at ",p)}
	    fi
  {then () = p := herm_center(p)}
  then L = big_unitary_hash.lookup(p)
  then () = if L.>= then return true fi
  {then (LAM,NU,) = low(p)}
  {then () = if #Ns > 0 and NU > 8*Ns~[0]*low_frac
       	    then return is_unitary_to_hts(p,Ns)
	    elif #Ns > 0 and NU < Ns~[0]*low_frac/2
	    then return is_pure(to_ht(hermitian_form_irreducible(p),Ns~[0]))
	    fi}
  in if interrupt_flag
     then return is_unitary_to_hts_big_SIMPLE_interrupt(p, Ns, interrupt_base_time)
     else to_hts_count[#Ns] +:= 1;
     	  if #Ns = 0
       	  then to_hts_count_mat[0,0]+:=1;
	       return is_unitary_hash_big_SIMPLE(p)
	  fi;
  	  for N@i in Ns
     	  do if not is_unitary_to_ht_big_SIMPLE(p,N)
     	     then to_hts_count_mat[i,#Ns] +:= 1;
	     	  return false
	     fi
     	  od;
     to_hts_count_mat[#Ns,#Ns] +:= 1;
     true
     fi

{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big (Param p,[int] Ns) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if #Ns = 0 then return is_unitary_hash_big(p) fi;
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_to_hts_big_SIMPLE(pd,Ns) od)

set test_count_mat = null(10,10)
set test_count = null(10)

{ONLY for G simple}
{ compute Hermitian form to height N; if it's positive, then compute full form }
set is_unitary_test_big_SIMPLE_interrupt(Param p, int N, int time) = bool:
    let which_flag = low(p,N), result = 0, start = elapsed_ms(), (LAM,NU,) = low(p)
    {then () = if NU > 8*N*low_frac
       	      then return is_pure(hermitian_form_irreducible_to_ht(p,N))
      	      elif NU < N*low_frac/2
      	      then return is_pure(to_ht(hermitian_form_irreducible(p),N))
    	      else}
    then () = while result.=
    	      do result := if which_flag
	      	 	   then is_unitary_to_ht_MvL(p,N,time)
			   else case hermitian_form_irreducible(p,time)
	      	   	      	| timed_out: 0
		   	      	| done(r): if is_pure(r) then return true fi;
					   if is_pure(to_ht(r,N))
		     		   	      then 1
				   	      else -1
					      fi
		   	        esac
	      		   fi;
			   if result = -1 then return false fi;
      			   if which_flag then time := 2*time fi;
	        	   which_flag := not which_flag;
			   if print_int_flag then prints("in test, time = ", time, ", which_flag = ",
			      		     which_flag, ", elapsed = ",elapsed_ms() - start) fi
			   {unitary_test_counter.use()}
	       od
    {now result = +1}
    in is_unitary_hash_big_SIMPLE(p)

{ONLY for G simple}
{ compute Hermitian form to height N; if it's positive, then compute full form }
set is_unitary_test_big_SIMPLE(Param p, int N) = bool:
    {unitary_test_counter.use();} {{prints("N = ",N,", p = ",p);}}
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    if N < height(p) then return is_unitary_hash_big_SIMPLE(p) fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then return is_unitary_test(p,N) {prints("FPP DANGER TO HT at ",p)}
	      fi
    {then () = p := herm_center(p)}
    then () = if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
    	      then return true
    	      fi
    {then (LAM,NU) = low(p)}
    {then () = prints("LAM = ",LAM, ", NU = ", NU)}
    {then () = prints("is_unitary_hash = ",is_unitary_hash_big_SIMPLE(p), ", hform to ht = ",
    	 hermitian_form_irreducible_to_ht(p,N))}
    in test_count[1] +:= 1;
       if interrupt_flag
       then is_unitary_test_big_SIMPLE_interrupt(p,N,interrupt_base_time)
       elif low(p,N) {NU > LAM*low_frac}
       then if not is_pure(hermitian_form_irreducible_to_ht(p,N))
       	    then test_count_mat[0,1] +:= 1;
	    	 false
	    else test_count_mat[1,1] +:= 1;
	    	 is_unitary_hash_big_SIMPLE(p)
	    fi
       else test_count_mat[1,1] +:= 1;
       	    is_unitary_hash_big_SIMPLE(p)
       fi

{ONLY for G simple}
{ like previous, with list of heights; use interrupted is_unitary}
set is_unitary_test_big_SIMPLE_interrupt (Param p, [int] Ns, int time) = bool:
   let () = for N@i in Ns
       	    do let result=0, which_flag=low(p,N), start = elapsed_ms()
	       then () =  while result = 0
	     	       	  do result:= if which_flag
		     	      	      then is_unitary_to_ht_MvL(p,N,time)
			      	      else case hermitian_form_irreducible(p,time)
	     	      	      	     	   | timed_out: 0
		      		   	   | done(result):
					     if is_pure(result)
					     then 1
					     else -1
					     fi
		      	      	   	   esac
			      	       fi;
			    if print_int_flag then prints("in tests, time = ", time, "which_flag = ",
			       		      which_flag, ", elapsed = ",elapsed_ms() - start) fi;
               	    	    {unitary_test_counter.use();}
			    if result = -1 then return false fi;
 			    if not which_flag and result = 1 then return true fi;
		       	    if which_flag then time := 2*time fi;
		       	    which_flag := not which_flag
     	      		 od {while result}
	      {at this point result =1, indicating unitarity to ht N is true}
	      in ()
	   od
    in is_unitary_hash_big_SIMPLE(p)

{ONLY for G simple}
{ like previous, with list of heights }
set is_unitary_test_big_SIMPLE (Param p, [int] Ns) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then  return is_unitary_test(p,Ns) {prints("FPP DANGER TEST at ",p)}
	    fi
  {then () = p := herm_center(p)}
  then () = test_count[#Ns] +:= 1
  then L = big_unitary_hash.lookup(p)
  then () = if L.>= then return true fi
  then () = if #Ns = 0
       	    then test_count_mat[0,0] +:= 1;
	    return is_unitary_hash_big_SIMPLE(p)
	    fi
  then (LAM,NU,) = low(p)
  then () = if #Ns > 0 and NU > 8*Ns~[0]*low_frac
       	    then return is_unitary_test(p,Ns)
	    elif #Ns > 0 and NU < Ns~[0]*low_frac/2
	    then return is_unitary(p)
	    {is_pure(to_ht(hermitian_form_irreducible(p),Ns~[0]))}
	    fi
  in if interrupt_flag then is_unitary_test_big_SIMPLE_interrupt(p, Ns,interrupt_base_time)
     else for N@i in Ns
     	  do if not is_pure(hermitian_form_irreducible_to_ht(p,N))
	     {then unitary_test_counter.use()}
	     then test_count_mat[i,#Ns] +:= 1;
	     return false fi
	  od;
  	  test_count_mat[#Ns,#Ns] +:= 1;
	  is_unitary_hash_big_SIMPLE(p)
      fi

set is_unitary_test_big(Param p, int N) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_test_big_SIMPLE(pd,N) od)

set is_unitary_test_big(Param p, [int] Ns) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_test_big_SIMPLE(pd,Ns) od)


{ONLY for G simple}
{use the first m heights from deform_heights to test}
set is_unitary_def_test_big_SIMPLE_interrupt(Param p,int m, int time) = bool:
    let (def,flag)= deform_hts(p,m)
    in if flag
       then is_pos_on_LKTs(p) and is_unitary_to_hts_big_SIMPLE(p,def)
       else is_unitary_test_big_SIMPLE_interrupt(p,def,interrupt_base_time)
       fi

{ONLY for G simple}
{use the first m heights from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p,int m) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then return is_unitary_def_test(p,m) {prints("FPP DANGER DEF TEST at ",p)}
	      fi
    {then () = p := herm_center(p)}
    then L = big_unitary_hash.lookup(p)
    then () = if L.>= then return true fi
    {then N = height(p) + 4*m
    then (LAM,NU,) = low(p)
    then () = if NU > 8*low_frac
       	      then let (def,flag) = deform_hts(p,m)
	      	   in is_unitary_test(p,def)
		   {if flag then return is_unitary_test(p,deform_hts(p,m))...}
	     	   { elif #def > 0 and NU < *low_frac/2
	      	   then return is_unitary(p)}
	    {is_pure(to_ht(hermitian_form_irreducible(p),Ns~[0]))}
	    fi}
    then () = if interrupt_flag
    	      then return is_unitary_def_test_big_SIMPLE_interrupt(p, m, interrupt_base_time)
	      fi
    in if low(p, height(p) + 4*m) {2*NU > N*low_frac}
       then let (def,flag)= deform_hts(p,m)
       	    in if flag
       	       then is_pos_on_LKTs(p) and is_unitary_to_hts_big_SIMPLE(p,def)
       	       else is_unitary_test_big_SIMPLE(p,def)
       	       fi
       else is_unitary_hash_big_SIMPLE(p)
       fi

set is_unitary_def_test_big(Param p,int m) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_def_test_big_SIMPLE(pd,m) od)

{ONLY for G simple}
{use the first height from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p) = bool:
    is_unitary_def_test_big_SIMPLE(p,1)

{ONLY for G simple}
{use the first height from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p) = bool:
    is_unitary_def_test_big_SIMPLE(p,1)

set is_unitary_def_test_big(Param p) = bool:
    is_unitary_def_test_big(p,1)

{ONLY for G simple}
set is_unitary_next_big_SIMPLE(Param p) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let G = p.real_form
    then (LAM,NU,) = low(p)
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then if NU > LAM*low_frac
       	      	   then let n=next_heightB(p)
    	    	   	in if (n+1).=
	      		   then return true
	      		   elif is_unitary_to_ht_big(p,n)
	      		   then return is_unitary_hash_big_SIMPLE(p)
			   else return false {NOT unitary_to_ht}
			   fi {n=-1}
		   else return is_unitary_hash_big_SIMPLE(p)
		   fi {NU > LAM}
	       fi {not FPP_flag}
    {then () = p := herm_center(p)}
    in if NU > LAM*low_frac
       then let n=next_heightB(p)
    	    in  if (n+1).=
	      	then true
	      	elif is_unitary_to_ht_big_SIMPLE(p,n)
	      	then is_unitary_hash_big_SIMPLE(p)
		else false {NOT unitary_to_ht}
		fi {n=-1}
	else is_unitary_hash_big_SIMPLE(p)
	fi {NU > LAM}

set is_unitary_next_big(Param p) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_next_big_SIMPLE(pd) od)
