{this file concerns (local) facets of parameters, in preparation of analysis of their unitarity.}

<FPP_faces_geom.at
<goodroots.at { for is_pos_on_LKTs }
<Dirac.at
<hermitian.at
<K_highest_weights.at {for all_lambda_differential_0}
<unity.at {for deform_hts}
<red_count.at {for red_count@Param}
<face_classes.at {for coords}
<cohom_reductionND.at {for glue_sigs}
<up_mu.at {for up_mu_hash}
<Vogan-dual.at {for dual@Param}
<FPP_lambdas.at
{BREAK HERE?}

{lowest level (index in hts[]) to start testing}
{1 gives small improvement over 2 in E6; haven't tested bigger G}
set edge_offset = int: 3

{how much to increase index in hts[] for testing at various levels}
{1 improves E6_s and E6_q time by almost 10% }
set edge_skip = int: 1

{sort KTypes uniquely}
set temp_sort_u ([KType] K_types) = [KType]:
  if =#K_types then []
  else
     for @t in K_types[0].null_K_module+for Kt in K_types do (1,Kt) od do t od
  fi

{collection of lookup functions for faces of various dimensions}
set lookups([[vec]] LFD) = [(vec->int)]:
    for L@d in LFD do index_in(for v in L do v[:d+1] od) od

{tail is how many coords follow the vertex indices}
set sort(RealForm G, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH, int tail) = [[FaceVertsKHash]]:
    if #LFDKH = 0 or #LFDKH[0]=0 then return LFDKH fi;
    if sort_LFD_flag
       then let tworhocheck = G.two_rho_check
	    then f(vec v) = int:
		 let (num,den) = %((face_bary(Lvd,v[:#v - tail])*tworhocheck)*1000)
		 in num\den
	    in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
       else LFDKH
       fi

set sort(RealForm G, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH) = [[FaceVertsKHash]]:
    if #LFDKH = 0 or #LFDKH[0]=0 then return LFDKH fi;
    let tail = #LFDKH[0][0]-1
    in sort(G, Lvd, LFDKH, tail)

set anti_sort(RealForm G, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH) = [[FaceVertsKHash]]:
    if #LFDKH = 0 or #LFDKH[0]=0 then return LFDKH fi;
    let tail = #LFDKH[0][0]-1
    in if sort_LFD_flag
       then let tworhocheck = G.two_rho_check
	    then f(vec v) = int:
		 let (num,den) = %((face_bary(Lvd,v[:#v - tail])*tworhocheck)*1000)
		 in -num\den
	    in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
       else LFDKH
       fi

{set tensor_height(K_type mu) = int:
    let G = mu.real_form
    then x0 = KGB(G,0)
    then K0 = K_0(x0)}

{whether frequently to invoke the following function}
set check_pols_flag = false

set check_pols(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH,
    int HT, KTypePol_hash pol_hash) = void:
    if not check_pols_flag then return () fi;
    let red_shift = int: if red_count_flag
			 then 1
			 else 0
			 fi
    in {prints("checking pols at (",x.number,",",lambda,")");}
       for list@d in LFDKH
       do for v in list
	  do let p = parameter(x,lambda,face_bary(Lvd,v[:d+1]))
	     then P = K_type_pol(character_formula_to_height(1*p,HT))
	     in assert(@:P = to_ht(pol_hash.index(v[d+red_shift+1]),HT), "wrong K_char")
	  od
       od

{if the zero parameter at (x,lambda) has invariant form indefinite on
LKTs, then no irreducible Langlands quotient can be unitary. We used
to record the cases when all the LQs were unitary, but no
longer. Setting this flag to "false" restores the old calculation.}
set fewer_reducible_unitary_flag = true

{. If "true," then print number of invocations of a unitarity test .}
set test_verbose = true

{. If "true," then print a little info about invocations of a unitarity test .}
set test_slightly_verbose = true

set nullint(int N) = [int]:
    for n:N do 0 od

{whether to record nonunitary reps as well as unitary}
set nuhash_flag = true

{whether to use this hashed branch function as often as possible}
set branch_hash_flag = true

{whether to include KGB numbers in output files. True makes them more human-readable, sometimes longer}
set write_x_flag = false

{whether to include known (x,lambda) maps in output files.}
set write_x_lambda_flag = false

{whether to use the script branching code instead of library}
set my_branch_flag = true

{whether to use the script hash of K_type_formula instead of library}
set my_formula_flag = false

{The result of cohomological induction on the level of K}
set theta_induce_K(KTypePol QL, RealForm G) = KTypePol:
K_type_pol(sum(G, for c@pL in QL do c*theta_induce_standard(param(pL),G) od))

{decide NOT to hash nonunitary...well, UNdecided 1/14/25}
{try to incorporate RF_sig_table 1/18/25}
{sig_height = height(p)-1 means full signature
phash always contains uhash and nuhash}
set_type
[big_unitary_hash_table =
( ( -> int) real_form_size {number of real forms included}
  , ( -> vec) uhash_sizes {for every real form, the number of unitary reps}
  , (RealForm -> int) uhash_size {for one real form, number of unitary reps}
  , ( -> vec) nuhash_sizes {for every real form, the number of nonunitary reps}
  , (RealForm -> int) nuhash_size {for one real form, number of nonunitary reps}
  , ( -> vec) K_type_size {number of LKTs for each real form}
  , ( -> vec) K_type_pol_size
  , (KType -> KTypePol) K_type_formula
  , ((KType,int) -> KTypePol) K_type_formula_to_ht
  , ((KType, int) -> KTypePol) branch_entry {branch std to height}
  , ((KTypePol, int) -> KTypePol) branch {branch pol of stds to height}
  , ((KTypePol, int, int) -> maybe_KTP) branch_interrupt {branch pol of stds to height if possible in bounded time}
  , ((Param,int) -> KTypePol) sig_entry {signature to height}
  , (int, int -> int) branch_height {largest ht to which K type j on real form i has been branched}
  , (int, int -> int) sig_height {largest ht to which param j on real form i has had sig computed}
  , ( -> ) clear
  , (RealForm -> ) clearG
  , (RealForm -> int) rf_number {number of real form in list}
  , (int -> RealForm) rf_index {jth real form in list}
  , (RealForm -> [int]) xl_sizes {for given RealForm, for each x, number of lambda's occuring as (x,lambda)}
  , (RealForm -> [int]) xl_sizes_cumulative {for given RealForm, for each x, cumulative number of lambda's occuring as (x,lambda)}
  , ((RealForm,int) -> (int,int)) xl_lookup  {take (rf,j) to (x,index):
                                                (x,FPP_lambdas(x)[index]) is the j^th pair in the
                                                flattened list of (x,lambda) pairs}
  , (RealForm -> [int]) xl_known {for each x, bitmap of lambda for which FPP unitary dual is known}
  , (RealForm -> int) x_known {bitmap of x for which entire FPP dual is known}
  , (RealForm -> int) x_partial {bitmap of x for which some lambda have FPP dual known}
  , ((KGBElt,int) -> ) finish {add bitmap of new known (x,lambda) to xl_known}
  , ((RealForm,int,int) -> ) finish_num {add bitmap of new known (x,lambda) to xl_known}
  , (KGBElt -> ) finishx {add x to x_known}
  , ((RealForm,int) -> ) finishx_num {add x to x_known}
  , ((RealForm,int) ->) finishxmap {OR int with x_known(RealForm)}
  , (KGBElt -> ) partialx {add x to x_partial}
  , ((RealForm,int) -> ) partialx_num {add x to x_partial}
  , ((RealForm,[int]) -> ) finishall {add bitmaps of all new known (x,lambda) to xl_known}
  , (RealForm -> Param_hash) phash {hash table of all indexed parameters}
  , (RealForm -> Param_hash) uhash {hash table of known unitary}
  , (RealForm -> Param_hash) nuhash {hash table of known nonunitary}
  , (RealForm -> vec) nu_heights {list of heights to which nu reps are known non-unitary}
  , (Param -> (int,int)) long_plookup {(rf_index(p.real_form), location of p in its phash)}
  , (Param -> (int,int)) long_ulookup {(rf_index(p.real_form), location of p in its uhash)}
  , (Param -> int) plookup {(location of p in its phash)}
  , (Param -> int) ulookup {(location of p in its uhash)}
  , (Param -> int) nulookup {(location of p in its nuhash)}
  , (Param -> int) nu_height_lookup {smallest height at which p is known to be nonunitary}
  , ((Param,int) -> bool) nu_height_lookup_bool {whether p is known to be nonunitary to int}
  , (Param -> bool) check {check whether p is unitary, and add to appropriate hash table}
  , ((Param,int) -> bool) check_to_ht {check whether p is unitary to height}
  , (Param -> int) umatch {add p to its uhash table}
  , ((Param,int) -> int) numatch_height {add p known nonunitary to int to its hash table}
  , (Param -> int) numatch {add p to its nuhash table}
  , ((Param,int) -> int) long_umatch {add p to ith uhash table}
{  , ((int,ratvec,ratvec,int) -> int) long_umatch_coords {add p to ith uhash table}}
  , ((Param,int) -> int) long_match {add p to ith uhash table} {included for back compatibility}
  , ( -> ) write {output unitary data for file}
  , (RealForm -> ) writeG {output data for one group to file}
  , ((RealForm, int, int) -> ) writeGrange {output data for KGB(G)[low,high]}
  , ((KGBElt, ratvec) -> ) writexlam {output data for one x,lambda}
  , ((KGBElt, ratvec) -> string ) writexlam_no_G {output data for one x,lambda; wit-hout writing G}
  , (RealForm, [int] -> ) set_xl_sizes {set xl_sizes(RealForm)=[int]}
)
]

{function that will be properly defined in K_types.at}

set branch_std (KTypePol P, int cut_off) = KTypePol:
    let start = elapsed_ms()
    then ans = branch(P,cut_off)
    in branch_builtin_time +:= elapsed_ms() - start; ans

{set branch_std (KType mu, int cut_off) = KTypePol:
    branch_std(1*mu,cut_off)}

set finish_time = int:0
set is_finished_time = int:0
set branch_script_time = int:0
set convert_int_to_xl([int] cumulative_sizes, int j)=
let cumulative_sizes_augmented=[0]##cumulative_sizes then
x=locate_sorted(cumulative_sizes,j+1) in  {maximum: #cumulative_sizes-1 <-> last entry of cumulative_sizes}
if x>=#cumulative_sizes then (-1,-1) else 
(x,j-cumulative_sizes_augmented[x]) fi
{example:
cumulative_sizes=[12,20,44,50]:
this means there are 50 pairs, numbered [0,...,49] 
KGB_size=3, KGB(G,i) lambdas has size 12,20,44,50 (i=0,1,2,3)
j=49 -> j+1=50 -> x=3 -> (x,index)=(3,5)
j=50 -> j+1=51 -> x=4 -> (x,index)(-1,-1)

v=[12,20,44,50]
atlas> convert_int_to_xl (v,49)
Value: (3,5)
atlas> convert_int_to_xl (v,50)
Value: (-1,-1)
}

set convert_int_to_xl_index([int] cumulative_sizes, int j)=(int,int):
let cumulative_sizes_augmented=[0]##cumulative_sizes then
x=locate_sorted(cumulative_sizes,j+1) in  {maximum: #cumulative_sizes-1 <-> last entry of cumulative_sizes}
if x>=#cumulative_sizes then (-1,-1) else 
(x,j-cumulative_sizes_augmented[x]) fi
{example:
cumulative_sizes=[12,20,44,50]:
this means there are 50 pairs, numbered [0,...,49] 
KGB_size=3, KGB(G,i) lambdas has size 12,20,44,50 (i=0,1,2,3)
j=49 -> j+1=50 -> x=3 -> (x,index)=(3,5)
j=50 -> j+1=51 -> x=4 -> (x,index)(-1,-1)

v=[12,20,44,50]
atlas> convert_int_to_xl (v,49)
Value: (3,5)
atlas> convert_int_to_xl (v,50)
Value: (-1,-1)
}

{(G,cumulative_sizes,j) -> (KGB element x, ratvec lambda)}
set xl_pair(RealForm G,[int] cumulative_sizes, int j)=(KGBElt,ratvec):
    let (x_number,lambda_index)=convert_int_to_xl_index(cumulative_sizes,j) then
    x=KGB(G,x_number) in
    (x,FPP_lambdas(x)[lambda_index])

set make_big_unitary_hash() = big_unitary_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then uhashes = [Param_hash]: [] {one for each real form}
    then nuhashes = [Param_hash]: [] {one for each real form}
    then phashes = [Param_hash]: []
    {then status_strings = [[string]]: [] {one for each real form; "" is unknown, "T..." is unitary, "F..." nonunitary}}
    then K_type_hashes = [KType_hash] : [] {one for each real form; list of LKTs of params}
    then K_type_pol_hashes = [KTypePol_hash] : []  {one for each real form}
    then formulas = [vec]:[] {size of K_type_hash; entry in K_type_pol_hash recording K_type_formula}
    then formula_heights = [vec]:[] {size that of K_type_hash; largest height to which formula computed}
    then branches = [vec] : [] {one vec for each real form, of size #K types;
			      ith entry is index of branching KTypePol for KType #i}
    then sigs = [vec]: [] {one vec for each real form, of size #params;
			  jth entry is index of signature KTypePol for Param #j}
    then branch_heights = [vec]: [] {one list for each real form; jth entry is vec with ith entry the height
				   to which branch(param i) is known}
    then sig_heights = [vec]: [] {one list for each real form; jth entry is vec with ith entry
				 the height to which sig(param i) is known}
    then nu_heights = [vec]: [] {one list for each real form; jth entry is height to which jth entry of nuhash
				 is known to be nonunitary}
    then xl_sizes=[[int]]: [] {one [int] of xl_sizes for each real form }
    then xl_sizes_cumulative=[[int]]: [] {one [int] of xl_sizes for each real form }
    then xl_known = [[int]]: [] {one bitmap of known (x,lambda) for each real form and x}
    then x_known = [int]: [] {one bitmap of known x for each real form}
    then x_partial = [int]: [] {one bitmap of partially known x for each real form}
    then clearBUH() = void:
	 let () = real_form_hash.clear()
	 then () = uhashes := []
	 then () = nuhashes := []
	 then () = phashes := []
	 {then () = status_strings := []}
	 then () = K_type_hashes := []
	 then () = K_type_pol_hashes := []
	 then () = formulas := []
	 then () = formula_heights := []
	 then () = branches := []
	 then () = sigs := []
	 then () = branch_heights := []
	 then () = sig_heights := []
	 then () = nu_heights := []
         then () = xl_sizes := []
         then () = xl_sizes_cumulative := []
	 then () = xl_known := []
	 then () = x_known := []
	 then () = x_partial := []
	 in ()
    then add_real_form(RealForm rf) = int:
	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
	 then () = if i = I {haven't seen this real form before}
		   then	let empty = [int]: nullint(#KGB(rf))
                        then null_list=[int]:[] 
			then () = K_type_hashes #:= make_KType_hash();
			     K_type_pol_hashes #:= make_KTypePol_hash();
			     formulas #:= null(0);
			     formula_heights #:= null(0);
			     branches #:= null(0);
			     sigs #:= null(0);
			     branch_heights #:= null(0);
			     sig_heights #:= null(0);
			     nu_heights #:= null(0)
                        then ()=  xl_sizes #:= null_list
                        then ()=  xl_sizes_cumulative #:= null_list
                        then () = xl_known #:= empty {null(#KGB(rf))}
			then () = x_known #:= 0
			then () = x_partial #:= 0
			{then () = status_strings #:= []}
			then () = uhashes #:= make_Param_hash()
			then () = nuhashes #:= make_Param_hash()
			then () = phashes #:= make_Param_hash()
			in ()
		   fi
	  then () = assert(@:real_form_hash.size() = #phashes and #phashes = #xl_known
						 and #uhashes = #phashes and #nuhashes = #phashes
						 and #phashes = #x_known {and #phashes = #status_strings}
						 and #x_partial = #x_known
						 and #K_type_hashes = #x_known and #K_type_pol_hashes = #x_known
						 and #branches = #x_known and #sigs = #x_known
						 and #sig_heights = #x_known and #nu_heights = #x_known,
						 "big_unitary_hash damaged")
	  in i
    then add_K_type(KType mu) = (int, int): {real form index, K type index}
	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf,1*mu))}
	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then ktypenum = K_type_hashes[rfnum].match(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
		   then let pol = 1*mu
			then m = K_type_pol_hashes[rfnum].match(pol)
			{then () = if KTYPENUM = 26 then prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum], ", fs = ",formulas[rfnum],", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum]) fi}
			then () = formulas[rfnum] #:= m
			then () = formula_heights[rfnum] #:= height(mu)
			then () = branches[rfnum] #:= m
			then () = branch_heights[rfnum] #:= height(mu)
			then () = assert(@:real_form_hash.size() = #K_type_pol_hashes,"big_unitary_hash damaged")
			then () = assert(@:real_form_hash.size() = #K_type_hashes,"big_unitary_hash damaged")
			then () = assert(@:#branches[rfnum] = K_type_hashes[rfnum].size() and
				  #branch_heights[rfnum] = #branches[rfnum], "branch_hash_table damaged")
			then () = assert(@:#branches[rfnum] = #formula_heights[rfnum] and
				#branches[rfnum]  = #formulas[rfnum], "branch_hash_table damagedAKTFTH")
			in ()
		   fi
	in (rfnum, ktypenum)
    then add_K_type_formula(KType mu) = (int, int, int): {rfnum, ktypenum, index(formula)}
	 let (rfnum,ktypenum) = add_K_type(mu), h = height(mu)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu :=  K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf,1*mu))}
	 then () = if formula_heights[rfnum][ktypenum] != h-1
		   then let m = K_type_pol_hashes[rfnum].match({regroup(rf,} K_type_formula(mu)){)}
			then formsrf = formulas[rfnum], formhsrf = formula_heights[rfnum]
			then () = formsrf[ktypenum] := m
			then () = formhsrf[ktypenum] :=h-1
			{then () = formulas[rfnum][ktypenum] :=m}
			{then () formula_heights[rfnum][ktypenum] :=h-1}
			then () = formulas[rfnum] := formsrf
			then () = formula_heights[rfnum] := formhsrf
			in ()
		   fi
	 {then () = prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum], ", fs = ",formulas[rfnum],", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum])}
	 then() = assert(@:K_type_hashes[rfnum].size() = #branches[rfnum] and #branches[rfnum] = #formulas[rfnum]
			and #branches[rfnum] = #branch_heights[rfnum]
			and #branches[rfnum] = #formula_heights[rfnum], "branch_hash_table damagedAKTF")
	 in (rfnum, ktypenum, formulas[rfnum][ktypenum])
    then add_K_type_formula_to_ht(KType mu, int D) = (int,int,int): {rfn, ktypen, index_to_ht(formula)}
	 let (rfnum,ktypenum) = add_K_type(mu), h = height(mu)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu :=  K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {first_K_type(regroup(rf, 1*mu))}
	 then () = assert(@:D >= h, "too-low height argument for K_type_formula")
	 then () = if (formula_heights[rfnum][ktypenum] < D and formula_heights[rfnum][ktypenum] >= h)
		   then let m = K_type_pol_hashes[rfnum].match({regroup(rf,}K_type_formula(mu,D)){)}
			then formsrf = formulas[rfnum], formhsrf = formula_heights[rfnum]
			then () = formsrf[ktypenum] := m
			then () = formhsrf[ktypenum] := D
			{then () = formulas[rfnum][ktypenum] :=m}
			{then () formula_heights[rfnum][ktypenum] :=h-1}
			then () = formulas[rfnum] := formsrf
			then () = formula_heights[rfnum] := formhsrf
			in ()
		   fi
	 {then () = if ktypenum = 13 then prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum],
	      ", fs = ",formulas[rfnum], ", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum]) fi}
	 then() = assert(@:K_type_hashes[rfnum].size() = #branches[rfnum] and #branches[rfnum] = #formulas[rfnum]
			 and #branches[rfnum] = #branch_heights[rfnum]
			 and #branches[rfnum] = #formula_heights[rfnum], "branch_hash_table damagedAKTFTH")
	 in (rfnum, ktypenum, formulas[rfnum][ktypenum])
    then add_K_type_branch(KType mu, int D) = (int, int, int):
	 {this time add to height; D should be >= height(mu)}
	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
	 {now mu is attached to rf}
	 {first_K_type(regroup(rf,1*mu))}
	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then (,ktypenum) = add_K_type(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
		   then {let start_branch = elapsed_ms()}
			let pol = {regroup(rf,} branch_std(1*mu,D){)}
			then m = K_type_pol_hashes[rfnum].match(pol)
			then tempbranchhts = branch_heights[rfnum]
			then tempbranches = branches[rfnum]
			then () = tempbranches[ktypenum] := m
			then () = tempbranchhts[ktypenum] := D
			then () = branch_heights[rfnum] := tempbranchhts
			then () = branches[rfnum] := tempbranches
			then () = assert(@:real_form_hash.size() = #K_type_pol_hashes,"big_unitary_hash damaged")
			then () = assert(@:real_form_hash.size() = #K_type_hashes,"big_unitary_hash damaged")
			then () = assert(@:#branches[rfnum] = K_type_hashes[rfnum].size(), "big_unitary_hash damaged")
			   in ()
		   else {we've seen mu before}
		       if branch_heights[rfnum][ktypenum] < D
		       then let tempbranchhts = branch_heights[rfnum]
			    then tempbranches = branches[rfnum]
			    then pol = {regroup(rf,} branch_std(1*mu, D){)}
			    then m = K_type_pol_hashes[rfnum].match(pol)
			    then () = tempbranches[ktypenum]:=m
			    then () = tempbranchhts[ktypenum] :=  D
			    then () = branch_heights[rfnum] := tempbranchhts
			    then () = branches[rfnum] := tempbranches
			    in()
			fi {branch_heights[rfnum][ktypenum] < D}
		    fi {ktypenum = KTYPENUM}
	in (rfnum, ktypenum, branches[rfnum][ktypenum])

    then add_K_type_my_branch(KType mu, int D) = (int, int, int):
	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu :=  K_type(KGB(rf,mu.x.number), mu.lambda_minus_rho)
		   {now mu is attached to rf}
		   {first_K_type(regroup(rf,1*mu))}
	 then () = assert(@:D>=height(mu),"branch to D below height(mu)")
	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then (,ktypenum) = add_K_type(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
		   then let start = elapsed_ms()
			then ans = null_K_module(rf)
			then undone = 1*mu {guaranteed on rf}
			then () = while undone.!=
			     do let (c,tau) = first_term(undone)
				then corr = if my_formula_flag
					    then let (,,t) = add_K_type_formula_to_ht(tau,D)
						 in c*to_ht(K_type_pol_hashes[rfnum].list()[t],D)
						 {c*regroup(rf, to_ht(K_type_pol_hashes[rfnum].list()[t],D))}
					    else c*{regroup(rf,} K_type_formula(tau,D){)}
					    fi
				{then (,,t) = add_K_type_formula_to_ht(tau,D)}
				then () = undone-:= corr {c*regroup(rf, to_ht(K_type_pol_hashes[rfnum].list()[t],D))}
				in ans+:=c*tau
			     od
			then m = K_type_pol_hashes[rfnum].match(ans)
			then () = branch_script_time +:= elapsed_ms() - start
			then tempbranchhts = branch_heights[rfnum]
			then tempbranches = branches[rfnum]
			then () = tempbranches[ktypenum] := m
			then () = tempbranchhts[ktypenum] := D
			then () = branch_heights[rfnum] := tempbranchhts
			then () = branches[rfnum] := tempbranches
			then () = assert(@:real_form_hash.size() = #K_type_pol_hashes,"big_unitary_hash damaged")
			then () = assert(@:real_form_hash.size() = #K_type_hashes,"big_unitary_hash damaged")
			then () = assert(@:#branches[rfnum] = K_type_hashes[rfnum].size(), "big_unitary_hash damaged")
			in ()
		   else {we've seen mu before}
		       let Dold = branch_heights[rfnum][ktypenum]
		       then () = if Dold < D
			       then let ans = to_ht(K_type_pol_hashes[rfnum].list()[branches[rfnum][ktypenum]],Dold)
				    then undone = mu - sum(rf, for c@tau in ans
					     do let (,,Kft) = add_K_type_formula_to_ht(tau,D)
						in c*{regroup(rf,} to_ht(K_type_pol_hashes[rfnum].list()[Kft],D){)}
					     od)
				    then () = while undone.!=
					      do let (c,tau) = first_term(undone)
						 then corr = if my_formula_flag
							     then let (,,t) = add_K_type_formula_to_ht(tau,D)
								  in c*{regroup(rf,} to_ht(K_type_pol_hashes[rfnum].list()[t],D){)}
							     else c*regroup(rf, K_type_formula(tau,D))
							     fi
						 {then (,,t) = add_K_type_formula_to_ht(tau,D)}
						 then () = undone-:= corr {c*regroup(rf,
						      to_ht(K_type_pol_hashes[rfnum].list()[t],D))}
						 in ans+:=c*tau
					      od
			       then m = K_type_pol_hashes[rfnum].match(ans)
			       then tempbranches = branches[rfnum]
			       then tempbranchhts = branch_heights[rfnum]
			       then () = tempbranches[ktypenum]:=m
			       then () = tempbranchhts[ktypenum]:=  D
			       then () = branch_heights[rfnum] := tempbranchhts
			       then () = branches[rfnum] := tempbranches
			       in()
			       fi {Dold < D}
			in ()
		     fi {ktypenum = KTYPENUM}
	in (rfnum, ktypenum, branches[rfnum][ktypenum])

    then add_param_inf(Param p) = (int, int, int): {add a param, full herm form}
	let  rfnum = add_real_form(p.real_form)
	then PNUM = phashes[rfnum].size(), rf = real_form_hash.index(rfnum)
	{then () = p := regroup(rf, herm_center(p))}
	then list = global_vertices(rf, p.infinitesimal_character)
	{then phc = herm_center(p)}
	then () = p:=parameter(rf, p.x.number, p.lambda, sum(#list[0],list)/#list)
	then pnum = phashes[rfnum].match(p)
	then () = if pnum = PNUM {haven't computed with p before}
		  then let sig = if uhashes[rfnum].lookup(p).>=
				 then K_type_pol(character_formula(p))
				 else hermitian_form_irreducible(p) {insert computation from good?}
				 fi
		       then sig_ind = K_type_pol_hashes[rfnum].match(sig)
		       then () = sigs[rfnum] #:= sig_ind
		       then () = sig_heights[rfnum] #:= height(p) - 1
		       then N = nuhashes[rfnum].size()
		       then H = impure_height(sig)
		       then () = if H = - 1
				 then uhashes[rfnum].match(p)
				 else let n = nuhashes[rfnum].match(p)
				      in if n=N
					 then nu_heights[rfnum] #:=H
					 elif nu_heights[rfnum][n] > H
					 then let nuheightsrf = nu_heights[rfnum]
					      in nuheightsrf[n] :=H;
						 nu_heights[rfnum]:= nuheightsrf
					fi {n=N}
				 fi {H = -1}
		       then () = assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged")
		       then () = assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged")
		       then () = assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
		       then () = assert(@:#sig_heights[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
		       then () = assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(), "big_unitary_hash damaged")
		       in ()
		  else {we've seen p before}
		       if sig_heights[rfnum][pnum] >= height(p)
		       then let tempsigs = sigs[rfnum], tempsights = sig_heights[rfnum]
			    then sigD = if uhashes[rfnum].lookup(p).>=
					then K_type_pol(character_formula(p))
					else hermitian_form_irreducible(p)
					fi
			    then N = nuhashes[rfnum].size()
			    then H = impure_height(sigD)
			    then () = if H = -1
				      then uhashes[rfnum].match(p)
				      else let n = nuhashes[rfnum].match(p)
					   in if n=N
					      then nu_heights[rfnum] #:= H
					      elif nu_heights[rfnum][n] > H
					      then let nuheightsrf = nu_heights[rfnum]
						   in nuheightsrf[n] :=H;
						      nu_heights[rfnum]:= nuheightsrf
					      fi {n=N}
				      fi {H = -1}
			    then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			    then () = tempsigs[pnum] := sigD_ind
			    then () = tempsights[pnum]:= height(p) - 1
			    then () = sigs[rfnum] := tempsigs
			    then () = sig_heights[rfnum] := tempsights
			    in()
		       fi {sigheights >= height(p)}
		  fi {pnum = PNUM}
	 in (rfnum, pnum, sigs[rfnum][pnum])
   then add_param(Param p, int D) = (int, int, int): {add a param, form to ht D; assume D >= ht(p)}
	let  rfnum = add_real_form(p.real_form)
	then rf = real_form_hash.index(rfnum)
	then PNUM = phashes[rfnum].size()
	{then () = p:=regroup(rf,herm_center(p))}
	then list = global_vertices(rf, p.infinitesimal_character)
	{then phc = herm_center(p)}
	then () = p:=parameter(rf, p.x.number, p.lambda, sum(#list[0],list)/#list)
	then pnum = phashes[rfnum].match(p)
	then () = if pnum = PNUM {haven't computed with p before}
		  then let sigD = if uhashes[rfnum].lookup(p).>=
				  then let ans = K_type_pol(character_formula(p))
				       then () = D:=height(p)-1
				       in ans
				  elif low(p,D)
     	  			  then let ans =  hermitian_form_irreducible_to_ht(p,D)
				       then N = nuhashes[rfnum].size()
				       then H = impure_height(ans)
				       then () = if H = -1 {is_pure(ans)}
						 then ()
						 else let n = nuhashes[rfnum].match(p)
						      in if n=N
							 then nu_heights[rfnum]#:=H
							 elif nu_heights[rfnum][n] > H
							 then let nuheightsrf = nu_heights[rfnum]
							      in nuheightsrf[n] :=H;
								 nu_heights[rfnum]:= nuheightsrf
							 fi {n=N}
						 fi {H = -1}
				       in ans
				  else let ans = hermitian_form_irreducible(p)
				       then () = D:=height(p)-1
				       then N = nuhashes[rfnum].size()
				       then H = impure_height(ans)
				       then () = if H = -1
						 then uhashes[rfnum].match(p)
						 else let n = nuhashes[rfnum].match(p)
						      in if n=N
							 then nu_heights[rfnum]#:=H
							 elif nu_heights[rfnum][n] > H
							 then let nuheightsrf = nu_heights[rfnum]
							      in nuheightsrf[n] :=H;
								 nu_heights[rfnum]:= nuheightsrf
							 fi {n=N}
						 fi {H = -1}
				       in ans {this records full sig!}
				   fi {uhashes[rfnum].lookup(p).>=}
		       then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
		       then () = sigs[rfnum] #:= sigD_ind
		       then () = sig_heights[rfnum] #:= D
		       then () = assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged")
		       then () = assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged")
		       then () = assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
		       then () = assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(),
				 "big_unitary_hash nu_heights damaged")
		       in ()
		   else {we've seen p before}
		       if sig_heights[rfnum][pnum] >= height(p) and sig_heights[rfnum][pnum] < D
		       then let tempsigs = sigs[rfnum], tempsights = sig_heights[rfnum]
			    {then start_sig = elapsed_ms()}
			    then sigD = if uhashes[rfnum].lookup(p).>=
					then let ans = K_type_pol(character_formula(p))
					     then () = D:=height(p)-1
					     in ans
					elif low(p,D) {low(p.x,p.lambda,N)}
					then let ans = hermitian_form_irreducible_to_ht(p,D)
					     then N = nuhashes[rfnum].size()
					     then H = impure_height(ans)
					     then () = if H = -1
						       then ()
						       else let n = nuhashes[rfnum].match(p)
							    in if n=N
							       then nu_heights[rfnum]#:=H
							       elif nu_heights[rfnum][n] > H
							       then let nuheightsrf = nu_heights[rfnum]
							       in nuheightsrf[n] :=H;
								    nu_heights[rfnum]:= nuheightsrf
							       fi {n=N}
						       fi {H = -1}
					     in ans
					else let ans = hermitian_form_irreducible(p)
					     then N = nuhashes[rfnum].size()
					     then H = impure_height(ans)
					     then () = D:=height(p)-1
					     then () = if H = -1
						       then uhashes[rfnum].match(p)
						       else let n = nuhashes[rfnum].match(p)
							    in if n=N
							       then nu_heights[rfnum]#:=H
							       elif nu_heights[rfnum][n] > H
							       then let nuheightsrf = nu_heights[rfnum]
							       in nuheightsrf[n] :=H;
								    nu_heights[rfnum]:= nuheightsrf
							       fi {n=N}
						       fi {H=-1}
					     in ans
					fi
			    then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			    then () = tempsigs[pnum] := sigD_ind
			    then () = tempsights[pnum]:=D
			    then () = sigs[rfnum] := tempsigs
			    then () = sig_heights[rfnum] := tempsights
			    then () = assert(@:real_form_hash.size() = #phashes,"big_unitary_hash damaged")
			    then () = assert(@:real_form_hash.size() = #sig_heights,"big_unitary_hash damaged")
			    then () = assert(@:#sigs[rfnum] = phashes[rfnum].size(), "big_unitary_hash damaged")
			    then () = assert(@:#nu_heights[rfnum] = nuhashes[rfnum].size(),
				 "big_unitary_hash nu_heights damaged B")
			    in()

		       fi
		   fi
	 in (rfnum, pnum, sigs[rfnum][pnum])
    then clearG(RealForm rf) =
	 let i = real_form_hash.lookup(rf)
	 in if i >= 0
	    then {prints(i);}
		 uhashes[i].clear();
		 nuhashes[i].clear();
		 phashes[i].clear();
		 {status_strings[i]:=[];}
		 K_type_hashes[i].clear();
		 K_type_pol_hashes[i].clear();
		 formulas[i]:=[];
		 formula_heights[i]:=[];
		 branches[i] := [];
		 sigs[i] := [];
		 branch_heights[i] := [];
		 sig_heights[i] := [];
		 nu_heights[i] := [];
		 {prints("i = ",i, ", x_partial = ",x_partial);}
		 x_partial[i] := 0;
                 xl_sizes_cumulative[i] := [0];
		 xl_known[i] := nullint(#KGB(rf));
		 x_known[i] := 0
	    fi
    in
    ( (->int): {real_form_size} @int: real_form_hash.size()
    , ( -> vec): {uhash_sizes} @vec: for uhash in uhashes
				     do uhash.size()
				     od
    , (RealForm -> int): {uhash_size} (RealForm rf) int:
     let rfnum = add_real_form(rf)
     in uhashes[rfnum].size()
    , ( -> vec): {nuhash_sizes} @vec: for nuhash in nuhashes
				      do nuhash.size()
				      od
    , (RealForm -> int): {nuhash_size} (RealForm rf) int:
     let rfnum = add_real_form(rf)
     in uhashes[rfnum].size()
    , ( -> vec): {K_type_size} @vec: for hash in K_type_hashes do hash.size() od
    , ( -> vec): {K_type_pol_size} @vec: for hash in K_type_pol_hashes do hash.size() od
    , (KType -> KTypePol): {K_type_formula} (KType mu) KTypePol:
    begin
     if not my_formula_flag then return K_type_formula(mu) fi;
     let (rfnum,,m) = add_K_type_formula(mu)
     in regroup(mu.real_form, K_type_pol_hashes[rfnum].index(m))
    end
    , ((KType,int) -> KTypePol): {K_type_formula_to_ht} (KType mu, int D) KTypePol:
    begin
      if not my_formula_flag then return K_type_formula(mu,D) fi;
      let (rfnum,,m) = add_K_type_formula_to_ht(mu,D)
      in regroup(mu.real_form, to_ht(K_type_pol_hashes[rfnum].index(m), D))
    end
    , ((KType, int) -> KTypePol): {branch_entry} (KType mu, int D) KTypePol:
     begin
	let (rf, ktypenum,m) = if my_branch_flag
			       then add_K_type_my_branch(mu,D)
			       else add_K_type_branch(mu,D)
			       fi
	in regroup(mu.real_form, to_ht(K_type_pol_hashes[rf].index(m), D))
     end

    , ((KTypePol, int) -> KTypePol): {branch} (KTypePol pol, int D) KTypePol:
      let G = pol.real_form
      then rfnum = add_real_form(G)
      then rf = real_form_hash.index(rfnum)
      then () = pol := regroup(rf,pol)
      then terms = [(Split, KType)]: for c@mu in to_ht(pol,D)
				    do (c,mu)
				    od
      in regroup(G, to_ht(sum(rf, for (c,mu) in terms
				   do let (,,m) = if my_branch_flag
						    then add_K_type_my_branch(mu,D)
						    else add_K_type_branch(mu,D)
						    fi
				      in c*K_type_pol_hashes[rfnum].index(m)
				   od) , D))
      {for the next one assume my_branch; there is a built in interruptible}
    , ((KTypePol, int, int) -> maybe_KTP): {branch_interrupt} (KTypePol pol, int D, int time) maybe_KTP:
      let G = pol.real_form
      then rfnum = add_real_form(G), start_time = elapsed_ms()
      then rf = real_form_hash.index(rfnum)
      then () = pol := regroup(rf,pol)
      then terms = [(Split, KType)]: for c@mu in to_ht(pol,D)
				    do (c,mu)
				    od
      then ans = null_K_module(rf)
      then () = for (c,mu) in terms
		do if elapsed_ms() - start_time >= time then return timed_out() fi;
		   let (,,m) = add_K_type_my_branch(mu,D)
		   in ans +:= c*K_type_pol_hashes[rfnum].index(m)
		od
      in done(regroup(G, to_ht(ans, D)))
    , ((Param,int) -> KTypePol): {sig_entry} (Param p, int D) KTypePol:
     begin
	let (rfnum,pnum,sig_ind) = if D < height(p)
				then add_param_inf(p)
				else add_param(p,D)
				fi
	then G = p.real_form, rf = real_form_hash.index(rfnum)
	in if D < height(p)
	   then regroup(G, K_type_pol_hashes[rfnum].index(sig_ind))
	   else regroup(G, to_ht(K_type_pol_hashes[rfnum].index(sig_ind), D))
	   fi
     end
    , (int, int -> int): {branch_height} (int rfnum, int ktypenum): branch_heights[rfnum][ktypenum]
    , (int, int -> int): {sig_height} (int rfnum, int pnum): sig_heights[rfnum][pnum]
    , ( -> ): {clear} clearBUH
    , (RealForm -> ): {clearG} (RealForm rf):
      clearG(rf)
    , (RealForm -> int): {rf_number} (RealForm rf) int:
      add_real_form(rf)
    , (int -> RealForm): {rf_index} (int i) RealForm:
      real_form_hash.index(i)
    , (RealForm -> [int]): {xl_sizes} (RealForm rf) [int]:
      let i = add_real_form(rf)
      in xl_sizes[i]
    , (RealForm -> [int]): {xl_sizes_cumulative} (RealForm rf) [int]:
      let i = add_real_form(rf)
      in xl_sizes_cumulative[i]      
    , ((RealForm,int) -> (int,int)): {xl_lookup} (RealForm rf, int j):
        convert_int_to_xl(xl_sizes[add_real_form(rf)],j)
    , (RealForm -> [int]): {xl_known} (RealForm rf) [int]:
      let i = add_real_form(rf)
      in xl_known[i]
    , (RealForm -> int): {x_known} (RealForm rf) int:
      let i = add_real_form(rf)
      in x_known[i]
    , (RealForm -> int): {x_partial} (RealForm rf) int:
      let i = add_real_form(rf)
      in x_partial[i]
    , ((KGBElt,int) -> ): {finish} (KGBElt x, int M):
      let start = elapsed_ms()
      then i = add_real_form(x.real_form)
      then xl_knowni = [int]: xl_known[i]
      then () = xl_knowni[x.number] OR:= M
      then () = xl_known[i] := xl_knowni
      {then () = x_partial[i] := OR(to_bitset([x.number]),x_partial[i])
      then () = if xl_known[i][x.number] + 1 = to_bitset([#FPP_lambdas(x)])
		then x_known[i] := OR(to_bitset([x.number]),x_known[i])
		fi}
      then () = finish_time+:= elapsed_ms() - start
      in ()
    , ((RealForm, int,int) -> ): {finish_num} (RealForm G, int x_num, int M):
      let start = elapsed_ms()
      then i = add_real_form(G)
      then xl_knowni = [int]: xl_known[i]
      then () = xl_knowni[x_num] OR:= M
      then () = xl_known[i] := xl_knowni
      {then () = x_partial[i] := OR(to_bitset([x.number]),x_partial[i])
      then () = if xl_known[i][x.number] + 1 = to_bitset([#FPP_lambdas(x)])
		then x_known[i] := OR(to_bitset([x.number]),x_known[i])
		fi}
      then () = finish_time+:= elapsed_ms() - start
      in ()
    , (KGBElt -> ): {finishx} (KGBElt x):
      let i = add_real_form(x.real_form)
      then M = to_bitset([x.number])
      then () = x_known[i] OR:= M
      then () = x_partial[i] OR:= M
      in ()
    , ((RealForm,int) -> ): {finishx_num} (RealForm G,int x_num):
      let i = add_real_form(G)
      then M = to_bitset([x_num])
      then () = x_known[i] OR:= M
      then () = x_partial[i] OR:= M
      in ()
    , ((RealForm,int) ->): {finishxmap} (RealForm G, int M):
      let i = add_real_form(G)
      then () = x_known[i] := OR(M,x_known[i])
      in ()
    , (KGBElt -> ): {partialx}  (KGBElt x):
      let i = add_real_form(x.real_form)
      then M = to_bitset([x.number])
      then () = x_partial[i] := OR(M,x_partial[i])
      in ()
    , ((RealForm,int) -> ): {partialx_num}  (RealForm G, int x_num):
      let i = add_real_form(G)
      then M = to_bitset([x_num])
      then () = x_partial[i] OR:= M
      in ()
    , ((RealForm,[int]) -> ): {finishall} (RealForm rf, [int] Ms):
      let start = elapsed_ms()
      then i = add_real_form(rf)
      then xl_knowni = [int]: xl_known[i]
      then () = for n:#KGB(rf)
		do xl_knowni[n] := OR(Ms[n],xl_knowni[n])
		od
      then () = xl_known[i] := xl_knowni
      then v = vec: for M@j in Ms do if M.= then [] else [j] fi od.##
      then () = x_partial[i] := OR(x_partial[i], to_bitset(v))
      in finish_time+:= elapsed_ms() - start
    , (RealForm -> Param_hash): {phash} (RealForm rf) Param_hash:
      phashes[add_real_form(rf)]
    , (RealForm -> Param_hash): {uhash} (RealForm rf) Param_hash:
      uhashes[add_real_form(rf)]
    , (RealForm -> Param_hash): {nuhash} (RealForm rf) Param_hash:
      nuhashes[add_real_form(rf)]
    , (RealForm -> vec): {nu_heights} (RealForm rf) vec:
      nu_heights[add_real_form(rf)]
    , (Param -> (int,int)): {long_plookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      then j = phashes[i].lookup(p)
      in (i,j)
    , (Param -> (int,int)): {long_ulookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      then j = uhashes[i].lookup(p)
      in (i,j)
    , (Param -> int): {plookup} (Param p) int:
       phashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> int): {ulookup} (Param p) int:
       uhashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> int): {nulookup} (Param p) int:
       nuhashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> int): {nu_height_lookup} (Param p) int:
      let i = add_real_form(p.real_form)
      then j = nuhashes[i].lookup(p)
      in if j = -1
	 then -1
	 else nu_heights[i][j]
	 fi
    , ((Param,int) -> bool): {nu_height_lookup_bool} (Param p, int H) bool:
      let i = add_real_form(p.real_form)
      then j = nuhashes[i].lookup(p)
      in if j.< or H < height(p)
	 then false
	 else let H0 = nu_heights[i][j]
	      in H0.>= and H0 <= H
	 fi
    , (Param -> bool): {check} (Param p) bool:
      let (i,,sigD) = add_param_inf(p)
      in is_pure(K_type_pol_hashes[i].list()[sigD])
    , ((Param,int) -> bool): {check_to_ht} (Param p, int N) bool:
      let (i,,sigD) = add_param(p,N)
      in is_pure(to_ht(K_type_pol_hashes[i].list()[sigD], N))
{
      let i = add_real_form(p.real_form)
      {then () = prints("bitmap for ",p.x.number," is ",xl_known[i][p.x.number])}
      then () = p := herm_center(p)
      then j = add_param_inf(p)
      then ju = uhashes[i].lookup(p)
      in if ju.>= then true
	 else let jn = nuhashes[i].lookup(p)
	      in if jn.>= then false
		 elif {now p was not found in either} is_member_bitset(p.x.number, x_known[i])
		 then nuhashes[i].match(p); false
		 elif {now x not completely known} position(p.x, p.lambda).>=
		      and is_member_bitset(position(p.x, p.lambda), xl_known[i][p.x.number])	 then false
		 else let sig = add_param
		 chk = is_unitary(p)
		      then () = if chk
				then uhashes[i].match(p)
				else if nuhash_flag
				     then nuhashes[i].match(p)
				     fi
				fi
		      in chk
		 fi
	 fi
}
    , (Param -> int): {umatch} (Param p):
      let i = add_real_form(p.real_form)
      in uhashes[i].match(p)
    , ((Param,int) -> int): {numatch_height} (Param p, int H):
      let i = add_real_form(p.real_form)
      then N = nuhashes[i].size()
      in if nuhash_flag
	 then let n = nuhashes[i].match(p)
	 in if n=N
	    then nu_heights[i] #:= H; n
	    else if nu_heights[i][n] > H
		 then let nuhtsi = nu_heights[i]
		      in nuhtsi[n]:=H;
			 nu_heights[i]:=nuhtsi
		 fi; n
	    fi {n=N}
	 else -1
	 fi
    , (Param -> int): {numatch} (Param p):
      let i = add_real_form(p.real_form)
      then N = nuhashes[i].size()
      in if nuhash_flag
	 then let n = nuhashes[i].match(p)
	 in if n=N
	    then nu_heights[i]#:= -1; n
	    else n
	    fi
	 else -1
	 fi
    , ((Param,int) -> int): {long_umatch} (Param p, int i):
      uhashes[i].match(p)
    , ((Param,int) -> int): {long_match} (Param p, int i):
      uhashes[i].match(p)
    , ( -> ): {write} @void:
    let rf_list = real_form_hash.list()
    in for rf@i in rf_list
       do let Gname = "G"+to_string(i)
	  then listname = Gname+"_list"
	  then intlistname = Gname+"_XLK"
	  then plist = uhashes[i].list()
	  then bitmapintlist = xl_known[i]
	  then donemap = x_known[i]
	  then done_list = [int]:[]
	  then () = if write_x_flag then done_list :=
		for x in KGB(rf)
		       do if is_member_bitset(x.number, donemap)
			  then [x.number]
			  else []
			  fi
		       od.##
		 fi
	  in write_real_form(rf,Gname);
	     prints("set j = big_unitary_hash.rf_number(",Gname,")");
	     for p in plist
	     do let xnum = p.x.number
		in prints("void: big_unitary_hash.long_match(parameter(",Gname,",",xnum,",",p.lambda,",",p.nu,"),j)")
	     od;
	     if write_x_flag
	     then for xnum in done_list
		  do prints("void: big_unitary_hash.finishx_num(",Gname,",",xnum,")")
		  od
	     else prints("void: big_unitary_hash.finishxmap(",Gname,",",donemap,")")
	     fi;
             prints("void: big_unitary_hash.set_xl_sizes(",Gname,",",xl_sizes[i],")");
	     prints("set ",intlistname,"=[int]:[]");
	     write_append(bitmapintlist,intlistname);
	     prints("big_unitary_hash.finishall(",Gname,",",intlistname,")")
	od
    , (RealForm -> ): {writeG} (RealForm G):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      {then intlistname = Gname+"_XLK"}
      then plist = uhashes[i].list()
      {then bitmapintlist = xl_known[i]}
      then donemap = x_known[i]
      then done_list = [int]:[]
      then () = if write_x_flag then done_list := set_bit_positions(donemap)
		fi
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do let xnum = p.x.number
	    in prints("void:  big_unitary_hash.long_match(parameter(",Gname,",",xnum,",",p.lambda,",",p.nu,"),j)")
	 od;
	 {prints("void: big_unitary_hash.finishall(",Gname,",",xl_known[i],")");} {this has length #KGB(G), which is a lot; not worth including}
	 if write_x_flag
	 then for xnum in done_list
	      do prints("void: big_unitary_hash.finishx_num(",Gname,xnum,")")
	      od
	 else prints("void: big_unitary_hash.finishxmap(G_temp,",donemap,")")
	 fi;
         prints("void: big_unitary_hash.set_xl_sizes(G_temp,",xl_sizes[i],")");
	 if write_x_lambda_flag
	 then for N@j in xl_known[i]
	      do if N.!=
	      	 then prints("void: big_unitary_hash.finish(KGB(G_temp,j),N")
		 fi
	      od
	 fi;
         prints("void: big_unitary_hash.set_xl_sizes(G_temp,",xl_sizes[i],")")
{NOTE: next function records whether a given x is finished, but NOT whether
some lambdas for that x might be finished.}
    , ((RealForm, int, int) -> ): {writeGrange} (RealForm G, int low, int high):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list_"+to_string(low)+"_"+to_string(high)
      {then intlistname = Gname+"_XLK_"+to_string(low)+"_"+to_string(high)}
      then longlist = uhashes[i].list()
      then plist = for p in longlist
		   do if p.x.number >= low and p.x.number < high
		      then [p]
		      else []
		      fi
		   od.##
      then donemap = x_known[i]
      then donerangemap = AND(donemap, 2^high - 2^low)
      then done_list = set_bit_positions(donerangemap)
	   {these are the x's being written for which list is complete}
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")"); {, ptemp = GL(1,R).trivial");}
	 for p in plist
	 do let xnum = p.x.number
	    in prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",p.lambda,",",p.nu,"),j)")
	 od;
	 if write_x_flag
	 then for xnum in done_list
	      do prints("void: big_unitary_hash.finishx_num(",Gname,",",xnum,")")
	      od
	 else prints("void: big_unitary_hash.finishxmap(",Gname,",",donerangemap,")")
	 fi
    , ((KGBElt,ratvec) -> ): {writexlam} (KGBElt x, ratvec lambda):
      let G = x.real_form
      then xnum = x.number
      then i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then longlist = uhashes[i].list()
      then plist = for p in longlist
		   do if p.x = x and p.lambda = lambda
		      then [p]
		      else []
		      fi
		   od.##
      then N = to_bitset([position(x,lambda)])
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",lambda,",",p.nu,"),j)")
	 od;
	 if is_member_bitset(position(x,lambda), xl_known[i][xnum])
	 then prints("big_unitary_hash.finish_num(",Gname,",",xnum,",",to_string(N),")")
	 fi
     {changed writexlam_no_G to return a string}
    , ((KGBElt,ratvec) -> string ): {writexlam_no_G} (KGBElt x, ratvec lambda):
      let str=string:""
      then G = x.real_form
      then xnum = x.number
      then i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then longlist = uhashes[i].list()
      then plist = for p in longlist
		   do if p.x = x and p.lambda = lambda
		      then [p]
		      else []
		      fi
		   od.##
      then N = to_bitset([position(x,lambda)])
      in {write_real_form(G,Gname);}
	 str+:="set j = big_unitary_hash.rf_number(" + Gname + ")\n";
	 for p in plist do
           str+:="void: big_unitary_hash.long_match(parameter(G_temp," + xnum + "," +to_string(lambda) + "," + to_string(p.nu) +"),j)\n"
	 od;
	 if is_member_bitset(position(x,lambda), xl_known[i][xnum])
	 then str+:="big_unitary_hash.finish_num(" + Gname + "," + xnum + "," + to_string(N) + ")\n"
	 fi;str
   , ((RealForm,[int]) -> ): {set_xl_sizes} (RealForm G,[int] precomputed_xl_sizes):
       let i=add_real_form(G) in
       xl_sizes[i]:=
         if #precomputed_xl_sizes=0
            then {compute the answer} for x in KGB(G) do #FPP_lambdas(x) od
            else precomputed_xl_sizes
         fi;
       let ()=prints("cs: ", xl_sizes[i]) in 
       xl_sizes_cumulative[i]:=cumulate_forward(xl_sizes[i])
    )
    )



set big_unitary_hash = make_big_unitary_hash()

{get cumulative sizes from big_unitary_hash}
set xl_pair(RealForm G,int j)=(KGBElt,ratvec):
    let cumulative_sizes=big_unitary_hash.xl_sizes_cumulative(G) in
{    let ()=    assert(!=cumulative_sizes,"xl_sizes(G) not in big_unitary_hash. Probably do: big_unitary_hash.set_xl_sizes(G,[])") then}
{let()=     assert(cumulative_sizes != null(#cumulative_sizes),"xl_sizes(G) not in big_unitary_hash. Probably do: big_unitary_hash.set_xl_sizes(G,[])") in}
    xl_pair(G,cumulative_sizes,j)

{print xl_pair in format: x_number:lambda}
set print_xl_pair(RealForm G,int j)=void:
  let (x,lambda)=xl_pair(G,j) in prints(x.number,":", lambda)

{uses the results stored in big_unitary_hash.}
set branch_irr_hash(Param p, int D) = KTypePol:
    let CF = character_formula_to_height(p,D)
    in big_unitary_hash.branch(K_type_pol(CF),D)



{. The next family of functions all need simple derived group. Always
|vd.list| should be ALL vertices in the FPP; Lvd.list will be all infl
chars in the FPP for a parameter (x,lambda,*), with x and lambda
fixed. The face lists carried by [[FaceBary]] or [[FaceVertsIndex]]
may be pruned of reps not interesting for unitarity, but the indices
will always refer to a constant vlist.}

set two_to_position(KGBElt x, ratvec lambda) = int:
    let pos = position(x,lambda)
    in if pos.>=
       then to_bitset([position(x,lambda)])
       else -1
       fi

{set a bit in xl_known}
set finish(KGBElt x, ratvec lambda) = void:
    let pos = two_to_position(x,lambda)
    in if pos.>=
       then big_unitary_hash.finish(x, pos)
       fi

set finish(KGBElt x) = void:
    {let lambdas = FPP_lambdas(x)
    then m = #lambdas
    then M = (to_bitset([m]) - 1)
    in} big_unitary_hash.finishx(x)

{check whether a bit in xl_known is set}
set is_finished(KGBElt x, ratvec lambda) = bool:
    let start = elapsed_ms(), Mx_known = big_unitary_hash.x_known(x.real_form),
	Mx_partial = big_unitary_hash.x_partial(x.real_form), M = big_unitary_hash.xl_known(x.real_form)[x.number]
    {then () = prints("Mx_known = ",Mx_known,", Mx_partial = ",Mx_partial,", M = ",M)}
    then answer = if is_member_bitset(x.number,Mx_known)
		  then true
		  elif {is_member_bitset(x.number,Mx_partial)
		  then} let pos = position(x,lambda)
			in if pos.>=
			   then is_member_bitset(pos,M)
			   else false
			   fi
		  then true
		  else false
		  fi
    then () = is_finished_time +:= elapsed_ms() - start
    in answer

{requires G is in big_unitary_hash and cumulative_sizes is set}
set is_finished(RealForm G,[int] cumulative_sizes,int j)=bool:
    let (x,lambda)=xl_pair(G,cumulative_sizes,j) in is_finished(x,lambda)

{get cumulative_sizes from big_unitary_hash}
set is_finished(RealForm G,int j)=bool:
    let cumulative_sizes=big_unitary_hash.xl_sizes_cumulative(G) then
    ()=assert(!=cumulative_sizes,"cumulative_sizes not set") then
    (x,lambda)=xl_pair(G,cumulative_sizes,j) in
    is_finished(x,lambda)

{list of all pairs (x,lambda) for which complete FPP-unitary dual is present in big_unitary_hash}
set list_all_finished(RealForm G) = [(KGBElt,ratvec)]:
    let list = for x in KGB(G)
	       do set_bit_positions(big_unitary_hash.xl_known(G)[x.number])
	       od
    in for x in KGB(G)
       do let poss = list[x.number]
	  in for pos in poss
	     do (x, FPP_lambdas(x)[pos])
	     od
       od.##
{how much to scale semisimple rank to get ht trial jump}

{these functions were in unity.at; give useful heights to which to try unitarity}

{. gives (one of) the K-types of lowest height above mu in the
standard of LKT mu .} {NEED USEFUL BOUND in K_type_formula.}
set next_to_lowest_old(KType mu, int step) = KType:
    let form = null_K_module(mu.real_form)
    then m = height(mu)
    then () = for j:60 from 1
	      do let () = form :=
		     if my_branch_flag
		     then big_unitary_hash.branch(mu, m+j*step)-mu
		     else branch(mu,m+j*step) - mu
		     fi
		 in if form.!= then break fi
	      od
    in last_K_type(form)

set next_to_lowest(KType mu) = KType:
    let HT = height(mu)+1
    then NTL = null_K_module(mu)
    then () = while NTL.=
	      do NTL := big_unitary_hash.K_type_formula_to_ht(mu,HT) - mu;
		 HT+:=1
	      od
    in first_K_type(NTL)

{. height of a smallest non-lowest K_type of standard with LKT mu .}
set next_height(KType mu)  = int:
    height(next_to_lowest(mu))

{. height of a smallest non-lowest K_type of p .}
set next_height(Param p) = int:
    min(for mu in LKTs(p) do height(next_to_lowest(mu)) od)

set next_taus(KType mu, int D) = [KType]:
    if D.<= then return [] fi;
    let tau = mu
    in for j:D do tau := next_to_lowest(tau) od

set next_heights(KType mu, int D) = [int]:
    for tau in next_taus(mu,D) do height(tau) od

set next_heights(Param p, int D) = [int]:
    for tau in LKTs(p) do next_heights(tau, D) od.##.sort_u[:D]

set next_taus(Param p, int D) = [KType]:
    for mu in LKTs(p) do next_taus(mu, D) od.##.temp_sort_u[:D]

{if this produces -1, then the (hermitian) p is automatically unitary}
set next_heightB(Param p) = int:
    let mu = LKTs(p)[0]
    then M = if my_branch_flag
	     then big_unitary_hash.K_type_formula_to_ht(mu, height(p) +
		  height(p.root_datum, p.nu)) - mu
	     else K_type_formula(mu, height(p) + height(p.root_datum, p.nu)) - mu
	     fi
    in
    if =M then -1
    else
    let (,tau) = first_term(M) in height(tau)
    fi

set UHBS_time = int: 0

{assume p is hermitian, FPP}
set hermitian_form_irreducible_big_SIMPLE(Param p) = KTypePol:
    let () = p:=herm_center(p)
    then L = big_unitary_hash.ulookup(herm_center(p))
    in if L.>=
       then let ans = K_type_pol(character_formula(p))
	    in ans
       else big_unitary_hash.sig_entry(p,height(p)-1) {hermitian_form_irreducible(p)}
       fi

{this version is only for G simple, p FPP hermitian and centered}
{First weakly good, then Lucas}
set is_unitary_hash_big_SIMPLE_weak_Lucas(Param p) = bool:
    let (,pL) = wkgood_Q(p), G = p.real_form {first try weakly good induction}
    then L = pL.real_form
    then goodL = good_L(p)
    then answer = if L !=G
		  then let derpLs = for qLj in derived_factor_params0(pL)
				    do monomials(finalize(qLj))
				    od.##
		       in if #derpLs = 0
			  then true
			  else
			   let statuses = for derpL in derpLs
					  do big_unitary_hash.check(derpL)
					  od
			   in if all(statuses) or goodL = L
			      then all(statuses)
			      else {some derpL is not unitary, but the induction is not trivial}
				is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
					    do c*theta_induce_standard(param(qL), goodL)
					    od))
			     fi {all(statuses}
			  fi{#derpLs = 0}
		   else    {now start Lucas test}
		    let gamma = p.infinitesimal_character, rd = p.root_datum
		    then rdi = integrality_datum(rd,gamma)
		    then alphavs = for alphav@j in rd.simple_coroots
				   do if gamma*alphav < 1
				      then [j]
				      else let ji = coroot_index(rdi,alphav)
				      in if not is_member_sorted(tau(p))(ji)
					 then []
					 else [j]
					 fi {not is_member}
				      fi {gamma*alphav < 1}
				   od.##
		   then Q = KGPElt: (alphavs, p.x)
		   then rhou = Q.rho_u
		   in if((p.x.involution-1)*rhou).!=
		      then false
		      else
			let LL = Q.Levi
			in if LL != G {Lucas test gives a reduction}
			   then let xLL = inverse_embed_KGB(p.x,LL)
				then pLL = parameter(xLL,p.lambda - rhou, p.nu)
				{then () = assert(p = first_param(theta_induce_standard(pL,G)),
				"screwed up pL!")}
				then derpLLs = derived_factor_params0(pLL)
				in all(for derpLL in derpLLs
				       do @bool: big_unitary_hash.check(derpLL)
				       od)
			   else big_unitary_hash.check(p)
			   fi {LL != G}
			fi {Q theta-stable}
		 fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{this version is only for G simple, FPP hermitian and herm center p}
{tries first Lucas, then weakly good}
set is_unitary_hash_big_SIMPLE_Lucas_weak(Param p) = bool:
    let gamma = p.infinitesimal_character, rd = p.root_datum, G = p.real_form
    then rdi = integrality_datum(rd,gamma)
    then alphavs = for alphav@j in rd.simple_coroots
		  do if gamma*alphav < 1
		     then [j] {else must be = 1 since we're in FPP}
		     else let ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
    then Q = KGPElt: (alphavs, p.x)
    then rhou = Q.rho_u
    then () = if((p.x.involution-1)*rhou).!=
	      then big_unitary_hash.numatch(p); return false
	      fi
    then L = Q.Levi
    then answer = if L != G {Lucas test gives a reduction}
		  then
		   let xL = inverse_embed_KGB(p.x,L)
		   then pL = parameter(xL,p.lambda - rhou, p.nu)
		   {then () = assert(p = first_param(theta_induce_standard(pL,G)),
			"screwed up pL!")}
		   then derpLs = derived_factor_params0(pL)
		   in all(for derpL in derpLs
			  do @bool: big_unitary_hash.check(derpL)
			  od)
		  else
		   let (,pL) = wkgood_Q(p) {else try weakly good induction}
		   then derpLs = for qLj in derived_factor_params0(pL)
				 do monomials(finalize(qLj))
				 od.##
		   then goodL = good_L(p)
		   in if #derpLs = 0
		      then big_unitary_hash.umatch(p); true
		      else
		       let statuses = for derpL in derpLs
				      do big_unitary_hash.check(derpL)
				      od
		       in if all(statuses) or goodL = pL.real_form
			  then all(statuses)
			  else {some derpL is not unitary, but the induction is not trivial}
			       is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
					    do c*theta_induce_standard(param(qL), goodL)
					    od))
			 fi {all(statuses}
		       fi{#derpLs = 0}
		    fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{this version is only for G simple}
set is_unitary_hash_big_SIMPLE_Lucas(Param p) = bool:
    let gamma = p.infinitesimal_character, rd = p.root_datum, G=p.real_form
    then rdi = integrality_datum(rd,gamma)
    then alphavs = for alphav@j in rd.simple_coroots
		  do if gamma*alphav < 1
		     then [j]
		     else let ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
    then Q = KGPElt: (alphavs, p.x)
    then rhou = Q.rho_u
    then () = if((p.x.involution-1)*rhou).!=
	      then big_unitary_hash.numatch(p); return false
	      fi
    then L = Q.Levi
    then answer = if L != G {Lucas test gives a reduction}
		  then
		   let xL = inverse_embed_KGB(p.x,L)
		   then pL = parameter(xL,p.lambda - rhou, p.nu)
		   {then () = assert(p = first_param(theta_induce_standard(pL,G)),
			"screwed up pL!")}
		   then derpLs = derived_factor_params0(pL)
		   in all(for derpL in derpLs
			  do @bool: big_unitary_hash.check(derpL)
			  od)
		  else
		   big_unitary_hash.check(p)
		  fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer


{this version is only for G simple and hermitian FPP params}
{does weakly good induction}
set is_unitary_hash_big_SIMPLE_weak(Param p) = bool:
    let (,pL) = wkgood_Q(p), G = p.real_form
    then derpLs = for qLj in derived_factor_params0(pL)
		  do monomials(finalize(qLj))
		  od.##
    then () = if #derpLs = 0 then big_unitary_hash.umatch(p); return true fi
    then statuses = for derpL in derpLs
		    do big_unitary_hash.check(derpL)
		    od
    then goodL = good_L(p)
    then answer =
       if all(statuses) or goodL = pL.real_form
       then all(statuses)
       else {some derpL is not unitary, but the induction is not trivial}
	    is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
				   goodL)
			      od))
       fi{all(statuses)}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{tiny evidence that wk_Lucas is best, or at least not very bad}
set u_Lucas_flag = false
set u_wk_flag = false
set u_wk_Lucas_flag = true
set u_Lucas_wk_flag = false

{this version is only for G simple}
set is_unitary_hash_big_SIMPLE(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
	      then return is_unitary(p) {prints("FPP DANGER at ",p)}
	      fi
    then () = p := herm_center(p)
    then Lu = big_unitary_hash.ulookup(p)
    {then () = prints("p = ", p, ". Lu = ",Lu, ", is_finished = ",is_finished(p.x, p.lambda))}
    then () = if Lu.>= then return true fi
    then () = if is_finished(p.x, p.lambda)
	      then big_unitary_hash.numatch(p); return false fi
    then Ln = big_unitary_hash.nulookup(p)
    then () = if Ln.>= then return false fi
    then () = if u_Lucas_flag then return is_unitary_hash_big_SIMPLE_Lucas(p) fi
    then () = if u_wk_flag then return is_unitary_hash_big_SIMPLE_weak(p) fi
    then () = if u_Lucas_wk_flag then return is_unitary_hash_big_SIMPLE_Lucas_weak(p) fi
    then () = if u_wk_Lucas_flag then return is_unitary_hash_big_SIMPLE_weak_Lucas(p) fi
    then answer = big_unitary_hash.check(p)
    in if answer
       then big_unitary_hash.umatch(p); answer
       else big_unitary_hash.numatch(p); answer
       fi

{this version is only for G simple}
{return 1 means true, -1 false, 0 interrupted}
set is_unitary_hash_big_SIMPLE(Param p, int TIME) = int:
    if not is_hermitian(p) then return -1 fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then return is_unitary(p,TIME) {prints("FPP DANGER at ",p)}
	      fi
    then () = p := herm_center(p)
    then Lu = big_unitary_hash.ulookup(p)
    {then () = prints("p = ", p, ". Lu = ",Lu, ", is_finished = ",is_finished(p.x, p.lambda))}
    then () = if Lu.>= then return 1 fi
    then () = if is_finished(p.x, p.lambda)
    	      then big_unitary_hash.numatch(p); return -1 fi
    then Ln = big_unitary_hash.nulookup(p)
    then () = if Ln.>= then return -1 fi
    then answer = is_unitary(p,TIME)
    {
    then () = if u_Lucas_flag then return is_unitary_hash_big_SIMPLE_Lucas(p) fi
    then () = if u_wk_flag then return is_unitary_hash_big_SIMPLE_weak(p) fi
    then () = if u_Lucas_wk_flag then return is_unitary_hash_big_SIMPLE_Lucas_weak(p) fi
    then () = if u_wk_Lucas_flag then return is_unitary_hash_big_SIMPLE_weak_Lucas(p) fi
    then answer = big_unitary_hash.check(p)
    }
    in if answer.>
       then big_unitary_hash.umatch(p); answer
       elif answer.<
       then big_unitary_hash.numatch(p); answer
       else answer
       fi

set is_unitary_hash_big(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_hash_big_SIMPLE(pd) od)

set HOWMANY = int:0

set hermitian_form_irreducible_big(Param p) = KTypePol:
    if is_unitary_hash_big(p)
    then let ans = K_type_pol(character_formula(p))
	 in ans
    else let G = p.real_form
     	  then () = HOWMANY +:= 1
	  {in hermitian_form_irreducible(p)}
	  then derps = derived_factor_params0(p)
	  then mu0 = LKTs(p)[0]
	  {then ans = }
	  in glue_sigs(for derp in derps do hermitian_form_irreducible_big_SIMPLE(derp) od, mu0)
	  {
	  then () = prints("to-glue = ",for derp in derps do hermitian_form_irreducible_big_SIMPLE(derp) od)
	  then () = prints("glued answer = ",ans)
	  then () = prints("correct answer = ", hermitian_form_irreducible(p))
	  }
	  {then () = assert((ans - hermitian_form_irreducible(p)).=,"bad glue_sigs!")}
	  {in ans}
     fi

set print_int_flag = false

{initial time to give interruptible command}
set interrupt_base_time = int: 100 {was 200 before 7/24/25; sometimes 500...}

{assume p = u_to_ht_hash.list()[j], h = u_to_ht_hts[j] gives
is_unitary_to_ht(p,h) = true}
set u_to_ht_hash = make_Param_hash()
set u_to_ht_hts = [int]:[]

set add_to_u_to_ht(Param p,int h) = void:
    let M = u_to_ht_hash.size()
    then m = u_to_ht_hash.match(p)
    in if m = M
       then u_to_ht_hts #:= h
       else u_to_ht_hts[m] := max(u_to_ht_hts[m],h)
       fi

set add_to_u_to_ht([(Param,int)] data) = void:
    for d in data do add_to_u_to_ht(d) od

set u_to_ht_clear() = void:
    u_to_ht_hash.clear();
    u_to_ht_hts := ([int]: [])

{assume p is hermitian}
set hermitian_form_irreducible_to_ht_big_SIMPLE(Param p,int HT) = KTypePol:
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return hermitian_form_irreducible_to_ht(p,HT) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then L = big_unitary_hash.ulookup(p)
  then () = if L.>=
       	    then let ans =K_type_pol(character_formula_to_height(p,HT))
		 in return(ans)
	     fi
  then j = u_to_ht_hash.lookup(p)
  then () = if j.>= and u_to_ht_hts[j] >= HT
       	    then let ans =K_type_pol(character_formula_to_height(p,HT))
	    	 in return(ans)
	    fi
  in big_unitary_hash.sig_entry(p,HT) {this uses low(p,HT) to decide how to compute}

set HOWMTH = int:0

set hermitian_form_irreducible_to_ht_big(Param p,int HT) = KTypePol:
    HOWMTH +:= 1;
    if low(p,HT)
    then hermitian_form_irreducible_to_ht(p,HT)
    else to_ht(hermitian_form_irreducible(p),HT)
    fi

set is_unitary_to_ht_big_SIMPLE_old(Param p, int HT) = bool:
     hermitian_form_irreducible_to_ht_big_SIMPLE(p,HT).is_pure

{try is_unitary if H big enough for it to look faster. Increasing ???  means
is_unitary is tried LESS often}
set ht_bound_frac = rat: 1/2

{this version can't do lookup in big_unitary_hash without putting time versions of sig_entry}
set is_unitary_to_ht_big_SIMPLE_interrupt(Param p, int HT, int time) = int: {1 means true, -1 false, 0 interrupted}
  if (not is_hermitian(p)) then return -1 fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return -1 fi;
  if HT.< then return is_unitary_hash_big_SIMPLE(p,time) fi;
  if HT < height(p) then return 1 fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if (not FPP_flag)
       	    then return hermitian_form_irreducible_to_ht_MvL(p, HT, time).is_pure
	    fi
  then () = p := herm_center(p)
  then () = if big_unitary_hash.nu_height_lookup_bool(p,HT) then return -1 fi
  then () = if (big_unitary_hash.ulookup(p)).>= then return 1 fi
  then j = u_to_ht_hash.lookup(p)
  then () = if j.>= and u_to_ht_hts[j] >= HT
	    then return 1
	    fi
  in if low(p,HT)
     then is_unitary_to_ht_MvL (p, HT, time)
     else to_ht(hermitian_form_irreducible(p,time),HT).is_pure
     fi


{if low(p,HT) suggests it's worthwhile (FALSE) try is_unitary with time limit time}
set is_unitary_to_ht_big_SIMPLE(Param p, int HT, int time) = bool:
    if HT.< then return is_unitary_hash_big_SIMPLE(p) fi;
    if low(p,HT)
    then is_unitary_to_ht_big_SIMPLE_old(p, HT)
    else let ans = hermitian_form_irreducible(p,time) {maybe_KTP}
    	 in case ans
	    | timed_out: is_unitary_to_ht_big_SIMPLE_old(p, HT)
	    | done(r): is_pure(to_ht(r,HT))
	    esac
     fi

{false tries is_unitary intermittently}
set old_to_ht_flag = true

set avtime_frac = rat: 16/1

set is_unitary_to_ht_big_SIMPLE(Param p, int H) = bool:
    if old_to_ht_flag then return is_unitary_to_ht_big_SIMPLE_old(p, H) fi;
    if H < height(p) then return true fi;
    let N_hts = min(#tested_pos_to_ht_times, H - height(p))
    then prevtimes = for j:N_hts do tested_pos_to_ht_times[j] od.##
    then () = if #prevtimes = 0
	      then return is_unitary_to_ht_big_SIMPLE(p,H,floor(avtime_frac*100))
	      fi
    then avtime = sum(prevtimes)/#prevtimes
    in is_unitary_to_ht_big_SIMPLE(p, H, floor(avtime_frac*avtime))

{deform to walls of face, check lower comp factors for nonunitarity there}
{false if parameter is proven nonunitary, true if cannot decide}
set is_unitary_to_ht_wiggle_big_SIMPLE(KGBElt x, ratvec lambda, vec verts,
					int HT, LocalVertexData Lvd) = bool:
    if #verts <= 1 then return true fi;
    let p=parameter(x,lambda,face_bary(Lvd,verts)), d = #verts
    then H0 = height(p), short_verts = for i:d+1 do delete(verts,i) od
    then CF = character_formula_to_height(1*p,HT)
    then pdef1 = for sv in short_verts
		 do monomials(composition_series_to_ht(wiggle(CF, face_bary(Lvd,sv)), HT - 1))
		 od.##
    in not any(for q in pdef1
	   do @bool: height(q)>H0 and not is_unitary_to_ht_big_SIMPLE(q,HT)
	   od)


{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big(Param p,int N) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  {if (big_unitary_hash.ulookup(p)).>= then return true fi;} {this function is meant for nonsimple G}
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_to_ht_big_SIMPLE(pd,N) od)

set test_interrupt_verbose=false
set old_test_interrupt_flag = false
set Ufirst_flag = false

{"step" is how many steps up in to_ht list to start}
set is_unitary_test_big_SIMPLE_interrupt_old(Param p, int step) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if step.<= then step:=1 fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p)
  then ht_bound = (GAM - LAM) * diff_frac {NU/low_frac}
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then () = if (big_unitary_hash.ulookup(p)).>=
	    then return true
	    elif is_finished(p.x,p.lambda)
	    then return false
	    elif (big_unitary_hash.nulookup(p)).>=
	    then return false
	    fi
  then result = 0, mu = LKTs(p)[0]
  then taus = next_taus(p,step)
  then tau_bd = taus~[0]
  then ht = height(tau_bd)
  then old_ht = ht
  then {tau_bd = next_taus(mu,step)~[0],} top_ht = GAM {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then times_to_ht = [int]: [], time_to_ht = int:0
  then () = while result = 0 and ht < ht_bound
       	    do let  start_to_ht = elapsed_ms()
	       then () = old_ht:=ht
	       then to_ht_ans = is_unitary_to_ht_big_SIMPLE(p,ht)
	       then () = time_to_ht:=elapsed_ms() - start_to_ht
	       then () = if test_interrupt_verbose
			 then prints("time to ht ",ht," = ",print_time_string(time_to_ht))
			 fi
	       then () = times_to_ht #:= time_to_ht
	       then () = tau_bd := next_to_lowest(tau_bd);
	       	       	 old_ht:=ht;
		    	 ht:=height(tau_bd)
	       {then () = if time_to_ht > 10000 and test_verbose
			 then prints("height ",ht," of SIMPLE_interrupt took ",print_time_string(time_to_ht))
			 fi}
	       in result := if not to_ht_ans
			    then big_unitary_hash.numatch_height(p,old_ht); -1
			    elif old_ht >= top_ht
			    then big_unitary_hash.umatch(p); 1
			    elif test_interrupt_verbose
			    then let startu = elapsed_ms()
				 then r = is_unitary(p,floor(mu_time_mult*max(times_to_ht)))
				 then () = prints("result ",r," from is_unitary, in time ",
					 print_time_string(elapsed_ms() - startu))
				 in r
			    else is_unitary(p,floor(mu_time_mult*max(times_to_ht)))
			    fi
	    od
   in if result > 0 then true
      elif result < 0 then big_unitary_hash.numatch(p); false
      else is_unitary_hash_big_SIMPLE(p)
      fi

{"step" is how many steps up in to_ht list to start}
set is_unitary_test_big_SIMPLE_interrupt_Ufirst(Param p, int step) = bool:
  if old_test_interrupt_flag then return is_unitary_test_big_SIMPLE_interrupt_old(p,step) fi;
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if step.<= then step:=1 fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p)
  {then shift = 1}
  {then ht_bound = (GAM - LAM) * diff_frac {NU/low_frac}}
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then () = if (big_unitary_hash.ulookup(p)).>=
	    then return true
	    elif is_finished(p.x,p.lambda)
	    then return false
	    elif (big_unitary_hash.nulookup(p)).>=
	    then return false
	    fi
  then result = 0, mu = LKTs(p)[0]
  then taus = next_taus(p,step)
  then tau_bd = taus~[0]
  then ht = height(tau_bd)
  then old_ht = ht
  then top_ht = GAM
       {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then next_time = int: interrupt_base_time, test_time = int:0
  then () = while result = 0 {and ht < ht_bound}
       	    do let start_u = elapsed_ms()
	       then () = result := is_unitary(p, next_time);
		       	 test_time:= elapsed_ms() - start_u;
	       		 if test_interrupt_verbose
		       	 then prints("result ",result," from is_unitary, in time ",
				      	 print_time_string(test_time))
			 fi
	       then () = if result.!= then break fi
	       then start_to_ht = elapsed_ms()
	       then () = result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,next_time)
	       then () = test_time:=elapsed_ms() - start_to_ht
	       then () = if test_interrupt_verbose
	       	       	 then prints("result = ", result, " from to_ht ",ht,", in time ",
			      print_time_string(test_time))
			 fi
	       then () = if result.!= {got a result from to_ht}
	       	       	 then tau_bd := next_to_lowest(tau_bd);
			      old_ht := ht;
			      ht:=height(tau_bd);
			      next_time := max(next_time,test_time)
			 else next_time:=2*next_time {in case didn't finish}
			 fi
	       {then () = if time_to_ht > 10000 and test_verbose
	       	       	 then prints("height ",ht," of SIMPLE_interrupt took ",
			      		     print_time_string(time_to_ht))
			 fi}
	       in if result = -1
	       	  then big_unitary_hash.numatch_height(p,old_ht)
		  elif result = 1 and old_ht >= top_ht
		  then big_unitary_hash.umatch(p)
		  else if result = 1 then result:=0 fi
		  {else let startu = elapsed_ms() {to_ht was indeterminate}
		       in result := is_unitary(p, next_time);
		       	  test_time:= elapsed_ms() - startu;
			  next_time:= max(next_time,test_time);
		          if test_interrupt_verbose
		       	  then prints("result ",result," from is_unitary, in time ",
				      	 print_time_string(test_time))
			  fi}
		  fi
	    od
   in if result > 0
      then big_unitary_hash.umatch(p); true
      elif result < 0 then big_unitary_hash.numatch(p); false
      else is_unitary_hash_big_SIMPLE(p) {shouldn't come to here}
      fi

{"step" is how many steps up in to_ht list to start}
set is_unitary_test_big_SIMPLE_interrupt(Param p, int step) = bool:
  if old_test_interrupt_flag then return is_unitary_test_big_SIMPLE_interrupt_old(p,step) fi;
  if Ufirst_flag then return is_unitary_test_big_SIMPLE_interrupt_Ufirst(p,step) fi;
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if step.<= then step:=1 fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p)
  {then shift = 1}
  {then ht_bound = (GAM - LAM) * diff_frac {NU/low_frac}}
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then () = if (big_unitary_hash.ulookup(p)).>=
       	    then return true
	    elif is_finished(p.x,p.lambda)
	    then return false
	    elif (big_unitary_hash.nulookup(p)).>=
	    then return false
	    fi
  then result = 0, mu = LKTs(p)[0]
  then taus = next_taus(p,step)
  then tau_bd = taus~[0]
  then ht = height(tau_bd)
  then old_ht = ht
  then top_ht = GAM
       {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then next_time = int: interrupt_base_time, test_time = int:0
  then () = while result = 0 {and ht < ht_bound}
       	    do let  start_to_ht = elapsed_ms()
	       then () = result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,next_time)
	       then () = test_time:=elapsed_ms() - start_to_ht
	       then () = if test_interrupt_verbose
			 then prints("result = ", result, " from to_ht ",ht,", in time ",
			      print_time_string(test_time))
			 fi
	       then () = if result.!= {got a result}
			 then tau_bd := next_to_lowest(tau_bd);
			      next_time := max(next_time,test_time)
			 else next_time:=2*next_time {in case didn't finish}
			 fi;
			 old_ht:=ht;
			 ht:=height(tau_bd)
	       {then () = if time_to_ht > 10000 and test_verbose
			 then prints("height ",ht," of SIMPLE_interrupt took ",
					     print_time_string(time_to_ht))
			 fi}
	       in if result = -1
		  then big_unitary_hash.numatch_height(p,old_ht)
		  elif result = 1 and old_ht >= top_ht
		  then big_unitary_hash.umatch(p)
		  else let startu = elapsed_ms() {to_ht was indeterminate}
		       in result := is_unitary(p, next_time);
			  test_time:= elapsed_ms() - startu;
			  next_time:= max(next_time,test_time);
			  if test_interrupt_verbose
			  then prints("result ",result," from is_unitary, in time ",
					 print_time_string(test_time))
			  fi
		  fi
	    od
   in if result > 0
      then big_unitary_hash.umatch(p); true
      elif result < 0 then big_unitary_hash.numatch(p); false
      else is_unitary_hash_big_SIMPLE(p) {shouldn't come to here}
      fi

set default_interrupt_start = int: 1 {2}

set is_unitary_test_big_SIMPLE_interrupt(Param p) = bool:
    is_unitary_test_big_SIMPLE_interrupt(p, default_interrupt_start)

{hts should be increasing string of heights > height(p). Check those, then switch to above}
set is_unitary_test_big_SIMPLE_interrupt(Param p, [int] hts) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if #hts = 0 then return is_unitary_test_big_SIMPLE_interrupt(p, 1) fi;
  if hts~[0] <= height(p) then return is_unitary_test_big_SIMPLE_interrupt(p) fi;
  let G = p.real_form, (,NU,) = low(p)
  then ht_bound = NU*nu_frac
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary(p) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then () = if (big_unitary_hash.ulookup(p)).>=
	    then return true
	    elif is_finished(p.x,p.lambda)
	    then return false
	    fi
  then () = if (big_unitary_hash.nulookup(p)).>=
	    then return false
	    fi
  then result = 0, mu = LKTs(p)[0], top_ht = floor((p.infinitesimal_character)*G.two_rho_check)
       {unitary to top_ht implies unitary}
  then times_to_ht = int: 0
  then i0 = first(for ht in hts do ht > height(p) od)
  then () = hts:= hts[i0:]
  then () = for ht in hts
	    do let start_to_ht = elapsed_ms()
	       then to_ht_ans = is_unitary_to_ht_big_SIMPLE(p,ht)
	       then () = times_to_ht +:= elapsed_ms() - start_to_ht
	       {then () = if time_to_ht > 10000 and test_verbose
			 then prints("ht ",ht," of SIMPLE_interrupt took ",print_time_string(time_to_ht))
			 fi}
	       in result := if not to_ht_ans
			    then big_unitary_hash.numatch_height(p,ht); -1
			    elif ht >= top_ht
			    then big_unitary_hash.umatch(p); 1
			    else is_unitary(p,floor(mu_time_mult*times_to_ht))
			    fi
	    od
   then () = if result < 0 then big_unitary_hash.numatch(p); return false fi
   then taus = next_taus(mu,#hts), last_ht = hts~[0]
   then N = if height(taus~[0])> last_ht
	    then first(for tau in taus do height(tau)> last_ht od)
	    else #hts
	    fi
   in is_unitary_test_big_SIMPLE_interrupt(p, N)

{try for time milliseconds; return 1 if true, -1 if false, 0 if run out of time}
set is_unitary_test_big_SIMPLE_interrupted_Ufirst(Param p, int time) = int:
  if (not is_hermitian(p)) then return -1 fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return -1 fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p), start = elapsed_ms()
  {then ht_bound = (GAM - LAM) * diff_frac} {NU/low_frac}
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary(p,time) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then () = if (big_unitary_hash.ulookup(p)).>=
       	    then return 1
	    elif is_finished(p.x,p.lambda)
	    then return -1
	    elif (big_unitary_hash.nulookup(p)).>=
	    then return -1
	    fi
  then result = 0
  then tau_bd = next_to_lowest(LKTs(p)[0])
  then ht = height(tau_bd)
  then top_ht = GAM
       {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then next_time = int:  max(time\4,1), test_time = int:0
  then () = while result = 0 and elapsed_ms() - start < time
       	    do let start_u = elapsed_ms()
	       then () = result := is_unitary(p, next_time);
		       	 test_time:= elapsed_ms() - start_u;
	       		 if test_interrupt_verbose
		       	 then prints("result ",result," from is_unitary, in time ",
				      	 print_time_string(test_time))
			 fi
	       then () = if result.!= then break fi
	       then start_to_ht = elapsed_ms()
	       then () = result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,next_time)
	       then () = test_time:=elapsed_ms() - start_to_ht
	       then () = if test_interrupt_verbose
	       	       	 then prints("result = ", result, " from to_ht ",ht,", in time ",
			      print_time_string(test_time))
			 fi
	       then () = if result = 1 and ht <top_ht {got a useless result from to_ht}
	       	       	 then tau_bd := next_to_lowest(tau_bd);
			      ht:=height(tau_bd);
			      result := 0;
			      next_time := max(next_time,test_time)
			 elif result.=
			 then next_time:=2*next_time {in case didn't finish}
			 fi
	       in if result = -1
	       	  then big_unitary_hash.numatch_height(p,ht)
		  fi
	    od
   in if result > 0
      then big_unitary_hash.umatch(p)
      elif result < 0
      then big_unitary_hash.numatch(p)
      fi;
      result

{try for time milliseconds; return 1 if true, -1 if false, 0 if run out of time}
set is_unitary_test_big_SIMPLE_interrupted(Param p, int time) = int:
  if Ufirst_flag then return is_unitary_test_big_SIMPLE_interrupted_Ufirst(p,time) fi;
  if (not is_hermitian(p)) then return -1 fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return -1 fi;
  let G = p.real_form, (LAM,NU,GAM) = low(p), start = elapsed_ms()
  {then ht_bound = (GAM - LAM) * diff_frac} {NU/low_frac}
  {this estimates the biggest ht where to_ht could be faster than is_unitary}
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary(p,time) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then () = if (big_unitary_hash.ulookup(p)).>=
       	    then return 1
	    elif is_finished(p.x,p.lambda)
	    then return -1
	    elif (big_unitary_hash.nulookup(p)).>=
	    then return -1
	    fi
  then result = 0
  then tau_bd = next_to_lowest(LKTs(p)[0])
  then ht = height(tau_bd)
  then top_ht = GAM
       {floor((p.infinitesimal_character)*G.two_rho_check)}
       {unitary to top_ht implies unitary}
  then next_time = int: max(time\4,1), test_time = int:0
  then () = while result = 0 and elapsed_ms() - start < time
       	    do let start_to_ht = elapsed_ms()
	       then () = result := is_unitary_to_ht_big_SIMPLE_interrupt(p,ht,next_time)
	       then () = test_time:=elapsed_ms() - start_to_ht
	       then () = if test_interrupt_verbose
	       	       	 then prints("result = ", result, " from to_ht ",ht,", in time ",
			      print_time_string(test_time))
			 fi
	       then () = if result.> and ht< top_ht {got a useless result}
	       	       	 then tau_bd := next_to_lowest(tau_bd);
			      ht:=height(tau_bd);
			      result:=0;
			      next_time := max(next_time,test_time)
			 elif result.> {now ht>= top_ht}
			 then big_unitary_hash.umatch(p);
			      break
			 elif result.=
			 then next_time:=2*next_time {in case didn't finish}
			 elif result.<
			 then big_unitary_hash.numatch_height(p,ht);
			      break
			 fi
	       in {necessarily result = 0 here}
	       	  let startu = elapsed_ms() {to_ht was indeterminate}
		  in result := is_unitary(p, next_time);
		     test_time:= elapsed_ms() - startu;
		     if test_interrupt_verbose
		     then prints("result ",result," from is_unitary, in time ",
				  print_time_string(test_time))
		     fi;
		     if result.=
		     then next_time:= max(next_time,test_time)
		     fi
	    od
   in if result > 0
      then big_unitary_hash.umatch(p)
      elif result < 0
      then big_unitary_hash.numatch(p)
      fi;
      result
{This was in FPP_lambdas.at; moved here to use recording is_unitary tests}
{1 means unitary, -1 nonunitary, 0 no test}
set ind_test(Param p) = int:
    let icp = ind_cand_params(p).##, G = p.real_form
    then () = for pL in icp
       	      do if real_induce_irreducible(pL,G) = 1*p
       	  	 then if all(for dpL in derived_factor_params0(pL) do @bool:
		 is_unitary_test_big_SIMPLE_interrupt(dpL) od)
		 {is_unitary_hash_big_SIMPLE_weak(dpL) od)}
		 {is_unitary(dpL) od)}
		      then return 1
		      else return -1
		      fi
	  	 else if all(for dpL in derived_factor_params0(pL) do @bool:
		 is_unitary_test_big_SIMPLE_interrupt(dpL) od)
		 {is_unitary_hash_big_SIMPLE_weak(dpL) od)}
		 {is_unitary(dpL) od)}
		      then return 1
		      else 0
		      fi
		 fi
	      od
   in 0

set is_u_ind(Param p) = bool:
    let icpd = ind_cand_paramsD(p), G = p.real_form
    in any(for list in icpd do @bool: all(for dpL in list do is_unitary(dpL) od) od)

{list is meant to be a not large collection of Param's with the same unitarity
status; test interruptibly in succession until something gives}
set mult_is_unitary([Param] list) = bool:
    if #list = 0 then return true fi;
    if #list = 1 then return is_unitary_test_big_SIMPLE_interrupt(list[0]) fi;
    let next_time = interrupt_base_time
    then answer = int:0
    then () = while answer = 0
    	      do for p in list
	      	 do let this = is_unitary_test_big_SIMPLE_interrupted(p, next_time)
		    in if this.!=
		       then answer := this;
		       	    break
		       fi
		 od;
		 if answer.= then next_time:=2*next_time fi;
		 if next_time > 100000
		 then return any (for p in list
		      	     	  do @bool: is_unitary_test_big_SIMPLE_interrupt(p)
				  od)
		 fi
	      od
    in answer.>

set wiggle_is_unitary(Param p, KGBElt x, ratvec lambda, LocalVertexData Lvd) = bool:
    if not is_hermitian(p) then return false fi;
    p:= herm_center(p);
    let theta = p.x.involution, G = p.real_form
    then delta = G.distinguished_involution, gamma = p.infinitesimal_character
    then lamthlam = ratvec_as_vec((1+theta)*lambda)
    then Aff_theta(ratvec v) =  -theta*v + lamthlam
    then FV = for v in face_verts(G,gamma) do (v+delta*v)/2 od
    then local_vert_nums = [int]:
    	 for v in FV
    	 do Lvd.lookup((v+Aff_theta(v))/2)
	 od.sort_u
    then d = #local_vert_nums - 1
    then () = assert(@:gamma = face_bary(Lvd,local_vert_nums),
	       	    		 "bad Lvd or local_vert_nums")
    then vert_subs = power_set(local_vert_nums)[1:2^(d+1)] {omit empty, include full set}
    then deform_cands = [ratvec]:
	 for sub in vert_subs
	 do face_bary(Lvd,sub)
	 od
    then CF = character_formula(p)
    then defs = [[Param]]:
	 for gammabd in deform_cands
	 do  monomials(composition_series(wiggle(CF, gammabd)))
	 od
    then helpers = [Param]:
	 for list in defs
	 do if #list = 1
	    then [list[0]]
	    else []
	    fi
	 od.##
	     {these are Params whose unitarity is equivalent to that of p}
    then () = assert(@:#helpers > 0,"missing p from helpers?")
    then result = false
    then () = if any(for q in helpers do big_unitary_hash.uhash(G).lookup(q).>= od)
	      then result :=true
	      elif any(for list in defs
		       do any(for q in list do @bool: big_unitary_hash.nuhash(G).lookup(q).>= od)
		       od)
	      then result := false
	      else result := mult_is_unitary(helpers)
	      fi
     in if result
	then for list in defs
	     do for q in list
	     	do big_unitary_hash.uhash(G).match(q)
	     	od
	     od
	 else big_unitary_hash.numatch(p)
	 fi;
	 result

set wiggle_is_unitary(Param p) = bool:
    let x = p.x, lambda = p.lambda
    then Lvd = Lvd(x,lambda)
    in wiggle_is_unitary(p,x,lambda,Lvd)

set to_hts_count_mat = null(10,10)
set to_hts_count = null(10)

{Ns should be increasing string of heights > height(p).}
set is_unitary_to_hts_big_SIMPLE_interrupt(Param p,[int] Ns, int time) = bool:
    if print_int_flag then prints("N = ",Ns, " p = ",p) fi;
    if #Ns = 0 or Ns~[0] < height(p) then return true fi;
    if big_unitary_hash.nu_height_lookup_bool(p, Ns~[0]) then return false fi;
    let k = u_to_ht_hash.lookup(p) in if k.>= and u_to_ht_hts[k] >= Ns~[0] then return true fi;
    let j0 = first(for N in Ns do N>= height(p) od)
    then () = Ns:=Ns[j0:]
    then () = for N@i in Ns
	     do let result = 0, which_flag = low(p,N), start = elapsed_ms()
		then () = while result = 0
			  do result:= if which_flag
				     then is_unitary_to_ht_MvL(p,N,time)
				     else case hermitian_form_irreducible(p,time)
					  | timed_out: 0
					  | done(result):
					    if is_pure((to_ht(result,Ns~[0])))
					    then 1
					    else -1
					    fi
					  esac
				     fi;
				if print_int_flag then prints("in to_hts, time = ", time, ", which_flag = ",
				which_flag, ", elapsed = ", elapsed_ms() - start) fi;
			     {unitary_test_counter.use(); this is done in the calls above}
			     if not which_flag and not result.= then break fi;
			     if which_flag then time := 2*time fi;
			     which_flag := not which_flag
			  od {while result}
		in if result<0
		   then big_unitary_hash.numatch_height(p,Ns~[0]); return false
		   fi
	     od
     in true

{meant to be used for G simple}
{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big_SIMPLE(Param p,[int] Ns) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if #Ns = 0 or Ns~[0] < height(p) then return true fi;
  if big_unitary_hash.nu_height_lookup_bool(p, Ns~[0]) then return false fi;
  if (big_unitary_hash.ulookup(p)).>= then return true fi;
  let k = u_to_ht_hash.lookup(p) in if k.>= and u_to_ht_hts[k] >= Ns~[0] then return true fi;
  let j0 = first(for N in Ns do N>= height(p) od)
  then () = Ns:=Ns[j0:]
  then G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then return is_unitary_to_hts(p,Ns) {prints("FPP DANGER TO HT at ",p)}
	    fi
  {then () = p := herm_center(p)}
  in is_unitary_to_hts_big_SIMPLE_interrupt(p, Ns, interrupt_base_time)


{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big (Param p,[int] Ns) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  if #Ns = 0 then return is_unitary_hash_big(p) fi;
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_to_hts_big_SIMPLE(pd,Ns) od)


{ONLY for G simple}
{ compute Hermitian form to height N; if it's positive, then compute full form }
set is_unitary_test_big_SIMPLE(Param p, int N) = bool:
    if (not is_hermitian(p)) then return false fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    if N < height(p) then return is_unitary_hash_big_SIMPLE(p) fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
	      then return is_unitary{_test}(p{,N}) {prints("FPP DANGER TO HT at ",p)}
	      fi
    {then () = p := herm_center(p)}
    then () = if big_unitary_hash.ulookup(p).>=
	      then return true
	      elif is_finished(p.x,p.lambda)
	      then return false
	      fi
    then () = if big_unitary_hash.nulookup(p).>=
	      then return false
	      fi

    in let P = big_unitary_hash.sig_entry(p,N)
       in if not is_pure(P)
	  then false
	  else is_unitary_hash_big_SIMPLE(p)
	  fi

{ONLY for G simple}
{ like previous, with list of heights }
set is_unitary_test_big_SIMPLE (Param p, [int] Ns) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
	    then  return is_unitary{_test}(p{,Ns}) {prints("FPP DANGER TEST at ",p)}
	    fi
  {then () = p := herm_center(p)}
  {then () = test_count[#Ns] +:= 1}
  then () = if (big_unitary_hash.ulookup(p)).>= then return true fi
  then () = if (big_unitary_hash.nulookup(p)).>= then return false fi
  then () = if #Ns = 0
	    then {test_count_mat[0,0] +:= 1;}
	    return is_unitary_hash_big_SIMPLE(p)
	    fi
  in for N in Ns
     do if not is_pure(big_unitary_hash.sig_entry(p,N))
	then return false
	fi
     od;
     is_unitary_hash_big_SIMPLE(p)

set is_unitary_test_big(Param p, int N) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_test_big_SIMPLE(pd,N) od)

set is_unitary_test_big(Param p, [int] Ns) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_test_big_SIMPLE(pd,Ns) od)

{ONLY for G simple}
{use the first m heights from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p,int m) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
	      then return is_unitary{_def_test}(p{,m}) {prints("FPP DANGER DEF TEST at ",p)}
	      fi
    {then () = p := herm_center(p)}
    then () = if (big_unitary_hash.ulookup(p)).>= then return true fi
    then () = if (big_unitary_hash.nulookup(p)).>= then return false fi
    in if low(p, height(p))
       then let (def,flag)= deform_hts(p,m)
	    in if flag
	       then (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) and
		    is_unitary_to_hts_big_SIMPLE(p,def)
	       else is_unitary_test_big_SIMPLE(p,def)
	       fi
       else is_unitary_hash_big_SIMPLE(p)
       fi

set is_unitary_def_test_big(Param p,int m) = bool:
  if (not is_hermitian(p)) then return false fi;
  if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_def_test_big_SIMPLE(pd,m) od)

{ONLY for G simple}
{use the first height from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p) = bool:
    is_unitary_def_test_big_SIMPLE(p,1)

set is_unitary_def_test_big(Param p) = bool:
    is_unitary_def_test_big(p,1)

{ONLY for G simple}
set is_unitary_next_big_SIMPLE(Param p) = bool:
    if (not is_hermitian(p)) then return false fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let G = p.real_form
    then (LAM,NU,) = low(p)
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
	      then if NU > LAM*nu_frac
		   then let n=next_heightB(p)
			in if (n+1).=
			   then return true
			   elif is_unitary_to_ht_big(p,n)
			   then return is_unitary_hash_big_SIMPLE(p)
			   else big_unitary_hash.numatch(p); return false {NOT unitary_to_ht}
			   fi {n=-1}
		   else return is_unitary_hash_big_SIMPLE(p)
		   fi {NU > LAM}
	       fi {not FPP_flag}
    {then () = p := herm_center(p)}
    in if NU > LAM*nu_frac
       then let n=next_heightB(p)
	    in  if (n+1).=
		then true
		elif is_unitary_to_ht_big_SIMPLE(p,n)
		then is_unitary_hash_big_SIMPLE(p)
		else big_unitary_hash.numatch(p); false {NOT unitary_to_ht}
		fi {n=-1}
	else is_unitary_hash_big_SIMPLE(p)
	fi {NU > LAM}

set is_unitary_next_big(Param p) = bool:
    if (not is_hermitian(p)) then return false fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_next_big_SIMPLE(pd) od)

set theta_induce_signature(Param pL, RealForm G) = KTypePol:
    theta_induce_K(hermitian_form_irreducible_big(pL),G)

set theta_induce_signature_to_ht(Param pL, int DL, RealForm G) = KTypePol:
    theta_induce_K(hermitian_form_irreducible_to_ht_big(pL,DL),G)

{whether to use the new Davis/Mason-Brown criterion saying FPP reps on an outside
face of FPP might have to be coh ind}
set is_FPP_unitary_flag = false

{IF using test, whether to stop after easy part}
set Lucas_fast_flag = true


{Use Davis/Mason-Brown criterion. First bool says whether the test applies; second gives
result of test. Second is meaningful only if first is true; I guess make result (false,false)
otherwise?}
set is_FPP_unitary(Param p) = (bool,bool):
    if not is_FPP_unitary_flag then return (false,false) fi;
    if (not is_hermitian(p)) then return (true,false) fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return (true,false) fi;
    let G = (p:= herm_center(p)).real_form
    then gamma = p.infinitesimal_character
    then alphavs = for alphav@j in G.simple_coroots
		  do if gamma*alphav < 1
		     then [j]
		     elif gamma*alphav > 1
		     then []
		     else let rdi = integrality_datum(G,gamma)
			  then ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
     then () = if #alphavs = G.semisimple_rank
	       then return (false,false) {say we don't know}
	       fi
     then Q = KGPElt:(alphavs, p.x) {p now must be good range coh ind from Q}
     then rhou = Q.rho_u
     then () = if((p.x.involution-1)*rhou).!=
	       then return (true,false)
	       fi
     then () = if Lucas_fast_flag
	       then return (false,false)
	       {in this case question reduces to L, but we choose not to do
	       calculation on L}
	       fi
     then L = Q.Levi
     then xL = inverse_embed_KGB(p.x,L)
     then pL = parameter(xL,p.lambda - rhou, p.nu)
     then () = assert(@:p = first_param(theta_induce_standard(pL,G)),"screwed up pL!")
     then derpLs = derived_factor_params0(pL)
     in (true, all(for derpL in derpLs
		   do @bool:
		      {let () = FPP_unitary_hash_bottom_layer([(pL.x,pL.lambda)])
		      in} is_unitary_hash_big_SIMPLE(derpL)
		   od))

{First bool says whether the test applies; second gives result of
test. Second is meaningful only if first is true; make result
(false,false) otherwise}
{Can allow fancy_tester to use FPP_unitary_hash}
set is_FPP_unitary(Param p, (Param -> bool) fancy_tester ) = (bool,bool):
    if not is_FPP_unitary_flag then return (false,false) fi;
    if (not is_hermitian(p)) then return (true,false) fi;
    if not (fewer_reducible_unitary_flag or is_pos_on_LKTs(p)) then return (true,false) fi;
    let G = (p:= herm_center(p)).real_form
    then gamma = p.infinitesimal_character
    then rdi = integrality_datum(G,gamma)
    then alphavs = for alphav@j in G.simple_coroots
		  do if gamma*alphav < 1
		     then [j]
		     elif gamma*alphav > 1
		     then []
		     else let ji = coroot_index(rdi,alphav)
			  in if is_member_sorted(tau(p))(ji)
			     do j
			     fi
		     fi
		  od.##
     then () = if #alphavs = G.semisimple_rank
	       then return (false,false) {say we don't know}
	       fi
     then Q = KGPElt:(alphavs, p.x) {p now must be good range coh ind from Q}
     {then ()= prints("have Q = ",Q," in is_FPP_unitary")}
     then rhou = Q.rho_u
     then () = if((p.x.involution-1)*rhou).!=
	       then return (true,false)
	       fi
     then () = if Lucas_fast_flag
	       then return (false,false) {say we don't know}
	       fi
     then L = Q.Levi
     {then () = prints("in isfppu(fancy) at line 1834, p = ",p)}
     then xL = inverse_embed_KGB(p.x,L)
     then pL = parameter(xL,p.lambda - rhou, p.nu)
     then () = assert(@:p = first_param(theta_induce_standard(pL,G)),"screwed up pL!")
     then derpLs = derived_factor_params0(pL)
     in (true, all(for derpL in derpLs
		   do @bool: fancy_tester(derpL)
		   od))

set KUKU_flag = true

{if false, suppress printing of report after an FPP_unitary_hash* job}
{need this here for recursive application of smaller FPP's in fancy_tester}
set FPP_report_flag = true

{For each list of faces in FVKH, indices of faces for which the corresponding parameter is known
(by Uhash) to be unitary}
set KU(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] FVKH, Param_hash Uhash,
 (Param->bool) fancy_tester) = [vec]:
    {prints("in KU",fancy_tester);}
    let FPP_report_flag_hold = FPP_report_flag
    then () = FPP_report_flag :=false
    then answer =
	 for FVKHd@d in FVKH
	 do for vlong@j in FVKHd
	    do let verts = vlong[:d+1], G = x.real_form
	       then ps = monomials(finalize(parameter(x,lambda, face_bary(Lvd,verts))))
	       in if all(for p in ps do (Uhash.lookup(p)).>= od)
		  then [j]
		  elif all(for p in ps
			   do let (x,y) = is_FPP_unitary(p, fancy_tester)
			      then () = if x {whether the FPP test is applicable}
					then if y {result of FPP test}
					     then big_unitary_hash.uhash(G).match(p)
					     else big_unitary_hash.numatch(p)
					     fi
					fi
			      in x and y
			  od)
		  then [j]
		  else []
		  fi
	    od.##
	 od
    then () = FPP_report_flag:=FPP_report_flag_hold
    in answer

set KU(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] FVKH, Param_hash Uhash) =
[vec]:
    KU(x,lambda,Lvd,FVKH,Uhash, is_unitary_hash_big_SIMPLE@Param)

{takes the known unitaries from unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, (Param->bool) fancy_tester) = [vec]:
    if KUKU_flag then return KU(x,lambda, Lvd, LFDKH, Uhash, fancy_tester) fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1])))}
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
	  do if p.nu.=
	     then [j]
	     else let qs = monomials(finalize(p))
		  in if all(for q in qs do @bool: Uhash.lookup(q).>= od)
		     then [j]
		     else []
		     fi
	     fi
	  od.##
       od

set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
   known_unitaries(Uhash, x, lambda, Lvd, LFDKH, is_unitary_hash_big_SIMPLE@Param)


{Here UhashLocal is assumed to consist of Param's at (x,lambda)}
{this misses (in local_testK_level) unitary Param's that finalize to different x;
those are caught by local_testK_hash}
set known_unitaries(Param_hash UhashLocal, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
					      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = UhashLocal.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
	 do let p = UhashLocal.index(k)
	    then list = local_vertices(p)
	    in if #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
		    then m = lookups[#list-1](local_verts)
		    then () = assert(@:m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]#:=m
		    in ()
	       fi
	 od
     in out

{takes the known non-unitaries from non-unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
{set known_non_unitaries(Param_hash NUhash, KGBElt x, ratvec lambda, VertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let qs = monomials(finalize(p))
	     in if all(for q in qs do @bool: NUhash.lookup(q).>= od)
		then [j]
		else []
		fi
	  od.##
       od}
{whether to use deformation in looking for evidence that a Param is not unitary}
{TRUE fails in E6_q one_level at x = 723, lambda = [1,1,0,1,1,1]/1}
set wiggle_flag = false

{whether Param's appearing by deforming the irreducible at the face defined by verts to its
 codimension one faces give nonunitarity}
{set nu_wiggle(KGBElt x, ratvec lambda, vec verts, LocalVertexData Lvd, int HT) = bool:
    if #verts = 1 then return [] fi;
    let p = parameter(x,lambda,face_bary(Lvd,verts)), d = #verts -1
    then CF = character_formula_to_height(1*p,HT)
    then qs = monomials(composition_series_to_ht(( sum(x.real_form,
						for k:d+1
						do wiggle(CF, face_bary(Lvd,verts[:k]##verts[k+1:]))
						od)), HT - 1))
    in any(for q in qs
	   do @bool: not is_unitary_to_ht_big_SIMPLE(q,HT)
	   od)}

{list locations in LFDKH of reps known to be non-unitary to HTs}
set known_non_unitaries_wiggle_old(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, [int] HTs) = [vec]:
    if #LFDKH[0] = 0 then return [] fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    then answer = [vec]: for v:#LFDKH do vec: [] od
    then HT = HTs~[0], H0 = height(ps[0][0])
    then lookups = lookups(LFDKH) {dth term finds a d-face in LFDKH[d]}
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let pdef =
		 if not is_final(p) or d=0
		 then monomials(p)
		 else let CF = character_formula_to_height(1*p,HT)
		      then verts = LFDKH[d][j][:d+1]
		      in  monomials(composition_series_to_ht((sum(x.real_form,
					    for k:d+1
					    do wiggle(CF, face_bary(Lvd,verts[:k]##verts[k+1:]))
					    od)), HT - 1))
		     {to have an interesting test to HT, terms should have strictly smaller HT}
		 fi {now pdef consists of final Params that must be unitary to HT if p is}
	     in if any(for q in pdef
		       do @bool: big_unitary_hash.nu_height_lookup_bool(q,HT)
			  or (height(q) > H0 and not is_unitary_to_hts_big_SIMPLE(q,HTs))
		       od) {CONCERN if HTs[0] < H0?}
		then [j]
		else []
		fi
	  od.## {for p@j in ps[d]; this is vec of known nonunitary j for dim d}
       od {for d:#LFDKH}

{
set wiggle_test(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH,
		int d, int j, [int] HTs) = bool:
    if d = 0 then return true fi;
    let p = parameter(x,lambda,face_bary(Lvd, v[:d+1]))
    then lookup = lookups(LFDKH)[d-1], HT HTs~[0]
    then CF = character_formula_to_height(1*p,HT)
    then verts = LFDKH[d][j][:d+1]
    then short_verts = for k:d+1
		       do verts[:k]##verts[k+1:]
		       od {list of vertex sets for faces}
    then short_js = for sv in short_verts
		    do lookup(sv)
		    od
    in if red_count_flag
       then let redjis = [int]:
		for ji in short_js
		do if LFDKH[d-1][ji][d-1] > LFDKH[d][j][d]
		   then [ji]
		   else []
		   fi {rcs don't match}
		od
       then if #redjis > 0
	    then all(for ji in red_jis
	       do LFDKH[d-1][ji][d] = LFDKH[
		 in for sv in short_verts
		     do let pdefi = monomials(composition_series_to_ht(
					 wiggle(CF, face_bary(Lvd,sv)) , HT - 1))
			in if any (for q in pdefi
				  do @bool: big_unitary_hash.nu_height_lookup_bool(q,HT)
				      or (height(q) > H0 and not is_unitary_to_hts_big_SIMPLE(q,HTs))
				  od) {CONCERN if HTs[0] < H0?}
			   then answer[d]#:= j;
				for ji in short_js
				do if {to_ht(pol_hash.index(LFDKH[d][j][d+red_shift+1]),HT) =
				      to_ht(pol_hash.index(LFDKH[d-1][ji][d+red_shift]),HT)}
				      LFDKH[d][j][d+red_shift+1:d+red_shift+3] =
				      LFDKH[d-1][ji][d+red_shift:d+red_shift+2]
				      {same K-char, # Langlands quos}
				   then answer[d-1] #:= ji
				   fi {to_ht}
				od
			   fi {any q}
		      od {sv@i in short_verts}
}

set known_non_unitaries_wiggle(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, [int] HTs) = [vec]:
    if #LFDKH[0] = 0 then return [] fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    then answer = [vec]: for v:#LFDKH do vec: [] od
    then HT = HTs~[0], H0 = height(ps[0][0])
    then lookups = lookups(LFDKH) {dth term finds a d-face in LFDKH[d]},
	 red_shift = if red_count_flag then 1 else 0 fi
    then () = for d:#LFDKH
       do for p@j in ps[d]
	  do if (not is_final(p)) or d=0
	     then let pdef = monomials(p)
		  in if any(for q in pdef
			    do @bool: big_unitary_hash.nu_height_lookup_bool(q,HT)
			    od)
		     then answer[d]#:= j
		     fi
	     else {now p is final and d > 0}
		  let CF = character_formula_to_height(1*p,HT)
		  then verts = LFDKH[d][j][:d+1]
		  then short_verts = for k:d+1
				     do verts[:k]##verts[k+1:]
				     od {list of vertex sets for faces}
		  then short_js = for sv in short_verts
				  do lookups[d-1](sv)
				  od
		  in for sv in short_verts
		     do let pdefi = monomials(composition_series_to_ht(
					 wiggle(CF, face_bary(Lvd,sv)) , HT - 1))
			in if any (for q in pdefi
				  do @bool: big_unitary_hash.nu_height_lookup_bool(q,HT)
				      or (height(q) > H0 and not is_unitary_to_hts_big_SIMPLE(q,HTs))
				  od) {CONCERN if HTs[0] < H0?}
			   then answer[d]#:= j;
				for ji in short_js
				do if {to_ht(pol_hash.index(LFDKH[d][j][d+red_shift+1]),HT) =
				      to_ht(pol_hash.index(LFDKH[d-1][ji][d+red_shift]),HT)}
				      LFDKH[d][j][d+red_shift+1:d+red_shift+3] =
				      LFDKH[d-1][ji][d+red_shift:d+red_shift+2]
				      {same K-char, # Langlands quos}
				   then answer[d-1] #:= ji
				   fi {to_ht}
				od
			   fi {any q}
		      od {sv@i in short_verts}
	       fi {not is_final(p)}
	  od {for p@j in ps[d]; this is vec of known nonunitary j for dim d}
       od {for d:#LFDKH}
   in for list in answer do sort_u(list) od

{list locations in LFDKH of reps known to be non-unitary to HT}
set known_non_unitaries_wiggle(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, int HT) = [vec]:
known_non_unitaries_wiggle(x,lambda,Lvd,LFDKH,[HT])

{list locations in LFDKH of reps known to be non-unitary}
set known_non_unitaries_wiggle_old(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    if #LFDKH[0] = 0 then return [] fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    then H0 = height(ps[0][0])
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let pdef =
		 if not is_final(p) or d=0
		 then monomials(finalize(p))
		 else let CF = character_formula(finalize(p))
		      then verts = LFDKH[d][j][:d+1]
		      in  monomials(composition_series((sum(x.real_form,
					    for j:d+1
					    do wiggle(CF, face_bary(Lvd,verts[:j]##verts[j+1:]))
					    od))))
		 fi {now pdef consists of reps that must be unitary if p is}
	     in if any(for q in pdef
		       do @bool: (big_unitary_hash.nulookup(q)).>=
			  or (height(q) > H0 and not is_unitary_test_big_SIMPLE_interrupt(q))
		       od)
		then [j]
		else []
		fi
	  od.## {for p@j in ps[d]; this is vec of known nonunitary j for dim d}
       od {for d:#LFDKH}

set known_non_unitaries_wiggle(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    if #LFDKH[0] = 0 then return [] fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    then answer = [vec]: for v:#LFDKH do vec: [] od
    then H0 = height(ps[0][0])
    then lookups = lookups(LFDKH) {dth term finds a d-face in LFDKH[d]},
	 red_shift = if red_count_flag then 1 else 0 fi
    then () = for d:#LFDKH
       do for p@j in ps[d]
	  do if (not is_final(p)) or d=0
	     then let pdef = monomials(p)
		  in if any(for q in pdef
			    do @bool: (big_unitary_hash.nulookup(q)).>=
			    od)
		     then answer[d]#:= j
		     fi
	     else {now p is final and d > 0}
		  let CF = character_formula(1*p)
		  then verts = LFDKH[d][j][:d+1]
		  then short_verts = for k:d+1
				     do verts[:k]##verts[k+1:]
				     od {list of vertex sets for faces}
		  then short_js = for sv in short_verts
				  do lookups[d-1](sv)
				  od
		  in for sv in short_verts
		     do let pdefi = monomials(composition_series(wiggle(CF, face_bary(Lvd,sv))))
			in if any (for q in pdefi
				  do @bool: (big_unitary_hash.nulookup(q)).>=
				      or (height(q) > H0 and not
				      is_unitary_test_big_SIMPLE_interrupt(q))
				  od)
			   then answer[d]#:= j;
				for ji in short_js
				do if LFDKH[d][j][d+red_shift+1] = LFDKH[d-1][ji][d+red_shift]
				      and LFDKH[d][j][d+red_shift+2] =
					  LFDKH[d-1][ji][d+red_shift+1] {same # Langlands quos}
				   then answer[d-1] #:= ji
				   fi {to_ht}
				od
			   fi {any q}
		      od {sv@i in short_verts}
	       fi {not is_final(p)}
	  od {for p@j in ps[d]; this is vec of known nonunitary j for dim d}
       od {for d:#LFDKH}
   in for list in answer do sort_u(list) od

{list locations in LFDKH of reps known to be non-unitary at height HT}
set known_non_unitaries(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, int HT) = [vec]:
    if wiggle_flag
    then return known_non_unitaries_wiggle(x,lambda,Lvd,LFDKH,HT)
    fi;
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let qs = monomials(finalize(p))
	     in if any(for q in qs
		       do @bool: big_unitary_hash.nu_height_lookup_bool(q,HT)
		       od)
		then [j]
		else []
		fi
	  od.##
       od

{wiggle is quite slow without a height bound, so for now just don't do it here}
{list locations in LFDKH of reps known to be non-unitary}
set known_non_unitaries(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    {if wiggle_flag
    then return known_non_unitaries_wiggle(x,lambda,Lvd,LFDKH)
    fi;}
    let ps = for d:#LFDKH
	     do for v in LFDKH[d]
		do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
	  do let qs = monomials(finalize(p))
	     in if any(for q in qs
		       do @bool: (big_unitary_hash.nulookup(q)).>=
		       od)
		then [j]
		else []
		fi
	  od.##
       od

set localize(Param_hash Uhash, KGBElt x, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
	      do let p = Uhash.index(k)
		 in if p.x = x and p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc

set localize(Param_hash Uhash, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
	      do let p = Uhash.index(k)
		 in if p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc


{this is the Q(infinitesimal character) bound provided by Dirac inequality on all LKTs}
set DiracBD(KGBElt x, ratvec lambda) = rat:
    let G = x.real_form
    in min(for mu in LKTs(parameter(x,lambda,0*lambda))
	   do DiracBD(mu)
	   od)

{"true" means unitarity is possible in light of Dirac}
{avoid using is_hermitian defined in hermitian.at}
set DiracTest(Param p) = bool:
    let G=p.real_form
    then ans = bool: if not all(for q in monomials(finalize(p)) do is_hermitian(q) od) then false
       else let gamma = p.infinitesimal_character
	    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
	    then bound = DiracBD(p.x, p.lambda)
	    in Q(gamma,gamma) <= bound
       fi
    then () = if not ans then DTcount +:= 1 fi
    in ans

set DiracTest(KGBElt x, ratvec lambda, ratvec gamma) = bool:
    let Q = {Dirac_easy_hash.invt_form(x.real_form)} invariant_form(x.real_form)
    then bound = DiracBD(x, lambda)
    in Q(gamma,gamma) <= bound

{to be used in DiracBestTest. If the branch is too long, give up}
set protected_occurrence(KTypePol KC, KType tau, int time) = bool:
    case if my_branch_flag
	 then big_unitary_hash.branch_interrupt(KC,height(tau),time)
	 else branch(KC, height(tau), time)
	 fi
       | timed_out: false
       | done(B): B[tau].!=
    esac

{whether to use the time-protected versions of DiracBestTest}
set Dirac_pro_flag = true

set protected_occurrence(KTypePol KC, KType tau) = bool:
    let T = max(4000#tested_neg_times)\4
    in protected_occurrence(KC,tau,T)

{Kchar is mean to be the K-character, to height at least HT, of some subquotients
of p to which Dirac ineq is applied.}
set DiracBestTest_pro(int steps, Param p, int HT, KTypePol Kchar, int time) = bool:
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = best_Dirac_bound_cap(mu,steps)
    then j0 = first(for h in hts do h > HT od)
    then () = if j0<0 then j0:=#hts fi
    {now we only look up at [:j0]}
    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds[:j0] do b<psize od)
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p with hts bdded by HT}
       else let j2 = first(for tau@j in taus[j1:j0] {these taus would exclude p}
			    do @bool: protected_occurrence(Kchar, tau,time)
{
			       if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi
}
			    od)
	    in j2.< {if the bound at j0+j corresponds to a tau
		     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest_pro(int steps, Param p, int HT, KTypePol Kchar) = bool:
    let T = max(10000#tested_neg_times)
    in DiracBestTest_pro(steps, p, HT, Kchar, T)

{Kchar is mean to be the K-character, of some subquotients of p to which Dirac ineq is applied.}
set DiracBestTest_pro(int steps, Param p, KTypePol Kchar, int time) = bool:
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = best_Dirac_bound_cap(mu,steps)
    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds do b<psize od)
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p}
       else let j2 = first(for tau@j in taus[j1:] {these taus would exclude p}
			    do @bool: protected_occurrence(Kchar,tau,time)
			    {if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi}
			    od)
	    in j2.< {if the bound at j corresponds to a tau
		     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest_pro(int steps, Param p, KTypePol Kchar) = bool:
    let T = max(10000#tested_neg_times)\4
    in DiracBestTest_pro(steps, p, Kchar, T)

set DiracBestTest_pro(Param p, KTypePol Kchar) = bool:
    DiracBestTest_pro(Dirac_best_steps, p, Kchar)

{Kchar is mean to be the K-character, to height at least HT, of some subquotients
of p to which Dirac ineq is applied.}
set DiracBestTest(int steps, Param p, int HT, KTypePol Kchar) = bool:
    if Dirac_pro_flag then return DiracBestTest_pro(steps, p, HT, Kchar) fi;
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = truncate(best_Dirac_bound_cap(mu,steps),HT) {now all hts are <= HT}
    {then () = prints(taus," ",hts," ",bds)}
    {then j0 = first(for h in hts do h > HT od)
    then () = if j0<0 then j0:=#hts fi}
    {now we only look up at [:j0]}
    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds do b<psize od)
    {then () = prints("j1 = ",j1)}
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p with hts bdded by HT}
       else let j2 = first(for tau@j in taus[j1:] {these taus would exclude p}
			    do @bool: if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi
			    od)
	    in {prints("j2 = ",j2,", bad K_type = ",taus[j1 + j2]);}
	       j2.< {if the bound at j0+j corresponds to a tau
		     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest(int steps, Param p, KTypePol Kchar) = bool:
    if Dirac_pro_flag then return DiracBestTest_pro(steps, p, Kchar) fi;
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = best_Dirac_bound_cap(mu,steps)
    then Q = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds do b < psize od)
    {then () = prints("j1 = ",j1)}
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p with hts bdded by HT}
       else let j2 = first(for tau@j in taus[j1:] {these taus would exclude p}
			    do @bool: if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi
			    od)
	    in {prints("j2 = ",j2,", bad K_type = ",taus[j1 + j2]);}
	    j2.< {if the bound at j1+j corresponds to a tau
		     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest(Param p, int HT, KTypePol Kchar) = bool:
    DiracBestTest(Dirac_best_steps, p, HT, Kchar)

set DiracBestTest(Param p, KTypePol Kchar) = bool:
    DiracBestTest(Dirac_best_steps, p, Kchar)

{here p must be irr for branch_irr to work}
set DiracBestTest(int steps, Param p, int HT) = bool:
    DiracBestTest(steps, p, HT, K_type_pol(character_formula_to_height(1*p,HT)))

{here p must be irr for branch_irr to work}
set DiracBestTest(int steps, Param p) = bool:
    DiracBestTest(steps, p, K_type_pol(character_formula(1*p)))

{here p must be irr for branch_irr to work}
set DiracBestTest(Param p, int HT) = bool:
    DiracBestTest(Dirac_best_steps, p, HT, K_type_pol(character_formula_to_height(1*p,HT)))

set DiracBestTest(Param p) = bool:
    DiracBestTest(Dirac_best_steps, p, K_type_pol(character_formula(1*p)))

{creates LVD, map Perm on FPPverts at (x,lambda), {mapAct from FPPverts to local verts}}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.
parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}

set localFD_Lvd2 \
  (InnerClass ic, mat theta, ratvec lambda, {VertexData vd,} [(ratvec->int)] edge_lookups) =
  (LocalVertexData, PermOrderTwo{, vec}):
(   let Perm2 = thetaAct2(ic, theta, lambda, {vd,} edge_lookups)
    then vlist = {vd.list}FPP_vertices(ic)
    then vlistAct = [ratvec]:
	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
	 {def of Perm2 forces this to be an actual edge?}
    then Lvd = (vlistAct,#Perm2.fixed).to_vertex_data
    then Llookup = Lvd.lookup
    {then mapAct = vec: for j:#vlist do minus_1 od}
    {maps FPP vertex indices from vd to local indices from Lvd}
    {then () = for i@k in Perm2.fixed do mapAct[i]:= k od}
    {then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
					      mapAct[j]:=#Perm2.fixed + ell od}
    in (Lvd, Perm2{, mapAct})
)

set localFD_Lvd2 \
  ( KGBElt x, ratvec lambda, {VertexData vd,} [(ratvec->int)] edge_lookups) =
  localFD_Lvd2(x.inner_class, x.involution, lambda, {vd,} edge_lookups)

set localFD_Lvd2 \
  ( InnerClass ic, mat theta, ratvec lambda, {VertexData vd,} (vec->int) FlippedEdgeLookup) =
  (LocalVertexData, PermOrderTwo{, vec}):
(   let start = elapsed_ms(), Perm2 = thetaAct2(ic, theta, lambda, {vd,} FlippedEdgeLookup)
    then vlist = {vd.list} FPP_vertices(ic)
    then vlistAct = [ratvec]:
	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans
	 do if FlippedEdgeLookup([i,j]) >= 0
	    then [(vlist[i] + vlist[j])/2]
	    else []
	    fi
	 od.##
    then Lvd = (vlistAct,#Perm2.fixed).to_vertex_data
    then Llookup = Lvd.lookup
    {then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
					      mapAct[j]:=#Perm2.fixed + ell od}
    in (Lvd, Perm2{, mapAct})
)

set localFD_Lvd2 \
  (KGBElt x, ratvec lambda, {VertexData vd,} (vec->int) FlippedEdgeLookup) = (LocalVertexData, PermOrderTwo{, vec}):
  localFD_Lvd2(x.inner_class, x.involution, lambda, {vd,} FlippedEdgeLookup)

set FD12Time = int: 0

{takes local data and low global faces and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2) = [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1Dirac")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = ((ratvec,ratvec)->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then LF0 = [FaceVertsIndex]:
	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if Q(v,v) > DiracBD
	       then DTcount +:=1; []
	       elif not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       elif red_count_flag
	       then [[j, red_count(p,HT)]]
	       else [[j]]
	       fi
	  od.##
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
	 let EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
	     then for v in FPP_edges(G)
		  do if not(Llookup(v[0]) and Llookup(v[1])) then []
		     else let m = locate_sorted(Perm2.fixed, v[0]), n = locate_sorted(Perm2.fixed, v[1])
			  in if m< #Perm2.fixed and n < #Perm2.fixed and Perm2.fixed[m] = v[0]
				and Perm2.fixed[n] = v[1]
			     then [[m,n].sort]
			     else []
			     fi
		      fi
		  od.##
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesFixTrans = [vec]:
	      if #Perm2.fixed > 0 and #Perm2.trans > 0
	      then for v in FPP_flippable_triangles(G)
		   do let m = locate_sorted(Perm2.fixed, v[0]), n = trans_hash.lookup([v[1],v[2]])
		   in if m < #Perm2.fixed and Perm2.fixed[m]=v[0] and n.>=
		      then [[m,#Perm2.fixed+n]]
		      else []
		      fi
		   od.##
		else []
		fi
	   {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = ([vec]:
	      if #Perm2.trans > 1
	      then for v in FPP_flippable_tetrahedra(G)
		   do let m = trans_hash.lookup([v[0],v[1]]), n = trans_hash.lookup([v[2],v[3]])
		      in if m.>= and n.>=
			 then [[#Perm2.fixed + m, #Perm2.fixed + n].sort]
			 else []
			 fi
		    od.##
	       else []
	       fi)
	  {then () = prints("after TransTrans, time is ",print_time_string(elapsed_ms() - start))}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     { then () = prints("after Edges, time is ",print_time_string(elapsed_ms() - start))}
     then LF1 = [FaceVertsIndex]:
	 for v in Edges
	 do let nu = face_bary(Lvd, v)
	    then p = parameter(x,lambda,nu)
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v))}
	    in  if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
		then [] {from now on p is pos_on_LKTs}
		elif Q(nu,nu) > DiracBD
		then DTcount +:=1; prints("GOT HERE!"); []
		elif red_count_flag
		then [v#red_count(p,HT)]
		else [v]
		fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = [LF0]##[LF1]
    then () = FD12Time +:= elapsed_ms() - start
    in if face_verbose then prints("After localFD_1Dirac2, face counts are [",#LF0,
				  ",",#LF1,"]") fi;
       {if time_verbose then prints("     ",print_time_string(elapsed_ms() - start),
					  " for localFD_1Dirac2") fi;}
       if sort_LFD_flag
       then sort(G, Lvd, answer)
       else answer
       fi
)

set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) = [[FaceVertsIndex]]:
  localFD_1Dirac2(x, lambda, next_heights(parameter(x,lambda,0*lambda),edge_offset +1)~[0], Lvd, Perm2)

set FD12bzTime = int:0
set FD12bzFFTime = int:0
set FD12bzFTTime = int:0
set FD12bzTTTime = int:0

{edge-finding tests are performed by (Test B) for vertex set smaller than BoundB,}
{NOT ANY MORE: A1 is always slower than C, by quite a bit?}
     {(Test A1) for vertex sets smaller than BoundA1,}
{and (Test C) for larger vertex sets. I don't really have a clue how these
 should be computed}
set BoundB = int: 600

{takes local data and low global faces and computes local vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}

{If red_count_flag, add an extra coordinate recording red_count(p, next_heights[edge_offset])}
set localFD_1Dirac2_by_zero\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsIndex]]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1Dirac2_by_zero")
    fi;
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1, start = elapsed_ms()
    then () = if Dirac_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then length = #(Lvd.list)
    then freq = max(length\10,1)
    then LF0 = [FaceVertsIndex]:
    	 for v@j in Lvd.list
	 do if fund_face_verbose and red_count_flag and (j%freq).=
	    then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start))
	    fi;
	    let p = parameter(x,lambda,v)
	    in if Q(v,v) > DiracBD
	       then DTcount +:=1; []
	       elif not (fewer_reducible_unitary_flag or all(for q in monomials(finalize(p))
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       elif red_count_flag
	       then [[j, red_count(p,HT)]]
	       else [[j]]
	       fi
	 od.## {list of j for which vertex j is a candidate}
    {then () = if time_verbose
	      then prints("for LF0, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    then () = if #LF0 = 0
	      then return [[],[]]
	      fi
    then FixedList = [int]: for v in LF0
			    do let j = v[0]
			       in if j < #Perm2.fixed
				  then [j]
				  else break
				  fi
			    od.##
    then f = #FixedList, f0 = #Perm2.fixed
    then TranList = [int]: for v in LF0[f:] do v[0] od
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
		   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
	 Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
	 let startFF = elapsed_ms()
	 then EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
			{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
		    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
		       do for k in FixedList[i+1:f]
			  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
			     then [[j,k]]
			     else []
			     fi
			  od.## {list of edges starting with j}
		       od.##
	       {
	       elif f < BoundA1 {TEST A1}
		      {2*(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then for j in FixedList
		    do for w in FPP_edges_by_zero_unsorted(G)[Perm2.fixed[j]]
		       do if is_member_bitset(w[1],Glookup)
			  then [[j,locate_sorted(Perm2.fixed, w[1])]]
			  else []
			  fi
		       od.## {list of edges starting with j}
		    od.##

	       }
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
		    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
		       do for w@m in FPPEBZ[Perm2.fixed[j]]
			  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
			     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
			     else []
			     fi
			  od.##
		       od.##
	       fi {f < 2}
	   then () = FD12bzFFTime +:=elapsed_ms() - startFF
	   {then () = if time_verbose
		     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   then startFT = elapsed_ms()
	   then EdgesFixTrans = [vec]:
		if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
				do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
				od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   then () = FD12bzFTTime +:= elapsed_ms() - startFT
	   {then () = if time_verbose
		     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   then startTT = elapsed_ms()
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
		   in for k@m in TranList[:#TranList - 1] {k is the number of a midpoint local vertex}
			  {(i,j)@m in Perm2.trans}
		      do let (i,j) = Perm2.trans[k-f0]
			 then a = FEL([i,j]) {this is m + f0?}
			 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
			 in if {#Perm2.trans > m+1 and} #cands > 0
			    then for v in cands
				 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0
					  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT!");} [[k,n].sort]
				       else []
				       fi
				 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   then () = FD12bzTTTime +:= elapsed_ms() - startTT
	   {then () = if time_verbose
		     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
	    {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
     then length = #Edges
     then freq = max(length\10,1)
     then LF1 = [FaceVertsIndex]:
    	 for v@j in Edges
	 do if fund_face_verbose and red_count_flag and (j%freq).=
	    then prints("at edge ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start))
	    fi;
	    let nu = face_bary(Lvd,v)
	    then p = parameter(x,lambda,nu)
	    in {if Q(nu,nu) > DiracBD
	       then DTcount +:=1; []} {can't happen}
	       if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       elif red_count_flag
	       then [v#red_count(p,HT)]
	       else [v]
	       fi
	 od.##
    {then () = if time_verbose
	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    then answer = [LF0]##[LF1]
    then () = FD12bzTime +:= elapsed_ms() - start
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero, face counts are [",#LF0,
				  ",",#LF1,"]") fi;
       if sort_LFD_flag
       then sort(G, Lvd, answer)
       else answer
       fi
)


set localFD_1Dirac2_by_zero\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsIndex]]:
    localFD_1Dirac2_by_zero(x,lambda, next_heights(parameter(x,lambda,0*lambda),edge_offset+1)~[0], Lvd, Perm2)

set localFD_1Dirac2_by_zero(KGBElt x, ratvec lambda, int HT) = [[FaceVertsIndex]]:
    let theta = x.involution, ic = x.inner_class
    then lamthlam = ((1+theta)*lambda).numer
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic,theta,lamthlam)
    in localFD_1Dirac2_by_zero(x,lambda,HT, Lvd,Perm2)

set localFD_1Dirac2_by_zero(KGBElt x, ratvec lambda) = [[FaceVertsIndex]]:
    let theta = x.involution, ic = x.inner_class
    then lamthlam = ((1+theta)*lambda).numer
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic,theta,lamthlam)
    in localFD_1Dirac2_by_zero(x,lambda,Lvd,Perm2)

{add red_count while checking pos on LKTs, Dirac}
set localFD_1Dirac2_add_red(KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsIndex]] LF) =
    [[FaceVertsIndex]]:
    let G = x.real_form
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    in for d:#LF
       do for v in LF[d]
	  do let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     then qs = monomials(p)
	     in if Q(nu,nu) > DiracBD
		then DTcount +:=1; []
		elif not (fewer_reducible_unitary_flag or all(for q in qs
			    do @bool: is_pos_on_LKTs(q)
			    od))
		then []
		elif red_count_flag
		then [v#red_count(p,HT)] {HT = -1 means infinity}
		else [v]
		fi
	  od.##
       od

{If red_count_flag needed to height > next_heights[edge_offset], update here}
set localFD_1Dirac2_red_update\
  ( KGBElt x, ratvec lambda, int HT, LocalVertexData Lvd, [[FaceVertsIndex]] LF) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    if next_heights(parameter(x,lambda,0*lambda),edge_offset+1)~[0] >= HT
    then return LF
    fi;
    let G = x.real_form, start = elapsed_ms()
    in for LFd@d in LF
       do for v in LFd
	  do let w = v, p = parameter(x,lambda,face_bary(Lvd, v[:d+1]))
	     then () = w[d+1]:=red_count(p,HT)  {HT = -1 means infinity}
	     in w
	  od
       od
)

{No extra coordinates and no Dirac; meant for use in blob, so red_count and Dirac
are only done once for repeated parameters}
set localFD_by_zero_short\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then LF0 = [FaceVertsIndex]:
	 for j:#Lvd.list
	 do [j]
	 od
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    {then Llookup = is_member_sorted((for v in LF0 do v[0] od))}
    then Edges = [vec]:
	 let startFF = elapsed_ms()
	 then EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
	     then for j@m in Perm2.fixed[:#Perm2.fixed - 1]
		  do let cands = FPP_edges_by_zero_unsorted(G)[j] {list of edges beginning j}
		     in if {Llookup(m{mloc}) and} #cands > 0
			then for v in cands {global edges with v[0] = j}
			     do let n = locate_sorted(Perm2.fixed, v[1])
				in if n< #Perm2.fixed and Perm2.fixed[n] = v[1] {and Llookup(n)}
				   then [[m,n].sort]
				   else []
				   fi
			     od.## {this is the list of edges starting with m}
			 else []
			 fi {#cands > 0}
		   od.## {all FixFix edges}
	       else []
	       fi
	    then () = FD12bzFFTime +:=elapsed_ms() - startFF
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
	   then startFT = elapsed_ms()
	   then EdgesFixTrans = [vec]:
		if #Perm2.fixed > 0 and #Perm2.trans >0
		then for j@m in Perm2.fixed
		     do {let mloc = mapAct[j]} {this is m?}
			let cands = FPP_flippable_triangles_by_zero_unsorted(G)[j]
			in if {Llookup(m) and} #cands > 0
			   then for v in cands
				do let n = #Perm2.fixed + trans_hash.lookup(v[1:])
				   in if n >= #Perm2.fixed {and Llookup(n)}
				      then [[m,n]]
				      else []
				      fi
				od.## {[vec], all starting with m}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all m}
		  else []
		  fi
	   then () = FD12bzFTTime +:= elapsed_ms() - startFT
	   then startTT = elapsed_ms()
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #Perm2.trans > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
		   in for (i,j)@m in Perm2.trans
		      do let a = FEL([i,j]) {, mloc = mapAct[i]} {this is m+#Perm2.fixed?}
			 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
			 in if {Llookup(m+#Perm2.fixed) and} #Perm2.trans > m+1 and #cands > 0
			    then for v in cands
				 do let n = #Perm2.fixed + trans_hash.lookup(v[2:])
				    in if n >= #Perm2.fixed
				    {and Llookup(n) and Llookup(m+#Perm2.fixed)}
				       then [[m+#Perm2.fixed,n].sort]
				       else []
				       fi
				 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	    then () = FD12bzTTTime +:= elapsed_ms() - startTT
	    {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FaceVertsIndex]:
	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in  if fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od)
		then [v]
		else []
		fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = [LF0]##[LF1]
    then () = FD12bzTime +:= elapsed_ms() - start
    {then () = if elapsed_ms() - start > 10{FD12bzTime}
	      then prints("(fixed,trans) = (",#Perm2.fixed, ",",#Perm2.trans, "), face counts (",#LF0,",",Edges,") took ",print_time_string(elapsed_ms() - start))
	      fi}
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero_short, face counts are [",#LF0,
				  ",",#LF1,"]") fi;
       {if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
					  " for localFD_1Dirac2_by_zero") fi;}
       if sort_LFD_flag
       then sort(G, Lvd, answer)
       else answer
       fi
)


set localFD_1Dirac2_by_zero_old\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2, vec mapAct) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
	      then let bd = DiracBD(x,lambda)
		   then QG = {Dirac_easy_hash.invt_form(G)} invariant_form(G)
		   then index = first(for v in Lvd.list
				      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then LF0 = [FaceVertsIndex]:
	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if  Q(v,v) > DiracBD
	       then DTcount+:=1; []
	       elif not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       else [[j]]
	       fi
	 od.##{list of j for which vertex j is a candidate}
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
	 let EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
	     then for j in Perm2.fixed
		  do let mloc = mapAct[j]
		     in if Llookup(mloc)
			then for v in FPP_edges_by_zero(G)[j] {global edges with v[0] = j}
			     do if is_member_sorted(Perm2.fixed)(v[1])
				then let nloc =  mapAct[v[1]]
				     in if nloc > mloc and Llookup(nloc)
					then [[mloc,nloc]]
					else []
					fi
				else []
				fi
			     od.## {this is the list of edges starting with j}
			 else []
			 fi
		   od.## {all FixFix edges}
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesFixTrans = [vec]:
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
		    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
	   {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = [vec]:
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
		    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FaceVertsIndex]:
	 for v in Edges
	 do let nu = face_bary(Lvd, v)
	    then p = parameter(x,lambda,nu)
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in if Q(nu,nu) > DiracBD
	       then DTcount+:=1; []
	       elif not (fewer_reducible_unitary_flag or all(for q in monomials(p)
			    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       else [v]
	       fi
	  od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = [LF0]##[LF1]
    then () = FD12bzTime +:= elapsed_ms() - start
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero, face counts are [",#LF0,
				  ",",#LF1,"]") fi;
       {if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
					  " for localFD_1Dirac2_by_zero") fi;}
       if sort_LFD_flag
       then sort(G, Lvd, answer)
       else answer
       fi
)

{takes local data and low global faces and computes local vertices, imposing
hermitian, pos on LKTs. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
set localFD_1Steve\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_1Steve")
    fi;
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then length = #(Lvd.list)
    then freq = max(length\10,1)
    in for v@j in Lvd.list
       do if fund_face_verbose and (j%freq).=
	  then prints("at vertex ",j," of ",length,
	    	       " at time ", print_time_string(elapsed_ms() - start))
	  fi;
	  let p = parameter(x,lambda,v)
	  in if not (fewer_reducible_unitary_flag or all(for q in monomials(finalize(p))
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	     then []
	     else [[j]]
	     fi
	od.## {list of j for which vertex j is a candidate}
)

{takes local data and low global faces and local vertices and computes local edges, imposing
hermitian, pos on LKTs.}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_2Steve\
( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2, [FaceVertsIndex] LF0) =
    [FaceVertsIndex]:
(   if fund_face_verbose
    then prints(new_line,"start localFD_2Steve")
    fi;
    let G = x.real_form, {start = elapsed_ms(),} trans_hash = make_vec_hash()
    {then () = if time_verbose
    	      then prints("for LF0, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    then () = if #LF0 = 0
    	      then return []
	      fi
    then FixedList = [int]: for v in LF0
    	 	     	    do let j = v[0]
			       in if j < #Perm2.fixed
			       	  then [j]
				  else break
				  fi
			    od.##
    then f = #FixedList, f0 = #Perm2.fixed
    then TranList = [int]: for v in LF0[f:] do v[0] od
    then Llookup = is_member_sorted(FixedList##TranList)
    then Glookup = {is_member_sorted(for j in FixedList do Perm2.fixed[j] od)}
    	 	   to_bitset(for j in FixedList do Perm2.fixed[j] od)
    then {E = sum(for list in FPP_edges_by_zero_unsorted(G) do #list od),}
         Fverts = FPP_vertices(G)
    then F = #Fverts
    then Edges = [vec]:
    	 {let startFF = elapsed_ms()}
    	 let EdgesFixFix = [vec]:
	       if f < 2 then []
	       elif f < BoundB  {TEST B}
	       	      	{(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then let lookups = FPP_edges_by_zero_indices(G)
	       	    in for j@i in FixedList[:f-1] {f * (E/F)/2 tests}
	      	       do for k in FixedList[i+1:f]
		       	  do if lookups[Perm2.fixed[j]]([Perm2.fixed[j],Perm2.fixed[k]]).>=
		       	     then [[j,k]]
		       	     else []
		       	     fi
		       	  od.## {list of edges starting with j}
	       	       od.##
	       {
	       elif f < BoundA1 {TEST A1}
	       	      {2*(E*set_bit_positions(E)~[0]*set_bit_positions(f)~[0])\F}
	       then for j in FixedList
    	       	    do for w in FPP_edges_by_zero_unsorted(G)[Perm2.fixed[j]]
		       do if is_member_bitset(w[1],Glookup)
		          then [[j,locate_sorted(Perm2.fixed, w[1])]]
		       	  else []
		       	  fi
		       od.## {list of edges starting with j}
	       	    od.##

	       }
	       else let FPPEBZ = FPP_edges_by_zero_unsorted(G)
	       	    in for j in FixedList[:f-1] {TEST C} {seems always a little faster than A1?}
		    {in E7 spherical, C is seven times faster than B}
		    {SO OMIT A1}
	       	       do for w@m in FPPEBZ[Perm2.fixed[j]]
    	       	       	  do if is_member_bitset(w[1],Glookup) {Glookup(w[0]) and Glookup(w[1])}
		       	     then [[j, Lvd.lookup(Fverts[w[1]])]] {SEEMS FASTER THAN A1}
		       	     else []
		       	     fi
		    	  od.##
		       od.##
	       fi {f < 2}
	   {then () = FD12bzFFTime +:=elapsed_ms() - startFF}
	   {then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi}
	   {then startFT = elapsed_ms()}
      	   then EdgesFixTrans = [vec]:
	   	if #FixedList > 0 and #TranList > 0
		then for j in FixedList
		     do let cands = FPP_flippable_triangles_by_zero_unsorted(G)[Perm2.fixed[j]]
			in if #cands > 0
			   then for v in cands
			      	do let k = f0 + trans_hash.lookup(v[1:])
				   in if k >= f0 and Llookup(k) {and Llookup(j)}
				      then [[j,k]]
				      else []
				      fi
			       	od.## {[vec], all starting with j}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all j}
		  else []
		  fi
	   {then () = FD12bzFTTime +:= elapsed_ms() - startFT}
	   {then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi}
	   {then startTT = elapsed_ms()}
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #TranList > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for k@m in TranList[:#TranList - 1] {k is the number of a midpoint local vertex}
		      	  {(i,j)@m in Perm2.trans}
	      	      do let (i,j) = Perm2.trans[k-f0]
		      	 then a = FEL([i,j]) {this is m + f0?}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {#Perm2.trans > m+1 and} #cands > 0
		      	    then for v in cands
			      	 do let n = f0 + trans_hash.lookup(v[2:])
				    in if n >= f0
				       	  and Llookup(n) {and Llookup(m+f)}
				       then {prints("used TT!");} [[k,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   {then () = FD12bzTTTime +:= elapsed_ms() - startTT}
	   {then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi}
     	    {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     {then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi}
     then length = #Edges
     then freq = max(length\10,1)
     then LF1 = [FaceVertsIndex]:
    	 for v@j in Edges
	 do if fund_face_verbose and red_count_flag and (j%freq).=
	    then prints("at edge ",j," of ",length{,
	    	       " at time ", print_time_string(elapsed_ms() - start)})
	    fi;
	    let nu = face_bary(Lvd,v)
	    then p = parameter(x,lambda,nu)
	    in {if Q(nu,nu) > DiracBD
	       then DTcount +:=1; []} {can't happen}
	       if not (fewer_reducible_unitary_flag or all(for q in monomials(p)
	       	      	    do @bool: is_pos_on_LKTs(q)
			    od))
	       then []
	       else [v]
	       fi
	 od.##
    {then () = if time_verbose
    	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi}
    {then () = FD12bzTime +:= elapsed_ms() - start}
    in if(face_verbose) then prints("After localFD_2Steve, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if sort_LFD_flag
       then sort(G, Lvd, [LF1])[0]
       else LF1
       fi
)

{set left_good = int:0, left_bad = int:0, right_good = int:0, right_bad = int:0, LR_no_info = int:0}
{takes 0 and 1-diml local faces and adds K-char index}
{having K-char, take opportunity to apply Dirac ineq deeper }
{No height bound here; need red_count to infinity}
set localFD_KHash_01 (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), ht = height(parameter(x,lambda,0*lambda)), startDBTcount = DBTcount
    {then HT = next_heights(parameter(x,lambda,0*lambda),edge_offset+1)~[0]}
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not Dirac_best_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = {Dirac_easy_hash.invt_form(x.real_form)} invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
				do bs~[0]
				od)
	     then index = first(for v in Lvd.list
				do @bool: QG(v,v) > bestbd
				od)
	     in if index.>=
		then DiracBestBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    then answer0 = for v@k in LF[0]
		   ~do if k%(max(#LF[0]\10,2))=0 and fund_face_verbose
		      then prints("calculating K-character on vertex ",k,
		      " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		      fi;
		      let gamma = Lvd.list[v[0]]
		      then p0 = parameter(x, lambda, gamma)
		      then P = finalize(p0)
		      then KCF = K_type_pol(character_formula(P))
		      then m = ktp_hash.match(KCF)
		      in if (not temp_Dirac_best_flag) or (Q(gamma,gamma) <= DiracBestBD)
			    or DiracBestTest(p0,KCF)
			 then [v##[m,#monomials(P)]]
			 else []
			 fi
		   od.##
    then lookup0D = index_in(for v in answer0
			     do v[:1]
			     od)
    then answer1 = for v@k in LF[1] {if red_count_flag, has red_count as coor#2}
		   ~do if k%(max(#LF[1]\10,2))=0 and fund_face_verbose
		      then prints("calculating K-character on edge ",k,
			    " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		      fi;
		      let i = lookup0D([v[0]]), j = lookup0D([v[1]])
		      in if i < 0 or j < 0 {one edge endpoint has been removed already}
			 then []
			 else let nu = face_bary(Lvd,v[:2])
			      then p0 = parameter(x, lambda, nu)
			      then P = finalize(p0)
			      in if red_count_flag
				 then if answer0[i][1] = v[2] {Kchars match}
				      then [v##[answer0[i][2],#monomials(P)]]
				      elif answer0[j][1] = v[2]
				      then [v##[answer0[j][2], #monomials(P)]]
				      else let m = ktp_hash.match(K_type_pol(character_formula(P)))
				      in [v##[m,#monomials(P)]]
				      fi {answer = v[2]}
				 else let m = ktp_hash.match(K_type_pol(character_formula(P)))
				      in [v##[m, #monomials(P)]]
				 fi{red_count_flag}
			 fi{i<0}
		     od.##
    then time = elapsed_ms() - start
    then () = if time_verbose then prints(" ", print_time_string(time),
			     " for localFD_KHash_01 (vertex/edge K-chars)");
			     prints(" face counts to dim 1: [",#answer0,",",#answer1,
			     "]; Dirac_best eliminated ", DBTcount - startDBTcount)
			     fi
    in if sort_LFD_flag
       then sort(x.real_form, Lvd, [answer0,answer1])
       else [answer0,answer1]
       fi

set to_htB_flag = false

{takes 0 and 1-diml local faces and adds K-char index to height HT}
set localFD_KHash_01 (KGBElt x, ratvec lambda, LocalVertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), p0 = parameter(x,lambda,0*lambda), startDBTcount = DBTcount
    then ht = height(p0), HT0= next_heights(p0,edge_offset+1)~[0]
    then () = if HT > HT0 and red_count_flag
	      then LF := localFD_1Dirac2_red_update(x, lambda, HT, Lvd, LF)
	      fi
    then Q = (ratvec,ratvec ->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not Dirac_best_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do truncate(best_Dirac_bound(mu),HT) od
	      then bestbd = min(for (,hs,bs) in best_bounds
				do bs~[0]
				od)
	     {then () = prints("best_bounds = ",best_bounds)}
	     then index = first(for v in Lvd.list
				do @bool: QG(v,v) > bestbd
				od)
	     in if index.>=
		then DiracBestBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    {then () = prints("starting LF0 = ",LF[0]); prints("starting LF1 = ",LF[1])}
    {then () = if to_htB_flag then LF[0] :=~LF[0] fi}
    then answer0 = for v@k in LF[0]
		   ~do if k%(max(#LF[0]\10,2))=0 and fund_face_verbose {E7_s sph: 3 times slower without tilde}
		      then prints("calculating K-character on vertex ",k,
		      " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		      fi;
		      let gamma = Lvd.list[v[0]]
		      then p0 = parameter(x, lambda, gamma)
		      then P = finalize(p0)
		      then KCF = K_type_pol(if to_htB_flag
					    then composition_series_to_heightB(P,HT)
					    else character_formula_to_height(P,HT)
					    fi)
		      then m = ktp_hash.match(KCF)
		      in if (not temp_Dirac_best_flag) or (Q(gamma,gamma) <= DiracBestBD)
			    or DiracBestTest(p0,HT)
			 then {prints("gain param at p0 = ",p0, ", vert = ",v[0]," tests = ",
			      not temp_Dirac_best_flag," ", (Q(gamma,gamma) <= DiracBestBD)," ",
			      DiracBestTest(p0,HT,KCF));}
			      [v##[m,#monomials(P)]]
			 else  {prints("lose param at p0 = ",p0, ", vert = ",v[0], " tests = ",
			       not temp_Dirac_best_flag," ", (Q(gamma,gamma) <= DiracBestBD)," ",
			       DiracBestTest(p0,HT));}
					    []
			 fi
		   od.##
    {then () = prints("answer0 = ",answer0)}
    {then candps = for v in answer0 do parameter(x,lambda,Lvd.list[v[0]]) od}
    {then () = prints("down to ",count(for p in candps do is_unitary(Finalize(p)) od)," unitary verts")}
    then lookup0D = index_in(for v in answer0
			     do v[:1]
			     od)
     {then () = if to_htB_flag then LF[1] :=~LF[1] fi}
    then answer1 = for v@k in LF[1]
		  ~do if k%(max(#LF[1]\10,2))=0 and fund_face_verbose {E7_s spherical: 20% slower without tilde}
		      then prints("calculating K-character on edge ",k,
			   " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		      fi;
		      let i = lookup0D([v[0]]), j = lookup0D([v[1]])
		      in if i < 0 or j < 0 {one edge endpoint has been removed already}
			 then []
			 else let nu = face_bary(Lvd,v[:2])
			      then p0 = parameter(x, lambda, nu)
			      then P = finalize(p0)
			      in if red_count_flag
				 then if answer0[i][1] = v[2] {red_counts match}
				      then [v##[answer0[i][2],#monomials(P)]]
				      elif answer0[j][1] = v[2] {red_counts match}
				      then [v##[answer0[j][2], #monomials(P)]]
				      else let m = ktp_hash.match(K_type_pol(
					       if to_htB_flag
					       then composition_series_to_heightB(P,HT)
					       else character_formula_to_height(P,HT)
					       fi))
					    in [v##[m, #monomials(P)]]
				      fi {answer = v[2]}
				 else let m = ktp_hash.match(K_type_pol(
					  if to_htB_flag
					  then composition_series_to_heightB(P,HT)
					  else character_formula_to_height(P,HT)
					  fi))
				      in {prints("gain param at p0 = ",p0, ", verts = ", v[:2], " tests = ",
						      not temp_Dirac_best_flag," ",
						      (Q(nu,nu) <= DiracBestBD)," ",
						      DiracBestTest(p0,HT))
					   ;} [v##[m, #monomials(P)]]
				 fi{red_count_flag}
			 fi{i<0}
		     od.##
    then time = elapsed_ms() - start
    then () = if time_verbose then prints(" ", print_time_string(time),
			     " for localFD_KHash_01 to ht = ",HT," (vertex/edge K-chars)");
			     prints(" face counts to dim 1: [",#answer0,",",#answer1,
			     "]; Dirac_best eliminated ", DBTcount - startDBTcount)
			     fi
    in if sort_LFD_flag
       then sort(x.real_form, Lvd, [answer0,answer1])
       else [answer0,answer1]
       fi

{same as above, using graph of K-relations}
{takes 0 and 1-diml local faces and adds K-char index}
{only called when red_count_flag = true. In element of LF[d], first d+1 coords are vertices;
next and last is red_count. Adjoin two more: K-char, and #Langlands quotients}
set localFD_KHash_01_graph (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), startDBTcount = DBTcount
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not Dirac_best_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = {Dirac_easy_hash.invt_form(x.real_form)} invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
				do bs~[0]
				od)
	     then index = first(for v in Lvd.list
				do @bool: QG(v,v) > bestbd
				od)
	     in if index.>=
		then DiracBestBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    then NumClasses = #eq
    then () = if test_verbose
	      then prints("     Examining ",NumClasses," classes in localFD_hash_01_graph.")
	      fi
    then polNums = [int]: {one for each class}
	 for C in eq
	 ~do let (d,j) = coords(LF,C~[0]) {the tilde chooses a
	 representative on largest possible face, so least integral}
	    then verts = vec: LF[d][j][:d+1]
	    then gamma = face_bary(Lvd,verts)
	    then pC = parameter(x,lambda,gamma)
	    then PC = finalize(pC)
	    then KCF = K_type_pol(character_formula(PC))
	    in if (not temp_Dirac_best_flag) or (Q(gamma,gamma) <= DiracBestBD)
		  or DiracBestTest(pC,KCF)
	       then ktp_hash.match(KCF)
	       else -1
	       fi
	 od
    then () = polNums := ~polNums {since they were computed in reverse order}
    then nLKT = #LKTs(parameter(x,lambda,0*lambda))
    then answer = for LFd@d in LF
		  do for v@j in LFd
		     do let N = polNums[classListByFace[d][j]]
			then m = if nLKT = 1 or N.<
				 then 1
				 else #monomials(finalize(parameter(x,lambda,face_bary(Lvd,v[:d+1]))))
				 fi
			in if N.>=
			   then [v##[N,m]]
			   else []
			   fi
		     od.##
		  od
    then time = elapsed_ms() - start
    then () = if time_verbose then prints(" ", print_time_string(time),
			     " for localFD_KHash_01_graph (vertex/edge K-chars)");
			     prints(" face counts to dim 1: [",#answer[0],",",#answer[1],
			     "]; Dirac_best eliminated ", DBTcount - startDBTcount)
			     fi
    {then () = if time_verbose then prints("     ", print_time_string(time),
			     " for localFD_KHash_01_graph (vertex/edge K-chars)") fi}
    in answer

{same as above, using graph of K-relations}
{takes 0 and 1-diml local faces and adds K-char index}
{only called when red_count_flag = true. In element of LF[d], first d+1 coords are vertices;
next and last is red_count. Adjoin two more: K-char, and #Langlands quotients}
set localFD_KHash_01_graph (KGBElt x, ratvec lambda, LocalVertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), startDBTcount = DBTcount
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
	 if not Dirac_best_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then QG = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do truncate(best_Dirac_bound(mu),HT) od
	      then bestbd = min(for (,hs,bs) in best_bounds
				do bs~[0]
				od)
	     {then () = prints("bestbd = ",bestbd,", QG(rho) = ",QG(x.real_form.rho,x.real_form.rho))}
	     then index = first(for v in Lvd.list
				do @bool: QG(v,v) > bestbd
				od)
	     in if index.>=
		then DiracBestBD := bestbd; Q:=QG; true
		else false
		fi
	 fi
    then NumClasses = #eq
    then () = if test_verbose
	      then prints("     Examining ",NumClasses," classes in localFD_hash_01_graph to ht ",HT)
	      fi
    then () = for C@k in eq
     	      do if #C > 1
	      	 then let (d0,j0) = coords(LF, C[0])
	    	      then r0 = LF[d0][j0][d0+1]
		      in for m in C[1:]
		      	 do let (d,j) = coords(LF,m)
			    in assert(@:r0 = LF[d][j][d+1],"problem with red_count graph")
			 od
		  fi
	       od
    then polNums = [int]:
	 for C@k in eq
	 ~do if k%(max(#eq\10,2))=0 and fund_face_verbose
	    then prints("calculating K-character on class ",k,
		 " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
	    fi;
	    let (d,j) = coords(LF,C~[0]) {the tilde chooses a
		representative on largest possible face, so least integral}
	    then verts = vec: LF[d][j][:d+1]
	    then gamma = face_bary(Lvd,verts)
	    then pC = parameter(x,lambda,gamma)
	    then PC = finalize(pC)
	    then KCF = if to_htB_flag
		       then K_type_pol(composition_series_to_heightB(PC,HT))
		       else K_type_pol(character_formula_to_height(PC,HT))
		       fi
	    in if (not temp_Dirac_best_flag) or (Q(gamma,gamma) <= DiracBestBD)
		  or DiracBestTest(pC,HT)
	       then ktp_hash.match(KCF)
	       else -1
	       fi
	 od
    then () =  polNums := ~polNums {because they were calculated in reverse order}
    then nLKT = #LKTs(parameter(x,lambda,0*lambda))
    then answer0 = for v@j in LF[0]
		   do let N = polNums[classListByFace[0][j]]
		      then m = if nLKT = 1 or N.<
			       then 1
			       else #monomials(finalize(parameter(x,lambda,Lvd.list[v[0]])))
			       fi
		      in if N.>=
			 then [v##[N,m]]
			 else []
			 fi
		    od.##
    then lookup0D = index_in(for v in answer0
			     do v[:1]
			     od)
    then answer1 = for v@k in LF[1]
		   do let i = lookup0D([v[0]]), j = lookup0D([v[1]])
		      in if i < 0 or j < 0 {one edge endpoint has been removed already}
			 then []
			 else let N = polNums[classListByFace[1][k]]
				then m = if nLKT = 1 or N.<
					 then 1
					 else #monomials(finalize(parameter(x,lambda,face_bary(Lvd,v[:2]))))
					 fi
				in if N.>=
				   then [v##[N,m]]
				   else []
				   fi
			   fi
		     od.##
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
			     " for localFD_KHash_01_graph (vertex/edge K-chars)");
		   prints(" face counts to dim 1: [",#answer0,",",#answer1,
			     "]; Dirac_best eliminated ", DBTcount - startDBTcount)
	       fi
    in if sort_LFD_flag
       then sort(x.real_form,Lvd,[answer0,answer1])
       else [answer0,answer1]
       fi

{don't compute K_chars, just use red_count}
set localFD_KHash_01_graph_dry (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    assert(@:red_count_flag,"localFD_KHash_01_graph_dry requires red_count_flag :=true");
    let start = elapsed_ms(), startDBTcount = DBTcount
    then NumClasses = #eq
    then () = if test_verbose
	      then prints("     Examining ",NumClasses," classes in localFD_hash_01_graph_dry")
	      fi
    then mu = LKT(x.real_form.trivial)
    then nLKT = #LKTs(parameter(x,lambda,0*lambda))
    then answer = for LFd@d in LF
		  do for v@j in LFd
		     do let KCF = v[d+1]*mu
			then N = ktp_hash.match(KCF)
			then m = if nLKT = 1
				 then 1
				 else #monomials(finalize(parameter(x,lambda,face_bary(Lvd,v[:d+1]))))
				 fi
			in v##[N,m]
		     od
		  od
    then time = elapsed_ms() - start
    then () = if time_verbose then prints("     ", print_time_string(time),
			     " for localFD_KHash_01_graph_dry (vertex/edge K-chars)") fi
    in answer

{takes list of 0- and d-diml faces, with d \ge 1, and builds all
d+1-diml faces having all faces in the d-diml list. The int e is the
number of extra coords in each face.}
set superFaces([vec] L0, [vec] Ld, int e) =
    [vec]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [vec]:
   for v in L0
   do let m0 = v[0] {first vertex in new face}
      in [vec]:
	 for small in Ld
	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    elif any(for k:d+1 do lookupsd( m0#(small[:k]##small[k+1:d+1])) = -1 od)
	    then [] {require all d-faces to be in Ld}
	    else [m0#small[:d+1]] {now m0##small is a candidate face}
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFaces was ",
			print_time_string(elapsed_ms() - start))
	  fi}
in answer
fi

{record also the locations in Ld of the d+2 faces in Ld from which each d+1 superface arises}
{e is the number of non-vertex coords in the vec's}
set superFaces_plus([vec] L0, [vec] Ld, int e) =
    [(vec,vec)]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()} {dimension of the faces to be extended}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [(vec,vec)]:
   for v in L0
   do let m0 = v[0] {first vertex in new face}
      in [(vec,vec)]:
	 for small@look0 in Ld
	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    else let look = vec:
		     for k:d+1
		     do lookupsd(m0#(small[:k]##small[k+1:d+1]))
		     od
		 in if look.>=
		    then [(m0#small[:d+1], look0#look)] {now m0##small is a candidate face}
		    else []
		    fi
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFaces was ",
			print_time_string(elapsed_ms() - start))
	  fi}
in answer
fi

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
(   {if face_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;}
    if #LFKH = 0 or #LFKH[0] = 0 then return [] fi;
    let G = x.real_form, start=elapsed_ms()
    then e = if red_count_flag {red_shift+2}
	     then 3
	     else 2
	     fi
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2; dim is the new bigger dim}
	      do let lookup = if red_count_flag
			      then index_in(for v in LFKH[dim-1] do v[:dim] od)
			      else index_in([vec]:[])
			      fi
		 in LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],e)
				   in [vec]:
				      for (actual,locs) in acts {vec of size dim+1, coords of subs}
				      do let p0 = parameter(x,lambda, face_bary(Lvd, actual))
					 then P = finalize(p0)
					 then midreds = vec: if red_count_flag
							then [red_count(p0)]
							else []
							fi
					 then subs = if red_count_flag
						     then for k:dim
							  do delete(actual,k) {vec of size dim}
							  od
						     else []
						     fi
					 then k = if red_count_flag
						  then first(for i in locs
							do [LFKH[dim-1][i][dim]] = midreds
							od)
						  else -1
						  fi
					 then ms = monomials(P)
					 in if fewer_reducible_unitary_flag or all(for q in ms
									    do @bool: is_pos_on_LKTs(q)
									    od)
					    then if k.>= {so red_count_flag is true}
						 then {prints(p0, ktp_hash.list()[LFKH[dim-1][locs[k]][dim]]);}
						      [actual##midreds##[LFKH[dim-1][locs[k]][dim+1], #ms]]
						 else {let startCF = elapsed_ms()}
						      let m = {char_counter.use();} ktp_hash.match(
							   K_type_pol(character_formula(P)))
						      {then () = charTime +:= elapsed_ms() - startCF}
						      in [actual##midreds##[m, #ms]]
						 fi {K-char matches a face}
					     else []
					     fi {pos on LKTs}
				   od.## {[FaceVertsKHash]})
	 od
    then () = LFKH := if sort_LFD_flag
		      then sort(G, Lvd, LFKH)
		      else LFKH
		      fi
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
				" for localFD_Khashbt to dim ",t-1,
				"; face counts = ", for list in LFKH do #list od) fi
    in if sort_LFD_flag
       then sort(G,Lvd,LFKH)
       else LFKH
       fi

)

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t). This time
just calculate K characters to HT. ASSUME red_counts are at least to HT.

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t, int HT, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
(   if #LFKH = 0 or #LFKH[0] = 0 then return [] fi;
    if face_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;
    let G = x.real_form, start=elapsed_ms()
    then e = if red_count_flag {number of LFKH coords after vertices}
	     then 3
	     else 2
	     fi
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
	      do let lookup = if red_count_flag
			      then index_in(for v in LFKH[dim-1] do v[:dim] od)
			      else index_in([vec]:[])
			      fi
	      in LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],e)
				in [vec]:
				   for (actual,locs) in acts
				   do let p0 = parameter(x,lambda, face_bary(Lvd, actual))
				      then P = finalize(p0)
				      then midreds = vec: if red_count_flag
						     then [red_count(p0,HT)]
						     else []
						     fi
				      then subs = if red_count_flag
						  then for k:dim+1
						       do delete(actual, k) {vec of size dim}
						       od
						  else []
						  fi
				      then k = if red_count_flag
						  then first(for i in locs
							do [LFKH[dim-1][i][dim]] = midreds
							od)
						  else -1
						  fi
				      then ms = monomials(P)
				      in if fewer_reducible_unitary_flag or all(for q in ms
									 do @bool: is_pos_on_LKTs(q)
									 od)
					 then if k.>= {so red_count_flag is true}
					      then [actual##midreds##[ LFKH[dim-1][locs[k]][dim+1], #ms]]
					      else let m = ktp_hash.match(
						       if to_htB_flag
						       then K_type_pol(composition_series_to_heightB(P,HT))
						       else K_type_pol(character_formula_to_height(P,HT))
						       fi)
						   in [actual##midreds##[m, #ms]]
					       fi {K-char matches a face}
					  else []
					  fi {pos on LKTs}
				   od.## {[FaceVertsKHash]})
	 od
    {then () = LFKH := sort(G, Lvd, LFKH)}
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	       " for localFD_Khashbt to height ", HT, " and dim ",t-1,
	       "; face counts = ", for list in LFKH do #list od) fi
    in if sort_LFD_flag
       then sort(G,Lvd,LFKH)
       else LFKH
       fi
)

set extend_character_verbose = false

set extend_K_characters(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
    if fund_face_verbose
    then prints(new_line,"start extend_K_characters for ", [int]: for list in LFKH do #list od, " faces")
    fi;
    let G = x.real_form, start = elapsed_ms(), red_shift = if red_count_flag then 1 else 0 fi
    then answer =
       for d:#LFKH
       do [vec]: if extend_character_verbose then prints(new_line, "start to extend ",#LFKH[d],
			     " K-characters in dimension ",d,
			     " in extend_K_characters")
	  fi; for v@k in LFKH[d]
	      ~do if k%(max(#LFKH[d]\10,2))=0 and extend_character_verbose {try tilde}
		 then prints("calculating K-character on face ",k,
		      " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		 fi;
		 let nu = face_bary(Lvd, v[:d+1]), w=v
		 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
		 then p0 = parameter(x, lambda, nu)
		 then P = finalize(p0)
		 {then startCF = elapsed_ms()}
		 then m = ktp_hash.match(K_type_pol(character_formula(P)))
		 {then () = charTime +:= elapsed_ms() - startCF}
		 then () = w[d+red_shift+1] := m
		 then () = if red_count_flag
			   then w[d+1]:= red_count(p0)
			   fi
		 in w
	      od
      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
		  " for extend_K_characters") fi
     in answer {sort(G,Lvd,answer)}

set extend_K_characters(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, int HT, KTypePol_hash ktp_hash) =
	[[FaceVertsKHash]]:
    if fund_face_verbose
    then prints(new_line,"start extend_K_characters to height ",HT, " for ",
	 [int]: for list in LFKH do #list od, " faces")
    fi;
    let G = x.real_form, start = elapsed_ms(), red_shift = if red_count_flag then 1 else 0 fi
    then answer =
       for d:#LFKH
	do [vec]: if extend_character_verbose then prints(new_line, "start to extend ",#LFKH[d], {try tilde}
			     " K-characters in dimension ",d, " to height ",HT)
	  fi;   for v@k in LFKH[d]
		do if k%(max(#LFKH[d]\10,2))=0 and extend_character_verbose {try tilde}
		 then prints("calculating K-character on face ",k,
		      " in time ",print_time_string(elapsed_ms() - start),"; #ktp_hash = ",ktp_hash.size())
		 fi;
		 let nu = face_bary(Lvd, v[:d+1]), w=v
		 then p0 = parameter(x, lambda, nu)
		 then P = finalize(p0)
		 then m = ktp_hash.match(if to_htB_flag
					 then K_type_pol(composition_series_to_heightB(P,HT))
					 else K_type_pol(character_formula_to_height(P,HT))
					 fi)
		 then () = w[d+red_shift+1] := m
		 then () = if red_count_flag
			   then w[d+1]:= red_count(p0,HT)
			   fi
		 in w
	      od
       od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
		  " for extend_K_characters to ht ", HT) fi
     in answer

set extend_K_characters_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, KTypePol_hash ktp_hash, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    if fund_face_verbose
    then prints(new_line,"start extend_K_characters_graph for ", [int]:
	 for list in LFKH do #list od, " faces")
    fi;
    let G = x.real_form, start = elapsed_ms(), NumClasses = #eq
    then polNums = [int]: {these are indices in ktp_hash of new K-characters}
       for C in eq
       do let (d,j) = coords(LFKH,C~[0]) {the tilde chooses a
	  representative on largest possible face, so least integral}
	  then verts = vec: LFKH[d][j][:d+1]
	  then pC = parameter(x,lambda,face_bary(Lvd,verts))
	  then PC = finalize(pC)
	  {then startCF = elapsed_ms()}
	  then m = {char_counter.use();} ktp_hash.match(K_type_pol(character_formula(PC)))
	  {then () = charTime +:= elapsed_ms() - startCF}
	  in m
       od {C in eq}
     then answer = for LFd@d in LFKH
		   do [vec]: for j:#LFd
		      do let v = LFd[j]
			 then () = v[d+2] := polNums[classListByFace[d][j]]
			 in v
		      od {fix d-diml faces}
		   od {fix all faces}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
		  " for extend_K_characters_graph") fi
     in sort(x.real_form, Lvd, answer)

set extend_K_characters_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, int HT, KTypePol_hash ktp_hash, [[int]] eq, [vec] classListByFace) =
	[[FaceVertsKHash]]:
    if fund_face_verbose
    then prints(new_line,"start extend_K_characters_graph to height ",HT, " for ",
    [int]: for list in LFKH do #list od, " faces")
    fi;
    let G = x.real_form, start = elapsed_ms(), NumClasses = #eq
    then polNums = [int]: {these are indices in ktp_hash of new K-characters}
       for C in eq
       do let (d,j) = coords(LFKH,C~[0]) {the tilde chooses a
	  representative on largest possible face, so least integral}
	  then verts = vec: LFKH[d][j][:d+1]
	  then pC = parameter(x,lambda,face_bary(Lvd,verts))
	  then PC = finalize(pC)
	  then m = ktp_hash.match(if to_htB_flag
				  then K_type_pol(composition_series_to_heightB(PC,HT))
				  else K_type_pol(character_formula_to_height(PC,HT))
				  fi)
	  in m
       od {C in eq}
     then answer = for LFd@d in LFKH
		   do [vec]: for j:#LFd
		      do let v = LFd[j]
			 then () = v[d+2] := polNums[classListByFace[d][j]]
			 in v
		      od {fix d-diml faces}
		   od {fix all faces}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
		  " for extend_K_characters_graph") fi
     in answer
