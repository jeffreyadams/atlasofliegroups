{this file concerns (local) facets of parameters, in preparation of analysis of their unitarity.}
<FPP_faces_geom.at
<goodroots.at { for is_pos_on_LKTs }
<Dirac.at
<hermitian.at
<K_highest_weights.at {for all_lambda_differential_0}
<unity.at {for deform_hts}
<red_count.at {for red_count@Param}
<face_classes.at {for coords}
<cohom_reductionND.at {for glue_sigs}
{BREAK HERE?}

{collection of lookup functions for faces of various dimensions}
set lookups([[vec]] LFD) = [(vec->int)]:
    for L@d in LFD do index_in(for v in L do v[:d+1] od) od

{assume LFDKH has tail coords referring to K-char}
set sort(RealForm G, LocalVertexData Lvd, [[FaceVertsKHash]] LFDKH, int tail) = [[FaceVertsKHash]]:
    if sort_LFD_flag
    then let tworhocheck = G.two_rho_check
    	 then f(vec v) = int:
    	      let (num,den) = %(sum(for j in v[:#v - tail] do Lvd.list[j]*tworhocheck od)*1000)
	      in num\den
    	 in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
    else LFDKH
    fi

{If NU (nu part) > LAM (lambda part) *low_frac, then figure to_ht could work better}
set low_frac = 1/1

{START LAMBDA TABLES}

{version of solve from basic using precomputed echelon form, to speed repeated calcs}
set solve(vec b, mat M, mat C, [int] s) = maybe_a_vec:
(    let (n,k)=shape(M)
     then j=0 { runs up to k, used to index backwards }, sol=null(k)
     in assert(#b=n,"equation mismatch");
     	for i:n
       ~do if j<#s and i=s~[j] { then it is a pivot row, with pivot at M[j][i] }
       	   then let Mj=M~[j]
	   	then (q,r)=b[i]\%Mj[i]
		in if !=r then return ().no_vec { because inexact division} fi;
       		   sol~[j]:=q;
		   b-:=Mj*q; { correct for contribution from sol[j~] }
       		   j+:=1
       	    elif !=b[i] then return ().no_vec { because no pivot available }
       	    fi
   	 od;
	 (C[:k]*sol).solution
)

{these are the possible lambda+theta*lambda for x.involution = theta. First
vec_hash will be filled with candidate lamthlam (for which a lambda in X* + rho exists).
For each lamthlam there is a Perm2 in the second list.}
set cands_hash(InnerClass ic, mat theta, vec_hash lamthlam_hash) = [PermOrderTwo]:
    let th1 = 1+theta, verts = FPP_vertices(ic), FEs = FPP_flippable_edges(ic),
    	Perm2s = [PermOrderTwo]: [], empty = [(int,int)]: []
    then shift = (-th1*ic.rho).numer
    then () = for v@j in verts
       	      do let w = th1*v
       	      	 in if w.denom = 1 and any(vec_solve(th1, w.numer + shift))
	       	    then let M = lamthlam_hash.size()
	       	    then m = lamthlam_hash.match(w.numer)
	       	    in if m = M
	     	       then let () = Perm2s #:= (vec: [j],empty)
		       	    in ()
		       else let Perm2sm = Perm2s[m]
			    then () = Perm2sm.fixed #:= j
			    then () = Perm2s[m] := Perm2sm
			    in ()
		       fi
	            fi
               od
    then () = for pair in FEs
    	      do  let a = verts[pair[0]], b = verts[pair[1]]
	      	  then w = a+theta*b
	      	  in if theta*w = w and w.denom = 1
		     and any(vec_solve(th1, w.numer + shift))
		     then let M = lamthlam_hash.size()
	             then m = lamthlam_hash.match(w.numer)
	             in if m = M
		     	then let () = Perm2s #:= (null(0),[(pair[0],pair[1])])
			     in ()
			else let Perm2sm = Perm2s[m]
			     then () = Perm2sm.trans #:= (pair[0],pair[1])
			     then () = Perm2s[m] := Perm2sm
			     in ()
			fi
		     fi
	       od
     in Perm2s

set Lnu(Param p) = RealForm:
    let p1 = to_no_Cplus(p), G=p.real_form
    then rhoi1 = rho_i(p1.x)
    then rdnu = centralizer(G,[rhoi1.numer])
    in quasisplit_form(inner_class(rdnu, p1.x.involution))


set Wnu(Param p) = [WeylElt]:
    let Lnu = Lnu(p), p1 = to_no_Cplus(p), rho = p.real_form.rho
    then theta1 = p1.x.involution
    in for w1 in Weyl_orbit_ws(Lnu,(p1.infinitesimal_character).numer)
       do if w1*theta1 = theta1*w1 and parameter(p1.x, w1*(p1.lambda - rho)+rho, 0*rho) = p1*0
       	  then [w1]
	  else [] fi
       od.##

set maxPR_cowts(Param p) = [vec]:
    let p1 = to_no_Cplus(p), G = p.real_form
    then theta = p1.x.involution {, xo = x_open(G)}
    then coweights = for xi in G.fundamental_coweights
    	 	   do (xi - xi*theta).numer
		   od.no_reps
    then M = null(rank(G),0)
    then () = for tau in coweights
       	      do if rank(M#tau) = rank(M) + 1
       	      	 then M#:=tau
	  	 fi
       	      od
    in M

{result is tuples ([dpLs]) with pL hermitian and p = Ind_P^G(pL); so pL and p are unitary iff all the dpLs are}
set ind_cand_params = (Param -> [Param]):
    let param_hash = make_Param_hash()
    then answers = [[Param]]: [] {one for each Param known}
    in (Param -> [Param]): (Param p) [Param]:
       if not is_hermitian(p) then return [] fi;
       let I = param_hash.size()
       then i = param_hash.match(p)
       then () = if i=I
       	       	 then let G = p.real_form, p1 = to_no_Cplus(p)
    		      then xo = x_open(G)
    		      then lists = for tau in maxPR_cowts(p)
    	 	      	   	   do let Q = parabolic_by_cwt(tau, xo)
	    		      	      then L = Q.Levi
	    		      	      then x1L = inverse_embed_KGB(p1.x, L)
	    		      	      then lambda1L = p1.lambda - rho_u(Q)
	    		      	      then list = [Param]: []
	    		      	      then () =  for w1 in Wnu(p)
	       	       	      	      	   do let p1L = first_param(finalize(
					      parameter(x1L, lambda1L, w1*p1.nu)))
		       	  		      in if is_hermitian(p1L)
		      	     		     	    {and is_FPP(L, p1L.infinitesimal_character)}
		     	    			    and real_induce_irreducible(p1L,G) = p
	       	     	     		          then list := for q in derived_factor_params0((p1L))										  do herm_center(q)
						       	       od
	       		    			  fi
	 	        		    od
	    		      	      in list
	 		    	    od
		       then j = first(for list in lists do #list >0 od)
		       in if j.>=
		       	  then answers#:= lists[j]
			  else answers#:= []
		   	  fi
		   fi

	then ()= assert(#answers = param_hash.size(),"ind_cand_params hash damaged")
	in answers[i]

set_type Lvd_Perm2{_mapAct} = (LocalVertexData Lvd, PermOrderTwo Perm2{, vec mapAct})

set Perm2_to_LPm(InnerClass ic, PermOrderTwo Perm2) = Lvd_Perm2{_mapAct}:
    let verts = FPP_vertices(ic)
    then FEs = FPP_flippable_edges(ic)
    then vlist = (for f in Perm2.fixed do verts[f] od)## (for (p,q) in Perm2.trans do face_bary(verts,[p,q]) od)
    then Lvd = to_vertex_data(vlist,#Perm2.fixed)
    {then mapAct = vec: for j:#verts do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for f@k in Perm2.fixed do mapAct[f]:= k od
    then () = for (p,q)@ell in Perm2.trans do mapAct[p]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[q]:=#Perm2.fixed + ell od}
    in (Lvd, Perm2{, mapAct})

{Record for each inner class a list of some involutions in inner class; and for each such involution,
 some possible lambdas; and for each such lambda, a list of (local vertex data, Perm2, mapAct)}
set_type
[Lvd_Perm2_table =

( (->int) inner_class_size {number of inner classes included}
  , ( -> vec) ic_vlist_size {for each inner class, the number of FPP-vertices}
  , ( -> ) clear
  , ( -> vec) involution_size {for each inner class, number of involutions so far considered}
  , ( -> [vec]) lamthlam_size {for each inner class and involution, number of d_lambdas (actually lambda+theta*lambda)
      	 		       so far considered}
{  , ( -> [vec]) cands_size {for each inner class and involution, number of candidate lambda+theta*lambda
      	 		       so far considered}}
  , ( -> [[vec]]) Lvd_list_size {for each inner class and involution and d_lambda, size of Lvd.list}
  , (InnerClass -> VertexData) FPP_vertex_data {one for each inner class}
  , (InnerClass -> (vec -> int)) flippable_edge_lookup
  {, (InnerClass -> [FaceVertsIndex]) FPP_flip_tet}
  , (InnerClass -> [ratvec]) FPP_local_vertices {one for each inner class}
{  , ((InnerClass, mat) -> [vec]) cands {for each involution, a list of candidates for lambda+theta_lambda}}
  , ((InnerClass, mat) -> [vec]) lamthlams {for each involution, list of allowed lambda+theta_lambda}
  , ((InnerClass, mat, vec) -> int) lamthlam_number {for each involution, number of lambda+theta_lambda in list}
  , ((InnerClass, mat) -> [ratvec]) lambda0s {for each involution, list of allowed lambda mod twists}
  , ((InnerClass, mat,vec) -> PermOrderTwo) Perm2 {for each involution and lamthlam, corresponding Perm2}
  , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2{_mapAct})]) LPm_entries {allowed lambda mod twists, corr entry}
    		       	  	    {like output of old FPP_lambdas_big_new}
  , ((InnerClass, mat, vec) -> LocalVertexData) Lvd {local vertex data, one for each theta and lambda+theta*lambda}
  , ((InnerClass, mat, vec) -> Lvd_Perm2{_mapAct}) LPm_entry {one for each theta and lambda+theta*lambda}
{  , ((InnerClass, mat, vec) -> ) append {just compute, don't report LPm entry}}
  , (int -> InnerClass) inner_class_index
  , (int -> VertexData) vd_index {vertex data for inner class}
  , ((int,int,int) -> Lvd_Perm2{_mapAct}) Lvd_Perm2_index {one for each inner class, involution,
    		      					       lambda + theta*lambda}
)
]

set make_Lvd_Perm2_table() = Lvd_Perm2_table:
(   let inner_class_hash = make_InnerClass_hash()
    then inv_hashes = [mat_hash]: [] {one for each inner class}
    then vertex_datas = [VertexData]: [] {one for each inner class}
    then FELs = [(vec->int)]: [] {one for each inner class}
    then FPP_local_verts = [[ratvec]]: [] {one list for each inner class}
{    then cands = [[[vec]]]: [] {one [vec] for each inner class and involution}}
    then lamthlam_hashess = [[vec_hash]]: [] {one for each inner class and involution}
    	 {entries are vecs of size ic.rank: lamba+theta*lambda, for a
	 	  certain choice of lambda (defined up to twist and equivalence}
    then Perm2s = [[[PermOrderTwo]]]: [] {one for each involution and cand lamthlam}
    then entries = [[[Lvd_Perm2]]]: [] {one list for each involution and cand lamthlam}
    then clear() = void:
    	 let () = inner_class_hash.clear()
	 then () = inv_hashes := []
	 then () = vertex_datas := []
	 then () = FELs := []
	 then () = FPP_local_verts := []
{	 then () = cands := []}
	 then () = lamthlam_hashess := []
	 then () = Perm2s := []
	 then () = entries := []
	 in ()
    then add_inner_class(InnerClass ic) = int:
    	 let I = inner_class_hash.size()
	 then i = inner_class_hash.match(ic)
    	 then () = if i = I {haven't seen this inner class before}
	      	   then inv_hashes #:= make_mat_hash();
	    	   	vertex_datas #:= FPP_vertex_data(ic);
			FELs #:= FPP_flippable_edge_lookup(ic);
	    	   	FPP_local_verts #:= FPP_local_vertices(ic, vertex_datas[i].list, FELs[i]);
{			cands #:= [];}
	    	   	lamthlam_hashess #:= [];
			Perm2s #:= [];
	    	   	entries #:= []
	    	   fi
	  in i
     then add_involution(InnerClass ic, mat theta) = (int, int):
    	 let i = add_inner_class(ic)
	 then J = inv_hashes[i].size()
      	 then j = inv_hashes[i].match(theta)
     	 then () = if j = J {haven't seen this involution before}
      	      	   then {cands[i] #:= [];}
			lamthlam_hashess[i] #:= make_vec_hash();
			Perm2s[i] #:= [];
		   	entries[i] #:= []
		   fi
	 in (i, j)
    then add_cands(InnerClass ic, mat theta) = (int, int):
    	 let (i,j) = add_involution(ic,theta)
	 then tempPerm2si = Perm2s[i]
	 then entriesi = entries[i]
	 then () = if {#cands[i][j] > 0} lamthlam_hashess[i][j].size() > 0
	 	   then return (i,j)
	 	   else let Perm2cands = cands_hash(ic,theta, lamthlam_hashess[i][j]) {this  writes to the hash table the possible lamthlam}
			then () = tempPerm2si[j] := Perm2cands
			then () = entriesi[j] := for lamthlam@k in lamthlam_hashess[i][j].list()
			     	       	    do let Perm2 = Perm2cands[k]
				     	       in Perm2_to_LPm(ic,Perm2)
					    od
			then () = Perm2s[i] :=tempPerm2si
			then () = entries[i] := entriesi
			in ()
		    fi
	 in (i,j)
    then add_KGBElt(KGBElt x) = (int,int):
    	 let i = add_inner_class(x.inner_class)
    	 then n = x.number
	 in (i,n)
    in
    ( ( -> int): {inner_class_size} @int: inner_class_hash.size()
    , ( -> vec): {ic_vlist_size} @vec: for vd in vertex_datas do #vd.list od
    , ( -> ): {clear} clear
    , ( -> vec): {involution_size} @vec: for inv_hash in inv_hashes do inv_hash.size() od
    , ( -> [vec]): {lamthlam_size} @[vec]:
      for lamthlam_hashes in lamthlam_hashess {ith inner class}
      do for lamthlam_hash in lamthlam_hashes    {jth involution}
      	 do lamthlam_hash.size()
	 od
      od
    , ( -> [[vec]]): {Lvd_list_size} @[[vec]]:
      for i: #entries
      do for j: #entries[i]
	 do for k: #entries[i][j]
	    do #(entries[i][j][k].Lvd.list)
	    od {vec for involution}
	 od {[vec] for inner class}
      od
    , (InnerClass -> VertexData): {FPP_vertex_data}  (InnerClass ic) VertexData:
      let i = add_inner_class(ic)
      in vertex_datas[i]
    , (InnerClass -> (vec -> int)): {flippable_edge_lookup} (InnerClass ic) (vec -> int):
      let i = add_inner_class(ic)
      in FELs[i]
    , (InnerClass -> [ratvec]): {FPP_local_vertices} (InnerClass ic)  [ratvec]:
      let i = add_inner_class(ic)
       in FPP_local_verts[i]
{    , ((InnerClass, mat) -> [vec]): {cands} (InnerClass ic, mat theta) [vec]:
      let (i,j) = add_cands(ic,theta)
      in cands[i][j]}
    , ((InnerClass, mat) -> [vec]): {lamthlams} (InnerClass ic, mat theta) [vec]:
      let (i,j) = add_cands(ic,theta)
      in lamthlam_hashess[i][j].list()
     , ((InnerClass, mat, vec) -> int): {lamthlam_number} (InnerClass ic, mat theta, vec lamthlam) int:
      let (i,j) = add_cands(ic,theta), th1 = theta+1
      in lamthlam_hashess[i][j].lookup(lamthlam)
    , ((InnerClass, mat) -> [ratvec]): {lambda0s} (InnerClass ic, mat theta) [ratvec]:
      let (i,j) = add_cands(ic,theta), th1 = 1+theta
      in for lamthlam in lamthlam_hashess[i][j].list()  {k:lamthlam_hashess[i][j].size()}
      	 do let lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
      	    in lr+ic.rho
	 od
    , ((InnerClass, mat,vec) -> PermOrderTwo): {Perm2} (InnerClass ic, mat theta, vec lamthlam):
      let (i,j) = add_cands(ic,theta)
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in Perm2s[i][j][k]
    , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2{_mapAct})]): {LPm_entries} (InnerClass ic, mat theta)
      [(ratvec, Lvd_Perm2{_mapAct})]:
      let (i,j) = add_cands{lamthlam_hash}(ic,theta), th1 = theta+1
      in for lamthlam@k in lamthlam_hashess[i][j].list()
	 do let lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
	    in (lr+ic.rho, entries[i][j][k])
	 od
    , ((InnerClass, mat, vec) -> LocalVertexData): {Lvd} (InnerClass ic, mat theta, vec lamthlam)
      		    LocalVertexData:
      let (i,j) = add_cands{lamthlam_hash}(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k].Lvd
      {the next function FAILS in U(3,3), called inside FPP_unitary_hash(U(3,3))}
    , ((InnerClass, mat, vec) -> Lvd_Perm2{_mapAct}): {LPm_entry} (InnerClass ic, mat theta, vec lamthlam)
    Lvd_Perm2{_mapAct}:
      let (i,j) = add_cands(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k]
    , (int -> InnerClass): {inner_class_index} (int i) InnerClass: inner_class_hash.index(i)
    , (int -> VertexData): {vd_index} (int i) VertexData: vertex_datas[i]
    , ((int,int,int) -> Lvd_Perm2{_mapAct}): {Lvd_Perm2_index} (int i, int j, int k): Lvd_Perm2{_mapAct}:
      entries[i][j][k]
)
)

set LPm_table = make_Lvd_Perm2_table()

{
set localFD_1Dirac2_by_zero(KGBElt x, ratvec lambda) = [[FaceVertsIndex]]:
    let theta = x.involution, ic = x.inner_class
    then lamthlam = ((1+theta)*lambda).numer
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic,theta,lamthlam)
    in localFD_1Dirac2_by_zero(x,lambda,Lvd,Perm2)
}

set Lvd(KGBElt x, ratvec lambda) = LocalVertexData:
    let theta = x.involution, ic = x.inner_class
    then lamthlam = ratvec_as_vec((1+theta)*lambda)
    in LPm_table.Lvd(ic,theta,lamthlam)

{this is the list of all possible lambda + theta*lambda for ic and theta}
set FPP_lamthlams(InnerClass ic, mat theta) = [vec]:
    LPm_table.lamthlams(ic,theta)

{list of lambdas up to twist by differential zero}
set FPP_lambda0s(InnerClass ic, mat theta) = [ratvec]:
    LPm_table.lambda0s(ic, theta)

set_type
[FPP_lambda_table =

( (->int) real_form_size {number of RealForms included}
  , ( -> ) clear
  , (KGBElt -> int) add_KGBElt
  , (KGBElt -> [ratvec]) FPP_lambdas {for each inner class, the number of FPP-vertices}
  , ((KGBElt,ratvec) -> int) position {location of lambda in FPP_lambdas(x)}
)
]

set make_FPP_lambda_table() = FPP_lambda_table:
(   let real_form_hash = make_RealForm_hash()
    then lambda_hashess = [[ratvec_hash]]: [] {one ratvec_hash for each real form and KGBElt}
    then clear() = void:
    	 let () = real_form_hash.clear()
	 then () = lambda_hashess := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then lambda_hashess #:= for x in KGB(rf) do make_ratvec_hash() od
	    	   fi
	  in i
    then add_KGBElt(KGBElt x) = int:
    	 let i = add_real_form(x.real_form)
    	 then n = x.number
	 then () = if lambda_hashess[i][n].size() = 0 {haven't computed FPP_lambdas(x)}
	      	   then {let theta = x.involution
		   	then tworhoi = sum(imaginary_posroots(G,theta))
			then imag_simple_roots = for alphav in imaginary_poscoroots(G,theta)
			     		   do if tworhoi*alphav = 2
					      then [alphav]
					      else []
					      fi
					   od.##}
			let zeroPol = null_module(x.real_form), zeroNu = null(x.real_form.rank)/1
		   	then longlist = LPm_table.lambda0s(x.inner_class, x.involution),
			     twists = all_lambda_differential_0(x.involution)
			then list0 = for lambda0 in longlist
			     	     do let q = parameter(x, lambda0, zeroNu)
				     	in if q!= zeroPol
				     	then [q.lambda]
					else []
					fi
				     od.##
			in for l0 in list0
			   do for tau in twists
			      do lambda_hashess[i][n].match(parameter(x,l0+tau,zeroNu).lambda)
	  		      od
       			   od.##
		     fi
	  in n
     in
( (->int): {real_form_size} @int: real_form_hash.size()
  , ( -> ): clear
  , (KGBElt -> int): {add_KGBElt} (KGBElt x) int: add_KGBElt(x)
  , (KGBElt -> [ratvec]): {FPP_lambdas} (KGBElt x) [ratvec]:
    let i = add_real_form(x.real_form)
    then n = add_KGBElt(x)
    in lambda_hashess[i][n].list()
  , ((KGBElt,ratvec) -> int): {position} (KGBElt x, ratvec lambda) int:
    let i = add_real_form(x.real_form)
    then n = add_KGBElt(x)
    in lambda_hashess[i][n].lookup(lambda)
)
)

set FPP_lam_table = make_FPP_lambda_table()

{list of lambdas for x up to twist by differential zero}
set FPP_lambda0s(KGBElt x) = [ratvec]:
    let longlist = LPm_table.lambda0s(x.inner_class, x.involution), G=x.real_form
    then zeroPol = null_module(G), zeroNu = null(G.rank)/1
    in for lambda0 in longlist
       do if 1*parameter(x, lambda0, zeroNu) != zeroPol
       	  then [lambda0]
	  else []
	  fi
       od.##

set FPP_lambda_table_flag = true

set FPP_lambdas(KGBElt x) = [ratvec]:
    if FPP_lambda_table_flag
    then FPP_lam_table.FPP_lambdas(x)
    else let list0 = FPP_lambda0s(x), G=x.real_form
    	 then twists = all_lambda_differential_0(x.involution)
	 then zeroNu = null(G.rank)/1
	 in for ell0 in list0
	    do for tau in twists
	       do parameter(x,ell0+tau,zeroNu).lambda
	       od
       	     od.##
    fi

set position_time = int:0

{location of lambda in FPP_lambdas(x)}
set position(KGBElt x, ratvec lambda) = int:
    let start = elapsed_ms()
    then lambdaNorm = parameter(x,lambda,0*lambda).lambda
    then N = FPP_lam_table.position(x,lambdaNorm)
    then () = if N=-1 then prints("WARNING: at G = ",x.real_form,", x = ",x.number,", lambda = ",
    	 lambdaNorm," is not attached to x.") fi
    then () = position_time +:= elapsed_ms() - start
    in N

set FPP_lambdas([KGBElt] xs) = [[ratvec]]:
    for x in xs
    do FPP_lambdas(x)
    od



{If NU (nu part) > LAM (lambda part) *low_frac, then figure to_ht could work better}
set low_frac = 1/1


{low refers to small lambda}
{"true" should mean nu is large, so these elts are near the
"top" of their blocks, and is_unitary_to_ht is fast.
"false" should mean  nu is small, and is_unitary is fast.}
{N is meant to be a height bound (bigger than height(parameter)}
{set low(KGBElt x, ratvec lambda, int N) = bool:
    let G = x.inner_class
    then theta = x.involution
    then Lvd = LPm_table.Lvd(G, theta, (1+theta)*lambda.numer)
    then LAM = dominant(G, (1+theta)*lambda)*G.two_rho_check + 2*N
    then NU = max(for gamma in Lvd.list do dominant(G, (1-theta)*gamma) *G.two_rho_check od)
    {then R = G.two_rho * G.two_rho_check}
    in NU > low_frac*LAM}

{whether to use to_height in computing to height N}
{true means large nu, so to_ht could be better}
set low(Param p, int N) = bool:
    let (,NU,) = low(p)
    in NU > 2*N*low_frac

set nullint(int N) = [int]:
    for n:N do 0 od

{whether to record nonunitary reps as well as unitary}
set nuhash_flag = true

{whether to use this hashed branch function as often as possible}
set branch_hash_flag = true

{whether to include KGB numbers in output files. True makes them more human-readable, sometimes longer}
set write_x_flag = false

{whether to use the script branching code instead of library}
set my_branch_flag = true

{whether to use the script hash of K_type_formula instead of library}
set my_formula_flag = false

{The result of cohomological induction on the level of K}
set theta_induce_K(KTypePol QL, RealForm G) = KTypePol:
K_type_pol(sum(G, for c@pL in QL do c*theta_induce_standard(param(pL),G) od))

{decide NOT to hash nonunitary...well, UNdecided 1/14/25}
{try to incorporate RF_sig_table 1/18/25}
{sig_height = height(p)-1 means full signature
phash always contains uhash and nuhash}
set_type
[big_unitary_hash_table =
( ( -> int) real_form_size {number of real forms included}
  , ( -> vec) uhash_sizes {for every real form, the number of unitary reps}
  , (RealForm -> int) uhash_size {for one real form, number of unitary reps}
  , ( -> vec) nuhash_sizes {for every real form, the number of nonunitary reps}
  , (RealForm -> int) nuhash_size {for one real form, number of nonunitary reps}
  , ( -> vec) K_type_size {number of LKTs for each real form}
  , ( -> vec) K_type_pol_size
  , (KType -> KTypePol) K_type_formula
  , ((KType,int) -> KTypePol) K_type_formula_to_ht
  , ((KType, int) -> KTypePol) branch_entry {branch std to height}
  , ((KTypePol, int) -> KTypePol) branch {branch pol of stds to height}
  , ((Param,int) -> KTypePol) sig_entry {signature to height}
  , (int, int -> int) branch_height {largest ht to which K type j on real form i has been branched}
  , (int, int -> int) sig_height {largest ht to which param j on real form i has had sig computed}
  , ( -> ) clear
  , (RealForm -> ) clearG
  , (RealForm -> int) rf_number {number of real form in list}
  , (int -> RealForm) rf_index {jth real form in list}
  , (RealForm -> [int]) xl_known {for each x, bitmap of lambda for which FPP unitary dual is known}
  , (RealForm -> int) x_known {bitmap of x for which entire FPP dual is known}
  , (RealForm -> int) x_partial {bitmap of x for which some lambda have FPP dual known}
  , ((KGBElt,int) -> ) finish {add bitmap of new known (x,lambda) to xl_known}
  , (KGBElt -> ) finishx {add x to x_known}
  , ((RealForm,int) ->) finishxmap {OR int with x_known(RealForm)}
  , (KGBElt -> ) partialx {add x to x_partial}
  , ((RealForm,[int]) -> ) finishall {add bitmaps of all new known (x,lambda) to xl_known}
  , (RealForm -> Param_hash) phash {hash table of all indexed parameters}
  , (RealForm -> Param_hash) uhash {hash table of known unitary}
  , (RealForm -> Param_hash) nuhash {hash table of known nonunitary}
  , (Param -> (int,int)) long_plookup {(rf_index(p.real_form), location of p in its phash)}
  , (Param -> (int,int)) long_ulookup {(rf_index(p.real_form), location of p in its uhash)}
  , (Param -> int) plookup {(location of p in its phash)}
  , (Param -> int) ulookup {(location of p in its uhash)}
  , (Param -> int) nulookup {(location of p in its nuhash)}
  , (Param -> bool) check {check whether p is unitary, and add to appropriate hash table}
  , ((Param,int) -> bool) check_to_ht {check whether p is unitary to height}
  , (Param -> int) umatch {add p to its uhash table}
  , (Param -> int) numatch {add p to its nuhash table}
  , ((Param,int) -> int) long_umatch {add p to ith uhash table}
  , ((Param,int) -> int) long_match {add p to ith uhash table} {included for back compatibility}
  , ( -> ) write {output unitary data for file}
  , (RealForm -> ) writeG {output data for one group to file}
  , ((RealForm, int, int) -> ) writeGrange {output data for KGB(G)[low,high]}
  , ((KGBElt, ratvec) -> ) writexlam {output data for one x,lambda}
  , ((KGBElt, ratvec) -> ) writexlam_no_G {output data for one x,lambda; without writing G}
)
]

{function that will be properly defined in K_types.at}

set branch_std (KTypePol P, int cut_off) = KTypePol:
    let start = elapsed_ms()
    then ans = branch(P,cut_off)
    in branch_builtin_time +:= elapsed_ms() - start; ans

{set branch_std (KType mu, int cut_off) = KTypePol:
    branch_std(1*mu,cut_off)}

set finish_time = int:0
set is_finished_time = int:0
set branch_script_time = int:0

set make_big_unitary_hash() = big_unitary_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then uhashes = [Param_hash]: [] {one for each real form}
    then nuhashes = [Param_hash]: [] {one for each real form}
    then phashes = [Param_hash]: []
    {then status_strings = [[string]]: [] {one for each real form; "" is unknown, "T..." is unitary, "F..." nonunitary}}
    then K_type_hashes = [KType_hash] : [] {one for each real form; list of LKTs of params}
    then K_type_pol_hashes = [KTypePol_hash] : []  {one for each real form}
    then formulas = [vec]:[] {size of K_type_hash; entry in K_type_pol_hash recording K_type_formula}
    then formula_heights = [vec]:[] {size that of K_type_hash; largest height to which formula computed}
    then branches = [vec] : [] {one vec for each real form, of size #K types;
   		   	      ith entry is index of branching KTypePol for KType #i}
    then sigs = [vec]: [] {one vec for each real form, of size #params;
   	       	      	  jth entry is index of signature KTypePol for Param #j}
    then branch_heights = [vec]: [] {one list for each real form; jth entry is vec with ith entry the height
   		       	 	   to which branch(param i) is known}
    then sig_heights = [vec]: [] {one list for each real form; jth entry is vec with ith entry
    	 	       	      	 the height to which sig(param i) is known}
    then xl_known = [[int]]: [] {one bitmap of known (x,lambda) for each real form and x}
    then x_known = [int]: [] {one bitmap of known x for each real form}
    then x_partial = [int]: [] {one bitmap of partially known x for each real form}
    then clearBUH() = void:
    	 let () = real_form_hash.clear()
	 then () = uhashes := []
	 then () = nuhashes := []
	 then () = phashes := []
	 {then () = status_strings := []}
         then () = K_type_hashes := []
         then () = K_type_pol_hashes := []
    	 then () = formulas := [] 
    	 then () = formula_heights := [] 
         then () = branches := []
         then () = sigs := []
         then () = branch_heights := []
         then () = sig_heights := []
	 then () = xl_known := []
	 then () = x_known := []
	 then () = x_partial := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then	let empty = [int]: nullint(#KGB(rf))
		   	then () = K_type_hashes #:= make_KType_hash();
		             K_type_pol_hashes #:= make_KTypePol_hash();
			     formulas #:= null(0);
			     formula_heights #:= null(0);
		       	     branches #:= null(0);
		             sigs #:= null(0);
		             branch_heights #:= null(0);
			     sig_heights #:= null(0)
		   	then () = xl_known #:= empty {null(#KGB(rf))}
			then () = x_known #:= 0
			then () = x_partial #:= 0
			{then () = status_strings #:= []}
			then () = uhashes #:= make_Param_hash()
			then () = nuhashes #:= make_Param_hash()
			then () = phashes #:= make_Param_hash()
			in ()
	    	   fi
	  then () = assert(real_form_hash.size() = #phashes and #phashes = #xl_known
	       	    				 and #uhashes = #phashes and #nuhashes = #phashes
	       	    				 and #phashes = #x_known {and #phashes = #status_strings}
						 and #x_partial = #x_known
						 and #K_type_hashes = #x_known and #K_type_pol_hashes = #x_known
						 and #branches = #x_known and #sigs = #x_known
						 and #sig_heights = #x_known, "big_unitarity_hash damaged")
	  in i
    then add_K_type(KType mu) = (int, int): {real form index, K type index}
   	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := first_K_type(regroup(rf,1*mu))
	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then ktypenum = K_type_hashes[rfnum].match(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	     	   then let pol = 1*mu
	     	       	then m = K_type_pol_hashes[rfnum].match(pol)
			{then () = if KTYPENUM = 26 then prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum], ", fs = ",formulas[rfnum],", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum]) fi}
			then () = formulas[rfnum] #:= m
			then () = formula_heights[rfnum] #:= height(mu)
		      	then () = branches[rfnum] #:= m
		       	then () = branch_heights[rfnum] #:= height(mu)
		       	then () = assert(real_form_hash.size() = #K_type_pol_hashes,"big_unitarity_hash damaged")
        	       	then () = assert(real_form_hash.size() = #K_type_hashes,"big_unitarity_hash damaged")
		       	then () = assert(#branches[rfnum] = K_type_hashes[rfnum].size() and
			     	  #branch_heights[rfnum] = #branches[rfnum], "branch_hash_table damaged")
			then () = assert(#branches[rfnum] = #formula_heights[rfnum] and
			     	#branches[rfnum]  = #formulas[rfnum], "branch_hash_table damagedAKTFTH")
		       	in ()
		   fi
	in (rfnum, ktypenum)
    then add_K_type_formula(KType mu) = (int, int, int): {rfnum, ktypenum, index(formula)}
       	 let (rfnum,ktypenum) = add_K_type(mu), h = height(mu)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := first_K_type(regroup(rf,1*mu))
       	 then () = if formula_heights[rfnum][ktypenum] != h-1
       	       	   then let m = K_type_pol_hashes[rfnum].match(K_type_formula(mu))
		   	then formsrf = formulas[rfnum], formhsrf = formula_heights[rfnum]
			then () = formsrf[ktypenum] := m
			then () = formhsrf[ktypenum] :=h-1
		      	{then () = formulas[rfnum][ktypenum] :=m}
			{then () formula_heights[rfnum][ktypenum] :=h-1}
			then () = formulas[rfnum] := formsrf
			then () = formula_heights[rfnum] := formhsrf
			in ()
		   fi
	 {then () = prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum], ", fs = ",formulas[rfnum],", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum])}
         then() = assert(K_type_hashes[rfnum].size() = #branches[rfnum] and #branches[rfnum] = #formulas[rfnum]
       	      		and #branches[rfnum] = #branch_heights[rfnum]
			and #branches[rfnum] = #formula_heights[rfnum], "branch_hash_table damagedAKTF")
         in (rfnum, ktypenum, formulas[rfnum][ktypenum])
    then add_K_type_formula_to_ht(KType mu, int D) = (int,int,int): {rfn, ktypen, index_to_ht(formula)}
      	 let (rfnum,ktypenum) = add_K_type(mu), h = height(mu)
       	 then () = assert(D >= h, "too-low height argument for K_type_formula")
       	 then () = if (formula_heights[rfnum][ktypenum] < D and formula_heights[rfnum][ktypenum] >= h)
       	       	   then let m = K_type_pol_hashes[rfnum].match(K_type_formula(mu,D))
		   	then formsrf = formulas[rfnum], formhsrf = formula_heights[rfnum]
			then () = formsrf[ktypenum] := m
			then () = formhsrf[ktypenum] := D
		      	{then () = formulas[rfnum][ktypenum] :=m}
			{then () formula_heights[rfnum][ktypenum] :=h-1}
			then () = formulas[rfnum] := formsrf
			then () = formula_heights[rfnum] := formhsrf
		      	in ()
		   fi
	 {then () = if ktypenum = 13 then prints(K_type_hashes[rfnum].size(),", bs = ",branches[rfnum],
	      ", fs = ",formulas[rfnum], ", bhs = ",branch_heights[rfnum], ", fhs = ",formula_heights[rfnum]) fi}
         then() = assert(K_type_hashes[rfnum].size() = #branches[rfnum] and #branches[rfnum] = #formulas[rfnum]
	 	         and #branches[rfnum] = #branch_heights[rfnum]
			 and #branches[rfnum] = #formula_heights[rfnum], "branch_hash_table damagedAKTFTH")
         in (rfnum, ktypenum, formulas[rfnum][ktypenum])
    then add_K_type_branch(KType mu, int D) = (int, int, int):
    	 {this time add to height; D should be >= height(mu)}
   	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu := first_K_type(regroup(rf,1*mu))
	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then (,ktypenum) = add_K_type(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	     	   then {let start_branch = elapsed_ms()}
		       	let pol = branch_std(1*mu,D)
	     	       	then m = K_type_pol_hashes[rfnum].match(pol)
			then tempbranchhts = branch_heights[rfnum]
		       	then tempbranches = branches[rfnum]
		       	then () = tempbranches[ktypenum] := m
		       	then () = tempbranchhts[ktypenum] := D
		       	then () = branch_heights[rfnum] := tempbranchhts
			then () = branches[rfnum] := tempbranches
		       	then () = assert(real_form_hash.size() = #K_type_pol_hashes,"big_unitarity_hash damaged")
        	       	then () = assert(real_form_hash.size() = #K_type_hashes,"big_unitarity_hash damaged")
		       	then () = assert(#branches[rfnum] = K_type_hashes[rfnum].size(), "big_unitarity_hash damaged")
		       	   in ()
		   else {we've seen mu before}
		       if branch_heights[rfnum][ktypenum] < D
		       then let tempbranchhts = branch_heights[rfnum]
		       	    then tempbranches = branches[rfnum]
		       	    then pol = branch_std(1*mu, D)
		       	    then m = K_type_pol_hashes[rfnum].match(pol)
		       	    then () = tempbranches[ktypenum]:=m
		       	    then () = tempbranchhts[ktypenum] :=  D
		       	    then () = branch_heights[rfnum] := tempbranchhts
			    then () = branches[rfnum] := tempbranches
		       	    in()
		        fi {branch_heights[rfnum][ktypenum] < D}
		    fi {ktypenum = KTYPENUM}
	in (rfnum, ktypenum, branches[rfnum][ktypenum])

    then add_K_type_my_branch(KType mu, int D) = (int, int, int):
    	 let rfnum = add_real_form(mu.real_form)
	 then rf = real_form_hash.index(rfnum)
	 then () = mu :=  first_K_type(regroup(rf,1*mu))
	 then () = assert(D>=height(mu),"branch to D below height(mu)")
	 then rfnum = add_real_form(rf)
	 then () = rf:= real_form_hash.index(rfnum)
	 then () = mu:= first_K_type(regroup(rf,1*mu))
    	 then KTYPENUM = K_type_hashes[rfnum].size()
	 then (,ktypenum) = add_K_type(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	      	   then let start = elapsed_ms()
		   	then ans = null_K_module(rf)
		   	then undone = 1*mu {guaranteed on rf}
			then () = while undone.!=
			     do let (c,tau) = first_term(undone)
			     	then corr = if my_formula_flag
				     	    then let (,,t) = add_K_type_formula_to_ht(tau,D)
					    	 in c*regroup(rf, to_ht(K_type_pol_hashes[rfnum].list()[t],D))
					    else c*K_type_formula(tau,D)
					    fi
			     	{then (,,t) = add_K_type_formula_to_ht(tau,D)}
				then () = undone-:= corr {c*regroup(rf, to_ht(K_type_pol_hashes[rfnum].list()[t],D))}
				in ans+:=c*tau
			     od
			then m = K_type_pol_hashes[rfnum].match(ans)
			then () = branch_script_time +:= elapsed_ms() - start
			then tempbranchhts = branch_heights[rfnum]
			then tempbranches = branches[rfnum]
			then () = tempbranches[ktypenum] := m
		       	then () = tempbranchhts[ktypenum] := D
			then () = branch_heights[rfnum] := tempbranchhts
			then () = branches[rfnum] := tempbranches
		       	then () = assert(real_form_hash.size() = #K_type_pol_hashes,"big_unitarity_hash damaged")
        	       	then () = assert(real_form_hash.size() = #K_type_hashes,"big_unitarity_hash damaged")
		       	then () = assert(#branches[rfnum] = K_type_hashes[rfnum].size(), "big_unitarity_hash damaged")
		       	in ()
		   else {we've seen mu before}
		       let Dold = branch_heights[rfnum][ktypenum]
		       then () = if Dold < D
			       then let ans = to_ht(K_type_pol_hashes[rfnum].list()[branches[rfnum][ktypenum]],Dold)
			       	    then undone = mu - sum(rf, for c@tau in ans
			       	    	     do let (,,Kft) = add_K_type_formula_to_ht(tau,D)
						in c*regroup(rf, to_ht(K_type_pol_hashes[rfnum].list()[Kft],D))
					     od)
			       	    then () = while undone.!=
			       	    	      do let (c,tau) = first_term(undone)
					      	 then corr = if my_formula_flag
				     	    	      	     then let (,,t) = add_K_type_formula_to_ht(tau,D)
					    	 	     	  in c*regroup(rf, to_ht(K_type_pol_hashes[rfnum].list()[t],D))
					    		     else c*K_type_formula(tau,D)
					    		     fi
			     	       	      	 {then (,,t) = add_K_type_formula_to_ht(tau,D)}
				       		 then () = undone-:= corr {c*regroup(rf,
						      to_ht(K_type_pol_hashes[rfnum].list()[t],D))}
				       		 in ans+:=c*tau
			     	    	      od
		       	       then m = K_type_pol_hashes[rfnum].match(ans)
			       then tempbranches = branches[rfnum]
			       then tempbranchhts = branch_heights[rfnum]
		       	       then () = tempbranches[ktypenum]:=m
		       	       then () = tempbranchhts[ktypenum]:=  D
		       	       then () = branch_heights[rfnum] := tempbranchhts
			       then () = branches[rfnum] := tempbranches
		       	       in()
		               fi {Dold < D}
			in ()
		     fi {ktypenum = KTYPENUM}
	in (rfnum, ktypenum, branches[rfnum][ktypenum])

    then add_param_inf(Param p) = (int, int, int): {add a param, full herm form}
   	let  rfnum = add_real_form(p.real_form)
	then PNUM = phashes[rfnum].size()
	then () = p:=herm_center(p)
	then pnum = phashes[rfnum].match(p)
	then () = if pnum = PNUM {haven't computed with p before}
	     	  then let sig = hermitian_form_irreducible(p) {insert computation from good?}
		       then sig_ind = K_type_pol_hashes[rfnum].match(sig)
		       then () = sigs[rfnum] #:= sig_ind
		       then () = sig_heights[rfnum] #:= height(p) - 1
		       then () = if is_pure(sig)
		       	       	 then uhashes[rfnum].match(p)
				 else nuhashes[rfnum].match(p)
				 fi
		       then () = assert(real_form_hash.size() = #phashes,"big_unitarity_hash damaged")
		       then () = assert(real_form_hash.size() = #sig_heights,"big_unitarity_hash damaged")
		       then () = assert(#sigs[rfnum] = phashes[rfnum].size(), "big_unitarity_hash damaged")
		       then () = assert(#sig_heights[rfnum] = phashes[rfnum].size(), "big_unitarity_hash damaged")
		       in ()

		  else {we've seen p before}
                       if sig_heights[rfnum][pnum] >= height(p)
                       then let tempsigs = sigs[rfnum], tempsights = sig_heights[rfnum]
                            then sigD = hermitian_form_irreducible(p)
			    then () = if is_pure(sigD)
				      then uhashes[rfnum].match(p)
				      else nuhashes[rfnum].match(p)
				      fi
			    then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			    then () = tempsigs[pnum] := sigD_ind
                            then () = tempsights[pnum]:= height(p) - 1
			    then () = sigs[rfnum] := tempsigs
                            then () = sig_heights[rfnum] := tempsights
                            in()

                       fi
		  fi
	 in (rfnum, pnum, sigs[rfnum][pnum])
   then add_param(Param p, int D) = (int, int, int): {add a param, form to ht D; assume D >= ht(p)}
        let  rfnum = add_real_form(p.real_form)
        then PNUM = phashes[rfnum].size()
	then () = p:=herm_center(p)
        then pnum = phashes[rfnum].match(p)
        then () = if pnum = PNUM {haven't computed with p before}
                  then let sigD = if low(p,D) {low(p.x,p.lambda,D)}
     	  			  then let ans =  hermitian_form_irreducible_to_ht(p,D)
				       then () = if is_pure(ans)
					     	 then ()
					     	 else nuhashes[rfnum].match(p)
						 fi
					in ans
     	 			   else let ans = hermitian_form_irreducible(p)
					then () = D:=height(p)-1
	       				then () = if is_pure(ans)
					     	  then uhashes[rfnum].match(p)
						  else nuhashes[rfnum].match(p)
						  fi
	       				in ans
     	 			   fi
                       then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
		       then () = sigs[rfnum] #:= sigD_ind
		       then () = sig_heights[rfnum] #:= D
                       then () = assert(real_form_hash.size() = #phashes,"big_unitarity_hash damaged")
		       then () = assert(real_form_hash.size() = #sig_heights,"big_unitarity_hash damaged")
                       then () = assert(#sigs[rfnum] = phashes[rfnum].size(), "big_unitarity_hash damaged")
                       in ()
                   else {we've seen p before}
                       if sig_heights[rfnum][pnum] >= height(p) and sig_heights[rfnum][pnum] < D
                       then let tempsigs = sigs[rfnum], tempsights = sig_heights[rfnum]
                            {then start_sig = elapsed_ms()}
                            then sigD = if low(p,D) {low(p.x,p.lambda,N)}
     	  			   	then let ans = hermitian_form_irreducible_to_ht(p,D)
					     then () = if is_pure(ans)
					     	       then ()
					     	       else nuhashes[rfnum].match(p)
						       fi
					     in ans
     	 				else let ans = hermitian_form_irreducible(p)
					     then () = D:=height(p)-1
					     then () = if is_pure(ans)
					     	       then uhashes[rfnum].match(p)
						       else nuhashes[rfnum].match(p)
						       fi
	       				     in ans
					fi
			    then sigD_ind = K_type_pol_hashes[rfnum].match(sigD)
			    then () = tempsigs[pnum] := sigD_ind
                            then () = tempsights[pnum]:=D
			    then () = sigs[rfnum] := tempsigs
                            then () = sig_heights[rfnum] := tempsights
                            in()

                       fi
                   fi
         in (rfnum, pnum, sigs[rfnum][pnum])
    then clearG(RealForm rf) =
    	 let i = real_form_hash.lookup(rf)
	 in if i >= 0
	    then {prints(i);}
	    	 uhashes[i].clear();
		 nuhashes[i].clear();
		 phashes[i].clear();
		 {status_strings[i]:=[];}
		 K_type_hashes[i].clear();
		 K_type_pol_hashes[i].clear();
		 branches[i] := [];
       		 sigs[i] := [];
       		 branch_heights[i] := [];
       		 sig_heights[i] := [];
	    	 {prints("i = ",i, ", x_partial = ",x_partial);}
	    	 x_partial[i] := 0;
		 xl_known[i] := nullint(#KGB(rf));
		 x_known[i] := 0
	    fi
    in
    ( (->int): {real_form_size} @int: real_form_hash.size()
    , ( -> vec): {uhash_sizes} @vec: for uhash in uhashes
      	   	 	       	     do uhash.size()
				     od
    , (RealForm -> int): {uhash_size} (RealForm rf) int:
     let rfnum = add_real_form(rf)
     in uhashes[rfnum].size()
    , ( -> vec): {nuhash_sizes} @vec: for nuhash in nuhashes
      	   	 		      do nuhash.size()
				      od
    , (RealForm -> int): {nuhash_size} (RealForm rf) int:
     let rfnum = add_real_form(rf)
     in uhashes[rfnum].size()
    , ( -> vec): {K_type_size} @vec: for hash in K_type_hashes do hash.size() od
    , ( -> vec): {K_type_pol_size} @vec: for hash in K_type_pol_hashes do hash.size() od
    , (KType -> KTypePol): {K_type_formula} (KType mu) KTypePol:
    begin
     if not my_formula_flag then return K_type_formula(mu) fi;
     let (rfnum,,m) = add_K_type_formula(mu)
     in regroup(mu.real_form, K_type_pol_hashes[rfnum].index(m))
    end
    , ((KType,int) -> KTypePol): {K_type_formula_to_ht} (KType mu, int D) KTypePol:
    begin
      if not my_formula_flag then return K_type_formula(mu,D) fi;
      let (rfnum,,m) = add_K_type_formula_to_ht(mu,D)
      in regroup(mu.real_form, to_ht(K_type_pol_hashes[rfnum].index(m), D))
    end
    , ((KType, int) -> KTypePol): {branch_entry} (KType mu, int D) KTypePol:
     begin
     	let (rf, ktypenum,m) = if my_branch_flag
	    	 	       then add_K_type_my_branch(mu,D)
			       else add_K_type_branch(mu,D)
			       fi
	in regroup(mu.real_form, to_ht(K_type_pol_hashes[rf].index(m), D))
     end

    , ((KTypePol, int) -> KTypePol): {branch} (KTypePol pol, int D) KTypePol:
      let terms = [(Split, KType)]: for c@mu in to_ht(pol,D)
      	  	  	   	    do (c,mu)
				    od
      then G = pol.real_form
      in to_ht( sum(pol.real_form, for (c,mu) in terms
      	 			   do let (rf,,m) = if my_branch_flag
				      	  	    then add_K_type_my_branch(mu,D)
						    else add_K_type_branch(mu,D)
						    fi
				      in regroup(G, c*K_type_pol_hashes[rf].index(m))
				   od) , D)
    , ((Param,int) -> KTypePol): {sig_entry} (Param p, int D) KTypePol:
     begin
	let (rf,pnum,sig_ind) = if D < height(p)
	    		      	then add_param_inf(p)
				else add_param(p,D)
				fi
	in if D < height(p)
	   then regroup(p.real_form, K_type_pol_hashes[rf].index(sig_ind))
	   else regroup(p.real_form, to_ht(K_type_pol_hashes[rf].index(sig_ind), D))
	   fi
     end
    , (int, int -> int): {branch_height} (int rf, int ktypenum): branch_heights[rf][ktypenum]
    , (int, int -> int): {sig_height} (int rf, int pnum): sig_heights[rf][pnum]
    , ( -> ): {clear} clearBUH
    , (RealForm -> ): {clearG} (RealForm rf):
      clearG(rf)
    , (RealForm -> int): {rf_number} (RealForm rf) int:
      add_real_form(rf)
    , (int -> RealForm): {rf_index} (int i) RealForm:
      real_form_hash.index(i)
    , (RealForm -> [int]): {xl_known} (RealForm rf) [int]:
      let i = add_real_form(rf)
      in xl_known[i]
    , (RealForm -> int): {x_known} (RealForm rf) int:
      let i = add_real_form(rf)
      in x_known[i]
    , (RealForm -> int): {x_partial} (RealForm rf) int:
      let i = add_real_form(rf)
      in x_partial[i]
    , ((KGBElt,int) -> ): {finish} (KGBElt x, int M):
      let start = elapsed_ms()
      then i = add_real_form(x.real_form)
      then xl_knowni = [int]: xl_known[i]
      then () = xl_knowni[x.number] := OR(M,xl_knowni[x.number])
      then () = xl_known[i] := xl_knowni
      {then () = x_partial[i] := OR(to_bitset([x.number]),x_partial[i])
      then () = if xl_known[i][x.number] + 1 = to_bitset([#FPP_lambdas(x)])
      	      	then x_known[i] := OR(to_bitset([x.number]),x_known[i])
		fi}
      then () = finish_time+:= elapsed_ms() - start
      in ()
    , (KGBElt -> ): {finishx} (KGBElt x):
      let i = add_real_form(x.real_form)
      then M = to_bitset([x.number])
      then () = x_known[i] := OR(M,x_known[i])
      then () = x_partial[i] := OR(M,x_partial[i])
      in ()
    , ((RealForm,int) ->): {finishxmap} (RealForm G, int M):
      let i = add_real_form(G)
      then () = x_known[i] := OR(M,x_known[i])
      in ()
    , (KGBElt -> ): {partialx}  (KGBElt x):
      let i = add_real_form(x.real_form)
      then M = to_bitset([x.number])
      then () = x_partial[i] := OR(M,x_partial[i])
      in ()
    , ((RealForm,[int]) -> ): {finishall} (RealForm rf, [int] Ms):
      let start = elapsed_ms()
      then i = add_real_form(rf)
      then xl_knowni = [int]: xl_known[i]
      then () = for n:#KGB(rf)
      	      	do xl_knowni[n] := OR(Ms[n],xl_knowni[n])
		od
      then () = xl_known[i] := xl_knowni
      then v = vec: for M@j in Ms do if M.= then [] else [j] fi od.##
      then () = x_partial[i] := OR(x_partial[i], to_bitset(v))
      in finish_time+:= elapsed_ms() - start
    , (RealForm -> Param_hash): {phash} (RealForm rf) Param_hash:
      phashes[add_real_form(rf)]
    , (RealForm -> Param_hash): {uhash} (RealForm rf) Param_hash:
      uhashes[add_real_form(rf)]
    , (RealForm -> Param_hash): {nuhash} (RealForm rf) Param_hash:
      nuhashes[add_real_form(rf)]
    , (Param -> (int,int)): {long_plookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      then j = phashes[i].lookup(p)
      in (i,j)
    , (Param -> (int,int)): {long_ulookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      then j = uhashes[i].lookup(p)
      in (i,j)
    , (Param -> int): {plookup} (Param p) int:
       phashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> int): {ulookup} (Param p) int:
       uhashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> int): {nulookup} (Param p) int:
       nuhashes[add_real_form(p.real_form)].lookup(p)
    , (Param -> bool): {check} (Param p) bool:
      let (i,,sigD) = add_param_inf(p)
      in is_pure(K_type_pol_hashes[i].list()[sigD])
    , ((Param,int) -> bool): {check_to_ht} (Param p, int N) bool:
      let (i,,sigD) = add_param(p,N)
      in is_pure(to_ht(K_type_pol_hashes[i].list()[sigD], N))
{
      let i = add_real_form(p.real_form)
      {then () = prints("bitmap for ",p.x.number," is ",xl_known[i][p.x.number])}
      then () = p := herm_center(p)
      then j = add_param_inf(p)
      then ju = uhashes[i].lookup(p)
      in if ju.>= then true
      	 else let jn = nuhashes[i].lookup(p)
      	      in if jn.>= then false
      	      	 elif {now p was not found in either} is_member_bitset(p.x.number, x_known[i])
	 	 then nuhashes[i].match(p); false
	 	 elif {now x not completely known} position(p.x, p.lambda).>=
	 	      and is_member_bitset(position(p.x, p.lambda), xl_known[i][p.x.number])	 then false
	 	 else let sig = add_param
		 chk = is_unitary(p)
	      	      then () = if chk
	      		      	then uhashes[i].match(p)
	      			else if nuhash_flag
			     	     then nuhashes[i].match(p)
			     	     fi
				fi
	      	      in chk
	 	 fi
	 fi
}
    , (Param -> int): {umatch} (Param p):
      let i = add_real_form(p.real_form)
      in uhashes[i].match(p)
    , (Param -> int): {numatch} (Param p):
      let i = add_real_form(p.real_form)
      in if nuhash_flag
      	 then nuhashes[i].match(p)
	 else -1
	 fi
    , ((Param,int) -> int): {long_umatch} (Param p, int i):
      uhashes[i].match(p)
    , ((Param,int) -> int): {long_match} (Param p, int i):
      uhashes[i].match(p)
    , ( -> ): {write} @void:
    let rf_list = real_form_hash.list()
    in for rf@i in rf_list
       do let Gname = "G"+to_string(i)
	  then listname = Gname+"_list"
	  then intlistname = Gname+"_XLK"
	  then plist = uhashes[i].list()
	  {then bitmapintlist = xl_known[i]}
	  then donemap = x_known[i]
	  then done_list = [int]:[]
	  then () = if write_x_flag then done_list :=
	        for x in KGB(rf)
      	   	       do if is_member_bitset(x.number, donemap)
			  then [x.number]
			  else []
			  fi
		       od.##
		 fi
	  in write_real_form(rf,Gname);
	     prints("set j = big_unitary_hash.rf_number(",Gname,")");
	     for p in plist
	     do let xnum = p.x.number
	     	in prints("void: big_unitary_hash.long_match(parameter(Gname,",xnum,",",p.lambda,",",p.nu,"),j)")
	     od;
	     if write_x_flag
	     then for xnum in done_list
	      	  do prints("void: big_unitary_hash.finishx(KGB(Gname)[",xnum,"])")
	      	  od
	     else prints("void: big_unitary_hash.finishxmap(Gname,",donemap,")")
	     fi
	     {prints("set ",intlistname,"=[int]:[]");
	     write_append(bitmapintlist,intlistname);
	     prints("big_unitary_hash.finishall(",Gname,",",intlistname,")")}
	od
    , (RealForm -> ): {writeG} (RealForm G):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then intlistname = Gname+"_XLK"
      then plist = uhashes[i].list()
      {then bitmapintlist = xl_known[i]}
      then donemap = x_known[i]
      then done_list = [int]:[]
      then () = if write_x_flag then done_list :=
      	      	       for x in KGB(G)
      	   	       do if is_member_bitset(x.number, donemap)
			  then [x.number]
			  else []
			  fi
		       od.##
		 fi
      in write_real_form(G,Gname);
      	 prints("set j = big_unitary_hash.rf_number(",Gname,")"); 
	 for p in plist
	 do let xnum = p.x.number
	    in prints("void:  big_unitary_hash.long_match(parameter(G_temp,",xnum,",",p.lambda,",",p.nu,"),j)")
	 od;
	 {prints("void: big_unitary_hash.finishall(",Gname,",",xl_known[i],")");} {this has length #KGB(G), which is a lot; not worth including}
	 if write_x_flag
	 then for xnum in done_list
	      do prints("void: big_unitary_hash.finishx(KGB(G_temp)[",xnum,"])")
	      od
	 else prints("void: big_unitary_hash.finishxmap(G_temp,",donemap,")")
	 fi
    , ((RealForm, int, int) -> ): {writeGrange} (RealForm G, int low, int high):
      let i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list_"+to_string(low)+"_"+to_string(high)
      then intlistname = Gname+"_XLK_"+to_string(low)+"_"+to_string(high)
      then longlist = uhashes[i].list()
      then plist = for p in longlist
      	   	   do if p.x.number >= low and p.x.number < high
		      then [p]
		      else []
		      fi
		   od.##
      then donemap = x_known[i]
      then donerangemap = AND(donemap, 2^high - 2^low)
      then done_list = [int]: []
      then () = if write_x_flag then done_list :=
      	      	       for x in KGB(G)[low:high]
      	   	       do if is_member_bitset(x.number, donemap)
			  then [x.number]
			  else []
			  fi
		       od.##
		fi
      	   {these are the x's being written for which list is complete}
      in write_real_form(G,Gname);
      	 prints("set j = big_unitary_hash.rf_number(",Gname,")"); {, ptemp = GL(1,R).trivial");}
	 for p in plist
	 do let xnum = p.x.number
	    in prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",p.lambda,",",p.nu,"),j)")
	 od;
	 if write_x_flag
	 then for xnum in done_list
	      do prints("void: big_unitary_hash.finishx(KGB(G_temp)[",xnum,"])")
	      od
	 else prints("void: big_unitary_hash.finishxmap(G_temp,",donerangemap,")")
	 fi
    , ((KGBElt,ratvec) -> ): {writexlam} (KGBElt x, ratvec lambda):
      let G = x.real_form
      then xnum = x.number
      then i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then longlist = uhashes[i].list()
      then plist = for p in longlist
      	   	   do if p.x = x and p.lambda = lambda
		      then [p]
		      else []
		      fi
		   od.##
      then N = to_bitset([position(x,lambda)])
      in write_real_form(G,Gname);
         prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",lambda,",",p.nu,"),j)")
	 od;
	 if is_member_bitset(position(x,lambda), xl_known[i][xnum])
	 then prints("big_unitary_hash.finish(KGB(G_temp)[",xnum,"],",to_string(N),")")
	 fi
    , ((KGBElt,ratvec) -> ): {writexlam_no_G} (KGBElt x, ratvec lambda):
      let G = x.real_form
      then xnum = x.number
      then i = add_real_form(G)
      then Gname = "G_temp"
      then listname = Gname+"_list"
      then longlist = uhashes[i].list()
      then plist = for p in longlist
      	   	   do if p.x = x and p.lambda = lambda
		      then [p]
		      else []
		      fi
		   od.##
      then N = to_bitset([position(x,lambda)])
      in {write_real_form(G,Gname);}
         prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 for p in plist
	 do prints("void: big_unitary_hash.long_match(parameter(G_temp,",xnum,",",lambda,",",p.nu,"),j)")
	 od;
	 if is_member_bitset(position(x,lambda), xl_known[i][xnum])
	 then prints("big_unitary_hash.finish(KGB(G_temp)[",xnum,"],",to_string(N),")")
	 fi
    )
)

set big_unitary_hash = make_big_unitary_hash()

{uses the results stored in big_unitary_hash.}
set branch_irr_hash(Param p, int D) = KTypePol:
    let CF = character_formula_to_height(p,D)
    in big_unitary_hash.branch(K_type_pol(CF),D)


{. The next family of functions all need simple derived group. Always
|vd.list| should be ALL vertices in the FPP; Lvd.list will be all infl
chars in the FPP for a parameter (x,lambda,*), with x and lambda
fixed. The face lists carried by [[FaceBary]] or [[FaceVertsIndex]]
may be pruned of reps not interesting for unitarity, but the indices
will always refer to a constant vlist.}

set two_to_position(KGBElt x, ratvec lambda) = int:
    let pos = position(x,lambda)
    in if pos.>=
       then to_bitset([position(x,lambda)])
       else -1
       fi

{set a bit in xl_known}
set finish(KGBElt x, ratvec lambda) = void:
    let pos = two_to_position(x,lambda)
    in if pos.>=
       then big_unitary_hash.finish(x, pos)
       fi

set finish(KGBElt x) = void:
    {let lambdas = FPP_lambdas(x)
    then m = #lambdas
    then M = (to_bitset([m]) - 1)
    in} big_unitary_hash.finishx(x)

{check whether a bit in xl_known is set}
set is_finished(KGBElt x, ratvec lambda) = bool:
    let start = elapsed_ms(), Mx_known = big_unitary_hash.x_known(x.real_form),
    	Mx_partial = big_unitary_hash.x_partial(x.real_form), M = big_unitary_hash.xl_known(x.real_form)[x.number]
    {then () = prints("Mx_known = ",Mx_known,", Mx_partial = ",Mx_partial,", M = ",M)}
    then answer = if is_member_bitset(x.number,Mx_known)
    	 	  then true
		  elif {is_member_bitset(x.number,Mx_partial)
		  then} let pos = position(x,lambda)
		  	in if pos.>=
			   then is_member_bitset(pos,M)
			   else false
			   fi
		  then true
		  else false
		  fi
    then () = is_finished_time +:= elapsed_ms() - start
    in answer

{list of all pairs (x,lambda) for which complete FPP-unitary dual is present in big_unitary_hash}
set all_finished(RealForm G) = [(KGBElt,ratvec)]:
    let list = for x in KGB(G)
    	       do set_bit_positions(big_unitary_hash.xl_known(G)[x.number])
	       od
    in for x in KGB(G)
       do let poss = list[x.number]
       	  in for pos in poss
       	     do (x, FPP_lambdas(x)[pos])
       	     od
       od.##



{these functions were in unity.at; give useful heights to which to try unitarity}


{. gives (one of) the K-types of lowest height above mu in the
standard of LKT mu .} {NEED USEFUL BOUND in K_type_formula.}
set next_to_lowest(KType mu) = KType:
    let form = if my_branch_flag
    	       then big_unitary_hash.K_type_formula_to_ht(mu, height(mu) + 30)
	       else K_type_formula(mu, height(mu) + 30)
	       fi
    in first_K_type(form - mu)

{. height of a smallest non-lowest K_type of standard with LKT mu .}
set next_height(KType mu)  = int:
    height(next_to_lowest(mu))

set next_height(KType mu) = int:
    let m = height(mu)
    in m+first( for j in #30 do @:!=
     if my_branch_flag
     then big_unitary_hash.K_type_formula_to_ht(mu, height(mu) + m+2*j+2) - mu
     else K_type_formula(mu,m+2*j+2) - mu
     fi od)

{. height of a smallest non-lowest K_type of p .}
set next_height(Param p) = int:
    height(next_to_lowest(LKTs(p)[0]))

{entries are the m heights of K-types of standard of mu after mu.}
set next_heights(KType mu, int m) = [int]:
    let h = height(mu), start = elapsed_ms()
    then N = h+10, list = [int]: []
    then () = while #list < m
    	 do let klist = monomials(
	    	      	if my_branch_flag
	    	      	then big_unitary_hash.branch(mu, N) - mu
			else branch_std(mu,N) - mu
			fi)
	     then () = list:= sort_u(for tau in klist do height(tau) od)
	     in N+:=5
	 od
    { then () = if time_verbose then prints("    ",print_time_string(
    elapsed_ms() - start)," for next_heights to ",m) fi }
    in list[:m]

set next_heights(Param p, int m) = [int]:
    for tau in LKTs(p) do next_heights(tau,m) od.##.sort_u[:m]

{if this produces -1, then the (hermitian) p is automatically unitary}
set next_heightB(Param p) = int:
    let mu = LKTs(p)[0]
    then M = if my_branch_flag
    	     then big_unitary_hash.K_type_formula_to_ht(mu, height(p) +
	     	  height(p.root_datum, p.nu)) - mu
	     else K_type_formula(mu, height(p) + height(p.root_datum, p.nu)) - mu
	     fi
    in
    if =M then -1
    else
    let (,tau) = first_term(M) in height(tau)
    fi




set UHBS_time = int: 0

{assume p is hermitian, FPP}
set hermitian_form_irreducible_big_SIMPLE(Param p) = KTypePol:
    let () = p:=herm_center(p)
    then L = big_unitary_hash.ulookup(herm_center(p))
    in if L.>=
       then {let startCF = elapsed_ms()}
       	    {then m = char_counter.use()
	    then} let ans = K_type_pol(character_formula(p))
	    {then () = charTime +:= elapsed_ms() - startCF}
	    in ans
       else big_unitary_hash.sig_entry(p,height(p)-1) {hermitian_form_irreducible(p)}
       fi

{this version is only for G simple, p FPP hermitian and centered}
{First weakly good, then Lucas}
set is_unitary_hash_big_SIMPLE_weak_Lucas(Param p) = bool:
    let (,pL) = wkgood_Q(p), G = p.real_form {first try weakly good induction}
    then L = pL.real_form
    then goodL = good_L(p)
    then answer = if L !=G
		  then let derpLs = for qLj in derived_factor_params0(pL)
    	 	   	    	    do monomials(finalize(qLj))
		  	    	    od.##
		       in if #derpLs = 0
		       	  then true
    		      	  else
		       	   let statuses = for derpL in derpLs
    		     	   	      	  do big_unitary_hash.check(derpL)
		    		      	  od
       		       	   in if all(statuses) or goodL = L
		       	      then all(statuses)
        		      else {some derpL is not unitary, but the induction is not trivial}
       	    		        is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      		    do c*theta_induce_standard(param(qL), goodL)
			      		    od))
			     fi {all(statuses}
		          fi{#derpLs = 0}
		   else    {now start Lucas test}
    		    let gamma = p.infinitesimal_character, rd = p.root_datum
    		    then rdi = integrality_datum(rd,gamma)
    		    then alphavs = for alphav@j in rd.simple_coroots
    	 	    	 	   do if gamma*alphav < 1
		     		      then [j]
		     		      else let ji = coroot_index(rdi,alphav)
			  	      in if not is_member_sorted(tau(p))(ji)
			     	      	 then []
			     		 else [j]
			     		 fi {not is_member}
		     		      fi {gamma*alphav < 1}
		  		   od.##
   		   then Q = KGPElt: (alphavs, p.x)
    		   then rhou = Q.rho_u
    		   in if((p.x.involution-1)*rhou).!=
     	     	      then false
   		      else
		        let LL = Q.Levi
    		      	in if LL != G {Lucas test gives a reduction}
       	 	      	   then let xLL = inverse_embed_KGB(p.x,LL)
       	      	      	   	then pLL = parameter(xLL,p.lambda - rhou, p.nu)
       	      	   	   	{then () = assert(p = first_param(theta_induce_standard(pL,G)),
		  		"screwed up pL!")}
    	      	   	   	then derpLLs = derived_factor_params0(pLL)
    	     	   	   	in all(for derpLL in derpLLs
    	 	      	  	       do @bool: big_unitary_hash.check(derpLL)
		      	  	       od)
	 	  	   else big_unitary_hash.check(p)
		           fi {LL != G}
			fi {Q theta-stable}
		 fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{this version is only for G simple, FPP hermitian and herm center p}
{tries first Lucas, then weakly good}
set is_unitary_hash_big_SIMPLE_Lucas_weak(Param p) = bool:
    let gamma = p.infinitesimal_character, rd = p.root_datum, G = p.real_form
    then rdi = integrality_datum(rd,gamma)
    then alphavs = for alphav@j in rd.simple_coroots
    	 	  do if gamma*alphav < 1
		     then [j] {else must be = 1 since we're in FPP}
		     else let ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
    then Q = KGPElt: (alphavs, p.x)
    then rhou = Q.rho_u
    then () = if((p.x.involution-1)*rhou).!=
     	      then big_unitary_hash.numatch(p); return false
	      fi
    then L = Q.Levi
    then answer = if L != G {Lucas test gives a reduction}
       	 	  then
		   let xL = inverse_embed_KGB(p.x,L)
       	      	   then pL = parameter(xL,p.lambda - rhou, p.nu)
       	      	   {then () = assert(p = first_param(theta_induce_standard(pL,G)),
		  	"screwed up pL!")}
    	      	   then derpLs = derived_factor_params0(pL)
    	     	   in all(for derpL in derpLs
    	 	      	  do @bool: big_unitary_hash.check(derpL)
		      	  od)
	 	  else
		   let (,pL) = wkgood_Q(p) {else try weakly good induction}
		   then derpLs = for qLj in derived_factor_params0(pL)
    	 	   	    	 do monomials(finalize(qLj))
		  	    	 od.##
		   then goodL = good_L(p)
		   in if #derpLs = 0
		      then big_unitary_hash.umatch(p); true
    		      else
		       let statuses = for derpL in derpLs
    		     	   	      do big_unitary_hash.check(derpL)
		    		      od
       		       in if all(statuses) or goodL = pL.real_form
       			  then all(statuses)
        		  else {some derpL is not unitary, but the induction is not trivial}
       	    		       is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      		    do c*theta_induce_standard(param(qL), goodL)
			      		    od))
			 fi {all(statuses}
		       fi{#derpLs = 0}
		    fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{this version is only for G simple}
set is_unitary_hash_big_SIMPLE_Lucas(Param p) = bool:
    let gamma = p.infinitesimal_character, rd = p.root_datum, G=p.real_form
    then rdi = integrality_datum(rd,gamma)
    then alphavs = for alphav@j in rd.simple_coroots
    	 	  do if gamma*alphav < 1
		     then [j]
		     else let ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
    then Q = KGPElt: (alphavs, p.x)
    then rhou = Q.rho_u
    then () = if((p.x.involution-1)*rhou).!=
     	      then big_unitary_hash.numatch(p); return false
	      fi
    then L = Q.Levi
    then answer = if L != G {Lucas test gives a reduction}
       	 	  then
		   let xL = inverse_embed_KGB(p.x,L)
       	      	   then pL = parameter(xL,p.lambda - rhou, p.nu)
       	      	   {then () = assert(p = first_param(theta_induce_standard(pL,G)),
		  	"screwed up pL!")}
    	      	   then derpLs = derived_factor_params0(pL)
    	     	   in all(for derpL in derpLs
    	 	      	  do @bool: big_unitary_hash.check(derpL)
		      	  od)
	 	  else
		   big_unitary_hash.check(p)
		  fi {L!=G}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer


{this version is only for G simple and hermitian FPP params}
{does weakly good induction}
set is_unitary_hash_big_SIMPLE_weak(Param p) = bool:
    let (,pL) = wkgood_Q(p), G = p.real_form
    then derpLs = for qLj in derived_factor_params0(pL)
    	 	  do monomials(finalize(qLj))
		  od.##
    then () = if #derpLs = 0 then big_unitary_hash.umatch(p); return true fi
    then statuses = for derpL in derpLs
    		    do big_unitary_hash.check(derpL)
		    od
    then goodL = good_L(p)
    then answer =
       if all(statuses) or goodL = pL.real_form
       then all(statuses)
       else {some derpL is not unitary, but the induction is not trivial}
       	    is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
			           goodL)
			      od))
       fi{all(statuses)}
    then () = if answer
	      then big_unitary_hash.umatch(p)
	      else big_unitary_hash.numatch(p)
	      fi
    in answer

{tiny evidence that wk_Lucas is best, or at least not very bad}
set u_Lucas_flag = false
set u_wk_flag = false
set u_wk_Lucas_flag = true
set u_Lucas_wk_flag = false

{this version is only for G simple}
set is_unitary_hash_big_SIMPLE(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then return is_unitary(p) {prints("FPP DANGER at ",p)}
	      fi
    then () = p := herm_center(p)
    then Lu = big_unitary_hash.ulookup(p)
    {then () = prints("p = ", p, ". Lu = ",Lu, ", is_finished = ",is_finished(p.x, p.lambda))}
    then () = if Lu.>= then return true fi
    then () = if is_finished(p.x, p.lambda)
    	      then big_unitary_hash.numatch(p); return false fi
    then Ln = big_unitary_hash.nulookup(p)
    then () = if Ln.>= then return false fi
    then () = if u_Lucas_flag then return is_unitary_hash_big_SIMPLE_Lucas(p) fi
    then () = if u_wk_flag then return is_unitary_hash_big_SIMPLE_weak(p) fi
    then () = if u_Lucas_wk_flag then return is_unitary_hash_big_SIMPLE_Lucas_weak(p) fi
    then () = if u_wk_Lucas_flag then return is_unitary_hash_big_SIMPLE_weak_Lucas(p) fi
    then answer = big_unitary_hash.check(p)
    in if answer
       then big_unitary_hash.umatch(p); answer
       else big_unitary_hash.numatch(p); answer
       fi

set is_unitary_hash_big(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_hash_big_SIMPLE(pd) od)

set HOWMANY = int:0

set hermitian_form_irreducible_big(Param p) = KTypePol:
    if is_unitary_hash_big(p)
    then {let startCF = elapsed_ms()
       	 then m = char_counter.use()
	 then} let ans = K_type_pol(character_formula(p))
	 {then () = charTime +:= elapsed_ms() - startCF}
	 in ans
     else let G = p.real_form
     	  then () = HOWMANY +:= 1
	  {in hermitian_form_irreducible(p)}
     	  then derps = derived_factor_params0(p)
     	  then mu0 = LKTs(p)[0]
	  {then ans = }
	  in glue_sigs(for derp in derps do hermitian_form_irreducible_big_SIMPLE(derp) od, mu0)
	  {
	  then () = prints("to-glue = ",for derp in derps do hermitian_form_irreducible_big_SIMPLE(derp) od)
	  then () = prints("glued answer = ",ans)
	  then () = prints("correct answer = ", hermitian_form_irreducible(p))
	  }
	  {then () = assert((ans - hermitian_form_irreducible(p)).=,"bad glue_sigs!")}
	  {in ans}
     fi

{if true, then try is_unitary during is_unitary_to_ht}
set interrupt_flag = false {KGB(E7_s,20895), lambda = rho is HORRIBLE with "true"}
set print_int_flag = false

{initial time to give interruptible command}
set interrupt_base_time = int:200

{START with full is_unitary tests, because those are actually interruptable}
{ meant to be used for G simple }
{ compute Hermitian form to ht on p, report if it is unitary}
set hermitian_form_irreducible_to_ht_big_SIMPLE_interrupt(Param p,int N, int time) = KTypePol:
  let which_flag = low(p,N), start = elapsed_ms(), (LAM,NU,) = low(p), empty = p.real_form.null_K_module
  then () = if print_int_flag then prints("N = ",N, ", p = ",p) fi
  then result = empty
  then () = while result.=
       	    do let maybe = if which_flag
     	       	       	   then hermitian_form_irreducible_to_ht_MvL(p,N,time)
	      	       	   else hermitian_form_irreducible(p,time)
	      	       	   fi
	       then () = result := case maybe
	      	       	 	   | timed_out: empty
		  		   | done(ans): to_ht(ans,N)
		  		   esac
      	        then () = if which_flag then time := 2*time fi
	        then () = which_flag := not which_flag;
		if print_int_flag then prints("in form_to_ht, time = ", time, ", which_flag = ", which_flag,
		", elapsed = ",elapsed_ms() - start) fi
		in ()
  	     od
  in result

{assume p is hermitian}
set hermitian_form_irreducible_to_ht_big_SIMPLE(Param p,int N) = KTypePol:
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return hermitian_form_irreducible_to_ht(p,N) {prints("FPP DANGER TO HT at ",p)}
	    fi
  then () = p := herm_center(p)
  then L = big_unitary_hash.ulookup(p)
  then () = if L.>=
       	    then {let startCF = elapsed_ms()
	    	 then m = char_counter.use()
	    	 then} let ans =K_type_pol(character_formula_to_height(p,N))
		 {then () = charTime +:= elapsed_ms() - startCF}
		 in return(ans)
	     fi
  in if interrupt_flag
     then hermitian_form_irreducible_to_ht_big_SIMPLE_interrupt(p,N, interrupt_base_time)
     else if low(p,N) {low(p.x,p.lambda,N)}
     	  then let (,pL) = wkgood_Q(p)
	       then derpLs = for qLj in derived_factor_params0(pL)
    	 	    	     do monomials(finalize(qLj))
		  	     od.##
    	       then () = if #derpLs = 0
	       	       	 then big_unitary_hash.umatch(p);
	       	       	      return K_type_pol(character_formula_to_height(p,N))
			 fi
	       then NLs = for derpL in derpLs do N - height(p) + height(derpL) od
 	       then dersigs = for derpL@j in derpLs
		       	      do big_unitary_hash.sig_entry(derpL,NLs[j])
			      od
	       then sigL = to_ht(glue_sigs(dersigs, LKTs(pL)[0]), N -height(p) + height(pL))
	       in to_ht(theta_induce_K(sigL,G), N)
     	  else big_unitary_hash.sig_entry(p,N)
	  fi {low}
     fi{interrupt}

set HOWMTH = int:0

set hermitian_form_irreducible_to_ht_big(Param p,int N) = KTypePol:
    HOWMTH +:= 1;
    if low(p,N) {low(p.x,p.lambda,N)}
    then hermitian_form_irreducible_to_ht(p,N)
    else to_ht(hermitian_form_irreducible(p),N)
    fi

{START with full is_unitary tests, because those are actually interruptable}
{ meant to be used for G simple }
{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big_SIMPLE_interrupt(Param p,int N, int time) = bool:
  let which_flag = low(p,N), result = 0, start = elapsed_ms(), (LAM,NU,) = low(p)
  then () = if print_int_flag then prints("N = ",N, ", p = ",p) fi
  {then () = if NU > 8*N*low_frac
       	    then return is_pure(hermitian_form_irreducible_to_ht(p,N))
      	    elif NU < N*low_frac/2
      	    then return is_pure(to_ht(hermitian_form_irreducible(p),N))
      	    else}
  then () = while result.=
       	    do result := if which_flag
     	       	      	 then is_unitary_to_ht_MvL(p,N,time)
	      		 else case hermitian_form_irreducible(p,time)
	      	   	      | timed_out: 0
		   	      | done(result): if is_pure(to_ht(result,N))
		     		   	      then 1
				   	      else -1
					      fi
		   	      esac
	      		 fi;
      		if which_flag then time := 2*time fi;
	        which_flag := not which_flag;
		if print_int_flag then prints("in to_ht, time = ", time, ", which_flag = ", which_flag,
		", elapsed = ",elapsed_ms() - start) fi
      		{unitary_test_counter.use() done in calls above}
  	     od
  in result.>

{ meant to be used for G simple }
{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big_SIMPLE(Param p,int N) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary_to_ht(p,N) {prints("FPP DANGER TO HT at ",p)}
	    fi
  {then () = p := herm_center(p)}
  then () = if (big_unitary_hash.ulookup(p)).>= then return true fi
  then () = if (big_unitary_hash.nulookup(p)).>= then return false fi
  in if interrupt_flag
     then is_unitary_to_ht_big_SIMPLE_interrupt(p,N, interrupt_base_time)
     else {unitary_test_counter.use(); done in calls below}
     	  is_pure(big_unitary_hash.sig_entry(p,N))
     fi
{
     	  if low(p,N) {low(p.x,p.lambda,N)}
     	  then {is_pure(hermitian_form_irreducible_to_ht(p,N))}
	       let boo = is_unitary_to_ht(p,N)
	       then () = if not boo
	       	       	 then big_unitary_hash.numatch(p)
			 fi
	       in boo
     	  else let P = hermitian_form_irreducible(p)
	       then () = if is_pure(P)
	       	       	 then big_unitary_hash.umatch(p)
			 else big_unitary_hash.numatch(p)
			 fi
	       in is_pure(to_ht(P,N))
     	  fi
     fi
}
{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big(Param p,int N) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if (big_unitary_hash.ulookup(p)).>= then return true fi;
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_to_ht_big_SIMPLE(pd,N) od)

set to_hts_count_mat = null(10,10)
set to_hts_count = null(10)

set is_unitary_to_hts_big_SIMPLE_interrupt(Param p,[int] Ns, int time) = bool:
    if print_int_flag then prints("N = ",Ns, " p = ",p) fi;
    let () = for N@i in Ns
       	     do let result = 0, which_flag = low(p,N), start = elapsed_ms()
     	        then () = while result = 0
	     	       	  do result:= if which_flag
		     	      	     then is_unitary_to_ht_MvL(p,N,time)
			      	     else case hermitian_form_irreducible(p,time)
	     	      	      	     	  | timed_out: 0
		      		   	  | done(result):
					    if is_pure((to_ht(result,Ns~[0])))
					    then 1
					    else -1
					    fi
		      	      	   	  esac
			      	     fi;
			     	if print_int_flag then prints("in to_hts, time = ", time, ", which_flag = ",
				which_flag, ", elapsed = ", elapsed_ms() - start) fi;
                	     {unitary_test_counter.use(); this is done in the calls above}
			     if not which_flag and not result.= then break fi;
		       	     if which_flag then time := 2*time fi;
		       	     which_flag := not which_flag
     	      		  od {while result}
		in if result.< then big_unitary_hash.numatch(p); return false fi
	     od
     in true

{meant to be used for G simple}
{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big_SIMPLE(Param p,[int] Ns) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then return is_unitary_to_hts(p,Ns) {prints("FPP DANGER TO HT at ",p)}
	    fi
  {then () = p := herm_center(p)}
  then () = if (big_unitary_hash.ulookup(p)).>= then return true fi
    in if interrupt_flag
     then return is_unitary_to_hts_big_SIMPLE_interrupt(p, Ns, interrupt_base_time)
     else if #Ns = 0
       	  then return is_unitary_hash_big_SIMPLE(p)
	  fi;
  	  for N in Ns
     	  do if not is_unitary_to_ht_big_SIMPLE(p,N)
     	     then return false
	     fi
     	  od;
     	  true
     fi

{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big (Param p,[int] Ns) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if #Ns = 0 then return is_unitary_hash_big(p) fi;
  let pds = derived_factor_params0(p)
  in all(for pd in pds do @bool: is_unitary_to_hts_big_SIMPLE(pd,Ns) od)

{ONLY for G simple}
{ compute Hermitian form to height N; if it's positive, then compute full form }
set is_unitary_test_big_SIMPLE_interrupt(Param p, int N, int time) = bool:
    let which_flag = low(p,N), result = 0, start = elapsed_ms()
    then () = while result.=
    	      do result := if which_flag
	      	 	   then is_unitary_to_ht_MvL(p,N,time)
			   else case hermitian_form_irreducible(p,time)
	      	   	      	| timed_out: 0
		   	      	| done(r): if is_pure(r) then return true fi;
					   if is_pure(to_ht(r,N))
		     		   	      then 1
				   	      else -1
					      fi
		   	        esac
	      		   fi;
			   if result = -1 then big_unitary_hash.numatch(p); return false fi;
      			   if which_flag then time := 2*time fi;
	        	   which_flag := not which_flag;
			   if print_int_flag then prints("in test, time = ", time, ", which_flag = ",
			      		     which_flag, ", elapsed = ",elapsed_ms() - start) fi
	       od
    {now result = +1}
    in is_unitary_hash_big_SIMPLE(p)

{ONLY for G simple}
{ compute Hermitian form to height N; if it's positive, then compute full form }
set is_unitary_test_big_SIMPLE(Param p, int N) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    if N < height(p) then return is_unitary_hash_big_SIMPLE(p) fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then return is_unitary{_test}(p{,N}) {prints("FPP DANGER TO HT at ",p)}
	      fi
    {then () = p := herm_center(p)}
    then () = if is_finished(p.x, p.lambda) and big_unitary_hash.ulookup(p).>=
    	      then return true
    	      fi
    in if interrupt_flag
       then is_unitary_test_big_SIMPLE_interrupt(p,N,interrupt_base_time)
       else let P = big_unitary_hash.sig_entry(p,N)
       	    in if not is_pure(P)
	       then false
	       else is_unitary_hash_big_SIMPLE(p)
	       fi
       fi

{ONLY for G simple}
{ like previous, with list of heights; use interrupted is_unitary}
set is_unitary_test_big_SIMPLE_interrupt (Param p, [int] Ns, int time) = bool:
   let () = for N@i in Ns
       	    do let result=0, which_flag=low(p,N), start = elapsed_ms()
	       then () =  while result = 0
	     	       	  do result:= if which_flag
		     	      	      then is_unitary_to_ht_MvL(p,N,time)
			      	      else case hermitian_form_irreducible(p,time)
	     	      	      	     	   | timed_out: 0
		      		   	   | done(result):
					     if is_pure(result)
					     then 1
					     else -1
					     fi
		      	      	   	   esac
			      	       fi;
			    if print_int_flag then prints("in tests, time = ", time, "which_flag = ",
			       		      which_flag, ", elapsed = ",elapsed_ms() - start) fi;
               	    	    {unitary_test_counter.use();}
			    if result = -1 then big_unitary_hash.numatch(p); return false fi;
 			    if not which_flag and result = 1 then return true fi;
		       	    if which_flag then time := 2*time fi;
		       	    which_flag := not which_flag
     	      		 od {while result}
	      {at this point result =1, indicating unitarity to ht N is true}
	      in ()
	   od
    in is_unitary_hash_big_SIMPLE(p)

{ONLY for G simple}
{ like previous, with list of heights }
set is_unitary_test_big_SIMPLE (Param p, [int] Ns) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  let G = p.real_form
  then FPP_flag = is_FPP(G,p.infinitesimal_character)
  then () = if not FPP_flag
    	    then  return is_unitary{_test}(p{,Ns}) {prints("FPP DANGER TEST at ",p)}
	    fi
  {then () = p := herm_center(p)}
  {then () = test_count[#Ns] +:= 1}
  then () = if (big_unitary_hash.ulookup(p)).>= then return true fi
  then () = if (big_unitary_hash.nulookup(p)).>= then return false fi
  then () = if #Ns = 0
       	    then {test_count_mat[0,0] +:= 1;}
	    return is_unitary_hash_big_SIMPLE(p)
	    fi
  in for N in Ns
     do if not is_pure(big_unitary_hash.sig_entry(p,N))
     	then return false
	fi
     od;
     is_unitary_hash_big_SIMPLE(p)

{
  in if interrupt_flag then is_unitary_test_big_SIMPLE_interrupt(p, Ns,interrupt_base_time)
     else for N@i in Ns
     	  do if not is_pure(hermitian_form_irreducible_to_ht(p,N))
	     {then unitary_test_counter.use()}
	     then test_count_mat[i,#Ns] +:= 1;
	     return false fi
	  od;
  	  test_count_mat[#Ns,#Ns] +:= 1;
	  is_unitary_hash_big_SIMPLE(p)
      fi
}

set is_unitary_test_big(Param p, int N) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_test_big_SIMPLE(pd,N) od)

set is_unitary_test_big(Param p, [int] Ns) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_test_big_SIMPLE(pd,Ns) od)


{ONLY for G simple}
{use the first m heights from deform_heights to test}
set is_unitary_def_test_big_SIMPLE_interrupt(Param p,int m, int time) = bool:
    let (def,flag)= deform_hts(p,m)
    in if flag
       then is_pos_on_LKTs(p) and is_unitary_to_hts_big_SIMPLE(p,def)
       else is_unitary_test_big_SIMPLE_interrupt(p,def,interrupt_base_time)
       fi

{ONLY for G simple}
{use the first m heights from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p,int m) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let G = p.real_form
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then return is_unitary{_def_test}(p{,m}) {prints("FPP DANGER DEF TEST at ",p)}
	      fi
    {then () = p := herm_center(p)}
    then () = if (big_unitary_hash.ulookup(p)).>= then return true fi
    then () = if (big_unitary_hash.nulookup(p)).>= then return false fi
    then () = if interrupt_flag
    	      then return is_unitary_def_test_big_SIMPLE_interrupt(p, m, interrupt_base_time)
	      fi
    in if low(p, height(p) + 4*m)
       then let (def,flag)= deform_hts(p,m)
       	    in if flag
       	       then is_pos_on_LKTs(p) and is_unitary_to_hts_big_SIMPLE(p,def)
       	       else is_unitary_test_big_SIMPLE(p,def)
       	       fi
       else is_unitary_hash_big_SIMPLE(p)
       fi

set is_unitary_def_test_big(Param p,int m) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_def_test_big_SIMPLE(pd,m) od)

{ONLY for G simple}
{use the first height from deform_heights to test}
set is_unitary_def_test_big_SIMPLE(Param p) = bool:
    is_unitary_def_test_big_SIMPLE(p,1)

set is_unitary_def_test_big(Param p) = bool:
    is_unitary_def_test_big(p,1)

{ONLY for G simple}
set is_unitary_next_big_SIMPLE(Param p) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let G = p.real_form
    then (LAM,NU,) = low(p)
    then FPP_flag = is_FPP(G,p.infinitesimal_character)
    then () = if not FPP_flag
    	      then if NU > LAM*low_frac
       	      	   then let n=next_heightB(p)
    	    	   	in if (n+1).=
	      		   then return true
	      		   elif is_unitary_to_ht_big(p,n)
	      		   then return is_unitary_hash_big_SIMPLE(p)
			   else big_unitary_hash.numatch(p); return false {NOT unitary_to_ht}
			   fi {n=-1}
		   else return is_unitary_hash_big_SIMPLE(p)
		   fi {NU > LAM}
	       fi {not FPP_flag}
    {then () = p := herm_center(p)}
    in if NU > LAM*low_frac
       then let n=next_heightB(p)
    	    in  if (n+1).=
	      	then true
	      	elif is_unitary_to_ht_big_SIMPLE(p,n)
	      	then is_unitary_hash_big_SIMPLE(p)
		else big_unitary_hash.numatch(p); false {NOT unitary_to_ht}
		fi {n=-1}
	else is_unitary_hash_big_SIMPLE(p)
	fi {NU > LAM}

set is_unitary_next_big(Param p) = bool:
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    let pds = derived_factor_params0(p)
    in all(for pd in pds do @bool: is_unitary_next_big_SIMPLE(pd) od)

set theta_induce_signature(Param pL, RealForm G) = KTypePol:
    theta_induce_K(hermitian_form_irreducible_big(pL),G)

set theta_induce_signature_to_ht(Param pL, int DL, RealForm G) = KTypePol:
    theta_induce_K(hermitian_form_irreducible_to_ht_big(pL,DL),G)

{whether to use the new Davis/Mason-Brown criterion saying FPP reps on an outside
face of FPP might have to be coh ind}
set is_FPP_unitary_flag = false

{IF using test, whether to stop after easy part}
set Lucas_fast_flag = true


{Use Davis/Mason-Brown criterion. First bool says whether the test applies; second gives
result of test. Second is meaningful only if first is true; I guess make result (false,false)
otherwise?}
set is_FPP_unitary(Param p) = (bool,bool):
    if not is_FPP_unitary_flag then return (false,false) fi;
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p))
    then return (true,false)
    fi;
    let () = p:= herm_center(p), G = p.real_form
    then gamma = p.infinitesimal_character
    then alphavs = for alphav@j in G.simple_coroots
    	 	  do if gamma*alphav < 1
		     then [j]
		     elif gamma*alphav > 1
		     then []
		     else let rdi = integrality_datum(G,gamma)
		     	  then ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
     then () = if #alphavs = G.semisimple_rank
     	       then return (false,false) {say we don't know}
	       fi
     then Q = KGPElt:(alphavs, p.x) {p now must be good range coh ind from Q}
     then rhou = Q.rho_u
     then () = if((p.x.involution-1)*rhou).!=
     	       then return (true,false)
	       fi
     then () = if Lucas_fast_flag
     	       then return (false,false)
	       {in this case question reduces to L, but we choose not to do
	       calculation on L}
	       fi
     then L = Q.Levi
     then xL = inverse_embed_KGB(p.x,L)
     then pL = parameter(xL,p.lambda - rhou, p.nu)
     then () = assert(p = first_param(theta_induce_standard(pL,G)),"screwed up pL!")
     then derpLs = derived_factor_params0(pL)
     in (true, all(for derpL in derpLs
     	       	   do @bool:
		      {let () = FPP_unitary_hash_bottom_layer([(pL.x,pL.lambda)])
		      in} is_unitary_hash_big_SIMPLE(derpL)
		   od))


{First bool says whether the test applies; second gives result of
test. Second is meaningful only if first is true; make result
(false,false) otherwise}
{Can allow fancy_tester to use FPP_unitary_hash}

set is_FPP_unitary(Param p, (Param -> bool) fancy_tester ) = (bool,bool):
    if not is_FPP_unitary_flag then return (false,false) fi;
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p))
    then return (true,false)
    fi;
    let () = p:= herm_center(p), G = p.real_form
    then gamma = p.infinitesimal_character
    then rdi = integrality_datum(G,gamma)
    then alphavs = for alphav@j in G.simple_coroots
    	 	  do if gamma*alphav < 1
		     then [j]
		     elif gamma*alphav > 1
		     then []
		     else let ji = coroot_index(rdi,alphav)
			  in if not is_member_sorted(tau(p))(ji)
			     then []
			     else [j]
			     fi
		     fi
		  od.##
     then () = if #alphavs = G.semisimple_rank
     	       then return (false,false) {say we don't know}
	       fi
     then Q = KGPElt:(alphavs, p.x) {p now must be good range coh ind from Q}
     {then ()= prints("have Q = ",Q," in is_FPP_unitary")}
     then rhou = Q.rho_u
     then () = if((p.x.involution-1)*rhou).!=
     	       then return (true,false)
	       fi
     then () = if Lucas_fast_flag
     	       then return (false,false) {say we don't know}
	       fi
     then L = Q.Levi
     {then () = prints("in isfppu(fancy) at line 1834, p = ",p)}
     then xL = inverse_embed_KGB(p.x,L)
     then pL = parameter(xL,p.lambda - rhou, p.nu)
     then () = assert(p = first_param(theta_induce_standard(pL,G)),"screwed up pL!")
     then derpLs = derived_factor_params0(pL)
     in (true, all(for derpL in derpLs
     	       	   do @bool: fancy_tester(derpL)
		   od))

set KUKU_flag = true

{if false, suppress printing of report after an FPP_unitary_hash* job}
{need this here for recursive application of smaller FPP's in fancy_tester}
set FPP_report_flag = true

{For each list of faces in FVKH, indices of faces for which the corresponding parament is known
(by Uhash) to be unitary}
set KU(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] FVKH, Param_hash Uhash,
 (Param->bool) fancy_tester) = [vec]:
    {prints("in KU",fancy_tester);}
    let FPP_report_flag_hold = FPP_report_flag
    then () = FPP_report_flag :=false
    then answer =
    	 for FVKHd@d in FVKH
    	 do for vlong@j in FVKHd
       	    do let verts = vlong[:d+1], G = x.real_form
       	       then ps = monomials(finalize(parameter(x,lambda, face_bary(Lvd,verts))))
	       in if all(for p in ps do (Uhash.lookup(p)).>= od)
	       	  then [j]
	     	  elif all(for p in ps
	     	       	   do let (x,y) = is_FPP_unitary(p, fancy_tester)
		      	      then () = if x
			      	      	then if y
			      	   	     then big_unitary_hash.uhash(G).match(p)
				   	     else big_unitary_hash.nuhash(G).match(p)
				   	     fi
			      	   	fi
			      in x and y
		       	  od)
	     	  then [j]
	     	  else []
	     	  fi
       	    od.##
     	 od
    then () = FPP_report_flag:=FPP_report_flag_hold
    in answer

set KU(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] FVKH, Param_hash Uhash) =
[vec]:
    KU(x,lambda,Lvd,FVKH,Uhash, is_unitary_hash_big_SIMPLE@Param) 
 
{takes the known unitaries from unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH, (Param->bool) fancy_tester) = [vec]:
    if KUKU_flag then return KU(x,lambda, Lvd, LFDKH, Uhash, fancy_tester) fi;
    let ps = for d:#LFDKH
    	     do for v in LFDKH[d]
	     	do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1])))}
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
       	  do if p.nu.=
	     then [j]
	     else let qs = monomials(finalize(p))
	     	  in if all(for q in qs do @bool: Uhash.lookup(q).>= od)
	     	     then [j]
		     else []
		     fi
	     fi
	  od.##
       od

set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
   known_unitaries(Uhash, x, lambda, Lvd, LFDKH, is_unitary_hash_big_SIMPLE@Param)


{Here UhashLocal is assumed to consist of Param's at (x,lambda)}
{this misses (in local_testK_level) unitary Param's that finalize to different x;
those are caught by local_testK_hash}
set known_unitaries(Param_hash UhashLocal, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
    	      	  	    	     	      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = UhashLocal.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
       	 do let p = UhashLocal.index(k)
       	    then list = local_vertices(p)
            in if #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
	     	    then m = lookups[#list-1](local_verts)
		    then () = assert(m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]#:=m
		    in ()
	       fi
	 od
     in out

{takes the known non-unitaries from non-unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
{set known_non_unitaries(Param_hash NUhash, KGBElt x, ratvec lambda, VertexData Lvd,
    [[FaceVertsKHash]] LFDKH) = [vec]:
    let ps = for d:#LFDKH
    	     do for v in LFDKH[d]
	     	do parameter(x,lambda,face_bary(Lvd, v[:d+1]))
		{face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
       	  do let qs = monomials(finalize(p))
	     in if all(for q in qs do @bool: NUhash.lookup(q).>= od)
	     	then [j]
		else []
		fi
	  od.##
       od}


set localize(Param_hash Uhash, KGBElt x, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.x = x and p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc

set localize(Param_hash Uhash, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc


{this is the Q(infinitesimal character) bound provided by Dirac inequality on all LKTs}
set DiracBD(KGBElt x, ratvec lambda) = rat:
    let G = x.real_form
    in min(for mu in LKTs(parameter(x,lambda,0*lambda))
       	   do DiracBD(mu)
	   od)

{"true" means unitarity is possible in light of Dirac}
{avoid using is_hermitian defined in hermitian.at}
set DiracTest(Param p) = bool:
    let G=p.real_form
    then ans = bool: if not all(for q in monomials(finalize(p)) do is_hermitian(q) od) then false
       else let gamma = p.infinitesimal_character
    	    then Q = invariant_form(G)
	    then bound = DiracBD(p.x, p.lambda)
	    in Q(gamma, gamma) <= bound
       fi
    then () = if not ans then DTcount +:= 1 fi
    in ans

{Kchar is mean to be the K-character, to height at least HT, of some subquotients
of p to which Dirac ineq is applied.}
set DiracBestTest(int steps, Param p, int HT, KTypePol Kchar) = bool:
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = best_Dirac_bound_cap(mu,steps)
    then j0 = first(for h in hts do h > HT od)
    then () = if j0<0 then j0:=#hts fi
    {now we only look up at [:j0]}
    then Q = invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds[:j0] do b<psize od)
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p with hts bdded by HT}
       else let j2 = first(for tau@j in taus[j1:j0] {these taus would exclude p}
       	    	     	    do @bool: if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi
			    od)
	    in j2.< {if the bound at j0+j corresponds to a tau
	       	     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

{Kchar is mean to be the K-character, of some subquotients of p to which Dirac ineq is applied.}
set DiracBestTest(int steps, Param p, KTypePol Kchar) = bool:
    if not  all(for q in monomials(finalize(p)) do is_hermitian(q) od) then return false fi;
    let mu = LKTs(p)[0], G=p.real_form {should test all LKTs!}
    then (taus,hts,bds) = best_Dirac_bound_cap(mu,steps)
    then Q = invariant_form(G)
    then gamma = p.infinitesimal_character
    then psize = Q(gamma,gamma)
    then j1 = first(for b in bds do b<psize od)
    then ans = bool:  if j1 < 0
       then true {none of the bds catches p}
       else let j2 = first(for tau@j in taus[j1:] {these taus would exclude p}
       	    	     	    do @bool: if branch_hash_flag
			       then big_unitary_hash.branch(Kchar,hts[j1+j])[tau].!=
			       else branch_std(Kchar,hts[j1+j])[tau].!=
			       fi
			    od)
	    in j2.< {if the bound at j corresponds to a tau
	       	     actually appearing in p, then get false}
       fi
    then () = if not ans then DBTcount +:= 1 fi
    in ans

set DiracBestTest(Param p, int HT, KTypePol Kchar) = bool:
    DiracBestTest(Dirac_best_steps, p, HT, Kchar)

set DiracBestTest(Param p, KTypePol Kchar) = bool:
    DiracBestTest(Dirac_best_steps, p, Kchar)

{here p must be irr for branch_irr to work}
set DiracBestTest(int steps, Param p, int HT) = bool:
    DiracBestTest(steps, p, HT, K_type_pol(character_formula_to_height(p,HT)))

{here p must be irr for branch_irr to work}
set DiracBestTest(int steps, Param p) = bool:
    DiracBestTest(steps, p, K_type_pol(character_formula(p)))

{here p must be irr for branch_irr to work}
set DiracBestTest(Param p, int HT) = bool:
    DiracBestTest(Dirac_best_steps, p, HT, K_type_pol(character_formula_to_height(p,HT)))

set DiracBestTest(Param p) = bool:
    DiracBestTest(Dirac_best_steps, p, K_type_pol(character_formula(p)))

{creates LVD, map Perm on FPPverts at (x,lambda), {mapAct from FPPverts to local verts}}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.
parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}

set localFD_Lvd2 \
  (InnerClass ic, mat theta, ratvec lambda, {VertexData vd,} [(ratvec->int)] edge_lookups) =
  (LocalVertexData, PermOrderTwo{, vec}):
(   let Perm2 = thetaAct2(ic, theta, lambda, {vd,} edge_lookups)
    then vlist = {vd.list}FPP_vertices(ic)
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
	 {def of Perm2 forces this to be an actual edge?}
    then Lvd = (vlistAct,#Perm2.fixed).to_vertex_data
    then Llookup = Lvd.lookup
    {then mapAct = vec: for j:#vlist do minus_1 od}
    {maps FPP vertex indices from vd to local indices from Lvd}
    {then () = for i@k in Perm2.fixed do mapAct[i]:= k od}
    {then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od}
    in (Lvd, Perm2{, mapAct})
)

set localFD_Lvd2 \
  ( KGBElt x, ratvec lambda, {VertexData vd,} [(ratvec->int)] edge_lookups) =
  localFD_Lvd2(x.inner_class, x.involution, lambda, {vd,} edge_lookups)

set localFD_Lvd2 \
  ( InnerClass ic, mat theta, ratvec lambda, {VertexData vd,} (vec->int) FlippedEdgeLookup) =
  (LocalVertexData, PermOrderTwo{, vec}):
(   let start = elapsed_ms(), Perm2 = thetaAct2(ic, theta, lambda, {vd,} FlippedEdgeLookup)
    then vlist = {vd.list} FPP_vertices(ic)
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans
	 do if FlippedEdgeLookup([i,j]) >= 0
	    then [(vlist[i] + vlist[j])/2]
	    else []
	    fi
	 od.##
    then Lvd = (vlistAct,#Perm2.fixed).to_vertex_data
    then Llookup = Lvd.lookup
    {then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od}
    in (Lvd, Perm2{, mapAct})
)

set localFD_Lvd2 \
  (KGBElt x, ratvec lambda, {VertexData vd,} (vec->int) FlippedEdgeLookup) = (LocalVertexData, PermOrderTwo{, vec}):
  localFD_Lvd2(x.inner_class, x.involution, lambda, {vd,} FlippedEdgeLookup)

set FD12Time = int: 0

{takes local data and low global faces and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) = [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1Dirac")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let bd = DiracBD(x,lambda)
	      	   then QG =invariant_form(G)
		   then index = first(for v in Lvd.list
		   	      	      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then LF0 = [FaceVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if Q(v,v) > DiracBD
	    then DTcount +:=1; []
	    elif not all(for q in monomials(finalize(p))
	       	      	  do @bool: is_pos_on_LKTs(q)
			  od)
	    then []
	    elif red_count_flag
	    then [[j, red_count(p)]]
	    else [[j]]
	    fi
	 od.##
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
 	     then for v in FPP_edges(G)
	     	  do if not(Llookup(v[0]) and Llookup(v[1])) then []
		     else let m = locate_sorted(Perm2.fixed, v[0]), n = locate_sorted(Perm2.fixed, v[1])
		     	  in if m< #Perm2.fixed and n < #Perm2.fixed and Perm2.fixed[m] = v[0]
			     	and Perm2.fixed[n] = v[1]
		     	     then [[m,n].sort]
			     else []
			     fi
		      fi
		  od.##
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
      	   then EdgesFixTrans = [vec]:
	      if #Perm2.fixed > 0 and #Perm2.trans > 0
	      then for v in FPP_flippable_triangles(G)
	      	   do let m = locate_sorted(Perm2.fixed, v[0]), n = trans_hash.lookup([v[1],v[2]])
	      	   in if m < #Perm2.fixed and Perm2.fixed[m]=v[0] and n.>=
		      then [[m,#Perm2.fixed+n]]
		      else []
		      fi
		   od.##
		else []
		fi
           {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = ([vec]:
	      if #Perm2.trans > 1
	      then for v in FPP_flippable_tetrahedra(G)
	      	   do let m = trans_hash.lookup([v[0],v[1]]), n = trans_hash.lookup([v[2],v[3]])
	      	      in if m.>= and n.>=
		      	 then [[#Perm2.fixed + m, #Perm2.fixed + n].sort]
			 else []
		    	 fi
	            od.##
	       else []
	       fi)
	  {then () = prints("after TransTrans, time is ",print_time_string(elapsed_ms() - start))}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     { then () = prints("after Edges, time is ",print_time_string(elapsed_ms() - start))}
     then LF1 = [FaceVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v))}
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then if red_count_flag
	    	 then [v#red_count(p)]
		 else [v]
		 fi
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    then () = FD12Time +:= elapsed_ms() - start
    in if face_verbose then prints("After localFD_1Dirac2, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       {if time_verbose then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2") fi;}
       answer
)

set FD12bzTime = int:0
set FD12bzFFTime = int:0
set FD12bzFTTime = int:0
set FD12bzTTTime = int:0

{takes local data and low global faces and computes local vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}

{If red_count_flag, add an extra coordinate recording red_count(p)}
set localFD_1Dirac2_by_zero\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1, start = elapsed_ms()
    then () = if Dirac_flag
    	      then let bd = DiracBD(x,lambda)
	      	   then QG =invariant_form(G)
		   then index = first(for v in Lvd.list
		   	      	      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then LF0 = [FaceVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if Q(v,v) > DiracBD
	       then DTcount +:=1; []
	       elif not all(for q in monomials(finalize(p))
	       	      	     do is_pos_on_LKTs(q)
			     od)
	       then []
	       elif red_count_flag
	       then [[j, red_count(p)]]
	       else [[j]]
	       fi
	 od.## {list of j for which vertex j is a candidate}
    then () = if time_verbose
    	      then prints("for LFO, time is ",print_time_string(elapsed_ms() - start))
	      fi
    then FixedList = [int]: for v in LF0
    	 	     	    do let j = v[0]
			       in if j < #Perm2.fixed
			       	  then [j]
				  else break
				  fi
			    od.##
    then TranList = [int]: for v in LF0[#FixedList:] do v[0] od
    then Llookup = is_member_sorted(FixedList##TranList)
    then Edges = [vec]:
    	 let startFF = elapsed_ms()
    	 then EdgesFixFix = [vec]:
	      let F = #FixedList
	      in if F < 2 then []
	      	 else
	      for j in FixedList[:F-1]
	      do for w in FPP_edges_by_zero_unsorted(G)[Perm2.fixed[j]]
		 do let k = locate_sorted(Perm2.fixed, w[1])
		    in if k < #Perm2.fixed and Perm2.fixed[k] = w[1] and
		       	     Llookup(k)
		       then [[j,k].sort]
		       else []
		       fi
		    od.## {list of edges starting with j}
	       od.## {list of all FixFix edges}
	       fi {F < 2}
	    then () = FD12bzFFTime +:=elapsed_ms() - startFF
	   then () = if time_verbose
	   	     then prints("for FixFix, time is ",print_time_string(elapsed_ms() - startFF))
		     fi
	   then startFT = elapsed_ms()
      	   then EdgesFixTrans = [vec]:
	   	if #Perm2.fixed > 0 and #Perm2.trans >0
		then for j@m in Perm2.fixed
		     do {let mloc = mapAct[j]} {this is m?}
		     	let cands = FPP_flippable_triangles_by_zero_unsorted(G)[j]
			in if {Llookup(m) and} #cands > 0
			   then for v in cands
			      	do let n = #Perm2.fixed + trans_hash.lookup(v[1:])
				   in if n >= #Perm2.fixed
				      	 and Llookup(n) and Llookup(m)
				      then [[m,n]]
				      else {DTcount +:= 1;} []
				      fi
			       	od.## {[vec], all starting with m}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all m}
		  else []
		  fi
	   then () = FD12bzFTTime +:= elapsed_ms() - startFT
	   then () = if time_verbose
	   	     then prints("for FixTranspose, time is ",print_time_string(elapsed_ms() - startFT))
		     fi
	   then startTT = elapsed_ms()
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #Perm2.trans > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for (i,j)@m in Perm2.trans
	      	      do let a = FEL([i,j]) {, mloc = mapAct[i]} {this is m+#Perm2.fixed?}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {Llookup(m+#Perm2.fixed) and} #Perm2.trans > m+1 and #cands > 0
		      	    then for v in cands
			      	 do let n = #Perm2.fixed + trans_hash.lookup(v[2:])
				    in if n >= #Perm2.fixed
				       	  and Llookup(n) and Llookup(m+#Perm2.fixed)
				       then [[m+#Perm2.fixed,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	   then () = FD12bzTTTime +:= elapsed_ms() - startTT
	   then () = if time_verbose
	   	     then prints("for TransposeTranspose, time is ",print_time_string(elapsed_ms() - startTT))
		     fi
     	    {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then () = if time_verbose
     	       then prints("after Edges, time is ",print_time_string(elapsed_ms() - start))
	       fi
     then LF1 = [FaceVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then if red_count_flag
	    	 then [v#red_count(p)]
		 else [v]
		 fi
	    else []
	    fi
	 od.##
    then () = if time_verbose
    	      then prints("after LF1, time is ",print_time_string(elapsed_ms() - start))
	      fi
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    then () = FD12bzTime +:= elapsed_ms() - start
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       answer
)


set localFD_1Dirac2_by_zero(KGBElt x, ratvec lambda) = [[FaceVertsIndex]]:
    let theta = x.involution, ic = x.inner_class
    then lamthlam = ((1+theta)*lambda).numer
    then (Lvd,Perm2) = LPm_table.LPm_entry(ic,theta,lamthlam)
    in localFD_1Dirac2_by_zero(x,lambda,Lvd,Perm2)

{No extra coordinates and no Dirac; meant for use in blob, so red_count and Dirac
are only done once for repeated parameters}
set localFD_by_zero_short\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then LF0 = [FaceVertsIndex]:
    	 for j:#Lvd.list
	 do [j]
	 od
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    {then Llookup = is_member_sorted((for v in LF0 do v[0] od))}
    then Edges = [vec]:
    	 let startFF = elapsed_ms()
    	 then EdgesFixFix = [vec]:
             if #Perm2.fixed > 1
	     then for j@m in Perm2.fixed[:#Perm2.fixed - 1]
	     	  do let cands = FPP_edges_by_zero_unsorted(G)[j] {list of edges beginning j}
		     in if {Llookup(m{mloc}) and} #cands > 0
		     	then for v in cands {global edges with v[0] = j}
			     do let n = locate_sorted(Perm2.fixed, v[1])
			     	in if n< #Perm2.fixed and Perm2.fixed[n] = v[1] {and Llookup(n)}
				   then [[m,n].sort]
				   else []
				   fi
			     od.## {this is the list of edges starting with m}
	     		 else []
			 fi {#cands > 0}
		   od.## {all FixFix edges}
	       else []
	       fi
	    then () = FD12bzFFTime +:=elapsed_ms() - startFF
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
	   then startFT = elapsed_ms()
      	   then EdgesFixTrans = [vec]:
	   	if #Perm2.fixed > 0 and #Perm2.trans >0
		then for j@m in Perm2.fixed
		     do {let mloc = mapAct[j]} {this is m?}
		     	let cands = FPP_flippable_triangles_by_zero_unsorted(G)[j]
			in if {Llookup(m) and} #cands > 0
			   then for v in cands
			      	do let n = #Perm2.fixed + trans_hash.lookup(v[1:])
				   in if n >= #Perm2.fixed {and Llookup(n)}
				      then [[m,n]]
				      else []
				      fi
			       	od.## {[vec], all starting with m}
			    else []
			    fi {#cands > 0}
		      od.## {[vec], all m}
		  else []
		  fi
	   then () = FD12bzFTTime +:= elapsed_ms() - startFT
	   then startTT = elapsed_ms()
	   then EdgesTransTrans = [vec]: {this is the longest}
	      if #Perm2.trans > 1
	      then let FEL = FPP_flippable_edge_lookup(G)
	      	   in for (i,j)@m in Perm2.trans
	      	      do let a = FEL([i,j]) {, mloc = mapAct[i]} {this is m+#Perm2.fixed?}
	      	      	 then cands = FPP_flippable_tetrahedra_by_zero_unsorted(G)[a]
		      	 in if {Llookup(m+#Perm2.fixed) and} #Perm2.trans > m+1 and #cands > 0
		      	    then for v in cands
			      	 do let n = #Perm2.fixed + trans_hash.lookup(v[2:])
				    in if n >= #Perm2.fixed {and Llookup(n)}
				       then [[m+#Perm2.fixed,n].sort]
				       else []
				       fi
			       	 od.## {[vec], all starting with mloc}
			     else []
			     fi {#Perm2.trans > m+1}
		       od.## {[vec], all mloc}
		 else []
		 fi
	    then () = FD12bzTTTime +:= elapsed_ms() - startTT
     	    {then () = prints("EFF = ", EdgesFixFix, ", EFT = ",EdgesFixTrans,", ETT = ",EdgesTransTrans)}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FaceVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    	then [v]
	   	else []
	    	fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    then () = FD12bzTime +:= elapsed_ms() - start
    {then () = if elapsed_ms() - start > 10{FD12bzTime}
    	      then prints("(fixed,trans) = (",#Perm2.fixed, ",",#Perm2.trans, "), face counts (",#LF0,",",Edges,") took ",print_time_string(elapsed_ms() - start))
	      fi}
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero_short, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       {if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2_by_zero") fi;}
       answer
)

{add red_count while checking pos on LKTs, Dirac}
set localFD_1Dirac2_add_red(KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsIndex]] LF) =
    [[FaceVertsIndex]]:
    let G = x.real_form
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let bd = DiracBD(x,lambda)
	      	   then QG =invariant_form(G)
		   then index = first(for v in Lvd.list
		   	      	      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    in for d:#LF
       do for v in LF[d]
       	  do let nu = face_bary(Lvd,v)
	     then p = parameter(x,lambda,nu)
	     then qs = monomials(p)
	     in if Q(v,v) > DiracBD
	     	then DTcount +:=1; []
		elif not all(for q in qs do is_pos_on_LKTs(q) od)
		then []
		elif red_count_flag
		then [v#red_count(p)]
		else [v]
		fi
	  od.##
       od

set localFD_1Dirac2_by_zero_old\
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, PermOrderTwo Perm2, vec mapAct) =
    [[FaceVertsIndex]]:
(   {if face_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let bd = DiracBD(x,lambda)
	      	   then QG =invariant_form(G)
		   then index = first(for v in Lvd.list
		   	      	      do @bool: QG(v,v) > bd
				      od)
		   in if index.>=
		      then Q:=QG; DiracBD:=bd
		      fi
	      fi
    then LF0 = [FaceVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if Q(v,v) > DiracBD
	       then DTcount+:=1; []
	       elif all(for q in monomials(finalize(p))
	       	      	do is_pos_on_LKTs(q)
		      	od)
	       then [[j]]
	       else []
	       fi
	 od.##{list of j for which vertex j is a candidate}
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let EdgesFixFix = [vec]:
             if #Perm2.fixed > 1
	     then for j in Perm2.fixed
	     	  do let mloc = mapAct[j]
		     in if Llookup(mloc)
		     	then for v in FPP_edges_by_zero(G)[j] {global edges with v[0] = j}
			     do if is_member_sorted(Perm2.fixed)(v[1])
			     	then let nloc =  mapAct[v[1]]
				     in if nloc > mloc and Llookup(nloc)
				     	then [[mloc,nloc]]
             				else []
					fi
				else []
				fi
			     od.## {this is the list of edges starting with j}
	     		 else []
			 fi
		   od.## {all FixFix edges}
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
      	   then EdgesFixTrans = [vec]:
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
	      	    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
           {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = [vec]:
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
	      	    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
	          fi
	       od.##
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FaceVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,face_bary(Lvd, v))
	 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v)))}
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    then () = FD12bzTime +:= elapsed_ms() - start
    in if(face_verbose) then prints("After localFD_1Dirac2_by_zero, face counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       {if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2_by_zero") fi;}
       answer
)

{set left_good = int:0, left_bad = int:0, right_good = int:0, right_bad = int:0, LR_no_info = int:0}
{takes 0 and 1-diml local faces and adds K-char index}
{having K-char, take opportunity to apply Dirac ineq deeper }
set localFD_KHash_01 (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), ht = height(parameter(x,lambda,0*lambda))
    then lookup0 = if red_count_flag
    	 	   then index_in(for v in LF[0] do v[:1] od)
	 	   else index_in([vec]:[])
		   fi
    then QG = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
    	 if not Dirac_best_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then Q = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
	      	   	    	do bs~[0]
				od)
	     then index = first(for v in Lvd.list
	     	  	  	do @bool: Q(v,v) > bestbd
				od)
	     in if index.>=
	     	then DiracBestBD := bestbd; QG:=Q; true
		else false
		fi
	 fi
    then answer0 = for v@k in LF[0]
       	     	   do if k%(max(#LF[0]\10,2))=0 and fund_face_verbose
	      	      then prints("examining face ",k,
	      	      "; #ktp_hash = ",ktp_hash.size())
	      	      fi;
		      let gamma = Lvd.list[v[0]]
       	      	      then p0 = parameter(x, lambda, gamma)
	      	      then P = finalize(p0)
		      then KCF = K_type_pol(character_formula(P))
		      then m = ktp_hash.match(KCF)
		      in if (not temp_Dirac_best_flag) or (QG(gamma,gamma) <= DiracBestBD)
		      	    or DiracBestTest(p0,KCF)
		      	 then [v##[m,#monomials(P)]]
			 else []
			 fi
		   od.##
    then lookup0D = index_in(for v in answer0
    	 	    	     do v[:1]
			     od)
    then answer1 = for v@k in LF[1] {if red_count_flag, has red_count as coor#2}
    	 	   do if k%(max(#LF[1]\10,2))=0 and fund_face_verbose
	      	      then prints("examining face ",k,
	      	      	   "; #ktp_hash = ",ktp_hash.size())
	      	      fi;
		      if lookup0D(v[:1])<0 or lookup0D(v[1:2])<0
		      then {DBTcount+:=1;} []
		      else
		      let nu = face_bary(Lvd,v[:2])
		      then p0 = parameter(x, lambda, nu)
		      then P = finalize(p0)
		      in if red_count_flag
		      	 then let i = lookup0D([v[0]]), j = lookup0D([v[1]])
			 in if answer0[i][1] = v[2] {Kchars match}
			    then [v##[answer0[i][2],#monomials(P)]]
			    elif answer0[j][1] = v[2]
			    then [v##[answer0[j][2], #monomials(P)]]
			    else let m = ktp_hash.match(K_type_pol(character_formula(P)))
			    	 in [v##[m, #monomials(P)]]
			    fi {answer = v[2]}
			 else let m = ktp_hash.match(K_type_pol(character_formula(P)))
			      in [v##[m, #monomials(P)]]
			 fi{red_count_flag}
			 fi{lookup0}
       	     	     od.##
    then time = elapsed_ms() - start
    then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01 (vertex/edge K-chars)") fi
    in [answer0,answer1]

{takes 0 and 1-diml local faces and adds K-char index to height HT}
set localFD_KHash_01 (KGBElt x, ratvec lambda, LocalVertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF) = [[FaceVertsKHash]]:
    let start = elapsed_ms(), ht = height(parameter(x,lambda,0*lambda))
    then lookup0 = if red_count_flag
    	 	   then index_in(for v in LF[0] do v[:1] od)
		   else index_in([vec]:[])
		   fi
    then QG = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
    	 if not Dirac_best_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then Q = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
	      	   	    	do bs~[0]
				od)
	     then index = first(for v in Lvd.list
	     	  	  	do @bool: Q(v,v) > bestbd
				od)
	     in if index.>=
	     	then DiracBestBD := bestbd; QG:=Q; true
		else false
		fi
	 fi
    then answer0 = for v@k in LF[0]
       	     	   do if k%(max(#LF[0]\10,2))=0 and fund_face_verbose
	      	      then prints("examining face ",k,
	      	      "; #ktp_hash = ",ktp_hash.size())
	      	      fi;
		      let gamma = Lvd.list[v[0]]
       	      	      then p0 = parameter(x, lambda, gamma)
	      	      then P = finalize(p0)
		      then KCF = K_type_pol(character_formula_to_height(P,HT))
		      then m = ktp_hash.match(KCF)
		      in if (not temp_Dirac_best_flag) or (QG(gamma,gamma) <= DiracBestBD)
		      	    or DiracBestTest(p0,HT,KCF)
		      	 then [v##[m,#monomials(P)]]
			 else []
			 fi
		   od.##
    then lookup0D = index_in(for v in answer0
    	 	    	     do v[:1]
			     od)
    then answer1 = for v@k in LF[1]
    	 	   do if k%(max(#LF[1]\10,2))=0 and fund_face_verbose
	      	      then prints("examining face ",k,
	      	      	   "; #ktp_hash = ",ktp_hash.size())
	      	      fi;
		      if lookup0D(v[:1])<0 or lookup0D(v[1:2])<0
		      then []
		      else
		      let nu = face_bary(Lvd,v[:2])
		      then p0 = parameter(x, lambda, nu)
		      then P = finalize(p0)
		      in if red_count_flag
		      	 then let i = lookup0D([v[0]]), j = lookup0D([v[1]])
			 in if answer0[i][1] = v[2]
			    then [v##[answer0[i][2],#monomials(P)]]
			    elif answer0[j][1] = v[2]
			    then [v##[answer0[j][2], #monomials(P)]]
			    else let m = ktp_hash.match(
				      K_type_pol(character_formula_to_height(P,HT)))
			         in  [v##[m,#monomials(P)]]
			    fi {answer = v[2]}
			 else let m = {char_counter.use();} ktp_hash.match(
				      K_type_pol(character_formula_to_height(P,HT)))
			      in [v##[m,#monomials(P)]]
			 fi{red_count_flag}
			 fi{lookup0D}
       	     	    od.##
    then time = elapsed_ms() - start
    then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01 (vertex/edge K-chars)") fi
    in [answer0,answer1]

{same as above, using graph of K-relations}
{takes 0 and 1-diml local faces and adds K-char index}
{only called when red_count_flag = true. In element of LF[d], first d+1 coords are vertices;
next and last is red_count. Adjoin two more: K-char, and #Langlands quotients}
set localFD_KHash_01_graph (KGBElt x, ratvec lambda, LocalVertexData Lvd, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    let ht = height(parameter(x,lambda,0*lambda)), start = elapsed_ms()
    then QG = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
    	 if not Dirac_best_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then Q = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
	      	   	    	do bs~[0]
				od)
	     then index = first(for v in Lvd.list
	     	  	  	do @bool: Q(v,v) > bestbd
				od)
	     in if index.>=
	     	then DiracBestBD := bestbd; QG:=Q; true
		else false
		fi
	 fi
    then NumClasses = #eq
    then polNums = [int]: {one for each class}
    	 for C in eq
    	 do let (d,j) = coords(LF,C~[0]) {the tilde chooses a
	 representative on largest possible face, so least integral}
	    then verts = vec: LF[d][j][:d+1]
	    then gamma = face_bary(Lvd,verts)
	    then pC = parameter(x,lambda,gamma)
	    then PC = finalize(pC)
	    then KCF = K_type_pol(character_formula(PC))
	    in if (not temp_Dirac_best_flag) or (QG(gamma,gamma) <= DiracBestBD)
	       	  or DiracBestTest(pC,KCF)
	       then ktp_hash.match(KCF)
	       else -1
	       fi
	 od
    then nLKT = #LKTs(parameter(x,lambda,0*lambda))
    then answer = for LFd@d in LF
       	 	  do for v@j in LFd
	  	     do let N = polNums[classListByFace[d][j]]
	     	     	then m = if nLKT = 1 or N.<
		      	       	 then 1
		      		 else #monomials(finalize(parameter(x,lambda,face_bary(Lvd,v[:d+1]))))
		      		 fi
	      	        in if N.>=
	      	 	   then [v##[N,m]]
		 	   else []
		 	   fi
	  	     od.##
       		  od
    then time = elapsed_ms() - start
    then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01_graph (vertex/edge K-chars)") fi
    in answer
{same as above, using graph of K-relations}
{takes 0 and 1-diml local faces and adds K-char index}
{only called when red_count_flag = true. In element of LF[d], first d+1 coords are vertices;
next and last is red_count. Adjoin two more: K-char, and #Langlands quotients}
set localFD_KHash_01_graph (KGBElt x, ratvec lambda, LocalVertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FaceVertsIndex]] LF, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    let ht = height(parameter(x,lambda,0*lambda)), start = elapsed_ms()
    then QG = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBestBD = 0/1
    then temp_Dirac_best_flag = bool:
    	 if not Dirac_best_flag then false
	 else let mus = LKTs(parameter(x,lambda,0*lambda))
	      then Q = invariant_form(x.real_form)
	      then best_bounds = for mu in mus do best_Dirac_bound(mu) od
	      then bestbd = min(for (,,bs) in best_bounds
	      	   	    	do bs~[0]
				od)
	     then index = first(for v in Lvd.list
	     	  	  	do @bool: Q(v,v) > bestbd
				od)
	     in if index.>=
	     	then DiracBestBD := bestbd; QG:=Q; true
		else false
		fi
	 fi
    then NumClasses = #eq
    then polNums = [int]:
    	 for C in eq
    	 do let (d,j) = coords(LF,C~[0]) {the tilde chooses a
	 representative on largest possible face, so least integral}
	    then verts = vec: LF[d][j][:d+1]
	    then gamma = face_bary(Lvd,verts)
	    then pC = parameter(x,lambda,gamma)
	    then PC = finalize(pC)

	    then KCF = K_type_pol(character_formula(PC))
	    in if (not temp_Dirac_best_flag) or (QG(gamma,gamma) <= DiracBestBD)
	       	  or DiracBestTest(pC,HT,KCF)
	       then ktp_hash.match(KCF)
	       else -1
	       fi
	 od
    then nLKT = #LKTs(parameter(x,lambda,0*lambda))
    then answer = for LFd@d in LF
       	 	  do for v@j in LFd
	  	     do let N = polNums[classListByFace[d][j]]
	     	     	then m = if nLKT = 1 or N.<
		     	then 1
		     	else #monomials(finalize(parameter(x,lambda,face_bary(Lvd,v[:d+1]))))
		     	fi
	      		in if N.>=
	      	 	   then [v##[N,m]]
		 	   else []
		 	   fi
	  	     od.##
       		  od
    then time = elapsed_ms() - start
    then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01_graph (vertex/edge K-chars)") fi
    in answer

{takes list of 0- and d-diml faces, with d \ge 1, and builds all
d+1-diml faces having all faces in the d-diml list. The int e is the
number of extra coords in each face.}
set superFaces([vec] L0, [vec] Ld, int e) =
    [vec]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [vec]:
   for v in L0
   do let m0 = v[0] {first vertex in new face}
      in [vec]:
      	 for small in Ld
      	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    elif any(for k:d+1 do lookupsd( m0#(small[:k]##small[k+1:d+1])) = -1 od)
	    then [] {require all d-faces to be in Ld}
	    else [m0#small[:d+1]] {now m0##small is a candidate face}
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFaces was ",
		      	print_time_string(elapsed_ms() - start))
          fi}
in answer
fi

{record also the locations in Ld of the d+2 faces in Ld from which each d+1 superface arises}
set superFaces_plus([vec] L0, [vec] Ld, int e) =
    [(vec,vec)]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [(vec,vec)]:
   for v in L0
   do let m0 = v[0] {first vertex in new face}
      in [(vec,vec)]:
      	 for small@look0 in Ld
      	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    else let look = vec:
	    	     for k:d+1
		     do lookupsd(m0#(small[:k]##small[k+1:d+1]))
		     od
	    	 in if look.>=
		    then [(m0#small[:d+1], look0#look)] {now m0##small is a candidate face}
		    else []
		    fi
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFaces was ",
		      	print_time_string(elapsed_ms() - start))
          fi}
in answer
fi

{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
(   {if face_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;}
    let G = x.real_form, start=elapsed_ms()
    then e = if red_count_flag
    	     then 3
	     else 2
	     fi
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do let lookup = if red_count_flag
	      	     	      then index_in(for v in LFKH[dim-1] do v[:dim] od)
			      else index_in([vec]:[])
			      fi
	      	 in LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],e)
	      	    	       	   in for (actual,locs) in acts {vec of size dim+1, coords of subs}
	       	    	      	      do let bary =
				      	     sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      	 then p0 = parameter(x,lambda, bary)
				      	 then P = finalize(p0)
				      	 then midreds = if red_count_flag
					      	      	then [red_count(p0)]
							else []
							fi
					 then subs = if red_count_flag
					      	     then for k:dim
					      	     	  do actual[:k]##actual[k+1:] {vec of size dim}
						     	  od
						     else []
						     fi
				      	 then k = if red_count_flag
					      	  then first(for i in locs
				      	       	     	do [LFKH[dim-1][i][dim]] = midreds
						     	od)
						  else -1
						  fi
				         then ms = monomials(P)
				      	 in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	    then if k.>=
					    	 then {prints(p0, ktp_hash.list()[LFKH[dim-1][locs[k]][dim]]);}
					      	      [actual##midreds##[LFKH[dim-1][locs[k]][dim+1], #ms]]
					 	 else {let startCF = elapsed_ms()}
					      	      let m = {char_counter.use();} ktp_hash.match(
						      	   K_type_pol(character_formula(P)))
					      	      {then () = charTime +:= elapsed_ms() - startCF}
					      	      in [actual##midreds##[m, #ms]]
						 fi {K-char matches a face}
		       		    	     else []
				    	     fi {pos on LKTs}
		    	      	   od.## {[FaceVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, e)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt to dim ",t-1) fi
    in if(face_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, face counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)


{takes local data to height level, dimension \le b-1, and adds faces from
b to (t-1)-dimensional FPP-faces; make sure subfaces are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t). This time
just calculate K characters to HT

Need to assume b \ge 2, so have a list of potentially unitary faces and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, LocalVertexData Lvd, [[FaceVertsKHash]] LFKH,
    int b, int t, int HT, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
(   if face_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;
    let G = x.real_form, start=elapsed_ms()
    then e = if red_count_flag
    	     then 3
	     else 2
	     fi
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do let lookup = if red_count_flag
	      	     	      then index_in(for v in LFKH[dim-1] do v[:dim] od)
			      else index_in([vec]:[])
			      fi
	      in LFKH := LFKH# (let acts = superFaces_plus(LFKH[0],LFKH[dim-1],e)
	      	    	       	in for (actual,locs) in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then midreds = if red_count_flag
					      	      	then [red_count(p0)]
							else []
							fi
				      then subs = if red_count_flag
					      	  then for k:dim+1
					      	       do actual[:k]##actual[k+1:] {vec of size dim}
						       od
						   else []
						   fi
				      	 then k = if red_count_flag
					      	  then first(for i in locs
				      	       	     	do [LFKH[dim-1][i][dim]] = midreds
						     	od)
						  else -1
						  fi
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then if k.>=
					      then [actual##midreds##[ LFKH[dim-1][locs[k]][dim+1], #ms]]
					      else {let startCF = elapsed_ms()
					      	   then () = char_counter.use()}
					     	   let m =  {char_counter.use();} ktp_hash.match(
						   	K_type_pol(character_formula_to_height(P,HT)))
					      	   {then () = charTime +:= elapsed_ms() - startCF}
					      	   in [actual##[m, #ms]]
					      fi {K-char matches a face}
		       		    	  else []
				    	  fi {pos on LKTs}
		    	      	   od.## {[FaceVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, e)
    {then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	       " for localFD_Khashbt to height ", HT, " and dim ",t-1) fi}
    in if(face_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, face counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)

set extend_K_characters(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FaceVertsKHash]]:
    {if face_verbose
    then prints(new_line,"start extend_K_characters")
    fi;}
    let G = x.real_form, start = elapsed_ms(), red_shift = if red_count_flag then 1 else 0 fi
    then answer =
       for d:#LFKH
       do if fund_face_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_face_verbose
	      	 then prints("examining face ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = face_bary(Lvd, v[:d+1]), w=v
		 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
		 {then startCF = elapsed_ms()}
	  	 then m = {char_counter.use();} ktp_hash.match(K_type_pol(character_formula(P)))
		 {then () = charTime +:= elapsed_ms() - startCF}
	  	 then () = w[d+red_shift+1] := m
		 in w
              od
      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters") fi
     in answer

set extend_K_characters(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, int ht, KTypePol_hash ktp_hash) =
    	[[FaceVertsKHash]]:
    if face_verbose
    then prints(new_line,"start extend_K_characters to height ",ht)
    fi;
    let G = x.real_form, start = elapsed_ms(), red_shift = if red_count_flag then 1 else 0 fi
    then answer =
       for d:#LFKH
       do if fund_face_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_face_verbose
	      	 then prints("examining face ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = face_bary(Lvd, v[:d+1]), w=v
		 {face_bary_ic(x.inner_class, face_bary(Lvd.list, v[:d+1]))}
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
		 {then startCF = elapsed_ms()}
	  	 then m = {char_counter.use();} ktp_hash.match(K_type_pol(character_formula_to_height(P,ht)))
		 {then () = charTime +:= elapsed_ms() - startCF}
	  	 then () = w[d+red_shift+1] := m
		 in w
              od
       od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters to ht ", ht) fi
     in answer

set extend_K_characters_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, KTypePol_hash ktp_hash, [[int]] eq, [vec] classListByFace) = [[FaceVertsKHash]]:
    {if face_verbose
    then prints(new_line,"start extend_K_characters")
    fi;}
    let G = x.real_form, start = elapsed_ms(), NumClasses = #eq
    then polNums = [int]: {these are indices in ktp_hash of new K-characters}
       for C in eq
       do let (d,j) = coords(LFKH,C~[0]) {the tilde chooses a
	  representative on largest possible face, so least integral}
	  then verts = vec: LFKH[d][j][:d+1]
	  then pC = parameter(x,lambda,face_bary(Lvd,verts))
	  then PC = finalize(pC)
	  {then startCF = elapsed_ms()}
	  then m = {char_counter.use();} ktp_hash.match(K_type_pol(character_formula(PC)))
	  {then () = charTime +:= elapsed_ms() - startCF}
	  in m
       od {C in eq}
     then answer = for LFd@d in LFKH
       	  	   do for j:#LFd
	  	      do let v = LFd[j]
		      	 then () = v[d+2] := polNums[classListByFace[d][j]]
		         in v
		      od {fix d-diml faces}
	  	   od {fix all faces}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters_graph") fi
     in answer

set extend_K_characters_graph(KGBElt x, ratvec lambda, LocalVertexData Lvd,
    [[FaceVertsKHash]] LFKH, int ht, KTypePol_hash ktp_hash, [[int]] eq, [vec] classListByFace) =
    	[[FaceVertsKHash]]:
    if face_verbose
    then prints(new_line,"start extend_K_characters_graph to height ",ht)
    fi;
    let G = x.real_form, start = elapsed_ms(), NumClasses = #eq
    then polNums = [int]: {these are indices in ktp_hash of new K-characters}
       for C in eq
       do let (d,j) = coords(LFKH,C~[0]) {the tilde chooses a
	  representative on largest possible face, so least integral}
	  then verts = vec: LFKH[d][j][:d+1]
	  then pC = parameter(x,lambda,face_bary(Lvd,verts))
	  then PC = finalize(pC)
	  {then startCF = elapsed_ms()}
	  then m = {char_counter.use();} ktp_hash.match(K_type_pol(character_formula_to_height(PC,ht)))
	  {then () = charTime +:= elapsed_ms() - startCF}
	  in m
       od {C in eq}
     then answer = for LFd@d in LFKH
       	  	   do for j:#LFd
	  	      do let v = LFd[j]
		      	 then () = v[d+2] := polNums[classListByFace[d][j]]
		         in v
		      od {fix d-diml faces}
	  	   od {fix all faces}
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters_graph") fi
     in answer
