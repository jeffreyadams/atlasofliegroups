<nilpotent_orbit_partitions.at { for |nilpotent_lambdas_classical|, |get_type| }

{lists of 1/2 h(O^\vee) for exceptional groups}

{ exceptional groups first }
{ nilpotent orbit given by labelled Dynkin diagram
  label c={0,1,2} on node i -> (c/2)*i^th fundamental weight }

set nilpotent_lambdas_G2=[ratvec]:
[[0,0],[0,1]/2,[1,0]/2,[1,0],[1,1]]

{ these are flipped from the table Carter due to the duality }

set nilpotent_lambdas_F4=[ratvec]:
[[0,0,0,0]
,[0,0,0,1]/2
,[1,0,0,0]
,[0,0,1,0]/2
,[1,0,0,0]
,[0,0,0,1]
,[0,1,0,0]/2
,[1,0,0,2]/2
,[0,1,0,1]/2
,[1,0,1,0]/2
,[0,0,1,0]
,[2,1,0,1]/2
,[0,0,1,1]
,[1,0,1,0]
,[1,0,1,1]
,[1,1,1,1]
]

set nilpotent_lambdas_E6=[ratvec]:
[[0,0,0,0,0,0]
,[0,1,0,0,0,0]/2
,[1,0,0,0,0,1]/2
,[0,0,0,1,0,0]/2
,[0,1,0,0,0,0]
,[1,1,0,0,0,1]/2
,[1,0,0,0,0,1]
,[0,0,1,0,1,0]/2
,[1,2,0,0,0,1]/2
,[1,0,0,1,0,1]/2
,[0,1,1,0,1,0]/2
,[0,0,0,1,0,0]
,[1,1,0,0,0,1]
,[0,1,0,1,0,0]
,[1,1,1,0,1,1]/2
,[2,1,1,0,1,2]/2
,[1,2,1,0,1,1]/2
,[1,0,0,1,0,1]
,[1,1,0,1,0,1]
,[1,1,1,0,1,1]
,[1,1,1,1,1,1]
]

set nilpotent_lambdas_E7=[ratvec]:
[[0,0,0,0,0,0,0]
,[1,0,0,0,0,0,0]/2
,[0,0,0,0,0,1,0]/2
,[0,0,0,0,0,0,1]
,[0,0,1,0,0,0,0]/2
,[1,0,0,0,0,0,0]
,[0,1,0,0,0,0,1]/2
,[1,0,0,0,0,1,0]/2
,[0,0,0,1,0,0,0]/2
,[2,0,0,0,0,1,0]/2
,[0,0,0,0,0,1,0]
,[0,1,0,0,0,0,0]
,[1,0,0,0,0,0,1]
,[0,0,1,0,0,1,0]/2
,[1,0,0,1,0,0,0]/2
,[0,0,1,0,0,0,0]
,[1,0,0,0,1,0,1]/2
,[1,0,1,0,0,0,0]
,[0,1,1,0,0,0,1]/2
,[0,0,0,1,0,1,0]/2
,[1,0,0,0,0,1,0]
,[0,0,0,0,1,0,0]
,[1,0,0,0,0,1,1]
,[2,1,1,0,0,0,1]/2
,[1,0,0,1,0,1,0]/2
,[2,0,0,1,0,1,0]/2
,[0,0,0,1,0,0,0]
,[1,0,0,1,0,2,0]/2
,[1,0,0,1,0,1,2]/2
,[1,0,0,0,1,0,0]
,[0,1,1,0,1,0,2]/2
,[0,0,1,0,0,1,0]
,[1,0,1,0,0,1,0]
,[0,0,0,1,0,0,1]
,[0,0,0,1,0,1,0]
,[2,1,1,0,1,1,0]/2
,[2,1,1,0,1,0,2]/2
,[1,0,0,1,0,0,1]
,[2,1,1,0,1,2,2]/2
,[1,0,0,1,0,1,0]
,[1,0,1,1,0,1,0]
,[1,0,0,1,0,1,1]
,[1,1,1,0,1,0,1]
,[1,1,1,0,1,1,1]
,[1,1,1,1,1,1,1]
]

set nilpotent_lambdas_E8=[ratvec]:
[[0,0,0,0,0,0,0,0]
,[0,0,0,0,0,0,0,1]/2
,[1,0,0,0,0,0,0,0]/2
,[0,0,0,0,0,0,1,0]/2
,[0,0,0,0,0,0,0,1]
,[0,1,0,0,0,0,0,0]/2
,[1,0,0,0,0,0,0,1]/2
,[0,0,0,0,0,1,0,0]/2
,[1,0,0,0,0,0,0,2]/2
,[0,0,1,0,0,0,0,0]/2
,[1,0,0,0,0,0,0,0]
,[1,0,0,0,0,0,1,0]/2
,[0,0,0,0,0,1,0,1]/2
,[0,0,0,0,0,0,1,0]
,[0,0,0,0,0,0,1,1]
,[0,0,0,0,1,0,0,0]/2
,[0,0,1,0,0,0,0,1]/2
,[0,1,0,0,0,0,1,0]/2
,[1,0,0,0,0,1,0,0]/2
,[1,0,0,0,0,0,0,1]
,[0,0,0,1,0,0,0,0]/2
,[0,1,0,0,0,0,1,2]/2
,[0,1,0,0,0,0,0,0]
,[1,0,0,0,0,1,0,1]/2
,[1,0,0,0,1,0,0,0]/2
,[1,0,0,0,0,1,0,2]/2
,[0,0,0,1,0,0,0,1]/2
,[0,0,0,0,0,1,0,0]
,[2,0,0,0,0,1,0,1]/2
,[0,0,0,1,0,0,0,2]/2
,[0,0,1,0,0,1,0,0]/2
,[0,1,0,0,0,0,0,1]
,[1,0,0,0,0,0,1,0]
,[1,0,0,0,0,0,1,1]
,[0,0,0,1,0,0,1,0]/2
,[1,0,0,1,0,0,0,1]/2
,[0,0,1,0,0,1,0,1]/2
,[0,1,1,0,0,0,1,0]/2
,[1,0,0,0,1,0,1,0]/2
,[0,0,0,1,0,1,0,0]/2
,[1,0,0,0,1,0,1,2]/2
,[0,0,0,0,1,0,0,0]
,[1,0,0,0,0,1,0,0]
,[0,1,1,0,0,0,1,2]/2
,[1,0,0,1,0,1,0,0]/2
,[0,0,0,1,0,1,0,2]/2
,[1,0,0,0,0,1,0,1]
,[0,0,0,0,1,0,0,1]
,[2,1,1,0,0,0,1,2]/2
,[1,0,0,0,0,1,1,1]
,[1,0,0,1,0,1,0,1]/2
,[1,0,0,1,0,1,1,0]/2
,[1,0,0,1,0,1,0,2]/2
,[2,0,0,1,0,1,0,2]/2
,[0,0,0,1,0,0,0,1]
,[1,0,0,0,1,0,0,1]
,[1,0,0,1,0,1,2,2]/2
,[0,1,1,0,1,0,2,2]/2
,[0,0,0,1,0,0,1,0]
,[2,1,1,0,1,1,0,1]/2
,[0,0,0,1,0,0,1,1]
,[2,1,1,0,1,0,2,2]/2
,[1,0,0,1,0,0,1,0]
,[1,0,0,1,0,0,1,1]
,[2,1,1,0,1,2,2,2]/2
,[1,0,0,1,0,1,0,1]
,[1,0,0,1,0,1,1,1]
,[1,1,1,0,1,0,1,1]
,[1,1,1,0,1,1,1,1]
,[1,1,1,1,1,1,1,1]
]

set nilpotent_lambdas_E (int n) = [ratvec]:
  case n-6 { case index counts from 0 }
  in nilpotent_lambdas_E6, nilpotent_lambdas_E7, nilpotent_lambdas_E8
  else error("wrong rank for type E")
  esac

set nilpotent_lambdas (RootDatum rd) = [ratvec]: { this assumes |rd| is simple }
  case type_number(rd)-4
  then nilpotent_lambdas_classical(rd)
  in { exceptional numbers 4..6 for E,F,G }
    nilpotent_lambdas_E(rank(rd)), nilpotent_lambdas_F4, nilpotent_lambdas_G2
  else error("Pure torus") { type_number=7 }
  esac
