{scripts to calculate Dirac inequality attached to a K-type}
{works only when rank(G) = rank(K)}

<basic.at
<K.at { for |K_0| }
<K_highest_weights.at { for |highest_weight| }
<hermitian.at { for |is_unitary| }
<K_types.at { for |branch_irr| }
<hash.at {for |make_KType_hash| }

{list of theta-stable positive systems for fundamental Cartan}
set thetaStable(RealForm G) = [KGBElt]:
    let delta = G.distinguished_involution
    then N = first(for x in KGB(G) do @bool: x.involution != delta od)
    in if N = -1
       then KGB(G)
       else KGB(G)[:N]
       fi

{corr K_0's in equal rank case}
set Ks(RealForm G) = [RealForm]:
    let delta = G.distinguished_involution in
    for x in KGB(G) do if x.involution = delta then [K_0(x)] else [] fi
    od.##

set fundxs = [KGBElt]: []
set ks = [RealForm]: []
set rhocs = [ratvec]: []
set rho = ratvec: []
set preppedDirac = false

set prepDirac(RealForm G) = void:
    let () = fundxs := thetaStable(G)
    then () = ks := Ks(G)
    then () = rhocs := for x in fundxs do rho_c(x) od
    then () = rho := G.rho
    then () = preppedDirac := true
    in ()

{list of PRV components of mu\otimes spin(s), equal rank case}
{one term for each x in fundamental fiber. Term for x is highest
weight for K_0(x) of PRV component of mu \otimes rho_n(x)^*, plus rho_c(x).
If K disconnected, each highest weight will lead to same DiracIC, so keep
only first. Maybe need to fix this for calculating Dirac cohomology?}
set muPRVs(KType mu) = [ratvec]:
    if preppedDirac
    then let muth = for x in fundxs do highest_weights(mu,x)[0].mu od
    	 in for mu@j in muth do dominant(ks[j], mu + rhocs[j] - rho) + rhocs[j] od
    else let Xth = thetaStable(mu.real_form), ks=Ks(mu.real_form), rhoo = rho(mu.real_form)
	 then muth = for x in Xth do highest_weights(mu,x)[0].mu od
	 in for mu@j in  muth do dominant(ks[j], (mu + rho_c(Xth[j]) - rhoo))+rho_c(Xth[j])  od
    fi

{rewrite to remember answers that have already been computed}
set muPRVs_remember = (KType -> [ratvec]):
    let muhash = make_KType_hash() {list of known KType's}
    then answers = [[ratvec]]: [] {list of answers for each known KType, start with empty list}
    in (KType -> [ratvec]): (KType mu) [ratvec]:
    let I = muhash.size()  {size() is a function attached to muhash, takes no argument}
    then i = muhash.match(mu) {match@KType is a function attached to muhash, "adds" KType to list}
    then () = if i=I
    	      then let answer = if preppedDirac
    	      	   	      then let muth = for x in fundxs
		   	    	       	      do highest_weights(mu,x)[0].mu
				   	      od
    	 			   in for mu@j in muth
				      do dominant(ks[j], mu + rhocs[j] - rho) + rhocs[j]
			   	      od
    	      		       else let Xth = thetaStable(mu.real_form),
				     	 ks=Ks(mu.real_form), rhoo = rho(mu.real_form)
	      	   		     then muth = for x in Xth do highest_weights(mu,x)[0].mu od
	 	   		     in for mu@j in  muth
		      		     	do dominant(ks[j], (mu + rho_c(Xth[j]) - rhoo))+rho_c(Xth[j])
		      			od
    	       		       fi
		     in answers #:= answer
	        fi
      in answers[i]

set DiracICtime = int:0

{meant to hold all K-types whose DiracIC's have been computed...}
set KTypeHash = make_KType_hash()

{...and the corresponding computations}
set DiracICs = [ratvec]:[]

{Dirac infl char estimate for mu, equal rank case}
set DiracIC(KType mu) = ratvec:
    	let start = elapsed_ms()
	then j = KTypeHash.match(mu)
	in   if j < #DiracICs
	     then let () =  DiracICtime := DiracICtime + elapsed_ms() - start
	     	  in DiracICs[j]
	     else let mutildes=muPRVs(mu), G= mu.real_form
	     	  then rhocheck = rho_check(G)
	     	  then ics= for muprime in mutildes do dominant(G,muprime) od
	     	  then minloc = min_loc(for ic in ics do ic*rhocheck od)
	     	  then () = DiracICs := DiracICs#ics[minloc]
	     	  then () = DiracICtime := DiracICtime + elapsed_ms() - start
		  in ics[minloc]
	     fi

{this calculates all unitary reps containing mu for which mu
contributes to Dirac cohom}
set DiracCoh(KType mu) = [Param]:
    let ic =  DiracIC(mu), G= mu.real_form
    then ht = rat_as_int(2*ic*rho_check(G)), allic = all_parameters_gamma(G,ic)
    in
	for p in allic do
    	if height(p) <= ht then
	      if is_unitary(p) and branch_irr(p,ht)[mu] != 0
	      then [p]
	      else []
	      fi
	else break
	fi od.##
