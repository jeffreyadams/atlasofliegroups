<character_table_reps.at
{<springer_tables.at}{moved stuff requiring springer tables to cells_springer.at}
{this file does not require springer_tables.at}

set W_cell(Param p)=(int,WCell):
let (index,cells)=W_cells(p) then
j=first(for i:#cells do let (param_indices,)=cells[i] in find(param_indices,index)>=0 od) then
(tau,g)=cells[j] in
(index,(tau,(p.integrality_datum,g)))

set W_cell_of(Param p)=WCell:let (,c)=W_cell(p) in c

{assuming block and cells are already computed:}
set W_cell([Param] block,[WCell] cells,Param p)=(int,WCell):
let index=find(block,p) then
cell_number=first(for (param_numbers,)@i in cells do find(param_numbers,index)>=0 od) in
(index,cells[cell_number])

set W_cell_of([Param] block,[WCell] cells,Param p)=WCell:
let (,c)=W_cell(block,cells,p) in c


{ ----------- cell representations --------------}
{{moved from character_table_reps.at}}

{. character of representation of W on cell .}
set cell_character (CharacterTable ct,WCell cell) = [int]:
  for w in ct.class_reps do trace(cell_action(cell,w)) od

set cell_character(CharacterTable ct)=(WCell -> [int]):(WCell cell):cell_character(ct,cell)
set cell_characters (CharacterTable ct,[WCell] cells) = [[int]]:
  for cell in cells do cell_character(ct, cell) od

set cells_table (CharacterTable ct,[WCell] cells) = mat:
  matrix_of_inner_products(ct,cell_characters(ct,cells))

set cells_table_augmented (CharacterTable ct, [WCell] cells) = mat:
  let characters =
    cell_characters(ct,cells) ## [ ct.trivial, ct.sign, ct.reflection ]
  in matrix_of_inner_products(ct,characters)

set cell_representation (CharacterTable ct,WCell cell) = W_rep:
  (#cell.graph,
   for i:ct.lie_type.semisimple_rank
   do unsparse(cell_action(cell,i),#cell.graph) od)

{ list of representations defined by an array of cells }
set cell_representations(CharacterTable ct,[WCell] cells)=[W_rep]:
  for cell in cells do cell_representation(ct,cell) od

{smallest_degree_summands is in character_tables.at}
{NOTE: need to incorporate the permutation relating ct.root_datum and cell.root_datum}
{note that ct.root_datum must be (isomorphic to) cell.root_datum,
 which is the integrality_datum of a parameter}
set special_character(CharacterTable ct,WCell cell)=
let (valid,P)=root_permutation(ct.root_datum.derived,cell.root_datum.derived) in
assert(valid,"No root system isomorphism");
let summands=smallest_degree_summands(ct,ct.decompose(cell_character(ct,cell,P)))
in if #summands>1 then error("not unique special representation")
   elif #summands=0 then error("no special summands?")
   else summands[0]
   fi
set special_character(CharacterTable ct)=(WCell->int):(WCell cell):
  special_character(ct,cell)

set special_character(CharacterTable ct,[int] cell_character)=
let summands=smallest_degree_summands(ct,ct.decompose(cell_character)) in
if #summands>1 then error("not unique special representation") elif
#summands=0 then error("no special summands?") else summands[0] fi
{set special_character(CharacterTable ct)=([int]->int):
 ([int] cell_character):special_character(ct,cell_character)}

set cells_verbose=false

set #(WCell cell) = int: #cell.labels { should also equal |#cell.graph| }

set parameters([Param] block,WCell cell)=[Param]:
  let (labels,)=cell in for i in labels do block[i] od

set parameters([Param] block,[WCell] cells)=[Param]:
##for cell in cells do parameters(block,cell) od

set parameters([([Param],[WCell])] data)=[Param]:
##for i:#data do parameters(data[i]) od


{ expand and partition set of params into blocks }
set blocks ([Param] params) = [[Param]]:
   let block_list = [[Param],ParamPol]: {second component for quick search } []
in for p in params
   do if for (,P) in block_list do =P[p] od.all
      then let B=block_of(p) in block_list #:= (B,p.null_module+B)
      fi
   od; for (B,) in block_list do B od

{ W_cells@Param is built-in, returns the number in cell which we ignore here }
set blocks_and_cells([Param] params) = [[Param],[WCell]]:
  for B in blocks(params)
  {caution: b and block_of(b[0]) might not be in the same order (MvL really??) }
  {if not, one can do simpler: |do let (,cell)=W_cells(b[0]) in (b,cell) od| }
  do let cell=W_cells_of(B[0]) in (B,cell) od

set blocks_and_cells (Param p) = [[Param],[WCell]]: blocks_and_cells(block_of(p))

{ locate a given parameter in structure returned from |blocks_and_cells| }
set find ([[Param],[WCell]] blocks_and_cells, Param p) = (int,int):
for (block,cells)@i in blocks_and_cells
do for cell@j in cells
   do if find(parameters(block,cell),p).>= then return (i,j) fi
   od
od; (minus_1,minus_1)

set push ([Param] params, ratvec gamma) = [Param]:
  for p in params do coherent_family_irr(p,gamma).monomials { zero or one |Param| } od.##

set cell_members_given_descent (RootDatum rd, WCell (,graph), [int] S) = [int]:
   let target = complement(rd.semisimple_rank,S) { so S is desired ASCENT set? }
in for (tau,)@i in graph.nodes do if tau=target then [i] else [] fi od.##

{given cell, gamma, dim_special, reject the cell
unless #cell>=dim_special and
some parameter p in cell has tau_complement(p)=singular roots on gamma}
set potential_cell(RootDatum rd_int,WCell cell, ratvec gamma, int springer_dim)=bool:
if #cell< springer_dim then prints("dim: ", #cell, " ", springer_dim);false
elif
 let singular_roots=##for alpha@i in rd_int.simple_roots do if =alpha*gamma then [i] else [] fi od in
 let ()=prints("sr: ", singular_roots) in
 let a= any(let (,(,graph))=cell in for i:#cell do let (tau,)=graph[i] in prints("tau: ",tau);tau=singular_roots od)
 in prints("a=",a);not a then false
else true
fi

set show([WCell] cells)=void:
for (cell,)@i in cells do prints(i, " ", cell) od;
for (cell,(,graph))@i in cells do
prints("// cell #",i, ":");
tabulate(
 for (a,b)@i in graph do
 let arrows=b in
  [i.to_string + "[" + cell[i].to_string + "]" + ":",
  a.to_string,
  "-->",
  let m=if #arrows=0 then 1 else max(for (,y) in arrows do y od) fi  in
if m=1 then (for (x,y) in arrows do x od).to_string else
 (for (x,y) in arrows do (x,y) od).to_string
fi
] od)
  od


{

// cell #14:
0[45]: {1,2} --> 3
1[47]: {1,2} --> 3
2[49]: {2,3} --> 3
3[51]: {1,3} --> 0,1,2


Value: 16
atlas> cells[14]
Value: ([45,47,49,51],[([0,1],[(3,1)]),([0,1],[(3,1)]),([1,2],[(3,1)]),([0,2],[(0,1),(1,1),(2,1)])])
}

{------------------- fake degrees ----------------}


set fake_degrees(CharacterTable ct,[WCell] cells)=[int]:
let rv=for i:ct.n_classes do -1 od in
for cell in cells do
 let cell_char=ct.decompose(ct.cell_character(cell)) then
 ()=prints("cell_char: ", cell_char) then
 special_char=special_character(ct,cell) then
 ()=prints("special_char: ", special_char) then
 special_fake_degree=ct.degree(special_char) then
 ()=prints("sfd: ", special_fake_degree) in
 for i:ct.n_classes do
  if cell_char[i]!=0 then rv[i]:=special_fake_degree fi
 od
od;rv

set update_fake_degrees(CharacterTable ct,[WCell] cells)=CharacterTable:
ct.fake_degrees:=fake_degrees(ct,cells);ct

set show_degrees(CharacterTable ct)=void:
let fake_degree(int i)=if #ct.fake_degrees=0 then -1 else ct.fake_degrees[i] fi in
prints("a(i)=fake degree(character #i)",new_line,"b(i)=degree(character #i)",new_line,"*: special",new_line);
tabulate(
["i","dim","a(i)","b(i)"]#
for i:ct.n_classes do
{don't know special_representation_star without springer table}
[i.to_string,ct.dimension(i).to_string{+ct.special_representation_star(i)},ct.fake_degrees[i].to_string,ct.degree(i).to_string] od)
