{ the functions in this file have not been carefully checked }

<misc.at
<kl.at
set translate_debug=false

{
  translate Param p, at infinitesimal character gamma,
  to new infinitesimal character gamma_new
  assumes gamma,gamma_new are dominant, shift=gamma_new-gamma is integral
  replaces (x,lambda,nu) with (x,lambda+shift,nu+shift)
  if gamma,gamma_new are regular, p and T(p,gamma_new) will have
    identical block structure
  if gamma is regular and gamma_new is singular, block of T(p,gamma_new)
    will be a quotient of block at gamma
  if gamma or gamma_new is not dominant, no guarantees (but no test either)
}
set translate_by (Param p, vec shift) = ParamPol:
  let (x,lambda_rho,gamma)=%p in finalize(param(x,lambda_rho+shift,gamma+shift))
set T(Param p, ratvec gamma_new)= ParamPol:
  translate_by(p,ratvec_as_vec(gamma_new-infinitesimal_character(p)))

{ translate a ParamPol by translating each term }
set T(ParamPol P, ratvec gamma_new)= ParamPol:
  if =P then P { without any terms, there is nothing to change }
  else
    let gamma = infinitesimal_character(first_param(P))
    then shift = ratvec_as_vec(gamma_new-gamma)
    then rv= 0*P in
    for w@q in P do rv+:=w*translate_by(q,shift) od;rv
  fi

set to_wall (RootDatum id, int k, ratvec gamma) = vec:
  let (n,d)=%(fundamental_weight(id,k)*(coroot(id,k)*gamma))
  in assert(d=1,"cannot project to wall "+k); n

{ translate parameter p to simple root wall #k of the integral root system }
set Psi(Param p,int k)= ParamPol:
  let gamma=infinitesimal_character(p)
  then id = integrality_datum(root_datum(p),gamma)
  then shift = -to_wall (id,k,gamma)
  in translate_by(p,shift)

{ when all terms has same infinitesimal character, this is more efficient: }
set Psi(ParamPol P,ratvec gamma,int k)= ParamPol:
  let id = integrality_datum(root_datum(P),gamma)
  then shift = -to_wall (id,k,gamma) then
  rv=null_module(P.real_form) in
    for w@q in P do rv+:=w*translate_by(q,shift) od;rv

{ translate p to intersection of set of simple root walls of integral system }
set Psi(Param p,[int] v)= ParamPol:
  let gamma=infinitesimal_character(p)
  then id=integrality_datum(root_datum(p),gamma)
  then shift = - sum( rank(id) # for k in v  do to_wall(id,k,gamma) od )
  in translate_by(p,shift)

{ translate P to intersection of set of simple root walls of integral system }
set Psi(ParamPol P,[int] v)= ParamPol:
  let rv=null_module(real_form(P))  in
  for w@q in P do rv+:=w*Psi(q,v) od;rv

set Psi(ParamPol P,ratvec gamma,[int] v)= ParamPol:
  let id = integrality_datum(root_datum(P),gamma)
  then shift = - sum( rank(id) # for k in v  do to_wall(id,k,gamma) od )
  then rv= null_module(real_form(P))  in
   for w@q in P do rv+:=w*translate_by(q,shift) od;rv

{true if translation of irreducible parameter p to gamma is non-zero}
{set I_will_survive_int(Param p,ratvec gamma)=bool:
let rd=p.root_datum then
tau=p.tau in
all(for i:rd.ss_rank do  rd.simple_coroots[i]*gamma != 0 or find(tau,i)=-1 od)}

set I_will_survive_int(Param p,ratvec gamma)=bool:
let rd=p.root_datum then
tau=p.tau in
all(for i:rd.ss_rank do  rd.simple_coroots[i]*gamma != 0 or find(tau,i)=-1 od)

{corrected version handles non-integral infinitesimal character
true if translation of irreducible parameter p to gamma is non-zero}
set I_will_survive(Param p,ratvec gamma)=bool:
let rd=p.root_datum then
rd_int=integrality_datum(rd,gamma) in
all(for i:rd_int.ss_rank do  rd_int.simple_coroots[i]*gamma != 0 or not is_descent(i,p) od)


set T_irr(Param p,ratvec v)=ParamPol:
{has to be a ParamPol to allow for 0
 result is either 0 or a single parameter
}
{return p if v=infinitesimal character of P}
if p.infinitesimal_character=v then p
elif
{p.infinitesimal character is automatically dominant,
if v is also dominant then we're staying in the chamber,
and T_irreducible(p) is simply shifting the parameter,
just like for a standard module, except that
the result is 0 iff: <alpha^vee,lambda>=0 where
alpha is a simple root in the tau-invariant of p}
is_dominant(p.root_datum,v) then
{ if  any (for j in tau(p) do p.root_datum.simple_coroots[j]*v=0 od) 
  then null_module(p.real_form) 
  else T(p,v)}
if I_will_survive(p,v) then T(p,v) else null_module(p.real_form)
fi
else
{hard case: could be crossing a wall}
composition_series(T(character_formula(p),v)) fi

{return an actual Param if nonzero}
set T_irr_nonzero(Param p,ratvec v)=Param:
let P=T_irr(p,v) in
assert(#P!=0,"module is 0");
assert(#P=1,"module is not irreducible");
first_param(P)

{translate an irreducible from singular to regular}
{move an irreducible parameter to regular infinitesimal character}
set make_regular_irr(Param p)=Param:T_irr_nonzero(p,p.infinitesimal_character +2*rho(p.root_datum))

{ translate a ParamPol by translating each term }
set T_irr(ParamPol P, ratvec gamma_new)= ParamPol:
  if =P then P { without any terms, there is nothing to change }
  else
    let rv=0*P in
{    let gamma = infinitesimal_character(first_param(P))
    then shift = ratvec_as_vec(gamma_new-gamma) 
    for w@q in P do rv+:=w*T_irr(q,shift) od;rv}
     for w@q in P do rv+:=w*T_irr(q,gamma_new) od;rv
  fi


{ the "pseudo-tau" invariant }
{ this is a subset of simple integral roots such that:
  1) one can translate to this wall (i.e., the requisite translation is in X^*)
  2) this translation is 0
  If G is simply connected this should be the usual tau_invariant
  Example: the trivial representation of SO(3), the unique simple root
  is in the pseudo-tau invariant, but you can't translate to the wall,
  since rho is not in the root lattice

  root k of the integral roots is in pseudo-tau(p) if
  <gamma,alpha_k^v>*fund_weight is integral, and
  Psi(p,k)=0 or its x(Psi(p,k)) gets changed by finalize
  (here Psi(p,k) is the translation of the standard module for p)
}

set pseudo_tau_bitset (Param p)= (int,(int->bool)):
  let gamma = infinitesimal_character(p)
  then id=integrality_datum(real_form(p),gamma)
  in
  ( semisimple_rank(id)
  , (int k): let (n,d)=%(fundamental_weight(id,k)*(coroot(id,k)*gamma))
    in d=1 and
      (let p0=first_param(translate_by(p,-n))
       in is_zero(p0) or x(p0)!=x(first_param(ParamPol:p0)))
  )

{ set of integers, defining a subset of the simple integral roots }
set pseudo_tau (Param p) = [int]: list(pseudo_tau_bitset(p))

{ set of integers, defining a subset of the simple integral roots }
set pseudo_tau_complement (Param p)= [int]: complement(pseudo_tau_bitset(p))

{ push Param p to the most singular place where the irreducible is non-zero,
  i.e. to all of the root walls not in the pseudo_tau_invariant
}
set make_maximally_singular (Param p)= ParamPol: Psi(p,pseudo_tau_complement(p))

{
  translate each term in a list of parameters to all the simple root walls
  not in its tau_invariant, and test if it is unitary.
  The even special unipotents of G should (all?) show up this way, varying
  over all blocks at rho
}
{set test_even_unipotent (Param p)= void:
( let q=make_maximally_singular(p)
  then Q=hermitian_form_irreducible(q)
  in
  prints(""); prints("original parameter: ",p)
; prints("translated parameter: ",q,", ", infinitesimal_character(q))
; prints("translated irreducible is unitary: ",is_unitary(Q))
; if translate_debug then prints(Q.pol_format) fi
)

{ test_even_unipotent of a list of parameters }
set test_even_unipotent ([Param] params)= void:
  for p in params do  test_even_unipotent(p) od
}
