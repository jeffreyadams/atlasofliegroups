{		computing coherent continuations		}

<basic.at
<translate.at { for translation functor T@(Param(Pol),ratvec) }
<W_orbit.at


{ ------------ Cayleys as sums of one or two terms ---------- }

{ Cayley transform as a sum of one or two terms }
set Cayley_sum (int k,Param p) = ParamPol:
  let c1=Cayley(k,p) then c2=cross(k,c1) in
  if c1=c2 then c1 else c1+c2 fi

{ -----------coherent continuation in basis of standards----------- }

{ DANGEROUS BEND
  all versions of coherent continuation action are right actions
     (u*w).p = w*(u*p)
  therefore the reflection arguments are written to the right
     coherent_std_reg(p,w*u)=coherent_std_reg(coherent_std_reg(p,w),u)
  this ultimately comes down to the inverse on pages 460-461
  of Vogan's big green book
}

{ coherent continuation action of integrally simple root |s| on Param |p|
  in basis of standards; |s| is simple index in the *integrality* root datum }

set coherent_std (Param p,int s) = ParamPol:
{ we need the |integrality_datum| on the fly since |status(s,p.x)| would wrongly
  interpret |s| as index into full root system. Here use |status@(vec,KGBElt)| }
  let type=status(p.integrality_datum.simple_roots[s],p.x) in
  if   type=1 { compact imaginary }     then -p
  elif type=3 { non-compact imaginary } then Cayley_sum(s,p)-cross(s,p)
  else        { complex or real }            cross(s,p)
  fi

{ coherent continuation action of simple root on ParamPol in basis of standards
  regular case
}
set coherent_std (ParamPol P,int s) = ParamPol:
  sum(P.real_form,for coeff@p in P do coeff*coherent_std(p,s) od)

{ coherent continuation action of Weyl group on Param in basis of standards
  see the dangerous bend above; this applies [a1,a2,...,an] in
  the order ( . * a1 * a2 * ... * an )
  this applies to all other invocations of coherent_*
}
set coherent_std (Param p,[int] w) = ParamPol:
  let P=p.as_pol in for s in w do P:=coherent_std(P,s) od; P

set coherent_std (Param p,WeylElt w)=ParamPol:coherent_std(p,w.word)

{ coherent continuation action of Weyl group on ParamPol, basis of standards }
set coherent_std (ParamPol P,[int] w) = ParamPol:
  for s in w do P:=coherent_std(P,s) od; P


{arguments in other order gives the same action:}
set coherent_std (WeylElt v,Param p)=ParamPol:coherent_std(p,v.word)
set coherent_std (WeylElt v,ParamPol P)=ParamPol:coherent_std(P,v.word)

{ ------------coherent continuation in basis of irreducibles------------ }

{ coherent continuation of simple root on Param in basis of irreducibles }
set coherent_irr (Param p,int s) =
  composition_series(coherent_std(character_formula(p),s))

{ coherent continuation of Weyl group element on Param, basis of irreducibles }
set coherent_irr (Param p,[int] w)=
  composition_series(coherent_std(character_formula(p),w))
set coherent_irr (Param p,WeylElt w)=ParamPol: coherent_irr(p,w.word)

{ coherent continuation of simple root on ParamPol, basis of irreducibles }
set coherent_irr (ParamPol P,int s) = ParamPol:
  composition_series(coherent_std(character_formula(P),s))

{ coherent continuation of Weyl group element on ParamPol in
  basis of irreducibles }
set coherent_irr (ParamPol P,[int] w) = ParamPol:
  composition_series(coherent_std(character_formula(P),w))
set coherent_irr (ParamPol P,WeylElt w) = ParamPol: coherent_irr(P,w.word)

{ ---------------------------coherent families------------------------------ }

set coherent_family_irr (ParamPol P, ratvec gamma_target)=ParamPol:
  if is_dominant(root_datum(P),gamma_target) then T_irr(P,gamma_target)
  else let (w,gamma_target_dominant)=from_dominant(root_datum(P),gamma_target) in
    T_irr(coherent_irr(P,w.word),gamma_target_dominant)
    {this translation is within the dominant chamber}
 fi
