<basic.at
<convert_c_form.at
<hash.at {for KTypePol_hash}
<count.at {for unitary_test_counter}
<time.at {for print_time_string}
<cohom_reductionND {for derived_factor_params}
<FPP_faces_geom {for herm_center}{get charTime!}{FPP_def_count}
<writeFiles {for write commands}
<deform.at {for script full_deform}
<kl.at {for def_low}

set deformLookupCounter = make_counter()
set deformCalcCounter = make_counter()
set twistedDeformLookupCounter = make_counter()
set twistedDeformCalcCounter = make_counter()

{typewise_pure(c_form) is a necessary condition for purity of hermitian form, and rules out a lot}
set is_typewise_pure(KTypePol P) = bool:
    all(for c@tau in P do is_pure(c) od)

{let p = pmax(x,lambda,nu) be the FPP parameter of biggest infl char gamma;
and write LAM = height(pmax), GAM = height(gamma), R = height(rho).}

{when bottom_layer is used at (x,lambda), more_shift is set to shift_frac*(GAM - LAM)}
{DECREASING means less deep bottom layer, which is faster but catches less non-unitarity}
{a little experimentation suggested that shift_frac about 1 would capture almost all the
non-unitarity that it's possible to capture with bottom layer; but that is expensive in time.}
set shift_frac = rat: 1/3

{the integer more_shift, controlling shifts for non-minimal
parabolics, is bounded by min_ht_mult times the shift for the minimal
(classification) parabolic.}
set min_ht_mult = rat: 2/1

{bottom layer is used only when LAM/GAM  < LAGAmax...}
{should be in [0,1]}
set LAGAmax = rat: 3/4

{... and GAM/R + LAM/GAM > GARLAGmin}
{should be in [0,2]}
set GARLAGmin = 1/1

{more_shift invoked when when GAM/R > GARmin}
set GARmin = rat: 3/5

set LARmax = rat: 4/5
set LAGAmin = 1/1
set LARmin = rat: 1/2


set status_time = int: 0
set status_count = int: 0
{next three global variables concern function is_unitary_test_big_SIMPLE_interrupt in FPP_faces_herm.at}
set up_mu_time = int:0
set mu_time_mult = rat: 1/1 {1/1}

{it "true" use up_mu_hash to calculate heights for is_unitary_to_ht}
{set up_mu_flag = false {true}}

{multiple of G.rank to use as jump in step size}
set mu_rank_mult = rat: 1/2 {1/4}

{how far above LKT to start is_unitary_to_ht tests}
set edge_offset = int: 1

{when the non-minimal parabolics are used at the end, how much above
height(p) to look at K-types.  A larger number finds more nonunitary,
takes longer}
set more_shift_level = int: 0

set test_bl_time = int: 0

set test_no_unitary_time = int: 0

set test_no_Dirac_time = int: 0

{how often deforming location succeeds in proving unitary}
set hash_def_true_count = int: 0

{how often deforming location succeeds in proving nonunitary}
set hash_def_false_count = int: 0

set def_thruples_time = int:0

{if true, try to raise mu in few steps to minimize number of to_ht calculations}
set max_loc_flag = true

{records how many pairs (x,lambda) are skipped because all Params are
indefinite on LKTs.}
set none_count = int:0

set hash_real_dumbCounter = make_counter()
set hash_dumbCounter = make_counter()
set hash_def_dumbCounter = make_counter()
set hashCounter = make_counter()
set hash2Counter = make_counter()
set hash_one_levelCounter = make_counter()
set hash_bottom_layerCounter = make_counter()
set hash_steveCounter = make_counter()

{initial time to give interruptible command}
set interrupt_base_time = int: 100 {was 200 before 7/24/25; sometimes 500...}

{ the next type is the same as |Maybe<KTypePol>|, but injector names differ }
set_type maybe_KTP = (void timed_out | KTypePol done)

set_type maybe_PP =  (void timed_out_PP | ParamPol done_PP)

{to record time spent in is_unitary, is_unitary_to_ht, etc.}
set unitaryTime = int: 0

set predictor_verbose =false
set predictor_flag = false {evening 12/21/25; was false until 12/19, when something went wrong}
set predictor_time = int:0

set to_ht (KTypePol P,int N) = KTypePol:
  if N<0 then return P fi;
  let (below,)=height_split(P,N) in below

set to_ht(maybe_KTP P,int N) = maybe_KTP:
    if N < 0 then return P fi;
    case P
    | timed_out: timed_out()
    | done(r): done(to_ht(r,N))
    esac

{Each KL_sum_at_s(Param) will be hashed only to some maximum height; full KL_sum_at_s is hashed by library}
set_type
[KL_sum_hash_table =
( (->int) param_size {number of parameters included}
  , (Param->int) max_ht {largest height to which KL_sum_at_s is hashed}
  , ((Param,int)->ParamPol) entry {KL_sum_at_s_to_height}
  , ((Param,int,int)->maybe_PP) maybe_entry {KL_sum_at_s_to_height}
  , (->Param_hash) paramhash
  , (->vec) max_hts
  , (->) clear
)
]

set make_KL_sum_hash_table() = KL_sum_hash_table:
( let paramhash = make_Param_hash()
  then KL_sums = [ParamPol]:[] {one for each p in Param_hash}
  then max_hts = vec:[] {one for each p in Param_hash}
  then clearKLSH() = void:
       paramhash.clear();
       KL_sums:=[];
       max_hts:=[]
  then add_param(Param p, int HT) = int: {index in Param_hash; HT MUST be >= 0}
       let N = paramhash.size()
       then n = paramhash.match(p)
       in if n=N or max_hts[n] < HT
       	  then let PP = KL_sum_at_s_to_height(p,HT)
	       in if n=N
	       	  then max_hts #:=HT;
	       	  KL_sums #:=PP
	     	  else max_hts[n]:=HT;
	       	  KL_sums[n]:=PP
	     	  fi
	  fi;
	  n
  then maybe_add_param(Param p, int HT, int time) = int: {index in Param_hash; HT >= 0}
       let N = paramhash.size()
       then n = paramhash.lookup(p)
       in if n<0 or max_hts[n] < HT
       	  then let mPP = KL_sum_at_s_to_height(p,HT,time)
	       in case mPP
	       	  | timed_out_PP: -1
	     	  | done_PP(PP): if n < 0
	       		 then max_hts #:=HT;
			      KL_sums #:=PP;
			      n:=N
			 else max_hts[n]:=HT;
			      KL_sums[n]:=PP
			 fi;
			 n
		   esac
	   else n
	   fi
   in
   ( (->int): {param_size} @int: paramhash.size()
   , (Param->int): {max_ht} (Param p):
     let n = paramhash.lookup(p)
     in if n < 0
     	then -1
	else max_hts[n]
	fi
   , ((Param,int)->ParamPol): {entry} (Param p, int HT):
     to_ht(HT)(KL_sums[add_param(p,HT)])
   , ((Param,int,int)->maybe_PP): {maybe_entry} (Param p, int HT, int time):
     let n = maybe_add_param(p,HT,time)
     in if n < 0
     	then timed_out_PP()
     	else to_ht(HT)(KL_sums[n]).done_PP
	fi
   , (->Param_hash): {paramhash} @:paramhash
   , (->vec): {max_hts} @:max_hts
   , (->): {clear} clearKLSH
   )
)

set KLsumhash = make_KL_sum_hash_table()

set KL_sum_at_s_to_ht(int HT) = (Param p) ParamPol:
    if HT < 0 then return KL_sum_at_s(p) fi;
    if low_char(p,HT)
    then KLsumhash.entry(p,HT)
    else let (below,) = height_split(KL_sum_at_s(p),HT), middle = elapsed_ms()
    	 in below
    fi
{
	 then notoht = middle - start
	 then other = KL_sum_at_s_to_height(p,HT)
	 then toht = elapsed_ms() - middle 
       	 in if toht < notoht - 5
	    then prints("At ",p," ",HT,"toht = ",toht,", notoht = ",notoht)
	    fi;
	    below
}
  {let P = KL_sum_at_s_to_height(p,N) in}
{
  if low_char(p,HT)
  then KL_sum_at_s_to_height(p,HT)
  else let (below,) = height_split(KL_sum_at_s(p),HT)
       in below
  fi
}

set KL_sum_at_s_to_ht_inter(int HT) = (Param p,int time) maybe_PP:
    if  HT < 0 then return KL_sum_at_s(p).done_PP fi;
    if low_char(p,HT)
    then KLsumhash.maybe_entry(p,HT,time)
    else let (below,) = height_split(KL_sum_at_s(p),HT)
    	 in below.done_PP
    fi
{
let start = elapsed_ms()
    	 then (below,) = height_split(KL_sum_at_s(p),HT), middle = elapsed_ms()
	 then other = KL_sum_at_s_to_height(p,HT)
	 then toht = elapsed_ms() - middle 
    	 in if toht < notoht - 5
	    then prints("At ",p," ",HT,"toht = ",toht,", notoht = ",notoht)
	    fi;
	    below.done_PP
}

set twisted_KL_sum_at_s_to_ht(int HT) = (Param p) ParamPol:
    if HT < 0 then return twisted_KL_sum_at_s(p)
    else let (below,) = height_split(twisted_KL_sum_at_s(p),HT)
    	 in below
    fi
  {to_ht(N)(twisted_KL_sum_at_s(p))}

{set to_ht (ParamPol P,int N) = ParamPol:
  if N<0 then return P fi;
  let (below,)=height_split(P,N) in below}


set character_formula_to_ht(Param p, int HT) = ParamPol:
    if HT.< then return character_formula(p) fi; 
    if not low_char(p,HT)
    then let (below,) = height_split(character_formula(p),HT)
    	 in return below  {again this counts and records time}
    else let start = elapsed_ms()
    	 in s_to_1(KL_sum_at_s_to_ht(HT)(p)) next charTimeToHt+:= elapsed_ms() - start; char_counter_to_ht.use()
    fi

set character_formula_to_ht (ParamPol P, int HT) = ParamPol:
    map(((Param->ParamPol): (Param p): character_formula_to_ht(p, HT)), P)

set composition_series_to_ht(ParamPol P, int HT) = ParamPol:
  if HT.< then return composition_series(P) fi;
  let (PHT,) = height_split(P,HT)
  in null_module(P)+
  while !=PHT { non null module }
  do let (coef,p):term=first_term(PHT)
     in PHT -:= coef*character_formula_to_ht(p,HT)
     ; term
  od

set composition_series_to_ht (Param p,int H) = ParamPol: composition_series_to_ht(ParamPol: p, H)

{take a KTypePol _apparently_ attached to G and make it _actually_ attached
to G. Need this to use looked-up deformations.}
set regroup(RealForm G, KTypePol P) = KTypePol:
    sum(G, for c@q in P do let (,m) = %q.x
    	   in c*K_type(KGB(G,m), q.lambda_minus_rho) od)

set regroup(RealForm G, Param p) = Param:
    parameter(G, p.x.number, p.lambda, p.nu)

set low_height(KTypePol P) = int:
    if P.= then -1
    else min(0)(for @t in P do height(t) od)
    fi

set low_height(ParamPol P) = int:
    if P.= then -1
    else min(0)(for @t in P do height(t) od)
    fi

set impure_height(KTypePol P) = int:
    if is_pure(P) then -1
    else let (a, mu) = first_term(P)
    	 then () = if not is_pure(a) then return height(mu) fi
	 then () = for c@tau in a*P
	    	   do if not s_part(c).=
		      then return height(tau)
		      fi
		   od
	 in -1
     fi

{whether to use the script full_deform}
set deform_script_flag = false

{whether to use reducibility_points_rp}
set deform_rp_flag = false

{whether to use old (always to_ht) version}
set full_deform_old_flag = false

set full_deform_to_ht_MvL_old(Param p, int height) = KTypePol:
  let start = elapsed_ms(), !empty_K=null_K_module(p.real_form), !empty=null_module(p)
  then output = empty_K, def = empty, time = interrupt_base_time
  then P = empty +
       	 { snap p down to a reducibility point, or tempered parameter }
     	 (let rp = reducibility_points(p)
      	  in if =#rp
      	     then output +:= p.K_type; []
	     else [p*rp~[0]]
	     fi)
      then () = while >#P
       	    do set (def,P) :=
               (let q=first_param(P) in block_deform(q,P next P:=empty,height))
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output := (output next output:=empty_K) + kt; P := (P next P:=empty) + pp
  	    od
  in output


set full_deform_to_ht_MvL_old(Param p, int height,int TIME) = maybe_KTP:
  let start = elapsed_ms(), !empty_K=null_K_module(p.real_form), !empty=null_module(p)
  then output = empty_K, def = empty{ , time = max(TIME\32,interrupt_base_time)}
  then P = empty +
       	 { snap p down to a reducibility point, or tempered parameter }
     	 (let rp = reducibility_points(p)
      	  in if =#rp
      	     then output +:= p.K_type; []
	     else [p*rp~[0]]
	     fi)
      then () = while >#P
       	    do set (def,P) :=
               (let q=first_param(P) in block_deform(q,P next P:=empty,height))
	       ; if elapsed_ms() - start > TIME
	       	 then return timed_out()
		 fi
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output := (output next output:=empty_K) + kt; P := (P next P:=empty) + pp
  	    od
  in done(output)

{worst cases for block_deform appear to be low(p) = (N,n,N+m) where n and m are relatively small and N big.}
set full_deform_to_ht_MvL_base(Param p, int height) = KTypePol:
if full_deform_old_flag then return full_deform_to_ht_MvL_old(p,height) fi;
( if not {to_ht_over_u_flag} def_low(p,height)
  then return to_ht(full_deform(p),height)
  fi;
  let !empty_K=null_K_module(p.real_form), !empty=null_module(p)
  then output = empty_K, def = empty
  then P = empty +
  { snap p down to a reducibility point, or tempered parameter }
     (let rp =  if deform_rp_flag
	      	then reducibility_points_rp(p,height)
		else reducibility_points(p)
		fi
       in if =#rp then output +:= p.K_type; [] else [p*rp~[0]] fi)
       	  then () = while >#P
       	    do {prints("At A, q = ",first_param(P), ", height = ",height,", #P = ",#P);}
	       set (def,P) :=
               (let q=first_param(P) in block_deform(q,P next P:=empty,height))
  	       ; let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output := (output next output:=empty_K) + kt; P := (P next P:=empty) + pp
  	    od
  in output
)

set full_deform_to_ht_MvL_base(Param p, int height, int time) = maybe_KTP:
if full_deform_old_flag then return full_deform_to_ht_MvL_old(p,height,time) fi;
( if not ({to_ht_over_u_flag} def_low(p,height))
  then return to_ht(full_deform(p,time),height)
  fi;
  let start = elapsed_ms(), !empty_K=null_K_module(p.real_form), !empty=null_module(p)
  then output = empty_K, def = empty, expiration = elapsed_ms() + time
  then P = empty +
  { snap p down to a reducibility point, or tempered parameter }
     (let rp = if deform_rp_flag
	      	then reducibility_points_rp(p,height)
		else reducibility_points(p)
		fi
       in
        if =#rp then output +:= p.K_type; [] else [p*rp~[0]] fi)
  then () = while >#P
       	    do {prints("At B, q = ",first_param(P), ", height = ",height,", #P = ",#P);}
	       set (def,P) :=
               (let q=first_param(P) in block_deform(q,P next P:=empty,height))
  	       ; if elapsed_ms() > expiration
	       	 then {deformed_hash_flag := deformed_hash_flag_hold;}
		 return timed_out() fi
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output := (output next output:=empty_K) + kt; P := (P next P:=empty) + pp
  	    od
  in {deformed_hash_flag := deformed_hash_flag_hold;} done(output)
)


{whether to use _alt versions of full_deform_to_ht_MvL}
set alt_flag = false
set alt_count = int: 0
set alt_time = int:0

set full_deform_to_ht_MvL_altA(Param p, int height) = KTypePol:
  if not alt_flag then return full_deform_to_ht_MvL_base(p,height) fi;
  alt_count +:=1;
  let start = elapsed_ms(), !empty_K=null_K_module(p.real_form), !empty=null_module(p)
  then output = empty_K, def = empty, time = interrupt_base_time
  then P = empty +
       	 { snap p down to a reducibility point, or tempered parameter }
     	 (let rp = if deform_rp_flag
	      	   then reducibility_points_rp(p,height)
		   else reducibility_points(p)
		   fi
      	  in if =#rp
      	     then output +:= p.K_type; []
	     else [p*rp~[0]]
	     fi)
      then () = while >#P
       	    do if elapsed_ms() - start > time
	       then {try full_deform}
		    let try = full_deform(p,time)
		    {if deform_script_flag
		    	      then recursive_deform_scr(p, height, time)
		    	      else full_deform(p,time)
			      fi}
		    in case try
		       |timed_out: time:=2*time; ()
		       |done(r): alt_time +:= elapsed_ms() - start; return to_ht(r, height)
		       esac
		fi;
		{prints("At C, q = ",first_param(P), ", height = ",height,", #P = ",#P);}
		set (def,P) :=
               (let q=first_param(P) in block_deform(q,P next P:=empty,height))
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output := (output next output:=empty_K) + kt; P := (P next P:=empty) + pp
  	    od
  in alt_time +:= elapsed_ms() - start; output

set alt_time_int_fail = int:0
set alt_time_int_pass = int:0

{THIS is where all the time is spent! For Spin(6,4), it's 15.4 secs vs 2.2 for uninterrupted}
set full_deform_to_ht_MvL_altA(Param p, int height,int TIME) = maybe_KTP:
  if not alt_flag then return full_deform_to_ht_MvL_base(p,height,TIME) fi;
  let start = elapsed_ms(), !empty_K=null_K_module(p.real_form), !empty=null_module(p){,
      deformed_hash_flag_hold = deformed_hash_flag}
  {then () = if height >= 0
       	    then deformed_hash_flag:=true
	    fi}
  then output = empty_K, def = empty, time = max(TIME\32,interrupt_base_time)
  then P = empty +
       	 { snap p down to a reducibility point, or tempered parameter }
     	 (let rp = if deform_rp_flag
	      	   then reducibility_points_rp(p,height)
		   else reducibility_points(p)
		   fi
      	  in if =#rp
      	     then output +:= p.K_type; []
	     else [p*rp~[0]]
	     fi)
      then () = while >#P
       	    do if elapsed_ms() - start > TIME
	       then alt_time_int_fail +:= elapsed_ms() - start; return timed_out()
	       fi;
	       if elapsed_ms() - start > time
	       then time:=2*time;
		    let try = full_deform(p,time) {try full_deform}
		    {if deform_script_flag {try full_deform}
		    	      then recursive_deform_scr(p, height, time)
		    	      else full_deform(p,time)
			      fi}
		    in case try
		       |timed_out: time:=2*time; ()
		       |done(r): alt_count+:=1;
		       		 alt_time_int_pass+:= elapsed_ms() - start;
				 return done(to_ht(r, height))
		       esac
		fi;
		{prints("At D, q = ",first_param(P), ", height = ",height,", #P = ",#P);}
		set (def,P) :=
               (let q=first_param(P) in block_deform(q,P next P:=empty,height))
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output := (output next output:=empty_K) + kt; P := (P next P:=empty) + pp
  	    od
  in alt_count+:=1; alt_time_int_pass+:= elapsed_ms() - start; done(output)

set alt_verbose = false
set alt_full = false
set alt_time_guess = interrupt_base_time

set START_TIME = int:0
{set used_to_ht = int:0}

set full_deform_to_ht_MvL_alt(Param p, int height) = KTypePol:
  if not alt_flag then return full_deform_to_ht_MvL_base(p,height) fi;
  START_TIME:=elapsed_ms(); {used_to_ht:=0}
  alt_count+:=1;
  if alt_verbose
  then prints(new_line,"starting full_deform_to_ht_MvL_alt(",p,",",height,")")
  fi;
  let !empty_K=null_K_module(p.real_form), !empty=null_module(p),  start_to_ht = elapsed_ms()
  then output = empty_K, def = empty, time = alt_time_guess
  {time will increase as we fail}
  then P = empty +
       	 { snap p down to a reducibility point, or tempered parameter }
     	 (let rp = if deform_rp_flag
	      	   then reducibility_points_rp(p, height)
		   else reducibility_points(p)
		   fi
      	  in if =#rp
      	     then output +:= p.K_type; []
	     else [p*rp~[0]]
	     fi)
  then () = if alt_verbose
       	    then prints("working P = ",P," after ",print_time_string(elapsed_ms() - START_TIME))
	    fi
  {then () = used_to_ht+:= elapsed_ms() - start_to_ht}
  then () = while >#P
       	    do if elapsed_ms() - start_to_ht > time
	       then {try full_deform}
	       	    if alt_verbose
		    then prints(new_line,"starting loop try_full after ",print_time_string(elapsed_ms() - START_TIME),
       	      	    " for ", print_time_string(time))
		    fi;
		    let try = full_deform(p,time)
		    	      {if deform_script_flag
		    	      then recursive_deform_scr(p, height, time)
			      else full_deform(p,time)
			      fi}
		    in start_to_ht:=elapsed_ms(); {starting a new round of deform_to_ht}
		       case try
		       |timed_out: if alt_verbose
		       		   then prints("failed after ",print_time_string(elapsed_ms() - START_TIME))
				   fi; time:=2*time; ()
		       |done(r): alt_time_int_pass:= elapsed_ms() - START_TIME;
		       		 {alt_full := true;}
				 alt_time_guess := max(alt_time_guess, elapsed_ms() - START_TIME);
				 if alt_verbose
				 then prints("succeeded after ",print_time_string(elapsed_ms() - START_TIME))
				 fi;
				 return to_ht(r, height)
		       esac
		fi;
		if alt_verbose
		then prints(new_line, "starting loop (def,P), P = ",P," after ",print_time_string(elapsed_ms() - START_TIME))
		fi;
		{prints("At E, q = ",first_param(P), ", height = ",height,", #P = ",#P);}
		set (def,P) :=
		(let q=first_param(P) in block_deform(q,P,height))
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output +:= kt; P +:= pp;
	      	 if alt_verbose
		 then prints("completed loop (def,P), P = ",P," after ",print_time_string(elapsed_ms() - START_TIME))
		 fi
	    od
  in {deformed_hash_flag := deformed_hash_flag_hold;}
     alt_time_guess:= max(alt_time_guess,elapsed_ms() - START_TIME);
     alt_time+:= elapsed_ms() - START_TIME;
     if alt_verbose
     then prints(new_line,"completed full_deform_to_ht_MvL_alt after ",
		  print_time_string(elapsed_ms() - START_TIME))
     fi;
     {alt_full:= false;} output

set full_deform_to_ht_MvL_alt(Param p, int height,int TIME) = maybe_KTP:
  if not alt_flag then return full_deform_to_ht_MvL_base(p,height,TIME) fi;
  START_TIME:=elapsed_ms(); {TIME:= max(TIME,alt_time_guess);}
  if alt_verbose
  then prints(new_line,"starting full_deform_to_ht_MvL_alt(",p,",",height,",",TIME,")")
  fi;
  let start = elapsed_ms(), !empty_K=null_K_module(p.real_form), !empty=null_module(p),
      start_to_ht = elapsed_ms()
  then output = empty_K, def = empty, time = max(TIME\32,interrupt_base_time)
  then P = empty +
       	 { snap p down to a reducibility point, or tempered parameter }
     	 (let rp = if deform_script_flag
	      	   then reducibility_points_rp(p, height)
		   else reducibility_points(p)
		   fi
      	  in if =#rp
      	     then output +:= p.K_type; []
	     else [p*rp~[0]]
	     fi)
  then () = if alt_verbose
       	    then prints("working P = ",P," after ",print_time_string(elapsed_ms() - START_TIME))
	    fi
  then () = while >#P
       	    do if elapsed_ms() - START_TIME > TIME
	       then alt_time_int_fail +:= elapsed_ms() - start; return timed_out()
	       fi;
	       if elapsed_ms() - start_to_ht > time
	       then {try full_deform}
	       	    if alt_verbose
		    then prints(new_line,"starting loop try_full after ",print_time_string(elapsed_ms() - START_TIME),
       	      	    " for ", print_time_string(time))
		    fi;
		    let try = full_deform(p,time)
		    {if deform_script_flag
		    	      then recursive_deform_scr(p, height, time)
			      else full_deform(p,time)
			      fi}
		    in start_to_ht:=elapsed_ms();
		       case try
		       |timed_out: if alt_verbose
		       		   then prints("failed after ",print_time_string(elapsed_ms() - START_TIME))
				   fi; time:=2*time; ()
		       |done(r): alt_count+:=1;
		       		 alt_time_int_pass+:= elapsed_ms() - start;
				 if alt_verbose
				 then prints("succeeded after ",print_time_string(elapsed_ms() - START_TIME))
				 fi;
				 return done(to_ht(r, height))
		       esac
		fi;
		if alt_verbose
		then prints(new_line,"starting loop (def,P), P = ",P," after ",print_time_string(elapsed_ms() - START_TIME))
		fi;
		{prints("At F, q = ",first_param(P), ", height = ",height,", #P = ",#P);}
		set (def,P) :=
	       (let q=first_param(P) in block_deform(q,P,height))
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output +:= kt; P +:= pp;
{
	       (let q=first_param(P) in block_deform(q,P next P:=empty,height))
  	       ;  let kt = for c@m in def if  =nu(m) do (c,m.K_type) fi od
     	       	  ,   pp = for c@m in def if !=nu(m) do (c,m) fi od
  	      in output := (output next output:=empty_K) + kt; P := (P next P:=empty) + pp;

}
	      	 if alt_verbose
		 then prints("completed loop (def,P), P = ",P," after ",print_time_string(elapsed_ms() - START_TIME))
		 fi
  	    od
  in alt_time_guess:= max(alt_time_guess,elapsed_ms() - START_TIME);
     alt_time_int_pass+:= elapsed_ms() - START_TIME;
     alt_full:=false;
     if alt_verbose
     then prints("completed full_deform_to_ht_MvL_alt after ",
		  print_time_string(elapsed_ms() - START_TIME))
     fi;
     done(output)

{should require number of -alphav*theta >= number of alphav}
set red_coroots(KGBElt x) = [vec]:
    let G = x.real_form,  theta = x.involution
    then rho = G.rho, pos_co = G.poscoroots
    in for alphav@j in pos_co
       do if (alphav*theta*rho).< and poscoroot_index(G, -alphav*theta) >= j
       	  then [alphav]
	  else []
	  fi
       od.##

{this version guarantees that the range function in steve.at produces NONNEGATIVE integers, allowing
the value to be stored as a bitset}
set red_coroots_DV(KGBElt x, ratvec lambda) = [vec]:
   let rd = x.root_datum
in for alpha_v@j in rd.poscoroots
   {retain real poscoroots and complex descents nonneg on d_lambda}
      if coroot_index(rd,alpha_v*x.involution).< and (alpha_v*((1+x.involution)*lambda)).>=
      do alpha_v
      fi
   od

set MvL_alcove_time = int:0
{This vec characterizes the half-open alcove in which Marc puts p}
set MvL_alcove(Param p) = vec:
    let start = elapsed_ms(), theta1= 1+p.x.involution, p0 = p*0
    in for alphav in red_coroots(p.x)
       do if (alphav*theta1).=
       	  then if is_parity(root(p.root_datum,alphav), p0)
       	       then floor((alphav*p.infinitesimal_character)\2)
	       else floor((alphav*p.infinitesimal_character - 1)\2)
	       fi
       	  else floor(alphav*p.infinitesimal_character)
       	  fi
       od next MvL_alcove_time +:= elapsed_ms() - start

{ table of full_deform to ht, indexed by Param. MODIFY 11/22/25: NEG HEIGHT MEANS NO CUTOFF. {OLD: Height zero means no cutoff.}}
{since untwisted is not used for unequal rank, store only twisted in that case.}
{Twisted always stored with no cutoff, since we don't now have a good twisted
to_ht, so make that a separate type.}
set_type
[ deformation_hash_to_ht =
( ( -> int) size {number of parameters stored}
  , ( -> ) clear
  , (Param -> int) height {maximum height to which p is deformed: NEG means infty}
  , ((Param,int)->KTypePol) entry
  , ((Param,int,int)->maybe_KTP) maybe_entry
  , (Param->int) lookup
  , ((Param,int,KTypePol)->) append
  , ((Param,int,KTypePol,int)->) append_time
  , ((Param,int,maybe_KTP)->) maybe_append
  , ((Param,int,maybe_KTP,int)->) maybe_append_time
  , (int -> Param) param_index {parameter #j}
  , (int -> int) height_index {height to which parameter #j is deformed}
  , (int -> int) time_index {time to compute deformation of parameter #j}
  , (int -> KTypePol) data_index {deformation of parameter #j to its ht}
  )
]

set deform_param_hash = make_Param_hash() {used as index into...}
set deformed_data = [KTypePol] : []
set deform_max_heights = [int] : []
set deform_use_count = [int] : []
set deform_times = [int]: []

set_type xlv_type = (KGBElt x, ratvec lambda, vec v)

set xlv_hash_code(xlv_type xlv, int N) = int:
    (hash_code(xlv.x,N) + 3*hash_code(xlv.lambda,N) + 7*hash_code(xlv.v,N))%N

set xlv_equality(xlv_type xlv, xlv_type ymw) = bool:
    xlv.x = ymw.x and xlv.lambda = ymw.lambda and xlv.v = ymw.v

set deform_xlv_hash = make_hash(xlv_hash_code, xlv_equality)

set make_deformation_hash_to_ht () = deformation_hash_to_ht:
(  let clear() = void:
       let () = deform_param_hash.clear()
       then () = deform_max_heights :=[]
       then () = deformed_data :=[]
       then () = deform_times :=[]
       then () = deform_use_count := []
       in ()
   then add_param(Param p, int h) = int:
       	let I = deform_param_hash.size()
	then i = deform_param_hash.lookup(p)
	then P = null_K_module(SL(1,R))
	then start = elapsed_ms()
	{then() = if p.nu = [-1,0,2,0,-1,2,-1]/2 then 1\0 else 0 fi}
	then () = if i.< {haven't seen this p before}
	     then deformCalcCounter.use();
	     	  P := if h<0
	     	      then if is_equal_rank(p.real_form)
		      	   then full_deform(p)
			   else twisted_full_deform(p)
			   fi
		      else if is_equal_rank(p.real_form)
		      	   then full_deform_to_ht_MvL_base(p,h) {was base}
			   else to_ht(twisted_full_deform(p),h)
			   fi
		      fi;
		   deform_times #:= elapsed_ms() - start;
		   deform_param_hash.match(p);
		   i:=I;
		   deform_max_heights #:= h;
		   deformed_data#:=P;
		   deform_use_count#:=0
	      elif {i>=0; p seen} h < 0 and deform_max_heights[i].>=
	      then deformCalcCounter.use();
	      	   P := if is_equal_rank(p.real_form)
		      	then full_deform(p)
			else twisted_full_deform(p)
			fi {full_deform(p)};
		   deform_times[i]:=elapsed_ms() - start;
		   deform_max_heights[i]:=-1;
		   deformed_data[i]:=P
	      elif {i >=0, h>=0 } deform_max_heights[i] >= 0 and h > deform_max_heights[i]
	      then deformCalcCounter.use();
	      	   P := if is_equal_rank(p.real_form)
		      	then full_deform_to_ht_MvL_base(p,h) {was _base}
			else to_ht(twisted_full_deform(p),h)
			fi {deform_to_height(p,h)};
		   deform_times[i]:=elapsed_ms() - start;
		   deform_max_heights[i]:=h;
		   deformed_data[i]:=P
	      else deformLookupCounter.use()
	      fi
	  then () = deform_use_count[i] +:=1
	  in i
  then maybe_add_param(Param p, int h, int time) = int:
   	let I = deform_param_hash.size(), G = p.real_form
	{then () = prints("I = ",I)}
	then k = deform_param_hash.lookup(p)
	{then () = prints("k = ",k)}
	then P = maybe_KTP: timed_out()
	then start = elapsed_ms()
	then () = if k.< {haven't seen this p before}
	     then deformCalcCounter.use();
	     	  P := if is_equal_rank(p.real_form)
		       then if h<0
	     	       	    then full_deform(p,time)
		      	    else full_deform_to_ht_MvL_base(p,h,time) {was base}
			    fi
		       else if h<0
		       	    then twisted_full_deform(p,time)
			    else to_ht(twisted_full_deform(p,time),h)
			    fi
		   fi; {this step should not change deformation_hash_table!}
		   case P
		   	| timed_out: return -1
			| done(result):
		   k:=deform_param_hash.match(p);
		   {prints("k = ",k,", I = ",deform_param_hash.size());}
		   {assert(@:k=I,"def table changed inside maybe_add_param?");}
		   deform_times #:= elapsed_ms() - start;
		   deform_max_heights #:= h;
		   deformed_data#:=result;
		   deform_use_count#:=0
		   esac
	      elif {k>=0; p seen} h<0 and deform_max_heights[k].>=
	      then deformCalcCounter.use();
	      	   P := if is_equal_rank(G)
		     	then full_deform(p,time)
			else twisted_full_deform(p,time)
			fi;
		   case P
		   	| timed_out: return -1
			| done(result):
		   deform_times[k]:=elapsed_ms() - start;
		   deform_max_heights[k]:=-1;
		   deformed_data[k]:=result;
		   deform_use_count[k]+:=1
		   esac
	      elif {k =>0, h>=0 or } deform_max_heights[k] >= 0 and h > deform_max_heights[k]
	      then deformCalcCounter.use();
	      	   P := if is_equal_rank(G)
		     	then full_deform_to_ht_MvL_base(p,h,time) {was _base}
			else to_ht(twisted_full_deform(p,time),h)
			fi;
		   case P
		   	| timed_out: return -1
			| done(result):
		   deform_times[k]:=elapsed_ms() - start;
		   deform_param_hash.match(p);
		   deform_max_heights[k]:= h;
		   deformed_data[k]:=result;
		   deform_use_count[k] +:=1
		   esac
	      else deformLookupCounter.use()
	      fi
	  in k
   in
   ( ( -> int): {size} @int: deform_param_hash.size()
  , ( -> ): {clear} clear
  , (Param -> int): {height} (Param p): deform_max_heights[deform_param_hash.lookup(p)]
  , ((Param, int)->KTypePol): {entry} (Param p, int h):
    let i = add_param(p, h)
    in if h >= 0
       then regroup(p.real_form,to_ht(deformed_data[i],h))
       else regroup(p.real_form,deformed_data[i])
       fi
  , ((Param,int,int)->maybe_KTP): {maybe_entry} (Param p, int h, int time):
    let j = maybe_add_param(p, h, time)
    in if j < 0
       then timed_out()
       else if h.>=
       	    then (regroup(p.real_form, to_ht(deformed_data[j],h))).done
	    else (regroup(p.real_form,deformed_data[j])).done
	    fi
       fi
  , (Param->int): {lookup} (Param p): deform_param_hash.lookup(p)
  , ((Param,int,KTypePol)->): {append} (Param p, int h, KTypePol P):
    let I = deform_param_hash.size()
    then i = deform_param_hash.match(p)
    in if i=I {haven't seen p before}
       then deform_max_heights #:=h;
	    deformed_data#:=P;
	    deform_times#:=0;
	    deform_use_count#:=0
       elif {i < I} (h<0 and deform_max_heights[i].>=)
	    or h>deform_max_heights[i] {seen p, but not to h}
       then deform_max_heights[i]:=h;
	    deformed_data[i]:=P;
	    deform_use_count[i]+:=1
       fi
  , ((Param,int,KTypePol,int)->): {append_time} (Param p, int h, KTypePol P, int time):
    let I = deform_param_hash.size()
    then i = deform_param_hash.match(p)
    {then () = if p.nu = [-1,0,2,0,-1,2,-1]/2 then 1\0 else 0 fi}
    in if i=I {haven't seen p before}
       then deform_max_heights #:=h;
	    deformed_data#:=P;
	    deform_use_count#:=0;
	    deform_times #:=time
       elif {i < I} (h<0 and deform_max_heights[i].>=)
	    or h>deform_max_heights[i] {seen p, but not to h}
       then deform_max_heights[i]:=h;
	    deformed_data[i]:=P;
	    deform_use_count[i]+:=1;
	    deform_times[i]:=time
       fi
  , ((Param,int,maybe_KTP)->): {maybe_append} (Param p, int HT, maybe_KTP P):
    case P
    	 | timed_out: ()
    	 | done(result):
    	   let I = deform_param_hash.size()
    	   then i = deform_param_hash.match(p)
    	   {then () = if p.nu = [-1,0,2,0,-1,2,-1]/2 then 1\0 else 0 fi}
    	   in if i=I {haven't seen p before}
       	      then deform_max_heights #:=HT;
	      	   deformed_data#:=result;
		   deform_times#:=0;
	   	   deform_use_count#:=0
       	      elif {i < I} (HT<0 and deform_max_heights[i].>=)
	      	   or HT>deform_max_heights[i] {seen p, but not to HT}
       	      then deform_max_heights[i]:=HT;
	      	   deformed_data[i]:=result
       	      fi
    esac
  , ((Param,int,maybe_KTP,int)->): {maybe_append_time}  (Param p, int HT, maybe_KTP P, int time):
    case P
    	 | timed_out: ()
    	 | done(result):
    	   let I = deform_param_hash.size()
    	   then i = deform_param_hash.match(p)
    	   {then () = if p.nu = [-1,0,2,0,-1,2,-1]/2 then 1\0 else 0 fi}
    	   in if i=I {haven't seen p before}
       	      then deform_max_heights #:=HT;
	      	   deformed_data#:=result;
		   deform_times#:=time;
	   	   deform_use_count#:=0
       	      elif {i < I} (HT<0 and deform_max_heights[i].>=)
	      	   or HT>deform_max_heights[i] {seen p, but not to HT}
       	      then deform_max_heights[i]:=HT;
	      	   deformed_data[i]:=result;
		   deform_times[i]:=time;
		   deform_use_count[i]+:=1
       	      fi
    esac
  , (int -> Param): {param_index} (int j): deform_param_hash.index(j)
  , (int -> int): {height_index} (int j): deform_max_heights[j]
  , (int -> int): {time_index}  (int j): deform_times[j]
  , (int -> KTypePol): {data_index} (int j): deformed_data[j]
  )
)


set make_deformation_hash_to_htB () = deformation_hash_to_ht:
(  let clear() = void:
       let () = deform_xlv_hash.clear()
       then () = deform_max_heights :=[]
       then () = deformed_data :=[]
       then () = deform_times :=[]
       then () = deform_use_count := []
       in ()
   then add_param(Param p, int h) = int:
       	let I = deform_xlv_hash.size()
	then xlv = (p.x,p.lambda, MvL_alcove(p))
	then i = deform_xlv_hash.lookup(xlv)
	then P = null_K_module(SL(1,R))
	then start = elapsed_ms()
	{then() = if p.nu = [-1,0,2,0,-1,2,-1]/2 then 1\0 else 0 fi}
	then () = if i.< {haven't seen this MvL_alcove before}
	     then deformCalcCounter.use();
	     	  P := if h<0
	     	      then if is_equal_rank(p.real_form)
		      	   then full_deform(p)
			   else twisted_full_deform(p)
			   fi
		      else if is_equal_rank(p.real_form)
		      	   then full_deform_to_ht_MvL_base(p,h) {was _base}
			   else to_ht(twisted_full_deform(p),h)
			   fi
		      fi;
		   deform_times #:= elapsed_ms() - start;
		   deform_xlv_hash.match(xlv);
		   i:=I;
		   deform_max_heights #:= h;
		   deformed_data#:=P;
		   deform_use_count#:=0
	      elif {i>=0; p seen} h < 0 and deform_max_heights[i].>=
	      then deformCalcCounter.use();
	      	   P := if is_equal_rank(p.real_form)
		      	then full_deform(p)
			else twisted_full_deform(p)
			fi {full_deform(p)};
		   deform_times[i]:=elapsed_ms() - start;
		   deform_max_heights[i]:=-1;
		   deformed_data[i]:=P
	      elif {i >=0, h>=0 } deform_max_heights[i] >= 0 and h > deform_max_heights[i]
	      then deformCalcCounter.use();
	      	   P := if is_equal_rank(p.real_form)
		      	then full_deform_to_ht_MvL_base(p,h) {was _base}
			else to_ht(twisted_full_deform(p),h)
			fi {deform_to_height(p,h)};
		   deform_times[i]:=elapsed_ms() - start;
		   deform_max_heights[i]:=h;
		   deformed_data[i]:=P
	      else deformLookupCounter.use()
	      fi
	  then () = deform_use_count[i] +:=1
	  in i
  then maybe_add_param(Param p, int h, int time) = int:
   	let I = deform_xlv_hash.size(), G = p.real_form
	{then () = prints("I = ",I)}
	then xlv = (p.x, p.lambda, MvL_alcove(p))
	then k = deform_xlv_hash.lookup(xlv)
	{then () = prints("k = ",k)}
	then P = maybe_KTP: timed_out()
	then start = elapsed_ms()
	then () = if k.< {haven't seen this p before}
	     then deformCalcCounter.use();
	     	  P := if is_equal_rank(p.real_form)
		       then if h<0
	     	       	    then full_deform(p,time)
		      	    else full_deform_to_ht_MvL_base(p,h,time) {was _base}
			    fi
		       else if h<0
		       	    then twisted_full_deform(p,time)
			    else to_ht(twisted_full_deform(p,time),h)
			    fi
		   fi; {this step should not change deformation_hash_table!}
		   case P
		   	| timed_out: return -1
			| done(result):
		   k:=deform_xlv_hash.match(xlv);
		   {prints("k = ",k,", I = ",deform_xlv_hash.size());}
		   {assert(@:k=I,"def table changed inside maybe_add_param?");}
		   deform_times #:= elapsed_ms() - start;
		   deform_max_heights #:= h;
		   deformed_data#:=result;
		   deform_use_count#:=0
		   esac
	      elif {k>=0; p seen} h<0 and deform_max_heights[k].>=
	      then deformCalcCounter.use();
	      	   P := if is_equal_rank(G)
		     	then full_deform(p,time)
			else twisted_full_deform(p,time)
			fi;
		   case P
		   	| timed_out: return -1
			| done(result):
		   deform_times[k]:=elapsed_ms() - start;
		   deform_max_heights[k]:=-1;
		   deformed_data[k]:=result;
		   deform_use_count[k]+:=1
		   esac
	      elif {k =>0, h>=0 or } deform_max_heights[k] >= 0 and h > deform_max_heights[k]
	      then deformCalcCounter.use();
	      	   P := if is_equal_rank(G)
		     	then full_deform_to_ht_MvL_base(p,h,time) {was _base}
			else to_ht(twisted_full_deform(p,time),h)
			fi;
		   case P
		   	| timed_out: return -1
			| done(result):
		   deform_times[k]:=elapsed_ms() - start;
		   deform_xlv_hash.match(p.x, p.lambda,MvL_alcove(p));
		   deform_max_heights[k]:= h;
		   deformed_data[k]:=result;
		   deform_use_count[k] +:=1
		   esac
	      else deformLookupCounter.use()
	      fi
	  in k
   in
   ( ( -> int): {size} @int: deform_xlv_hash.size()
  , ( -> ): {clear} clear
  , (Param -> int): {height} (Param p): deform_max_heights[deform_param_hash.lookup(p)]
  , ((Param, int)->KTypePol): {entry} (Param p, int h):
    let i = add_param(p, h)
    in if h >= 0
       then regroup(p.real_form,to_ht(deformed_data[i],h))
       else regroup(p.real_form,deformed_data[i])
       fi
  , ((Param,int,int)->maybe_KTP): {maybe_entry} (Param p, int h, int time):
    let j = maybe_add_param(p, h, time)
    in if j < 0
       then timed_out()
       else if h.>=
       	    then (regroup(p.real_form, to_ht(deformed_data[j],h))).done
	    else (regroup(p.real_form,deformed_data[j])).done
	    fi
       fi
  , (Param->int): {lookup} (Param p): deform_xlv_hash.lookup(p.x,p.lambda,MvL_alcove(p))
  , ((Param,int,KTypePol)->): {append} (Param p, int h, KTypePol P):
    let I = deform_xlv_hash.size()
    then i = deform_xlv_hash.match(p.x,p.lambda,MvL_alcove(p))
    in if i=I {haven't seen p before}
       then deform_max_heights #:=h;
	    deformed_data#:=P;
	    deform_times#:=0;
	    deform_use_count#:=0
       elif {i < I} (h<0 and deform_max_heights[i].>=)
	    or h>deform_max_heights[i] {seen p, but not to h}
       then deform_max_heights[i]:=h;
	    deformed_data[i]:=P;
	    deform_use_count[i]+:=1
       fi
  , ((Param,int,KTypePol,int)->): {append_time} (Param p, int h, KTypePol P, int time):
    let I = deform_xlv_hash.size()
    then i = deform_xlv_hash.match(p.x, p.lambda, MvL_alcove(p))
    {then () = if p.nu = [-1,0,2,0,-1,2,-1]/2 then 1\0 else 0 fi}
    in if i=I {haven't seen p before}
       then deform_max_heights #:=h;
	    deformed_data#:=P;
	    deform_use_count#:=0;
	    deform_times #:=time
       elif {i < I} (h<0 and deform_max_heights[i].>=)
	    or h>deform_max_heights[i] {seen p, but not to h}
       then deform_max_heights[i]:=h;
	    deformed_data[i]:=P;
	    deform_use_count[i]+:=1;
	    deform_times[i]:=time
       fi
  , ((Param,int,maybe_KTP)->): {maybe_append} (Param p, int HT, maybe_KTP P):
    case P
    	 | timed_out: ()
    	 | done(result):
    	   let I = deform_xlv_hash.size()
    	   then i = deform_xlv_hash.match(p.x,p.lambda,MvL_alcove(p))
    	   {then () = if p.nu = [-1,0,2,0,-1,2,-1]/2 then 1\0 else 0 fi}
    	   in if i=I {haven't seen p before}
       	      then deform_max_heights #:=HT;
	      	   deformed_data#:=result;
		   deform_times#:=0;
	   	   deform_use_count#:=0
       	      elif {i < I} (HT<0 and deform_max_heights[i].>=)
	      	   or HT>deform_max_heights[i] {seen p, but not to HT}
       	      then deform_max_heights[i]:=HT;
	      	   deformed_data[i]:=result
       	      fi
    esac
  , ((Param,int,maybe_KTP,int)->): {maybe_append_time}  (Param p, int HT, maybe_KTP P, int time):
    case P
    	 | timed_out: ()
    	 | done(result):
    	   let I = deform_xlv_hash.size()
    	   then i = deform_xlv_hash.match(p.x,p.lambda, MvL_alcove(p))
    	   {then () = if p.nu = [-1,0,2,0,-1,2,-1]/2 then 1\0 else 0 fi}
    	   in if i=I {haven't seen p before}
       	      then deform_max_heights #:=HT;
	      	   deformed_data#:=result;
		   deform_times#:=time;
	   	   deform_use_count#:=0
       	      elif {i < I} (HT<0 and deform_max_heights[i].>=)
	      	   or HT>deform_max_heights[i] {seen p, but not to HT}
       	      then deform_max_heights[i]:=HT;
	      	   deformed_data[i]:=result;
		   deform_times[i]:=time;
		   deform_use_count[i]+:=1
       	      fi
    esac
  , (int -> Param): {Param_index} (int j):
    prints("not a good question for xlv hash");
    prints("xlv entry is ",deform_xlv_hash.index(j));
    SL(2,R).trivial
  , (int -> int): {height_index} (int j): deform_max_heights[j]
  , (int -> int): {time_index}  (int j): deform_times[j]
  , (int -> KTypePol): {data_index} (int j): deformed_data[j]
  )
)


set append_to_deformation_hash(RealForm G, Param p, [KPolTermDatum] data, int ht, int use) = void:
    let I = deform_param_hash.size()
    then i = deform_param_hash.lookup(p)
    in if i.< {haven't seen this p}
       then deform_param_hash.match(p);
	    i:=I;
	    deform_max_heights #:=ht;
	    deformed_data #:= K_pol(G,data);
	    deform_times #:=0;
	    deform_use_count #:= use
       elif (deform_max_heights[i] < ht) or
	    (ht < 0 and deform_max_heights[i] >= 0)
       then deform_param_hash.match(p);
       	    deform_max_heights[i] := ht;
	    deformed_data[i] := K_pol(G, data);
	    deform_times[i]:=0;
	    deform_use_count[i] +:=use
       fi

set append_to_deformation_hash(RealForm G, [Param] p_list, [[KPolTermDatum]] data_list,
    [int] ht_list, [int] use_list) = void:
    for p@j in p_list
    do append_to_deformation_hash(G,p,data_list[j],ht_list[j],use_list[j])
    od
set write_deformation_frac = 100

{write the part of deformation_hash referring to G}
set write_deformation_hash(RealForm G) = void:
    let param_list = deform_param_hash.list()
    then M = max((for P@j in deformed_data do
    deform_use_count[j]*#deformed_data[j] od)#0)
    then good_j = for p@j in param_list
    	 	   do if p.real_form = G and deform_use_count[j]* #deformed_data[j] *write_deformation_frac > M
		      then [j]
		      else []
		      fi
		   od.##
    then good_param_list = for j in good_j do param_list[j] od
    then good_deformed_data = for j in good_j do K_data(deformed_data[j]) od
    then good_deform_max_heights = for j in good_j do deform_max_heights[j] od
    then good_deform_use_count = for j in good_j do deform_use_count[j] od
    in write_real_form(G,"G_temp");
       for p@k in good_param_list
       do let (,x) = %p.x
       	  in prints("let p_temp = parameter(G_temp,",x,",",p.lambda,",",p.nu,")");
	     prints("then temp_def_data = ",good_deformed_data[k]);
       	     prints("in append_to_deformation_hash(G_temp, p_temp,",good_deformed_data[k],",",
       		  good_deform_max_heights[k],",", good_deform_use_count[k],")")
       od

{
set_type
[ twisted_deformation_hash =
( ( -> int) size {number of parameters stored}
  , ( -> ) clear
  , (Param -> int) height {maximum height to which p is deformed}
  , ((Param,int)->KTypePol) entry
  , (Param->int) lookup
  , ((Param,int,KTypePol)->) append
  , ((Param,int,maybe_KTP)->) maybe_append
  , (int -> Param) param_index {parameter #j}
  , (int -> int) height_index {height to which parameter #j is deformed}
  , (int -> KTypePol) data_index {deformation of parameter #j}
  )
]

set twisted_deform_param_hash = make_Param_hash() {used as index into...}
set twisted_deformed_data = [KTypePol] : []
set twisted_deform_max_heights = [int] : []
set twisted_deform_times = [int] : []
set twisted_deform_use_count = [int] : []

set make_twisted_deformation_hash() = twisted_deformation_hash:
(   let clear() = void:
       let () =  twisted_deform_param_hash.clear()
       then () = twisted_deform_max_heights :=[]
       then () = twisted_deformed_data :=[]
       then () = twisted_deform_times :=[]
       then () = twisted_deform_use_count := []
       in ()
   then add_param(Param p, int h) = int:
       	let I =  twisted_deform_param_hash.size()
	then i =  twisted_deform_param_hash.match(p)
	then P = null_K_module(SL(1,R))
	then () = if i=I {haven't seen this p before}
	     then twistedDeformCalcCounter.use();
	     	  P := if h=0
		       then twisted_full_deform(p)
		       else to_ht(twisted_full_deform(p),h)
		       fi;
		  twisted_deformed_data#:=P;
		  twisted_deform_max_heights #:=h;
		  twisted_deform_use_count#:=0
	      elif {i>=0; p seen} h=0 and twisted_deform_max_heights[i].>
	      then twistedDeformCalcCounter.use();
	      	   P := twisted_full_deform(p);
		   twisted_deform_max_heights[i]:=0;
		   twisted_deformed_data[i]:=P
	      elif {i >0, h>0 or } twisted_deform_max_heights[i] > 0
	       	    and h > twisted_deform_max_heights[i]
	      then twistedDeformCalcCounter.use();
	      	   P := to_ht(twisted_full_deform(p),h);
		   twisted_deform_max_heights[i]:=h;
		   twisted_deformed_data[i]:=P
	      else twistedDeformLookupCounter.use()
	      fi
	  in i
   in
   ( ( -> int): {size} @int:  twisted_deform_param_hash.size()
  , ( -> ): {clear} clear
  , (Param -> int): {height} (Param p):twisted_deform_max_heights[deform_param_hash.lookup(p)]
  , ((Param,int)->KTypePol): {entry} (Param p, int h):
    let i = add_param(p,h)
    in if h > 0
       then regroup(p.real_form,to_ht(twisted_deformed_data[i],h))
       else regroup(p.real_form,twisted_deformed_data[i])
       fi
  , (Param->int): {lookup} (Param p): twisted_deform_param_hash.lookup(p)
  , ((Param,int,KTypePol)->): {append} (Param p, int h, KTypePol P):
    let I = twisted_deform_param_hash.size()
    then i = twisted_deform_param_hash.match(p)
    in if i=I {haven't seen p before}
       then twisted_deform_max_heights #:=h;
	    twisted_deformed_data#:=P;
	    twisted_deform_use_count#:=0
       elif {i < I} (h=0 and twisted_deform_max_heights[i].>) 
	    or h>twisted_deform_max_heights[i] {seen p, but not to h}
       then twisted_deform_max_heights[i]:=h;
	    twisted_deformed_data[i]:=P
       fi
  , ((Param,int,maybe_KTP)->): {maybe_append} (Param p, int HT, maybe_KTP P):
    case P
    	 | timed_out: ()
    	 | done(result):
    	   let I = twisted_deform_param_hash.size()
    	   then i = twisted_deform_param_hash.match(p)
    	   in if i=I {haven't seen p before}
       	      then twisted_deform_max_heights #:=HT;
	      	   twisted_deformed_data#:=result;
	   	   twisted_deform_use_count#:=0
       	      elif {i < I} (HT=0 and twisted_deform_max_heights[i].>) 
	      	   or HT>twisted_deform_max_heights[i] {seen p, but not to HT}
       	      then twisted_deform_max_heights[i]:=HT;
	      	   twisted_deformed_data[i]:=result
       	      fi
    esac
  , (int -> Param): {param_index} (int j):  twisted_deform_param_hash.index(j)
  , (int -> int): {height_index} (int j): twisted_deform_max_heights[j]
  , (int -> KTypePol): {data_index} (int j): twisted_deformed_data[j]
  )
)

set append_to_twisted_deformation_hash(RealForm G, Param p, [KPolTermDatum] data) = void:
    let I = twisted_deform_param_hash.size()
    then i = twisted_deform_param_hash.match(p)
    in if i=I {haven't seen this p}
       then twisted_deformed_data #:= K_pol(G,data)
       fi

set append_to_twisted_deformation_hash(RealForm G, [Param] p_list, [[KPolTermDatum]] data_list) = void:
    for p@j in p_list
    do append_to_twisted_deformation_hash(G,p,data_list[j])
    od

{write the part of deformation_hash referring to G}
set write_twisted_deformation_hash(RealForm G) = void:
    let param_list = twisted_deform_param_hash.list()
    then good_j = for p@j in param_list
    	 	   do if p.real_form = G then [j]
		      else []
		      fi
		   od.##
    then good_param_list = for j in good_j do param_list[j] od
    then good_twisted_deformed_data = for j in good_j do K_data(twisted_deformed_data[j]) od
    in write_real_form(G,"G_temp");
       for p@k in good_param_list
       do let (,x) = %p.x
       	  in prints("let p_temp = parameter(G_temp,",x,",",p.lambda,",",p.nu,")");
       	     prints("in append_to_twisted_deformation_hash(G_temp,p_temp,",good_twisted_deformed_data[k],
	     ")")
       od
}

{whether to use these hash tables. "False" saves quite a bit of memory
(about 10% in F4_s) with very little speed cost (less than 1% in
F4_s)}
{TRUE should help interrupted to_ht}
set deformed_hash_flag = false {true}

{set xlv_flag = false {true costs 10% time for E7_s near x.number = 12000}}

{set deformedHash = if xlv_flag
    		   then make_deformation_hash_to_htB()
		   else make_deformation_hash_to_ht()
		   fi}

set deformedHashA =  make_deformation_hash_to_ht()
set deformedHashB =  make_deformation_hash_to_htB()
set deformedHash = deformedHashA

set choose_xlv(bool choice) = void:
    if choice
    then deformedHash:= deformedHashB
    else deformedHash:= deformedHashA
    fi


{set twistedDeformedHash = make_twisted_deformation_hash()}

{like is_pure, but in case of false, second value is the lowest K-type where
the KTypePol changes sign. Better to put the guilty K-type in a hash table.}
set is_pure_cert(KTypePol P) = [KType]:
    if is_pure(P) then [KType]: []
    else let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0
	 then () = if a0*b0 != 0
	           then let ()= j:=0
		   	in ()
	           elif b0 = 0
	      	   then let ()= j:= first(for (,b,)@j in terms
	      	      	     	      	   do b!=0
				      	   od)
			in ()
	      	   else {now b0!=0 and a0=0}
		   	let () = j:= first(for (a,,)@j in terms
	      	      	     	      do a!=0
				      od)
			in ()
		   fi
	  then (,,pj) = terms[j]
	  in [pj]
    fi

{like is_pure_cert, but in case of false, writing the guilty K-types in a
hash table.}
set is_pure_cert_hash_old(KTypePol P, KTypePol_hash cert_hash) = bool:
    if not is_pure(P)
    then let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0
	 then () = if a0*b0 != 0
	           then let ()= j:=0
		   	in ()
	           elif b0 = 0
	      	   then let ()= j:= first(for (,b,)@j in terms
	      	      	     	      	   do b!=0
				      	   od)
			in ()
	      	   else {now b0!=0 and a0=0}
		   	let () = j:= first(for (a,,)@j in terms
	      	      	     	      do a!=0
				      od)
			in ()
		   fi
	  then (,,pj) = terms[j]
	  then x = cert_hash.match(1*pj)
	  in false
    else true
    fi

{like is_pure_cert, but in case of false, writing the guilty K-types in a
hash table.}
{ want this version to record SUM of lowest impurity }
set is_pure_cert_hash(KTypePol P, KTypePol_hash cert_hash) = bool:
    if not is_pure(P)
    then let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0 {next line is the lowest negative terms}
	 then B = if a0*b0 != 0
	          then to_ht(P,height(p0))
	          elif b0 = 0
	      	  then let N = sum(P.real_form, for (a,b,p) in terms
		   	      			do if b!=0 then [1*p] else [] fi od.##)
		   	in to_ht(N,height(first_K_type(N)))
	      	  else  {now b0!=0 and a0=0}
		       let N = sum(P.real_form, for (a,b,p) in terms
		   	      			do if a!=0 then [1*p] else [] fi od.##)
		       in to_ht(N,height(first_K_type(N)))
		  fi
	  then x = cert_hash.match(B)
	  in false
    else true
    fi

{meant to hold number of NEGATIVE Dirac inequality tests}
set DTcount = int: 0

{meant to hold number of NEGATIVE Dirac_best inequality tests}
set DBTcount = int: 0

set next_heightC_time = int: 0

{will be modified to name of local test being run}
set test_string = string: ""

{whether to report on slow is_unitary and is_unitary_to_ht}
set drain_plug_flag = bool: false

{report on tests requiring more than this time; default is 100000 = 10 seconds}
set drain_plug_time = int: 100000

set tested_pos_hash = make_Param_hash() {all Param's that have had a positive is_unitary test}
set tested_pos_times = [int]: [] {one for each tested_pos_hash.list() entry; TOTAL time
    		       	 	    for all positive is_unitary tests of entry}
set tested_pos_strings = [string]: []
set tested_pos_counts = [int]: [] {hope this is 0 or 1!}

set tested_neg_hash = make_Param_hash() {all Param's that have had a negative is_unitary test}
set tested_neg_times = [int]: [] {one for each tested_list entry; TOTAL time
    		       	 	    for all negative is_unitary tests of entry}
set tested_neg_strings = [string]: []
set tested_neg_counts = [int]: [] {hope this is 0 or 1!}

set tested_inter_hash = make_Param_hash() {all Param's that have had an interrupted is_unitary test}
set tested_inter_times = [int]: [] {one for each tested_inter_hash.list() entry; TOTAL time
    		       	 	    for all interrupt is_unitary tests of entry}
set tested_inter_counts = [int]: []
set tested_inter_strings = [string]: []

set tested_pos_to_ht_hashes = [Param_hash]: [] {jth is all Param's that had a positive is_unitary
    			      		       	to height(p)+j test}
set tested_pos_to_ht_times = [[int]]: []
set tested_pos_to_ht_strings = [[string]]: []
set tested_pos_to_ht_counts = [[int]]: []

set tested_neg_to_ht_hashes = [Param_hash]: [] {jth is all Param's that had a negative is_unitary
    			      		       	to height(p)+j test}
set tested_neg_to_ht_times = [[int]]: []
set tested_neg_to_ht_strings = [[string]]: []
set tested_neg_to_ht_counts = [[int]]: []

set tested_inter_to_ht_hashes = [Param_hash]: [] {jth is all Param's that had an interrupted is_unitary
    			      		       	to height(p)+j test}
set tested_inter_to_ht_times = [[int]]: []
set tested_inter_to_ht_strings = [[string]]: []
set tested_inter_to_ht_counts = [[int]]: []

set OT_hash = make_Param_hash() {used to record interrupted tests that ran too long; maybe not used now?}
set OT_times = [int]: [] {cumulative time for each OT_hash.list() entry}
set OT_counts = [int]: [] {number of occurrences for each OT_hash.list() entry}

{set cSp = int:0}
set was_tested(Param p, int T, bool ans) = void:
    {let () = if p = parameter(Sp(6,R),8,[2,1,1],[1,-1,0]/2)
    	     then cSp+:=1; 1/(cSp-4)
	     else 1/1
	     fi}
    {if p = parameter(F4_s,101,[1,1,1,-1]/1,[0,1,0,-2]/1)
    then assert(@:false); prints("testing p0")
    fi;}
    {if p = parameter(F4_s,102,[2,2,1,-4]/1,[1,4,0,-9]/4)
    then assert(@:false); prints("testing p1")
    fi;}
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," to test is_unitary = ", ans)
    fi;
    unitary_test_counter.use();
    let i = tested_inter_hash.lookup(p)
    in if i >= 0
       then T+:=tested_inter_times[i]
       fi;
    if ans
    then let M = tested_pos_hash.size()
       	 then m = tested_pos_hash.match(p)
       	 {then prints("M = ",M,", m = ",m)}
	 in if m = M
	    then tested_pos_times#:=T;
	    	 tested_pos_strings #:= test_string;
		 tested_pos_counts #:=1
	    else tested_pos_times[m] +:= T;
	    	 tested_pos_counts[m] +:= 1
	    fi
    else let M = tested_neg_hash.size()
       	 then m = tested_neg_hash.match(p)
	 {then prints("M = ",M,", m = ",m)}
	 in if m = M
	    then tested_neg_times#:=T;
	    	 tested_neg_strings #:= test_string;
		 tested_neg_counts #:=1
	    else tested_neg_times[m] +:= T;
	    	 tested_neg_counts[m] +:= 1
	    fi
    fi

set was_tested_inter(Param p, int T) = void:
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," for interrupted is_unitary")
    fi;
    unitary_test_counter.use();
    let M = tested_inter_hash.size()
    then m = tested_inter_hash.match(p)
    in if m=M
       then tested_inter_times #:= T;
	    tested_inter_strings #:= test_string;
       	    tested_inter_counts #:=1
       else tested_inter_times[m] +:= T;
       	    tested_inter_counts[m] +:=1
       fi

{keep track of whether interruption ran too long}
set was_tested_inter(Param p, int T, int T_target) = void:
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," for interrupted is_unitary")
    fi;
    if T>(5/4)*T_target
    then let OTM = OT_hash.size()
    	 then OTm = OT_hash.match(p)
	 in if OTm=OTM
	    then OT_times #:= T - T_target;
	    	 OT_counts #:= 1
	    else OT_times[OTm] +:= T - T_target;
	    	 OT_counts[OTm] +:= 1
	    fi
    fi;
    unitary_test_counter.use();
    let M = tested_inter_hash.size()
    then m = tested_inter_hash.match(p)
    in if m=M
       then tested_inter_times #:= T;
       	    tested_inter_counts #:=1
       else tested_inter_times[m] +:= T;
       	    tested_inter_counts[m] +:=1
       fi

set was_tested_to_ht(Param p,int N, int T, bool ans) = void:
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," to test is_unitary_to_ht ", N,
    	 	 " = ",ans)
    fi;
    unitary_test_counter.use();
    let h = N - height(p)
    then add = h+1 - #tested_pos_to_ht_hashes
    in if add>0
        then tested_pos_to_ht_hashes ##:= for j:add do make_Param_hash() od;
	     tested_neg_to_ht_hashes ##:= for j:add do make_Param_hash() od;
	     tested_inter_to_ht_hashes ##:= for j:add do make_Param_hash() od;
	     tested_pos_to_ht_times ##:= for j:add do [int]: [] od;
	     tested_neg_to_ht_times ##:= for j:add do [int]: [] od;
	     tested_inter_to_ht_times ##:= for j:add do [int]: [] od;
	     tested_pos_to_ht_strings ##:= for j:add do [string]: [] od;
	     tested_neg_to_ht_strings ##:= for j:add do [string]: [] od;
	     tested_inter_to_ht_strings ##:= for j:add do [string]: [] od;
	     tested_pos_to_ht_counts ##:= for j:add do [int]: [] od;
	     tested_neg_to_ht_counts ##:= for j:add do [int]: [] od;
	     tested_inter_to_ht_counts ##:= for j:add do [int]: [] od
       fi;
       let i = tested_inter_to_ht_hashes[h].lookup(p)
       in if i >= 0 then T+:= tested_inter_to_ht_times[h][i] fi;
       if ans
       then let M = tested_pos_to_ht_hashes[h].size()
    	    then m = tested_pos_to_ht_hashes[h].match(p)
       	    in if m = M
	       then tested_pos_to_ht_times[h]#:=T;
	    	    tested_pos_to_ht_strings[h] #:= test_string;
		    tested_pos_to_ht_counts[h] #:=1
	       else let tpthh = tested_pos_to_ht_times[h], tpthc = tested_pos_to_ht_counts[h]
		    in tpthh[m] +:= T;
		       tested_pos_to_ht_times[h] := tpthh;
		       tpthc[m] +:= 1;
		       tested_pos_to_ht_counts[h] := tpthc
	       fi
        else let M = tested_neg_to_ht_hashes[h].size()
    	     then m = tested_neg_to_ht_hashes[h].match(p)
	     in	if m = M
	       	then tested_neg_to_ht_times[h] #:=T;
	    	    tested_neg_to_ht_strings[h] #:= test_string;
		    tested_neg_to_ht_counts[h] #:=1
	       else let tnthh = tested_neg_to_ht_times[h], tnthc = tested_neg_to_ht_counts[h]
	    	    in tnthh[m] +:= T;
		       tnthc[m] +:= 1;
		       tested_neg_to_ht_times[h] := tnthh;
		       tested_neg_to_ht_counts[h] := tnthc
	       fi
        fi

set was_tested_inter_to_ht(Param p,int HT, int T) = void:
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," for interrupted is_unitary_to_ht ", HT)
    fi;
    unitary_test_counter.use();
    let h = HT - height(p)
    then add = h+1 - #tested_pos_to_ht_hashes
    then () = if add>0
    	      then tested_pos_to_ht_hashes ##:= for j:add do make_Param_hash() od;
	      	   tested_neg_to_ht_hashes ##:= for j:add do make_Param_hash() od;
	      	   tested_inter_to_ht_hashes ##:= for j:add do make_Param_hash() od;
		   tested_pos_to_ht_times ##:= for j:add do [int]: [] od;
		   tested_neg_to_ht_times ##:= for j:add do [int]: [] od;
		   tested_inter_to_ht_times ##:= for j:add do [int]: [] od;
		   tested_pos_to_ht_strings ##:= for j:add do [string]: [] od;
		   tested_neg_to_ht_strings ##:= for j:add do [string]: [] od;
		   tested_inter_to_ht_strings ##:= for j:add do [string]: [] od;
		   tested_pos_to_ht_counts ##:= for j:add do [int]: [] od;
		   tested_neg_to_ht_counts ##:= for j:add do [int]: [] od;
		   tested_inter_to_ht_counts ##:= for j:add do [int]: [] od
	      fi
    in let M = tested_inter_to_ht_hashes[h].size()
       then m = tested_inter_to_ht_hashes[h].match(p)
       in if m = M
	  then tested_inter_to_ht_times[h]#:=T;
	       tested_inter_to_ht_strings[h] #:= test_string;
	       tested_inter_to_ht_counts[h] #:=1
	  else let tithh = tested_inter_to_ht_times[h], tithc = tested_inter_to_ht_counts[h]
	       in tithh[m] +:= T;
	       	  tested_inter_to_ht_times[h] := tithh;
	    	  tithc[m] +:= 1;
		  tested_inter_to_ht_counts[h] := tithc
	  fi

{keep track of whether interruption failed}
{set was_tested_inter_to_ht(Param p, int HT, int T, int T_target) = void:
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," for interrupted is_unitary_to_ht", HT)
    fi;
    if T>(5/4)*T_target
    then let OTM = OT_hash.size()
    	 then OTm = OT_hash.match(p)
	 in if OTm=OTM
	    then OT_times #:= T - T_target;
	    	 OT_counts #:= 1
	    else OT_times[OTm] +:= T - T_target;
	    	 OT_counts[OTm] +:= 1
	    fi
    fi;
    unitary_test_counter.use();
    let M = tested_inter_hash.size()
    then m = tested_inter_hash.match(p)
    in if m=M
       then tested_inter_times #:= T;
       	    tested_inter_counts #:=1
       else tested_inter_times[m] +:= T;
       	    tested_inter_counts[m] +:=1
       fi}

set report_tested(string label) = void:
{    prints("...",label,"...",DTcount," Dirac elim, ",DBTcount," best-Dirac elim; predictor_time = ",
    	  print_time_string(predictor_time));}
    prints("...",label,"...",DTcount + DBTcount," Dirac elim; status_time = ",
    	   print_time_string(status_time), " for ", status_count," reports");
   prints("FPP_def_time = ",print_time_string(FPP_def_time), " for ",
   FPP_use_count, " tests, ",FPP_def_count, " eliminations");
   	   {predictor_time = ", print_time_string(predictor_time));}
    {edge_offset = ",edge_offset);}
    {next_heightC_time = ",}
           {print_time_string(next_heightC_time));}
    prints(new_line,tested_pos_hash.size()," pos is_unitary tests, in time = ",
    	print_time_string(sum(tested_pos_times)),"; ",tested_neg_hash.size()," neg is_unitary tests, in time = ",
    	print_time_string(sum(tested_neg_times)));
    prints(sum(tested_inter_counts), " interrupted is_unitary tests, of ",
    	   tested_inter_hash.size(), " different parameters, in time ",
	print_time_string(sum(tested_inter_times)));
    prints(new_line,sum(for hash in tested_pos_to_ht_hashes do hash.size() od)," pos tests to_ht, in time = ",
 	 	   print_time_string(sum(for list in tested_pos_to_ht_times do sum(list) od)),"; ",
	   sum(for hash in tested_neg_to_ht_hashes do hash.size() od)," neg tests to_ht, in time = ",
 	   	   print_time_string(sum(for list in tested_neg_to_ht_times do sum(list) od)));
    prints(sum(for list in tested_inter_to_ht_counts do sum(list) od), " interrupted tests to ht of ",
    		   sum(for hash in tested_inter_to_ht_hashes
    	do hash.size() od)," different parameters, in time = ",
 	 	   print_time_string(sum(for list in tested_inter_to_ht_times do sum(list) od)));
    if OT_hash.size() > 0
    then prints(OT_hash.size()," params had ", sum(OT_counts), " interrupted tests go too long by ",
    	 print_time_string(sum(OT_times)))
    fi;
    prints("#bottom_layer = ",hash_bottom_layerCounter.use_count(), ", #one_level = ",
    	   hash_one_levelCounter.use_count(), {", #real_dumb = "} ", #dumb = ",
	   hash_real_dumbCounter.use_count() +
    	   hash_dumbCounter.use_count() +
   	    hash_def_dumbCounter.use_count(), ", #hash = ",
    	    hashCounter.use_count(), ", #hash2 = ",
    	    hash2Counter.use_count(), ", #steve = ",hash_steveCounter.use_count());
    prints(print_time_string(unitaryTime)," for ",unitary_test_counter.use_count()," utests; ",
    print_time_string(charTime), " for ",char_counter.use_count(), " char calcs; ",
    print_time_string(charTimeToHt), " for ",char_counter_to_ht.use_count(), " char_to_ht calcs.");
    {prints("time for up_mu = ",print_time_string(up_mu_time), ", mu_time_mult = ",mu_time_mult,
    	   ", shift_frac = ",shift_frac, ", min_ht_mult = ", min_ht_mult);}
    {prints({"LAGAmax = ",LAGAmax,", GARLAGmin = ",GARLAGmin, ", GARmin = ", GARmin,}
    	   "Dirac elims = ",DTcount,", Dirac_best elims = ",DBTcount, ", ",print_time_string(def_thruples_time),
	   " to find deformed thruple candidates.");
    prints("Found ",hash_def_true_count," deformations proving unitarity (to height), ",
    	   hash_def_false_count," deformations proving nonunitarity (to height).")
    prints("no_unitary_time = ", print_time_string(test_no_unitary_time), ", no_Dirac_time = ",
    	   print_time_string(test_no_Dirac_time)," , #(x,lambda) eliminated by LKTs = ",none_count);}
    prints("  ----------------")

set report_tested() = void: report_tested("")

{doesn't work with report_tested_cum}
set clear_report_tested() = void:
    tested_pos_hash.clear(); tested_pos_times:=[]; tested_pos_strings:=[]; tested_pos_counts:=[];
    tested_neg_hash.clear(); tested_neg_times:=[]; tested_neg_strings:=[]; tested_neg_counts:=[];
    tested_inter_hash.clear(); tested_inter_times:=[]; tested_inter_counts:=[];
    OT_hash.clear(); OT_times:=[]; OT_counts:=[]
    for h:#tested_pos_to_ht_hashes
    do tested_pos_to_ht_hashes[h].clear(); tested_pos_to_ht_times[h]:=[]; tested_pos_to_ht_strings[h]:=[];
       tested_pos_to_ht_counts[h]:=[]; tested_neg_to_ht_counts[h]:=[];
       tested_neg_to_ht_hashes[h].clear(); tested_neg_to_ht_times[h]:=[]; tested_neg_to_ht_strings[h]:=[];
       tested_inter_to_ht_hashes[h].clear(); tested_inter_to_ht_times[h]:=[]; tested_inter_to_ht_strings[h]:=[];
       tested_inter_to_ht_counts[h]:=[]
    od

set (report_tested_cum,clear_report_tested_cum) = (((string, string) -> void),(void->void)):
    let tph = int: 0, tpt = int:0, tnh = int: 0, tnt = int:0, oth = int:0, otc = int:0, ott = int:0
    then tic = int: 0, tih = int: 0, tit = int:0, tphh = int: 0, tpht = int:0, tnhh = int: 0, tnht = int: 0,
    	 tihc = int: 0, tihh = int:0, tiht = int:0,
    	 utc = int: 0, utt = int: 0, ct = int:0, ctth = int: 0, cu = int: 0, cuth = int:0, DTc = int:0, DBTc = int: 0, nhtC_time = int:0
    in (((string,string)->void): (string local_label, string running_label) void:
    prints("  ----------------");
    prints("...",local_label,"...",DTcount - DTc," Dirac elim, ",DBTcount - DBTc,
    " best-Dirac elim, more_shift_level = ",more_shift_level, ", edge_offset = ",edge_offset);
    	DTc :=DTcount; DBTc := DBTcount; nhtC_time:=next_heightC_time;
    prints(new_line,tested_pos_hash.size() - tph, " pos is_unitary tests, in time = ",
    	print_time_string(sum(tested_pos_times) - tpt),"; ",tested_neg_hash.size() - tnh,
	" neg is_unitary tests, in time = ",print_time_string(sum(tested_neg_times) - tnt));
	tph:=tested_pos_hash.size();
	tpt := sum(tested_pos_times);
	tnh:=tested_neg_hash.size();
	tnt := sum(tested_neg_times);
    prints(sum(tested_inter_counts) - tic, " interrupted is_unitary tests, of ",
    	   tested_inter_hash.size() - tih, " different parameters, in time ",
	print_time_string(sum(tested_inter_times) - tit));
	tic:= sum(tested_inter_counts);
	tih:= tested_inter_hash.size();
	tit:=sum(tested_inter_times);
    prints(new_line,sum(for hash in tested_pos_to_ht_hashes do hash.size() od) -tphh," pos tests to_ht, in time = ",
    	print_time_string(sum(for list in tested_pos_to_ht_times do sum(list) od) - tpht),"; ",
	   sum(for hash in tested_neg_to_ht_hashes do hash.size() od) - tnhh," neg tests to_ht, in time = ",
 	   	   print_time_string(sum(for list in tested_neg_to_ht_times do sum(list) od) - tnht));
        tphh:= sum(for hash in tested_pos_to_ht_hashes do hash.size() od);
	tpht:=sum(for list in tested_pos_to_ht_times do sum(list) od);
        tnhh:= sum(for hash in tested_neg_to_ht_hashes do hash.size() od);
	tnht:=sum(for list in tested_neg_to_ht_times do sum(list) od);
    prints(sum(for list in tested_inter_to_ht_counts do sum(list) od) - tihc,
    	" interrupted tests to_ht, of ",sum(for hash
       in tested_inter_to_ht_hashes do hash.size() od) - tihh," different parameters, in time = ",
       print_time_string(sum(for list in tested_inter_to_ht_times do sum(list) od) - tiht),new_line);
       	tihc:=sum(for list in tested_inter_to_ht_counts do sum(list) od);
 	tihh:=sum(for hash in tested_inter_to_ht_hashes do hash.size() od);
	tiht:=sum(for list in tested_inter_to_ht_times do sum(list) od);
    if OT_hash.size() - oth > 0
    then prints(OT_hash.size()-oth," params had ", sum(OT_counts)-otc, " interrupted tests go too long by ",
    	 print_time_string(sum(OT_times) -ott));
	 oth:=OT_hash.size();
	 otc := sum(OT_counts);
	 ott := sum(OT_times)
    fi;
    prints("#bottom_layer = ",hash_bottom_layerCounter.use_count(), ", #one_level = ",
    	   hash_one_levelCounter.use_count(), {", #real_dumb = "} ", #dumb = ",
	   hash_real_dumbCounter.use_count() +
    	   hash_dumbCounter.use_count() +
   	    hash_def_dumbCounter.use_count(), ", #hash = ",
    	    hashCounter.use_count(), ", #hash2 = ",
    	    hash2Counter.use_count(), ", #steve = ",hash_steveCounter.use_count());
    prints(print_time_string(unitaryTime - utt)," for ",unitary_test_counter.use_count() -utc,
    					 " utests; ",
    			     print_time_string(charTime - ct), " for ",char_counter.use_count() -cu,
			     " char calcs, ",
			     print_time_string(charTimeToHt - ctth), " for ",char_counter_to_ht.use_count() -cuth,
			     " char to ht calcs");
	 utt:= unitaryTime;
	 utc:=unitary_test_counter.use_count();
	 ct:=charTime; ctth:=charTimeToHt;
	 cu:= char_counter.use_count(); cuth:=char_counter_to_ht.use_count();
    prints("...",running_label,"...",DTcount + DBTcount," Dirac elim; status_time = ",
    	   print_time_string(status_time), " for ", status_count," reports");
    prints("FPP_def_time = ",print_time_string(FPP_def_time)," for ",
    	    FPP_use_count, " tests, ",FPP_def_count, " eliminations");
	   		{predictor_time = ", print_time_string(predictor_time));}
    prints(new_line,tph," pos is_unitary tests, in time = ", print_time_string(tpt),"; ",tnh,
	" neg is_unitary tests, in time = ",print_time_string(tnt));
    prints(tic, " interrupted is_unitary tests, of ",tih, " different parameters, in time ",
	print_time_string(tit));
    prints(new_line,tphh," pos tests to_ht, in time = ",print_time_string(tpht),"; ",tnhh," neg tests to_ht, in time = ",
 	print_time_string(tnht));
    prints(sum(for list in tested_inter_to_ht_counts do sum(list) od)," interrupted tests to_ht, of ",sum(for hash
       in tested_inter_to_ht_hashes do hash.size() od)," different parameters, in time = ",
 	 	   print_time_string(sum(for list in tested_inter_to_ht_times do sum(list) od)), new_line);
    if oth.>
    then prints(OT_hash.size()," params had ", sum(OT_counts), " interrupted tests go too long by ",
    	 print_time_string(sum(OT_times)))
    fi;
    prints("#bottom_layer = ",hash_bottom_layerCounter.use_count(), ", #one_level = ",
    	   hash_one_levelCounter.use_count(), {", #real_dumb = "} ", #dumb = ",
	   hash_real_dumbCounter.use_count() +
    	   hash_dumbCounter.use_count() +
   	    hash_def_dumbCounter.use_count(), ", #hash = ",
    	    hashCounter.use_count(), ", #hash2 = ",
    	    hash2Counter.use_count(), ", #steve = ",hash_steveCounter.use_count());
    prints(print_time_string(unitaryTime)," for ",unitary_test_counter.use_count()," utests; ",
    print_time_string(charTime), " for ",char_counter.use_count(), " char calcs; ",
    print_time_string(charTimeToHt), " for ",char_counter_to_ht.use_count(), " char_to_ht calcs");
    prints("  ----------------")
    , @: {clear_report_tested_cum}
     tph := 0; tpt := 0; tnh := 0; tnt :=0; oth :=0; otc :=0; ott :=0;
     tic := 0; tih := 0; tit :=0; tphh := 0; tpht :=0; tnhh := 0; tnht := 0;
     tihc:=0; tihh:=0; tiht:=0;
     utc := 0; utt := 0; ct :=0; cu := 0; ctth := 0; cuth :=0; DTc:=0; DBTc:=0; nhtC_time:=0)

set report_tested_cum() = report_tested_cum("","")

set wsf_time = int:0

set worst_so_far(Param p, int H) = int:
    let start_wsf = elapsed_ms()
    in if H.>= then {this is what we do for a new test of p to height: look at all tests of p
       	    	  to lower heights (pos, interrupted}
       	 let TH = #tested_pos_to_ht_times
     	 then top_j = min(TH, H-height(p)+1)
     	 in let I_s = for j:top_j {can't be negative tests below H, or we wouldn't be asking}
      	    	      do vec: [tested_pos_to_ht_hashes[j].lookup(p),
			       tested_inter_to_ht_hashes[j].lookup(p){, 
		     	       tested_neg_to_ht_hashes[j].lookup(p)}]
	    	      od {where p shows up in each of these test lists}
  	    then j_last = last(for j:top_j do I_s[j] != [-1,-1] od) {greatest height where it appears}
  	    then index = int: -1
  	    in wsf_time +:= elapsed_ms() - start_wsf;
	       if j_last >= 0 {well, if it DOES appear}
     	       then if (index:= I_s[j_last][0])>=0
     	       	    then 2*tested_pos_to_ht_times[j_last][index]
	  	    else 5*tested_inter_to_ht_times[j_last][I_s[j_last][1]]
	  	    fi
     		else {if p hasn't been tested at all, take worst of all q's tested to H}
		     max( (tested_inter_to_ht_times[:top_j] ##  tested_neg_to_ht_times[:top_j]
	    	     	  ## tested_pos_to_ht_times[:top_j] ##[[0]]).##)
     	        fi {j_last >=0}
    else {this is what we do for a new unitary test of p: look at all interrupted tests of p}
    	 {should I look also at tests of p to height??}
	 let index = tested_inter_hash.lookup(p) {where p shows up in interrupted list}
	     then I_s = for hash@j in tested_pos_to_ht_hashes
	     	      	    do vec: [hash.lookup(p),
			       tested_inter_to_ht_hashes[j].lookup(p)]
			    od
	     then j_last = last(for I in I_s do I != [-1,-1] od), index_to_ht = int:-1
	     then to_ht_worst = if j_last < 0
	     	  	      	then 0
				elif (index_to_ht := I_s[j_last][0]) >= 0
				then 2*tested_pos_to_ht_times[j_last][index_to_ht]
				else 5*tested_inter_to_ht_times[j_last][I_s[j_last][1]]
				fi
    	 in wsf_time +:= elapsed_ms() - start_wsf;
	    if index >= 0 {IF it shows up}
	    then max(5*tested_inter_times[index], to_ht_worst)
    	    else {if p hasn't been tested at all, take worst of all q's tested}
	    max(tested_neg_times##tested_pos_times##tested_inter_times##[0])
    	    fi {index >=0}
    fi {H.>=}

{whether to insist that a timed deform compute at least one term}
{set push_deform_flag = true}

{predicted time in milliseconds to complete is_unitary{to_ht}(p,{HT})}
set u_predictor(Param p, int HT) = int:
    let WSF = max(5*(p.real_form.semisimple_rank)^2, worst_so_far(p,HT)),
    	start_pred = elapsed_ms()
    in if not (deformed_hash_flag and predictor_flag)
       then WSF
       else {push_deform_flag:=true;}
       	    let delta = p.real_form.distinguished_involution,
	    	list = {is_unitary runs over terms in KL_sum_to_ht(p,HT)}
	    if HT < 0  {will do full_deform(q) on each term}
    	    then sort_by_height(partial_block(p)) {INCREASING height: get easier}
	    else monomials(KL_sum_at_s_to_ht(HT)(p))
	    fi
	    then () = list := for q in list
	    	 	    do if is_fixed(delta,q)
			       do q
			       fi
			    od.##
    	    then indices = for q in list do deformedHash.lookup(q) od
	    	 {have we stored answer? Storage location j if yes, -1 if no}
    	    then known_indices = [int]: for j in indices
    	 	       	       	 do if j >= 0
			       	       and ((deformedHash.height_index(j) < 0)
				       or (HT >= 0 and deformedHash.height_index(j) >= HT))
			    	    do j {loop that runs 0 or 1 times}
				    fi
			      	 od.##
    	     then N = #indices, n = #known_indices {possible terms, known terms}
    	     then times = for j in known_indices do deformedHash.time_index(j) od
	      {recorded times to compute known full_deform}
    	     in if predictor_verbose
	     	then prints(new_line,"Start predicting to height ", HT, " param ",p);
		     prints("(N,n) = (",N,",",n, "), times = ",times)
		fi;
       	        let ans = if n = 0 {no known times; compute _one_ such time}
       	     	    	  then let i0 = (2*#list)\3 {#list\2}
				       {if HT < 0
			       	       then 3*#list\5 {moderately difficult term}
				       else #list\6 {earlier in list is harder}
				       fi}
			       then q = list[i0] {necessarily not in deformedHash}
			       then () = if predictor_verbose
			       	       	 then prints("chosen random q is number ",i0,
					      " of ",N,": ",q)
					 fi
			       then start_def = elapsed_ms()
	    	 	       then Q = deformedHash.entry(q,HT)
			       then RT = elapsed_ms() - start_def
			       in if predictor_verbose
				  then prints("chosen random time ",
					       print_time_string(RT))
				  fi;
				  {max((N-1)*(RT+1), N*interrupt_base_time\2)}
				  (N-1)*(RT+1)
			       {deformedHash.maybe_entry(q,HT,2*WSF)}
		  	       {in case Q
		     	       	  | timed_out: max(2*N*WSF, interrupt_base_time)
		 	  	  | done(r): let j0 = deformedHash.lookup(q)
				    	     in if predictor_verbose
					     	then prints("chosen random time ",
						     print_time_string(deform_times[j0]))
						fi;
						max(N*deform_times[j0], interrupt_base_time)
		     		  esac}
			   else (N-n)*(max(times)+1) {N-n deforms to compute, estimated time}
			   	+ 2*n*interrupt_base_time {n lookups}
			   fi
		 in if predictor_verbose
		    then prints("prediction ",print_time_string(ans), " in time ",
		    	 print_time_string(elapsed_ms() - start_pred))
		    fi;
		    predictor_time+:= elapsed_ms() - start_pred;
		    ans
	    fi

{set adjust_factor = int: 5}

{return predicted (u_time, to_ht_time)}
set adjust_to_ht_over_u(Param p,int HT) = (int,int):
    (u_predictor(p,-1), u_predictor(p,HT))
    {if HT <= height(p) then return (0,0) fi;
    let u_time = u_predictor(p,-1), to_ht_time = u_predictor(p,HT)
    in to_ht_over_u_flag := (u_time > adjust_factor* to_ht_time) or strict_low(p,HT);
       (u_time,to_ht_time)}

{.write c-invariant form on standard module as a KTypePol }
{ never involves |twisted_full_deform| }
set c_form_std(Param p) = KTypePol:
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then deformedHash.entry(pc,-1)
       else full_deform(pc)
       fi

{.write c-invariant form on standard module as a KTypePol }
{ never involves |twisted_full_deform| }
set c_form_std_cut(int HT) = (Param p) KTypePol:
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then deformedHash.entry(pc,HT)
       else full_deform_to_ht_MvL_base(pc,HT)
       {to_ht(full_deform(pc),HT)}
       fi

{p must be fixed by standard involution!}
set twisted_c_form_std(Param p) = KTypePol: { c-form on extended group}
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then deformedHash.entry(pc,-1)
       else twisted_full_deform(pc)
       fi

{    c_form on irreducible representations   }

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as KTypePol }
set c_form_irreducible (Param p) = KTypePol:
   let ori_nr_p = orientation_nr(p)
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
in map(c_form_std@Param, oriented_KL_sum )

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as KTypePol }
set c_form_irreducible_cut (Param p,int HT) = KTypePol:
   let ori_nr_p = orientation_nr(p)
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s_to_ht(HT)(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
   then cfsc = (Param -> KTypePol): (Param p) KTypePol: c_form_std_cut(HT)(p)
in to_ht(map(cfsc, oriented_KL_sum),HT)

{    twisted_c_form_irreducible   }

{ utility: compute fixed and unfixed contributions to c-form on irreducible(p)
  no deformation is done, but orientation numbers are included;
  fixed contributions are already halved; for unfixed ones this needs to wait
}

{p must be fixed by standard involution!}
set twisted_c_form_irreducible_contributions (Param p) =
    (ParamPol,ParamPol): { (fixed part, 2*unfixed part) }
  let G=p.real_form, ori_nr_p = orientation_nr(p)
  then formula = (1+s)*KL_sum_at_s(p) + (1-s)*twisted_KL_sum_at_s(p)
  in { two value-producing loops can be a lot more efficient than one: }
  ( G.null_module +
      for c@q in formula
         if twist(q)=q do (half(c)*orientation_nr_term(ori_nr_p,q),q) fi
      od
   , G.null_module +
      for c@q in formula
         if twist(q)!=q do (c*orientation_nr_term(ori_nr_p,q),q) fi
      od
  )

set twisted_c_form_irreducible_contributions_cut (Param p, int HT) =
    (ParamPol,ParamPol): { (fixed part, 2*unfixed part) }
  let G=p.real_form, ori_nr_p = orientation_nr(p)
  then formula = (1+s)*KL_sum_at_s_to_ht(HT)(p) + (1-s)*twisted_KL_sum_at_s_to_ht(HT)(p)
  in { two value-producing loops can be a lot more efficient than one: }
     let (first,second) = ( (
      	 G.null_module +
      	 for c@q in formula
         if twist(q)=q do (half(c)*orientation_nr_term(ori_nr_p,q),q) fi
      	    	       od)
   , (G.null_module +
      for c@q in formula
         if twist(q)!=q do (c*orientation_nr_term(ori_nr_p,q),q) fi
      od))
      in if HT<0 then (first,second)
      	 else let (first_low,) = height_split(first,HT)
	      then (second_low,) = height_split(second,HT)
	      in (first_low,second_low)
	 fi
    {if HT < 0 then return twisted_KL_sum_at_s(p)
    else let (below,) = height_split(twisted_KL_sum_at_s(p),HT)
    	 in below
    fi}

{ The following function implements algorithm from Vogan in email 9/22/16:
  * for each delta-fixed term q add c_form_std(q) (fully twisted-deformed)
  * for each pair {q,delta(q)} add q*0 (deformation to nu=0 of q).
  For second kind it it convenient to add q*0 and delta(q)*0
  separately and at the end divide the sum of such contributions by 2.
}
{.twisted c-invariant form on an irreducible in terms of standardrepKs.}
{p must be fixed by standard involution!}
set twisted_c_form_irreducible_unnormalized (Param p) = KTypePol:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions(p)
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  in map(twisted_c_form_std@Param,fixed)+half(unfixed.K_type_pol)
)

{ normalization here means making the leading term 1 (rather than |s|) }
{p must be fixed by standard involution!}
set twisted_c_form_irreducible (Param p) = KTypePol:
   let unnormalized=twisted_c_form_irreducible_unnormalized(p)
   then (c,)=first_term(unnormalized)
in if c=1 then unnormalized
   elif c=s then s*unnormalized
   else error("leading coefficient is not 1 or s")
   fi

{.whether J(p) admits an invariant Hermitian form.}
set is_hermitian (Param p) = bool: equivalent(twist(p),p)

set check_hermitian (Param p, bool irreducible) = void:
  if not p.is_hermitian
  then error(if irreducible then "Irreducible" else "Standard" fi
            ," module does not admit any invariant Hermitian form")
  fi

set show_unitary_time() = void: prints("Time so far for is_unitary = ",
    		      print_time_string(unitaryTime))

{.Hermitian form on a irreducible module, normalization from its initial term.}
set hermitian_form_irreducible(Param p) = KTypePol:
  {unitary_test_counter.use();}
  let start_time = elapsed_ms()
  then answer = if is_equal_rank(real_form(p))
       	      	then c_form_irreducible(p) { not twisted, in equal rank case this is faster }
 		else check_hermitian(p,true); twisted_c_form_irreducible(p)
  		fi.convert_cform_hermitian
  in unitaryTime+:=elapsed_ms() - start_time;
     was_tested(p, elapsed_ms() - start_time, is_pure(answer));
     answer

set hermitian_form_irreducible_cut(Param p, int HT) = KTypePol:
  {unitary_test_counter.use();}
  let start_time = elapsed_ms()
  then answer = if is_equal_rank(real_form(p))
       	      	then c_form_irreducible_cut(p,HT) { not twisted, in equal rank case this is faster }
 		else check_hermitian(p,true); to_ht(twisted_c_form_irreducible(p),HT)
  		fi.convert_cform_hermitian
  in unitaryTime+:=elapsed_ms() - start_time;
     was_tested_to_ht(p,HT, elapsed_ms() - start_time, is_pure(answer));
     answer

{ compute Hermitian form on p, and report if it is unitary }
set is_unitary (Param p) = bool:
  p.is_hermitian and hermitian_form_irreducible(p).is_pure

{-1 if is_unitary, otherwise lowest height at which fails}
set is_unitary_depth(Param p) = int:
    if not p.is_hermitian
    then -2
    else hermitian_form_irreducible(p).impure_height
    fi

{ compute Hermitian form on p, and report if it is unitary }
set is_unitaryB (Param p) = bool:
  {unitary_test_counter.use();}
  let start_time = elapsed_ms()
  in if is_equal_rank(p.real_form)
  then let CF = c_form_irreducible(p)
       in if not is_typewise_pure(CF)
       	  then unitaryTime+:=elapsed_ms() - start_time;
	       was_tested(p, elapsed_ms() - start_time, false);
	       false
     	  else let answer = CF.convert_cform_hermitian.is_pure
	       then () = unitaryTime+:=elapsed_ms() - start_time
	       then () = was_tested(p, elapsed_ms() - start_time, answer)
	       in answer
     	  fi
   else check_hermitian(p,true);
   	let TCF = twisted_c_form_irreducible(p)
	in if not is_typewise_pure(TCF)
	   then unitaryTime+:=elapsed_ms() - start_time;
	        was_tested(p, elapsed_ms() - start_time, false);
	       	false
	   else let answer = TCF.convert_cform_hermitian.is_pure
	       then () = unitaryTime+:=elapsed_ms() - start_time
	       then () = was_tested(p, elapsed_ms() - start_time, answer)
	       in answer
	   fi
   fi

{ compute Hermitian form on p, and report
certificate; unitary means empty certificate }
set is_unitary_cert (Param p) = [KType]:
  hermitian_form_irreducible(p).is_pure_cert

{ compute Hermitian form on p, report if it is unitary, and otherwise record certificate }
set is_unitary(Param p,KTypePol_hash cert_hash) = bool:
  p.is_hermitian and is_pure_cert_hash(hermitian_form_irreducible(p),cert_hash)


{ some time-limited functions, using new built-in |full_deform@(Param,int)| }

{ the next type is the same as |Maybe<KTypePol>|, but injector names differ }
{set_type maybe_KTP = (void timed_out | KTypePol done)}

{1 means pure, 0 means timed out, -1 means impure}
set is_pure(maybe_KTP P) = int:
    case P
    | timed_out: 0
    | done(r): if is_pure(r)
      	       then 1
	       else -1
	       fi
    esac

set map ((Param->maybe_KTP)f, ParamPol P) = maybe_KTP:
  sum(P.real_form
     ,for c@p in P
     ~do case f(p) | timed_out: return timed_out() | done(r): c*r esac
      od
     ).done


{if deform_hash_flag, guaranteed to deform at least one term}
{finishes without interruption if all terms already deformed}
set c_form_irreducible (Param p,int time) = maybe_KTP:
   let ori_nr_p = orientation_nr(p), expiration = elapsed_ms() + time
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
   then list = [Param]: [], indices = [int]: [], unknown_ks = [int]: []
   then () = if deformed_hash_flag {this will compute one full_deform, unless that takes more than 20*time}
   	     then let () = list := monomials(oriented_KL_sum)
	     	  then () = indices := for p in list do deformedHash.lookup(p) od
		  then () = unknown_ks := for j@k in indices
    	 	       	       	 	     do if j < 0
			       	       	     	   or (deformedHash.height_index(j) >= 0)
			    	    		   do k {loop that runs 0 or 1 times}
				    		fi
			      	 	     od.##
		  in if #unknown_ks = 0
		     then return map( (Param q) KTypePol:
	      	   	      	      deformedHash.entry(q,-1), oriented_KL_sum).done
		     else deformedHash.maybe_entry(list[unknown_ks[(#unknown_ks-1)\2]],-1, 5*time)

		     fi {#unknown_ks = 0}
	     fi {deformed_hash_flag}
   in map( (Param q) maybe_KTP:
      if expiration - elapsed_ms() < 0 {and not keep_next}
      then timed_out()
      else if deformed_hash_flag
      	   then let j = deformedHash.lookup(q)
	   	in deformedHash.maybe_entry(q,-1, expiration - elapsed_ms())
	   else full_deform(q, expiration - elapsed_ms())
	   fi
      fi
      , oriented_KL_sum
      )

{if deform_hash_flag, guaranteed to deform at least one term (FAIL??}
{finishes without interruption if all terms already deformed}
set c_form_irreducible_cut (Param p,int HT, int time) = maybe_KTP:
   let ori_nr_p = orientation_nr(p), expiration = elapsed_ms() + time
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s_to_ht(HT)(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
   then list = [Param]: [], indices = [int]: [], unknown_ks = [int]: []
   then () = if deformed_hash_flag {this will compute one full_deform, unless that takes more than 20*time}
   	     then let () = list := monomials(oriented_KL_sum)
	     	  then () = indices := for p in list do deformedHash.lookup(p) od
		  then () = unknown_ks := for j@k in indices
    	 	       	       	 	     do if j < 0
			       	       	     	   or (deformedHash.height_index(j) >= 0 and
						       deformedHash.height_index(j) < HT)
			    	    		   do k {loop that runs 0 or 1 times}
				    		fi
			      	 	     od.##
		  in if #unknown_ks = 0
		     then return map( (Param q) KTypePol:
	      	   	      	      deformedHash.entry(q,HT), oriented_KL_sum).done
		     else {deformedHash.maybe_entry(list[unknown_ks[(#unknown_ks-1)\2]],-1, 5*time)}
		     	  deformedHash.entry(list[unknown_ks[(#unknown_ks-1)\2]],HT)
		     fi {#unknown_ks = 0}
	     fi {deformed_hash_flag}
   in map( (Param q) maybe_KTP:
      if expiration - elapsed_ms() < 0
      then timed_out()
      else if deformed_hash_flag
      	   then let j = deformedHash.lookup(q)
	   	in deformedHash.maybe_entry(q,HT, expiration - elapsed_ms())
	   else full_deform(q, expiration - elapsed_ms())
	   fi
      fi
      , oriented_KL_sum
      )


{if deform_hash_flag, guaranteed to deform at least one term}
set twisted_c_form_irreducible (Param p,int time) = maybe_KTP:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions(p)
  , expiration = elapsed_ms() + time{, keep_next = deformed_hash_flag and push_deform_flag}
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
   then list = [Param]: [], indices = [int]: [], unknown_ks = [int]: []
   then () = if deformed_hash_flag
   	     then let () = list := monomials(fixed)
	     	  then () = indices := for p in list do deformedHash.lookup(p) od
		  then () = unknown_ks := for j@k in indices
    	 	       	       	 	     do if j < 0
			       	       	     	   or (deformedHash.height_index(j) >= 0)
			    	    		   do k {loop that runs 0 or 1 times}
				    		fi
			      	 	     od.##
		  in if #unknown_ks > 0
		     then deformedHash.maybe_entry(list[unknown_ks[(#unknown_ks-1)\2]],-1,5*time)
		     fi
	     fi
  in case
        map( (Param q) maybe_KTP:
	if expiration - elapsed_ms() < 0 {and not keep_next}
      	then timed_out()
      	else if deformed_hash_flag
	     then {if (deformedHash.lookup(q).< or deform_max_heights[deformedHash.lookup(q)] >= 0)
	     	  then keep_next:= false; push_deform_flag:=false
		  fi;}
	     	  deformedHash.entry(q,-1).done
	     else twisted_full_deform(q, expiration - elapsed_ms())
	     fi
      	fi
	   , fixed
	   )
     | timed_out: timed_out()
     | done(r): done(r + half(unfixed.K_type_pol))
     esac
)

set hermitian_form_irreducible (Param p, int time) = maybe_KTP:
   {unitary_test_counter.use();}
   let start_time = elapsed_ms()
   then answer = case if is_equal_rank(real_form(p))
               	      then c_form_irreducible(p,time)
	 	      else check_hermitian(p,true);
		      	   twisted_c_form_irreducible(p,time)
	 	      fi
   		 | timed_out: was_tested_inter(p, elapsed_ms() - start_time);
		   	      timed_out()
   		 | done(r): let ans = r.convert_cform_hermitian
		   	    then total_time=elapsed_ms() - start_time, boo = is_pure(ans)
			    in was_tested(p, total_time, boo);
			       ans.done
   		 esac
  in unitaryTime+:=elapsed_ms() - start_time;
     answer

set hermitian_form_irreducible_cut (Param p, int HT, int time) = maybe_KTP:
   {unitary_test_counter.use();}
   let start_time = elapsed_ms()
   then answer = case if is_equal_rank(real_form(p))
               	      then c_form_irreducible_cut(p,HT,time)
	 	      else check_hermitian(p,true);
		      	   twisted_c_form_irreducible(p,time)
	 	      fi
   		 | timed_out: was_tested_inter_to_ht(p, HT, elapsed_ms() - start_time);
		   	      timed_out()
   		 | done(r): let ans = to_ht(r.convert_cform_hermitian,HT)
		   	    then total_time=elapsed_ms() - start_time, boo = is_pure(ans)
			    in was_tested_to_ht(p, HT, total_time, boo);
			       ans.done
   		 esac
  in unitaryTime+:=elapsed_ms() - start_time;
     answer


set is_unitary (Param p, int time) = int: { -1: no, 0:timed out, 1: yes }
    if p.is_hermitian
    else -1
    then case hermitian_form_irreducible(p,time)
       	 | timed_out: 0
       	 | done(result): if result.is_pure then 1 else -1 fi
       	 esac
    fi

{1: is unitary, 0: timed out, -1: non-hermitian, otherwise -2*(lowest nonunitary height+1)}
set is_unitary_depth (Param p, int time) = int: 
    if p.is_hermitian
    else -1
    then case hermitian_form_irreducible(p,time)
       	 | timed_out: 0
       	 | done(result): let D = result.impure_height
	   		 in if D<0 then 1
			    else -2*(D+1)
			    fi
       	 esac
    fi


{ end of core unitarity functionality, remaining variations for user comfort }

{ same as |c_form_irreducible|, but also return a second component that
  exposes the linear combination of contributions from standard representations
  that produced the result (parameter, coefficient, c_form on this standard)

  formulas: write
    J(y)  =sum_x               (-1)^{ell(x)-ell(y)}P(x,y)(q=1)I(x)
  then
    J(y)_c=sum_x (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
  where
    P(x,y) is a cumulated KL polynomial
    (-1)^{ell(x)-ell(y)}P(x,y) is given by signed_KL_col(y)[i] with
    indices[i]=x on(x,y)=orientation number given by orientation_nr_term()
    I(x)_c given as combination of standards x' with nu(x')=0 by c_form_std(x)
  algorithm: compute the sum for J(y)_c, using signed_KL_col and c_form_std
}
{.c-form on an irreducible, with extra output.}
set c_form_irreducible_long (Param p) =
      (ParamPol,[(Param,Split,KTypePol)],KTypePol):
   let ori_nr_p = orientation_nr(p), formula=KL_sum_at_s(p)
   then standards = { list of contributions }
      for c@q in formula
      do let form_on_standard = c_form_std(q)
         ,   factor           = c*orientation_nr_term(ori_nr_p,q)
      in (q,factor,form_on_standard)
      od
in ( formula, standards
   , null_K_module(p.real_form)+for(,c,f) in standards do c*f od
   )

{ starting formula in the c-form calculation: J(p)_c=sum w(q)I(q)_c }
set twisted_c_form_irreducible_as_sum_of_standards (Param p) = ParamPol:
  +twisted_c_form_irreducible_contributions(p) { add twisted and untwisted }

{.c_form_irreducible with extra information.}
set twisted_c_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,KTypePol)],[Param,Split,KType],KTypePol):
( assert(@:twist(p)=p,"parameter is not fixed by inner class involution");
  let (fixed,unfixed) = twisted_c_form_irreducible_contributions(p)
  then G=p.real_form
  , fixed_contribs = [(Param,Split,KTypePol)]:
      for c@q in fixed do (q,c,c*twisted_full_deform(q)) od
  , unfixed_contribs = [(Param,Split,KType)]:
      for c@q in unfixed
      do { now |1+s| divides |c|, which justifies not using |scale_extended|: }
         (q,c,K_type(q))
      od
  then fixed_terms = KTypePol: sum(G,for (,,c) in fixed_contribs do c od)
  ,  unfixed_terms = KTypePol:
        G.null_K_module+for (,c,q0) in unfixed_contribs do (c,q0) od
in ( fixed+unfixed
   , fixed_contribs
   , unfixed_contribs
   , fixed_terms + half(unfixed_terms) )
   )

set twist_orbits (ParamPol P) = ParamPol:
( assert(@:map(twist@Param,P)=P) { polynomial is assumed to be twist-stable }
; P.real_form.null_module +
  while !=P
  do let (c,q):term = P.first_term then tq=twist(q)
  in term
  next if q=tq then P-:=term else let m_c = -c in P+:=[(m_c,q),(m_c,tq)] fi
  od
)

{ print versions }

set print_twisted_c_form_irreducible_long (Param p) = void:
(  let (formula,terms0,terms1,answer) = twisted_c_form_irreducible_long(p)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
        ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("c-form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{ analyse }

{ print only terms with "mixed" coefficient (a+bs), i.e., both a,b\ne 0 }
set mixed (Split w)= bool: not w.is_pure
set mixed_terms (ParamPol P) = ParamPol:
  0*P + for w@p in P if w.mixed do (w,p) fi od
set analyse (ParamPol P) = void:
  prints("Mixed terms:",P.mixed_terms.pol_format)

{  Hermitian forms  }

{.Hermitian dual.}
set hermitian_dual (Param p) = Param: normal(twist(p))

{.Hermitian form on a standard module, canonical normalization.}
set hermitian_form_std (Param p) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_std(p)
  else check_hermitian(p,false); twisted_c_form_std(p)
  fi. convert_cform_hermitian

{.Hermitian form on a irreducible module, normalization from p0.}
set hermitian_form_irreducible (Param p,KType t0) = KTypePol:
  let c_invariant_form =
    if is_equal_rank(real_form(p)) { then avoid twisted version, for speed }
    then c_form_irreducible(p)
    else check_hermitian(p,true); twisted_c_form_irreducible(p)
    fi
  in convert_cform_hermitian(c_invariant_form,t0)

{. Hermitian form on an irreducible, with extra information.}
set hermitian_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,KTypePol)],[(Param,Split,KType)],KTypePol):
  { here we just use |twisted_c_form_irreducible| in all cases }
  check_hermitian(p,true);
  let (formula,terms0,terms1,cform) = twisted_c_form_irreducible_long(p)
  in (formula,terms0,terms1, convert_cform_hermitian(cform))

set hermitian_form_irreducible_long (Param p, KType t0) =
    (ParamPol,[(Param,Split,KTypePol)],[(Param,Split,KType)],KTypePol):
  check_hermitian(p,true);
  let (formula,terms0,terms1,cform) = twisted_c_form_irreducible_long(p)
  in (formula,terms0,terms1, convert_cform_hermitian(cform,t0))

{.nice output of hermitian_form_irreducible.}
set print_hermitian_form_irreducible (Param p) = void:
  hermitian_form_irreducible(p).pol_format.prints

{.nice output of Hermitian forms on list of parameters.}
set print_hermitian_form_irreducible ([Param] P) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p)
  od

set print_hermitian_form_irreducible (Param p,KType p0) = void:
  hermitian_form_irreducible(p,p0).pol_format.prints

set print_hermitian_form_irreducible ([Param] P,KType p0) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p,p0)
  od

set print_hermitian_form_irreducible_long (Param p) = void:
(  let (formula,terms0,terms1,answer) = hermitian_form_irreducible_long(p)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
         ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{.print Hermitian form on irreducible, plus extra information.}
set print_hermitian_form_irreducible_long (Param p,KType p0) = void:
(  let (formula,terms0,terms1,answer) = hermitian_form_irreducible_long(p,p0)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
         ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{ cut the red tape and tell about the hermitian form analysis directly }
set analyse_hermitian_form_irreducible (Param p) = void:
  if not p.is_hermitian
  then prints("Parameter ",p," is not delta-fixed; no hermitian form exists")
  else prints("Parameter ",p," is delta-fixed",new_line,
    "twisted c_form on irreducible in terms of standard representations:")
  ; let (fixed,unfixed) = twisted_c_form_irreducible_contributions(p)
    , c_form=p.real_form.null_K_module
    in
    if !=fixed then prints("Twist-fixed contributions:") fi
  ; c_form+:=
    for c@q in fixed
    do let contribution = c*twisted_full_deform(q) in
      prints(c,"* form on I(",q,"), fully deformed:",contribution,new_line)
    ; contribution
    od
  ; if !=unfixed then prints(new_line,"Non twist-fixed terms:") fi
  ; c_form+:=
    for c@q in twist_orbits(unfixed)
    do let contribution = half(c*K_type(q)+c*K_type(twist(q))) in
      prints(c,"*(I(",q,")",new_line
          ,"        +I(",twist(q),")), at nu=0:",contribution,new_line)
    ; contribution
    od
  ; prints(new_line,"Complete c-invariant form:",c_form,new_line)
  ; prints("Hermitian form:",c_form.convert_cform_hermitian,new_line)
  fi

{   unitarity and weak unitarity tests }

{ compute |p.hermitian_form_irreducible.is_pure|; try to get |false| rapidly }
set hermitian_form_is_pure (Param p) = bool:
( let G=p.real_form
  then (fixed,unfixed) = (ParamPol,ParamPol):
      twisted_c_form_irreducible_contributions(p)
  , result = KTypePol: G.null_K_module
  , tp0 = first_K_type(K_type(p)) { reference for |mu| }
  then limit = 1 + (fixed+unfixed).last_param.height
  then lowest (ParamPol P) = if =P then limit else P.first_param.height fi
  , cur_fix = ParamPol: G.null_module, cur_unfix = ParamPol: G.null_module
  in unfixed:=twist_orbits(unfixed) { choose one of each delta-exchanged pair }
; while
    let fh=fixed.lowest, uh=unfixed.lowest then height = min(fh,uh)+1 in
    height<=limit { equivalently |!=fixed or !=unfixed| }
  do
    if fh<height
    then set (cur_fix,fixed) := height_split(fixed,height)
    else cur_fix:=G.null_module
    fi
  ; if uh<height
    then set (cur_unfix,unfixed):=height_split(unfixed,height)
    else cur_unfix:=G.null_module
    fi
  ; result +:= map(twisted_full_deform@Param,cur_fix)
    	      +K_type_pol(cur_unfix)
  ; let (cur_result,later_result)=height_split(result,height) in
    if not convert_cform_hermitian(cur_result,tp0).is_pure_1
    then return false
    fi
  ; result:=later_result { we are done with terms below |height|, forget them }
  od
; convert_cform_hermitian(result,tp0).is_pure_1
)

set print_is_unitary (Param p) = void:
  if p.is_hermitian
  then let hf=hermitian_form_irreducible(p) in
    if hf.is_pure
    then prints("Unitary")
    else let (real,nonreal,mixed)=purity(hf) in
      prints("Non-Unitary",new_line
	    , real, " real terms", new_line
	    , nonreal," nonreal terms", new_line
	    , mixed, " mixed terms")
    fi
  else prints("Irreducible module does not admit any invariant Hermitian form")
  fi

{ no mixed terms }
set is_weakly_unitary (KTypePol P) = bool: let (,,mixed)=purity(P) in =mixed

{ compute Hermitian form on p, and report if it is weakly unitary }
set is_weakly_unitary (Param p) = bool:
  let G=real_form(p) in
  if is_equal_rank(G)
  then is_weakly_unitary(c_form_irreducible(p))
  else is_weakly_unitary(twisted_c_form_irreducible(p))
  fi

{ for "big" versions: see extParamPol.at }

set test_line (Param p) = void:
( let (x,lambda_minus_rho,gamma) = %p
  , points=reducibility_points(p)
  ,   ipoints=integrality_points(root_datum(p),2*nu(p))
  in prints("testing line through ", p)
; prints("reducibility points: ",points)
; prints("integrality points (for 2*nu): ",ipoints)
; if #points=0
  then prints("entire line is irreducible and unitary"
             ,if K_type(p).is_final then "" else " (nu=0 is not final)" fi)
  else points:=(0/1)#points { tack on initial zero }
  ; if not points[#points-1]=1/1 then points:=points#(1/1) fi
  ; for i:#points-1 from 1
    do
      let t=(points[i]+points[i-1])/2
      then q=param(x,lambda_minus_rho,gamma*t)         { mid point interval }
      ,    r=param(x,lambda_minus_rho,gamma*points[i]) { end point interval }
      in prints(nu(p)*t,": ", is_unitary(first_param(finalize(q))))
      ;  prints(nu(p)*points[i],": ", is_unitary(first_param(finalize(r))))
    od
  fi
)

set weak_test (Param p) = bool:
  let formula=twisted_c_form_irreducible(p)
  then bad=null_K_module(real_form(p)) +
    for w@p in formula if not is_pure(w) do w*p fi od
  in
  if #bad=0 then prints("number of terms: ", #formula); true
  else prints("number of terms: ", #formula,new_line,"bad terms:", bad ); false
  fi

set strong_test (Param p)=bool:
  let formula=hermitian_form_irreducible(p)
  then bad=null_K_module(real_form(p)) +
    for w@p in formula if not is_pure(w) do w*p fi od
  then OK = =bad { return whether bad terms are absent }
  in prints("number of terms: ", #formula);
  if not OK then prints("bad terms:", bad) fi; OK

set branch_c_form_irreducible(Param p, int N) = KTypePol:
  branch(c_form_irreducible(p),N)


{table of is_unitary results, indexed by Param}
{this type is not used}
set_type 
[ unitarity_bool_hash =
( ( -> int) size
  , ( -> int) count
  , ( -> ) clear
  , (Param->bool) entry
  , (Param->bool) do_you_know {asks if the answer is tabulated}
  , (Param->) append
  , ((Param,bool)->) attest {attest to unitarity of Param}
  , (int -> Param) param_index
  , (int -> bool) data_index
  )
]

set make_unitarity_bool_hash () = unitarity_bool_hash:
(  let param_hash = make_Param_hash()
   then bool_data = [bool] : []
   then clear() = void:
   	let () = param_hash.clear()
 	then () = bool_data:=[]
       	in ()
   in 
   ( ( -> int): { size } @int: #bool_data
   , ( -> int): { count } @int: count(bool_data)
   , ( -> ): {clear} clear
   , (Param -> bool): {entry} (Param p) bool:
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	then () = if m = M
	     	  then {unitary_test_counter.use();}
		       bool_data:= (bool_data next bool_data:= [])
		       	     	   # is_unitary(p);
		       assert(#bool_data = param_hash.size(),
		       			 "unitarity_bool_hash is damaged")
		  fi
	in bool_data[m]
     end
   , (Param -> bool): {do_you_know} (Param p) bool:
     if #simple_factors(p.real_form) = 1
     then p:=herm_center(p)
     fi;
     param_hash.lookup(p).>=
   , (Param->): {append } (Param p):
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	in if m = M
	   then {unitary_test_counter.use();}
		bool_data:= (bool_data next bool_data:= [])
		       	     	   # is_unitary(p)
           fi
     end
   , ((Param,bool)->): {attest} (Param p, bool answer):
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	in if m = M
	   then bool_data#:= answer {(bool_data next bool_data:= [])
		       	     	   # answer}
	   else assert(bool_data[m] = answer,"bad attest")
           fi
     end
   , (int -> Param): {param_index} (int j): param_hash.index(j)
   , (int -> bool): {data_index} (int j): bool_data[j]
  )
)

{smallest theta-stable Q from which p is good range cohomologically induced, and the inducing parameter}
set good_Q(Param p) = (KGPElt, Param):
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x), SCR = G.simple_coroots
    then goodS = ((for j in complement(G.semisimple_rank,suppS)
		     do if (gamma*SCR[j]).=
		        then [j]
		       	else []
		       	fi
		     od.##)##suppS).sort_u
    then goodQ = KGPElt:(goodS, x)
    then goodL = goodQ.Levi
    then xL = inverse_embed_KGB(x,goodL)
    then goodpL = parameter(xL, p.lambda_minus_rho+goodL.rho, p.nu)
    in (goodQ,goodpL)

set good_L(Param p) = RealForm:
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x), SCR = G.simple_coroots
    then goodS = ((for j in complement(G.semisimple_rank,suppS)
		     do if (gamma*SCR[j]).=
		        then [j]
		       	else []
		       	fi
		     od.##)##suppS).sort_u
    in (goodS,x).Levi

{smallest easy theta-stable Q from which p is weakly good range cohomologically
induced, and the inducing parameter}
set wkgood_Q(Param p) = (KGPElt, Param):
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x) {, SCR = G.simple_coroots}
    then wkgoodQ = KGPElt:(suppS, x)
    then wkgoodL = wkgoodQ.Levi
    then xL = inverse_embed_KGB(x,wkgoodL)
    then wkgoodpL = parameter(xL, p.lambda_minus_rho+wkgoodL.rho, p.nu)
    in (wkgoodQ,wkgoodpL)

{these functions are not used; subsumed by big_unitary_hash}
set unitarity_hash = make_unitarity_bool_hash()

set is_unitary_hash(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let (,pL) = wkgood_Q(p), G=p.real_form
    then derpLs = derived_factor_params0(pL)
    then answer = all([(->bool)] : for derpL in derpLs do @bool:
       			unitarity_hash.entry(derpL) od)
    {then formL = hermitian_form_irreducible(pL)}
    {then answer = is_pure(formL)}
    in if answer or pL = p
       then answer
       else {answer is false, and pL is on proper Levi}
       	    let goodL = good_L(p)
       	    in is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
			           goodL)
			      od))
       fi
    {unitarity_hash.entry(p)}

set do_you_know_is_unitary(Param p) = bool:
    unitarity_hash.do_you_know(p)

set attest_is_unitary(Param p, bool answer) = void:
    unitarity_hash.attest(p,answer)
