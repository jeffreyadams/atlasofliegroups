<basic.at
<convert_c_form.at
<hash.at {for KTypePol_hash}
<count.at {for unitary_test_counter}
<time.at {for print_time_string}

set deformLookupCounter = make_counter()
set deformCalcCounter = make_counter()

set to_ht (KTypePol P,int N) = KTypePol:
  let (below,)=height_split(P,N) in below

{tables of full_deform to ht, indexed by Param; one for each height}
set_type 
[ deformation_hash =
( ( -> int) size
  , ( -> bool) is_twisted
  , ( -> ) clear
  , ( -> int) height
  , (int -> ) adjust_height
  , (Param->KTypePol) entry
  , (Param->) append
  , (int -> Param) param_index
  , (int -> KTypePol) data_index
  )
]

set make_deformation_hash (int h, bool twisted) = deformation_hash:
(  let param_hash = make_Param_hash()
   then deformed_data = [KTypePol] : []
   then height = int:h
   then twisted = bool: twisted
   then clear() = void:
       let () = param_hash.clear()
       then () = deformed_data:=[]
       in ()
   in 
   ( ( -> int): { size } @int: param_hash.size()
   , ( -> bool): {is_twisted} @bool: twisted
   , ( -> ): {clear} clear
   , ( -> int): {height} @int: height
   , (int -> ): {adjust_height} (int h): height:= h
   , (Param -> KTypePol): {entry} (Param p)
     KTypePol:
     begin
	let M = param_hash.size()
	then m = param_hash.match(p)
	then () = if m = M
	     	  then deformCalcCounter.use();
		       if twisted
		       then deformed_data:= (deformed_data next deformed_data:= [])
		       	    #if height > 0
		             then to_ht(twisted_full_deform(p), height)
		  {might use to_ht(twisted_full_deform(p),height)?}
			     else twisted_full_deform(p)
			     fi
			else deformed_data:= (deformed_data next deformed_data:= [])
		       	     #if height > 0
		              then deform_to_height(p, height)
		  {might use to_ht(full_deform(p),height)?}
			      else full_deform(p)
			      fi
		  	fi
		  else deformLookupCounter.use()
		  fi
	in deformed_data[m]
     end
   , (Param->): {append } (Param p):
     begin
	let M = param_hash.size()
	then m = param_hash.match(p)
	then () = if m = M
	     	  then deformCalcCounter.use();
		       deformed_data:= (deformed_data next deformed_data:= [])
		       #if height > 0
		       	then deform_to_height(p, height)
			else full_deform(p)
			fi
		  else deformLookupCounter.use()
		  fi
	in ()
     end
   , (int -> Param): {param_index} (int j): param_hash.index(j)
   , (int -> KTypePol): {data_index} (int j): deformed_data[j]
  )
)

set deformedParams = for m:1500 do make_deformation_hash(m,false) od
{NEED TO MODIFY TWISTED HASH}
set twistedDeformedParams = for m:1500 do make_deformation_hash(m,true) od
{set deformations = [[KTypePol]]: for m:1500 do [] od
set twistedDeformations = [[KTypePol]]: for m:1500 do [] od}

{take a KTypePol _apparently_ attached to G and make it _actually_ attached
to G. Need this to use looked-up deformations.}
set regroup(RealForm G, KTypePol P) = KTypePol:
    sum(G, for c@q in P do let (,m) = %q.x
    	   in c*K_type(KGB(G,m), q.lambda_minus_rho) od)

{like is_pure, but in case of false, second value is the lowest K-type where the KTypePol
 changes sign. Better to put the guilty K-type in a hash table.}
set is_pure_cert(KTypePol P) = [KType]:
    if is_pure(P) then [KType]: []
    else let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0
	 then () = if a0*b0 != 0
	           then let ()= j:=0
		   	in ()
	           elif b0 = 0
	      	   then let ()= j:= first(for (,b,)@j in terms
	      	      	     	      	   do b!=0
				      	   od)
			in ()
	      	   else {now b0!=0 and a0=0}
		   	let () = j:= first(for (a,,)@j in terms
	      	      	     	      do a!=0
				      od)
			in ()
		   fi
	  then (,,pj) = terms[j]
	  in [pj]
    fi

{like is_pure_cert, but in case of false, writing the guilty K-types in a hash table.}
set is_pure_cert_hash_old(KTypePol P, KTypePol_hash cert_hash) = bool:
    if not is_pure(P)
    then let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0
	 then () = if a0*b0 != 0
	           then let ()= j:=0
		   	in ()
	           elif b0 = 0
	      	   then let ()= j:= first(for (,b,)@j in terms
	      	      	     	      	   do b!=0
				      	   od)
			in ()
	      	   else {now b0!=0 and a0=0}
		   	let () = j:= first(for (a,,)@j in terms
	      	      	     	      do a!=0
				      od)
			in ()
		   fi
	  then (,,pj) = terms[j]
	  then x = cert_hash.match(1*pj)
	  in false
    else true
    fi

{like is_pure_cert, but in case of false, writing the guilty K-types in a hash table.}
{ want this version to record SUM of lowest impurity }
set is_pure_cert_hash(KTypePol P, KTypePol_hash cert_hash) = bool:
    if not is_pure(P)
    then let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0 {next line is the lowest negative terms}
	 then B = if a0*b0 != 0
	          then to_ht(P,height(p0))
	          elif b0 = 0
	      	  then let N = sum(P.real_form, for (a,b,p) in terms
		   	      			do if b!=0 then [1*p] else [] fi od.##)
		   	in to_ht(N,height(first_K_type(N)))
	      	  else  {now b0!=0 and a0=0}
		       let N = sum(P.real_form, for (a,b,p) in terms
		   	      			do if a!=0 then [1*p] else [] fi od.##)
		       in to_ht(N,height(first_K_type(N)))
		  fi
	  then x = cert_hash.match(B)
	  in false
    else true
    fi

{.write c-invariant form on standard module as a KTypePol }
{set c_form_std = (Param->KTypePol): { never involves |twisted_full_deform| }
  full_deform@Param { built-in }}

set c_form_std(Param p) = KTypePol:
    let pc = alcove_center(p)
    in regroup(pc.real_form, deformedParams[0].entry(pc))

set twisted_c_form_std(Param p) = KTypePol: { c-form on extended group}
    let pc = alcove_center(p)
    in regroup(pc.real_form, twistedDeformedParams[0].entry(pc))

{    c_form on irreducible representations   }

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as KTypePol }
set c_form_irreducible (Param p) = KTypePol:
   let ori_nr_p = orientation_nr(p)
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
in map(c_form_std@Param, oriented_KL_sum )

{    twisted_c_form_irreducible   }

{ utility: compute fixed and unfixed contributions to c-form on irreducible(p)
  no deformation is done, but orientation numbers are included;
  fixed contributions are already halved; for unfixed ones this needs to wait
}
set twisted_c_form_irreducible_contributions (Param p) =
    (ParamPol,ParamPol): { (fixed part, 2*unfixed part) }
  let G=p.real_form, ori_nr_p = orientation_nr(p)
  then formula = (1+s)*KL_sum_at_s(p) + (1-s)*twisted_KL_sum_at_s(p)
  in { two value-producing loops can be a lot more efficient than one: }
  ( G.null_module +
      for c@q in formula
         if twist(q)=q do (half(c)*orientation_nr_term(ori_nr_p,q),q) fi
      od
   , G.null_module +
      for c@q in formula
         if twist(q)!=q do (c*orientation_nr_term(ori_nr_p,q),q) fi
      od
  )

{ The following function implements algorithm from Vogan in email 9/22/16:
  * for each delta-fixed term q add c_form_std(q) (fully twisted-deformed)
  * for each pair {q,delta(q)} add q*0 (deformation to nu=0 of q).
  For second kind it it convenient to add q*0 and delta(q)*0
  separately and at the end divide the sum of such contributions by 2.
}
{.twisted c-invariant form on an irreducible in terms of standardrepKs.}
set twisted_c_form_irreducible_unnormalized (Param p) = KTypePol:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions(p)
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  in map(twisted_c_form_std@Param,fixed)+half(unfixed.K_type_pol)
)

{ normalization here means making the leading term 1 (rather than |s|) }
set twisted_c_form_irreducible (Param p) = KTypePol:
   let unnormalized=twisted_c_form_irreducible_unnormalized(p)
   then (c,)=first_term(unnormalized)
in if c=1 then unnormalized
   elif c=s then s*unnormalized
   else error("leading coefficient is not 1 or s")
   fi

{.whether J(p) admits an invariant Hermitian form.}
set is_hermitian (Param p) = bool: equivalent(twist(p),p)

set check_hermitian (Param p, bool irreducible) = void:
  if not p.is_hermitian
  then error(if irreducible then "Irreducible" else "Standard" fi
            ," module does not admit any invariant Hermitian form")
  fi

{.Hermitian form on a irreducible module, normalization from its initial term.}
set hermitian_form_irreducible (Param p) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_irreducible(p) { not twisted, in equal rank case this is faster }
  else check_hermitian(p,true); twisted_c_form_irreducible(p)
  fi.convert_cform_hermitian

set unitaryTime = int: 0
set show_unitary_time() = void: prints("Time so far for is_unitary = ",
    		      print_time_string(unitaryTime))

{ compute Hermitian form on p, and report if it is unitary }
set is_unitary (Param p) = bool:
  unitary_test_counter.use();
  let start_time = elapsed_ms(), answer =
      p.is_hermitian and hermitian_form_irreducible(p).is_pure
  then () = unitaryTime+:=elapsed_ms() - start_time
  in answer

{ compute Hermitian form on p, and report
certificate; unitary means empty certificate }
set is_unitary_cert (Param p) = [KType]:
  hermitian_form_irreducible(p).is_pure_cert

{ compute Hermitian form on p, report if it is unitary, and otherwise record certificate }
set is_unitary(Param p,KTypePol_hash cert_hash) = bool:
  unitary_test_counter.use();
  p.is_hermitian and is_pure_cert_hash(hermitian_form_irreducible(p),cert_hash)

{ end of core unitarity functionality, remaining variations for user comfort }

{ same as |c_form_irreducible|, but also return a second component that
  exposes the linear combination of contributions from standard representations
  that produced the result (parameter, coefficient, c_form on this standard)

  formulas: write
    J(y)  =sum_x               (-1)^{ell(x)-ell(y)}P(x,y)(q=1)I(x)
  then
    J(y)_c=sum_x (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
  where
    P(x,y) is a cumulated KL polynomial
    (-1)^{ell(x)-ell(y)}P(x,y) is given by signed_KL_col(y)[i] with
    indices[i]=x on(x,y)=orientation number given by orientation_nr_term()
    I(x)_c given as combination of standards x' with nu(x')=0 by c_form_std(x)
  algorithm: compute the sum for J(y)_c, using signed_KL_col and c_form_std
}
{.c-form on an irreducible, with extra output.}
set c_form_irreducible_long (Param p) =
      (ParamPol,[(Param,Split,KTypePol)],KTypePol):
   let ori_nr_p = orientation_nr(p), formula=KL_sum_at_s(p)
   then standards = { list of contributions }
      for c@q in formula
      do let form_on_standard = c_form_std(q)
         ,   factor           = c*orientation_nr_term(ori_nr_p,q)
      in (q,factor,form_on_standard)
      od
in ( formula, standards
   , null_K_module(p.real_form)+for(,c,f) in standards do c*f od
   )

{ starting formula in the c-form calculation: J(p)_c=\sum w(q)I(q)_c }
set twisted_c_form_irreducible_as_sum_of_standards (Param p) = ParamPol:
  +twisted_c_form_irreducible_contributions(p) { add twisted and untwisted }

{.c_form_irrecible with extra information.}
set twisted_c_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,KTypePol)],[Param,Split,KType],KTypePol):
( assert(twist(p)=p,"parameter is not fixed by inner class involution");
  let (fixed,unfixed) = twisted_c_form_irreducible_contributions(p)
  then G=p.real_form
  , fixed_contribs = [(Param,Split,KTypePol)]:
      for c@q in fixed do (q,c,c*twisted_full_deform(q)) od
  , unfixed_contribs = [(Param,Split,KType)]:
      for c@q in unfixed
      do { now |1+s| divides |c|, which justifies not using |scale_extended|: }
         (q,c,K_type(q))
      od
  then fixed_terms = KTypePol: sum(G,for (,,c) in fixed_contribs do c od)
  ,  unfixed_terms = KTypePol:
        G.null_K_module+for (,c,q0) in unfixed_contribs do (c,q0) od
in ( fixed+unfixed
   , fixed_contribs
   , unfixed_contribs
   , fixed_terms + half(unfixed_terms) )
   )

set twist_orbits (ParamPol P) = ParamPol:
( assert(map(twist@Param,P)=P) { polynomial is assumed to be twist-stable }
; P.real_form.null_module +
  while !=P
  do let (c,q):term = P.first_term then tq=twist(q)
  in term
  next if q=tq then P-:=term else let m_c = -c in P+:=[(m_c,q),(m_c,tq)] fi
  od
)

{ print versions }

set print_twisted_c_form_irreducible_long (Param p) = void:
(  let (formula,terms0,terms1,answer) = twisted_c_form_irreducible_long(p)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
        ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("c-form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{ analyse }

{ print only terms with "mixed" coefficient (a+bs), i.e., both a,b\ne 0 }
set mixed (Split w)= bool: not w.is_pure
set mixed_terms (ParamPol P) = ParamPol:
  0*P + for w@p in P if w.mixed do (w,p) fi od
set analyse (ParamPol P) = void:
  prints("Mixed terms:",P.mixed_terms.pol_format)

{  Hermitian forms  }

{.Hermitian dual.}
set hermitian_dual (Param p) = Param: normal(twist(p))

{.Hermitian form on a standard module, canonical normalization.}
set hermitian_form_std (Param p) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_std(p)
  else check_hermitian(p,false); twisted_c_form_std(p)
  fi. convert_cform_hermitian

{.Hermitian form on a irreducible module, normalization from p0.}
set hermitian_form_irreducible (Param p,KType t0) = KTypePol:
  let c_invariant_form =
    if is_equal_rank(real_form(p)) { then avoid twisted version, for speed }
    then c_form_irreducible(p)
    else check_hermitian(p,true); twisted_c_form_irreducible(p)
    fi
  in convert_cform_hermitian(c_invariant_form,t0)

{. Hermitian form on an irreducible, with extra information.}
set hermitian_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,KTypePol)],[(Param,Split,KType)],KTypePol):
  { here we just use |twisted_c_form_irreducible| in all cases }
  check_hermitian(p,true);
  let (formula,terms0,terms1,cform) = twisted_c_form_irreducible_long(p)
  in (formula,terms0,terms1, convert_cform_hermitian(cform))

set hermitian_form_irreducible_long (Param p, KType t0) =
    (ParamPol,[(Param,Split,KTypePol)],[(Param,Split,KType)],KTypePol):
  check_hermitian(p,true);
  let (formula,terms0,terms1,cform) = twisted_c_form_irreducible_long(p)
  in (formula,terms0,terms1, convert_cform_hermitian(cform,t0))

{.nice output of hermitian_form_irreducible.}
set print_hermitian_form_irreducible (Param p) = void:
  hermitian_form_irreducible(p).pol_format.prints

{.nice output of Hermitian forms on list of parameters.}
set print_hermitian_form_irreducible ([Param] P) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p)
  od

set print_hermitian_form_irreducible (Param p,KType p0) = void:
  hermitian_form_irreducible(p,p0).pol_format.prints

set print_hermitian_form_irreducible ([Param] P,KType p0) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p,p0)
  od

set print_hermitian_form_irreducible_long (Param p) = void:
(  let (formula,terms0,terms1,answer) = hermitian_form_irreducible_long(p)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
         ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{.print Hermitian form on irreducible, plus extra information.}
set print_hermitian_form_irreducible_long (Param p,KType p0) = void:
(  let (formula,terms0,terms1,answer) = hermitian_form_irreducible_long(p,p0)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
         ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{ cut the red tape and tell about the hermitian form analysis directly }
set analyse_hermitian_form_irreducible (Param p) = void:
  if not p.is_hermitian
  then prints("Parameter ",p," is not delta-fixed; no hermitian form exists")
  else prints("Parameter ",p," is delta-fixed",new_line,
    "twisted c_form on irreducible in terms of standard representations:")
  ; let (fixed,unfixed) = twisted_c_form_irreducible_contributions(p)
    , c_form=p.real_form.null_K_module
    in
    if !=fixed then prints("Twist-fixed contributions:") fi
  ; c_form+:=
    for c@q in fixed
    do let contribution = c*twisted_full_deform(q) in
      prints(c,"* form on I(",q,"), fully deformed:",contribution,new_line)
    ; contribution
    od
  ; if !=unfixed then prints(new_line,"Non twist-fixed terms:") fi
  ; c_form+:=
    for c@q in twist_orbits(unfixed)
    do let contribution = half(c*K_type(q)+c*K_type(twist(q))) in
      prints(c,"*(I(",q,")",new_line
          ,"        +I(",twist(q),")), at nu=0:",contribution,new_line)
    ; contribution
    od
  ; prints(new_line,"Complete c-invariant form:",c_form,new_line)
  ; prints("Hermitian form:",c_form.convert_cform_hermitian,new_line)
  fi

{   unitarity and weak unitarity tests }

{ compute |p.hermitian_form_irreducible.is_pure|; try to get |false| rapidly }
set hermitian_form_is_pure (Param p) = bool:
( let G=p.real_form
  then (fixed,unfixed) = (ParamPol,ParamPol):
      twisted_c_form_irreducible_contributions(p)
  , result = KTypePol: G.null_K_module
  , tp0 = first_K_type(K_type(p)) { reference for |mu| }
  then limit = 1 + (fixed+unfixed).last_param.height
  then lowest (ParamPol P) = if =P then limit else P.first_param.height fi
  , cur_fix = ParamPol: G.null_module, cur_unfix = ParamPol: G.null_module
  in unfixed:=twist_orbits(unfixed) { choose one of each delta-exchanged pair }
; while
    let fh=fixed.lowest, uh=unfixed.lowest then height = min(fh,uh)+1 in
    height<=limit { equivalently |!=fixed or !=unfixed| }
  do
    if fh<height
    then set (cur_fix,fixed) := height_split(fixed,height)
    else cur_fix:=G.null_module
    fi
  ; if uh<height
    then set (cur_unfix,unfixed):=height_split(unfixed,height)
    else cur_unfix:=G.null_module
    fi
  ; result +:= map(twisted_full_deform@Param,cur_fix)
    	      +K_type_pol(cur_unfix)
  ; let (cur_result,later_result)=height_split(result,height) in
    if not convert_cform_hermitian(cur_result,tp0).is_pure_1
    then return false
    fi
  ; result:=later_result { we are done with terms below |height|, forget them }
  od
; convert_cform_hermitian(result,tp0).is_pure_1
)

set print_is_unitary (Param p) = void:
  if p.is_hermitian
  then let hf=hermitian_form_irreducible(p) in
    if hf.is_pure
    then prints("Unitary")
    else let (real,nonreal,mixed)=purity(hf) in
      prints("Non-Unitary",new_line
	    , real, " real terms", new_line
	    , nonreal," nonreal terms", new_line
	    , mixed, " mixed terms")
    fi
  else prints("Irreducible module does not admit any invariant Hermitian form")
  fi

{ no mixed terms }
set is_weakly_unitary (KTypePol P) = bool: let (,,mixed)=purity(P) in =mixed

{ compute Hermitian form on p, and report if it is weakly unitary }
set is_weakly_unitary (Param p) = bool:
  let G=real_form(p) in
  if is_equal_rank(G)
  then is_weakly_unitary(c_form_irreducible(p))
  else is_weakly_unitary(twisted_c_form_irreducible(p))
  fi

{ for "big" versions: see extParamPol.at }

set test_line (Param p) = void:
( let (x,lambda_minus_rho,gamma) = %p
  , points=reducibility_points(p)
  ,   ipoints=integrality_points(root_datum(p),2*nu(p))
  in prints("testing line through ", p)
; prints("reducibility points: ",points)
; prints("integrality points (for 2*nu): ",ipoints)
; if #points=0
  then prints("entire line is irreducible and unitary"
             ,if K_type(p).is_final then "" else " (nu=0 is not final)" fi)
  else points:=(0/1)#points { tack on initial zero }
  ; if not points[#points-1]=1/1 then points:=points#(1/1) fi
  ; for i:#points-1 from 1
    do
      let t=(points[i]+points[i-1])/2
      then q=param(x,lambda_minus_rho,gamma*t)         { mid point interval }
      ,    r=param(x,lambda_minus_rho,gamma*points[i]) { end point interval }
      in prints(nu(p)*t,": ", is_unitary(first_param(finalize(q))))
      ;  prints(nu(p)*points[i],": ", is_unitary(first_param(finalize(r))))
    od
  fi
)

set weak_test (Param p) = bool:
  let formula=twisted_c_form_irreducible(p)
  then bad=null_K_module(real_form(p)) +
    for w@p in formula if not is_pure(w) do w*p fi od
  in
  if #bad=0 then prints("number of terms: ", #formula); true
  else prints("number of terms: ", #formula,new_line,"bad terms:", bad ); false
  fi

set strong_test (Param p)=bool:
  let formula=hermitian_form_irreducible(p)
  then bad=null_K_module(real_form(p)) +
    for w@p in formula if not is_pure(w) do w*p fi od
  then OK = =bad { return whether bad terms are absent }
  in prints("number of terms: ", #formula);
  if not OK then prints("bad terms:", bad) fi; OK

set branch_c_form_irreducible(Param p, int N) = KTypePol:
  branch(c_form_irreducible(p),N)


{table of is_unitary results, indexed by Param}
set_type 
[ unitarity_bool_hash =
( ( -> int) size
  , ( -> int) count
  , ( -> ) clear
  , (Param->bool) entry
  , (Param->bool) do_you_know {asks if the answer is tabulated}
  , (Param->) append
  , ((Param,bool)->) attest {attest to unitarity of Param}
  , (int -> Param) param_index
  , (int -> bool) data_index
  )
]

set make_unitarity_bool_hash () = unitarity_bool_hash:
(  let param_hash = make_Param_hash()
   then bool_data = [bool] : []
   then clear() = void:
   	let () = param_hash.clear()
 	then () = bool_data:=[]
       	in ()
   in 
   ( ( -> int): { size } @int: #bool_data
   , ( -> int): { count } @int: count(bool_data)
   , ( -> ): {clear} clear
   , (Param -> bool): {entry} (Param p) bool:
     begin
	let M = param_hash.size()
	then m = param_hash.match(p)
	then () = if m = M
	     	  then unitary_test_counter.use();
		       bool_data:= (bool_data next bool_data:= [])
		       	     	   # is_unitary(p);
		       assert(#bool_data = param_hash.size(),
		       			 "unitarity_bool_hash is damaged")
		  fi
	in bool_data[m]
     end
   , (Param -> bool): {do_you_know} (Param p) bool:
     param_hash.lookup(p).>=
   , (Param->): {append } (Param p):
     begin
	let M = param_hash.size()
	then m = param_hash.match(p)
	in if m = M
	   then unitary_test_counter.use();
		bool_data:= (bool_data next bool_data:= [])
		       	     	   # is_unitary(p)
           fi
     end
   , ((Param,bool)->): {attest} (Param p, bool answer):
     begin
	let M = param_hash.size()
	then m = param_hash.match(p)
	in if m = M
	   then bool_data#:= answer {(bool_data next bool_data:= [])
		       	     	   # answer}
	   else assert(bool_data[m] = answer,"bad attest")
           fi
     end
   , (int -> Param): {param_index} (int j): param_hash.index(j)
   , (int -> bool): {data_index} (int j): bool_data[j]
  )
)

set unitarity_hash = make_unitarity_bool_hash()

set is_unitary_hash(Param p) = bool:
    unitarity_hash.entry(p)

set do_you_know_is_unitary(Param p) = bool:
    unitarity_hash.do_you_know(p)

set attest_is_unitary(Param p, bool answer) = void:
    unitarity_hash.attest(p,answer)
