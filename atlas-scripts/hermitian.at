<basic.at
<convert_c_form.at
<hash.at {for KTypePol_hash}
<count.at {for unitary_test_counter}
<time.at {for print_time_string}
<cohom_reductionND {for derived_factor_params}
<FPP_faces_geom {for herm_center}{get charTime!}
<writeFiles {for write commands}

set deformLookupCounter = make_counter()
set deformCalcCounter = make_counter()
set twistedDeformLookupCounter = make_counter()
set twistedDeformCalcCounter = make_counter()

{typewise_pure(c_form) is a necessary condition for purity of hermitian form, and rules out a lot}
set is_typewise_pure(KTypePol P) = bool:
    all(for c@tau in P do is_pure(c) od)

{let p = pmax(x,lambda,nu) be the FPP parameter of biggest infl char gamma;
and write LAM = height(pmax), GAM = height(gamma), R = height(rho).}

{when bottom_layer is used at (x,lambda), more_shift is set to shift_frac*(GAM - LAM)}
{DECREASING means less deep bottom layer, which is faster but catches less non-unitarity}
{a little experimentation suggested that shift_frac about 1 would capture almost all the
non-unitarity that it's possible to capture with bottom layer; but that is expensive in time.}
set shift_frac = rat: 1/3

{the integer more_shift, controlling shifts for non-minimal
parabolics, is bounded by min_ht_mult times the shift for the minimal
(classification) parabolic.}
set min_ht_mult = rat: 2/1

{bottom layer is used only when LAM/GAM  < LAGAmax...}
{should be in [0,1]}
set LAGAmax = rat: 3/4

{... and GAM/R + LAM/GAM > GARLAGmin}
{should be in [0,2]}
set GARLAGmin = 1/1

{more_shift invoked when when GAM/R > GARmin}
set GARmin = rat: 3/5

set LARmax = rat: 4/5
set LAGAmin = 1/1
set LARmin = rat: 1/2

{next three global variables concern function is_unitary_test_big_SIMPLE_interrupt in FPP_faces_herm.at}
set up_mu_time = int:0
set mu_time_mult = rat: 1/1 {1/1}

{it "true" use up_mu_hash to calculate heights for is_unitary_to_ht}
{set up_mu_flag = false {true}}

{multiple of G.rank to use as jump in step size}
set mu_rank_mult = rat: 1/2 {1/4}

set test_bl_time = int: 0

set test_no_unitary_time = int: 0

set test_no_Dirac_time = int: 0

{how often deforming location succeeds in proving unitary}
set hash_def_true_count = int: 0

{how often deforming location succeeds in proving nonunitary}
set hash_def_false_count = int: 0

set def_thruples_time = int:0

{if true, try to raise mu in few steps to minimize number of to_ht calculations}
set max_loc_flag = true

{records how many pairs (x,lambda) are skipped because all Params are
indefinite on LKTs.}
set none_count = int:0

set hash_real_dumbCounter = make_counter()
set hash_dumbCounter = make_counter()
set hash_def_dumbCounter = make_counter()
set hashCounter = make_counter()
set hash2Counter = make_counter()
set hash_one_levelCounter = make_counter()
set hash_bottom_layerCounter = make_counter()
set hash_steveCounter = make_counter()

{ the next type is the same as |Maybe<KTypePol>|, but injector names differ }
set_type maybe_KTP = (void timed_out | KTypePol done)

{to record time spent in is_unitary, is_unitary_to_ht, etc.}
set unitaryTime = int: 0

set to_ht (KTypePol P,int N) = KTypePol:
  if N<0 then return P fi;
  let (below,)=height_split(P,N) in below

{set to_ht (ParamPol P,int N) = ParamPol:
  if N<0 then return P fi;
  let (below,)=height_split(P,N) in below}

{take a KTypePol _apparently_ attached to G and make it _actually_ attached
to G. Need this to use looked-up deformations.}
set regroup(RealForm G, KTypePol P) = KTypePol:
    sum(G, for c@q in P do let (,m) = %q.x
    	   in c*K_type(KGB(G,m), q.lambda_minus_rho) od)

set regroup(RealForm G, Param p) = Param:
    parameter(G, p.x.number, p.lambda, p.nu)

{ table of full_deform to ht, indexed by Param. Height zero means no cutoff.}
{Twisted always stored with no cutoff, since we don't now have a good twisted
to_ht, so make that a separate type.}
set_type
[ deformation_hash_to_ht =
( ( -> int) size {number of parameters stored}
  , ( -> ) clear
  , (Param -> int) height {maximum height to which p is deformed}
  , ((Param,int)->KTypePol) entry
  , (Param->int) lookup
  , ((Param,int,KTypePol)->) append
  , ((Param,int,maybe_KTP)->) maybe_append
  , (int -> Param) param_index {parameter #j}
  , (int -> int) height_index {height to which parameter #j is deformed}
  , (int -> KTypePol) data_index {deformation of parameter #j to its ht}
  )
]

set deform_param_hash = make_Param_hash() {used as index into...}
set deformed_data = [KTypePol] : []
set deform_max_heights = [int] : []
set deform_use_count = [int] : []
set make_deformation_hash_to_ht () = deformation_hash_to_ht:
(  let clear() = void:
       let () = deform_param_hash.clear()
       then () = deform_max_heights :=[]
       then () = deformed_data :=[]
       then () = deform_use_count := []
       in ()
   then add_param(Param p, int h) = int:
       	let I = deform_param_hash.size()
	then i = deform_param_hash.lookup(p)
	then P = null_K_module(SL(1,R))
	then () = if i.< {haven't seen this p before}
	     then deformCalcCounter.use();
	     	  P := if h=0
	     	      then full_deform(p)
		      else deform_to_height(p,h)
		      fi;
		   deform_param_hash.match(p);
		   i:=I;
		   deform_max_heights #:= h;
		   deformed_data#:=P;
		   deform_use_count#:=0
	      elif {i>=0; p seen} h=0 and deform_max_heights[i].>
	      then deformCalcCounter.use();
	      	   P := full_deform(p);
		   deform_max_heights[i]:=0;
		   deformed_data[i]:=P
	      elif {i >0, h>0 or } deform_max_heights[i] > 0 and h > deform_max_heights[i]
	      then deformCalcCounter.use();
	      	   P := deform_to_height(p,h);
		   deform_max_heights[i]:=h;
		   deformed_data[i]:=P
	      else deformLookupCounter.use()
	      fi
	  then () = deform_use_count[i] +:=1
	  in i
   in
   ( ( -> int): {size} @int: deform_param_hash.size()
  , ( -> ): {clear} clear
  , (Param -> int): {height} (Param p): deform_max_heights[deform_param_hash.lookup(p)]
  , ((Param, int)->KTypePol): {entry} (Param p, int h):
    let i = add_param(p, h)
    in if h > 0
       then regroup(p.real_form,to_ht(deformed_data[i],h))
       else regroup(p.real_form,deformed_data[i])
       fi
  , (Param->int): {lookup} (Param p): deform_param_hash.lookup(p)
  , ((Param,int,KTypePol)->): {append} (Param p, int h, KTypePol P):
    let I = deform_param_hash.size()
    then i = deform_param_hash.match(p)
    in if i=I {haven't seen p before}
       then deform_max_heights #:=h;
	    deformed_data#:=P;
	    deform_use_count#:=0
       elif {i < I} (h=0 and deform_max_heights[i].>) 
	    or h>deform_max_heights[i] {seen p, but not to h}
       then deform_max_heights[i]:=h;
	    deformed_data[i]:=P
       fi
  , ((Param,int,maybe_KTP)->): {maybe_append} (Param p, int HT, maybe_KTP P):
    case P
    	 | timed_out: ()
    	 | done(result):
    	   let I = deform_param_hash.size()
    	   then i = deform_param_hash.match(p)
    	   in if i=I {haven't seen p before}
       	      then deform_max_heights #:=HT;
	      	   deformed_data#:=result;
	   	    deform_use_count#:=0
       	      elif {i < I} (HT=0 and deform_max_heights[i].>) 
	      	   or HT>deform_max_heights[i] {seen p, but not to HT}
       	      then deform_max_heights[i]:=HT;
	      	   deformed_data[i]:=result
       	      fi
    esac
  , (int -> Param): {param_index} (int j): deform_param_hash.index(j)
  , (int -> int): {height_index} (int j): deform_max_heights[j]
  , (int -> KTypePol): {data_index} (int j): deformed_data[j]
  )
)

set append_to_deformation_hash(RealForm G, Param p, [KPolTermDatum] data, int ht, int use) = void:
    let I = deform_param_hash.size()
    then i = deform_param_hash.lookup(p)
    in if i.< {haven't seen this p}
       then deform_param_hash.match(p);
	    i:=I;
	    deform_max_heights #:=ht;
	    deformed_data #:= K_pol(G,data);
	    deform_use_count #:= use
       elif (deform_max_heights[i] < ht) or
	    (ht = 0 and deform_max_heights[i] > 0)
       then deform_param_hash.match(p);
       	    deform_max_heights[i] := ht;
	    deformed_data[i] := K_pol(G, data);
	    deform_use_count[i] +:=use
       fi

set append_to_deformation_hash(RealForm G, [Param] p_list, [[KPolTermDatum]] data_list,
    [int] ht_list, [int] use_list) = void:
    for p@j in p_list
    do append_to_deformation_hash(G,p,data_list[j],ht_list[j],use_list[j])
    od
set write_deformation_frac = 100

{write the part of deformation_hash referring to G}
set write_deformation_hash(RealForm G) = void:
    let param_list = deform_param_hash.list()
    then M = max((for P@j in deformed_data do
    deform_use_count[j]*#deformed_data[j] od)#0)
    then good_j = for p@j in param_list
    	 	   do if p.real_form = G and deform_use_count[j]* #deformed_data[j] *write_deformation_frac > M
		      then [j]
		      else []
		      fi
		   od.##
    then good_param_list = for j in good_j do param_list[j] od
    then good_deformed_data = for j in good_j do K_data(deformed_data[j]) od
    then good_deform_max_heights = for j in good_j do deform_max_heights[j] od
    then good_deform_use_count = for j in good_j do deform_use_count[j] od
    in write_real_form(G,"G_temp");
       for p@k in good_param_list
       do let (,x) = %p.x
       	  in prints("let p_temp = parameter(G_temp,",x,",",p.lambda,",",p.nu,")");
	     prints("then temp_def_data = ",good_deformed_data[k]);
       	     prints("in append_to_deformation_hash(G_temp, p_temp,",good_deformed_data[k],",",
       		  good_deform_max_heights[k],",", good_deform_use_count[k],")")
       od

set_type
[ twisted_deformation_hash =
( ( -> int) size {number of parameters stored}
  , ( -> ) clear
  , (Param -> int) height {maximum height to which p is deformed}
  , ((Param,int)->KTypePol) entry
  , (Param->int) lookup
  , ((Param,int,KTypePol)->) append
  , ((Param,int,maybe_KTP)->) maybe_append
  , (int -> Param) param_index {parameter #j}
  , (int -> int) height_index {height to which parameter #j is deformed}
  , (int -> KTypePol) data_index {deformation of parameter #j}
  )
]

set twisted_deform_param_hash = make_Param_hash() {used as index into...}
set twisted_deformed_data = [KTypePol] : []
set twisted_deform_max_heights = [int] : []
set twisted_deform_use_count = [int] : []

set make_twisted_deformation_hash() = twisted_deformation_hash:
(   let clear() = void:
       let () =  twisted_deform_param_hash.clear()
       then () = twisted_deform_max_heights :=[]
       then () = twisted_deformed_data :=[]
       then () = twisted_deform_use_count := []
       in ()
   then add_param(Param p, int h) = int:
       	let I =  twisted_deform_param_hash.size()
	then i =  twisted_deform_param_hash.match(p)
	then P = null_K_module(SL(1,R))
	then () = if i=I {haven't seen this p before}
	     then twistedDeformCalcCounter.use();
	     	  P := if h=0
		       then twisted_full_deform(p)
		       else to_ht(twisted_full_deform(p),h)
		       fi;
		  twisted_deformed_data#:=P;
		  twisted_deform_max_heights #:=h;
		  twisted_deform_use_count#:=0
	      elif {i>=0; p seen} h=0 and deform_max_heights[i].>
	      then twistedDeformCalcCounter.use();
	      	   P := twisted_full_deform(p);
		   twisted_deform_max_heights[i]:=0;
		   twisted_deformed_data[i]:=P
	      elif {i >0, h>0 or } deform_max_heights[i] > 0
	       	    and h > deform_max_heights[i]
	      then twistedDeformCalcCounter.use();
	      	   P := to_ht(twisted_full_deform(p),h);
		   twisted_deform_max_heights[i]:=h;
		   twisted_deformed_data[i]:=P
	      else twistedDeformLookupCounter.use()
	      fi
	  in i
   in
   ( ( -> int): {size} @int:  twisted_deform_param_hash.size()
  , ( -> ): {clear} clear
  , (Param -> int): {height} (Param p):twisted_deform_max_heights[deform_param_hash.lookup(p)]
  , ((Param,int)->KTypePol): {entry} (Param p, int h):
    let i = add_param(p,h)
    in if h > 0
       then regroup(p.real_form,to_ht(twisted_deformed_data[i],h))
       else regroup(p.real_form,twisted_deformed_data[i])
       fi
  , (Param->int): {lookup} (Param p): deform_param_hash.lookup(p)
  , ((Param,int,KTypePol)->): {append} (Param p, int h, KTypePol P):
    let I = deform_param_hash.size()
    then i = deform_param_hash.match(p)
    in if i=I {haven't seen p before}
       then deform_max_heights #:=h;
	    deformed_data#:=P;
	    deform_use_count#:=0
       elif {i < I} (h=0 and deform_max_heights[i].>) 
	    or h>deform_max_heights[i] {seen p, but not to h}
       then deform_max_heights[i]:=h;
	    deformed_data[i]:=P
       fi
  , ((Param,int,maybe_KTP)->): {maybe_append} (Param p, int HT, maybe_KTP P):
    case P
    	 | timed_out: ()
    	 | done(result):
    	   let I = twisted_deform_param_hash.size()
    	   then i = twisted_deform_param_hash.match(p)
    	   in if i=I {haven't seen p before}
       	      then twisted_deform_max_heights #:=HT;
	      	   twisted_deformed_data#:=result;
	   	   twisted_deform_use_count#:=0
       	      elif {i < I} (HT=0 and twisted_deform_max_heights[i].>) 
	      	   or HT>deform_max_heights[i] {seen p, but not to HT}
       	      then twisted_deform_max_heights[i]:=HT;
	      	   twisted_deformed_data[i]:=result
       	      fi
    esac
  , (int -> Param): {param_index} (int j):  twisted_deform_param_hash.index(j)
  , (int -> int): {height_index} (int j): twisted_deform_max_heights[j]
  , (int -> KTypePol): {data_index} (int j): twisted_deformed_data[j]
  )
)

set append_to_twisted_deformation_hash(RealForm G, Param p, [KPolTermDatum] data) = void:
    let I = twisted_deform_param_hash.size()
    then i = twisted_deform_param_hash.match(p)
    in if i=I {haven't seen this p}
       then twisted_deformed_data #:= K_pol(G,data)
       fi

set append_to_twisted_deformation_hash(RealForm G, [Param] p_list, [[KPolTermDatum]] data_list) = void:
    for p@j in p_list
    do append_to_twisted_deformation_hash(G,p,data_list[j])
    od

{write the part of deformation_hash referring to G}
set write_twisted_deformation_hash(RealForm G) = void:
    let param_list = twisted_deform_param_hash.list()
    then good_j = for p@j in param_list
    	 	   do if p.real_form = G then [j]
		      else []
		      fi
		   od.##
    then good_param_list = for j in good_j do param_list[j] od
    then good_twisted_deformed_data = for j in good_j do K_data(twisted_deformed_data[j]) od
    in write_real_form(G,"G_temp");
       for p@k in good_param_list
       do let (,x) = %p.x
       	  in prints("let p_temp = parameter(G_temp,",x,",",p.lambda,",",p.nu,")");
       	     prints("in append_to_twisted_deformation_hash(G_temp,p_temp,",good_twisted_deformed_data[k],
	     ")")
       od
{whether to use these hash tables. "False" saves quite a bit of memory
(about 10% in F4_s) with very little speed cost (less than 1% in
F4_s)}
{TRUE should help interrupted to_ht}
set deformed_hash_flag = true

set deformedHash = make_deformation_hash_to_ht()
set twistedDeformedHash = make_twisted_deformation_hash()

{like is_pure, but in case of false, second value is the lowest K-type where
the KTypePol changes sign. Better to put the guilty K-type in a hash table.}
set is_pure_cert(KTypePol P) = [KType]:
    if is_pure(P) then [KType]: []
    else let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0
	 then () = if a0*b0 != 0
	           then let ()= j:=0
		   	in ()
	           elif b0 = 0
	      	   then let ()= j:= first(for (,b,)@j in terms
	      	      	     	      	   do b!=0
				      	   od)
			in ()
	      	   else {now b0!=0 and a0=0}
		   	let () = j:= first(for (a,,)@j in terms
	      	      	     	      do a!=0
				      od)
			in ()
		   fi
	  then (,,pj) = terms[j]
	  in [pj]
    fi

{like is_pure_cert, but in case of false, writing the guilty K-types in a
hash table.}
set is_pure_cert_hash_old(KTypePol P, KTypePol_hash cert_hash) = bool:
    if not is_pure(P)
    then let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0
	 then () = if a0*b0 != 0
	           then let ()= j:=0
		   	in ()
	           elif b0 = 0
	      	   then let ()= j:= first(for (,b,)@j in terms
	      	      	     	      	   do b!=0
				      	   od)
			in ()
	      	   else {now b0!=0 and a0=0}
		   	let () = j:= first(for (a,,)@j in terms
	      	      	     	      do a!=0
				      od)
			in ()
		   fi
	  then (,,pj) = terms[j]
	  then x = cert_hash.match(1*pj)
	  in false
    else true
    fi

{like is_pure_cert, but in case of false, writing the guilty K-types in a
hash table.}
{ want this version to record SUM of lowest impurity }
set is_pure_cert_hash(KTypePol P, KTypePol_hash cert_hash) = bool:
    if not is_pure(P)
    then let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0 {next line is the lowest negative terms}
	 then B = if a0*b0 != 0
	          then to_ht(P,height(p0))
	          elif b0 = 0
	      	  then let N = sum(P.real_form, for (a,b,p) in terms
		   	      			do if b!=0 then [1*p] else [] fi od.##)
		   	in to_ht(N,height(first_K_type(N)))
	      	  else  {now b0!=0 and a0=0}
		       let N = sum(P.real_form, for (a,b,p) in terms
		   	      			do if a!=0 then [1*p] else [] fi od.##)
		       in to_ht(N,height(first_K_type(N)))
		  fi
	  then x = cert_hash.match(B)
	  in false
    else true
    fi

{meant to hold number of NEGATIVE Dirac inequality tests}
set DTcount = int: 0

{meant to hold number of NEGATIVE Dirac_best inequality tests}
set DBTcount = int: 0


{will be modified to name of local test being run}
set test_string = string: ""

{whether to report on slow is_unitary and is_unitary_to_ht}
set drain_plug_flag = bool: false

{report on tests requiring more than this time; default is 100000 = 10 seconds}
set drain_plug_time = int: 100000

set tested_pos_hash = make_Param_hash()
set tested_pos_times = [int]: [] {one for each tested_pos_hash.list() entry}
set tested_pos_strings = [string]: []
set tested_pos_counts = [int]: []

set tested_neg_hash = make_Param_hash()
set tested_neg_times = [int]: [] {one for each tested_list entry}
set tested_neg_strings = [string]: []
set tested_neg_counts = [int]: []

set tested_inter_hash = make_Param_hash()
set tested_inter_times = [int]: [] {one for each tested_inter_hash.list() entry}
set tested_inter_counts = [int]: []
{set tested_inter_strings = [string]: []}

set tested_pos_to_ht_hashes = [Param_hash]: [] {for h:100 do make_Param_hash() od}
set tested_pos_to_ht_times = [[int]]: [] {for h:100 do [int]:[] od}
set tested_pos_to_ht_strings = [[string]]: [] {for h:100 do [] od}
set tested_pos_to_ht_counts = [[int]]: []

set tested_neg_to_ht_hashes = [Param_hash]: [] {for h:100 do make_Param_hash() od}
set tested_neg_to_ht_times = [[int]]: [] {for h:100 do [int]:[] od}
set tested_neg_to_ht_strings = [[string]]: [] {for h:100 do [] od}
set tested_neg_to_ht_counts = [[int]]: []

set OT_hash = make_Param_hash()
set OT_times = [int]: [] {cumulative time for each OT_hash.list() entry}
set OT_counts = [int]: [] {number of occurrences for each OT_hash.list() entry}

{set cSp = int:0}
set was_tested(Param p, int T, bool ans) = void:
    {let () = if p = parameter(Sp(6,R),8,[2,1,1],[1,-1,0]/2)
    	     then cSp+:=1; 1/(cSp-4)
	     else 1/1
	     fi}
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," to test is_unitary = ", ans)
    fi;
    if ans
    then let M = tested_pos_hash.size()
    	 then m = tested_pos_hash.match(p)
       	 in if m = M
	    then tested_pos_times#:=T;
	    	 tested_pos_strings #:= test_string;
		 tested_pos_counts #:=1
	    else tested_pos_times[m] +:= T;
	    	 tested_pos_counts[m] +:= 1
	    fi
    else let M = tested_neg_hash.size()
    	 then m = tested_neg_hash.match(p)
    	 in if m = M
	    then tested_neg_times#:=T;
	    	 tested_neg_strings #:= test_string;
		 tested_neg_counts #:=1
	    else tested_neg_times[m] +:= T;
	    	 tested_neg_counts[m] +:= 1
	    fi
    fi

set was_tested_inter(Param p, int T) = void:
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," for interrupted is_unitary")
    fi;
    let M = tested_inter_hash.size()
    then m = tested_inter_hash.match(p)
    in if m=M
       then tested_inter_times #:= T;
       	    tested_inter_counts #:=1
       else tested_inter_times[m] +:= T;
       	    tested_inter_counts[m] +:=1
       fi

{keep track of whether interruption failed}
set was_tested_inter(Param p, int T, int T_target) = void:
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," for interrupted is_unitary")
    fi;
    if T>(5/4)*T_target
    then let OTM = OT_hash.size()
    	 then OTm = OT_hash.match(p)
	 in if OTm=OTM
	    then OT_times #:= T - T_target;
	    	 OT_counts #:= 1
	    else OT_times[OTm] +:= T - T_target;
	    	 OT_counts[OTm] +:= 1
	    fi
    fi;
    let M = tested_inter_hash.size()
    then m = tested_inter_hash.match(p)
    in if m=M
       then tested_inter_times #:= T;
       	    tested_inter_counts #:=1
       else tested_inter_times[m] +:= T;
       	    tested_inter_counts[m] +:=1
       fi


set was_tested_to_ht(Param p,int N, int T, bool ans) = void:
    if drain_plug_flag and T > drain_plug_time
    then prints(p," took ",print_time_string(T)," to test is_unitary_to_ht ", N,
    	 	 " = ",ans)
    fi;
    let h = N - height(p)
    then add = h+1 - #tested_pos_to_ht_hashes
    then () = if add>0
    	      then tested_pos_to_ht_hashes ##:= for j:add do make_Param_hash() od;
	      	   tested_neg_to_ht_hashes ##:= for j:add do make_Param_hash() od;
		   tested_pos_to_ht_times ##:= for j:add do [int]: [] od;
		   tested_neg_to_ht_times ##:= for j:add do [int]: [] od;
		   tested_pos_to_ht_strings ##:= for j:add do [string]: [] od;
		   tested_neg_to_ht_strings ##:= for j:add do [string]: [] od;
		   tested_pos_to_ht_counts ##:= for j:add do [int]: [] od;
		   tested_neg_to_ht_counts ##:= for j:add do [int]: [] od
	      fi
    in if ans
       then let M = tested_pos_to_ht_hashes[h].size()
    	    then m = tested_pos_to_ht_hashes[h].match(p)
       	    in if m = M
	       then tested_pos_to_ht_times[h]#:=T;
	    	 tested_pos_to_ht_strings[h] #:= test_string;
		 tested_pos_to_ht_counts[h] #:=1
	    else let tpthh = tested_pos_to_ht_times[h]
	    	 then () = tpthh[m] +:= T
		 in tested_pos_to_ht_times[h] := tpthh;
	    	 let tpthc = tested_pos_to_ht_counts[h]
		 then () = tpthc[m] +:= 1
		 in tested_pos_to_ht_counts[h] := tpthc
	    fi
    else let M = tested_neg_to_ht_hashes[h].size()
    	 then m = tested_neg_to_ht_hashes[h].match(p)
    	 in if m = M
	    then tested_neg_to_ht_times[h]#:=T;
	    	 tested_neg_to_ht_strings[h] #:= test_string;
		 tested_neg_to_ht_counts[h] #:=1
	    else let tnthh = tested_neg_to_ht_times[h]
	    	 then () = tnthh[m] +:= T
		 in tested_neg_to_ht_times[h] := tnthh;
	    	 let tnthc = tested_neg_to_ht_counts[h]
		 then () = tnthc[m] +:= 1
		 in tested_neg_to_ht_counts[h] := tnthc
	    fi
    fi

set report_tested(string label) = void:
    prints("...",label,"...",DTcount," Dirac elim, ",DBTcount," best-Dirac elim");
    prints(tested_pos_hash.size()," pos is_unitary tests, in time = ",
    	print_time_string(sum(tested_pos_times)),"; ",tested_neg_hash.size()," neg is_unitary tests, in time = ",
    	print_time_string(sum(tested_neg_times)));
    prints(sum(tested_inter_counts), " interrupted is_unitary tests, of ",
    	   tested_inter_hash.size(), " different parameters, in time ",
	print_time_string(sum(tested_inter_times)));
    prints(sum(for hash in tested_pos_to_ht_hashes do hash.size() od)," pos tests to_ht, in time = ",
 	 	   print_time_string(sum(for list in tested_pos_to_ht_times do sum(list) od)),"; ",
	   sum(for hash in tested_neg_to_ht_hashes do hash.size() od)," neg tests to_ht, in time = ",
 	   	   print_time_string(sum(for list in tested_neg_to_ht_times do sum(list) od)));
    if OT_hash.size() > 0
    then prints(OT_hash.size()," params had ", sum(OT_counts), " interrupted tests go too long by ",
    	 print_time_string(sum(OT_times)))
    fi;
    prints("#bottom_layer = ",hash_bottom_layerCounter.use_count(), ", #one_level = ",
    	   hash_one_levelCounter.use_count(), {", #real_dumb = "} ", #dumb = ",
	   hash_real_dumbCounter.use_count() +
    	   hash_dumbCounter.use_count() +
   	    hash_def_dumbCounter.use_count(), ", #hash = ",
    	    hashCounter.use_count(), ", #hash2 = ",
    	    hash2Counter.use_count(), ", #steve = ",hash_steveCounter.use_count());
    prints(print_time_string(unitaryTime)," for ",unitary_test_counter.use_count()," unitarity tests; ",
    print_time_string(charTime), " for ",char_counter.use_count(), " char calculations.");
    {prints("time for up_mu = ",print_time_string(up_mu_time), ", mu_time_mult = ",mu_time_mult,
    	   ", shift_frac = ",shift_frac, ", min_ht_mult = ", min_ht_mult);}
    {prints({"LAGAmax = ",LAGAmax,", GARLAGmin = ",GARLAGmin, ", GARmin = ", GARmin,}
    	   "Dirac elims = ",DTcount,", Dirac_best elims = ",DBTcount, ", ",print_time_string(def_thruples_time),
	   " to find deformed thruple candidates.");
    prints("Found ",hash_def_true_count," deformations proving unitarity (to height), ",
    	   hash_def_false_count," deformations proving nonunitarity (to height).")
    prints("no_unitary_time = ", print_time_string(test_no_unitary_time), ", no_Dirac_time = ",
    	   print_time_string(test_no_Dirac_time)," , #(x,lambda) eliminated by LKTs = ",none_count);}
    prints("  ----------------")

set report_tested() = void: report_tested("")

{doesn't work with report_tested_cum}
set clear_report_tested() = void:
    tested_pos_hash.clear(); tested_pos_times:=[]; tested_pos_strings:=[]; tested_pos_counts:=[];
    tested_neg_hash.clear(); tested_neg_times:=[]; tested_neg_strings:=[]; tested_neg_counts:=[];
    tested_inter_hash.clear(); tested_inter_times:=[]; tested_inter_counts:=[];
    OT_hash.clear(); OT_times:=[]; OT_counts:=[]
    for h:#tested_pos_to_ht_hashes
    do tested_pos_to_ht_hashes[h].clear(); tested_pos_to_ht_times[h]:=[]; tested_pos_to_ht_strings[h]:=[];
       tested_pos_to_ht_counts[h]:=[]; tested_neg_to_ht_counts[h]:=[];
       tested_neg_to_ht_hashes[h].clear(); tested_neg_to_ht_times[h]:=[]; tested_neg_to_ht_strings[h]:=[]
    od

set (report_tested_cum,clear_report_tested_cum_clear) = (((string, string) -> void),(void->void)):
    let tph = int: 0, tpt = int:0, tnh = int: 0, tnt = int:0, oth = int:0, otc = int:0, ott = int:0
    then tic = int: 0, tih = int: 0, tit = int:0, tphh = int: 0, tpht = int:0, tnhh = int: 0, tnht = int: 0,
    	 utc = int: 0, utt = int: 0, ct = int:0, cu = int: 0, DTc = int:0, DBTc = int: 0
    in (((string,string)->void): (string local_label, string running_label) void:
    prints("  ----------------");
    prints("...",local_label,"...",DTcount - DTc," Dirac elim, ",DBTcount - DBTc," best-Dirac elim");
    	DTc :=DTcount; DBTc := DBTcount;
    prints(tested_pos_hash.size() - tph, " pos is_unitary tests, in time = ",
    	print_time_string(sum(tested_pos_times) - tpt),"; ",tested_neg_hash.size() - tnh,
	" neg is_unitary tests, in time = ",print_time_string(sum(tested_neg_times) - tnt));
	tph:=tested_pos_hash.size();
	tpt := sum(tested_pos_times);
	tnh:=tested_neg_hash.size();
	tnt := sum(tested_neg_times);
    prints(sum(tested_inter_counts) - tic, " interrupted is_unitary tests, of ",
    	   tested_inter_hash.size() - tih, " different parameters, in time ",
	print_time_string(sum(tested_inter_times) - tit));
	tic:= sum(tested_inter_counts);
	tih:= tested_inter_hash.size();
	tit:=sum(tested_inter_times);
    prints(sum(for hash in tested_pos_to_ht_hashes do hash.size() od) -tphh," pos tests to_ht, in time = ",
    	print_time_string(sum(for list in tested_pos_to_ht_times do sum(list) od) - tpht),"; ",
	   sum(for hash in tested_neg_to_ht_hashes do hash.size() od) - tnhh," neg tests to_ht, in time = ",
 	   	   print_time_string(sum(for list in tested_neg_to_ht_times do sum(list) od) - tnht));
        tphh:= sum(for hash in tested_pos_to_ht_hashes do hash.size() od);
	tpht:=sum(for list in tested_pos_to_ht_times do sum(list) od);
        tnhh:= sum(for hash in tested_neg_to_ht_hashes do hash.size() od);
	tnht:=sum(for list in tested_neg_to_ht_times do sum(list) od);
    if OT_hash.size() - oth > 0
    then prints(OT_hash.size()-oth," params had ", sum(OT_counts)-otc, " interrupted tests go too long by ",
    	 print_time_string(sum(OT_times) -ott));
	 oth:=OT_hash.size();
	 otc := sum(OT_counts);
	 ott := sum(OT_times)
    fi;
    prints("#bottom_layer = ",hash_bottom_layerCounter.use_count(), ", #one_level = ",
    	   hash_one_levelCounter.use_count(), {", #real_dumb = "} ", #dumb = ",
	   hash_real_dumbCounter.use_count() +
    	   hash_dumbCounter.use_count() +
   	    hash_def_dumbCounter.use_count(), ", #hash = ",
    	    hashCounter.use_count(), ", #hash2 = ",
    	    hash2Counter.use_count(), ", #steve = ",hash_steveCounter.use_count());
    prints(print_time_string(unitaryTime - utt)," for ",unitary_test_counter.use_count() -utc,
    					 " unitarity tests; ",
    			     print_time_string(charTime - ct), " for ",char_counter.use_count() -cu,
			     " char calculations.");
	 utt:= unitaryTime;
	 utc:=unitary_test_counter.use_count();
	 ct:=charTime;
	 cu:= char_counter.use_count();
    prints("...",running_label,"...",DTcount," Dirac elim, ",DBTcount," best-Dirac elim");
    prints(tph," pos is_unitary tests, in time = ", print_time_string(tpt),"; ",tnh,
	" neg is_unitary tests, in time = ",print_time_string(tnt));
    prints(tic, " interrupted is_unitary tests, of ",tih, " different parameters, in time ",
	print_time_string(tit));
    prints(tphh," pos tests to_ht, in time = ",print_time_string(tpht),"; ",tnhh," neg tests to_ht, in time = ",
 	print_time_string(tnht));
    if oth.>
    then prints(OT_hash.size()," params had ", sum(OT_counts), " interrupted tests go too long by ",
    	 print_time_string(sum(OT_times)))
    fi;
    prints("#bottom_layer = ",hash_bottom_layerCounter.use_count(), ", #one_level = ",
    	   hash_one_levelCounter.use_count(), {", #real_dumb = "} ", #dumb = ",
	   hash_real_dumbCounter.use_count() +
    	   hash_dumbCounter.use_count() +
   	    hash_def_dumbCounter.use_count(), ", #hash = ",
    	    hashCounter.use_count(), ", #hash2 = ",
    	    hash2Counter.use_count(), ", #steve = ",hash_steveCounter.use_count());
    prints(print_time_string(unitaryTime)," for ",unitary_test_counter.use_count()," unitarity tests; ",
    print_time_string(charTime), " for ",char_counter.use_count(), " char calculations.");
    prints("  ----------------")
    , @: {clear_report_tested_cum_clear}
     tph := 0; tpt := 0; tnh := 0; tnt :=0; oth :=0; otc :=0; ott :=0;
     tic := 0; tih := 0; tit :=0; tphh := 0; tpht :=0; tnhh := 0; tnht := 0;
     utc := 0; utt := 0; ct :=0; cu := 0; DTc:=0; DBTc:=0)

set report_tested_cum() = report_tested_cum("","")

{.write c-invariant form on standard module as a KTypePol }
{ never involves |twisted_full_deform| }
set c_form_std(Param p) = KTypePol:
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then deformedHash.entry(pc,0)
       else full_deform(pc)
       fi

set twisted_c_form_std(Param p) = KTypePol: { c-form on extended group}
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then twistedDeformedHash.entry(pc,0)
       else twisted_full_deform(pc)
       fi

{    c_form on irreducible representations   }

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as KTypePol }
set c_form_irreducible (Param p) = KTypePol:
   let ori_nr_p = orientation_nr(p)
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
in map(c_form_std@Param, oriented_KL_sum )

{    twisted_c_form_irreducible   }

{ utility: compute fixed and unfixed contributions to c-form on irreducible(p)
  no deformation is done, but orientation numbers are included;
  fixed contributions are already halved; for unfixed ones this needs to wait
}
set twisted_c_form_irreducible_contributions (Param p) =
    (ParamPol,ParamPol): { (fixed part, 2*unfixed part) }
  let G=p.real_form, ori_nr_p = orientation_nr(p)
  then formula = (1+s)*KL_sum_at_s(p) + (1-s)*twisted_KL_sum_at_s(p)
  in { two value-producing loops can be a lot more efficient than one: }
  ( G.null_module +
      for c@q in formula
         if twist(q)=q do (half(c)*orientation_nr_term(ori_nr_p,q),q) fi
      od
   , G.null_module +
      for c@q in formula
         if twist(q)!=q do (c*orientation_nr_term(ori_nr_p,q),q) fi
      od
  )

{ The following function implements algorithm from Vogan in email 9/22/16:
  * for each delta-fixed term q add c_form_std(q) (fully twisted-deformed)
  * for each pair {q,delta(q)} add q*0 (deformation to nu=0 of q).
  For second kind it it convenient to add q*0 and delta(q)*0
  separately and at the end divide the sum of such contributions by 2.
}
{.twisted c-invariant form on an irreducible in terms of standardrepKs.}
set twisted_c_form_irreducible_unnormalized (Param p) = KTypePol:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions(p)
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  in map(twisted_c_form_std@Param,fixed)+half(unfixed.K_type_pol)
)

{ normalization here means making the leading term 1 (rather than |s|) }
set twisted_c_form_irreducible (Param p) = KTypePol:
   let unnormalized=twisted_c_form_irreducible_unnormalized(p)
   then (c,)=first_term(unnormalized)
in if c=1 then unnormalized
   elif c=s then s*unnormalized
   else error("leading coefficient is not 1 or s")
   fi

{.whether J(p) admits an invariant Hermitian form.}
set is_hermitian (Param p) = bool: equivalent(twist(p),p)

set check_hermitian (Param p, bool irreducible) = void:
  if not p.is_hermitian
  then error(if irreducible then "Irreducible" else "Standard" fi
            ," module does not admit any invariant Hermitian form")
  fi

set show_unitary_time() = void: prints("Time so far for is_unitary = ",
    		      print_time_string(unitaryTime))

{.Hermitian form on a irreducible module, normalization from its initial term.}
set hermitian_form_irreducible (Param p) = KTypePol:
  unitary_test_counter.use();
  let start_time = elapsed_ms()
  then answer = if is_equal_rank(real_form(p))
       	      	then c_form_irreducible(p) { not twisted, in equal rank case this is faster }
 		else check_hermitian(p,true); twisted_c_form_irreducible(p)
  		fi.convert_cform_hermitian
  then () = unitaryTime+:=elapsed_ms() - start_time
  then () = was_tested(p, elapsed_ms() - start_time, is_pure(answer))
  in answer

{ compute Hermitian form on p, and report if it is unitary }
set is_unitary (Param p) = bool:
  p.is_hermitian and hermitian_form_irreducible(p).is_pure

{ compute Hermitian form on p, and report if it is unitary }
set is_unitaryB (Param p) = bool:
  unitary_test_counter.use();
  let start_time = elapsed_ms()
  in if is_equal_rank(p.real_form)
  then let CF = c_form_irreducible(p)
       in if not is_typewise_pure(CF)
       	  then unitaryTime+:=elapsed_ms() - start_time;
	       was_tested(p, elapsed_ms() - start_time, false);
	       false
     	  else let answer = CF.convert_cform_hermitian.is_pure
	       then () = unitaryTime+:=elapsed_ms() - start_time
	       then () = was_tested(p, elapsed_ms() - start_time, answer)
	       in answer
     	  fi
   else check_hermitian(p,true);
   	let TCF = twisted_c_form_irreducible(p)
	in if not is_typewise_pure(TCF)
	   then unitaryTime+:=elapsed_ms() - start_time;
	        was_tested(p, elapsed_ms() - start_time, false);
	       	false
	   else let answer = TCF.convert_cform_hermitian.is_pure
	       then () = unitaryTime+:=elapsed_ms() - start_time
	       then () = was_tested(p, elapsed_ms() - start_time, answer)
	       in answer
	   fi
   fi

{ compute Hermitian form on p, and report
certificate; unitary means empty certificate }
set is_unitary_cert (Param p) = [KType]:
  hermitian_form_irreducible(p).is_pure_cert

{ compute Hermitian form on p, report if it is unitary, and otherwise record certificate }
set is_unitary(Param p,KTypePol_hash cert_hash) = bool:
  p.is_hermitian and is_pure_cert_hash(hermitian_form_irreducible(p),cert_hash)


{ some time-limited functions, using new built-in |full_deform@(Param,int)| }

{ the next type is the same as |Maybe<KTypePol>|, but injector names differ }
{set_type maybe_KTP = (void timed_out | KTypePol done)}

{1 means pure, 0 means timed out, -1 means impure}
set is_pure(maybe_KTP P) = int:
    case P
    | timed_out: 0
    | done(r): if is_pure(r)
      	       then 1
	       else -1
	       fi
    esac

set map ((Param->maybe_KTP)f, ParamPol P) = maybe_KTP:
  sum(P.real_form
     ,for c@p in P
     ~do case f(p) | timed_out: return timed_out() | done(r): c*r esac
      od
     ).done

set c_form_irreducible (Param p,int time) = maybe_KTP:
   let ori_nr_p = orientation_nr(p), expiration = elapsed_ms() + time
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
   in map( (Param p) maybe_KTP: (let ans =full_deform(p,expiration-elapsed_ms())
      	   	     		in deformedHash.maybe_append(p, 0, ans);
				   ans)
      , oriented_KL_sum
      )

set twisted_c_form_irreducible (Param p,int time) = maybe_KTP:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions(p)
  , expiration = elapsed_ms() + time
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  in case
        map( (Param p) maybe_KTP: (let ans = twisted_full_deform(p,expiration-elapsed_ms())
	     	       		  in twistedDeformedHash.maybe_append(p,0,ans);
				     ans)
	   , fixed
	   )
     | timed_out: timed_out()
     | done(r): done(r + half(unfixed.K_type_pol))
     esac
)

set hermitian_form_irreducible (Param p, int time) = maybe_KTP:
   unitary_test_counter.use();
   let start_time = elapsed_ms()
   then answer = case if is_equal_rank(real_form(p))
               	      then c_form_irreducible(p,time)
	 	      else check_hermitian(p,true); twisted_c_form_irreducible(p,time)
	 	      fi
   		 | timed_out: unitaryTime+:=elapsed_ms() - start_time; was_tested_inter(p, elapsed_ms() - start_time,
		   time); return timed_out()
   		 | done(r): let ans = r.convert_cform_hermitian
		   	    then () = was_tested(p, elapsed_ms() - start_time, is_pure(ans)) in return ans.done
   		 esac
  then () = unitaryTime+:=elapsed_ms() - start_time
  in answer

set is_unitary (Param p, int time) = int: { -1: no, 0:timed out, 1: yes }
    if p.is_hermitian
    else -1
    then case hermitian_form_irreducible(p,time)
       	 | timed_out: 0
       	 | done(result): if result.is_pure then 1 else -1 fi
       	 esac
    fi

{ end of core unitarity functionality, remaining variations for user comfort }

{ same as |c_form_irreducible|, but also return a second component that
  exposes the linear combination of contributions from standard representations
  that produced the result (parameter, coefficient, c_form on this standard)

  formulas: write
    J(y)  =sum_x               (-1)^{ell(x)-ell(y)}P(x,y)(q=1)I(x)
  then
    J(y)_c=sum_x (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
  where
    P(x,y) is a cumulated KL polynomial
    (-1)^{ell(x)-ell(y)}P(x,y) is given by signed_KL_col(y)[i] with
    indices[i]=x on(x,y)=orientation number given by orientation_nr_term()
    I(x)_c given as combination of standards x' with nu(x')=0 by c_form_std(x)
  algorithm: compute the sum for J(y)_c, using signed_KL_col and c_form_std
}
{.c-form on an irreducible, with extra output.}
set c_form_irreducible_long (Param p) =
      (ParamPol,[(Param,Split,KTypePol)],KTypePol):
   let ori_nr_p = orientation_nr(p), formula=KL_sum_at_s(p)
   then standards = { list of contributions }
      for c@q in formula
      do let form_on_standard = c_form_std(q)
         ,   factor           = c*orientation_nr_term(ori_nr_p,q)
      in (q,factor,form_on_standard)
      od
in ( formula, standards
   , null_K_module(p.real_form)+for(,c,f) in standards do c*f od
   )

{ starting formula in the c-form calculation: J(p)_c=\sum w(q)I(q)_c }
set twisted_c_form_irreducible_as_sum_of_standards (Param p) = ParamPol:
  +twisted_c_form_irreducible_contributions(p) { add twisted and untwisted }

{.c_form_irreducible with extra information.}
set twisted_c_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,KTypePol)],[Param,Split,KType],KTypePol):
( assert(@:twist(p)=p,"parameter is not fixed by inner class involution");
  let (fixed,unfixed) = twisted_c_form_irreducible_contributions(p)
  then G=p.real_form
  , fixed_contribs = [(Param,Split,KTypePol)]:
      for c@q in fixed do (q,c,c*twisted_full_deform(q)) od
  , unfixed_contribs = [(Param,Split,KType)]:
      for c@q in unfixed
      do { now |1+s| divides |c|, which justifies not using |scale_extended|: }
         (q,c,K_type(q))
      od
  then fixed_terms = KTypePol: sum(G,for (,,c) in fixed_contribs do c od)
  ,  unfixed_terms = KTypePol:
        G.null_K_module+for (,c,q0) in unfixed_contribs do (c,q0) od
in ( fixed+unfixed
   , fixed_contribs
   , unfixed_contribs
   , fixed_terms + half(unfixed_terms) )
   )

set twist_orbits (ParamPol P) = ParamPol:
( assert(@:map(twist@Param,P)=P) { polynomial is assumed to be twist-stable }
; P.real_form.null_module +
  while !=P
  do let (c,q):term = P.first_term then tq=twist(q)
  in term
  next if q=tq then P-:=term else let m_c = -c in P+:=[(m_c,q),(m_c,tq)] fi
  od
)

{ print versions }

set print_twisted_c_form_irreducible_long (Param p) = void:
(  let (formula,terms0,terms1,answer) = twisted_c_form_irreducible_long(p)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
        ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("c-form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{ analyse }

{ print only terms with "mixed" coefficient (a+bs), i.e., both a,b\ne 0 }
set mixed (Split w)= bool: not w.is_pure
set mixed_terms (ParamPol P) = ParamPol:
  0*P + for w@p in P if w.mixed do (w,p) fi od
set analyse (ParamPol P) = void:
  prints("Mixed terms:",P.mixed_terms.pol_format)

{  Hermitian forms  }

{.Hermitian dual.}
set hermitian_dual (Param p) = Param: normal(twist(p))

{.Hermitian form on a standard module, canonical normalization.}
set hermitian_form_std (Param p) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_std(p)
  else check_hermitian(p,false); twisted_c_form_std(p)
  fi. convert_cform_hermitian

{.Hermitian form on a irreducible module, normalization from p0.}
set hermitian_form_irreducible (Param p,KType t0) = KTypePol:
  let c_invariant_form =
    if is_equal_rank(real_form(p)) { then avoid twisted version, for speed }
    then c_form_irreducible(p)
    else check_hermitian(p,true); twisted_c_form_irreducible(p)
    fi
  in convert_cform_hermitian(c_invariant_form,t0)

{. Hermitian form on an irreducible, with extra information.}
set hermitian_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,KTypePol)],[(Param,Split,KType)],KTypePol):
  { here we just use |twisted_c_form_irreducible| in all cases }
  check_hermitian(p,true);
  let (formula,terms0,terms1,cform) = twisted_c_form_irreducible_long(p)
  in (formula,terms0,terms1, convert_cform_hermitian(cform))

set hermitian_form_irreducible_long (Param p, KType t0) =
    (ParamPol,[(Param,Split,KTypePol)],[(Param,Split,KType)],KTypePol):
  check_hermitian(p,true);
  let (formula,terms0,terms1,cform) = twisted_c_form_irreducible_long(p)
  in (formula,terms0,terms1, convert_cform_hermitian(cform,t0))

{.nice output of hermitian_form_irreducible.}
set print_hermitian_form_irreducible (Param p) = void:
  hermitian_form_irreducible(p).pol_format.prints

{.nice output of Hermitian forms on list of parameters.}
set print_hermitian_form_irreducible ([Param] P) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p)
  od

set print_hermitian_form_irreducible (Param p,KType p0) = void:
  hermitian_form_irreducible(p,p0).pol_format.prints

set print_hermitian_form_irreducible ([Param] P,KType p0) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p,p0)
  od

set print_hermitian_form_irreducible_long (Param p) = void:
(  let (formula,terms0,terms1,answer) = hermitian_form_irreducible_long(p)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
         ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{.print Hermitian form on irreducible, plus extra information.}
set print_hermitian_form_irreducible_long (Param p,KType p0) = void:
(  let (formula,terms0,terms1,answer) = hermitian_form_irreducible_long(p,p0)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
         ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{ cut the red tape and tell about the hermitian form analysis directly }
set analyse_hermitian_form_irreducible (Param p) = void:
  if not p.is_hermitian
  then prints("Parameter ",p," is not delta-fixed; no hermitian form exists")
  else prints("Parameter ",p," is delta-fixed",new_line,
    "twisted c_form on irreducible in terms of standard representations:")
  ; let (fixed,unfixed) = twisted_c_form_irreducible_contributions(p)
    , c_form=p.real_form.null_K_module
    in
    if !=fixed then prints("Twist-fixed contributions:") fi
  ; c_form+:=
    for c@q in fixed
    do let contribution = c*twisted_full_deform(q) in
      prints(c,"* form on I(",q,"), fully deformed:",contribution,new_line)
    ; contribution
    od
  ; if !=unfixed then prints(new_line,"Non twist-fixed terms:") fi
  ; c_form+:=
    for c@q in twist_orbits(unfixed)
    do let contribution = half(c*K_type(q)+c*K_type(twist(q))) in
      prints(c,"*(I(",q,")",new_line
          ,"        +I(",twist(q),")), at nu=0:",contribution,new_line)
    ; contribution
    od
  ; prints(new_line,"Complete c-invariant form:",c_form,new_line)
  ; prints("Hermitian form:",c_form.convert_cform_hermitian,new_line)
  fi

{   unitarity and weak unitarity tests }

{ compute |p.hermitian_form_irreducible.is_pure|; try to get |false| rapidly }
set hermitian_form_is_pure (Param p) = bool:
( let G=p.real_form
  then (fixed,unfixed) = (ParamPol,ParamPol):
      twisted_c_form_irreducible_contributions(p)
  , result = KTypePol: G.null_K_module
  , tp0 = first_K_type(K_type(p)) { reference for |mu| }
  then limit = 1 + (fixed+unfixed).last_param.height
  then lowest (ParamPol P) = if =P then limit else P.first_param.height fi
  , cur_fix = ParamPol: G.null_module, cur_unfix = ParamPol: G.null_module
  in unfixed:=twist_orbits(unfixed) { choose one of each delta-exchanged pair }
; while
    let fh=fixed.lowest, uh=unfixed.lowest then height = min(fh,uh)+1 in
    height<=limit { equivalently |!=fixed or !=unfixed| }
  do
    if fh<height
    then set (cur_fix,fixed) := height_split(fixed,height)
    else cur_fix:=G.null_module
    fi
  ; if uh<height
    then set (cur_unfix,unfixed):=height_split(unfixed,height)
    else cur_unfix:=G.null_module
    fi
  ; result +:= map(twisted_full_deform@Param,cur_fix)
    	      +K_type_pol(cur_unfix)
  ; let (cur_result,later_result)=height_split(result,height) in
    if not convert_cform_hermitian(cur_result,tp0).is_pure_1
    then return false
    fi
  ; result:=later_result { we are done with terms below |height|, forget them }
  od
; convert_cform_hermitian(result,tp0).is_pure_1
)

set print_is_unitary (Param p) = void:
  if p.is_hermitian
  then let hf=hermitian_form_irreducible(p) in
    if hf.is_pure
    then prints("Unitary")
    else let (real,nonreal,mixed)=purity(hf) in
      prints("Non-Unitary",new_line
	    , real, " real terms", new_line
	    , nonreal," nonreal terms", new_line
	    , mixed, " mixed terms")
    fi
  else prints("Irreducible module does not admit any invariant Hermitian form")
  fi

{ no mixed terms }
set is_weakly_unitary (KTypePol P) = bool: let (,,mixed)=purity(P) in =mixed

{ compute Hermitian form on p, and report if it is weakly unitary }
set is_weakly_unitary (Param p) = bool:
  let G=real_form(p) in
  if is_equal_rank(G)
  then is_weakly_unitary(c_form_irreducible(p))
  else is_weakly_unitary(twisted_c_form_irreducible(p))
  fi

{ for "big" versions: see extParamPol.at }

set test_line (Param p) = void:
( let (x,lambda_minus_rho,gamma) = %p
  , points=reducibility_points(p)
  ,   ipoints=integrality_points(root_datum(p),2*nu(p))
  in prints("testing line through ", p)
; prints("reducibility points: ",points)
; prints("integrality points (for 2*nu): ",ipoints)
; if #points=0
  then prints("entire line is irreducible and unitary"
             ,if K_type(p).is_final then "" else " (nu=0 is not final)" fi)
  else points:=(0/1)#points { tack on initial zero }
  ; if not points[#points-1]=1/1 then points:=points#(1/1) fi
  ; for i:#points-1 from 1
    do
      let t=(points[i]+points[i-1])/2
      then q=param(x,lambda_minus_rho,gamma*t)         { mid point interval }
      ,    r=param(x,lambda_minus_rho,gamma*points[i]) { end point interval }
      in prints(nu(p)*t,": ", is_unitary(first_param(finalize(q))))
      ;  prints(nu(p)*points[i],": ", is_unitary(first_param(finalize(r))))
    od
  fi
)

set weak_test (Param p) = bool:
  let formula=twisted_c_form_irreducible(p)
  then bad=null_K_module(real_form(p)) +
    for w@p in formula if not is_pure(w) do w*p fi od
  in
  if #bad=0 then prints("number of terms: ", #formula); true
  else prints("number of terms: ", #formula,new_line,"bad terms:", bad ); false
  fi

set strong_test (Param p)=bool:
  let formula=hermitian_form_irreducible(p)
  then bad=null_K_module(real_form(p)) +
    for w@p in formula if not is_pure(w) do w*p fi od
  then OK = =bad { return whether bad terms are absent }
  in prints("number of terms: ", #formula);
  if not OK then prints("bad terms:", bad) fi; OK

set branch_c_form_irreducible(Param p, int N) = KTypePol:
  branch(c_form_irreducible(p),N)


{table of is_unitary results, indexed by Param}
{this type is not used}
set_type 
[ unitarity_bool_hash =
( ( -> int) size
  , ( -> int) count
  , ( -> ) clear
  , (Param->bool) entry
  , (Param->bool) do_you_know {asks if the answer is tabulated}
  , (Param->) append
  , ((Param,bool)->) attest {attest to unitarity of Param}
  , (int -> Param) param_index
  , (int -> bool) data_index
  )
]

set make_unitarity_bool_hash () = unitarity_bool_hash:
(  let param_hash = make_Param_hash()
   then bool_data = [bool] : []
   then clear() = void:
   	let () = param_hash.clear()
 	then () = bool_data:=[]
       	in ()
   in 
   ( ( -> int): { size } @int: #bool_data
   , ( -> int): { count } @int: count(bool_data)
   , ( -> ): {clear} clear
   , (Param -> bool): {entry} (Param p) bool:
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	then () = if m = M
	     	  then {unitary_test_counter.use();}
		       bool_data:= (bool_data next bool_data:= [])
		       	     	   # is_unitary(p);
		       assert(#bool_data = param_hash.size(),
		       			 "unitarity_bool_hash is damaged")
		  fi
	in bool_data[m]
     end
   , (Param -> bool): {do_you_know} (Param p) bool:
     if #simple_factors(p.real_form) = 1
     then p:=herm_center(p)
     fi;
     param_hash.lookup(p).>=
   , (Param->): {append } (Param p):
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	in if m = M
	   then {unitary_test_counter.use();}
		bool_data:= (bool_data next bool_data:= [])
		       	     	   # is_unitary(p)
           fi
     end
   , ((Param,bool)->): {attest} (Param p, bool answer):
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	in if m = M
	   then bool_data#:= answer {(bool_data next bool_data:= [])
		       	     	   # answer}
	   else assert(bool_data[m] = answer,"bad attest")
           fi
     end
   , (int -> Param): {param_index} (int j): param_hash.index(j)
   , (int -> bool): {data_index} (int j): bool_data[j]
  )
)

{smallest theta-stable Q from which p is good range cohomologically induced, and the inducing parameter}
set good_Q(Param p) = (KGPElt, Param):
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x), SCR = G.simple_coroots
    then goodS = ((for j in complement(G.semisimple_rank,suppS)
		     do if (gamma*SCR[j]).=
		        then [j]
		       	else []
		       	fi
		     od.##)##suppS).sort_u
    then goodQ = KGPElt:(goodS, x)
    then goodL = goodQ.Levi
    then xL = inverse_embed_KGB(x,goodL)
    then goodpL = parameter(xL, p.lambda_minus_rho+goodL.rho, p.nu)
    in (goodQ,goodpL)

set good_L(Param p) = RealForm:
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x), SCR = G.simple_coroots
    then goodS = ((for j in complement(G.semisimple_rank,suppS)
		     do if (gamma*SCR[j]).=
		        then [j]
		       	else []
		       	fi
		     od.##)##suppS).sort_u
    in (goodS,x).Levi

{smallest easy theta-stable Q from which p is weakly good range cohomologically
induced, and the inducing parameter}
set wkgood_Q(Param p) = (KGPElt, Param):
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x) {, SCR = G.simple_coroots}
    then wkgoodQ = KGPElt:(suppS, x)
    then wkgoodL = wkgoodQ.Levi
    then xL = inverse_embed_KGB(x,wkgoodL)
    then wkgoodpL = parameter(xL, p.lambda_minus_rho+wkgoodL.rho, p.nu)
    in (wkgoodQ,wkgoodpL)

{these functions are not used; subsumed by big_unitary_hash}
set unitarity_hash = make_unitarity_bool_hash()

set is_unitary_hash(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let (,pL) = wkgood_Q(p), G=p.real_form
    then derpLs = derived_factor_params0(pL)
    then answer = all([(->bool)] : for derpL in derpLs do @bool:
       			unitarity_hash.entry(derpL) od)
    {then formL = hermitian_form_irreducible(pL)}
    {then answer = is_pure(formL)}
    in if answer or pL = p
       then answer
       else {answer is false, and pL is on proper Levi}
       	    let goodL = good_L(p)
       	    in is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
			           goodL)
			      od))
       fi
    {unitarity_hash.entry(p)}

set do_you_know_is_unitary(Param p) = bool:
    unitarity_hash.do_you_know(p)

set attest_is_unitary(Param p, bool answer) = void:
    unitarity_hash.attest(p,answer)
