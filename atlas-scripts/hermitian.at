<basic.at
<convert_c_form.at
<hash.at {for KTypePol_hash}
<count.at {for unitary_test_counter}
<time.at {for print_time_string}
<cohom_reductionND {for derived_factor_params}
<FPP_faces_geom {for herm_center}
<writeFiles {for write commands}
set deformLookupCounter = make_counter()
set deformCalcCounter = make_counter()

set to_ht (KTypePol P,int N) = KTypePol:
  let (below,)=height_split(P,N) in below

{take a KTypePol _apparently_ attached to G and make it _actually_ attached
to G. Need this to use looked-up deformations.}
set regroup(RealForm G, KTypePol P) = KTypePol:
    sum(G, for c@q in P do let (,m) = %q.x
    	   in c*K_type(KGB(G,m), q.lambda_minus_rho) od)

{ table of full_deform to ht, indexed by Param. Height zero means no cutoff.}
{Twisted always stored with no cutoff, since we don't now have a good twisted
to_ht, so make that a separate type.}
set_type
[ deformation_hash_to_ht =
( ( -> int) size {number of parameters stored}
  , ( -> ) clear
  , (Param -> int) height {maximum height to which p is deformed}
  , ((Param,int)->KTypePol) entry
  , (Param->int) lookup
  , ((Param,int,KTypePol)->) append
  , (int -> Param) param_index {parameter #j}
  , (int -> int) height_index {height to which parameter #j is deformed}
  , (int -> KTypePol) data_index {deformation of parameter #j to its ht}
  )
]


set deform_param_hash = make_Param_hash() {used as index into...}
set deformed_data = [KTypePol] : []
set deform_max_heights = [int] : []
set deform_use_count = [int] : []
set make_deformation_hash_to_ht () = deformation_hash_to_ht:
(  {let param_hash = make_Param_hash()
   then max_heights = [int] : []
   then deformed_data = [KTypePol] : []}
   let clear() = void:
       let () = deform_param_hash.clear()
       then () = deform_max_heights :=[]
       then () = deformed_data :=[]
       then () = deform_use_count := []
       in ()
   then add_param(Param p, int h) = int:
       	let I = deform_param_hash.size()
	then i = deform_param_hash.lookup(p)
	then P = null_K_module(SL(1,R))
	then () = if i.< {haven't seen this p before}
	     then deformCalcCounter.use();
	     	  P := if h=0
	     	      then full_deform(p)
		      else deform_to_height(p,h)
		      fi;
		   deform_param_hash.match(p);
		   i:=I;
		   deform_max_heights #:= h;
		   deformed_data#:=P;
		   deform_use_count#:=0
	      elif {i>0; p seen} h=0 and deform_max_heights[i].>
	      then deformCalcCounter.use();
	      	   P := full_deform(p);
		   deform_max_heights[i]:=0;
		   deformed_data[i]:=P
	      elif {i >0, h>0 or } deform_max_heights[i] > 0 and h > deform_max_heights[i]
	      then deformCalcCounter.use();
	      	   P := deform_to_height(p,h);
		   deform_max_heights[i]:=h;
		   deformed_data[i]:=P
	      else deformLookupCounter.use()
	      fi
	  then () = deform_use_count[i] +:=1
	  in i
   in
   ( ( -> int): {size} @int: deform_param_hash.size()
  , ( -> ): {clear} clear
  , (Param -> int): {height} (Param p): deform_max_heights[deform_param_hash.lookup(p)]
  , ((Param, int)->KTypePol): {entry} (Param p, int h):
    let i = add_param(p, h)
    in if h > 0
       then regroup(p.real_form,to_ht(deformed_data[i],h))
       else regroup(p.real_form,deformed_data[i])
       fi
  , (Param->int): {lookup} (Param p): deform_param_hash.lookup(p)
  , ((Param,int,KTypePol)->): {append} (Param p, int h, KTypePol P):
    let I = deform_param_hash.size()
    then i = deform_param_hash.match(p)
    in if i=I {haven't seen p before}
       then deform_max_heights #:=h;
	    deformed_data#:=P;
	    deform_use_count#:=0
       elif {i < I} (h=0 and deform_max_heights[i].>) 
	    or h>deform_max_heights[i] {seen p, but not to h}
       then deform_max_heights[i]:=h;
	    deformed_data[i]:=P
       fi
  , (int -> Param): {param_index} (int j): deform_param_hash.index(j)
  , (int -> int): {height_index} (int j): deform_max_heights[j]
  , (int -> KTypePol): {data_index} (int j): deformed_data[j]
  )
)

set append_to_deformation_hash(RealForm G, Param p, [KPolTermDatum] data, int ht, int use) = void:
    let I = deform_param_hash.size()
    then i = deform_param_hash.lookup(p)
    in if i.< {haven't seen this p}
       then deform_param_hash.match(p);
	    i:=I;
	    deform_max_heights #:=ht;
	    deformed_data #:= K_pol(G,data);
	    deform_use_count #:= use
       elif (deform_max_heights[i] < ht) or
	    (ht = 0 and deform_max_heights[i] > 0)
       then deform_param_hash.match(p);
       	    deform_max_heights[i] := ht;
	    deformed_data[i] := K_pol(G, data);
	    deform_use_count[i] +:=use
       fi

set append_to_deformation_hash(RealForm G, [Param] p_list, [[KPolTermDatum]] data_list,
    [int] ht_list, [int] use_list) = void:
    for p@j in p_list
    do append_to_deformation_hash(G,p,data_list[j],ht_list[j],use_list[j])
    od
set write_deformation_frac = 100

{write the part of deformation_hash referring to G}
set write_deformation_hash(RealForm G) = void:
    let param_list = deform_param_hash.list()
    then M = max((for P@j in deformed_data do
    deform_use_count[j]*#deformed_data[j] od)#0)
    then good_j = for p@j in param_list
    	 	   do if p.real_form = G and deform_use_count[j]* #deformed_data[j] *write_deformation_frac > M
		      then [j]
		      else []
		      fi
		   od.##
    then good_param_list = for j in good_j do param_list[j] od
    then good_deformed_data = for j in good_j do K_data(deformed_data[j]) od
    then good_deform_max_heights = for j in good_j do deform_max_heights[j] od
    then good_deform_use_count = for j in good_j do deform_use_count[j] od
    in write_real_form(G,"G_temp");
       for p@k in good_param_list
       do let (,x) = %p.x
       	  in prints("let p_temp = parameter(G_temp,",x,",",p.lambda,",",p.nu,")");
	     prints("then temp_def_data = ",good_deformed_data[k]);
       	     prints("in append_to_deformation_hash(G_temp, p_temp,",good_deformed_data[k],",",
       		  good_deform_max_heights[k],",", good_deform_use_count[k],")")
       od

set_type
[ twisted_deformation_hash =
( ( -> int) size {number of parameters stored}
  , ( -> ) clear
  , (Param->KTypePol) entry
  , ((Param, int)->KTypePol) entry_to_ht
  , (int -> Param) param_index {parameter #j}
  , (int -> KTypePol) data_index {deformation of parameter #j}
  )
]

set twisted_deform_param_hash = make_Param_hash() {used as index into...}
set twisted_deformed_data = [KTypePol] : []

set make_twisted_deformation_hash() = twisted_deformation_hash:
(  {let param_hash = make_Param_hash()
   then deformed_data = [KTypePol] : []}
   let clear() = void:
       let () =  twisted_deform_param_hash.clear()
       then () = twisted_deformed_data :=[]
       in ()
   then add_param(Param p) = int:
       	let I =  twisted_deform_param_hash.size()
	then i =  twisted_deform_param_hash.match(p)
	then P = null_K_module(SL(1,R))
	then () = if i=I {haven't seen this p before}
	     then deformCalcCounter.use();
	     	  P := twisted_full_deform(p);
		  twisted_deformed_data#:=P
	      else deformLookupCounter.use()
	      fi
	  in i
   in
   ( ( -> int): {size} @int:  twisted_deform_param_hash.size()
  , ( -> ): {clear} clear
  , (Param->KTypePol): {entry} (Param p):
    let i = add_param(p)
    in regroup(p.real_form,twisted_deformed_data[i])
  , ((Param, int)->KTypePol): {entry_to_ht} (Param p, int h):
    let i = add_param(p)
    in if h > 0
       then regroup(p.real_form,to_ht(twisted_deformed_data[i],h))
       else regroup(p.real_form,twisted_deformed_data[i])
       fi
  , (int -> Param): {param_index} (int j):  twisted_deform_param_hash.index(j)
  , (int -> KTypePol): {data_index} (int j): twisted_deformed_data[j]
  )
)

set append_to_twisted_deformation_hash(RealForm G, Param p, [KPolTermDatum] data) = void:
    let I = twisted_deform_param_hash.size()
    then i = twisted_deform_param_hash.match(p)
    in if i=I {haven't seen this p}
       then twisted_deformed_data #:= K_pol(G,data)
       fi

set append_to_twisted_deformation_hash(RealForm G, [Param] p_list, [[KPolTermDatum]] data_list) = void:
    for p@j in p_list
    do append_to_twisted_deformation_hash(G,p,data_list[j])
    od

{write the part of deformation_hash referring to G}
set write_twisted_deformation_hash(RealForm G) = void:
    let param_list = twisted_deform_param_hash.list()
    then good_j = for p@j in param_list
    	 	   do if p.real_form = G then [j]
		      else []
		      fi
		   od.##
    then good_param_list = for j in good_j do param_list[j] od
    then good_twisted_deformed_data = for j in good_j do K_data(twisted_deformed_data[j]) od
    in write_real_form(G,"G_temp");
       for p@k in good_param_list
       do let (,x) = %p.x
       	  in prints("let p_temp = parameter(G_temp,",x,",",p.lambda,",",p.nu,")");
       	     prints("in append_to_twisted_deformation_hash(G_temp,p_temp,",good_twisted_deformed_data[k],
	     ")")
       od
{whether to use these hash tables. "False" saves quite a bit of memory
(about 10% in F4_s) with very little speed cost (less than 1% in F4_s)}
set deformed_hash_flag = false

set deformedHash = make_deformation_hash_to_ht()
set twistedDeformedHash = make_twisted_deformation_hash()

{like is_pure, but in case of false, second value is the lowest K-type where
the KTypePol changes sign. Better to put the guilty K-type in a hash table.}
set is_pure_cert(KTypePol P) = [KType]:
    if is_pure(P) then [KType]: []
    else let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0
	 then () = if a0*b0 != 0
	           then let ()= j:=0
		   	in ()
	           elif b0 = 0
	      	   then let ()= j:= first(for (,b,)@j in terms
	      	      	     	      	   do b!=0
				      	   od)
			in ()
	      	   else {now b0!=0 and a0=0}
		   	let () = j:= first(for (a,,)@j in terms
	      	      	     	      do a!=0
				      od)
			in ()
		   fi
	  then (,,pj) = terms[j]
	  in [pj]
    fi

{like is_pure_cert, but in case of false, writing the guilty K-types in a
hash table.}
set is_pure_cert_hash_old(KTypePol P, KTypePol_hash cert_hash) = bool:
    if not is_pure(P)
    then let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0
	 then () = if a0*b0 != 0
	           then let ()= j:=0
		   	in ()
	           elif b0 = 0
	      	   then let ()= j:= first(for (,b,)@j in terms
	      	      	     	      	   do b!=0
				      	   od)
			in ()
	      	   else {now b0!=0 and a0=0}
		   	let () = j:= first(for (a,,)@j in terms
	      	      	     	      do a!=0
				      od)
			in ()
		   fi
	  then (,,pj) = terms[j]
	  then x = cert_hash.match(1*pj)
	  in false
    else true
    fi

{like is_pure_cert, but in case of false, writing the guilty K-types in a
hash table.}
{ want this version to record SUM of lowest impurity }
set is_pure_cert_hash(KTypePol P, KTypePol_hash cert_hash) = bool:
    if not is_pure(P)
    then let terms = for c@p in P
    	     	     do let (a,b) = %c
    	     	     	in (a,b,p)
		     od
    	 then (a0,b0,p0) = terms[0]
	 then j=int:0 {next line is the lowest negative terms}
	 then B = if a0*b0 != 0
	          then to_ht(P,height(p0))
	          elif b0 = 0
	      	  then let N = sum(P.real_form, for (a,b,p) in terms
		   	      			do if b!=0 then [1*p] else [] fi od.##)
		   	in to_ht(N,height(first_K_type(N)))
	      	  else  {now b0!=0 and a0=0}
		       let N = sum(P.real_form, for (a,b,p) in terms
		   	      			do if a!=0 then [1*p] else [] fi od.##)
		       in to_ht(N,height(first_K_type(N)))
		  fi
	  then x = cert_hash.match(B)
	  in false
    else true
    fi

{will be modified to name of local test being run}
set test_string = string: ""

set tested_pos_hash = make_Param_hash()
set tested_pos_list = [Param]: []
set tested_pos_times = [int]: [] {one for each tested_pos_hash.list() entry}
set tested_pos_mults = [int]: [] {one for each tested_hash.list() entry}
{set tested_bools = [bool]: []}
set tested_pos_mult_times = [[int]]: [] {one for each tested_pos_hash.list() entry}
set tested_pos_strings = [string]: []

set tested_neg_hash = make_Param_hash()
set tested_neg_list = [Param]: []
set tested_neg_times = [int]: [] {one for each tested_list entry}
set tested_neg_mults = [int]: [] {one for each tested_hash.list() entry}
{set tested_bools = [bool]: []}
set tested_neg_mult_times = [[int]]: [] {one for each tested_hash.list()}
set tested_neg_strings = [string]: []

set tested_to_ht_hashes = for h:100 do make_Param_hash() od
set tested_to_ht_lists = for h:100 do [Param]:[] od
set tested_to_ht_times = for h:100 do [int]:[] od
set tested_to_ht_mults = [[int]]: for h:100 do [] od {one for each tested_to_ht_hashes[h].list()}
set tested_to_ht_bools = [[bool]]: for h:100 do [] od
set tested_to_ht_mult_times = [[[int]]]: for h:100 do [] od{one for each tested_to_ht_hashes[h].list()}
set tested_to_ht_strings = [[string]]: for h:100 do [] od

{set cSp = int:0}
set was_tested(Param p, int T, bool ans) = void:
    {let () = if p = parameter(Sp(6,R),8,[2,1,1],[1,-1,0]/2)
    	     then cSp+:=1; 1/(cSp-4)
	     else 1/1
	     fi}
    if ans
    then let M = tested_pos_hash.size()
       	 then m = tested_pos_hash.match(p)
       	 then () = if m=M then tested_pos_mults #:= 0; tested_pos_mult_times #:=[] fi
       	 in tested_pos_list#:=p; tested_pos_times#:=T; tested_pos_mults[m]+:=1;
       	  {tested_bools#:= ans;} tested_pos_mult_times[m] #:=T;
	  tested_pos_strings #:= test_string
    else let M = tested_neg_hash.size()
       	 then m = tested_neg_hash.match(p)
       	 then () = if m=M then tested_neg_mults #:= 0; tested_neg_mult_times #:=[] fi
       	 in tested_neg_list#:=p; tested_neg_times#:=T; tested_neg_mults[m]+:=1;
       	  {tested_bools#:= ans;} tested_neg_mult_times[m] #:=T;
	  tested_neg_strings #:= test_string
    fi

set was_tested_to_ht(Param p,int N, int T, bool ans) = void:
    let h = N - height(p)
    then M = tested_to_ht_hashes[h].size()
    then m = tested_to_ht_hashes[h].match(p)
    then () = if m=M then tested_to_ht_mults[h] #:= 0; tested_to_ht_mult_times[h] #:=[] fi
    then tthtsh = tested_to_ht_times[h], tthmsh = tested_to_ht_mults[h], tthmtsh = tested_to_ht_mult_times[h],
    	 tthbsh = tested_to_ht_bools[h], tthsh = tested_to_ht_strings[h]
    then () = tthtsh #:=T; tthmsh[m] +:=1; tthmtsh[m] #:=T; tthbsh #:=ans; tthsh #:=test_string
    then () = tested_to_ht_times[h] := tthtsh; tested_to_ht_mults[h]:=tthmsh;
    	 tested_to_ht_bools[h] :=tthbsh; tested_to_ht_mult_times[h]:=tthmtsh;
	 tested_to_ht_strings[h] := tthsh
    in tested_to_ht_lists[h]#:=p

set report_tested() = void:
    {let mults = [int]: null(tested_hash.size())
    then time_lists = [[int]]: for j:tested_hash.size() do [] od
    then () = for p@k in tested_list
    	      do let j = tested_hash.lookup(p)
	      	 in mults[j] +:= 1;
    	      	    time_lists[j] #:= tested_times[k]

              od}
 {
    let max_mult = max(tested_mults)
    then max_time = max(tested_times)
    then j_mult = first(for m in tested_mults do m=max_mult od)
    then simply_bad_js = for p@j in tested_hash.list()
    	 	       	 do if tested_mults[j] > 1 and is_simple(p.real_form)
			    then [j]
			    else []
			    fi
			 od.##
    then max_simple_mult = if #simply_bad_js > 0
    	 		   then max(for j in simply_bad_js do tested_mults[j] od)
			   else 0
			   fi
    then j_long = first(for T in tested_times do T = max_time od)
}
    {then mults_to_ht = [[int]]: for h:100 do null(tested_to_ht_hashes[h].size()) od
    then time_lists_to_ht = [[[int]]]: for h:100 do for j:tested_to_ht_hashes[h].size() do [] od od
    then () = for h:100
    	      do for p@k in tested_to_ht_lists[h]
	      	 do let j = tested_to_ht_hashes[h].lookup(p)
		    then mthh = mults_to_ht[h], tlthh = time_lists_to_ht[h]
		    then () = mthh[j]+:=1; tlthh[j] #:= tested_to_ht_times[h][k]
		    in mults_to_ht[h]:= mthh; time_lists_to_ht[h]:=tlthh
		 od
	      od}
{
    then max_mult_to_hts = for h:100 do if #tested_to_ht_mults[h]>0
    	 		       	     	then max(tested_to_ht_mults[h])
					else 0
					fi
				     od
    then max_time_to_hts = for h:100 do if #tested_to_ht_times[h]>0
    	 		       	     	then max(tested_to_ht_times[h])
					else 0
					fi
				     od
    then j_mult_to_hts = for h:100 do first(for m in tested_to_ht_mults[h] do m = max_mult_to_hts[h] od) od
    	 {-1 if empty}
    then simply_bad_js_to_ht = for h:100
    	 	       	 do for p@j in tested_to_ht_hashes[h].list()
			    do if tested_to_ht_mults[h][j] > 1 and is_simple(p.real_form)
			       then [j]
			       else []
			       fi
			    od.##
			 od
    then max_simple_mult_to_hts = for h:100
    	 			do if #simply_bad_js_to_ht[h] > 1
				   then max(for j in simply_bad_js_to_ht[h] do tested_to_ht_mults[h][j] od)
				   else 0
				   fi
				od
    then j_long_to_ht = for h:100
    	 	      	do first(for T in tested_to_ht_times[h] do T = max_time_to_hts[h] od)
			od

    in
}
    prints(new_line,#tested_pos_list," positive is_unitary tests; ",tested_pos_hash.size()," distinct, in time = ",
    	print_time_string(sum(tested_pos_times)),
	"; time for repetitions = ", print_time_string(
	 sum(for v in tested_pos_mult_times do sum(v[1:]) od)));
    prints(#tested_neg_list," negative is_unitary tests; ",tested_neg_hash.size()," distinct, in time = ",
    	print_time_string(sum(tested_neg_times)),
	"; time for repetitions = ", print_time_string(
	 sum(for v in tested_neg_mult_times do sum(v[1:]) od)),new_line);
    prints(sum(for h:100 do #tested_to_ht_lists[h] od)," tests to_ht; ",
       	 sum(for h:100 do tested_to_ht_hashes[h].size() od)," distinct. Total time = ",
 	 print_time_string(sum(for h:100 do sum(tested_to_ht_times[h]) od)), "; time for repetitions = ",
 	 print_time_string(sum(for h:100 do sum(for v in tested_to_ht_mult_times[h] do sum(v[1:]) od)od)));
    prints(sum(for h:100 do count(tested_to_ht_bools[h]) od)," positive tests to_ht, taking ",
    	print_time_string(sum(for h:100 do sum(for T@m in tested_to_ht_times[h] do
	if tested_to_ht_bools[h][m] then T else 0 fi od) od)))
{
    ;
    prints("largest mult is_unitary test is ",max_mult," for p#", j_mult,"; times ",tested_mult_times[j_mult]);
    {for j in simply_bad_js
    do prints("times for simple G repeated is_unitary #",j," are ", time_lists[j])
    od;}
    if #simply_bad_js > 0
    then let max_mult_simple = max(for j in simply_bad_js do tested_mults[j] od)
    	 then j_mult_simple = simply_bad_js[first(for j in simply_bad_js do tested_mults[j] = max_mult_simple od)]
    	 in prints("largest mult for simple G is_unitary is ",max_mult_simple," for p#", j_mult_simple,
	 "; times ",tested_mult_times[j_mult_simple],new_line)
    fi;
    for h:100
    do if #simply_bad_js_to_ht[h] > 0
       then let max_mult_simple_to_ht = max(for j in simply_bad_js_to_ht[h] do tested_to_ht_mults[h][j] od)
       	    then j_mult_simple_to_ht = simply_bad_js_to_ht[h][first(for j in simply_bad_js_to_ht[h]
       	    	 		       			do tested_to_ht_mults[h][j] = max_mult_simple_to_ht od)]
       	    in if max_mult_simple_to_ht > 1
       	       then prints("largest mult for simple G is_unitary_to_ht(",h,") is ",max_mult_simple_to_ht," for p#",
       	    	 	j_mult_simple_to_ht,"; times ",tested_to_ht_mult_times[h][j_mult_simple_to_ht])
	       fi
       fi
    od
}

set clear_report_tested() = void:
    tested_pos_hash.clear(); tested_pos_list:=[]; tested_pos_times:=[]; tested_pos_mults:=[]; tested_pos_mult_times:=[];
    tested_neg_hash.clear(); tested_neg_list:=[]; tested_neg_times:=[]; tested_neg_mults:=[]; tested_neg_mult_times:=[];
    for h:100
    do tested_to_ht_hashes[h].clear(); tested_to_ht_lists[h]:=[]; tested_to_ht_times[h]:=[];
       tested_to_ht_mults[h] := []; tested_to_ht_mult_times[h]:=[]
    od


{.write c-invariant form on standard module as a KTypePol }
{ never involves |twisted_full_deform| }
set c_form_std(Param p) = KTypePol:
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then deformedHash.entry(pc,0)
       else full_deform(pc)
       fi

set twisted_c_form_std(Param p) = KTypePol: { c-form on extended group}
    let pc = alcove_center(p)
    in if deformed_hash_flag
       then twistedDeformedHash.entry(pc)
       else twisted_full_deform(pc)
       fi

{    c_form on irreducible representations   }

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
{.c-invariant form on irreducible module of p as KTypePol }
set c_form_irreducible (Param p) = KTypePol:
   let ori_nr_p = orientation_nr(p)
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
in map(c_form_std@Param, oriented_KL_sum )

{    twisted_c_form_irreducible   }

{ utility: compute fixed and unfixed contributions to c-form on irreducible(p)
  no deformation is done, but orientation numbers are included;
  fixed contributions are already halved; for unfixed ones this needs to wait
}
set twisted_c_form_irreducible_contributions (Param p) =
    (ParamPol,ParamPol): { (fixed part, 2*unfixed part) }
  let G=p.real_form, ori_nr_p = orientation_nr(p)
  then formula = (1+s)*KL_sum_at_s(p) + (1-s)*twisted_KL_sum_at_s(p)
  in { two value-producing loops can be a lot more efficient than one: }
  ( G.null_module +
      for c@q in formula
         if twist(q)=q do (half(c)*orientation_nr_term(ori_nr_p,q),q) fi
      od
   , G.null_module +
      for c@q in formula
         if twist(q)!=q do (c*orientation_nr_term(ori_nr_p,q),q) fi
      od
  )

{ The following function implements algorithm from Vogan in email 9/22/16:
  * for each delta-fixed term q add c_form_std(q) (fully twisted-deformed)
  * for each pair {q,delta(q)} add q*0 (deformation to nu=0 of q).
  For second kind it it convenient to add q*0 and delta(q)*0
  separately and at the end divide the sum of such contributions by 2.
}
{.twisted c-invariant form on an irreducible in terms of standardrepKs.}
set twisted_c_form_irreducible_unnormalized (Param p) = KTypePol:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions(p)
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  in map(twisted_c_form_std@Param,fixed)+half(unfixed.K_type_pol)
)

{ normalization here means making the leading term 1 (rather than |s|) }
set twisted_c_form_irreducible (Param p) = KTypePol:
   let unnormalized=twisted_c_form_irreducible_unnormalized(p)
   then (c,)=first_term(unnormalized)
in if c=1 then unnormalized
   elif c=s then s*unnormalized
   else error("leading coefficient is not 1 or s")
   fi

{.whether J(p) admits an invariant Hermitian form.}
set is_hermitian (Param p) = bool: equivalent(twist(p),p)

set check_hermitian (Param p, bool irreducible) = void:
  if not p.is_hermitian
  then error(if irreducible then "Irreducible" else "Standard" fi
            ," module does not admit any invariant Hermitian form")
  fi

set unitaryTime = int: 0
set show_unitary_time() = void: prints("Time so far for is_unitary = ",
    		      print_time_string(unitaryTime))

{.Hermitian form on a irreducible module, normalization from its initial term.}
set hermitian_form_irreducible (Param p) = KTypePol:
  unitary_test_counter.use();
  let start_time = elapsed_ms()
  then answer = if is_equal_rank(real_form(p))
       	      	then c_form_irreducible(p) { not twisted, in equal rank case this is faster }
 		else check_hermitian(p,true); twisted_c_form_irreducible(p)
  		fi.convert_cform_hermitian
  then () = unitaryTime+:=elapsed_ms() - start_time
  then () = was_tested(p, elapsed_ms() - start_time, is_pure(answer))
  in answer

{ compute Hermitian form on p, and report if it is unitary }
set is_unitary (Param p) = bool:
  p.is_hermitian and hermitian_form_irreducible(p).is_pure

{ compute Hermitian form on p, and report
certificate; unitary means empty certificate }
set is_unitary_cert (Param p) = [KType]:
  hermitian_form_irreducible(p).is_pure_cert

{ compute Hermitian form on p, report if it is unitary, and otherwise record certificate }
set is_unitary(Param p,KTypePol_hash cert_hash) = bool:
  p.is_hermitian and is_pure_cert_hash(hermitian_form_irreducible(p),cert_hash)


{ some time-limited functions, using new built-in |full_deform@(Param,int)| }
set_type [ maybe_KTP = (void timed_out | KTypePol done) ]

set map ((Param->maybe_KTP)f, ParamPol P) = maybe_KTP:
  sum(P.real_form
     ,for c@p in P
     ~do case f(p) | timed_out: return timed_out() | done(r): c*r esac
      od
     ).done

set c_form_irreducible (Param p,int time) = maybe_KTP:
   let ori_nr_p = orientation_nr(p), expiration = elapsed_ms() + time
   then oriented_KL_sum = ParamPol: null_module(p) +
      for c@q in KL_sum_at_s(p) do (c*orientation_nr_term(ori_nr_p,q),q) od
   in map( (Param p) maybe_KTP: full_deform(p,expiration-elapsed_ms())
      , oriented_KL_sum
      )

set twisted_c_form_irreducible (Param p,int time) = maybe_KTP:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions(p)
  , expiration = elapsed_ms() + time
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  in case
        map( (Param p) maybe_KTP: twisted_full_deform(p,expiration-elapsed_ms())
	   , fixed
	   )
     | timed_out: timed_out()
     | done(r): done(r + half(unfixed.K_type_pol))
     esac
)

set hermitian_form_irreducible (Param p, int time) = maybe_KTP:
   unitary_test_counter.use();
   let start_time = elapsed_ms()
   then answer = case if is_equal_rank(real_form(p))
               	      then c_form_irreducible(p,time)
	 	      else check_hermitian(p,true); twisted_c_form_irreducible(p,time)
	 	      fi
   		 | timed_out: return timed_out()
   		 | done(r): r.convert_cform_hermitian.done
   		 esac
  then () = unitaryTime+:=elapsed_ms() - start_time
  in answer

set is_unitary (Param p, int time) = int: { -1: no, 0:timed out, 1: yes }
    if p.is_hermitian
    else -1
    then case hermitian_form_irreducible(p,time)
       	 | timed_out: 0
       	 | done(result): if result.is_pure then 1 else -1 fi
       	 esac
    fi

{ end of core unitarity functionality, remaining variations for user comfort }

{ same as |c_form_irreducible|, but also return a second component that
  exposes the linear combination of contributions from standard representations
  that produced the result (parameter, coefficient, c_form on this standard)

  formulas: write
    J(y)  =sum_x               (-1)^{ell(x)-ell(y)}P(x,y)(q=1)I(x)
  then
    J(y)_c=sum_x (-1)^{on(x,y)}(-1)^{ell(x)-ell(y)}P(x,y)(q=s)I(x)_c
  where
    P(x,y) is a cumulated KL polynomial
    (-1)^{ell(x)-ell(y)}P(x,y) is given by signed_KL_col(y)[i] with
    indices[i]=x on(x,y)=orientation number given by orientation_nr_term()
    I(x)_c given as combination of standards x' with nu(x')=0 by c_form_std(x)
  algorithm: compute the sum for J(y)_c, using signed_KL_col and c_form_std
}
{.c-form on an irreducible, with extra output.}
set c_form_irreducible_long (Param p) =
      (ParamPol,[(Param,Split,KTypePol)],KTypePol):
   let ori_nr_p = orientation_nr(p), formula=KL_sum_at_s(p)
   then standards = { list of contributions }
      for c@q in formula
      do let form_on_standard = c_form_std(q)
         ,   factor           = c*orientation_nr_term(ori_nr_p,q)
      in (q,factor,form_on_standard)
      od
in ( formula, standards
   , null_K_module(p.real_form)+for(,c,f) in standards do c*f od
   )

{ starting formula in the c-form calculation: J(p)_c=\sum w(q)I(q)_c }
set twisted_c_form_irreducible_as_sum_of_standards (Param p) = ParamPol:
  +twisted_c_form_irreducible_contributions(p) { add twisted and untwisted }

{.c_form_irreducible with extra information.}
set twisted_c_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,KTypePol)],[Param,Split,KType],KTypePol):
( assert(twist(p)=p,"parameter is not fixed by inner class involution");
  let (fixed,unfixed) = twisted_c_form_irreducible_contributions(p)
  then G=p.real_form
  , fixed_contribs = [(Param,Split,KTypePol)]:
      for c@q in fixed do (q,c,c*twisted_full_deform(q)) od
  , unfixed_contribs = [(Param,Split,KType)]:
      for c@q in unfixed
      do { now |1+s| divides |c|, which justifies not using |scale_extended|: }
         (q,c,K_type(q))
      od
  then fixed_terms = KTypePol: sum(G,for (,,c) in fixed_contribs do c od)
  ,  unfixed_terms = KTypePol:
        G.null_K_module+for (,c,q0) in unfixed_contribs do (c,q0) od
in ( fixed+unfixed
   , fixed_contribs
   , unfixed_contribs
   , fixed_terms + half(unfixed_terms) )
   )

set twist_orbits (ParamPol P) = ParamPol:
( assert(map(twist@Param,P)=P) { polynomial is assumed to be twist-stable }
; P.real_form.null_module +
  while !=P
  do let (c,q):term = P.first_term then tq=twist(q)
  in term
  next if q=tq then P-:=term else let m_c = -c in P+:=[(m_c,q),(m_c,tq)] fi
  od
)

{ print versions }

set print_twisted_c_form_irreducible_long (Param p) = void:
(  let (formula,terms0,terms1,answer) = twisted_c_form_irreducible_long(p)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
        ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("c-form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{ analyse }

{ print only terms with "mixed" coefficient (a+bs), i.e., both a,b\ne 0 }
set mixed (Split w)= bool: not w.is_pure
set mixed_terms (ParamPol P) = ParamPol:
  0*P + for w@p in P if w.mixed do (w,p) fi od
set analyse (ParamPol P) = void:
  prints("Mixed terms:",P.mixed_terms.pol_format)

{  Hermitian forms  }

{.Hermitian dual.}
set hermitian_dual (Param p) = Param: normal(twist(p))

{.Hermitian form on a standard module, canonical normalization.}
set hermitian_form_std (Param p) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_std(p)
  else check_hermitian(p,false); twisted_c_form_std(p)
  fi. convert_cform_hermitian

{.Hermitian form on a irreducible module, normalization from p0.}
set hermitian_form_irreducible (Param p,KType t0) = KTypePol:
  let c_invariant_form =
    if is_equal_rank(real_form(p)) { then avoid twisted version, for speed }
    then c_form_irreducible(p)
    else check_hermitian(p,true); twisted_c_form_irreducible(p)
    fi
  in convert_cform_hermitian(c_invariant_form,t0)

{. Hermitian form on an irreducible, with extra information.}
set hermitian_form_irreducible_long (Param p) =
    (ParamPol,[(Param,Split,KTypePol)],[(Param,Split,KType)],KTypePol):
  { here we just use |twisted_c_form_irreducible| in all cases }
  check_hermitian(p,true);
  let (formula,terms0,terms1,cform) = twisted_c_form_irreducible_long(p)
  in (formula,terms0,terms1, convert_cform_hermitian(cform))

set hermitian_form_irreducible_long (Param p, KType t0) =
    (ParamPol,[(Param,Split,KTypePol)],[(Param,Split,KType)],KTypePol):
  check_hermitian(p,true);
  let (formula,terms0,terms1,cform) = twisted_c_form_irreducible_long(p)
  in (formula,terms0,terms1, convert_cform_hermitian(cform,t0))

{.nice output of hermitian_form_irreducible.}
set print_hermitian_form_irreducible (Param p) = void:
  hermitian_form_irreducible(p).pol_format.prints

{.nice output of Hermitian forms on list of parameters.}
set print_hermitian_form_irreducible ([Param] P) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p)
  od

set print_hermitian_form_irreducible (Param p,KType p0) = void:
  hermitian_form_irreducible(p,p0).pol_format.prints

set print_hermitian_form_irreducible ([Param] P,KType p0) = void:
  for p in P
  do prints(new_line,"Hermitian form on irreducible: ",p)
  ; print_hermitian_form_irreducible(p,p0)
  od

set print_hermitian_form_irreducible_long (Param p) = void:
(  let (formula,terms0,terms1,answer) = hermitian_form_irreducible_long(p)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
         ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{.print Hermitian form on irreducible, plus extra information.}
set print_hermitian_form_irreducible_long (Param p,KType p0) = void:
(  let (formula,terms0,terms1,answer) = hermitian_form_irreducible_long(p,p0)
in prints(new_line,new_line
         ,"(twisted) c-form on irreducible in terms of standards:",new_line
         ,formula.pol_format,new_line)
;  for (p,coeff,P) in terms0
   do prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"fully deformed",new_line, (coeff*P).pol_format, new_line)
   od
; (let done = { to suppress one of every delta-orbit, we collect seen terms }
    null_module(p) in
   for (p,coeff,p0) in terms1
   do
     if done[p]=0
     then done+:=twist(p) { record to suppress printing |twist(p)| later }
     ; prints("coeff*form on standard: ", new_line
            ,coeff.split_format,"*",p,":",new_line
	    ,"deformed to 0 ", p0, new_line)
     fi
   od
  )
; prints("Hermitian form on irreducible module p=",p,":",new_line
        ,answer.pol_format, "purity=", purity(answer))
)

{ cut the red tape and tell about the hermitian form analysis directly }
set analyse_hermitian_form_irreducible (Param p) = void:
  if not p.is_hermitian
  then prints("Parameter ",p," is not delta-fixed; no hermitian form exists")
  else prints("Parameter ",p," is delta-fixed",new_line,
    "twisted c_form on irreducible in terms of standard representations:")
  ; let (fixed,unfixed) = twisted_c_form_irreducible_contributions(p)
    , c_form=p.real_form.null_K_module
    in
    if !=fixed then prints("Twist-fixed contributions:") fi
  ; c_form+:=
    for c@q in fixed
    do let contribution = c*twisted_full_deform(q) in
      prints(c,"* form on I(",q,"), fully deformed:",contribution,new_line)
    ; contribution
    od
  ; if !=unfixed then prints(new_line,"Non twist-fixed terms:") fi
  ; c_form+:=
    for c@q in twist_orbits(unfixed)
    do let contribution = half(c*K_type(q)+c*K_type(twist(q))) in
      prints(c,"*(I(",q,")",new_line
          ,"        +I(",twist(q),")), at nu=0:",contribution,new_line)
    ; contribution
    od
  ; prints(new_line,"Complete c-invariant form:",c_form,new_line)
  ; prints("Hermitian form:",c_form.convert_cform_hermitian,new_line)
  fi

{   unitarity and weak unitarity tests }

{ compute |p.hermitian_form_irreducible.is_pure|; try to get |false| rapidly }
set hermitian_form_is_pure (Param p) = bool:
( let G=p.real_form
  then (fixed,unfixed) = (ParamPol,ParamPol):
      twisted_c_form_irreducible_contributions(p)
  , result = KTypePol: G.null_K_module
  , tp0 = first_K_type(K_type(p)) { reference for |mu| }
  then limit = 1 + (fixed+unfixed).last_param.height
  then lowest (ParamPol P) = if =P then limit else P.first_param.height fi
  , cur_fix = ParamPol: G.null_module, cur_unfix = ParamPol: G.null_module
  in unfixed:=twist_orbits(unfixed) { choose one of each delta-exchanged pair }
; while
    let fh=fixed.lowest, uh=unfixed.lowest then height = min(fh,uh)+1 in
    height<=limit { equivalently |!=fixed or !=unfixed| }
  do
    if fh<height
    then set (cur_fix,fixed) := height_split(fixed,height)
    else cur_fix:=G.null_module
    fi
  ; if uh<height
    then set (cur_unfix,unfixed):=height_split(unfixed,height)
    else cur_unfix:=G.null_module
    fi
  ; result +:= map(twisted_full_deform@Param,cur_fix)
    	      +K_type_pol(cur_unfix)
  ; let (cur_result,later_result)=height_split(result,height) in
    if not convert_cform_hermitian(cur_result,tp0).is_pure_1
    then return false
    fi
  ; result:=later_result { we are done with terms below |height|, forget them }
  od
; convert_cform_hermitian(result,tp0).is_pure_1
)

set print_is_unitary (Param p) = void:
  if p.is_hermitian
  then let hf=hermitian_form_irreducible(p) in
    if hf.is_pure
    then prints("Unitary")
    else let (real,nonreal,mixed)=purity(hf) in
      prints("Non-Unitary",new_line
	    , real, " real terms", new_line
	    , nonreal," nonreal terms", new_line
	    , mixed, " mixed terms")
    fi
  else prints("Irreducible module does not admit any invariant Hermitian form")
  fi

{ no mixed terms }
set is_weakly_unitary (KTypePol P) = bool: let (,,mixed)=purity(P) in =mixed

{ compute Hermitian form on p, and report if it is weakly unitary }
set is_weakly_unitary (Param p) = bool:
  let G=real_form(p) in
  if is_equal_rank(G)
  then is_weakly_unitary(c_form_irreducible(p))
  else is_weakly_unitary(twisted_c_form_irreducible(p))
  fi

{ for "big" versions: see extParamPol.at }

set test_line (Param p) = void:
( let (x,lambda_minus_rho,gamma) = %p
  , points=reducibility_points(p)
  ,   ipoints=integrality_points(root_datum(p),2*nu(p))
  in prints("testing line through ", p)
; prints("reducibility points: ",points)
; prints("integrality points (for 2*nu): ",ipoints)
; if #points=0
  then prints("entire line is irreducible and unitary"
             ,if K_type(p).is_final then "" else " (nu=0 is not final)" fi)
  else points:=(0/1)#points { tack on initial zero }
  ; if not points[#points-1]=1/1 then points:=points#(1/1) fi
  ; for i:#points-1 from 1
    do
      let t=(points[i]+points[i-1])/2
      then q=param(x,lambda_minus_rho,gamma*t)         { mid point interval }
      ,    r=param(x,lambda_minus_rho,gamma*points[i]) { end point interval }
      in prints(nu(p)*t,": ", is_unitary(first_param(finalize(q))))
      ;  prints(nu(p)*points[i],": ", is_unitary(first_param(finalize(r))))
    od
  fi
)

set weak_test (Param p) = bool:
  let formula=twisted_c_form_irreducible(p)
  then bad=null_K_module(real_form(p)) +
    for w@p in formula if not is_pure(w) do w*p fi od
  in
  if #bad=0 then prints("number of terms: ", #formula); true
  else prints("number of terms: ", #formula,new_line,"bad terms:", bad ); false
  fi

set strong_test (Param p)=bool:
  let formula=hermitian_form_irreducible(p)
  then bad=null_K_module(real_form(p)) +
    for w@p in formula if not is_pure(w) do w*p fi od
  then OK = =bad { return whether bad terms are absent }
  in prints("number of terms: ", #formula);
  if not OK then prints("bad terms:", bad) fi; OK

set branch_c_form_irreducible(Param p, int N) = KTypePol:
  branch(c_form_irreducible(p),N)


{table of is_unitary results, indexed by Param}
set_type 
[ unitarity_bool_hash =
( ( -> int) size
  , ( -> int) count
  , ( -> ) clear
  , (Param->bool) entry
  , (Param->bool) do_you_know {asks if the answer is tabulated}
  , (Param->) append
  , ((Param,bool)->) attest {attest to unitarity of Param}
  , (int -> Param) param_index
  , (int -> bool) data_index
  )
]

set make_unitarity_bool_hash () = unitarity_bool_hash:
(  let param_hash = make_Param_hash()
   then bool_data = [bool] : []
   then clear() = void:
   	let () = param_hash.clear()
 	then () = bool_data:=[]
       	in ()
   in 
   ( ( -> int): { size } @int: #bool_data
   , ( -> int): { count } @int: count(bool_data)
   , ( -> ): {clear} clear
   , (Param -> bool): {entry} (Param p) bool:
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	then () = if m = M
	     	  then {unitary_test_counter.use();}
		       bool_data:= (bool_data next bool_data:= [])
		       	     	   # is_unitary(p);
		       assert(#bool_data = param_hash.size(),
		       			 "unitarity_bool_hash is damaged")
		  fi
	in bool_data[m]
     end
   , (Param -> bool): {do_you_know} (Param p) bool:
     if #simple_factors(p.real_form) = 1
     then p:=herm_center(p)
     fi;
     param_hash.lookup(p).>=
   , (Param->): {append } (Param p):
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	in if m = M
	   then {unitary_test_counter.use();}
		bool_data:= (bool_data next bool_data:= [])
		       	     	   # is_unitary(p)
           fi
     end
   , ((Param,bool)->): {attest} (Param p, bool answer):
     begin
	if #simple_factors(p.real_form) = 1
	then p:=herm_center(p)
	fi;
	let M = param_hash.size()
	then m = param_hash.match(p)
	in if m = M
	   then bool_data#:= answer {(bool_data next bool_data:= [])
		       	     	   # answer}
	   else assert(bool_data[m] = answer,"bad attest")
           fi
     end
   , (int -> Param): {param_index} (int j): param_hash.index(j)
   , (int -> bool): {data_index} (int j): bool_data[j]
  )
)

{smallest theta-stable Q from which p is good range cohomologically induced, and the inducing parameter}
set good_Q(Param p) = (KGPElt, Param):
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x), SCR = G.simple_coroots
    then goodS = ((for j in complement(G.semisimple_rank,suppS)
		     do if (gamma*SCR[j]).=
		        then [j]
		       	else []
		       	fi
		     od.##)##suppS).sort_u
    then goodQ = KGPElt:(goodS, x)
    then goodL = goodQ.Levi
    then xL = inverse_embed_KGB(x,goodL)
    then goodpL = parameter(xL, p.lambda_minus_rho+goodL.rho, p.nu)
    in (goodQ,goodpL)

set good_L(Param p) = RealForm:
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x), SCR = G.simple_coroots
    then goodS = ((for j in complement(G.semisimple_rank,suppS)
		     do if (gamma*SCR[j]).=
		        then [j]
		       	else []
		       	fi
		     od.##)##suppS).sort_u
    in (goodS,x).Levi

{smallest easy theta-stable Q from which p is weakly good range cohomologically
induced, and the inducing parameter}
set wkgood_Q(Param p) = (KGPElt, Param):
    let G = p.real_form, x = p.x, gamma = p.infinitesimal_character
    then theta = x.involution, suppS = support(x) {, SCR = G.simple_coroots}
    then wkgoodQ = KGPElt:(suppS, x)
    then wkgoodL = wkgoodQ.Levi
    then xL = inverse_embed_KGB(x,wkgoodL)
    then wkgoodpL = parameter(xL, p.lambda_minus_rho+wkgoodL.rho, p.nu)
    in (wkgoodQ,wkgoodpL)

set unitarity_hash = make_unitarity_bool_hash()

set is_unitary_hash(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let (,pL) = wkgood_Q(p), G=p.real_form
    then derpLs = derived_factor_params0(pL)
    then answer = all([(->bool)] : for derpL in derpLs do @bool:
       			unitarity_hash.entry(derpL) od)
    {then formL = hermitian_form_irreducible(pL)}
    {then answer = is_pure(formL)}
    in if answer or pL = p
       then answer
       else {answer is false, and pL is on proper Levi}
       	    let goodL = good_L(p)
       	    in is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
			           goodL)
			      od))
       fi
    {unitarity_hash.entry(p)}

set do_you_know_is_unitary(Param p) = bool:
    unitarity_hash.do_you_know(p)

set attest_is_unitary(Param p, bool answer) = void:
    unitarity_hash.attest(p,answer)
