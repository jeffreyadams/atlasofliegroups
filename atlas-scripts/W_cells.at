<characters.at

{ Character of W-representations on cells }

{. given lists of pairs (int,int) and n find (n,m) and return m .}
set find_mate([(int,int)] pairs,int n)=int:
let index=first(#pairs,(int k)bool: let (a,)=pairs[k] in a=n) in
if index!=-1 then let (,b)=pairs[index] in b else 0 fi

{ matrix of action of of i^th simple reflection on a cell
  a cell is: ([int],[([int],[(int,int)])]) cell,int i)
  as described in the W_cells command in atlas-functions.help}

{. matrix of action of i^th simple reflection on a cell .}
set cell_action(([int],[([int],[(int,int)])]) cell,int i)=mat:
let (params,graph)=cell then
n=#params then
taus=for j:n do let (tau,)=graph[j] in tau od then
arrows=for j:n do let (,arrow)=graph[j] in arrow od in
for j:n do
 let col = null(n) in
  if (find(taus[j],i)) !=-1 then col[j]:=-1
   else col[j]:=1;
   for k:n do
    if find(taus[k],i) !=-1 then
     col[k]:=find_mate(arrows[k],j)
    fi
   od
  fi;col
od

{. matrix of action of product of simple reflections on a cell .}
set cell_action(([int],[([int],[(int,int)])]) cell,[int] w)=mat:
let (elements,)=cell then
n=#elements then 
rv=id_mat(n) in
for i in reverse(w) do rv*:=cell_action(cell,i) od;rv

{. matrix of action of WeylElt on a cell .}
set cell_action(([int],[([int],[(int,int)])]) cell,WeylElt w)=mat:
cell_action(cell,w.word)

{set data=([WeylElt],[int]):(conjugacy_classes(rd),sizes_of_conjugacy_classes(*))
 pass this to avoid recomputing it }

{. character of representation of W on cell .}
set cell_character(([int],[([int],[(int,int)])]) cell, ([WeylElt],[int]) data)=
ClassFunction:let (classes,sizes) =data in (classes,sizes,for w in classes do trace(cell_action(cell,w)) od)

{. list of characters of representation on list of cells .}
set cell_characters([([int],[([int],[(int,int)])])] cells, ([WeylElt],[int]) data)=
for cell in cells do cell_character(cell,data) od

{. matrix of inner products of characters of cell representations .}
set matrix_of_innerproducts([ClassFunction] characters,([WeylElt],[int]) data)=mat:
  for i:#characters do for j:#characters do 
  rat_as_int(characters[i]*characters[j]) od od

set cells_table([([int],[([int],[(int,int)])])] cells,([WeylElt],[int]) data)=mat:
let characters=for cell in cells do cell_character(cell,data) od in 
matrix_of_inner_products(characters)

set cells_table_augmented([([int],[([int],[(int,int)])])] cells,([WeylElt] classes,[int] sizes))=mat:
let rd=classes[0].root_datum then
characters=
for cell in cells do cell_character(cell,(classes,sizes)) od
#trivial_character(rd) # sgn_character(rd) # reflection_character(rd)  
in matrix_of_inner_products(characters)





{ Description of the cell representation taken from messages/wcells.help}
{
The Weyl group representation attached to the cell may be described as
follows. It has a Z basis {L_j} indexed by the cell elements j. If
root i is in the tau invariant for element j, then

s_i(L_j) = -L_j.

If i is not in the tau invariant, then

s_i(L_j) = L_j + sum_{elements k, i in tau(k)} m_{kj} * L_k.

where m_{kj} denotes the multiplicity of the edge from k to j.
That is, m*L_k appears in the sum here if i is in the tau-invariant of
L_k, and the pair (j,m) appears in the list for row k.

([224,247,250,253,256],
[([0,1,2],[(1,1)]),
([0,1,3],[(0,1),(3,1),(4,1)]),
([1,2,3],[(3,1)]),([0,2,3],
[(1,1),(2,1)]),([0,1,2],[(1,1)])])

0[224]: {1,2,3} --> 1
1[247]: {1,2,4} --> 0,3,4
2[250]: {2,3,4} --> 3
3[253]: {1,3,4} --> 1,2
4[256]: {1,2,3} --> 1
}