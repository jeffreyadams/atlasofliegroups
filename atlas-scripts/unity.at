<to_ht.at
<induction.at {for theta_stable_quasi_data}
<goodroots.at
<sort.at {for sort_u}
<count.at
<time.at {for time_verbose}
{<K_types.at} {for branch_std}
{<FPP_facets_herm.at {for unitary_hash_big}}
set height(RootDatum R, ratvec nu) = int:
    let q = dominant(R,nu)*R.two_rho_check
    in q.numer\q.denom

{lists in order all the heights of terms in Q except the lowest}
set off_hts(KTypePol Q) = [int]:
     for @q in Q
     do height(q)
     od.sort_u[1:]

set deform_support (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then seen=null_module(G), !empty_K=null_K_module(G)
in p. { apply recursive function initially to our argument |p| }
  (rec_fun support (Param p) KTypePol:
      if =seen[p] else empty_K { skip already included support }
      then seen[p]:=1
      ; p.K_type +
	for k@q
	in sum(G,for factor in reducibility_points(p) do deform(p*factor)
	{first_param(finalize(p*factor))} od)
	do support(q) od
      fi
   )
)

{this is the block_Hasse interval below p, including p if final}
set lower_interval(Param p) = ParamPol: sum(p.real_form, for q in partial_block(p) do q od)

{this version of support(full_deform) seems fastest}
set deform_support_int (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then seen=null_module(G), !empty_K=null_K_module(G)
in p. { apply recursive function initially to our argument |p| }
  (rec_fun support_int (Param p) KTypePol:
      if =seen[p] else empty_K { skip already included support }
      then seen[p]:=1
      ; p.K_type +
	for k@q in sum(G,for factor in reducibility_points(p)
	    	   	 do lower_interval(p*factor)
		  	 od)
	do if height(q) > height(p)
	   then support_int(q)
	   else empty_K
	   fi
	od
      fi
   )
)

set support_params_int_hash = make_Param_hash()
set deform_supports_int_table = [KTypePol]: []

{Same answer as deform_support_int, but much faster}
set rec_fun deform_support_int_hash(Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then empty_K = null_K_module(G)
   then () = p:=alcove_center(p)
   then j = support_params_int_hash.lookup(p)

   then D = if j.>=
      	    then deform_supports_int_table[j]
	    else p.K_type +
	       	 for @q in sum(G,for factor in reducibility_points(p)
	       	    	       	 do lower_interval(first_param(
					p*factor)) od)
	         do if height(q) > height(p)
		    then deform_support_int_hash(q)
		    else empty_K
		    fi
		 od
      	    fi
    then () = D:= sum(G, for @r in D do r od)
    then J = support_params_int_hash.size()
    then () = if not J = #deform_supports_int_table
      	      then error("haven't filled table with int_hash")
	      fi
    then j = support_params_int_hash.lookup(p)
    then () = if j = J
      	      then deform_supports_int_table #:= D
	      fi
    in D
)


{this is meant to contain the block_Hasse interval below p}
set lower_interval_dumb(Param p) = ParamPol:
(if not is_final(p) then error("improper parameter") fi
;   let B = block_of(p), G=p.real_form, ell = length(p)
    then nullP = null_module(G)
    in sum(G, for q in B
       	      do if length(q) >= ell then break
       	      	 else if is_final(q) then q
		      else nullP
		      fi
		 fi
	       od)
)

{ set deform_support_dumb (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then () = p:=alcove_center(p)
   then seen=null_module(G), !empty_K=null_K_module(G)
in p. { apply recursive function initially to our argument |p| }
  (rec_fun support_dumb (Param p) KTypePol:
      if =seen[p] else empty_K { skip already included support }
      then seen[p]:=1
      ; p.K_type +
	for k@q in sum(G,
	    for factor in reducibility_points(p)
	    do lower_interval_dumb(first_param(p*factor))
	    od)
	do support_dumb(q) od
      fi
   )
)

set support_params_dumb_hash = make_Param_hash()
set deform_supports_dumb_table = [KTypePol]: []

set rec_fun deform_support_dumb_hash (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then () = p:=alcove_center(p)
   then J = support_params_dumb_hash.size(), j = support_params_dumb_hash.match(p)
   then () = if not J = #deform_supports_dumb_table
      	      then error("haven't filled table with dumb_hash")
	      fi
   then () = if j = J
      	     then let D = p.K_type +
	       	      for k@q in sum(G,for factor in reducibility_points(p)
	       	    	       	     do lower_interval_dumb(
				     	first_param(p*factor)) od)
	              do deform_support_dumb_hash(q) od
    		  then () = D:= sum(G, for @r in D do r od)
		  in  deform_supports_dumb_table #:= D
	      fi
   in deform_supports_dumb_table[j]
)
}
set short_hts(Param p) = [int]:
    let start = elapsed_ms()
    then answer = [int]:
    	 (for r in reducibility_points(p)
    	 do for @q in deform(p*r)
       	    do for mu in LKTs(q)
       	       do height(mu)
       	       od
       	    od.##
    	 od.## # height(p)).sort_u[1:]
    then () = if time_verbose then prints("     ",
     	     print_time_string(elapsed_ms() - start), " for short_hts") fi
     in answer

set deform_hts(Param p) = [int]:
    let start = elapsed_ms()
    then answer = off_hts(deform_support_int_hash(p))
    then () = if time_verbose then prints("     ",
     	     print_time_string(elapsed_ms() - start), " for deform_hts") fi
    in answer


{Seeks to return string of at least N terms from deform_hts. If this is all there are
(so that testing to these hts determines unitarity, then bool is true.}
set rec_fun deform_hts(Param p, int N) = ([int],bool):
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then empty_K = null_K_module(G)
   then () = p:=alcove_center(p)
   then j = support_params_int_hash.lookup(p)
   then () = if not support_params_int_hash.size() = #deform_supports_int_table
      	     then error("haven't filled table with hash")
	     fi
   in if j >= 0 
      then let answer = off_hts(deform_supports_int_table[j])
	   in return(answer[:min(N,#answer)], #answer<=N)
      else let temp = 1*p.K_type
	   then () = for factor in reducibility_points(p)
	       	     do for @q in lower_interval(first_param(p*factor))
		      	do if height(q) > height(p)
			   then let () = temp:=temp+ deform_support_int_hash(q)
			   	then test = off_hts(temp)
			   	in if #test > N then return (test[:N],false)
			      	   fi
			   fi
			od
		     od
	   then answer = off_hts(temp)
	   then () = temp:= sum(G, for @r in temp do r od)
		  then j1 = support_params_int_hash.match(p)
		  then () = if j1 = #deform_supports_int_table
      	      	       	    then deform_supports_int_table:=
			    (deform_supports_int_table next deform_supports_int_table:=[])
			    			       # temp
	      		    fi
		  in (answer[:min(N,#answer)], #answer<=N)
      	     fi
)

