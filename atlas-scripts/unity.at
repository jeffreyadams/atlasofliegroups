<to_ht.at
<goodroots.at
<induction.at {for theta_stable_quasi_data}
<sort.at {for sort_u}
<count.at

set height(RootDatum R, ratvec nu) = int:
    let q = dominant(R,nu)*R.two_rho_check
    in q.numer\q.denom

set short_hts(Param p) = [int]:
    (for r in reducibility_points(p)
    do for @q in deform(p*r)
       do for mu in LKTs(q)
       	  do height(mu)
       	  od
       od.##
    od.## # height(p)).sort_u[1:]

{ To test a bunch of parameters attached to one KGB element x, and one
lambda, a good idea might be to compute N =
next_to_lowest((x,lambda)); then on each parameter p run
unitarity_test(p,N). Maybe even better: if mu is a LKT, compute tau =
next_to_lowest(mu), and then run unitary_test(p, height (tau),
next_height(tau) }

{. gives (one of) the K-types of lowest height above mu in the
standard of LKT mu .} {NEED USEFUL BOUND in K_type_formula.}
set next_to_lowest(KType mu) = KType:
    let (,tau) = first_term(K_type_formula(mu, height(mu) + 30) - mu)
    in tau

{. height of a smallest non-lowest K_type of standard with LKT mu .}
set next_height(KType mu)  = int:
    height(next_to_lowest(mu))

set next_height(KType mu) = int:
    let m = height(mu)
    in m+first( for j in #30 do @:!= K_type_formula(mu,m+2*j+2) - mu od)

{. height of a smallest non-lowest K_type of p .}
set next_height(Param p) = int:
    height(next_to_lowest(LKTs(p)[0]))

{entries are the m heights of K-types of standard of mu after mu.}
set next_heights(KType mu, int m) = [int]:
    let h = height(mu)
    then N = h+10, list = [int]: []
    then () = while #list < m
    	 do list:=sort_u(for tau in monomials(branch(mu,N) - mu)
	    		 do height(tau)
			 od);
	    N:=N+5
	 od
    in list[:m]

set next_heights(Param p, int m) = [int]:
    for tau in LKTs(p) do next_heights(tau,m) od.##.sort_u[:m]

{if this produces -1, then the (hermitian) p is automatically unitary}
set next_heightB(Param p) = int:
    let mu = LKTs(p)[0]
    then M = K_type_formula(mu, height(p) + height(p.root_datum, p.nu)) - mu
    in
    if =M then -1
    else
    let (,tau) = first_term(M) in height(tau)
    fi

{. tests unitarity first on LKTs, then everywhere .}
set is_unitary_test(Param p) = bool:
    is_pos_on_LKTs(p) and
    is_unitary(p)

{. tests unitarity first on LKTs, then on next-to-lowest, then
everywhere .}
set is_unitary_test_next(Param p) = bool:
    is_pos_on_LKTs(p) and
    is_unitary_to_ht(p, next_height(p)) and
    is_unitary(p)

{. tests unitarity first on LKTs, then on next-to-lowest up to
height(nu), then everywhere. If no K-types to height(nu), then true .}
set is_unitary_test_nextB(Param p) = bool:
    is_pos_on_LKTs(p) and
    (
    let n = next_heightB(p)
    in
    if n = -1 then true
    else
    is_unitary_to_ht(p,n) and
    is_unitary(p)
    fi
    )

{way to get N for LKT mu: compute K_type_formula(mu), take next to
lowest term}
{. same as previous if next_height N is known .}
set is_unitary_test(Param p, int N) = bool:
    is_unitary_to_ht(p, N) and
    is_unitary(p)

set is_unitary_test(Param p, int N, KTypePol_hash cert_hash) = bool:
    is_pos_on_LKTs(p) and
    is_unitary_to_ht(p, N, cert_hash) and
    is_unitary(p,cert_hash)

set is_unitary_test(Param p, int N1, int N2) = bool:
    is_unitary_to_ht(p, N1) and
    is_unitary_to_ht(p, N2) and
    is_unitary(p)

set is_unitary_test(Param p, int N1, int N2, KTypePol_hash cert_hash) = bool:
    is_unitary_to_ht(p, N1, cert_hash) and
    is_unitary_to_ht(p, N2, cert_hash) and
    is_unitary(p, cert_hash)

set is_unitary_test(Param p, int N1, int N2, int N3) = bool:
    is_unitary_to_ht(p, N1) and
    is_unitary_to_ht(p, N2) and
    is_unitary_to_ht(p, N3) and
    is_unitary(p)

set is_unitary_test(Param p, [int] Ns) = bool:
    for N in Ns
    do if not is_unitary_to_ht(p,N)
       then return false
       fi
    od;
    is_unitary(p)

set is_unitary_test(Param p, [int] Ns, KTypePol_hash cert_hash) = bool:
    for N in Ns
    do if not is_unitary_to_ht(p,N, cert_hash)
       then return false
       fi
    od;
    {all(for N in Ns do is_unitary_to_ht(p,N,cert_hash) od) and}
    is_unitary(p,cert_hash)

{use the first N heights from short_heights to test}
set is_unitary_short_test(Param p,int N) = bool:
    let short= short_hts(p)
    in is_unitary_test(p,short[:min(N,#short)])


{ these commands are useful for speed tests over bunches of parameters

set G4 =F4_s
set nus4 = for b in box(5,4) do b/4 od
set x4 = x_open(G4)
set ps4 = for nu in nus4 do parameter(x4,[1,1,1,1],nu) od

set G6 = E6_q
set nus6 = for b in box(4,6) do b/3 od
set x6 = x_open(G6)
set ps6 = for nu in nus6 do Finalize(parameter(x6,[1,1,1,1,1,1],nu)) od

set G7 = E7_s
set nus7 = for b in box(4,7) do b/3 od
set x7 = x_open(G7)
set ps7 = for nu in nus7 do parameter(x7,[1,1,1,1,1,1,1],nu) od

}
