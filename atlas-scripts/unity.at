<to_ht.at
<induction.at {for theta_stable_quasi_data}
<goodroots.at
<sort.at {for sort_u}
<count.at
<time.at {for time_verbose}
set height(RootDatum R, ratvec nu) = int:
    let q = dominant(R,nu)*R.two_rho_check
    in q.numer\q.denom


set deform_support (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then seen=null_module(G), !empty_K=null_K_module(G)
in p. { apply recursive function initially to our argument |p| }
  (rec_fun support (Param p) KTypePol:
      if =seen[p] else empty_K { skip already included support }
      then seen[p]:=1
      ; p.K_type +
	for k@q
	in sum(G,for factor in reducibility_points(p) do deform(p*factor)
	{first_param(finalize(p*factor))} od)
	do support(q) od
      fi
   )
)

set support_params_hash = make_Param_hash()
set deform_supports_table = [KTypePol]: []

set rec_fun deform_support_hash (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then () = p:=alcove_center(p)
   then j = support_params_hash.lookup(p)
   then () = if not support_params_hash.size() = #deform_supports_table
      	      	then error("haven't filled table with hash")
	      	fi
   then D = if j >= 0 
      	    then deform_supports_table[j]
	    else p.K_type +
	       	    for k@q in sum(G,for factor in reducibility_points(p)
	       	    	       	     do deform(p*factor) od)
	            do deform_support_hash(q) od
      	    fi
   then () = D:= sum(G, for @r in D do r od)
   then j1 = support_params_hash.match(p)
   then () = if j1 = #deform_supports_table
      	      	then deform_supports_table:=
		(deform_supports_table next deform_supports_table:=[])
		# D
		fi
    in D
)

{this is meant to be the block_Hasse interval below p}
set lower_interval(Param p) = ParamPol:
(if not is_final(p) then error("improper parameter") fi
;   let (B,M) = block_Hasse(p), G=p.real_form
    then d = length(B~[0]) - length(B[0])
    then N = 1+M
    then () = for j:d do N:= N+N*M od
    then j0 = first(for q in B do p=q od)
    in sum(G, for j:j0 do (if is_final(B[j]) and N[j,j0]!=0 then 1 else 0
    fi)*B[j] od)
)

{
{intended to hold last elements of common blocks}
set block_hash = make_Param_hash()

{for each block in block_hash, the result of block_of}
set block_table = [[Param]]: []

set lower_interval_hash(Param p) = ParamPol:
(if not is_final(p) then error("improper parameter") fi
;   let j = )
}

set deform_support_int (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then seen=null_module(G), !empty_K=null_K_module(G)
in p. { apply recursive function initially to our argument |p| }
  (rec_fun support_int (Param p) KTypePol:
      if =seen[p] else empty_K { skip already included support }
      then seen[p]:=1
      ; p.K_type +
	for k@q in sum(G,for factor in reducibility_points(p)
	    	   	 do lower_interval(first_param(finalize(p*factor)))
		  	 od)
	do support_int(q) od
      fi
   )
)

set support_params_int_hash = make_Param_hash()
set deform_supports_int_table = [KTypePol]: []

set rec_fun deform_support_int_hash(Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then () = p:=alcove_center(p)
   then j = support_params_int_hash.lookup(p)
   then () = if not support_params_int_hash.size() = #deform_supports_int_table
      	     then error("haven't filled table with hash")
	     fi
   then D = if j >= 0 
      	    then deform_supports_int_table[j]
	    else p.K_type +
	       	 for @q in sum(G,for factor in reducibility_points(p)
	       	    	       	 do lower_interval(first_param(finalize(
					p*factor))) od)
	         do deform_support_int_hash(q) od
      	       fi
    then () = D:= sum(G, for @r in D do r od)
    then j1 = support_params_int_hash.match(p)
    then () = if j1 = #deform_supports_int_table
      	      then deform_supports_int_table:=
		(deform_supports_int_table next deform_supports_int_table:=[])
		# D
	      fi
    in D
)

{this is meant to contain the block_Hasse interval below p}
set lower_interval_dumb(Param p) = ParamPol:
(if not is_final(p) then error("improper parameter") fi
;   let B = block_of(p), G=p.real_form, ell = length(p)
    then nullP = null_module(G)
    in sum(G, for q in B
       	      do if length(q) >= ell then break
       	      	 else if is_final(q) then q
		      else nullP
		      fi
		 fi
	       od)
)

set deform_support_dumb (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then () = p:=alcove_center(p)
   then seen=null_module(G), !empty_K=null_K_module(G)
in p. { apply recursive function initially to our argument |p| }
  (rec_fun support_dumb (Param p) KTypePol:
      if =seen[p] else empty_K { skip already included support }
      then seen[p]:=1
      ; p.K_type +
	for k@q in sum(G,
	    for factor in reducibility_points(p)
	    do lower_interval_dumb(first_param(finalize(p*factor)))
	    od)
	do support_dumb(q) od
      fi
   )
)

set support_params_dumb_hash = make_Param_hash()
set deform_supports_dumb_table = [KTypePol]: []

set rec_fun deform_support_dumb_hash (Param p) = KTypePol:
( if not is_final(p) then error("improper parameter") fi
;  let G=real_form(p)
   then () = p:=alcove_center(p)
   then j = support_params_dumb_hash.lookup(p)
   then () = if not support_params_dumb_hash.size() = #deform_supports_dumb_table
      	      then error("haven't filled table with hash")
	      fi
   then D = if j >= 0
      	    then deform_supports_dumb_table[j]
	    else p.K_type +
	       	    for k@q in sum(G,for factor in reducibility_points(p)
	       	    	       	     do lower_interval_dumb(
				     	first_param(p*factor)) od)
	            do deform_support_dumb_hash(q) od
      	    fi
    then () = D:= sum(G, for @r in D do r od)
    then j1 = support_params_dumb_hash.match(p)
    then () = if j1 = #deform_supports_dumb_table
      	      	then {deform_supports_dumb_table:=deform_supports_dumb_table # D}
		deform_supports_dumb_table:=
			(deform_supports_dumb_table next deform_supports_dumb_table :=[])
		        	# D
	       fi
    in D
)

set short_hts(Param p) = [int]:
    let start = elapsed_ms()
    then answer = [int]:
    	 (for r in reducibility_points(p)
    	 do for @q in deform(p*r)
       	    do for mu in LKTs(q)
       	       do height(mu)
       	       od
       	    od.##
    	 od.## # height(p)).sort_u[1:]
    then () = if time_verbose then prints("     ",
     	     print_time_string(elapsed_ms() - start), " for short_hts") fi
     in answer

set deform_hts(Param p) = [int]:
    let start = elapsed_ms()
    then answer = [int]:
      for @q in deform_support_hash(p)
      do height(q)
      od.sort_u[1:]
    then () = if time_verbose then prints("     ",
     	     print_time_string(elapsed_ms() - start), " for deform__hts") fi
    in answer

{ To test a bunch of parameters attached to one KGB element x, and one
lambda, a good idea might be to compute N =
next_to_lowest((x,lambda)); then on each parameter p run
unitarity_test(p,N). Maybe even better: if mu is a LKT, compute tau =
next_to_lowest(mu), and then run unitary_test(p, height (tau),
next_height(tau) }

{. gives (one of) the K-types of lowest height above mu in the
standard of LKT mu .} {NEED USEFUL BOUND in K_type_formula.}
set next_to_lowest(KType mu) = KType:
    let (,tau) = first_term(K_type_formula(mu, height(mu) + 30) - mu)
    in tau

{. height of a smallest non-lowest K_type of standard with LKT mu .}
set next_height(KType mu)  = int:
    height(next_to_lowest(mu))

set next_height(KType mu) = int:
    let m = height(mu)
    in m+first( for j in #30 do @:!= K_type_formula(mu,m+2*j+2) - mu od)

{. height of a smallest non-lowest K_type of p .}
set next_height(Param p) = int:
    height(next_to_lowest(LKTs(p)[0]))

{entries are the m heights of K-types of standard of mu after mu.}
set next_heights(KType mu, int m) = [int]:
    let h = height(mu), start = elapsed_ms()
    then N = h+10, list = [int]: []
    then () = while #list < m
    	 do list:=sort_u(for tau in monomials(branch(mu,N) - mu)
	    		 do height(tau)
			 od);
	    N:=N+5
	 od
    then () = if time_verbose then prints("    ",print_time_string(
    elapsed_ms() - start)," for next_heights to ",m) fi
    in list[:m]

set next_heights(Param p, int m) = [int]:
    for tau in LKTs(p) do next_heights(tau,m) od.##.sort_u[:m]

{if this produces -1, then the (hermitian) p is automatically unitary}
set next_heightB(Param p) = int:
    let mu = LKTs(p)[0]
    then M = K_type_formula(mu, height(p) + height(p.root_datum, p.nu)) - mu
    in
    if =M then -1
    else
    let (,tau) = first_term(M) in height(tau)
    fi

{. tests unitarity first on LKTs, then everywhere .}
set is_unitary_test(Param p) = bool:
    is_pos_on_LKTs(p) and
    is_unitary(p)

{. tests unitarity first on LKTs, then on next-to-lowest, then
everywhere .}
set is_unitary_test_next(Param p) = bool:
    is_pos_on_LKTs(p) and
    is_unitary_to_ht(p, next_height(p)) and
    is_unitary(p)

{. tests unitarity first on LKTs, then on next-to-lowest up to
height(nu), then everywhere. If no K-types to height(nu), then true .}
set is_unitary_test_nextB(Param p) = bool:
    is_pos_on_LKTs(p) and
    (
    let n = next_heightB(p)
    in
    if n = -1 then true
    else
    is_unitary_to_ht(p,n) and
    is_unitary(p)
    fi
    )

{way to get N for LKT mu: compute K_type_formula(mu), take next to
lowest term}
{. same as previous if next_height N is known .}
set is_unitary_test(Param p, int N) = bool:
    is_unitary_to_ht(p, N) and
    is_unitary(p)

set is_unitary_test(Param p, int N, KTypePol_hash cert_hash) = bool:
    is_pos_on_LKTs(p) and
    is_unitary_to_ht(p, N, cert_hash) and
    is_unitary(p,cert_hash)

set is_unitary_test(Param p, int N1, int N2) = bool:
    is_unitary_to_ht(p, N1) and
    is_unitary_to_ht(p, N2) and
    is_unitary(p)

set is_unitary_test(Param p, int N1, int N2, KTypePol_hash cert_hash) = bool:
    is_unitary_to_ht(p, N1, cert_hash) and
    is_unitary_to_ht(p, N2, cert_hash) and
    is_unitary(p, cert_hash)

set is_unitary_test(Param p, int N1, int N2, int N3) = bool:
    is_unitary_to_ht(p, N1) and
    is_unitary_to_ht(p, N2) and
    is_unitary_to_ht(p, N3) and
    is_unitary(p)

set is_unitary_test(Param p, [int] Ns) = bool:
    for N in Ns
    do if not is_unitary_to_ht(p,N)
       then return false
       fi
    od;
    is_unitary(p)

set is_unitary_test(Param p, [int] Ns, KTypePol_hash cert_hash) = bool:
    for N in Ns
    do if not is_unitary_to_ht(p,N, cert_hash)
       then return false
       fi
    od;
    {all(for N in Ns do is_unitary_to_ht(p,N,cert_hash) od) and}
    is_unitary(p,cert_hash)

{use the first N heights from short_heights to test}
set is_unitary_short_test(Param p,int N) = bool:
    let short= short_hts(p)
    in is_unitary_test(p,short[:min(N,#short)])

{use the first N heights from short_heights to test}
set is_unitary_def_test(Param p,int N) = bool:
    let def= deform_hts(p)
    in if #def <= N
       then is_pos_on_LKTs(p) and is_unitary_to_hts(p,def)
       else is_unitary_test(p,def[:N])
       fi

{ these commands are useful for speed tests over bunches of parameters

set G4 =F4_s
set nus4 = for b in box(5,4) do b/4 od
set x4 = x_open(G4)
set ps4 = for nu in nus4 do parameter(x4,[1,1,1,1],nu) od

set G6 = E6_q
set nus6 = for b in box(4,6) do b/3 od
set x6 = x_open(G6)
set ps6 = for nu in nus6 do Finalize(parameter(x6,[1,1,1,1,1,1],nu)) od

set G7 = E7_s
set nus7 = for b in box(4,7) do b/3 od
set x7 = x_open(G7)
set ps7 = for nu in nus7 do parameter(x7,[1,1,1,1,1,1,1],nu) od

}
