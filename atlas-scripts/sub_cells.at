<lietypes.at { for |is_locally_isomorphic| }
<K.at      { for |K_0| }
<W_reps.at { for type |WGraph| }
<cells.at

{is_complex moved to complex.at}

set swapped_factors(RealForm G)=[(int,int)]:
assert(G.is_complex,"G is not complex");
let sf=G.simple_factors in
##for factor@i in sf do
 let root=G.distinguished_involution*factor.simple_roots[0] then
 j=first(for i:#sf do find(sf[i].simple_roots,root) !=-1 od) in
  if i<j then [(i,j)] else [] fi
od

set left_factors(RealForm G)=[RootDatum]:
assert(G.is_complex,"G is not complex");
let sf=G.simple_factors in
for (i,j) in G.swapped_factors do sf[i] od

set left_roots(RealForm G)=[vec]:
##for f in G.left_factors do [vec]:f.simple_roots od

set left_coroots(RealForm G)=[vec]:
##for f in G.left_factors do [vec]:f.simple_coroots od

set left_copy(RealForm G)=RootDatum:
root_datum(left_roots(G),left_coroots(G))

set left_root_indices(RealForm G)=[int]:
for v in G.left_roots do find(G.simple_roots,v) od

set right_factors(RealForm G)=[RootDatum]:
assert(G.is_complex,"G is not complex");
let sf=G.simple_factors in
for (i,j) in G.swapped_factors do sf[i] od

set right_roots(RealForm G)=[vec]:
##for f in G.right_factors do [vec]:f.simple_roots od

set right_coroots(RealForm G)=[vec]:
##for f in G.right_factors do [vec]:f.simple_coroots od

set right_copy(RealForm G)=RootDatum:
root_datum(right_roots(G),right_coroots(G))

set right_root_indices(RealForm G)=[int]:
for v in G.right_roots do find(G.simple_roots,v) od

{tau invariant of node of WGraph}
set tau(WGraph graph,int i)=[int]:let (tau,)=graph.nodes[i] in tau
set in_tau(WGraph graph,int i, int j)=bool:
if find(tau(graph,i),j)>=0 then true else false fi

{intersection of sets of integers}
set intersection([int] S,[int] T)=[int]:
##for i in S do if find(T,i)>=0 then [i] else [] fi od

{directed graph underlying (symmetric) WGraph
 see atlas-functions.help/W_graph
 discard edge x->y if tax(x)\subset tau(y)
 [keep edge x-> y if there is j\in tau(x), j\not\in\tau(y)]
}
set digraph(WGraph graph)=WGraph:
(graph.root_datum,for (tau,edges) in graph.nodes do
    (tau,
	##for (target,mult) in edges do
	    if not is_subset(tau,tau(graph.nodes[target])) then [(target,mult)] else [] fi
	  od)
od)

set intersection([int] A,[int] B)=[int]:
##for i in A do if find(B,i)!=-1 then [i] else [] fi od

{subgraph of a directed graph
 given by subset S of simple roots
 keep link x->y if there is j\in S satisfying:
  j\in \tau(x)  j\not\in\tau(y) i.e. 
  S\cap tau(x)\not\subset \tau(y) 
}

set sub_digraph(WGraph graph,[int] S)=WGraph:
(sub_root_datum(graph.root_datum,S).derived,for (tau,edges) in graph.nodes do
    (intersection(S,tau),
	##for (target,mult) in edges do
	    let tau_target=tau(graph.nodes[target]) in
	    	if not is_subset(intersection(S,tau),tau_target) 
		   then [(target,mult)] else [] fi
	  od)
od)

set sub_graph(WGraph graph,[int] S)=WGraph:
(graph.root_datum,for (tau,edges) in graph.nodes do
    (tau,
	##for (target,mult) in edges do
	    let tau_target=tau(graph.nodes[target]) in
	    	if not is_subset(intersection(S,tau),tau_target) or
		   not is_subset(intersection(S,tau_target),tau) 
		   then [(target,mult)] else [] fi
	  od)
od)

set links(WGraph graph)=[[int]]:
for i:#graph do let (,links)=graph.nodes[i] in
 for (j,) in links do j
 od
od

{strong_components(g) returns [([int] nodes,WGraph)]:
the ith entry ([int] nodes,WGraph graph) is:
 nodes is the list of nodes in the strong component
  (as returned by strong_components(links(g)))
 graph is the WGraph of these nodes, renumbered [0,1,...,k]
  so this really is a WGraph, without reference to the original,
  as in the W_cells command,
}
set strong_components(WGraph g)=[WCell]: {[([int],WGraph)]:}
let (components,)=strong_components(links(g)) in
for comp in components do
 (comp,
   (g.root_datum,
     for i in comp do let (tau,links)=g.nodes[i] in
       (tau,##for (j,m) in links do let index=find(comp,j) in
       if index>=0 then [(index,m)] else [] fi od
       )
 od))
od

{same as the previous, except that the nodes [0,1,...,n] of
 g are also labeled by [int] nodes, and we want to keep track of
 this numbering also
 this means for each component there are two lists of indices:
  first one:  the nodes of component, in their numbering [0,...,n] of nodes of g
  second one: the nodes of component, in their numbering from [int] nodes
  return: (second one,graph)
}
set strong_components(WCell cell)=[WCell]:{[([int],WGraph)]:}
let (nodes,g)=cell in
for (indices,graph) in strong_components(g)  do
(for i in indices do nodes[i] od, graph)
od

set sub_cells(WCell (nodes,graph),[int] S)=[WCell]:
strong_components(nodes,sub_digraph(graph,S))

set left_cells(RealForm G,WCell cell)=[WCell]:
sub_cells(cell,left_root_indices(G))

set right_cells(RealForm G,WCell cell)=[WCell]:
sub_cells(cell,right_root_indices(G))

set left_cell_of(Param p)=
let (index,cell)=W_cell(p) then
cells=left_cells(p.real_form,cell) then
j=first(for (vertices,links) in cells do find(vertices,index)>=0 od) in 
cells[j]


set extract_nodes(WGraph g, [int] nodes)=WGraph:
(g.root_datum,
for i in nodes do
let (tau,links)=g.nodes[i] in
 (tau,##for (j,m) in links do
  let index=find(nodes,j) in
   if index!=-1 then [(index,m)] else [] fi od)
od
)

{. character of representation of W on cell .}
{
set cell_character_C (CharacterTable ct,WCell cell) = [int]:
for w in ct.class_reps do trace(cell_action(cell,w)) od
}

{ ----- output commands  -----------}
set show(WGraph g)=void:
tabulate(["node","tau","links"]#for (a,b)@i in g.nodes do
 [i.to_string,a.to_string,b.to_string] od)

set show(WCell (vertices,g))=
prints("vertices: ", vertices);show(g)

set show([WGraph] graphs)=void:
tabulate(["graph","node","tau","links"]#
##for graph@i in graphs do
 ["","","",""]#for (a,b)@j in graph.nodes do
 [i.to_string,j.to_string,a.to_string,b.to_string] od od)

set show([WCell] cells)=void:
for (vertices,graph)@i in cells do
prints("cell #", i, new_line,"vertices: ", vertices);
show(graph);prints() od

{convert [int] to string, truncating after max terms}
set short_string([int] list,int max)=
if #list<max then list.to_string else
let rv="[" in
 for i:max do rv+:=list[i].to_string+"," od;
rv+:=list~[1].to_string+",...]";
rv
fi

set show_short([WCell] cells)=void:
tabulate(["cell","size","nodes"]#for (nodes,graph)@i in cells do
[i.to_string,(#nodes).to_string,short_string(nodes,15)] od)

{write a graphviz file
 typical usage:
 > file.dot prints(export(g))
 in console:
 dot -Tpdf -ofile.pdf file.dot"
}
set export(WGraph g)=string:
let text=
"strict digraph  { " +
new_line + "size=""30.0,30.0!""; " +
new_line + "center=true;  " +
new_line + "node [color=black,fontcolor=black] " +
new_line + " edge [arrowhead=normal,color=black]; "
in
for node@i in g.nodes do
 let (tau,arrows)=node then
 str=new_line+i.to_string+ ";" in
  for (j,m) in arrows do str+:=i.to_string + "->" + j.to_string + ";" od;
 text+:=str
od;text+new_line+"}"

{G is complex, 
 st_left is the springer table for the left copy of G
}
{set special_left_orbit(SpringerTable st_left,Param p)=
special_orbit(st_left,W_cell
}