<cyclotomic.at
<coxeter.at
<W_orbit.at
<representations.at
<finite_dimensional.at

{! Weyl character formula computed at elements of finite order

Suppose G is a connected, complex reductive group, or a connected
compact group. An irreducible finite dimensional representation (pi,V)
of G is determined by its highest weight. The Weyl character formula
computes the trace of pi(t), for t a (semisimple) element of G, as a
quotient. If t is regular (the identity component of its centralizer
is a torus) both numerator and denominator are nonzero.

If t is singular both the numerator and denominator can vanish, in
which case a version of L'Hopital's rule is needed. For example when
t=1 this gives the Weyl dimension formula.

There is a version of the Weyl character formula, which can be
directly evaluated on any element t, which involves the Weyl dimension
formula on the centralizer of t. This is the formula we have
implemented. If t has order n then trace(pi(t)) is an algebraic
integer in the cyclotomic field of n^th roots of 1, i.e. an integral
linear combination of roots of 1.

See https://www2.bc.edu/mark-reeder/WeylChar.pdf Proposition 6.1 !}

{. set true for more output .}
set verbose_wcf=false

{ see if w is equivalent to v mod Z^n for some v in list}
set find_ratvec_mod_vec ([ratvec] v, ratvec w) = int:
   first(for r in v do =(r-w)%1 od)

{ keep coset representatives of list of ratvecs mod Z^n}
set reduce_ratvecs_mod_lattice ([ratvec] S) = [ratvec]:
   let reduced= for s in S do s%1 od, result=[ratvec]:[] in
   for x in reduced
   do if all(for y in result do x!=y od) then result#:=x fi
   od; result

{ action is by dual(rd) since v is in X_*(T)_Q }
set W_orbit_torus_element(RootDatum rd,ratvec v)=[ratvec]:
   reduce_ratvecs_mod_lattice(W_orbit(dual(rd),v))

{ see centralizer@(KGBElt,ratvec) in K_highest_weights.at
  don't need x, and test is <alpha,v> is an integer
}
set centralizer(RootDatum rd,ratvec v) = RootDatum:
   let roots = columns_with((vec alpha): is_integer(alpha*v), posroots(rd))
   then coroots = rank(rd) # for alpha in roots do coroot(rd,alpha) od
   in root_datum(simple_from_positive(roots,coroots))

{. order of element of Q/Z.}
set QmodZ_order(ratvec v)=int:denom(v)

{ evaluate character (in Z^n) of T on t\in T of finite order,
giving result in the given cyclotomic field}
set eval_char_T(vec lambda, ratvec v,cyclotomicField F)=cyclotomicFieldElement:
   exp_1(lambda*v,F)

{.product of $1-\exp(-alpha)(t)$ over all posroots $\alpha$ making it nonzero.}
set weyl_denominator_quotient(RootDatum rd, ratvec v,cyclotomicField F) =
      cyclotomicFieldElement:
   let result=F.one in
   for alpha in posroots(rd)
   do let eval=(alpha*v)%1 in
      if !=eval then result*:=(F.one-F.one*exp_1(-eval,F)) fi
   od; result


{.Weyl character formula for finite dimensional with extremal weight lambda
  at t=exp_1(v).}
set wcf(RootDatum rd, vec lambda,ratvec v,cyclotomicField F) =
      cyclotomicFieldElement:
   let S=W_orbit_torus_element(rd,v), rv=F.zero in
   for w in S
   do let rd_w=centralizer(rd,w), num=eval_char_T(lambda,w,F)
      ,  denom=weyl_denominator_quotient(rd,w,F)
      then denom_inverse=inverse(denom)
      ,    dim_term=embed_Q(dimension(rd_w,lambda+rho(rd)-rho(rd_w)),F)
      in if verbose_wcf
         then prints(new_line, "t= ", w)
         ;  prints("numerator= ", to_string(num),new_line
                  ,"denominator= ", to_string(denom), new_line
                  ,"dimension term= ", dim_term)
         ;  prints("centralizer: ", rd_w)
	 ;  prints("inverse of denominator:", denom_inverse
	          ,"  ", to_string(denom_inverse))
         ;  prints("contribution: ", to_string((num*denom_inverse)*dim_term))
         fi
      ;  rv+:=(num*denom_inverse)*dim_term
   od; assert(is_integer(rv.v),"Character value is not an algebraic integer");
   rv

{mainly for debugging;
 same as previous, also returning an array of terms from the computation }
set wcf_long (RootDatum rd, vec lambda,ratvec v,cyclotomicField F) =
      (cyclotomicFieldElement,[cyclotomicFieldElement]):
   let S=W_orbit_torus_element(rd,v)
   , rv=F.zero, list=[cyclotomicFieldElement]:[]
   in
   for w in S
   do let rd_w=centralizer(rd,w), num=eval_char_T(lambda,w,F)
      ,  denom=weyl_denominator_quotient(rd,w,F)
      then denom_inverse=inverse(denom)
      ,    dim_term=embed_Q(dimension(rd_w,lambda+rho(rd)-rho(rd_w)),F)
      then contrib=(num*denom_inverse)*dim_term
      in if verbose_wcf
         then prints(new_line, "t= ", w)
         ;  prints("numerator= ", to_string(num),new_line
	          ,"denominator= ", to_string(denom), new_line
		  ,"dimension term= ", dim_term)
         ;  prints("centralizer: ", rd_w)
         ;  prints("inverse of denominator:", denom_inverse
		  ,"  ", to_string(denom_inverse))
         ;  prints("contribution: ", to_string((num*denom_inverse)*dim_term))
	 fi
      ;  rv+:=(num*denom_inverse)*dim_term
      ;  list#:=contrib
   od; (rv,list)

{variants of wcf functions}
set wcf (RootDatum rd, vec lambda,ratvec v) = cyclotomicFieldElement:
   wcf(rd,lambda,v,CF(denom(v)))
set wcf (vec lambda,(RootDatum rd,ratvec v)) = cyclotomicFieldElement:
   wcf(rd,lambda,v,CF(denom(v)))
set wcf(Param p, ratvec v) = cyclotomicFieldElement:
   wcf(root_datum(p),highest_weight_finite_dimensional(fd_only(p)),v)

set wcf_long (RootDatum rd, vec lambda,ratvec v) =
      (cyclotomicFieldElement,[cyclotomicFieldElement]):
   wcf_long(rd,lambda,v,CF(denom(v)))
set wcf_long (vec lambda,(RootDatum rd,ratvec v)) =
      (cyclotomicFieldElement,[cyclotomicFieldElement]):
   wcf_long(rd,lambda,v,CF(denom(v)))

{special case of Weyl character formula: x^2\in Z (strong real form)
 used for computing signatures of Hermitian forms, need to handle
 large integers
 currently integer is of size <=2^31-1, want to allow 2^63-1
 (eventually arbitrary precision)
 temporary work-around: use rationals instead of integers
 returns (rat theta,rat k): Trace(pi(x))=e^{2\pi i theta}*k
 since x^2\in Z, \pi(x)=\zeta^{1/2}diag(\pm 1,...,\pm 1) where
 zeta^{1/2} is a square root of the central character evaluated as x^2
 zeta=e^{\pi i\theta}
}

{.Weyl character formula for highest weight lambda evaluated on an element x
  in T with x^2 in Z.}
set wcf_strong_real(RootDatum rd, ratvec lambda,ratvec v)=(rat,rat):
(  let S=W_orbit_torus_element(rd,v)
   , denominator=weyl_denominator_quotient(rd,v,cyclotomic_field(2)).to_rational
       { this is a power of 2, and same on all elements of orbit }
   , result=rat: 0
   in if verbose_wcf
      then prints("centralizer(x): ", centralizer(rd,v), new_line
                 ,"denominator: ", denominator)
      fi
   ;  for w in S
      do let rd_w=centralizer(rd,w) in
         result+:= minus_1^(lambda*2*(w-v)).rat_as_int
                  *(dimension_rat(rd_w,lambda+rho(rd)-rho(rd_w))/denominator)
     od; (lambda*v,result)
)

{.Weyl character formula for finite dimensional p evaluated on an element x
 in T with x^2 in Z.}
set wcf_strong_real (Param p,ratvec v) = (rat,rat):
   wcf_strong_real(root_datum(p),p.fd_only.highest_weight_finite_dimensional,v)

{ Weyl character formula: given set of weights, add them up at exp(2i\pi t)
  input should be the set of weights (with multiplicities) of a representation }
{.evaluate sum of weights at t.}
set wcf ([vec] weights,ratvec v) = cyclotomicFieldElement:
   let F=cyclotomic_field(denom(v)) then result=F.zero in
   for mu in weights
   do let trace=exp_1(mu*v,F) in
      if verbose_wcf then prints("mu= ", mu, " trace= ", to_string(trace)) fi
   ;  result+:=trace
   od; result

{.torus factor of strong real form of x.}
set torus_factor_x (RealForm G) = (RootDatum,ratvec):
   ( root_datum(G), (torus_factor(KGB(G,0))+rho_check(G))/2 )

{.output of Weyl character formula.}
set wcf_report (RealForm G, vec lambda, ratvec t) = void:
   prints("highest weight=", lambda, "  "
         ," dimension=", dimension(finite_dimensional(G,lambda))
         ," trace=", wcf(lambda,(G,t)).to_string)

set wcf_report (Param p,ratvec t) = void:
   wcf_report(real_form(p), highest_weight_finite_dimensional(fd_only(p)), t)

{.run over all finite dimensionals up to height bound.}
set wcf_report (RealForm G, int height_bound, ratvec t) = void:
   prints("Computing trace of exp(2i\pi",t
         ,") on representations up to height ", height_bound,new_line);
   let M=ratvecs_as_ratmat(fundamental_weights(G)) in
   for mu in box(height_bound,ss_rank(G))
   do let lambda=M*mu in
      if lambda.is_integer then wcf_report(G, lambda.ratvec_as_vec, t) fi
   od
