{some isomorphisms of Weyl groups not neceessarily coming from root systems
 for example W(rd)\simeq W(dual(rd))
}
<character_tables.at

{v=e_j for some j}
set index_standard_basis(vec v)=int:
let j=first(for i:#v do !=v[i] od) in assert(e(#v,j)=v);j

set no_F_factor(RootDatum rd)=bool:
all(for f in rd.simple_factors do let (letter,)=simple_type(f.derived) in letter != "F" od)

{M=permutation matrix ->
permutation of [0,1,...,n-1] defined by a
M*e(n,j)=e(n,M*j)
atlas> M
Value:
| 0, 1, 0 |
| 0, 0, 1 |
| 1, 0, 0 |
atlas> M*e(3,0)=e(3,2)
Value: true
atlas> M*0=2
Value: true
atlas> all(for i:3 do M*e(3,i)=e(3,M*i) od)
Value: true
}
set *(mat M,int i)=index_standard_basis(M[i])

{set *(mat M,WeylElt w)=WeylElt: W_elt(w.root_datum,for i in w.word do M*i od)}

{given permutation isomorphism, replace w in rd.W with w_new in rd_new.W
 if rd_new isn't given take rd_new=rd, M is a permutation automorphism of rd}
set permute(mat M,WeylElt w,RootDatum rd_new)=WeylElt: W_elt(rd_new,for i in w.word do M*i od)
set permute(mat M,WeylElt w)=WeylElt:permute(M,w,w.root_datum)

{
set permute(mat M,[WeylElt] classes,RootDatum rd_new)=[WeylElt]:
for w in classes do classes[first(for y in classes do is_conjugate(permute(M,w,rd_new),y) od)] od

set permute(mat M,[WeylElt] classes)=[WeylElt]:
if #classes=0 then [] else permute(M,classes,classes[0].root_datum) fi
}

{M takes W_1 to W_2, given classes_1, classes_2, find the induced permutation
on classes. This requires a lookup since M takes w\in W_1 to w'\in W_2, but
not necessarily a conjugacy classes representative in W_2}
set induced_permutation_on_classes(mat M,[WeylElt] classes,[WeylElt] classes_new)=[int]:
for w in classes do
 first(for y in classes_new do is_conjugate(permute(M,w,classes_new[0].root_datum),y) od)
od
set induced_permutation_on_classes(mat M,[WeylElt] classes)=[int]:
induced_permutation_on_classes(M,classes,classes)

{given M relating classes and classes_new, convert character for W_1 to W_2}
set permute_character(mat M,[WeylElt] classes,[WeylElt] classes_new,[int] char)=[int]:
let ind=induced_permutation_on_classes(M,classes,classes_new) in
 for i:#char do char[ind[i]] od
set permute_character(mat M,[WeylElt] classes,[int] char)=[int]:
permute_character(M,classes,classes,char)

set permute_character(mat M,CharacterTable ct,[int] char)=[int]:
permute_character(M,ct.class_representatives,char)

{
set permute_character(mat M,CharacterTable ct,[WeylElt] classes_new,[int] char)=[int]:
permute_character(M,ct.class_representatives,classes_new,char)
}
set exchange_long_short(CharacterTable ct,[int] char)=[int]:
if no_F_factor(ct.root_datum) then char else
 let rd=ct.root_datum then
 M=root_permutations(rd,dual(rd))[0] in
 if M=id_mat(#M)
  then char
 else
  permute_character(M,ct,char)
 fi
fi

set exchange_long_short_index(CharacterTable ct,int index)=int:
ct.character_index(exchange_long_short(ct,ct.characters[index]))


