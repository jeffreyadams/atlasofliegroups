<basic.at
<combinatorics.at { for types |Partition|, |Signed_cycles|, and many functions }
<W_characters.at
<simple_factors.at

{conjugacy classes and representations of classical Weyl groups
this file consists mainly of some union types to
aggregate A/BC/D constructions into a uniform type
see character_tables.at
springer_tables.at
see character_table_*.at (A,B,C,D,E,F,G)
springer_table_*.at (A,BC,D,E,F,G)
}

{ test |rd| for being of simple type T (a letter in "ABCDEFG"), and return (as
  a list of integers) a map from standard diagam labelling to |rd| simple roots
}
set test_simple_type(string T, RootDatum rd) = [int]:
(  let  (lt,map)=Cartan_matrix_type(rd.Cartan_matrix)
   then factors=simple_factors(lt) then nf=#factors
in assert(nf=1,"Root datum diagram is not connected ("+ nf +" components)")
;  let (type,rank)=factors[0]
in assert(type=T,"Not a simple type "+T+" root datum")
;  map
)

set_type A_class = Partition { parametrise W conjugacy classes in type A }
set_type A_irrep = Partition

{ for types B and C, there is the type |Signed_cycles| from combinatorics.at
  Here we group cycles with |true| negative sign), then cycles with |false|
  (positive sign), each decreasingly sorted, to a order pair of |Paritition|s }
set_type BC_class = Signed_cycles
set_type BC_irrep = (Partition,Partition)

set_type
[ D_class = { cycle types restricted to Dn subgroup }
   ( Signed_cycles unsplit_class { the product of all signs is positive }
   | (Partition,bool) split_class { "all false" even cycles, and a single sign }
   )
,  D_irrep = { from folding pairs of partitions under swapping }
   ( (Partition,Partition) unsplit_irr { unequal partitions, larger first }
   | (Partition,bool) split_irr { for pair of equal partitions, with sign }
   )
]

{ A type that allows grouping any of the above or none into a single value }
set_type
[ classical_class =
    ( A_class class_A
    | BC_class class_BC
    | D_class  class_D
    | void null_class { for an exceptional group }
    )
, classical_irrep =
    ( A_irrep irrep_A
    | BC_irrep irrep_BC
    | D_irrep irrep_D
    | void null_irrep{for an exceptional group}
    )
]

{ functions to extract form the union; for user convenience only, for
  programming purpusos always use discrimination clauses (case..esac as below) }

set split_class (D_class c) = (Partition,bool):
   case c | split_class(pair): pair | else error("class is not split") esac

set unsplit_class(D_class c) = Signed_cycles:
   case c | unsplit_class(pair): pair | else error("class is split") esac



set get_class_A(classical_class cl) = A_class:
case cl
| class_A(P): P
| class_BC(x): error("wrong type")
| class_D(x):  error("wrong type")
| else 	       []
esac

set get_class_BC(classical_class cl) = BC_class:
case cl
| class_A(x):   error("wrong type")
| class_BC(PQ): PQ
| class_D(x):   error("wrong type")
| else          []
esac

set get_class_D(classical_class cl) = D_class:
case cl
| class_D(val): val
| else          error("wrong type")
esac

{-------------------------------------------------------------------}


set get_irrep_A(classical_irrep rep) = [int]:
   case rep | P.irrep_A: P | else error("wrong type") esac

set get_irrep_BC(classical_irrep rep) = ([int],[int]):
   case rep | PQ.irrep_BC: PQ | else error("wrong type") esac

set get_irrep_D(classical_irrep rep) = D_irrep:
   case rep | val.irrep_D: val | else error("wrong type") esac


{			string representations				}

set parts_string (Partition lambda) = string: lambda.to_string[1:1~]
set cycles_string = ([int]->string): to_string@[int]
set irrep_string ([int] cycles) = string:
   (  "{", cycles.parts_string ,  "}" ).to_string

set sign_string (bool s) = string: if s then "-" else "+" fi
set parts_string (Partition lambda) = string: { partition without brackets }
  lambda.to_string[1:1~]
{ |cycles@(Partition,Partition)| tacks booleans one cycle lengths, the do this: }
set cycles_string ([int,bool] cycles) = string:
(  "["
,  for (l,s)@pos in cycles
   do if =pos then l.to_string##s.sign_string
      else "," ##  l.to_string##s.sign_string
      fi
   od.##
,  "]"
).to_string

set irrep_string(BiPartition(lambda,mu)) = string:
   ("{", lambda.parts_string, "+|-", mu.parts_string, "}").to_string

set cycles_string (D_class c) = string:
    case c
    | cycles.unsplit_class: cycles.cycles_string
    | (alpha,s).split_class: (alpha,sign_string(s)).to_string
    esac
set irrep_string(D_irrep chi) = string:
  case chi
  | (mu,lambda).unsplit_irr: { here we keep the stored order of partitions }
    ("{",mu.parts_string,"|",lambda.parts_string,"}").to_string
  | (mu,s).split_irr:
    ("{",mu.parts_string,"|",mu.parts_string,"}",s.sign_string).to_string
  esac


{			some cases special to type D:			}

{ recover the value of |n| }
set rank (D_class c) = int:
   case c
   | cycles.unsplit_class: cycles.rank { rank@Signed_cycles; combinatorics.at }
   | (lambda,).split_class: lambda.sum { |lambda| has all cycles (even,false) }
   esac

set rank (D_irrep chi) = int:
   case chi
   | pair.unsplit_irr: pair.rank { rank@(Partition,Partition); combinatorics.at }
   | (lambda,).split_irr: 2*lambda.sum { |lambda| stands for (lambda,lambda) }
   esac

{ rather than |signed_cycle_type_code|, $D_n$ classes need a finer analysis }
set to_D_class ([int] sigma) { as from |classic_permutation } = D_class:
   let cycles = for a in sigma do abs(a)-1 od.permutation_cycles
   then cycle_signs = for cyc in cycles do for i in cyc do <sigma[i] od.XOR od
   then type_code =
       for cyc@i in cycles do #cyc*sign(cycle_signs[i]) od.reverse_sort
   , neg_count = count(cycle_signs) { number of cycles with odd flip count }
in if neg_count.is_odd then error("Permutation is not in type D subgroup")
   elif not(neg_count.= and type_code.is_very_even)
   then type_code.as_signed_cycles.unsplit_class
   else { we have a split cycle, count parities of flip positions for sign }
      let parity =
	 for cyc in cycles
	 do for i@pos in cyc do <sigma[i] and pos.is_odd od.XOR
	 od.XOR
   in (type_code,parity).split_class
   fi

set = = (D_class,D_class->bool):
   let code(Signed_cycles c) = vec: for (l,flip) in c do l*sign(flip) od
in (D_class c0,D_class c1) bool:
  case c0
  | cyc0.unsplit_class:
    case c1 | cyc1.unsplit_class: code(cyc0)=code(cyc1) | else false esac
  | (lambda,eps0).split_class:
    case c1 | (mu,eps1).split_class: lambda=mu and eps0=eps1 | else false esac
  esac
set != (D_class c0,D_class c1) = bool: not(c0=c1)

set cycle_type_order (D_class c) = int:
   case c
   | cycles.unsplit_class: cycles.cycle_type_order { as in types B, C }
   | (lambda,).split_class: lambda.cycle_type_order { as in type A }
   esac
set cycle_centralizer_order (D_class c) = int:
   case c
   | cycles.unsplit_class: { unsplit means half of BC centralizer is not in Dn }
       cycles.cycle_centralizer_order\2
   | (alpha,).split_class: { split means full BC centralizer is in Dn subgroup }
       { simulate |cycle_centralizer_order@Signed_cycles|, using ..@Partition }
       alpha.cycle_centralizer_order*2^#alpha { add a factor 2 for each cycle }
   esac
set cycle_class_size (D_class c) = int:
  let n=rank(c) in n.fac * 2^(n-1) \ cycle_centralizer_order(c)

{ compute cycle type of power of a signed permutation, given its cycle type }
set cycle_power (D_class c, int k) = D_class:
   case c
   | cycles.unsplit_class: cycle_power(cycles,k).unsplit_class
   | (alpha,sign).split_class: let beta=cycle_power(alpha,k) in
     if beta.is_very_even { whether class remains split (may fail for even |k|) }
     then (beta,sign).split_class { keep sign when class remains split }
     { an easy way to see that this is right: certainly when |sign=false|, the
       power gets no sign, but since an outer automorphisme interchanges the
       halves of every split class, |sign=true| should give the opposite half }
     else for part in beta do (part,false) od.unsplit_class
     fi
   esac

set centralizer_order (D_class c) = int:
   case c
   | cycles.unsplit_class: { unsplit means half of BC centralizer is not in Dn }
       cycles.cycle_centralizer_order\2
   | (alpha,).split_class: { split means full BC centralizer is in Dn subgroup }
       { simulate |cycle_centralizer_order@Signed_cycles|, using ..@Partition }
       alpha.cycle_centralizer_order*2^#alpha { add a factor 2 for each cycle }
   esac

set class_size (D_class c) = int:
  let n=rank(c) in n.fac * 2^(n-1) \ centralizer_order(c)

set D_irreducibles (int n) = [D_irrep]:
 ##for (lambda,):pair in partition_pairs(n)
   do if leq_partitions(pair) then [] else [pair.unsplit_irr] fi
   od ##
  (let (s,r)=n\%2 in
   if =r else []
   then
    ##for lambda in partitions(s)
      do [(lambda,false).split_irr,(lambda,true).split_irr]
      od
   fi
  )

set D_classes (int n) = [D_class]:
   for (lambda,mu):pair in partition_pairs(n)
   do if (#mu).is_odd then [] { must have even number of cycles in |mu| }
      elif not(=mu and lambda.is_very_even) { whether unsplit }
      then [pair.to_cycles.unsplit_class]
      else [ (lambda,false).split_class, (lambda,true).split_class ]
      fi
   od.##

set character (D_irrep chi, D_class c) = int:
   assert(chi.rank = c.rank,"Size mismatch");
   let pos_cycles(Partition mu)=Signed_cycles: for l in mu do (l,false) od in
   case chi
   | pair.unsplit_irr:
     case c
     | cycles.unsplit_class: hyperoctahedral_character(pair,cycles)
     | (alpha,).split_class: { both halves behave as their BC class }
        hyperoctahedral_character(pair,pos_cycles(alpha))
     esac
   | (lambda,epsilon).split_irr:
     case c
     | cycles.unsplit_class:
       let (q,r) = hyperoctahedral_character((lambda,lambda),cycles)\%2 in
       assert(=r,"Odd character value at unsplit class"); q
     | (alpha,delta).split_class:
       let Hn_char = int:
           hyperoctahedral_character((lambda,lambda),pos_cycles(alpha))
       ,   Sn_char = int:
           assert(alpha.is_very_even,"Split class with odd cycle(s)");
           Murnaghan_Nakayama(lambda, alpha\2)
       then (q,r) = (Hn_char+sign(epsilon!=delta)*2^#alpha*Sn_char)\%2
       in assert(=r,"Parity problem for split-split character value"); q
     esac
   esac

set is_split(D_class c) = bool:
   case c | (,).split_class: true | else false esac

set split_and_unsplit_classes([D_class] list) =
      (([Partition,bool],[int]),([Signed_cycles],[int])):
let split=[Partition,bool]:[], map_split=[int]:[]
,   unsplit=[Signed_cycles]:[], map_unsplit=[int]:[]
in for x@i in list
   do case x
      | split_class(s):    split  #:= s;  map_split#:=i
      | unsplit_class(us): unsplit #:=us; map_unsplit#:=i
      esac
   od; ((split,map_split),(unsplit,map_unsplit))

set is_split(D_irrep pi) = bool:
   case pi | (,).split_irr: true | else false esac

set split_irrep (D_irrep pi) = (Partition,bool):
   case pi | pair.split_irr: pair | else error("rep is unsplit") esac

set unsplit_irrep (D_irrep pi) = (Partition,Partition):
   case pi | pair.unsplit_irr: pair | else error("rep is split") esac

{ curried version could be more efficient here }
set index_D_classes([D_class] L) = (D_class->int):
   let ((split,map_split),(unsplit,map_unsplit)) = split_and_unsplit_classes(L)
in (D_class class) int:
   case class
   | split_class(P,boolean):
       let ix=first(#split,(int i)bool: let (a,b)=split[i] in a=P and b=boolean)
       in map_split[ix]
   | unsplit_class(cycles): index_signed_cycles(unsplit,map_unsplit)(cycles)
   esac

{ uncurried vesion used curried one (without efficieny gain) }
set index_D_classes([D_class] L, D_class c) = int: index_D_classes(L)(c)


set split_and_unsplit_reps([D_irrep] list) =
      (([Partition,bool],[int]), ([Partition,Partition],[int])):
let  split=[Partition,bool]:[], map_split=[int]:[]
,  unsplit=[Partition,Partition]:[], map_unsplit=[int]:[]
in for x@i in list
   do case x
      | split_irr(r):    split  #:= r;  map_split#:=i
      | unsplit_irr(ur): unsplit #:=ur; map_unsplit#:=i
      esac
   od; ((split,map_split),(unsplit,map_unsplit))

{ curried first }
set index_D_reps([D_irrep] L) = (D_irrep->int):
   let ((split,map_split),(unsplit,map_unsplit)) = split_and_unsplit_reps(L)
in (D_irrep rep) int:
   case rep
   | split_irr(P,boolean):
      let ix=first(#split,(int i)bool: let (a,b)=split[i] in a=P and b=boolean)
      in map_split[ix]
   | unsplit_irr(lambda,mu):
     let ix=first(#unsplit
                 ,(int i)bool: let (a,b)=unsplit[i] in a=lambda and b=mu
		 )
     in map_unsplit[ix]
   esac

set index_D_reps ([D_irrep] L,D_irrep rep) = int: index_D_reps(L)(rep)

set class_string(classical_class cl)=
  case cl
  | cl.class_A: cl.to_string
  | cl.class_BC: cl.to_string
  | cl.class_D: cl.cycles_string
  | else ""
  esac

set irrep_string(classical_irrep rep)=
  case rep
  | lambda.irrep_A: lambda.to_string
  | pair.irrep_BC: pair.to_string
  | r.irrep_D: r.irrep_string
  | else ""
  esac
