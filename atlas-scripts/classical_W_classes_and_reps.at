<basic.at
<combinatorics.at { for types |Partition|, |Signed_cycles|, and many functions }
<W_classes.at
<simple_factors.at

{conjugacy classes and representations of classical Weyl groups
this file consists mainly of some union types to
aggregate A/BC/D constructions into a uniform type
see character_tables.at
springer_tables.at
see character_table_*.at (A,B,C,D,E,F,G)
springer_table_*.at (A,BC,D,E,F,G)
}

set_type A_class = Partition { parametrise W conjugacy classes in type A }
set_type A_irrep = Partition

{ for types B and C, there is the type |Signed_cycles| from combinatorics.at
  Here we group cycles with |true| negative sign), then cycles with |false|
  (positive sign), each decreasingly sorted, to a order pair of |Paritition|s }
set_type BC_class = Signed_cycles
set_type BC_irrep = (Partition,Partition)

{ A type that allows grouping any of the above or none into a single value }
set_type
[ classical_class =
    ( A_class class_A
    | BC_class class_BC
    | D_class  class_D
    | void null_class { for an exceptional group }
    )
, classical_irrep =
    ( A_irrep irrep_A
    | BC_irrep irrep_BC
    | D_irrep irrep_D
    | void null_irrep{for an exceptional group}
    )
]

{ functions to extract form the union; for user convenience only, for
  programming purpusos always use discrimination clauses (case..esac as below) }

set split_class (D_class c) = (Partition,bool):
   case c | split_class(pair): pair | else error("class is not split") esac

set unsplit_class(D_class c) = Signed_cycles:
   case c | unsplit_class(pair): pair | else error("class is split") esac



set get_class_A(classical_class cl) = A_class:
case cl
| class_A(P): P
| class_BC(x): error("wrong type")
| class_D(x):  error("wrong type")
| else	       []
esac

set get_class_BC(classical_class cl) = BC_class:
case cl
| class_A(x):   error("wrong type")
| class_BC(PQ): PQ
| class_D(x):   error("wrong type")
| else          []
esac

set get_class_D(classical_class cl) = D_class:
case cl
| class_D(val): val
| else          error("wrong type")
esac

{-------------------------------------------------------------------}


set get_irrep_A(classical_irrep rep) = [int]:
   case rep | P.irrep_A: P | else error("wrong type") esac

set get_irrep_BC(classical_irrep rep) = ([int],[int]):
   case rep | PQ.irrep_BC: PQ | else error("wrong type") esac

set get_irrep_D(classical_irrep rep) = D_irrep:
   case rep | val.irrep_D: val | else error("wrong type") esac


{			string representations				}

set parts_string (Partition lambda) = string: lambda.to_string[1:1~]
set cycles_string = ([int]->string): to_string@[int]
set irrep_string ([int] cycles) = string:
   (  "{", cycles.parts_string ,  "}" ).to_string

set sign_string (bool s) = string: if s then "-" else "+" fi
set parts_string (Partition lambda) = string: { partition without brackets }
  lambda.to_string[1:1~]
{ |cycles@(Partition,Partition)| tacks booleans one cycle lengths, the do this: }
set cycles_string ([int,bool] cycles) = string:
(  "["
,  for (l,s)@pos in cycles
   do if =pos then l.to_string##s.sign_string
      else "," ##  l.to_string##s.sign_string
      fi
   od.##
,  "]"
).to_string

set irrep_string(BiPartition(lambda,mu)) = string:
   ("{ ", lambda.parts_string, " +|- ", mu.parts_string, " }").to_string

set cycles_string (D_class c) = string:
    case c
    | cycles.unsplit_class: cycles.cycles_string
    | (alpha,s).split_class: (alpha,sign_string(s)).to_string
    esac
set irrep_string(D_irrep chi) = string:
  case chi
  | (mu,lambda).unsplit_irr: { here we keep the stored order of partitions }
    ("{ ",mu.parts_string," | ",lambda.parts_string," }").to_string
  | (mu,s).split_irr:
    ("{ ",mu.parts_string," | ",mu.parts_string," }",s.sign_string).to_string
  esac


{			some cases special to type D:			}

set is_split(D_class c) = bool:
   case c | (,).split_class: true | else false esac

set split_and_unsplit_classes([D_class] list) =
      (([Partition,bool],[int]),([Signed_cycles],[int])):
let split=[Partition,bool]:[], map_split=[int]:[]
,   unsplit=[Signed_cycles]:[], map_unsplit=[int]:[]
in for x@i in list
   do case x
      | split_class(s):    split  #:= s;  map_split#:=i
      | unsplit_class(us): unsplit #:=us; map_unsplit#:=i
      esac
   od; ((split,map_split),(unsplit,map_unsplit))

set is_split(D_irrep pi) = bool:
   case pi | (,).split_irr: true | else false esac

set split_irrep (D_irrep pi) = (Partition,bool):
   case pi | pair.split_irr: pair | else error("rep is unsplit") esac

set unsplit_irrep (D_irrep pi) = (Partition,Partition):
   case pi | pair.unsplit_irr: pair | else error("rep is split") esac


set split_and_unsplit_reps([D_irrep] list) =
      (([Partition,bool],[int]), ([Partition,Partition],[int])):
let  split=[Partition,bool]:[], map_split=[int]:[]
,  unsplit=[Partition,Partition]:[], map_unsplit=[int]:[]
in for x@i in list
   do case x
      | split_irr(r):    split  #:= r;  map_split#:=i
      | unsplit_irr(ur): unsplit #:=ur; map_unsplit#:=i
      esac
   od; ((split,map_split),(unsplit,map_unsplit))

{ curried first }
set index_D_reps([D_irrep] L) = (D_irrep->int):
   let ((split,map_split),(unsplit,map_unsplit)) = split_and_unsplit_reps(L)
in (D_irrep rep) int:
   case rep
   | split_irr(P,boolean):
      let ix=first(#split,(int i)bool: let (a,b)=split[i] in a=P and b=boolean)
      in map_split[ix]
   | unsplit_irr(lambda,mu):
     let ix=first(#unsplit
                 ,(int i)bool: let (a,b)=unsplit[i] in a=lambda and b=mu
		 )
     in map_unsplit[ix]
   esac

set index_D_reps ([D_irrep] L,D_irrep rep) = int: index_D_reps(L)(rep)

set class_string(classical_class cl)=
  case cl
  | cl.class_A: cl.to_string
  | cl.class_BC: cl.to_string
  | cl.class_D: cl.cycles_string
  | else ""
  esac

set irrep_string(classical_irrep rep)=
  case rep
  | lambda.irrep_A: lambda.to_string
  | pair.irrep_BC: pair.to_string
  | r.irrep_D: r.irrep_string
  | else ""
  esac
