{this file concerns (local) facets of parameters, in preparation of analysis of their unitarity.}
<FPP_facets_geom.at
<goodroots.at { for is_pos_on_LKTs }
<Dirac.at
<hermitian.at
<K_highest_weights.at {for all_lambda_differential_0}
<unity.at {for deform_hts}
{BREAK HERE?}


{takes the known unitaries from unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, VertexData Lvd,
    [[FacetVertsKHash]] LFDKH) = [vec]:
    let ps = for d:#LFDKH
    	     do for v in LFDKH[d]
	     	do parameter(x,lambda,facet_bary(Lvd.list, v[:d+1]))
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
       	  do let qs = monomials(finalize(p))
	     in if all(for q in qs do @bool: Uhash.lookup(q).>= od)
	     	then [j]
		else []
		fi
	  od.##
       od
{    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
    	      	  	    	     	      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = Uhash.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
       	 do let p = Uhash.index(k)
       	    then list = local_vertices(p)
            in if p.x = x and p.lambda=lambda and #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
	     	    then m = lookups[#list-1](local_verts)
		    then () = assert(m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]:= (out[#list-1] next out[#list -1]:=[])#m
		    in ()
	       fi
	 od
     in out}

{Here UhashLocal is assumed to consist of Param's at (x,lambda)}
{this misses (in local_testK_level) unitary Param's that finalize to different x;
those are caught by local_testK_hash}
set known_unitaries(Param_hash UhashLocal, VertexData Lvd,
    [[FacetVertsKHash]] LFDKH) = [vec]:
    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
    	      	  	    	     	      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = UhashLocal.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
       	 do let p = UhashLocal.index(k)
       	    then list = local_vertices(p)
            in if #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
	     	    then m = lookups[#list-1](local_verts)
		    then () = assert(m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]:=(out[#list-1] next out[#list -1]:=[])#m {out[#list-1]#m}
		    in ()
	       fi
	 od
     in out

set localize(Param_hash Uhash, KGBElt x, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.x = x and p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc

set localize(Param_hash Uhash, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc
{collection of lookup functions for facets of various dimensions}
set lookups([[vec]] LFD) = [(vec->int)]:
    for L@d in LFD do index_in(for v in L do v[:d+1] od) od

{assume LFDKH has tail coords referring to K-char}
set sort(RealForm G, VertexData Lvd, [[FacetVertsKHash]] LFDKH, int tail) = [[FacetVertsKHash]]:
    if sort_LFD_flag
    then let tworhocheck = G.two_rho_check
    	 then f(vec v) = int:
    	      let (num,den) = %(sum(for j in v[:#v - tail] do Lvd.list[j]*tworhocheck od)*1000)
	      in num\den
    	 in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
    else LFDKH
    fi

{this is the Q(infinitesimal character) bound provided by Dirac inequality on all LKTs}
set DiracBD(KGBElt x, ratvec lambda) = rat:
    let G = x.real_form
    then Q = invariant_form(G)
    in if not(Dirac_flag and is_equal_rank(G))
       then Q(G.rho,G.rho)
       else let mus = LKTs(parameter(x,lambda,0*lambda))
       	    then ics = for mu in mus do DiracIC(mu) od
    	    in min(for ic in ics do Q(ic,ic) od)
       fi

{"true" means unitarity is possible in light of Dirac}
{avoid using is_hermitian defined in hermitian.at}
set DiracTest(Param p) = bool:
    let G=p.real_form
    then () = Dirac_flag:=true
    in if not is_equal_rank(G) then return equivalent(twist(p),p) {is_hermitian(p)}
       else let gamma = p.infinitesimal_character
    	    then Q = invariant_form(G)
	    then bound = DiracBD(p.x, p.lambda)
	    in Q(gamma, gamma) <= bound
       fi

{creates LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local verts}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.
parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}

set localFD_Lvd2 \
  (InnerClass ic, mat theta, ratvec lambda, VertexData vd, [(ratvec->int)] edge_lookups) =
  (VertexData, PermOrderTwo, vec):
(   let Perm2 = thetaAct2(ic, theta, lambda, vd, edge_lookups)
    then vlist = vd.list
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
{DANGER! this may not be an edge!}
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)
)

set localFD_Lvd2 \
  (InnerClass ic, mat theta, ratvec lambda, VertexData vd, [(ratvec->int)] edge_lookups) =
  (VertexData, PermOrderTwo, vec):
(   let Perm2 = thetaAct2(ic, theta, lambda, vd, edge_lookups)
    then vlist = vd.list
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
{DANGER! this may not be an edge!}
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)
)

set localFD_Lvd2 \
  ( KGBElt x, ratvec lambda, VertexData vd, [(ratvec->int)] edge_lookups) =
  localFD_Lvd2(x.inner_class, x.involution, lambda, vd, edge_lookups)

set localFD_Lvd2 \
  ( mat theta, ratvec lambda, VertexData vd, (vec->int) FlippedEdgeLookup) =
  (VertexData, PermOrderTwo, vec):
(   let start = elapsed_ms(), Perm2 = thetaAct2(theta, lambda, vd, FlippedEdgeLookup)
    then vlist = vd.list
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans
	 do if FlippedEdgeLookup([i,j]) >= 0
	    then [(vlist[i] + vlist[j])/2]
	    else []
	    fi
	 od.##
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)
)

set localFD_Lvd2 \
  (KGBElt x, ratvec lambda, VertexData vd, (vec->int) FlippedEdgeLookup) = (VertexData, PermOrderTwo, vec):
  localFD_Lvd2(x.involution, lambda, vd, FlippedEdgeLookup)

{takes local data and low global facets and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}

set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, VertexData Lvd, PermOrderTwo Perm2, vec mapAct{,
    [[FacetVertsIndex]] globalFacets}) = [[FacetVertsIndex]]:
(   {if facet_verbose
    then prints(new_line,"start localFD_1Dirac")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FacetVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
 	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let EdgesFixFix = [vec]:
    	     {if #LF0 = #globalFacets[0]
	     then for v in globalFacets[1]
	      	  do [mapAct[v[0]], mapAct[v[1]]].sort
	      	  od
	      else} if #Perm2.fixed > 1
 	      	   then for v in FPP_edges(G){globalFacets[1]}
	       	   	do if is_member_sorted(Perm2.fixed)(v[0]) and
		       	      is_member_sorted(Perm2.fixed)(v[1])
		      	   then let mloc = mapAct[v[0]], nloc = mapAct[v[1]]
		       	   in if Llookup(mloc) and Llookup(nloc)
			      then [[mloc,nloc].sort]
			      else []
			      fi
		     	   else []
		      	   fi
		   	 od.##
	       	    else []
	       	    fi
	       {fi}
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
      	   then EdgesFixTrans = [vec]:
	   	{if global_top >= 2 and #Perm2.trans > 0 and #Perm2.fixed > 0
	       	then for v in globalFacets[2]
	       	     do let mixes = [[v[0],v[1],v[2]],[v[1],v[0],v[2]],[v[2],v[0],v[1]]]
		       	in for w in mixes
		       	   do if is_member_sorted(Perm2.fixed)(w[0]) and
			     	trans_hash.lookup([w[1],w[2]]) >= 0
		       	     then let xloc = mapAct[w[0]], yloc = mapAct[w[1]]
		       	     	  in if Llookup(xloc) and Llookup(yloc)
			       	     then [[xloc,yloc].sort]
			       	     else []
			       	     fi
			      else []
			      fi
			  od.##
		     od.##
	       	 else []
	       	 fi}
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
	      	    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
           {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = ([vec]:
	       {if global_top >= 3 and #Perm2.trans > 1
	       then for v in globalFacets[3]
	       	    do let mixes = [[v[0],v[1],v[2],v[3]], [v[0],v[2],v[1],v[3]],
		       	   	   [v[0],v[3],v[1],v[2]]]
		       in for w in mixes
		       	  do if trans_hash.lookup([w[0],w[1]]) >= 0 and
			     	trans_hash.lookup([w[2],w[3]]) >= 0 
		       	     then let xloc = mapAct[w[0]], zloc = mapAct[w[2]]
		       	     	  in if Llookup(xloc) and Llookup(zloc)
			       	     then [[xloc,zloc].sort]
			       	     else []
			       	     fi
			     else []
			     fi
			  od.##
		     od.##
	       else []
	       fi}
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
	      	    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
	          fi
	       od.##)
	  {then () = prints("after TransTrans, time is ",print_time_string(elapsed_ms() - start))}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     { then () = prints("after Edges, time is ",print_time_string(elapsed_ms() - start))}
     then LF1 = [FacetVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,facet_bary(Lvd.list, v))
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    in {if(facet_verbose) then prints("After localFD_1Dirac2, facet counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2") fi;}
       answer
)



{takes local data and low global facets and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
{This time assume that globalFacets[d] is list of size
#globalFacets[d-1] of d-facets, the jth list being all global facets that
begin with the jth global (d-1)-facet.}
set localFD_1Dirac2_by_zero\
  ( KGBElt x, ratvec lambda, VertexData Lvd, PermOrderTwo Perm2, vec mapAct{,
    [[[FacetVertsIndex]]] globalFacetsBYZERO}) = [[FacetVertsIndex]]:
(   {if facet_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FacetVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
 	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##{list of j for which vertex j is a candidate}
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let EdgesFixFix = [vec]:
             if #Perm2.fixed > 1
	     then for j in Perm2.fixed
	     	  do let mloc = mapAct[j]
		     in if Llookup(mloc)
		     	then for v in FPP_edges_by_zero(G)[j] {global edges with v[0] = j}
			     do if is_member_sorted(Perm2.fixed)(v[1])
			     	then let nloc =  mapAct[v[1]]
				     in if nloc > mloc and Llookup(nloc)
				     	then [[mloc,nloc]]
             				else []
					fi
				else []
				fi
			     od.## {this is the list of edges starting with j}
	     		 else []
			 fi
		   od.## {all FixFix edges}
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
      	   then EdgesFixTrans = [vec]:
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
	      	    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
{
	   	if global_top >= 2 and #Perm2.trans > 0 and #Perm2.fixed > 0
	       	then let GF2 = globalFacetsBYZERO[2].##
		     in  for v in GF2
	       	     	 do let mixes = [[v[0],v[1],v[2]],[v[1],v[0],v[2]],[v[2],v[0],v[1]]]
		       	    in for w in mixes
		       	       do if is_member_sorted(Perm2.fixed)(w[0]) and
			     	     	trans_hash.lookup([w[1],w[2]]) >= 0
		       	     	  then let xloc = mapAct[w[0]], yloc = mapAct[w[1]]
		       	     	        in if Llookup(xloc) and Llookup(yloc)
			       	     	   then [[xloc,yloc].sort]
			       	     	   else []
			       	     	   fi
			      	   else []
			      	   fi
			        od.##
		     	  od.##
	       	 else []
	       	 fi
           {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}}
	   then EdgesTransTrans = [vec]:
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
	      	    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
	          fi
	       od.##
{
	       if global_top >= 3 and #Perm2.trans > 1
	       then let GF3 = globalFacetsBYZERO[3].##
	       	    in for v in GF3
	       	    do let mixes = [[v[0],v[1],v[2],v[3]], [v[0],v[2],v[1],v[3]],
		       	   	   [v[0],v[3],v[1],v[2]]]
		       in for w in mixes
		       	  do if trans_hash.lookup([w[0],w[1]]) >= 0 and
			     	trans_hash.lookup([w[2],w[3]]) >= 0 
		       	     then let xloc = mapAct[w[0]], zloc = mapAct[w[2]]
		       	     	  in if Llookup(xloc) and Llookup(zloc)
			       	     then [[xloc,zloc].sort]
			       	     else []
			       	     fi
			     else []
			     fi
			  od.##
		     od.##
	       else []
	       fi}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FacetVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,facet_bary(Lvd.list, v))
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    in {if(facet_verbose) then prints("After localFD_1Dirac2, facet counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2") fi;}
       answer
)

{takes 0 and 1-diml local facets and adds K-char index}
set localFD_KHash_01 (KGBElt x, ratvec lambda, VertexData Lvd, KTypePol_hash ktp_hash,
[[FacetVertsIndex]] LF) = [[FacetVertsKHash]]:
    let start = elapsed_ms()
    then answer = for d:#LF
    	 do if fund_facet_verbose then prints(new_line, "start to compute ",#LF[d],
       	  		     " K-characters in dimension ",d,
			     " in localFD_KHash_01")
       	     fi;
	     for v@k in LF[d]
       	     do if k%(max(#LF[d]\10,2))=0 and fund_facet_verbose
	      	then prints("examining facet ",k,
	      	   "; #ktp_hash = ",ktp_hash.size())
	      	fi;
		let nu = facet_bary(Lvd.list, v)
       	      	then p0 = parameter(x, lambda, nu)
	      	then P = finalize(p0)
	      	then Q = K_type_pol(character_formula(P))
	      	in v##[ktp_hash.match(Q), #monomials(P)]
       	     od
    	od
   {then () = answer:= sort(x.real_form, Lvd, answer, 2)} {ARGUMENT ALREADY SORTED}
   then time = elapsed_ms() - start
   then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01") fi
   in answer

{takes 0 and 1-diml local facets and adds K-char index to height HT}
set localFD_KHash_01 (KGBElt x, ratvec lambda, VertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FacetVertsIndex]] LF) = [[FacetVertsKHash]]:
    let start = elapsed_ms()
    then answer = for d:#LF
    	 do if fund_facet_verbose then prints(new_line, "start to compute ",#LF[d],
       	  		     " K-characters to height ",HT, " in dimension ",d,
			     " in localFD_KHash_01")
       	    fi; for v@k in LF[d]
       	   do if k%(max(#LF[d]\10,2))=0 and fund_facet_verbose
	      then prints("examining facet ",k,
	      	   "; #ktp_hash = ",ktp_hash.size())
	      fi;
	      let nu = facet_bary(Lvd.list, v)
       	      then p0 = parameter(x, lambda, nu)
	      then P = finalize(p0)
	      then Q = K_type_pol(character_formula_to_height(P,HT))
	      in v##[ktp_hash.match(Q), #monomials(P)]
       	    od
    	  od
   {then () = answer:= sort(x.real_form, Lvd, answer, 2)} {argument already sorted}
   then time = elapsed_ms() - start
   then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01 to height ", HT) fi
   in answer

{takes list of 0- and d-diml facets, with d \ge 1, and builds all
d+1-diml facets having all faces in the d-diml list. The int e is the
number of extra coords in each facet.}
set superFacets([vec] L0, [vec] Ld, int e) =
    [vec]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [vec]:
   for v in L0
   do let m0 = v[0] {first vertex in new facet}
      in [vec]:
      	 for small in Ld
      	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    elif any(for k:d+1 do lookupsd( m0#(small[:k]##small[k+1:d+1])) = -1 od)
	    then [] {require all d-faces to be in Ld}
	    else [m0#small[:d+1]] {now m0##small is a candidate facet}
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFacets was ",
		      	print_time_string(elapsed_ms() - start))
          fi}
in answer
fi

{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary facets and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, VertexData Lvd, [[FacetVertsKHash]] LFKH,
    int b, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   {if facet_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;}
    let G = x.real_form, start=elapsed_ms()
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFacets(LFKH[0],LFKH[dim-1],2)
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then [actual##[ktp_hash.match(
				              K_type_pol(character_formula(P))), #ms]]
		       		    	 else []
				    	 fi
		    	      	   od.## {[FacetVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, 2)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt to dim ",t-1) fi
    in if(facet_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, facet counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)


{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t). This time
just calculate K characters to HT

Need to assume b \ge 2, so have a list of potentially unitary facets and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, VertexData Lvd, [[FacetVertsKHash]] LFKH,
    int b, int t, int HT, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;
    let G = x.real_form, start=elapsed_ms()
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFacets(LFKH[0],LFKH[dim-1],2)
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then [actual##[ktp_hash.match(
				              K_type_pol(character_formula_to_height(P, HT))), #ms]]
		       		    	 else []
				    	 fi
		    	      	   od.## {[FacetVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, 2)
    {then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	       " for localFD_Khashbt to height ", HT, " and dim ",t-1) fi}
    in if(facet_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, facet counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)

set extend_K_characters(KGBElt x, ratvec lambda, VertexData Lvd,
    [[FacetVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
    {if facet_verbose
    then prints(new_line,"start extend_K_characters")
    fi;}
    let G = x.real_form, start = elapsed_ms()
    then answer =
       for d:#LFKH
       do if fund_facet_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_facet_verbose
	      	 then prints("examining facet ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = facet_bary(Lvd.list, v[:d+1]), w=v
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
	  	 then Q = K_type_pol(character_formula(P))
	  	 then () = w[d+1] := ktp_hash.match(Q)
		 in w
              od
      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters") fi
     in answer

set extend_K_characters(KGBElt x, ratvec lambda, VertexData Lvd,
    [[FacetVertsKHash]] LFKH, int ht, KTypePol_hash ktp_hash) =
    	[[FacetVertsKHash]]:
    if facet_verbose
    then prints(new_line,"start extend_K_characters to height ",ht)
    fi;
    let G = x.real_form, start = elapsed_ms()
    then answer =
       for d:#LFKH
       do if fund_facet_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_facet_verbose
	      	 then prints("examining facet ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = facet_bary(Lvd.list, v[:d+1]), w=v
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
	  	 then Q = K_type_pol(character_formula_to_height(P,ht))
	  	 then () = w[d+1] := ktp_hash.match(Q)
		 in w
              od
       od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters to ht ", ht) fi
     in answer

{set all_lambda_differential_0(mat theta) = [vec]:
    let BLD0 = basis_lambda_differential_0(theta)
    in for v in all_0_1_vecs(n_columns(BLD0))
       do BLD0*v
       od}

set cands(InnerClass ic, mat theta, [ratvec] verts) = [vec]:
    let th1 = 1+theta
    in for v in verts
       do let w = th1*v
       	  in if w.denom = 1
	     then [w.numer]
             else []
             fi
       od.##.no_reps

{computes a set of integral vecs INCLUDING all of those in (1+theta)*FPP}
set candsBIG(InnerClass ic, mat theta) = [vec]:
    let th1 = 1+theta, {tester = [vec]: (1-theta).^} thmin = 1-theta
    then th1xis = th1*ic.fundamental_weights
    then mins = vec:
    	      	for j:ic.rank
    	        do floor(sum(for th1xi in th1xis do min(0,th1xi[j]) od))
		od
    then maxs = vec:
    	      	for j:ic.rank
    	        do ceil(sum(for th1xi in th1xis do max(0,th1xi[j]) od))+1
		od
    {jth coord of vector in th1*FPP is between mins[j] and maxs[j]}
    then B = mat:for b in box(maxs-mins) do b+mins od
    {number of rows = ic.rank}
    in for answer in columns(B)
       do if (thmin*(answer.numer)).=
       	  then [answer]
	  else []
	  fi
       od.##

{a point in FPP has wfundamental[j] coord in the range [min[j], max[j]]}
set candsNEW(InnerClass ic, mat theta) = [vec]:
    let {y = theta,} two_rho = ic.two_rho, w = id_mat(ic.rank)
    then x = KGB_elt(KGBElt_gen:(ic, theta, null(ic.rank)))
    then G = x.real_form
    then y = KGB(G, first(for z in KGB(G) do z.Cartan_class = x.Cartan_class od))
    then theta0 = y.involution
    then w = cross_divide(x,y)
    {then () = prints(matrix(w)*theta0*matrix(w.inverse))}
    then simple = [vec]: ic.simple_coroots, fundamental = ratmat:
    	 if ic.semisimple_rank > 0
	 then ratvecs_as_ratmat(ic.fundamental_weights)
	 else null(ic.rank,0)/1
	 fi
{    then down = for av@j in simple
    	      	do if (av*y)*two_rho < 0 and
		      not (av + av*y).=
		   then [j]
		   else []
		   fi
		od.##
    then () = while #down > 0
    	      do let refl = reflection(ic,down[0])
	      	 then () = y:= refl*y*refl
		 then () = w:=w*refl {conjugates y back to theta}
	      	 in down:= for av@j in simple
    	      	      	      	  do if (av*y)*two_rho < 0 and
		      		     	not (av + av*y).=
		   	      	     then [j]
		   		     else []
		   		     fi
			      	  od.##
	       od
    {then () = prints(w)}
    {y = w.inverse * theta * w is the long Weyl elt of a split equal rank Levi.}
    }
    then Snonreal = for av@j in simple
    	       	    do if ((theta0.^)*av + av).=
		       then []
		       else [j]
		       fi
		    od.##
    then Sreal = for av@j in simple
    	       	 do if ((theta0.^)*av + av).=
		    then [j]
		    else []
		    fi
		 od.##
    then theta01 = theta0 + 1, wsimple = [vec]: for av in simple do av*(w.inverse) od, wfundamental = matrix(w)*fundamental
    then allmaxs = [int]:
    	 for k:ic.semisimple_rank
    	 do let wak = wsimple[k]
	    in max( (wak*two_rho)\2,0)
	 od
    then allmins = [int]:
    	 for k:ic.semisimple_rank
    	 do let wak = wsimple[k]
	    in min( (wak*two_rho)\2,0)
	 od
    then nrmaxs = [int]:
    	 for k in Snonreal
 	 do 2*allmaxs[k] +
	    sum(for j in Sreal
	        do allmaxs[j]*((theta01*ic.fundamental_weights[j])*simple[k]).numer
		od) + 1
	 od
    then nrmins = [int]:
    	 for k in Snonreal
	 do 2*allmins[k] +
	    sum(for j in Sreal
	        do allmins[j]*((theta01*ic.fundamental_weights[j])*simple[k]).numer
		od)
	 od
    then wfundnonreal = ratmat:
	 if #Snonreal > 0
	 then ratvecs_as_ratmat(
	      for j in Snonreal
	      do w*ic.fundamental_weights[j] 
	      od)
	  else null(ic.rank,0)/1
	  fi
    {then () = prints("nrmins = ",nrmins,", nrmaxs = ",nrmaxs,", wsimple = ", wsimple,", wfundnonreal cols = ",for c in columns(wfundnonreal) do c od)}
    {then () = assert(ratmat_as_mat((1-theta)*wfundnonreal).=, "oops, don't have eigenfunctions")}
    then B = mat:for b in box(nrmaxs-nrmins) do b+nrmins od
    {number of rows = size of Snonreal. Each column is a potential combination of wfundnonreal columns in th1*FPP}
    in for v in columns (wfundnonreal*B)
       do if v.denom = 1  {assume rho in X*; otherwise v-rho}
	  then [v.numer]
	  else []
	  fi
        od.##{.no_reps}  {automatically no reps}

set_type Lvd_Perm2_mapAct = (VertexData Lvd, PermOrderTwo Perm2, vec mapAct)

{Record for each inner class a list of some involutions in inner class; and for each such involution,
 some possible lambdas; and for each such lambda, a list of (local vertex data, Perm2, mapAct)}
set_type
[Lvd_Perm2_mapAct_table =

( (->int) inner_class_size {number of inner classes included}
  , ( -> vec) ic_vlist_size {for each inner class, the number of FPP-vertices}
  , ( -> ) clear
  , ( -> vec) involution_size {for each inner class, number of involutions so far considered}
  , ( -> [vec]) lamthlam_size {for each inner class and involution, number of d_lambdas (actually lambda+theta*lambda)
      	 		       so far considered}
  , ( -> [[vec]]) Lvd_list_size {for each inner class and involution and d_lambda, size of Lvd.list}
  , (InnerClass -> VertexData) FPP_vertex_data {one for each inner class}
  , (InnerClass -> (vec -> int)) flippable_edge_lookup
  {, (InnerClass -> [FacetVertsIndex]) FPP_flip_tet}
  , (InnerClass -> [ratvec]) FPP_local_vertices {one for each inner class}
  , ((InnerClass, mat) -> [vec]) lamthlams {for each involution, list of allowed lambda+theta_lambda}
  , ((InnerClass, mat, vec) -> int) lamthlam_number {for each involution, number of lambda+theta_lambda in list}
  , ((InnerClass, mat) -> [ratvec]) lambda0s {for each involution, list of allowed lambda mod twists}
  , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2_mapAct)]) LPm_entries {allowed lambda mod twists, corr entry}
    		       	  	    {like output of old FPP_lambdas_big_new}
  , ((InnerClass, mat, vec) -> VertexData) Lvd {local vertex data, one for each theta and lambda+theta*lambda}
  , ((InnerClass, mat, vec) -> Lvd_Perm2_mapAct) LPm_entry {one for each theta and lambda+theta*lambda}
{  , ((InnerClass, mat, vec) -> ) append {just compute, don't report LPm entry}}
  , (int -> InnerClass) inner_class_index
  , (int -> VertexData) vd_index {vertex data for inner class}
  , ((int,int,int) -> Lvd_Perm2_mapAct) Lvd_Perm2_mapAct_index {one for each inner class, involution,
    		      					       lambda + theta*lambda}
)
]
set old_flag = true {use old cands function}
set big_flag = false {use candsBIG}
set new_flag = false {use candsNEW}

set make_Lvd_Perm2_mapAct_table() = Lvd_Perm2_mapAct_table:
(   let inner_class_hash = make_InnerClass_hash()
    then inv_hashes = [mat_hash]: [] {one for each inner class}
    then vertex_datas = [VertexData]: [] {one for each inner class}
    then FELs = [(vec->int)]: [] {one for each inner class}
    {then ELLs = [[(ratvec->int)]]: [] {one for each inner class}}
    {then Ffts = [[FacetVertsIndex]]:[] {one for each inner class}}
    then FPP_local_verts = [[ratvec]]: [] {one list for each inner class}
    then cands = [[[vec]]]: [] {one [vec] for each inner class and involution}
    then lamthlam_hashess = [[vec_hash]]: [] {one for each inner class and involution}
    	 {entries are vecs of size ic.rank: lamba+theta*lambda, for a
	 	  certain choice of lambda (defined up to twist and equivalence}
    then entries = [[[Lvd_Perm2_mapAct]]]: [] {one list for each involution and lamthlam}
    then clear() = void:
    	 let () = inner_class_hash.clear()
	 then () = inv_hashes := []
	 then () = vertex_datas := []
	 then () = FELs := []
	 {then () = ELLs := []}
	 {then () = Ffts := []}
	 then () = FPP_local_verts := []
	 then () = cands := []
	 then () = lamthlam_hashess := []
	 then () = entries := []
	 in ()
    then add_inner_class(InnerClass ic) = int:
    	 let I = inner_class_hash.size()
	 then i = inner_class_hash.match(ic)
    	 then () = if i = I {haven't seen this inner class before}
	      	   then inv_hashes := (inv_hashes next inv_hashes:=[])#make_mat_hash();
	    	   	vertex_datas := (vertex_datas next vertex_datas := [])#FPP_vertex_data(ic);
			FELs := (FELs next FELs:=[])# FPP_flippable_edge_lookup(ic);
			{ELLs := (ELLs next ELLs:=[])# edge_list_lookups(ic);}
			{Ffts := (Ffts next Ffts:=[])#FPP_flippable_tetrahedra(ic);}
	    	   	FPP_local_verts := (FPP_local_verts next FPP_local_verts:=[])
		     	#FPP_local_vertices(ic, vertex_datas[i].list, FELs[i]);
			cands := (cands next cands := [])#[];
	    	   	lamthlam_hashess := (lamthlam_hashess next lamthlam_hashess := [])#[];
	    	   	entries := (entries next entries :=[])# []
	    	   fi
	  in i
    then add_involution(InnerClass ic, mat theta) = (int, int):
    	 let i = add_inner_class(ic)
	 then J = inv_hashes[i].size()
      	 then j = inv_hashes[i].match(theta)
     	 then () = if j = J {haven't seen this involution before}
      	      	   then cands[i] := (cands[i] next cands[i] := [])
		    	 			    # [];
			lamthlam_hashess[i] := (lamthlam_hashess[i] next lamthlam_hashess[i] := [])
		    	 			    # make_vec_hash();
		   	entries[i] := (entries[i] next entries[i] := []) # []
		   fi
	 in (i, j)
    then add_cands(InnerClass ic, mat theta) = (int, int):
    	 let (i,j) = add_involution(ic,theta)
	 then tempcandsi = cands[i]
	 then () = tempcandsi[j] := if old_flag
	      	   		    then cands(ic, theta, FPP_local_verts[i])
				    elif big_flag
				    then candsBIG(ic,theta)
				    elif new_flag
				    then candsNEW(ic,theta)
				    else cands(ic, theta, FPP_local_verts[i])
				    fi
	 then () = cands[i]:=tempcandsi
	 in (i,j)
    then add_lamthlam_hash(InnerClass ic, mat theta) = (int, int):
      	 let (i,j) = add_cands(ic,theta)
      	 then th1 = 1+theta, verts = FPP_local_verts[i]
      	 then cands = cands[i][j]
	 {for v in verts
      	   	      do if ((th1*v).denom = 1) then [ratvec_as_vec(th1*v)]
		      	 else []
		      	 fi
		      od.##.no_reps}
      	 then () = for lamthlam in cands
      	      	   do case vec_solve(th1,lamthlam - th1*ic.rho)
                    | else () {[(ratvec,VertexData,PermOrderTwo,vec)]: []}
                    | solution(lr):
                      let k = lamthlam_hashess[i][j].lookup(lamthlam)
		      then tempi = entries[i]
                      then () = if k = -1 {#tempi[j]}
		      	      	then let trial =
				     	 {if FEL_flag
					 then} localFD_Lvd2(theta,lr+ic.rho,vertex_datas[i],FELs[i])
					 {else localFD_Lvd2(ic, theta,lr+ic.rho,vertex_datas[i],ELLs[i])
					 fi}
				     in if #(trial.Lvd.list) > 0
				     	then lamthlam_hashess[i][j].match(lamthlam);
                                   	     tempi[j]:= (tempi[j] next tempi[j]:=[]) #trial
                                    	fi
				 {else lamthlam was valid and already computed entries[i][j]}
				 fi
		      then () = entries[i]:= tempi
		      in ()
                      esac
		   od

         in (i, j)
    in
    ( ( -> int): {inner_class_size} @int: inner_class_hash.size()
    , ( -> vec): {ic_vlist_size} @vec: for vd in vertex_datas do #vd.list od
    , ( -> ): {clear} clear
    , ( -> vec): {involution_size} @vec: for inv_hash in inv_hashes do inv_hash.size() od
    , ( -> [vec]): {lamthlam_size} @[vec]:
      for lamthlam_hashes in lamthlam_hashess {ith inner class}
      do for lamthlam_hash in lamthlam_hashes    {jth involution}
      	 do lamthlam_hash.size()
	 od
      od
    , ( -> [[vec]]): {Lvd_list_size} @[[vec]]:
      for i: #entries
      do for j: #entries[i]
	 do for k: #entries[i][j]
	    do #(entries[i][j][k].Lvd.list)
	    od {vec for involution}
	 od {[vec] for inner class}
      od
    , (InnerClass -> VertexData): {FPP_vertex_data}  (InnerClass ic) VertexData:
      let i = add_inner_class(ic)
      in vertex_datas[i]
    , (InnerClass -> (vec -> int)): {flippable_edge_lookup} (InnerClass ic) (vec -> int):
      let i = add_inner_class(ic)
      in FELs[i]
    {, (InnerClass -> [FacetVertsIndex]): {FPP_flip_tet} (InnerClass ic) [FacetVertsIndex]:
      let i = add_inner_class(ic)
      in Ffts[i]}
    , (InnerClass -> [ratvec]): {FPP_local_vertices} (InnerClass ic)  [ratvec]:
      let i = add_inner_class(ic)
       in FPP_local_verts[i]
    , ((InnerClass, mat) -> [vec]): {lamthlams} (InnerClass ic, mat theta) [vec]:
      let (i,j) = add_lamthlam_hash(ic,theta)
      in for k:lamthlam_hashess[i][j].size() do lamthlam_hashess[i][j].index(k)[:ic.rank] od
    , ((InnerClass, mat, vec) -> int): {lamthlam_number} (InnerClass ic, mat theta, vec lamthlam) int:
      let (i,j) = add_lamthlam_hash(ic,theta), th1 = theta+1
      in lamthlam_hashess[i][j].lookup(lamthlam)
    , ((InnerClass, mat) -> [ratvec]): {lambda0s} (InnerClass ic, mat theta) [ratvec]:
      let (i,j) = add_lamthlam_hash(ic,theta)
      in for k:lamthlam_hashess[i][j].size()
      	 do let lamthlam = lamthlam_hashess[i][j].index(k), th1 = 1+theta
	    then lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
      	    in lr+ic.rho
	 od
    , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2_mapAct)]): {LPm_entries} (InnerClass ic, mat theta) [(ratvec, Lvd_Perm2_mapAct)]:
      let (i,j) = add_lamthlam_hash(ic,theta), th1 = theta+1
      in for k:lamthlam_hashess[i][j].size()
      	 do let lamthlam = lamthlam_hashess[i][j].index(k)
	    then lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
	    in (lr+ic.rho, entries[i][j][k])
	 od
    , ((InnerClass, mat, vec) -> VertexData): {Lvd} (InnerClass ic, mat theta, vec lamthlam) VertexData:
      let (i,j) = add_lamthlam_hash(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k].Lvd
    , ((InnerClass, mat, vec) -> Lvd_Perm2_mapAct): {LPm_entry} (InnerClass ic, mat theta, vec lamthlam) Lvd_Perm2_mapAct:
      let (i,j) = add_lamthlam_hash(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k]
    , (int -> InnerClass): {inner_class_index} (int i) InnerClass: inner_class_hash.index(i)
    , (int -> VertexData): {vd_index} (int i) VertexData: vertex_datas[i]
    , ((int,int,int) -> Lvd_Perm2_mapAct): {Lvd_Perm2_mapAct_index} (int i, int j, int k): Lvd_Perm2_mapAct: entries[i][j][k]
)
)

set LPm_table = make_Lvd_Perm2_mapAct_table()

{this is the list of all possible lambda + theta*lambda for ic and theta}
set FPP_lamthlams(InnerClass ic, mat theta) = [vec]:
    LPm_table.lamthlams(ic,theta)

{list of lambdas up to twist by differential zero}
set FPP_lambda0s(InnerClass ic, mat theta) = [ratvec]:
    LPm_table.lambda0s(ic, theta)

set FPP_lambdas(KGBElt x) = [ratvec]:
    let lambda0s = FPP_lambda0s(x.inner_class, x.involution), G = x.real_form
    then twists = all_lambda_differential_0(x.involution)
    then zeroPol = null_module(G), zeroNu = null(G.rank)/1
    in for lambda0 in lambda0s
       do if 1*parameter(x, lambda0, zeroNu) != zeroPol
       	  then for tau in twists
	       do parameter(x, lambda0+tau, zeroNu).lambda
	       od
	  else []
	  fi
       od.##

{location of lambda in FPP_lambdas(x)}
set position(KGBElt x, ratvec lambda) = int:
    {let theta = x.involution, ic = x.inner_class
    then () = lambda:= parameter(x,lambda,0*lambda).lambda
    then th1 = 1+theta {, lr = (lambda- ic.rho).numer}
    then lamthlam = (th1*lambda).numer
    then m0 = LPm_table.lamthlam_number(x.inner_class, theta, lamthlam)
    then () = assert(m0.>=, "oops, lamthlam not found")
    then D = #all_lambda_differential_0(x)
    in} {this doesn't work because not all lamthlam's occur for x}
    first(for mu in FPP_lambdas(x) do lambda = mu od)
    { then taus = all_lambda_differential_0(x)
    then lambda0 = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho)) + ic.rho
    then m1 = first(for tauprime in taus do parameter(x, lambda0 + tauprime,null(ic.rank)).lambda = lambda od)
    in m0*#taus + m1 {, D = 4^(ic.semisimple_rank)}
    {then () = if m >= D
    	      then prints("warning: lambda number ", m," exceeds max ",D,
	      		       "; not recording this (x,lambda)")
	      fi}
    {in D*x.number + m}}

set FPP_lambdas([KGBElt] xs) = [[ratvec]]:
    for x in xs
    do FPP_lambdas(x)
    od


set_type
[big_unitary_hash_table =
( ( -> int) real_form_size {number of real forms included}
  , ( -> vec) uhash_sizes {for every real form, the number of unitary reps}
  , (RealForm -> int) uhash_size {for one real form, number of unitary reps}
  , ( -> ) clear
  , (RealForm -> int) rf_number {number of real form in list}
  , (int -> RealForm) rf_index {jth real form in list}
  , (RealForm -> [int]) xl_known {for each x, bitmap of lambda) for which FPP unitary dual is known}
  , ((KGBElt,int) -> ) finish {add bitmap of new known (x,lambda) to xl_known}
  , (RealForm -> Param_hash) uhash {hash table of known unitary}
  , (Param -> (int,int)) long_lookup {(rf_index(p.real_form), location of p in its uhash)}
  , (Param -> int) lookup {(location of p in its uhash)}
  , (Param -> bool) check {check whether p is unitary, and if so add to its hash table}
  , (Param -> int) match {add p to its hash table}
  , ((Param,int) -> int) long_match {add p to ith hash table}
)
]

set finish_time = int:0

set make_big_unitary_hash() = big_unitary_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then uhashes = [Param_hash]: [] {one for each real form}
    then xl_known = [[int]]: [] {one bitmap of known (x,lambda) for each real form and x}
    then clear() = void:
    	 let () = real_form_hash.clear()
	 then () = uhashes := []
	 then () = xl_known := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
	 then empty = [int]: null(#KGB(rf))
    	 then () = if i = I {haven't seen this real form before}
	      	   then	xl_known:= (xl_known next xl_known:=[]) # empty {null(#KGB(rf))};
			uhashes := (uhashes next uhashes:=[])#make_Param_hash()
	    	   fi
	  {then () = if i=I then prints((real_form_hash.size(), #uhashes, #xl_known)) fi}
	  then () = assert(real_form_hash.size() = #uhashes and #uhashes = #xl_known, "big_unitarity_hash damaged")
	  in i
    in
    ( (->int): {real_form_size} @int: real_form_hash.size()
    , ( -> vec): {uhash_sizes} @vec: for uhash in uhashes do uhash.size() od
    , (RealForm -> int): {uhash_size} (RealForm rf) int:
      uhashes[add_real_form(rf)].size()
    , ( -> ): {clear} clear
    , (RealForm -> int): {rf_number} (RealForm rf) int:
      add_real_form(rf)
    , (int -> RealForm): {rf_index} (int i) RealForm:
      real_form_hash.index(i)
    , (RealForm -> [int]): {xl_known} (RealForm rf) [int]:
      let i = add_real_form(rf)
      in xl_known[i]
    , ((KGBElt,int) -> ): {finish} (KGBElt x, int M):
      let start = elapsed_ms()
      then i = add_real_form(x.real_form)
      then xl_knowni = [int]: xl_known[i]
      then () = xl_knowni[x.number] := OR(M,xl_knowni[x.number])
      then () = xl_known[i] := xl_knowni
      then () = finish_time+:= elapsed_ms() - start
      in []
    , (RealForm -> Param_hash): {uhash} (RealForm rf) Param_hash:
      uhashes[add_real_form(rf)]
    , (Param -> (int,int)): {long_lookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      in (i, uhashes[i].lookup(p))
    , (Param -> int): {lookup} (Param p) int:
      let i = add_real_form(p.real_form)
      in uhashes[i].lookup(p)
    , (Param -> bool): {check} (Param p) bool:
      let i = add_real_form(p.real_form)
      {then () = prints("bitmap for ",p.x.number," is ",xl_known[i][p.x.number])}
      then () = p := alcove_center(p)
      then j = uhashes[i].lookup(p)
      in if j.>=
      	 then true
      	 elif is_member_bitset (position(p.x, p.lambda), xl_known[i][p.x.number])
	 then false
	 else let chk = is_unitary(p)
	      then () = if chk
		     	then uhashes[i].match(p)
		     	fi
	      in chk
	 fi
    , (Param -> int): {match} (Param p):
      let i = add_real_form(p.real_form)
      in uhashes[i].match(p)
    , ((Param,int) -> int): {long_match} (Param p, int i):
      uhashes[i].match(p)
    )
)

set big_unitary_hash = make_big_unitary_hash()

{. The next family of functions all need simple derived group. Always
|vd.list| should be ALL vertices in the FPP; Lvd.list will be all infl
chars in the FPP for a parameter (x,lambda,*), with x and lambda
fixed. The facet lists carried by [[FacetBary]] or [[FacetVertsIndex]]
may be pruned of reps not interesting for unitarity, but the indices
will always refer to a constant vlist.}

set two_to_position(KGBElt x, ratvec lambda) = int:
    to_bitset([position(x,lambda)])

{set a bit in xl_known}
set finish(KGBElt x, ratvec lambda) = void:
    big_unitary_hash.finish(x, two_to_position(x,lambda))

set finish(KGBElt x) = void:
    let lambdas = FPP_lambdas(x)
    then m = #lambdas
    then M = (to_bitset([m]) - 1)
    in big_unitary_hash.finish(x, M)

{check whether a bit in xl_known is set}
set is_finished(KGBElt x, ratvec lambda) = bool:
    let M = big_unitary_hash.xl_known(x.real_form)[x.number]
    in is_member_bitset(position(x,lambda),M)

set all_finished(RealForm G) = [(KGBElt,ratvec)]:
    let list = for x in KGB(G)
    	       do set_bit_positions(big_unitary_hash.xl_known(G)[x.number])
	       od
    in for x in KGB(G)
       do let poss = list[x.number]
       	  in for pos in poss
       	     do (x, FPP_lambdas(x)[pos])
       	     od
       od.##


set is_unitary_hash_big(Param p) = bool:
    unitary_test_counter.use();
    if not is_hermitian(p) then return false fi;
    let G = p.real_form
    then () = if is_finished(p.x, p.lambda) then return big_unitary_hash.lookup(p).>= fi
    then (,pL) = wkgood_Q(p)
    then derpLs = derived_factor_params2(pL)
    then () = if #derpLs = 0 then return true fi
    {then () = for derpL in derpLs do big_unitary_hash.rf_index(derpL.real_form) od}
    then statuses = for derpL in derpLs
    		    do big_unitary_hash.check(derpL)
		    od
    in if all(statuses) or #statuses = 1
       then statuses[0]
       else {some derpL is not unitary, but the induction is not trivial}
       	    let goodL = good_L(p)
	    in is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
			           goodL)
			      od))
       fi


{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big (Param p,int N) = bool:
  unitary_test_counter.use();
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
  then return true
  fi;
  is_pure(hermitian_form_irreducible_to_ht(p,N))

{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big (Param p,int N) = bool:
  unitary_test_counter.use();
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
  then return true
  fi;
  is_pure(hermitian_form_irreducible_to_ht(p,N))

{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_hts_big (Param p,[int] Ns) = bool:
  unitary_test_counter.use();
  if #Ns = 0 then return is_unitary_hash_big(p) fi;
  if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
  then return true
  fi;
  for N in Ns do if is_pure(hermitian_form_irreducible_to_ht(p,N)) then () else  return false fi  od;
  true

{. same as previous if next_height N is known .}
set is_unitary_test_big(Param p, int N) = bool:
    unitary_test_counter.use();
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
    then return true
    fi;
    is_pure(hermitian_form_irreducible_to_ht(p,N)) and
    is_unitary_hash_big(p)

{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_test_big (Param p, [int] Ns) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
  then return true
  fi;
  if #Ns = 0 then return is_unitary_hash_big(p) fi;
  for N in Ns do if is_pure(hermitian_form_irreducible_to_ht(p,N)) then () else  return false fi  od;
  is_unitary_hash_big(p)

{use the first m heights from deform_heights to test}
set is_unitary_def_test_big(Param p,int m) = bool:
    let (def,flag)= deform_hts(p,m)
    in if flag
       then is_pos_on_LKTs(p) and is_unitary_to_hts_big(p,def)
       else is_unitary_test_big(p,def)
       fi

{use the first height from deform_heights to test}
set is_unitary_def_test_big(Param p) = bool:
    is_unitary_def_test_big(p,1)