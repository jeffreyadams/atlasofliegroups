{this file concerns (local) facets of parameters, in preparation of analysis of their unitarity.}
<FPP_facets_geom.at
<goodroots.at { for is_pos_on_LKTs }
<Dirac.at
<hermitian.at
<K_highest_weights.at {for all_lambda_differential_0}
<unity.at {for deform_hts}
{BREAK HERE?}


{takes the known unitaries from unitary_hash having the given x and lambda,
 and returns their locations in LFDKH}
set known_unitaries(Param_hash Uhash, KGBElt x, ratvec lambda, VertexData Lvd,
    [[FacetVertsKHash]] LFDKH) = [vec]:
    let ps = for d:#LFDKH
    	     do for v in LFDKH[d]
	     	do parameter(x,lambda,facet_bary(Lvd.list, v[:d+1]))
		od
	     od
    in for d:#LFDKH
       do for p@j in ps[d]
       	  do let qs = monomials(finalize(p))
	     in if all(for q in qs do @bool: Uhash.lookup(q).>= od)
	     	then [j]
		else []
		fi
	  od.##
       od

{Here UhashLocal is assumed to consist of Param's at (x,lambda)}
{this misses (in local_testK_level) unitary Param's that finalize to different x;
those are caught by local_testK_hash}
set known_unitaries(Param_hash UhashLocal, VertexData Lvd,
    [[FacetVertsKHash]] LFDKH) = [vec]:
    let lookups = for list@d in LFDKH do index_in(if #list = 0 then [vec]:[]
    	      	  	    	     	      else for v in list do v[:d+1] od
					      fi)
				      od
    then NumKnown = UhashLocal.size(), out = [vec]: for j:#LFDKH do vec:[] od
    then () = for k:NumKnown
       	 do let p = UhashLocal.index(k)
       	    then list = local_vertices(p)
            in if #list-1 < #LFDKH
	       then let local_verts = vec: for ell in list do Lvd.lookup(ell) od.sort
	     	    then m = lookups[#list-1](local_verts)
		    then () = assert(m.>=,"have known unitary not appearing in LFDKH")
		    then () = out[#list-1]:=(out[#list-1] next out[#list -1]:=[])#m {out[#list-1]#m}
		    in ()
	       fi
	 od
     in out

set localize(Param_hash Uhash, KGBElt x, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.x = x and p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc

set localize(Param_hash Uhash, ratvec lambda) = Param_hash:
    let NumKnown = Uhash.size(), UhashLoc = make_Param_hash()
    then () = for k:NumKnown
       	      do let p = Uhash.index(k)
	      	 in if p.lambda = lambda
		    then UhashLoc.match(p)
		    else -1
		    fi
	      od
    in UhashLoc
{collection of lookup functions for facets of various dimensions}
set lookups([[vec]] LFD) = [(vec->int)]:
    for L@d in LFD do index_in(for v in L do v[:d+1] od) od

{assume LFDKH has tail coords referring to K-char}
set sort(RealForm G, VertexData Lvd, [[FacetVertsKHash]] LFDKH, int tail) = [[FacetVertsKHash]]:
    if sort_LFD_flag
    then let tworhocheck = G.two_rho_check
    	 then f(vec v) = int:
    	      let (num,den) = %(sum(for j in v[:#v - tail] do Lvd.list[j]*tworhocheck od)*1000)
	      in num\den
    	 in for LFDKHd@d in LFDKH do sort_by(f)(LFDKHd) od
    else LFDKH
    fi

{this is the Q(infinitesimal character) bound provided by Dirac inequality on all LKTs}
set DiracBD(KGBElt x, ratvec lambda) = rat:
    let G = x.real_form
    then Q = invariant_form(G)
    in if not(Dirac_flag and is_equal_rank(G))
       then Q(G.rho,G.rho)
       else let mus = LKTs(parameter(x,lambda,0*lambda))
       	    then ics = for mu in mus do DiracIC(mu) od
    	    in min(for ic in ics do Q(ic,ic) od)
       fi

{"true" means unitarity is possible in light of Dirac}
{avoid using is_hermitian defined in hermitian.at}
set DiracTest(Param p) = bool:
    let G=p.real_form
    then () = Dirac_flag:=true
    in if not is_equal_rank(G) then return equivalent(twist(p),p) {is_hermitian(p)}
       else let gamma = p.infinitesimal_character
    	    then Q = invariant_form(G)
	    then bound = DiracBD(p.x, p.lambda)
	    in Q(gamma, gamma) <= bound
       fi

{creates LVD, map Perm on FPPverts at (x,lambda), mapAct from FPPverts to local verts}
{in U(3,2), x_open, #vlist = 16: 4 fixed, 6 pairs flipped by Perm. The set of 6 pairs
gives only 3 elts of vlistAct: need to get rid of 3 repetitions.
parameter(x,lambda,v) (v in Lvd.list) may NOT be hermitian in unequal rank.}

set localFD_Lvd2 \
  (InnerClass ic, mat theta, ratvec lambda, VertexData vd, [(ratvec->int)] edge_lookups) =
  (VertexData, PermOrderTwo, vec):
(   let Perm2 = thetaAct2(ic, theta, lambda, vd, edge_lookups)
    then vlist = vd.list
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans do (vlist[i] + vlist[j])/2 od
	 {def of Perm2 forces this to be an actual edge?}
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)
)

set localFD_Lvd2 \
  ( KGBElt x, ratvec lambda, VertexData vd, [(ratvec->int)] edge_lookups) =
  localFD_Lvd2(x.inner_class, x.involution, lambda, vd, edge_lookups)

set localFD_Lvd2 \
  ( mat theta, ratvec lambda, VertexData vd, (vec->int) FlippedEdgeLookup) =
  (VertexData, PermOrderTwo, vec):
(   let start = elapsed_ms(), Perm2 = thetaAct2(theta, lambda, vd, FlippedEdgeLookup)
    then vlist = vd.list
    then vlistAct = [ratvec]:
    	 for i in Perm2.fixed do vlist[i] od ##
	 for (i,j) in Perm2.trans
	 do if FlippedEdgeLookup([i,j]) >= 0
	    then [(vlist[i] + vlist[j])/2]
	    else []
	    fi
	 od.##
    then Lvd = vlistAct.to_vertex_data
    then Llookup = Lvd.lookup
    then mapAct = vec: for j:#vlist do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for i@k in Perm2.fixed do mapAct[i]:= k od
    then () = for (i,j)@ell in Perm2.trans do mapAct[i]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[j]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)
)

set localFD_Lvd2 \
  (KGBElt x, ratvec lambda, VertexData vd, (vec->int) FlippedEdgeLookup) = (VertexData, PermOrderTwo, vec):
  localFD_Lvd2(x.involution, lambda, vd, FlippedEdgeLookup)

{takes local data and low global facets and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
set localFD_1Dirac2\
  ( KGBElt x, ratvec lambda, VertexData Lvd, PermOrderTwo Perm2, vec mapAct{,
    [[FacetVertsIndex]] globalFacets}) = [[FacetVertsIndex]]:
(   {if facet_verbose
    then prints(new_line,"start localFD_1Dirac")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FacetVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
 	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let EdgesFixFix = [vec]:
	     if #Perm2.fixed > 1
 	     then for v in FPP_edges(G){globalFacets[1]}
	       	  do if is_member_sorted(Perm2.fixed)(v[0]) and
		       	      is_member_sorted(Perm2.fixed)(v[1])
		     then let mloc = mapAct[v[0]], nloc = mapAct[v[1]]
		       	  in if Llookup(mloc) and Llookup(nloc)
			     then [[mloc,nloc].sort]
			     else []
			     fi
		      else []
		      fi
		   od.##
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
      	   then EdgesFixTrans = [vec]:
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
	      	    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
           {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = ([vec]:
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
	      	    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
	          fi
	       od.##)
	  {then () = prints("after TransTrans, time is ",print_time_string(elapsed_ms() - start))}
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     { then () = prints("after Edges, time is ",print_time_string(elapsed_ms() - start))}
     then LF1 = [FacetVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,facet_bary(Lvd.list, v))
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    in {if(facet_verbose) then prints("After localFD_1Dirac2, facet counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2") fi;}
       answer
)



{takes local data and low global facets and computes vertices and edges, imposing
hermitian, pos on LKTs, and Dirac. Subspace is fixed points of affine involution of
h*. Perm records involution action on FPP verts. mapAct records local vertex to which an FPP
vertex "belongs" (either "is" or "is vertex of the edge")}
{Edge in local picture is either
1) edge in FPP contained subspace, OR
2) triangle in FPP meeting subspace in line (one vertex of tri in subspace, other
   two flipped by involution, OR
3) tetrahedron in FPP, two pairs of verts exchanged by involution}
{This time assume that globalFacets[d] is list of size
#globalFacets[d-1] of d-facets, the jth list being all global facets that
begin with the jth global (d-1)-facet.}
set localFD_1Dirac2_by_zero\
  ( KGBElt x, ratvec lambda, VertexData Lvd, PermOrderTwo Perm2, vec mapAct{,
    [[[FacetVertsIndex]]] globalFacetsBYZERO}) = [[FacetVertsIndex]]:
(   {if facet_verbose
    then prints(new_line,"start localFD_1DiracBYZERO")
    fi;}
    let G = x.real_form, start = elapsed_ms(), trans_hash = make_vec_hash()
    then () = for (m,n) in Perm2.trans do trans_hash.match([m,n]) od
    then Q = (ratvec,ratvec->rat): (ratvec v, ratvec w) rat: 0/1
    then DiracBD = 0/1
    then () = if Dirac_flag
    	      then let () = DiracBD := DiracBD(x,lambda)
	      	   then () = Q:=invariant_form(G)
	      	   in ()
	      fi
    then LF0 = [FacetVertsIndex]:
    	 for v@j in Lvd.list
	 do let p = parameter(x,lambda,v)
	    in if any(for q in monomials(finalize(p)) do not is_pos_on_LKTs(q) od) or
 	       (Dirac_flag and Q(v, v)> DiracBD)
	    then []
	    else [[j]]
	    fi
	 od.##{list of j for which vertex j is a candidate}
    {then () = prints("after LFO, time is ",print_time_string(elapsed_ms() - start))}
    then Llookup = is_member_sorted((for v in LF0 do v[0] od))
    then Edges = [vec]:
    	 let EdgesFixFix = [vec]:
             if #Perm2.fixed > 1
	     then for j in Perm2.fixed
	     	  do let mloc = mapAct[j]
		     in if Llookup(mloc)
		     	then for v in FPP_edges_by_zero(G)[j] {global edges with v[0] = j}
			     do if is_member_sorted(Perm2.fixed)(v[1])
			     	then let nloc =  mapAct[v[1]]
				     in if nloc > mloc and Llookup(nloc)
				     	then [[mloc,nloc]]
             				else []
					fi
				else []
				fi
			     od.## {this is the list of edges starting with j}
	     		 else []
			 fi
		   od.## {all FixFix edges}
	       else []
	       fi
	   {then () = prints("after FixFix, time is ",print_time_string(elapsed_ms() - start))}
      	   then EdgesFixTrans = [vec]:
	      for v in FPP_flippable_triangles(G)
	      do if is_member_sorted(Perm2.fixed)(v[0])
	      	    and trans_hash.lookup([v[1],v[2]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[1]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
		  fi
	       od.##
           {then () = prints("after FixTrans, time is ",print_time_string(elapsed_ms() - start))}
	   then EdgesTransTrans = [vec]:
	      for v in FPP_flippable_tetrahedra(G)
	      do if trans_hash.lookup([v[0],v[1]]).>= {for e:5 if e < 3 do e fi od}
	      	    and trans_hash.lookup([v[2],v[3]]).>=
		 then let xloc = mapAct[v[0]], yloc = mapAct[v[2]]
		      in if Llookup(xloc) and Llookup(yloc)
			 then [[xloc,yloc].sort]
			 else []
			 fi
		  else []
	          fi
	       od.##
	   in EdgesFixFix ## EdgesFixTrans ## EdgesTransTrans
     then LF1 = [FacetVertsIndex]:
    	 for v in Edges
	 do let p = parameter(x,lambda,facet_bary(Lvd.list, v))
	    in  if all(for q in monomials(p) do is_pos_on_LKTs(q) od)
	    then [v]
	    else []
	    fi
	 od.##
    { then () = prints("after LF1, time is ",print_time_string(elapsed_ms() - start))}
    then answer = sort(G, Lvd, [LF0]##[LF1], 0)
    in {if(facet_verbose) then prints("After localFD_1Dirac2, facet counts are [",#LF0,
    		      	   	  ",",#LF1,"]") fi;
       if(time_verbose) then prints("     ",print_time_string(elapsed_ms() - start),
       			     		  " for localFD_1Dirac2") fi;}
       answer
)

{takes 0 and 1-diml local facets and adds K-char index}
set localFD_KHash_01 (KGBElt x, ratvec lambda, VertexData Lvd, KTypePol_hash ktp_hash,
[[FacetVertsIndex]] LF) = [[FacetVertsKHash]]:
    let start = elapsed_ms()
    then answer = for d:#LF
    	 do if fund_facet_verbose then prints(new_line, "start to compute ",#LF[d],
       	  		     " K-characters in dimension ",d,
			     " in localFD_KHash_01")
       	     fi;
	     for v@k in LF[d]
       	     do if k%(max(#LF[d]\10,2))=0 and fund_facet_verbose
	      	then prints("examining facet ",k,
	      	   "; #ktp_hash = ",ktp_hash.size())
	      	fi;
		let nu = facet_bary(Lvd.list, v)
       	      	then p0 = parameter(x, lambda, nu)
	      	then P = finalize(p0)
	      	then Q = K_type_pol(character_formula(P))
	      	in v##[ktp_hash.match(Q), #monomials(P)]
       	     od
    	od
   {then () = answer:= sort(x.real_form, Lvd, answer, 2)} {ARGUMENT ALREADY SORTED}
   then time = elapsed_ms() - start
   then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01") fi
   in answer

{takes 0 and 1-diml local facets and adds K-char index to height HT}
set localFD_KHash_01 (KGBElt x, ratvec lambda, VertexData Lvd, int HT, KTypePol_hash ktp_hash,
[[FacetVertsIndex]] LF) = [[FacetVertsKHash]]:
    let start = elapsed_ms()
    then answer = for d:#LF
    	 do if fund_facet_verbose then prints(new_line, "start to compute ",#LF[d],
       	  		     " K-characters to height ",HT, " in dimension ",d,
			     " in localFD_KHash_01")
       	    fi; for v@k in LF[d]
       	   do if k%(max(#LF[d]\10,2))=0 and fund_facet_verbose
	      then prints("examining facet ",k,
	      	   "; #ktp_hash = ",ktp_hash.size())
	      fi;
	      let nu = facet_bary(Lvd.list, v)
       	      then p0 = parameter(x, lambda, nu)
	      then P = finalize(p0)
	      then Q = K_type_pol(character_formula_to_height(P,HT))
	      in v##[ktp_hash.match(Q), #monomials(P)]
       	    od
    	  od
   {then () = answer:= sort(x.real_form, Lvd, answer, 2)} {argument already sorted}
   then time = elapsed_ms() - start
   then () = if time_verbose then prints("     ", print_time_string(time),
   	     		     " for localFD_KHash_01 to height ", HT) fi
   in answer

{takes list of 0- and d-diml facets, with d \ge 1, and builds all
d+1-diml facets having all faces in the d-diml list. The int e is the
number of extra coords in each facet.}
set superFacets([vec] L0, [vec] Ld, int e) =
    [vec]:
if #Ld = 0 then []
else
let d = #Ld[0] - e-1 {, start = elapsed_ms()}
then lookupsd = index_in(for v in Ld do v[:d+1] od)
then answer = [vec]:
   for v in L0
   do let m0 = v[0] {first vertex in new facet}
      in [vec]:
      	 for small in Ld
      	 do if small[0] <= m0
	    then [] {require m0 to be FIRST}
	    elif any(for k:d+1 do lookupsd( m0#(small[:k]##small[k+1:d+1])) = -1 od)
	    then [] {require all d-faces to be in Ld}
	    else [m0#small[:d+1]] {now m0##small is a candidate facet}
	    fi
	 od.## {now have a list of candidates starting m0}
   od.##
{ then () = if time_verbose
	  then prints("time for superFacets was ",
		      	print_time_string(elapsed_ms() - start))
          fi}
in answer
fi

{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t).

Need to assume b \ge 2, so have a list of potentially unitary facets and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, VertexData Lvd, [[FacetVertsKHash]] LFKH,
    int b, int t, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   {if facet_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;}
    let G = x.real_form, start=elapsed_ms()
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFacets(LFKH[0],LFKH[dim-1],2)
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then [actual##[ktp_hash.match(
				              K_type_pol(character_formula(P))), #ms]]
		       		    	 else []
				    	 fi
		    	      	   od.## {[FacetVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, 2)
    then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	      	   		" for localFD_Khashbt to dim ",t-1) fi
    in if(facet_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, facet counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)


{takes local data to height level, dimension \le b-1, and adds facets from
b to (t-1)-dimensional FPP-facets; make sure subfacets are also in list
Roughly input goes from 0 to b-1 (size b), output 0 to t-1 (size t). This time
just calculate K characters to HT

Need to assume b \ge 2, so have a list of potentially unitary facets and edges.}
set localFD_KHashbt_lookDownGEO \
  ( KGBElt x, ratvec lambda, VertexData Lvd, [[FacetVertsKHash]] LFKH,
    int b, int t, int HT, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
(   if facet_verbose
    then prints(new_line,"start localFD_Khashbt_lookDownGEO, b = ",b,", t = ",t)
    fi;
    let G = x.real_form, start=elapsed_ms()
    then () = for dim:t-#LFKH from #LFKH {b has to be at least 2}
    	      do LFKH := LFKH# (let acts = superFacets(LFKH[0],LFKH[dim-1],2)
	      	    	       	in for actual in acts
	       	    	      	   do let bary =
				      sum(G.rank, for j in actual do Lvd.list[j] od)/(dim+1)
		       	      	      then p0 = parameter(x,lambda, bary)
				      then P = finalize(p0)
				      then ms = monomials(P)
				      in if all(for p in ms do is_pos_on_LKTs(p) od)
				      	 then [actual##[ktp_hash.match(
				              K_type_pol(character_formula_to_height(P, HT))), #ms]]
		       		    	 else []
				    	 fi
		    	      	   od.## {[FacetVertsKHash]})
	 od
    then () = LFKH := sort(G, Lvd, LFKH, 2)
    {then time = elapsed_ms() - start
    then () = if time_verbose
	      then prints("     ", print_time_string(time),
	       " for localFD_Khashbt to height ", HT, " and dim ",t-1) fi}
    in if(facet_verbose)
       then prints("After localFD_KHashbt_lookDownGEO, facet counts are ",
       			      for list in LFKH do #list od) fi;
       LFKH
)

set extend_K_characters(KGBElt x, ratvec lambda, VertexData Lvd,
    [[FacetVertsKHash]] LFKH, KTypePol_hash ktp_hash) = [[FacetVertsKHash]]:
    {if facet_verbose
    then prints(new_line,"start extend_K_characters")
    fi;}
    let G = x.real_form, start = elapsed_ms()
    then answer =
       for d:#LFKH
       do if fund_facet_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_facet_verbose
	      	 then prints("examining facet ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = facet_bary(Lvd.list, v[:d+1]), w=v
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
	  	 then Q = K_type_pol(character_formula(P))
	  	 then () = w[d+1] := ktp_hash.match(Q)
		 in w
              od
      od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters") fi
     in answer

set extend_K_characters(KGBElt x, ratvec lambda, VertexData Lvd,
    [[FacetVertsKHash]] LFKH, int ht, KTypePol_hash ktp_hash) =
    	[[FacetVertsKHash]]:
    if facet_verbose
    then prints(new_line,"start extend_K_characters to height ",ht)
    fi;
    let G = x.real_form, start = elapsed_ms()
    then answer =
       for d:#LFKH
       do if fund_facet_verbose then prints(new_line, "start to extend ",#LFKH[d],
       	  		     " K-characters in dimension ",d,
			     " in extend_K_characters")
       	  fi; for v@k in LFKH[d]
       	      do if k%(max(#LFKH[d]\10,2))=0 and fund_facet_verbose
	      	 then prints("examining facet ",k,
	    	      "; #ktp_hash = ",ktp_hash.size())
	  	 fi;
	  	 let nu = facet_bary(Lvd.list, v[:d+1]), w=v
       	  	 then p0 = parameter(x, lambda, nu)
	  	 then P = finalize(p0)
	  	 then Q = K_type_pol(character_formula_to_height(P,ht))
	  	 then () = w[d+1] := ktp_hash.match(Q)
		 in w
              od
       od
     then time = elapsed_ms() - start
     then () = if time_verbose then prints("     ", print_time_string(time),
     	       	  " for extend_K_characters to ht ", ht) fi
     in answer

{version of solve from basic using precomputed echelon form, to speed repeated calcs}
set solve(vec b, mat M, mat C, [int] s) = maybe_a_vec:
(    let (n,k)=shape(M)
     then j=0 { runs up to k, used to index backwards }, sol=null(k)
     in assert(#b=n,"equation mismatch");
     	for i:n
       ~do if j<#s and i=s~[j] { then it is a pivot row, with pivot at M[j][i] }
       	   then let Mj=M~[j]
	   	then (q,r)=b[i]\%Mj[i]
		in if !=r then return ().no_vec { because inexact division} fi;
       		   sol~[j]:=q;
		   b-:=Mj*q; { correct for contribution from sol[j~] }
       		   j+:=1
       	    elif !=b[i] then return ().no_vec { because no pivot available }
       	    fi
   	 od;
	 (C[:k]*sol).solution
)

{these are the possible lambda+theta*lambda for x.involution = theta}
set cands(InnerClass ic, mat theta, [ratvec] verts) = [vec]:
    let th1 = 1+theta
    in for v in verts
       do let w = th1*v
       	  in if w.denom = 1
	     then [w.numer]
             else []
             fi
       od.##.no_reps

{these are the possible lambda+theta*lambda for x.involution = theta. First
vec hash includes all candidate lamthlam (for which a lambda in X* + rho exists).
For each lamthlam there is a Perm2 in the second list.}
set cands_hash(InnerClass ic, mat theta, vec_hash lamthlam_hash) = [PermOrderTwo]:
    let th1 = 1+theta, verts = FPP_vertices(ic), FEs = FPP_flippable_edges(ic),
    	Perm2s = [PermOrderTwo]: [], empty = [(int,int)]: []
    then shift = (-th1*ic.rho).numer
    then () = for v@j in verts
       	      do let w = th1*v
       	      	 in if w.denom = 1 and any(vec_solve(th1, w.numer + shift))
	       	    then let M = lamthlam_hash.size()
	       	    then m = lamthlam_hash.match(w.numer)
	       	    in if m = M
	     	       then let () = Perm2s #:= (vec: [j],empty)
		       	    in ()
		       else let Perm2sm = Perm2s[m]
			    then () = Perm2sm.fixed #:= j
			    then () = Perm2s[m] := Perm2sm
			    in ()
		       fi
	                                                                                                                     	    fi
               od
    then () = for pair in FEs
    	      do  let a = verts[pair[0]], b = verts[pair[1]]
	      	  then w = a+theta*b
	      	  in if theta*w = w and w.denom = 1
		     and any(vec_solve(th1, w.numer + shift))
		     then let M = lamthlam_hash.size()
	             then m = lamthlam_hash.match(w.numer)
	             in if m = M
		     	then let () = Perm2s #:= (null(0),[(pair[0],pair[1])])
			     in ()
			else let Perm2sm = Perm2s[m]
			     then () = Perm2sm.trans #:= (pair[0],pair[1])
			     then () = Perm2s[m] := Perm2sm
			     in ()
			fi
		     fi
	       od
     in Perm2s


{computes a set of integral vecs INCLUDING all of those in (1+theta)*FPP}
set candsBIG(InnerClass ic, mat theta) = [vec]:
    let th1 = 1+theta, {tester = [vec]: (1-theta).^} thmin = 1-theta
    then th1xis = th1*ic.fundamental_weights
    then mins = vec:
    	      	for j:ic.rank
    	        do floor(sum(for th1xi in th1xis do min(0,th1xi[j]) od))
		od
    then maxs = vec:
    	      	for j:ic.rank
    	        do ceil(sum(for th1xi in th1xis do max(0,th1xi[j]) od))+1
		od
    {jth coord of vector in th1*FPP is between mins[j] and maxs[j]}
    then B = mat:for b in box(maxs-mins) do b+mins od
    {number of rows = ic.rank}
    in for answer in columns(B)
       do if (thmin*(answer.numer)).=
       	  then [answer]
	  else []
	  fi
       od.## 

{a point in FPP has wfundamental[j] coord in the range [min[j], max[j]]}
set candsNEW(InnerClass ic, mat theta) = [vec]:
    let {y = theta,} two_rho = ic.two_rho, w = id_mat(ic.rank)
    then x = KGB_elt(KGBElt_gen:(ic, theta, null(ic.rank)))
    then G = x.real_form
    then y = KGB(G, first(for z in KGB(G) do z.Cartan_class = x.Cartan_class od))
    then theta0 = y.involution
    then w = cross_divide(x,y)
    {then () = prints(matrix(w)*theta0*matrix(w.inverse))}
    then simple = [vec]: ic.simple_coroots, fundamental = ratmat:
    	 if ic.semisimple_rank > 0
	 then ratvecs_as_ratmat(ic.fundamental_weights)
	 else null(ic.rank,0)/1
	 fi
{    then down = for av@j in simple
    	      	do if (av*y)*two_rho < 0 and
		      not (av + av*y).=
		   then [j]
		   else []
		   fi
		od.##
    then () = while #down > 0
    	      do let refl = reflection(ic,down[0])
	      	 then () = y:= refl*y*refl
		 then () = w:=w*refl {conjugates y back to theta}
	      	 in down:= for av@j in simple
    	      	      	      	  do if (av*y)*two_rho < 0 and
		      		     	not (av + av*y).=
		   	      	     then [j]
		   		     else []
		   		     fi
			      	  od.##
	       od
    {then () = prints(w)}
    {y = w.inverse * theta * w is the long Weyl elt of a split equal rank Levi.}
    }
    then Snonreal = for av@j in simple
    	       	    do if ((theta0.^)*av + av).=
		       then []
		       else [j]
		       fi
		    od.##
    then Sreal = for av@j in simple
    	       	 do if ((theta0.^)*av + av).=
		    then [j]
		    else []
		    fi
		 od.##
    then theta01 = theta0 + 1, wsimple = [vec]: for av in simple do av*(w.inverse) od, wfundamental = matrix(w)*fundamental
    then allmaxs = [int]:
    	 for k:ic.semisimple_rank
    	 do let wak = wsimple[k]
	    in max( (wak*two_rho)\2,0)
	 od
    then allmins = [int]:
    	 for k:ic.semisimple_rank
    	 do let wak = wsimple[k]
	    in min( (wak*two_rho)\2,0)
	 od
    then nrmaxs = [int]:
    	 for k in Snonreal
 	 do 2*allmaxs[k] +
	    sum(for j in Sreal
	        do allmaxs[j]*((theta01*ic.fundamental_weights[j])*simple[k]).numer
		od) + 1
	 od
    then nrmins = [int]:
    	 for k in Snonreal
	 do 2*allmins[k] +
	    sum(for j in Sreal
	        do allmins[j]*((theta01*ic.fundamental_weights[j])*simple[k]).numer
		od)
	 od
    then wfundnonreal = ratmat:
	 if #Snonreal > 0
	 then ratvecs_as_ratmat(
	      for j in Snonreal
	      do w*ic.fundamental_weights[j] 
	      od)
	  else null(ic.rank,0)/1
	  fi
    {then () = prints("nrmins = ",nrmins,", nrmaxs = ",nrmaxs,", wsimple = ", wsimple,", wfundnonreal cols = ",for c in columns(wfundnonreal) do c od)}
    {then () = assert(ratmat_as_mat((1-theta)*wfundnonreal).=, "oops, don't have eigenfunctions")}
    then B = mat:for b in box(nrmaxs-nrmins) do b+nrmins od
    {number of rows = size of Snonreal. Each column is a potential combination of wfundnonreal columns in th1*FPP}
    in for v in columns (wfundnonreal*B)
       do if v.denom = 1  {assume rho in X*; otherwise v-rho}
	  then [v.numer]
	  else []
	  fi
        od.##{.no_reps}  {automatically no reps}

set_type Lvd_Perm2_mapAct = (VertexData Lvd, PermOrderTwo Perm2, vec mapAct)

set Perm2_to_LPm(InnerClass ic, PermOrderTwo Perm2) = Lvd_Perm2_mapAct:
    let verts = FPP_vertices(ic)
    then FEs = FPP_flippable_edges(ic)
    then vlist = (for f in Perm2.fixed do verts[f] od)## (for (p,q) in Perm2.trans do facet_bary(verts,[p,q]) od)
    then Lvd = to_vertex_data(vlist)
    then mapAct = vec: for j:#verts do minus_1 od
    {maps FPP vertex indices from vd to local indices from Lvd}
    then () = for f@k in Perm2.fixed do mapAct[f]:= k od
    then () = for (p,q)@ell in Perm2.trans do mapAct[p]:=#Perm2.fixed + ell;
    	      	  	       		      mapAct[q]:=#Perm2.fixed + ell od
    in (Lvd, Perm2, mapAct)

{Record for each inner class a list of some involutions in inner class; and for each such involution,
 some possible lambdas; and for each such lambda, a list of (local vertex data, Perm2, mapAct)}
set_type
[Lvd_Perm2_mapAct_table =

( (->int) inner_class_size {number of inner classes included}
  , ( -> vec) ic_vlist_size {for each inner class, the number of FPP-vertices}
  , ( -> ) clear
  , ( -> vec) involution_size {for each inner class, number of involutions so far considered}
  , ( -> [vec]) lamthlam_size {for each inner class and involution, number of d_lambdas (actually lambda+theta*lambda)
      	 		       so far considered}
  , ( -> [[vec]]) Lvd_list_size {for each inner class and involution and d_lambda, size of Lvd.list}
  , (InnerClass -> VertexData) FPP_vertex_data {one for each inner class}
  , (InnerClass -> (vec -> int)) flippable_edge_lookup
  {, (InnerClass -> [FacetVertsIndex]) FPP_flip_tet}
  , (InnerClass -> [ratvec]) FPP_local_vertices {one for each inner class}
  , ((InnerClass, mat) -> [vec]) cands {for each involution, a list of candidates for lambda+theta_lambda}
  , ((InnerClass, mat) -> [vec]) lamthlams {for each involution, list of allowed lambda+theta_lambda}
  , ((InnerClass, mat, vec) -> int) lamthlam_number {for each involution, number of lambda+theta_lambda in list}
  , ((InnerClass, mat) -> [ratvec]) lambda0s {for each involution, list of allowed lambda mod twists}
  , ((InnerClass, mat,vec) -> PermOrderTwo) Perm2 {for each involution and lamthlam, corresponding Perm2}
  , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2_mapAct)]) LPm_entries {allowed lambda mod twists, corr entry}
    		       	  	    {like output of old FPP_lambdas_big_new}
  , ((InnerClass, mat, vec) -> VertexData) Lvd {local vertex data, one for each theta and lambda+theta*lambda}
  , ((InnerClass, mat, vec) -> Lvd_Perm2_mapAct) LPm_entry {one for each theta and lambda+theta*lambda}
{  , ((InnerClass, mat, vec) -> ) append {just compute, don't report LPm entry}}
  , (int -> InnerClass) inner_class_index
  , (int -> VertexData) vd_index {vertex data for inner class}
  , ((int,int,int) -> Lvd_Perm2_mapAct) Lvd_Perm2_mapAct_index {one for each inner class, involution,
    		      					       lambda + theta*lambda}
)
]
set old_flag = true {use old cands function}
set big_flag = false {use candsBIG}
set new_flag = false {use candsNEW}

set make_Lvd_Perm2_mapAct_table() = Lvd_Perm2_mapAct_table:
(   let inner_class_hash = make_InnerClass_hash()
    then inv_hashes = [mat_hash]: [] {one for each inner class}
    then vertex_datas = [VertexData]: [] {one for each inner class}
    then FELs = [(vec->int)]: [] {one for each inner class}
    then FPP_local_verts = [[ratvec]]: [] {one list for each inner class}
    then cands = [[[vec]]]: [] {one [vec] for each inner class and involution}
    then lamthlam_hashess = [[vec_hash]]: [] {one for each inner class and involution}
    	 {entries are vecs of size ic.rank: lamba+theta*lambda, for a
	 	  certain choice of lambda (defined up to twist and equivalence}
    then Perm2s = [[[PermOrderTwo]]]: [] {one for each involution and cand lamthlam}
    then entries = [[[Lvd_Perm2_mapAct]]]: [] {one list for each involution and cand lamthlam}
    then clear() = void:
    	 let () = inner_class_hash.clear()
	 then () = inv_hashes := []
	 then () = vertex_datas := []
	 then () = FELs := []
	 then () = FPP_local_verts := []
	 then () = cands := []
	 then () = lamthlam_hashess := []
	 then () = Perm2s := []
	 then () = entries := []
	 in ()
    then add_inner_class(InnerClass ic) = int:
    	 let I = inner_class_hash.size()
	 then i = inner_class_hash.match(ic)
    	 then () = if i = I {haven't seen this inner class before}
	      	   then inv_hashes := (inv_hashes next inv_hashes:=[])#make_mat_hash();
	    	   	vertex_datas := (vertex_datas next vertex_datas := [])#FPP_vertex_data(ic);
			FELs := (FELs next FELs:=[])# FPP_flippable_edge_lookup(ic);
	    	   	FPP_local_verts #:= FPP_local_vertices(ic, vertex_datas[i].list, FELs[i]);
			cands #:= [];
	    	   	lamthlam_hashess #:= [];
			Perm2s #:= [];
	    	   	entries #:= []
	    	   fi
	  in i
     then add_involution(InnerClass ic, mat theta) = (int, int):
    	 let i = add_inner_class(ic)
	 then J = inv_hashes[i].size()
      	 then j = inv_hashes[i].match(theta)
     	 then () = if j = J {haven't seen this involution before}
      	      	   then cands[i] := (cands[i] next cands[i] := [])
		    	 			    # [];
			lamthlam_hashess[i] #:= make_vec_hash();
			Perm2s[i] #:= [];
		   	entries[i] #:= []
		   fi
	 in (i, j)
    then add_cands(InnerClass ic, mat theta) = (int, int):
    	 let (i,j) = add_involution(ic,theta)
	 then tempcandsi = cands[i]
	 then tempPerm2si = Perm2s[i]
	 then entriesi = entries[i]
	 then () = if #cands[i][j] > 0
	 	   then return (i,j)
	 	   else let Perm2cands = cands_hash(ic,theta, lamthlam_hashess[i][j])
		   	then () = tempcandsi[j] := lamthlam_hashess[i][j].list()
			then () = tempPerm2si[j] := Perm2cands
			then () = entriesi[j] := for lamthlam@k in lamthlam_hashess[i][j].list()
			     	       	    do let Perm2 = Perm2cands[k]
				     	       in Perm2_to_LPm(ic,Perm2)
					    od
			then () = cands[i] := tempcandsi
			then () = Perm2s[i] :=tempPerm2si
			then () = entries[i] := entriesi
			{() = tempcandsi[j] := if old_flag
	      	   		    	       	  then cands(ic, theta, FPP_local_verts[i])
				    		  elif big_flag
				    		  then candsBIG(ic,theta)
				    		  elif new_flag
				    		  then candsNEW(ic,theta)
				    		  else cands(ic, theta, FPP_local_verts[i])
				    		  fi
	 		then () = cands[i]:=tempcandsi}
			in ()
		    fi
	 in (i,j)
    then add_KGBElt(KGBElt x) = (int,int):
    	 let i = add_inner_class(x.inner_class)
    	 then n = x.number
	 in (i,n)
    in
    ( ( -> int): {inner_class_size} @int: inner_class_hash.size()
    , ( -> vec): {ic_vlist_size} @vec: for vd in vertex_datas do #vd.list od
    , ( -> ): {clear} clear
    , ( -> vec): {involution_size} @vec: for inv_hash in inv_hashes do inv_hash.size() od
    , ( -> [vec]): {lamthlam_size} @[vec]:
      for lamthlam_hashes in lamthlam_hashess {ith inner class}
      do for lamthlam_hash in lamthlam_hashes    {jth involution}
      	 do lamthlam_hash.size()
	 od
      od
    , ( -> [[vec]]): {Lvd_list_size} @[[vec]]:
      for i: #entries
      do for j: #entries[i]
	 do for k: #entries[i][j]
	    do #(entries[i][j][k].Lvd.list)
	    od {vec for involution}
	 od {[vec] for inner class}
      od
    , (InnerClass -> VertexData): {FPP_vertex_data}  (InnerClass ic) VertexData:
      let i = add_inner_class(ic)
      in vertex_datas[i]
    , (InnerClass -> (vec -> int)): {flippable_edge_lookup} (InnerClass ic) (vec -> int):
      let i = add_inner_class(ic)
      in FELs[i]
    , (InnerClass -> [ratvec]): {FPP_local_vertices} (InnerClass ic)  [ratvec]:
      let i = add_inner_class(ic)
       in FPP_local_verts[i]
    , ((InnerClass, mat) -> [vec]): {cands} (InnerClass ic, mat theta) [vec]:
      let (i,j) = add_cands(ic,theta)
      in cands[i][j]
    , ((InnerClass, mat) -> [vec]): {lamthlams} (InnerClass ic, mat theta) [vec]:
      let (i,j) = add_cands(ic,theta)
      in lamthlam_hashess[i][j].list()
     , ((InnerClass, mat, vec) -> int): {lamthlam_number} (InnerClass ic, mat theta, vec lamthlam) int:
      let (i,j) = add_cands(ic,theta), th1 = theta+1
      in lamthlam_hashess[i][j].lookup(lamthlam)
    , ((InnerClass, mat) -> [ratvec]): {lambda0s} (InnerClass ic, mat theta) [ratvec]:
      let (i,j) = add_cands(ic,theta), th1 = 1+theta
      in for lamthlam in lamthlam_hashess[i][j].list()  {k:lamthlam_hashess[i][j].size()}
      	 do let lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
      	    in lr+ic.rho
	 od
    , ((InnerClass, mat,vec) -> PermOrderTwo): {Perm2} (InnerClass ic, mat theta, vec lamthlam):
      let (i,j) = add_cands{lamthlam_hash}(ic,theta)
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in Perm2s[i][j][k]
    , ((InnerClass, mat) -> [(ratvec, Lvd_Perm2_mapAct)]): {LPm_entries} (InnerClass ic, mat theta)
      [(ratvec, Lvd_Perm2_mapAct)]:
      let (i,j) = add_cands{lamthlam_hash}(ic,theta), th1 = theta+1
      in for lamthlam@k in lamthlam_hashess[i][j].list()
	 do let lr = required_solution(th1,lamthlam - ratvec_as_vec(th1*ic.rho))
	    in (lr+ic.rho, entries[i][j][k])
	 od
    , ((InnerClass, mat, vec) -> VertexData): {Lvd} (InnerClass ic, mat theta, vec lamthlam) VertexData:
      let (i,j) = add_cands{lamthlam_hash}(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k].Lvd
    , ((InnerClass, mat, vec) -> Lvd_Perm2_mapAct): {LPm_entry} (InnerClass ic, mat theta, vec lamthlam)
    Lvd_Perm2_mapAct:
      let (i,j) = add_cands(ic,theta), th1 = theta+1
      then k = lamthlam_hashess[i][j].lookup(lamthlam)
      in entries[i][j][k]
    , (int -> InnerClass): {inner_class_index} (int i) InnerClass: inner_class_hash.index(i)
    , (int -> VertexData): {vd_index} (int i) VertexData: vertex_datas[i]
    , ((int,int,int) -> Lvd_Perm2_mapAct): {Lvd_Perm2_mapAct_index} (int i, int j, int k): Lvd_Perm2_mapAct:
      entries[i][j][k]
)
)

set LPm_table = make_Lvd_Perm2_mapAct_table()

{this is the list of all possible lambda + theta*lambda for ic and theta}
set FPP_lamthlams(InnerClass ic, mat theta) = [vec]:
    LPm_table.lamthlams(ic,theta)

{list of lambdas up to twist by differential zero}
set FPP_lambda0s(InnerClass ic, mat theta) = [ratvec]:
    LPm_table.lambda0s(ic, theta)

set_type
[FPP_lambda_table =

( (->int) real_form_size {number of RealForms included}
  , ( -> ) clear
  , (KGBElt -> int) add_KGBElt
  , (KGBElt -> [ratvec]) FPP_lambdas {for each inner class, the number of FPP-vertices}
  , ((KGBElt,ratvec) -> int) position {location of lambda in FPP_lambdas(x)}
)
]

set make_FPP_lambda_table() = FPP_lambda_table:
(   let real_form_hash = make_RealForm_hash()
    then lambda_hashess = [[ratvec_hash]]: [] {one ratvec_hash for each real form and KGBElt}
    then clear() = void:
    	 let () = real_form_hash.clear()
	 then () = lambda_hashess := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then lambda_hashess #:= for x in KGB(rf) do make_ratvec_hash() od
	    	   fi
	  in i
    then add_KGBElt(KGBElt x) = int:
    	 let i = add_real_form(x.real_form)
    	 then n = x.number
	 then () = if lambda_hashess[i][n].size() = 0 {haven't computed FPP_lambdas(x)}
	      	   then let zeroPol = null_module(x.real_form), zeroNu = null(x.real_form.rank)/1
		   	then longlist = LPm_table.lambda0s(x.inner_class, x.involution),
			     twists = all_lambda_differential_0(x.involution)
			then list0 = for lambda0 in longlist
			     	     do if 1*parameter(x, lambda0, zeroNu) != zeroPol
				     	then [lambda0]
					else []
					fi
				     od.##
			in for l0 in list0
			   do for tau in twists
			      do lambda_hashess[i][n].match(parameter(x,l0+tau,zeroNu).lambda)
	  		      od
       			   od.##
		     fi
	  in n
     in
( (->int): {real_form_size} @int: real_form_hash.size()
  , ( -> ): clear
  , (KGBElt -> int): {add_KGBElt} (KGBElt x) int: add_KGBElt(x)
  , (KGBElt -> [ratvec]): {FPP_lambdas} (KGBElt x) [ratvec]:
    let i = add_real_form(x.real_form)
    then n = add_KGBElt(x)
    in lambda_hashess[i][n].list()
  , ((KGBElt,ratvec) -> int): {position} (KGBElt x, ratvec lambda) int:
    let i = add_real_form(x.real_form)
    then n = add_KGBElt(x)
    in lambda_hashess[i][n].lookup(lambda)
)
)

set FPP_lam_table = make_FPP_lambda_table()

{list of lambdas for x up to twist by differential zero}
set FPP_lambda0s(KGBElt x) = [ratvec]:
    let longlist = LPm_table.lambda0s(x.inner_class, x.involution), G=x.real_form
    then zeroPol = null_module(G), zeroNu = null(G.rank)/1
    in for lambda0 in longlist
       do if 1*parameter(x, lambda0, zeroNu) != zeroPol
       	  then [lambda0]
	  else []
	  fi
       od.##

set FPP_lambdas(KGBElt x) = [ratvec]:
    FPP_lam_table.FPP_lambdas(x)
    {
    let lambda0s = FPP_lambda0s(x), zeroNu = null(x.real_form.rank)/1
    then twists = all_lambda_differential_0(x.involution)
    in for lambda0 in lambda0s
       do for tau in twists
	  do parameter(x,lambda0+tau,zeroNu).lambda
	  od
       od.##
}
set position_time = int:0

{location of lambda in FPP_lambdas(x)}
set position(KGBElt x, ratvec lambda) = int:
    let start = elapsed_ms()
    then lambdaNorm = parameter(x,lambda,0*lambda).lambda
    then N = FPP_lam_table.position(x,lambdaNorm)
    {then () = if N=-1 then prints("WARNING: at G = ",x.real_form,", x = ",x.number,", lambda = ",
    	 lambdaNorm," is not attached to x.") fi}
    then () = position_time +:= elapsed_ms() - start
    in N

{, lambda0s = FPP_lambda0s(x), theta = x.involution, lambdas = FPP_lambdas(x)
    then twists = all_lambda_differential_0(theta), lamthlam = (1+theta)*lambda
    then M = first(for lambda0 in lambda0s do (1+theta)*lambda0 = lamthlam od)
    then N = first(for j:#twists from M*#twists do lambda = lambdas[j] od) +M*#twists
    then () = position_time +:= elapsed_ms() - start
    in N}

set FPP_lambdas([KGBElt] xs) = [[ratvec]]:
    for x in xs
    do FPP_lambdas(x)
    od


set_type
[big_unitary_hash_table =
( ( -> int) real_form_size {number of real forms included}
  , ( -> vec) uhash_sizes {for every real form, the number of unitary reps}
  , (RealForm -> int) uhash_size {for one real form, number of unitary reps}
  , ( -> vec) nuhash_sizes {for every real form, the number of nonunitary reps}
  , (RealForm -> int) nuhash_size {for one real form, number of nonunitary reps}
  , ( -> ) clear
  , (RealForm -> int) rf_number {number of real form in list}
  , (int -> RealForm) rf_index {jth real form in list}
  , (RealForm -> [int]) xl_known {for each x, bitmap of lambda for which FPP unitary dual is known}
  , ((KGBElt,int) -> ) finish {add bitmap of new known (x,lambda) to xl_known}
  , ((RealForm,[int]) -> ) finishall {add bitmaps of all new known (x,lambda) to xl_known}
  , (RealForm -> Param_hash) uhash {hash table of known unitary}
  , (RealForm -> Param_hash) nuhash {hash table of known nonunitary}
  , (Param -> (int,int)) long_lookup {(rf_index(p.real_form), location of p in its uhash)}
  , (Param -> int) lookup {(location of p in its uhash)}
  , (Param -> bool) check {check whether p is unitary, and if so add to its hash table}
  , (Param -> int) match {add p to its hash table}
  , ((Param,int) -> int) long_match {add p to ith hash table}
  , (Param -> (int,int)) nulong_lookup {(rf_index(p.real_form), location of p in its nuhash)}
  , (Param -> int) nulookup {(location of p in its nuhash)}
  , (Param -> bool) nucheck {check whether p is nonunitary, and if so add to its hash table}
  , (Param -> int) numatch {add p to its nuhash table}
  , ((Param,int) -> int) long_numatch {add p to ith nuhash table}
  , ( -> ) write {output unitary data for file}
  , (RealForm -> ) writeG {output data for one group to file}
  , ((RealForm, int, int) -> ) writeGrange {output data for KGB(G)[low,high]}
)
]

set finish_time = int:0
set is_finished_time = int:0

set make_big_unitary_hash() = big_unitary_hash_table:
(   let real_form_hash = make_RealForm_hash()
    then uhashes = [Param_hash]: [] {one for each real form}
    then nuhashes = [Param_hash]: [] {one for each real form}
    then xl_known = [[int]]: [] {one bitmap of known (x,lambda) for each real form and x}
    then clear() = void:
    	 let () = real_form_hash.clear()
	 then () = uhashes := []
	 then () = nuhashes := []
	 then () = xl_known := []
	 in ()
    then add_real_form(RealForm rf) = int:
    	 let I = real_form_hash.size()
	 then i = real_form_hash.match(rf)
    	 then () = if i = I {haven't seen this real form before}
	      	   then	let empty = [int]: null(#KGB(rf))
		   	then () = xl_known #:= empty {null(#KGB(rf))}
			then () = uhashes #:= make_Param_hash()
			in nuhashes #:= make_Param_hash()
	    	   fi
	  {then () = if i=I then prints((real_form_hash.size(), #uhashes, #xl_known)) fi}
	  then () = assert(real_form_hash.size() = #uhashes and #uhashes = #xl_known
	       	    				 and #nuhashes = #uhashes, "big_unitarity_hash damaged")
	  in i
    in
    ( (->int): {real_form_size} @int: real_form_hash.size()
    , ( -> vec): {uhash_sizes} @vec: for uhash in uhashes do uhash.size() od
    , (RealForm -> int): {uhash_size} (RealForm rf) int:
      uhashes[add_real_form(rf)].size()
    , ( -> vec): {nuhash_sizes} @vec: for nuhash in nuhashes do nuhash.size() od
    , (RealForm -> int): {nuhash_size} (RealForm rf) int:
      nuhashes[add_real_form(rf)].size()
    , ( -> ): {clear} clear
    , (RealForm -> int): {rf_number} (RealForm rf) int:
      add_real_form(rf)
    , (int -> RealForm): {rf_index} (int i) RealForm:
      real_form_hash.index(i)
    , (RealForm -> [int]): {xl_known} (RealForm rf) [int]:
      let i = add_real_form(rf)
      in xl_known[i]
    , ((KGBElt,int) -> ): {finish} (KGBElt x, int M):
      let start = elapsed_ms()
      then i = add_real_form(x.real_form)
      then xl_knowni = [int]: xl_known[i]
      then () = xl_knowni[x.number] := OR(M,xl_knowni[x.number])
      then () = xl_known[i] := xl_knowni
      then () = finish_time+:= elapsed_ms() - start
      in ()
    , ((RealForm,[int]) -> ): {finishall} (RealForm rf, [int] Ms):
      let start = elapsed_ms()
      then i = add_real_form(rf)
      then xl_knowni = [int]: xl_known[i]
      then () = for n:#KGB(rf)
      	      	do xl_knowni[n] := OR(Ms[n],xl_knowni[n])
		od
      then () = xl_known[i] := xl_knowni
      in finish_time+:= elapsed_ms() - start
    , (RealForm -> Param_hash): {uhash} (RealForm rf) Param_hash:
      uhashes[add_real_form(rf)]
    , (RealForm -> Param_hash): {nuhash} (RealForm rf) Param_hash:
      nuhashes[add_real_form(rf)]
    , (Param -> (int,int)): {long_lookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      in (i, uhashes[i].lookup(p))
    , (Param -> int): {lookup} (Param p) int:
      let i = add_real_form(p.real_form)
      in uhashes[i].lookup(p)
    , (Param -> bool): {check} (Param p) bool:
      let i = add_real_form(p.real_form)
      {then () = prints("bitmap for ",p.x.number," is ",xl_known[i][p.x.number])}
      then () = p := herm_center(p)
      then j = uhashes[i].lookup(p)
      in if j.>=
      	 then true
      	 elif is_member_bitset (position(p.x, p.lambda), xl_known[i][p.x.number])
	 then false
	 else let () = unitary_test_counter.use()
	      then chk = is_unitary(p)
	      then () = if chk
		     	then uhashes[i].match(p)
			else nuhashes[i].match(p)
		     	fi
	      in chk
	 fi
    , (Param -> int): {match} (Param p):
      let i = add_real_form(p.real_form)
      in uhashes[i].match(p)
    , ((Param,int) -> int): {long_match} (Param p, int i):
      uhashes[i].match(p)
    , (Param -> (int,int)): {nulong_lookup} (Param p) (int,int):
      let i = add_real_form(p.real_form)
      in (i, nuhashes[i].lookup(p))
    , (Param -> int): {nulookup} (Param p) int:
      let i = add_real_form(p.real_form)
      in nuhashes[i].lookup(p)
    , (Param -> bool): {nucheck} (Param p) bool:
      let i = add_real_form(p.real_form)
      {then () = prints("bitmap for ",p.x.number," is ",xl_known[i][p.x.number])}
      then () = p := herm_center(p)
      then j = nuhashes[i].lookup(p)
      in if j.>=
      	 then false
      	 elif is_member_bitset (position(p.x, p.lambda), xl_known[i][p.x.number])
	 then true
	 else let () = unitary_test_counter.use()
	      then chk = is_unitary(p)
	      then () = if chk
		     	then uhashes[i].match(p)
			else nuhashes[i].match(p)
		     	fi
	      in not chk
	 fi
    , (Param -> int): {numatch} (Param p):
      let i = add_real_form(p.real_form)
      in nuhashes[i].match(p)
    , ((Param,int) -> int): {nulong_match} (Param p, int i):
      nuhashes[i].match(p)
    , ( -> ): {write} @void:
    let rf_list = real_form_hash.list()
    in for rf@i in rf_list
       do let Gname = "G"+to_string(i)
	  then listname = Gname+"_list"
	  then intlistname = Gname+"_XLK"
	  then plist = uhashes[i].list()
	  then bitmapintlist = xl_known[i]
	  in write_real_form(rf,Gname);
	     prints("set j = big_unitary_hash.rf_number(",Gname,")");
	     prints("set ",listname,"=[Param]:[]");
	     write_append_cat_param_list(plist,listname,Gname);
	     prints("set ",intlistname,"=[int]:[]");
	     write_append(bitmapintlist,intlistname);
	     prints("void: for p in ",listname," do big_unitary_hash.long_match(p,j) od");
	     prints("big_unitary_hash.finishall(",Gname,",",intlistname,")")
	od
    , (RealForm -> ): {writeG} (RealForm G):
      let i = add_real_form(G)
      then Gname = "Gtemp"
      then listname = Gname+"_list"
      then intlistname = Gname+"_XLK"
      then plist = uhashes[i].list()
      then bitmapintlist = xl_known[i]
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 prints("set ",listname,"=[Param]:[]");
	 write_append_cat_param_list(plist,listname,Gname);
	 prints("set ",intlistname,"=[int]:[]");
	 write_append(bitmapintlist,intlistname);
	 prints("void: for p in ",listname," do big_unitary_hash.long_match(p,j) od");
	 prints("big_unitary_hash.finishall(",Gname,",",intlistname,")")
    , ((RealForm, int, int) -> ): {writeGrange} (RealForm G, int low, int high):
      let i = add_real_form(G)
      then Gname = "Gtemp"
      then listname = Gname+"_list_"+to_string(low)+"_"+to_string(high)
      then intlistname = Gname+"_XLK_"+to_string(low)+"_"+to_string(high)
      then longlist = uhashes[i].list()
      then plist = for p in longlist
      	   	   do if p.x.number >= low and p.x.number < high
		      then [p]
		      else []
		      fi
		   od.##
      then longbitmapintlist = xl_known[i]
      then bitmapintlist = longbitmapintlist[low:high]
      in write_real_form(G,Gname);
	 prints("set j = big_unitary_hash.rf_number(",Gname,")");
	 prints("set X = KGB(",Gname,")[",low,":",high,"]");
	 prints("set ",listname,"=[Param]:[]");
	 write_append_cat_param_list(plist,listname,Gname);
	 prints("set ",intlistname,"=[int]:[]");
	 write_append(bitmapintlist,intlistname);
	 prints("void: for p in ",listname," do big_unitary_hash.long_match(p,j) od");
	 prints("for N@m in ",intlistname," do big_unitary_hash.finish(X[m],N) od")
    )
)

set big_unitary_hash = make_big_unitary_hash()

{. The next family of functions all need simple derived group. Always
|vd.list| should be ALL vertices in the FPP; Lvd.list will be all infl
chars in the FPP for a parameter (x,lambda,*), with x and lambda
fixed. The facet lists carried by [[FacetBary]] or [[FacetVertsIndex]]
may be pruned of reps not interesting for unitarity, but the indices
will always refer to a constant vlist.}

set two_to_position(KGBElt x, ratvec lambda) = int:
    to_bitset([position(x,lambda)])

{set a bit in xl_known}
set finish(KGBElt x, ratvec lambda) = void:
    big_unitary_hash.finish(x, two_to_position(x,lambda))

set finish(KGBElt x) = void:
    let lambdas = FPP_lambdas(x)
    then m = #lambdas
    then M = (to_bitset([m]) - 1)
    in big_unitary_hash.finish(x, M)

{check whether a bit in xl_known is set}
set is_finished(KGBElt x, ratvec lambda) = bool:
    let start = elapsed_ms(), M = big_unitary_hash.xl_known(x.real_form)[x.number]
    then answer = is_member_bitset(position(x,lambda),M)
    then () = is_finished_time +:= elapsed_ms() - start
    in answer

{list of all pairs (x,lambda) for which complete FPP-unitary dual is present in big_unitary_hash}
set all_finished(RealForm G) = [(KGBElt,ratvec)]:
    let list = for x in KGB(G)
    	       do set_bit_positions(big_unitary_hash.xl_known(G)[x.number])
	       od
    in for x in KGB(G)
       do let poss = list[x.number]
       	  in for pos in poss
       	     do (x, FPP_lambdas(x)[pos])
       	     od
       od.##

{this version is only for G simple and hermitian FPP params}
set is_unitary_hash_big_SIMPLE(Param p) = bool:
    let G = p.real_form
    then () = if is_finished(p.x, p.lambda) then return big_unitary_hash.lookup(p).>= fi
    then (,pL) = wkgood_Q(p)
    then derpLs = derived_factor_params2(pL)
    then () = if #derpLs = 0 then return true fi
    {then () = for derpL in derpLs do big_unitary_hash.rf_index(derpL.real_form) od}
    then statuses = for derpL in derpLs
    		    do big_unitary_hash.check(derpL)
		    od
    in if all(statuses) or #statuses = 1
       then statuses[0]
       else {some derpL is not unitary, but the induction is not trivial}
       	    let goodL = good_L(p)
	    in is_pure(sum(G, for c@qL in hermitian_form_irreducible(pL)
			      do c*theta_induce_standard(param(qL),
			           goodL)
			      od))
       fi

set is_unitary_hash_big(Param p) = bool:
    if not is_hermitian(p) then return false fi;
    let pds = derived_factor_params2(p)
    in all(for pD in pds do @bool: is_unitary_hash_big_SIMPLE(pD) od)

{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big (Param p,int N) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
  then return true
  fi;
  unitary_test_counter.use();
  is_pure(hermitian_form_irreducible_to_ht(p,N))

{meant to be used for G simple}
{ compute Hermitian form to ht on p, report if it is unitary}
set is_unitary_to_ht_big (Param p,int N) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
  then return true
  fi;
  unitary_test_counter.use();
  is_pure(hermitian_form_irreducible_to_ht(p,N))

{meant to be used for G simple}
{ compute Hermitian form to hts on p, report if it is unitary}
set is_unitary_to_hts_big (Param p,[int] Ns) = bool:
  if #Ns = 0 then return is_unitary_hash_big(p) fi;
  if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
  then return true
  fi;
  for N in Ns
  do if is_pure(hermitian_form_irreducible_to_ht(p,N))
     then  unitary_test_counter.use()
     else  return false fi  od;
  true

{ONLY for G simple}
{. same as previous if next_height N is known .}
set is_unitary_test_big(Param p, int N) = bool:
    unitary_test_counter.use();
    if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
    if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
    then return true
    fi;
    is_pure(hermitian_form_irreducible_to_ht(p,N)) and
    is_unitary_hash_big_SIMPLE(p)

{ONLY for G simple}
{. compute Hermitian form to ht on p, report if it is unitary .}
set is_unitary_test_big (Param p, [int] Ns) = bool:
  if (not is_hermitian(p)) or (not is_pos_on_LKTs(p)) then return false fi;
  if is_finished(p.x, p.lambda) and big_unitary_hash.lookup(p).>=
  then return true
  fi;
  if #Ns = 0 then return is_unitary_hash_big(p) fi;
  for N in Ns do if is_pure(hermitian_form_irreducible_to_ht(p,N)) then unitary_test_counter.use() else  return false fi  od;
  is_unitary_hash_big_SIMPLE(p)

{ONLY for G simple}
{use the first m heights from deform_heights to test}
set is_unitary_def_test_big(Param p,int m) = bool:
    let (def,flag)= deform_hts(p,m)
    in if flag
       then is_pos_on_LKTs(p) and is_unitary_to_hts_big(p,def)
       else is_unitary_test_big(p,def)
       fi

{ONLY for G simple}
{use the first height from deform_heights to test}
set is_unitary_def_test_big(Param p) = bool:
    is_unitary_def_test_big(p,1)

{ONLY for G simple}
set is_unitary_next_big(Param p) = bool:
    if is_pos_on_LKTs@Param(p)
    then  let n=next_heightB(p)
    	  in  if (n-1).=
	      then true
	      elif is_unitary_to_ht_big(p,n)
	      then is_unitary_hash_big_SIMPLE(p)
	      else false
	      fi
    else false
    fi
