<polynomial.at
<rational_polynomial.at
<sort.at
<ratmat.at
<gaussian.at	

set Cartesian ([int] a, [int] b) = [int]:
    ## for x in a do for y in b do x*y od od

{. divisors of an integer .}
set divisors (int n) = [int]:
   if =n then return [] fi;
   ((2,abs(n)).
    (rec_fun d(int b, int n) [int]:
      if b*b>n then if n=1 then [1] else [1,n] fi
      else let (q,r)=n\%b in
         if !=r then d(b+1,n)
         else let l=[1,b] in
            while =q%b do q\:=b; l:= 1 # (l*b) od
         ;  Cartesian(l,d(b+1,q))
         fi
      fi
    ).sort)

{. Euler totient function .}
set phi (int n) = int:
(  assert(n>0);
   let p=1, b=2 in
   while not (b*b>n)
   do let (q,r)=n\%b in
      if !=r then b+:=1 { |b| is not a divisor, raise it }
      else p*:=b-1
      ;  while =q%b do q\:=b; p*:=b od { move factors |b| from |q| to |p| }
      ;  n:=q
      fi
   od; if n=1 then p else p*(n-1) fi
)

{. n^th Cyclotomic Polynomial .}
set cyclotomic_polynomial (int n) = poly:
   let Phis=[poly]:[], divs=divisors(n)
   then locate (int d) = binary_search_first((int i)bool: divs[i]>=d,0,#divs)
   in
   for d in divs
   do let P=poly: (-1) # null(d-1) # 1 in { X^d - 1 }
      for dd in divisors(d)[:1~] do set(P,):=monic_divide(P,Phis[locate(dd)]) od
   ;  Phis#:=P
   od; Phis~[0]

{.list of integers relatively prime to n.}
set relative_primes(int n) = [int]:
  list ((int i)bool: gcd([i,n])=1 ,n)

{ a can be negative, N must be positive }
{. integer a -> representative 0\le b\le N-1 mod N .}
set mod (int a, int N) = int: assert(N>0,"N<=0");a%N


{ to_denominator(r,N): integer $a$ such that rational $r$ is congruent to
  $a/N$ modulo 1
  The application is that $\exp(2\pi i r)=\zeta^a$ where $\zeta=\exp(2\pi i/n)$
}
set to_denominator (rat r, int N) = int:
   let (numer,denom)=%(r%1) { reduce modulo 1, then split }
   then (q,r)=N\%denom
   in assert(r=0,"root of unity is not in the specified cyclotomic field");
   q*numer

{ cyclotomic Fields and their elements }

{ represent cyclotomic field by order and minpoly of generating root of 1 }
: cyclotomicField = (int order, poly Phi)

{.construct a cyclotomic field.}
set cyclotomic_field (int n) = cyclotomicField: (n, cyclotomic_polynomial(n))
set CF = cyclotomic_field@int  {abbreviation}

set degree (cyclotomicField F) = int: #F.Phi-1

set = (cyclotomicField E,cyclotomicField F) = bool: F.order=E.order

{element in a cyclotomic field is ([rat],cyclotomicField)
 use [rat] rather than ratvec to allow bigints}
{. element in a cyclotomic field.}
: cyclotomicFieldElement = ([rat] v,cyclotomicField F)

{.reduce rational polynomial modulo Phi(n).}
set reduce (cyclotomicFieldElement (v,F)) = cyclotomicFieldElement:
   let (,r)=monic_divide(v,F.Phi) in (r,F)

set = (cyclotomicFieldElement(v,F),cyclotomicFieldElement(w,G)) = bool:
   assert(F=G,"cyclotomic fieds differ in comparison");
   let (,r)= monic_divide(ratpoly_sub(v,w),F.Phi) in =r

set cyclotomic_field_element = reduce@([rat],cyclotomicField)

{.embed Q in cyclotomic field as (images of) constant polynomials.}
set embed_Q (rat r,cyclotomicField F) = cyclotomicFieldElement:
   cyclotomic_field_element([r],F) { embed $\Q$ }

set one (cyclotomicField F) = cyclotomicFieldElement:  embed_Q(1,F)
set zero (cyclotomicField F) = cyclotomicFieldElement: embed_Q(0,F)

set primitive_root (cyclotomicField F) = cyclotomic_field_element([0,1],F)

{operations on elements of cyclotomic fields}

set + (cyclotomicFieldElement (v,F),cyclotomicFieldElement (w,G)) =
      cyclotomicFieldElement:
   assert(F=G,"cyclotomic fields do not agree"); (ratpoly_plus(v,w),F)
set - (cyclotomicFieldElement (v,F),cyclotomicFieldElement (w,G)) =
      cyclotomicFieldElement:
   assert(F=G,"cyclotomic fields do not agree"); (ratpoly_sub(v,w),F)

set * (cyclotomicFieldElement (v,F),cyclotomicFieldElement (w,G)) =
      cyclotomicFieldElement:
   assert(F=G,"cyclotomic fields do not agree"); reduce(ratpoly_product(v,w),F)

{ positive power (should use repeated squaring; code below will do for now) }
set ^ (cyclotomicFieldElement (v,F),int k) = cyclotomicFieldElement:
   assert(k>=0,"Negative power in cyclotomic field not implemented");
(  if =k then [1]
   else let p=v in
      while >(k-:=1) do set(p,):=reduce(ratpoly_product(p,v),F) od; p
   fi
,  F
)

{ simplified operations }
set - (cyclotomicFieldElement (v,F)) = cyclotomicFieldElement: (-v,F)
set * (rat r, cyclotomicFieldElement (v,F)) = cyclotomicFieldElement: (r*v,F)

{order of element of F, returns -1 if element not of finite order}
set order(cyclotomicFieldElement x)= int:
   let one=x.F.one in
   if x=one then 0
   else 1+first(x.F.order*2,(int i)bool: x^(i+1)=one) { i+1: start search at 1 }
   fi

set is_rational (cyclotomicFieldElement z) = bool: #reduce(z).v<=1
set to_rational (cyclotomicFieldElement z) = rat:
   z:=reduce(z); assert(#z.v<=1,"element is not rational");
   if =#z.v then 0 else z.v[0] fi

set is_integer(cyclotomicFieldElement z) = bool:
   z.is_rational and z.to_rational.is_integer
set to_integer(cyclotomicFieldElement z)=int:
   let q=to_rational(z) in
   assert(q.is_integer,"element is not an integer"); q.rat_as_int

{ embed roots of unity in F }
set exp_1 (rat r,cyclotomicField F) = cyclotomicFieldElement:
   let k=to_denominator(r,F.order) in
   cyclotomic_field_element(null(k)##[1/1],F)

set zeta_power (int k, cyclotomicField F) = cyclotomicFieldElement:
   { first reduce modulo $X^n-1$, then modulo $\Phi(n)$ }
   reduce(null(k%F.order)##[1/1],F)

set * (ratmat M,cyclotomicFieldElement (v,F)) = cyclotomicFieldElement:
   ( M*v , F )

set galois_matrix (int k,cyclotomicField F) = ratmat:
  let d=degree(F) in ratvecs_as_ratmat(for i:d do zeta_power(k*i,F).v od)

set pad(cyclotomicFieldElement z)=cyclotomicFieldElement:(z.v##null(z.F.degree-#z.v),z.F)

set galois_action(int k, cyclotomicFieldElement z)=cyclotomicFieldElement:
let z=pad(z) in (galois_matrix(k,z.F)*z.v,z.F)

set galois_matrices(cyclotomicField F) = [ratmat]:
   for i in relative_primes(F.order) do galois_matrix(i,F) od

set matrix_of_multiplication (cyclotomicFieldElement z) = ratmat:
   for i:degree(z.F) do (z*zeta_power(i,z.F)).v od.ratvecs_as_ratmat

set norm (cyclotomicFieldElement z) = rat: det(matrix_of_multiplication(z))

{ three ways of computing inverse of element of cyclotomic field:
  using conjugates and norm in the cyclotomic field (risks overflow even
  when inverting elements of the subfield $\Q$), inverting by applying the
  inverse of the multiplication matrix, and inverting by solving the
  mulitplication problem using linear algebra (probably this has the least
  risk of umeric overflow, so it is selected as |inverse|).
}

{.inverse of z=products of nontrivial galois conjugates/norm.}
set inverse_by_norm (cyclotomicFieldElement (,F):z) = cyclotomicFieldElement:
   let w=F.one in z:=reduce(z);
   for A in galois_matrices(F)[1:] do w*:=A*z  od; (/norm(z))*w

{.inverse of z = inverse of (matrix of multipliciation by z) applied to F.one.}
set inverse_by_matrix (cyclotomicFieldElement(,F):z) = cyclotomicFieldElement:
   inverse(matrix_of_multiplication(z))*F.one

set inverse_by_solve (cyclotomicFieldElement(,F):z) = cyclotomicFieldElement:
   (solve(matrix_of_multiplication(z),F.one.v)[0],F)

set inverse_by_gauss(cyclotomicFieldElement(,F):z) = cyclotomicFieldElement:
    let M=matrix_of_multiplication(z) {|ratmat|} then 
    N=ratmat_to_bigmat(M) then
    v=[rat]:F.one.v in (times(inverse(N),v),F)

{ use inverse_by_gauss }
{.inverse of element in cyclotomic field.}
set inverse = inverse_by_gauss@cyclotomicFieldElement

set / = inverse@cyclotomicFieldElement { unary division is inverse }

{set / (cyclotomicFieldElement(v,F), cyclotomicFieldElement z) =
      cyclotomicFieldElement:
   (solve(matrix_of_multiplication(z),v)[0],F)}

set / (cyclotomicFieldElement z, cyclotomicFieldElement w)=cyclotomicFieldElement:z*inverse(w)

{.convert cyclotomic field element to a string for output.}
set to_string (cyclotomicFieldElement z) = string:
   if z.v.is_integer
   then stringPoly(z.v.ratvec_as_vec,"x")+" in F("+ z.F.order+ ")"
   else stringPoly(z.v,"x")+" in F("+ z.F.order+ ")"
   fi

{.display cyclotomic field element as polynomial in x.}
set show (cyclotomicFieldElement z) = void: prints(to_string(z))

set complex_conjugate(cyclotomicFieldElement z)=cyclotomicFieldElement:
let v=z.v then
zeta=z.F.primitive_root then
rv=z.F.zero in
for j:#v do rv+:=v[j]*inverse(zeta^j) od;rv

set bar(cyclotomicFieldElement z)=cyclotomicFieldElement:complex_conjugate(z)
set is_real(cyclotomicFieldElement z)=bool:z=z.bar

set absolute_value_squared(cyclotomicFieldElement z)=cyclotomicFieldElement:z*z.bar