{ This file was an auxiliary to conjugacy_classes.at, which is superseded by
  W_characters.at; therefore it will be soon removed.

  The script deals with the genaration of all conjugacy classes of Levi systems
  for a given root datum, the funtion Levi_classes below. In W_characters.at
  this is done inside the function standard_Levi_conjugacy_representatives

  The final function print_Levis_by_conjugate_rhos has no counterpart elsewhere.
}

<basic.at
<parabolics.at

{. Decide whether two weights are conjugate by the Weyl group. .}
set is_W_conjugate (ratvec v, ratvec w, RootDatum rd) = bool:
   dominant(rd,v)=dominant(rd,w)

{. Remove a list of integer arrays from a list of integer arrays; this
   is set difference for sets of integer lists. .}
set remove_from_set ([[int]] old_set, [[int]] rem_set) = [[int]]:
##for S in old_set
  do if none(for T in rem_set do T=S od) then [S] else [] fi od

{. Given a root datum, create a list of all complex parabolic subgroups. .}
set complex_parabolics (RootDatum rd) = [ComplexParabolic]:
  for S in power_set(semisimple_rank(rd)) do (rd,S) od

{. Given a root datum, create a list of subsets of the set of simple roots. .}
set complex_parabolics_S (RootDatum rd) = [[int]]:
  power_set(semisimple_rank(rd))

{. Given a list of integer arrays, create a list of those of size n. .}
set choose_by_size ([[int]] list, int n) = [[int]]:
  ##for S in list do if #S=n then [S] else [] fi od

{. Given a list of integer arrays representing sets of simple roots for a
   given root datum, create the list of corresponding rho(L)'s. .}
set compute_rhos ([[int]] list, RootDatum rd) = [ratvec]:
  for S in list do rho(complex_Levi(rd,S)) od

{. Given two complex parabolics of the same complex group, decide whether
   the rhos of their Levi factors are conjugate. .}
set is_conjugate (RootDatum rd,[int] S,[int] T) = bool:
   dominant(rd,rho(complex_Levi((rd,S))))=dominant(rd,rho(complex_Levi((rd,T))))

{. The Levi factors in the previous command are standard (given by subset of
   simple roots); the following test applies to any Levi subgroup containing
   the fixed H. .}
set is_conjugate(RootDatum rd, RootDatum rd_L1, RootDatum rd_L2) = bool:
   dominant(rd, rho(rd_L1))=dominant(rd,rho(rd_L2))

{. Given a list S of integers representing simple roots in a complex group,
   and a list of integer arrays, create the list of arrays whose corresponding
   rho(L) is conjugate to that defined by S. .}
set conjugates_by_rho (RootDatum rd, [int] S, [[int]] list) = [[int]]:
  let rhos=compute_rhos(list,rd) in
  let P=ComplexParabolic:(rd,S) in let rhoP=rho(complex_Levi(P))
  in let rho_dom=dominant(rd,rhoP) in
  ##for v@i in rhos do if dominant(rd,v)=rho_dom then [list[i]] else [] fi od

{. Given an array of integer lists representing simple roots in a complex
   group, print the list of Lie types of the corresponding Levi subgroups. .}
set print_conjugate_info (RootDatum rd, [[int]] S_list) = void:
   prints("Levi","         ","Lie Type");
   for S in S_list do let L=complex_Levi((rd,S)) in
   prints(S," ",Lie_type(L.rd_Levi)) od

{. Given a list of integer arrays representing sets of simple roots for a
   complex group, partition the list into sublists according to W-conjugacy
   classes for the corresponding rho(L). .}
set group_by_conjugate_rhos (RootDatum rd,[[int]] list) = [[[int]]]:
   let result=[] in let sets=list in
   while #sets>0 do let new_set=conjugates_by_rho (rd,sets[0],sets)
   in result#:=new_set; sets:=remove_from_set (sets,new_set) od;
   result

{. Given a list of integer arrays representing sets of simple roots for
   a complex group, create a list of integer arrays, one for each
   conjugacy class for the corresponding rho. .}
set classes_by_rho (RootDatum rd, [[int]] list) = [[int]]:
   let result=[] in let sets=list in
   while #sets>0 do let new_set=conjugates_by_rho (rd,sets[0],sets)
   in result#:=new_set[0]; sets:=remove_from_set (sets,new_set) od;
   result

{. Given a root datum defining a complex group, create a list of
   integer arrays, one for each conjugacy class for the corresponding
   rho(L), L of rank n. .}
set classes_by_rho (RootDatum rd, int n) = [[int]]:
   classes_by_rho (rd, choose_by_size(complex_parabolics_S(rd),n))

{. Given a root datum, create a list of integer arrays representing
   Levi subgroups of fixed rank, grouping together those that
   have conjugate rho(L). .}
set group_by_conjugate_rhos (RootDatum rd, int rank) = [[[int]]]:
   let list=complex_parabolics_S(rd) then
   same_size_list=choose_by_size(list,rank) in
   group_by_conjugate_rhos(rd,same_size_list)

{. Perform the previous function for all possible ranks of Levi
   subgroups. .}
set group_by_conjugate_rhos (RootDatum rd) = [int,[[[int]]]]:
   for i:semisimple_rank(rd)+1 do (i,group_by_conjugate_rhos(rd,i)) od

{. As the previous function, but with only one representative for
   each conjugacy class of Levis. .}
set classes_by_rho_int_list (RootDatum rd) = [int,[[int]]]:
   for i:semisimple_rank(rd)+1 do (i,classes_by_rho(rd,i)) od

{. list [ComplexLevi] of complex Levi subgroups, representatives of the
   conjugacy classes generated by the rho(Levi) algorithm .}
set classes_by_rho (RootDatum rd) = [ComplexLevi]:
  for v in ##for i:semisimple_rank(rd)+1 do classes_by_rho (rd,i) od
  do (rd,complex_Levi(rd,v).rd_Levi) od

{. list [ComplexLevi] of complex Levi subgroups, representatives of the
   conjugacy classes .}
set Levi_classes = (RootDatum->[ComplexLevi]): classes_by_rho@RootDatum

set print_Levis_by_conjugate_rhos (RootDatum rd) = void:
   prints ("rank  # of classes  classes");
   for i:semisimple_rank(rd)+1 do let list=group_by_conjugate_rhos(rd,i) in
     prints(i,"        ",#list,"          ",list) od
