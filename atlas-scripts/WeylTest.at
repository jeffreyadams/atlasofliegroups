< facetious.at

{IF p has infl char singular on alphavee, then w(p)*rho is POS on alphavee}

set directedWeyl(RootDatum rd, [int] up, [int] down) = [WeylElt]:
    for w in W(rd) do if all(
    for m in up do rd.simple_coroots[m]*(w*rd.rho) > 0
    	     	od)
			and all(
    for n in down do rd.simple_coroots[n]*(w*rd.rho) < 0
    	     	od)

		      then [w]
		      else []
		      fi
		   od.##

set RDI(RootDatum Affd, ratvec gamma) = integrality_datum(Affd,gamma)
set Up(RootDatum Affd, ratvec gamma) = [int]:
    let rdI = RDI(Affd, gamma)
    in for alphavee@j in rdI.simple_coroots
    	      do if alphavee*gamma = 0
	      	 then [j]
		 else []
		 fi
	      od.##
set Down(RootDatum Affd, ratvec gamma) = [int]:
    let rdI = RDI(Affd, gamma)
    in for betavee@k in rdI.simple_coroots
    	      do if is_simple_root(Affd,rdI.simple_roots[k])
	      	    and betavee*gamma = 1
		 then [k]
		 else []
		 fi
	       od.##

set directedWeylA(RootDatum Affd, ratvec gamma) = [WeylElt]:
    let up = Up(Affd,gamma), down = Down(Affd,gamma), rdI = RDI(Affd,gamma)
    in directedWeyl(rdI, up, down)

set shiftsA(RootDatum Affd, ratvec gamma) = [ratvec]:
    let dwA = directedWeylA(Affd, gamma), rhoI = RDI(Affd, gamma).rho
    in for w in dwA do w*rhoI od

set Params(RootDatum Affd, ratvec gamma) = [Param]:
    let rdI = RDI(Affd, gamma)
    in all_parameters_gamma(rdI.complexification
			, gamma##(gamma+rdI.rho))

set GoodParams(RootDatum Affd, ratvec gamma) = [Param]:
    let params = Params(Affd, gamma), down = Down(Affd, gamma)
    	, up = Up(Affd, gamma)
    in for p in params
       do
		let testp = is_member(tau(p))
    	 	in if all(for k in down do testp(k) od)
		   then [p]
		   else[]
		   fi
       od.##

set shiftsB(RootDatum Affd, ratvec gamma) = [ratvec]:
    let GP = GoodParams(Affd, gamma), rdi = RDI(Affd,gamma)
    in for p in GP do (((p.x).involution)*(null(rdi.rank)##rdi.rho))[:rdi.rank]
       	     	   od

set openureAlcoves(RootDatum Affd, ratvec gamma) = [FacetVerts]:
    let FVs = fundamental_vertices(Affd), shifts = shiftsA(Affd,gamma)
    in for shift in shifts do let (wtilde,) = from_fundamental_alcove(Affd
							, gamma + shift/1000)
			      in wtilde*FVs
			   od
