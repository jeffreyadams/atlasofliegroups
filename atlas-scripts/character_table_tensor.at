<basic.at
<character_tables.at
<group_operations.at

{ combining rows representing characters to one for the product group }
set outer_tensor([int] char_1,[int] char_2)=[int]:
   for x in char_1 do for y in char_2 do x*y od od.##

set product(WeylClassTable Wct0, WeylClassTable Wct1) = WeylClassTable:
   let rd0=Wct0.root_datum, rd1=Wct1.root_datum
   then rd= rd0*rd1, n0=rd0.rank, n1=rd1.rank
   then embed(WeylElt w0,WeylElt w1) = WeylElt: { for rd }
           chamber(rd,(w0*two_rho(rd0))##(w1*two_rho(rd1)))
   , sizes0=Wct0.class_sizes(), sizes1=Wct1.class_sizes()
   then reps =
      for w0 in Wct0.class_representatives()
      do for w1 in Wct1.class_representatives()
         do embed(w0,w1)
	 od
      od.##
   , class_size(int i) = int:
      let (q,r)=i\%Wct1.n_classes in sizes0[q]*sizes1[r]
   , class(WeylElt w) = int:
      let v=w*two_rho(rd) then w0=chamber(rd0,v[:n0]), w1=chamber(rd1,v[n0:])
      in Wct0.class_of(w0)*Wct1.n_classes + Wct1.class_of(w1)
   , class_pow(int i,int k) = int:
      let (i0,i1)=i\%Wct1.n_classes
      in Wct0.class_power(i0,k)*Wct1.n_classes + Wct1.class_power(i1,k)
 in W_class_table(rd,reps,class_size,class,class_pow)

set tensor(CharacterTable ct1,CharacterTable ct2) = CharacterTable:
let m=ct1.n_classes, n=ct2.n_classes then
{
{0,1,...,mn-1} <-> {(a,b)| 0\le 1\le m-1, 0\le b\le n-1}
f:int ->(int,int) , g:(int,int)->int
are inverse bijections
}
f(int k)=(int,int): (k\n,k%n) then
g(int a,int b)=int:a*n+b  then
Wct = product(ct1.class_table,ct2.class_table) then
order=ct1.order*ct2.order then
n_classes=m*n then
class_label(int k)=let (a,b)=f(k) in ct1.class_label(a) + ct2.class_label(b) then
class_reps=[WeylElt]:
for k:n_classes do
 let (a,b)=f(k) then
  rd1=ct1.root_datum then
  rd2=ct2.root_datum then
  w1_word=ct1.class_rep(a).word then
  w2_word=ct2.class_rep(b).word then
  w2_word_shifted=for i in w2_word do i+rd1.ss_rank od then
  w_word=   w1_word##w2_word_shifted in
  W_elt(rd1*rd2,w_word) od then
class_order(int k)=let (a,b)=f(k) in ct1.class_order(a) * ct2.class_order(b) then
class_power(int i,int j)=let (a,b)=f(i) in g(ct1.class_power(a,j),ct2.class_power(b,j)) then
centralizer_orders=for i:m*n do
 let (a,b)=f(i) in ct1.centralizer_orders[a]*ct2.centralizer_orders[b] od then
class_sizes=for i:m*n do
 let (a,b)=f(i) in ct1.class_sizes[a]*ct2.class_sizes[b] od then
irreducible_label(int i)=let (a,b)=f(i) in ct1.irreducible_label(a)+ct2.irreducible_label(b) then
sym_powers_reflection=
 ##for char_1 in ct1.characters do
  for char_2 in ct2.characters do
   outer_tensor(char_1,char_2)
  od
 od then
degrees=for i:m*n do let (a,b)=f(i) in ct1.degrees[a]+ct2.degrees[b] od then
fake_degrees=
 if #ct1.fake_degrees=m and #ct2.fake_degrees=n then
   for i:m*n do let (a,b)=f(i) in ct1.fake_degrees[a]+ct2.fake_degrees[b] od
 else [] fi then
table=kronecker_product(ct1.table,ct2.table) in
(
Wct,
order,
(int n) int: let(a,b)=f(n) in g(ct1.to_class_table(a),ct2.to_class_table(b)),
(int m) int: let(x,y)=f(m) in g(ct1.from_class_table(x),ct2.from_class_table(y)),
n_classes,
(int j): null_class(),
class_label,
class_reps,
class_order,
class_power,
centralizer_orders,
class_sizes,
(int j): null_irrep(),
irreducible_label,
sym_powers_reflection,
degrees,
fake_degrees,
table)
