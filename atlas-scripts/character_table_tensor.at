<basic.at
<character_tables.at
<group_operations.at

{ combining rows representing characters to one for the product group }
set outer_tensor([int] char_1,[int] char_2)=[int]:
   for x in char_1 do for y in char_2 do x*y od od.##

set product(WeylClassTable Wct0, WeylClassTable Wct1) = WeylClassTable:
   let rd0=Wct0.root_datum, rd1=Wct1.root_datum
   then rd= rd0*rd1, n0=rd0.rank, n1=rd1.rank
   then embed(WeylElt w0,WeylElt w1) = WeylElt: { for rd }
           chamber(rd,(w0*two_rho(rd0))##(w1*two_rho(rd1)))
   , sizes0=Wct0.class_sizes, sizes1=Wct1.class_sizes
   then reps =
      for w0 in Wct0.class_representatives
      do for w1 in Wct1.class_representatives
         do embed(w0,w1)
	 od
      od.##
   , class_size(int i) = int:
      let (q,r)=i\%Wct1.n_classes in sizes0[q]*sizes1[r]
   , class(WeylElt w) = int:
      let v=w*two_rho(rd) then w0=chamber(rd0,v[:n0]), w1=chamber(rd1,v[n0:])
      in Wct0.class_of(w0)*Wct1.n_classes + Wct1.class_of(w1)
   , class_pow(int i,int k) = int:
      let (i0,i1)=i\%Wct1.n_classes
      in Wct0.class_power(i0,k)*Wct1.n_classes + Wct1.class_power(i1,k)
 in W_class_table(rd,reps,class_size,class,class_pow)

set tensor(CharacterTable ct1,CharacterTable ct2) = CharacterTable:
let m=ct1.n_classes, n=ct2.n_classes
then f(int k)=(int,int): (k\n,k%n)
, g(int a,int b)=int:a*n+b
, Wct = product(ct1.class_table,ct2.class_table)
, n_classes=m*n
then
  class_label(int k)=let (a,b)=f(k) in ct1.class_label(a)##ct2.class_label(b)
, irreducible_label(int i) = string:
   let (a,b)=f(i) in ct1.irreducible_label(a)+ct2.irreducible_label(b)
, degrees = [int]:
   for i:m*n do let (a,b)=f(i) in ct1.degrees[a]+ct2.degrees[b] od
, get_generic_degree (int i) = int:
    let (a,b)=f(i) then d1 = ct1.generic_degree(a), d2=ct2.generic_degree(b)
    in if d1.< or d2.< then minus_1 else d1+d2 fi
, set_generic_degree (int i, (->int) d, bool check) = int:
    error("Cannot set generic degrees for tensor table: set it for factors")
, has_generic_degree (int i) = bool:
    let (a,b)=f(i) in ct1.has_generic_degree(a) and ct2.has_generic_degree(b)
, table=kronecker_product(ct1.table,ct2.table)
in
( Wct
, Wct.class_representatives
, class_label
, (int j): null_class()
, (int j): null_irrep()
, irreducible_label
, degrees
, get_generic_degree, set_generic_degree, has_generic_degree
, table
)
