{ Functionality related to Lie types dans Dynkin diagrams }

<basic.at
<generics.at { for |fst| }
<sort.at { for |partition_by| }
<combinatorics.at { for |compose_permutation| }

{ Computing diagram automorphismes for a Lie type:
  For a Lie type, generate all diagram automorphisms as permutation vectors,
  whose positions correspond to nodes of the diagram, so size is semisimple rank.
}

set simple_automorphisms (string simple_type, int rank) = [vec]:
   let identity = vec: #rank
in case char_index(simple_type,"ABCDEFG")
   in {A} if rank<=1 then [identity] else [identity, ~identity] fi
   ,  {B} [identity]
   ,  {C} [identity]
   ,  {D} if rank=4
          then [identity,[0,1,3,2],[2,1,0,3],[2,1,3,0],[3,1,0,2],[3,1,2,0] ]
	  else [identity, identity[:2~] ## identity~[:2] ]
	  fi
   ,  {E} if rank=6 then [identity,[5,1,4,3,2,0] ] else [identity] fi
   ,  {F} [identity]
   ,  {G} [identity]
   ,  {T} error("Cannot list diagram automorphisms for torus factors")
   else error("Unknown Lie type ",simple_type,rank)
   esac

{ Find groups of equal simple factors. The caller should make sure not to pass
  both factors B2 and C2 in the same call: choose one of the two to prefer,
  and convert the other systematically to that one before calling us.
}
set permutable_types ([string,int] simple_factors) = [[int]]:
   let leq((string t0,int r0),(string t1,int r1)) = bool:
      if t0!=t1 then t0<=t1 else r0<=r1 fi
in partition_by ( (int i):simple_factors[i] , leq ) (# #simple_factors)

set diagram_automorphisms (LieType t) = Iterator<vec>:
(  let types = [string,int]: simple_factors(t)
   , n = semisimple_rank(t) { size of all permutations }
   then clusters = [[int]]: permutable_types(types).(filter(([int]a):#a>1))
   , simple_autos = [int,[vec]]:
     for type@i in types do (i,simple_automorphisms(type)) od
     .(filter((int.,[vec]a):#a>1))
in { replace second component of each |simple_autos| entry }
   for (k,autos)@i in simple_autos
   do let m=#autos
      then deltas = { left-multiply each entry by cyclically preceeding one }
	for pi@i in autos
	do compose_permutations(permutation_inverse(autos[(i-1)%m]),pi)
	od
      in simple_autos[i] := (k,deltas) { replace after all |autos| are used }
   od
;
{ variables for iteration }
   let go=true { set to false when |incr| cannot produce anything new }
   , cur = vec: #n { working permutation }
   , auto_position = [int,int]:
     { loop indices while traversing automorphisms, and their modulus }
     for (,autos) in simple_autos do ( 0, #autos ) od { intially indices are 0 }

{ constants for iteration }
   , starts = 0 # map(snd)(types).cumulate_forward
   , modulus = { orders of the lists of automoprhism that are run over }
     for (,autos) in simple_autos do #autos od
   , current_perm = [vec]: { for each cluster the currently used permutation }
     for c in clusters do #(#c) { cluster identity } od
   then
     advance(int start,vec delta) = void:
     { right-multiply by permutation |delta| lifted to simpla factor at |start }
        let snap = cur[start:start+#delta] { take snapshot of old values } in
        for dst@src in delta do cur[start+src] := snap[dst] od
   , install(int k, vec pi) = void: { install permutation |pi| of cluster |k| }
        let cl = [int]: clusters[k]
	then (,r) = types[cl[0]] { get rank of eash of the factors permuted }
	, st = for i in cl do starts[i] od { and starting points of each factor }
	in for d:r
	   do for dst@src in pi do cur[st[src]+d] := st[dst]+d od
	   od
in ( @Maybe<vec>:  { |get| method: value produced this iteration, if any }
     if go then some(cur) else none() fi
   , @void:
     for (c,m)@j in auto_position
     do let k = (c+1) % m { increment "|c|" }
     , (i,deltas) = simple_autos[j] { find index of simple factor }
     in auto_position[j] := (k,m) { replace |c| by |k| }
     ;  advance(starts[i],deltas[k])
     ;  if k>0 then return() fi { stop unless |k| was wrapped around }
     od
     { now all factor automorphism are back to identity; advan the permutations }
   ; for perm@j in current_perm { |perm| is permutation of clusters[j] }
     do case next_permutation(perm)
        | none(): ()
	| some(pi): install(j,current_perm[j] := pi); return()
	esac
     od
   ; go:=false
   )
)

set list_automorphisms (LieType t) = void:
   let (get,incr)=diagram_automorphisms(t)
in case get()
   | none: ()
   | some(auto): let go=true in
     while go
     do print(auto)
     next incr()
     ; case get() | none(): go:=false | some(permutation): auto:=permutation esac
     od
   esac