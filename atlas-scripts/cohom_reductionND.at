< basic {for required_solution, etc.}
< ratmat {for ratmat}
< induction {for theta-stable parabolics}
< derived_cover {to pass simple factors to derived simple factors}
<K_highest_weights {for K_highest_weight_from_K0_weight}
{< hash.at }{needed if the KGB-related hash tables are restored}
{placed in hermitian.at, where it belongs.}
{all root data live on same Z^n}
{The jth [int] sigmaj is the map of simple roots for the jth little_rd into simple roots for G.}
set resorted([RootDatum] little_rds, RootDatum rd) = [[int]]:
    for little_rd in little_rds
    do for alpha@j in little_rd.simple_roots
	  do find_vec(alpha,rd.simple_roots)
	  od
       od

{ND stands for non-derived: just use simple factors as Levis in G}
{ lists real and/or complex simple factors }
{warning: simple roots may be ordered differently in simple_factors than in G. Example
is G = SO(2) x SO(6): simple roots (0,1,2) for G become (1,0,2) in simple_factors(G)[0]}
set simple_factors(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
	simpleFactors = simple_factors(RootDatum: G), {these have simple roots reordered}
	Factors = [RealForm]:[]
{need to provide the permutation of the simple roots in}
{2/22/24: add sort}
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex).sort,
	 newDiagram = diagram_component(G,newSimpleRootIndex).sort
    then Diagram = if diagram=newDiagram
    	      	   then diagram
		   elif diagram[0] < newDiagram[0]
		     then (diagram##newDiagram).sort
	      	   else []
	      	   fi
    in if #Diagram > 0
       then Factors##:= [real_form(inner_class(sub_datum(G,Diagram), delta), delta, tf)]
       fi
    od; Factors

{projection from ratl coweight of G to coweight of S, respecting
values on roots of S}
set cowt_inclusions(RealForm G) = [(ratvec->ratvec)]:
    for S in simple_factors(G)
    do (ratvec->ratvec):
    (ratvec v) : sum(G.rank,
      for xi@j in fundamental_coweights(S) do (v*S.simple_roots[j])*xi od)
    od

{projection from ratl weight of G to ratl weight of S, respecting
values on roots of S}
set wt_projections(RealForm G) = [(ratvec->ratvec)]:
    for S in simple_factors(G)
    do (ratvec->ratvec):
    (ratvec gamma) : sum(G.rank,
      for xi@j in fundamental_weights(S) do (gamma*S.simple_coroots[j])*xi od)
    od

set factor_KGBs(KGBElt x) = [KGBElt]:
    let G = x.real_form
    then SF = simple_factors(G)
    in for S in SF {this is automatically a theta-stable Levi}
       do {inverse_embed_KGB(x, S) doesn't work}
       	  let (w,) = from_dominant(S, x.involution *S.two_rho)
       	  then winv = w.inverse
       	  in KGB_elt(S.inner_class, KGB(G,0).involution * winv,
       	     		torus_factor(x) {+G.rho_check - S.rho_check})
       od
 
{these cohom induce (on K level) to p, I think}
set factor_params(Param p) = [Param]:
    let PIs = wt_projections(p.real_form)
    in for xj@j in factor_KGBs(p.x)
       do parameter(xj, p.lambda - p.real_form.rho + xj.real_form.rho,
       	  		PIs[j](p.nu))
       od

{these comologically induce to mu (on K), I think}
set factor_K_types(KType mu) = [KType]:
    for xj@j in factor_KGBs(mu.x)
    do K_type(xj, mu.lambda_minus_rho)
    od

{these comologically induce to mu (on K), I think}
{x is supposed to be a fundamental fiber KGBElt}
set factor_K_types(KType mu, KGBElt x) = [KType]:
    for xj@j in factor_KGBs(x)
    do K_types(K_highest_weight_from_K0_weight(xj, K0_param(mu, x).lambda_minus_rho))[0]
    od


{WHY DON'T LKTs of factor_params match factor_K_types???}
{In changing nu can change KGBElt of final parameter}
{In SL(2), (2,[0],[1]) has x =2, but (2,[0],[0]) has TWO x's, 0 and 1.}

set derived_info(RealForm G) = (RealForm, mat):
    let (,M) = derived_info(G.root_datum)
    in (derived(G),M)

{ lists derived groups DS ofreal and/or complex simple factors S.
  Matrix M maps weights for S to weights for DS. Result is (S,DS,M)}
  {because of simple_factors, roots in S and DS can be ordered differently}
set derived_simple_factors_info(RealForm G) = [(RealForm,RealForm, mat)]:
    for S in simple_factors(G)
    do let (derS,M) = {derived_cover_real_form_info(S)} derived_info(S)
    then () = if Cartan_matrix(derS) != Cartan_matrix(S) then prints("S and derS permuted!") fi 
    in (S,derS,M)
    od

set derived_simple_factors(RealForm G) = [RealForm]:
    for S in simple_factors(G)
    do derived(S)
    od

{projection from ratl coweight of G to coweight of DS, respecting
values on roots of S}
set derived_cowt_inclusions(RealForm G) = [(ratvec->ratvec)]:
    for (S,derS,M) in derived_simple_factors_info(G)
    do (ratvec->ratvec):
    (ratvec v) : sum(G.rank,
      for xi@j in fundamental_coweights(derS) do (v*S.simple_roots[j])*xi od)
    od

{projection from ratl weight of G to rational weight of DS, respecting
values on roots of S}
set derived_wt_projections(RealForm G) = [(ratvec->ratvec)]:
    for (S,derS,M) in derived_simple_factors_info(G)
    do (ratvec->ratvec):
       (ratvec gamma) : sum(derS.rank,
      for xi@j in fundamental_weights(derS) do (M*gamma*derS.simple_coroots[j])*xi od)
    od

{for each RealForm, store an index into KGBElts x using the involution theta = x.involution and the highest
K-weight of the first LKT of parameter(x, G.rho, G.rho).}
{

set_type
[KGBElt_index =
( ( -> ) clear
  , ((RealForm,mat,vec) -> KGBElt) KGB_index {take x.theta and K0-highest weight of 1st
    			   	   	     LKT of parameter(x, G.rho, G.rho)}
)
]

set make_KGBElt_index () = KGBElt_index:
  let real_form_hash = make_RealForm_hash()
  then hwt_hashes = [vec_hash] : [] {one for each real form}
  then theta_hashes = [mat_hash] : [] {one for each real form}
  then index_hashes = [vec_hash] : [] {one for each real form}
  then add_real_form(RealForm S) = int:
     let RF = real_form_hash.size()
     then rf = real_form_hash.match(S)
     then () =  if rf = RF {haven't seen this real form before}
     	     	then let  () = hwt_hashes #:= make_vec_hash()
     		     then () = theta_hashes #:= make_mat_hash()
     		     then () = index_hashes #:= make_vec_hash()
     		     then () = for x in KGB(S)
     	       	     	       do let mus = LKTs(parameter(x, S.rho, S.rho))
			       	  then muwt =
				       for mu in LKTs(parameter(x, S.rho, S.rho))
				       do K0_param(mu).lambda_minus_rho
				       od.sort[0]
			       	  in index_hashes[RF].match([hwt_hashes[rf].match(muwt),
			   		theta_hashes[RF].match(x.involution)])
	       		       od
     		     then () = assert(real_form_hash.size() = #hwt_hashes,"KGB_index damaged")
     		     then () = assert(#index_hashes = #hwt_hashes,"KGB_index damaged")
     		     then () = assert(#theta_hashes = #hwt_hashes,"KGB_index damaged")
     		     in assert(index_hashes[RF].size() = #KGB(S), "KGB_index too small")
		fi
      in rf
   then clear() = void:
   	let () = real_form_hash.clear()
	then () = hwt_hashes := []
	then () = theta_hashes := []
	then () = index_hashes := []
	in ()
   in KGBElt_index:
   ( ( -> ): {clear} clear
   , ((RealForm, mat, vec)->KGBElt): {KGB_index} (RealForm S, mat theta, vec tau) KGBElt:
      let rf = add_real_form(S)
      in KGB(S, index_hashes[rf].match([hwt_hashes[rf].match(tau), theta_hashes[rf].match(theta)])  )
   )

set KGBIndex = make_KGBElt_index()
}
{x is a KGBElt for G; want to pass to a KGBElt for each derived simple factor}
set derived_factor_KGBs(KGBElt x) = [KGBElt]: {need to change this to use highest weights somehow...}
    let derSF = derived_simple_factors_info(x.real_form)
    in for (S,derS,M) in derSF {this is automatically a theta-stable Levi}
       do let derSsimp = derS.simple_roots
	  then DderS = det(derSsimp)
	  then Minv = required_solution(derS.simple_roots.^, DderS*S.simple_roots.^).^/DderS
	  then () = assert(let (N,,denom) = M*Minv in denom = 1 and N = id_mat(derS.rank),
	       	    	       "bad Minv in derived_factor_KGBs")
       	  then dertheta = ratmat_as_mat(M*x.involution*Minv)
       	  then derx = KGB_elt(derS.inner_class, dertheta, torus_factor(x)*Minv)
	  then derSprime = derx.real_form
	  then () = derx := KGB(derS, KGB_elt(derS.inner_class, dertheta, torus_factor(x)*Minv).number)
	  in derx
       od

set old_derived_flag = false
{x is a KGBElt for G; want to pass to a KGBElt for each derived simple factor}
{
set derived_factor_KGBs3(KGBElt x) = [KGBElt]:
if old_derived_flag then return derived_factor_KGBs(x) fi;
    let G = x.real_form
    then derSF = derived_simple_factors_info(G), P = projection_to_K_matrix(G)
    then () = if #derSF = 1 and G.components_rank.=
    	      then let (,derS,) = derSF[0]
	      	   in return [KGB(derS,x.number)]
	      fi
    then Pinv = right_inverse(P)
    then derPs = for (S,derS,) in derSF do projection_to_K_matrix(derS) od
    in for (S,derS,M)@j in derSF {this is automatically a theta-stable Levi}
       do let mus = LKTs(parameter(x, G.rho, G.rho))
       	  then muwts = for mu in mus do K0_param(mu).lambda_minus_rho od {on K-torus for G}
	  then DderS = det(derS.simple_roots)
	  then Minv = required_solution(derS.simple_roots.^, DderS*S.simple_roots.^).^/DderS
	  then dermuwt = for muwt in muwts do derPs[j]*M*Pinv*muwt od.sort[0],  {worry about numbering of LKTs}
	       dertheta = ratmat_as_mat(M*x.involution*Minv)
	  in KGBIndex.KGB_index(derS, dertheta, dermuwt)
        od
}

{x is a KGBElt for G; want to pass to a KGBElt for each derived simple factor}
set derived_factor_KGBs2(KGBElt x) = [KGBElt]:
    if old_derived_flag then return derived_factor_KGBs(x) fi;
    let G = x.real_form
    then derSF = derived_simple_factors_info(G)
    then () = if #derSF = 1 and G.components_rank.=
    	      then let (,derS,) = derSF[0]
	      	   in return [KGB(derS,x.number)]
	      fi
    then tf = torus_factor(x), theta = x.involution
    then derPs = for (S,derS,) in derSF do projection_to_K_matrix(derS) od
    in for (S,derS,M)@j in derSF {this is automatically a theta-stable Levi}
       do let DderS = det(derS.simple_roots)
	  then Minv = required_solution(derS.simple_roots.^, DderS*S.simple_roots.^).^/DderS
	  then dertheta = ratmat_as_mat(M*x.involution*Minv)
	  in KGB(derS)[KGB_elt(derS.root_datum, dertheta, tf*Minv).number]
       od

set derived_factor_params(Param p) = [Param]:
    let DSFinfo = derived_simple_factors_info(p.real_form)
    in for xj@j in derived_factor_KGBs(p.x)
       do let (,DS,M) = DSFinfo[j]
       	  in parameter(xj, M*(p.lambda_minus_rho) + DS.rho, M*p.nu)
       od

set derived_factor_params2(Param p) = [Param]:
if old_derived_flag then return derived_factor_params(p) fi;
    let DSFinfo = derived_simple_factors_info(p.real_form)
    {let DPIs = derived_wt_projections(p.real_form)
    in}
    in for xj@j in derived_factor_KGBs2(p.x)
       do let (,DS,M) = DSFinfo[j]
       	  in parameter(xj, M*(p.lambda_minus_rho) + DS.rho, M*p.nu)
       od

set dfkiTime = int: 0

{L is Levi; has bunch of simple factors S (same rank as L), derived groups derS (simple!)}
{M maps X^* for L to X^* for derS}
{these comologically induce to mu (on K), I think}
set derived_factor_K_types_info(KType mu) = [(KType,mat)]:
    let start = elapsed_ms(), L = mu.real_form
    then DSFinfo = derived_simple_factors_info(L)
    then derSs = for (,derS,) in DSFinfo
    	       	 do derS
		 od
    then xcLs = for (,derS,M) in DSFinfo
    	       	do embed_KGB(KGB(derS,0),L,M)
	        od
    then muwts = for xcL in xcLs {highest wts for mu aligned with
    	       	     	    	 various derS}
    	       	 do K0_param(mu,xcL).lambda_minus_rho
		 od
    then derwts = for (S,derS,M)@j in DSFinfo
    	 	  do let derMK = projection_to_K_matrix(derS), MK = projection_to_K_matrix(S)
		     then MKinv = right_inverse(MK)
		     in derMK*ratvec_as_vec(
		     	sum(derS.rank, for alpha@k in simple_roots(derS)
    	 	     		       do (S.fundamental_coweights[k]*MKinv*muwts[j])*
						alpha
		     		       od))
		  od
    then answer = for derwt@j in derwts
       do let (,derS,M) = DSFinfo[j]
       	  in (K_types(K_highest_weight_from_K0_weight(KGB(derS,0),
		derwt))[0],M)
       od
   then () = assert(none(for (dermu,) in answer do is_zero(dermu) od), "zero K-type in derived_factor_K_types_info")
   then () = dfkiTime +:= elapsed_ms() - start
   in answer
{in case of mu = LKT(140,[5,3,3,1,1,-1]/2, [1,0,0,-1,0,0]/2), below fails in U(3,3)}
{    in for xj@j in derived_factor_KGBs(mu.x)
       do let (,,M) = DSFinfo[j]
       	  then muj = K_type(xj, M*mu.lambda_minus_rho)
	  in (muj,M)
       od}

{these comologically induce to mu (on K), I think}
{
set derived_factor_K_types_info3(KType mu) = [(KType,mat)]:
if old_derived_flag then return derived_factor_K_types_info(mu) fi;
    let start = elapsed_ms(), L = mu.real_form
    then DSFinfo = derived_simple_factors_info(L), P = projection_to_K_matrix(L)
    then Pinv = right_inverse(P)
    then derPs = for (,derS,) in DSFinfo do projection_to_K_matrix(derS) od
    then answer =  for (,derS,M)@j in DSFinfo {this is automatically a theta-stable Levi}
       	 	   do let dermuwt = derPs[j]*M*Pinv*K0_param(mu).lambda_minus_rho
          	      in (K_types(K_highest_weight_from_K0_weight(KGB(derS,0),dermuwt))[0], M)
       		   od
    then () = assert(none(for (dermu,) in answer do is_zero(dermu) od), "zero K-type in derived_factor_K_types_info")
    then () = dfkiTime +:= elapsed_ms() - start
    in answer
}

{these comologically induce to mu (on K), I think}
set derived_factor_K_types_info2(KType mu) = [(KType,mat)]:
if old_derived_flag then return derived_factor_K_types_info(mu) fi;
    let start = elapsed_ms(), L = mu.real_form
    then DSFinfo = derived_simple_factors_info(L), P = projection_to_K_matrix(L)
    then Pinv = right_inverse(P)
    then derPs = for (,derS,) in DSFinfo do projection_to_K_matrix(derS) od
    then answer = for (,derS,M)@j in DSFinfo {this is automatically a theta-stable Levi}
       	 	  do (K_type(derived_factor_KGBs2(mu.x)[j], M*(mu.lambda_minus_rho)), M)
       		  od
    then () = dfkiTime +:= elapsed_ms() - start
    in answer

{these comologically induce to mu (on K), I think}
set derived_factor_K_types(KType mu) = [KType]:
    for (muj,) in derived_factor_K_types_info(mu)
    do muj
    od

{these comologically induce to mu (on K), I think}
set derived_factor_K_types2(KType mu) = [KType]:
if old_derived_flag then return derived_factor_K_types(mu) fi;
    for (muj,) in derived_factor_K_types_info2(mu)
    do muj
    od

{WHY DON'T LKTs of factor_params match factor_K_types???}
{In changing nu can change KGBElt of final parameter}
{In SL(2), (2,[0],[1]) has x =2, but (2,[0],[0]) has TWO x's, 0 and 1.}
