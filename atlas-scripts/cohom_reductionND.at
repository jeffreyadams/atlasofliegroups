< basic {for required_solution, etc.}
< ratmat {for ratmat}
< induction {for theta-stable parabolics}
< derived_cover {to pass simple factors to derived simple factors}
<K_highest_weights {for K_highest_weight_from_K0_weight}
<cross_W_orbit.at {for cross_divide}
{< hash.at }{needed if the KGB-related hash tables are restored}
{placed in hermitian.at, where it belongs.}
{all root data live on same Z^n}
{The jth [int] sigmaj is the map of simple roots for the jth little_rd into simple roots for G.}

{whether to store computed paths}
set KGB_path_hash_flag = false

{chain of cross/Cayley to go from x to KGB(G,0). If the bool is true, then cross; else Cayley.
The reverse path goes from KGB(G,0) to x.}
set direct_path (KGBElt x) = [(int,bool)]:
    let G = x.real_form
    then p = parameter(x, G.rho,G.rho)
    then answer = [(int,bool)]: []
    then y = KGBElt: x
    then () = while length(y) > 0
    	      do let jC = first(for j:G.semisimple_rank
	      	       	       do length(cross(j,y)) < length(y)
			       od)
       	      	 in if jC.>=
		    then let () = y:= cross(jC,y)
       		      	 then () = answer #:= (jC,true)
       		 	 in p := parameter(y,G.rho,G.rho)
	            else let jr = first(for j:G.semisimple_rank
			      	       	     do length(Cayley(j,y)) < length(y)
					     od)
			 then () = y:= Cayley(jr,y)
			 then () = answer #:= (jr,false)
			 in p := parameter(y,G.rho,G.rho)
		    fi
    	      od
    {now y is fundamental}
    {then () = prints(y)}
    then word = word(cross_divide(y,KGB(G,0)))
    then () = answer ##:= for j in word do (j,true) od
    in answer

set rf_path_hash = make_RealForm_hash()

{one list for each rf in rf_path_hash; size #KGB(rf). Entry #x is path(x).} 
set path_lists = [[[(int,bool)]]]: []

set path(KGBElt x) = [(int,bool)]:
    if KGB_path_hash_flag
    then let G = x.real_form
    	 then I = rf_path_hash.size()
    	 then i = rf_path_hash.match(G)
   	 then () = if i = I {haven't seen this real form}
    	      	   then path_lists#:= for j:#KGB(G) do [(int,bool)]: [] od
	      	   fi
    	then num = x.number, pathlistsi = path_lists[i]
    	then () = if num > 0 and (#pathlistsi[num]).=
    	      then pathlistsi[num] := direct_path(x);
	      	   path_lists[i]:=pathlistsi
	      fi
    	in path_lists[i][num]
    else direct_path(x)
    fi

set clear_path() = void:
    rf_path_hash.clear(); path_lists:= []

set KGB_by_path(RealForm G, [int,bool] path) = KGBElt:
    let answer = KGB(G,0)
    then () = for (j,flag) in path
    	      ~do answer := if flag then cross(j,answer)
	      	 	    else Cayley(j,answer)
			    fi
	      od
    in answer

{ith list finds simple roots for rds[i] in simple roots for rd}
set resorted([RootDatum] little_rds, RootDatum rd) = [[int]]:
    for little_rd in little_rds
    do for alpha@j in little_rd.simple_roots
	  do find_vec(alpha,rd.simple_roots)
	  od
       od

{ND stands for non-derived: just use simple factors as Levis in G}
{ lists real and/or complex simple factors }
{warning: simple roots may be ordered differently in simple_factors than in G. Example
is G = SO(2) x SO(6): simple roots (0,1,2) for G become (1,0,2) in simple_factors(G)[0]}
set simple_factorsRF(RealForm G) = [RealForm]:
    let delta=G.distinguished_involution, tf=KGB(G,0).torus_factor,
	simpleFactors = simple_factors(RootDatum: G), {these have simple roots reordered}
	Factors = [RealForm]:[]
{need to provide the permutation of the simple roots in}
{2/22/24: add sort}
    in
    for rd@i in simpleFactors
    do
    let root = simple_roots(rd)[0]
    then newRoot = delta*root
    then simpleRootIndex = simple_root_index(G,root),
	 newSimpleRootIndex = simple_root_index(G,newRoot)
    then diagram = diagram_component(G,simpleRootIndex).sort,
	 newDiagram = diagram_component(G,newSimpleRootIndex).sort
    then Diagram = if diagram=newDiagram
    	      	   then diagram
		   elif diagram[0] < newDiagram[0]
		     then (diagram##newDiagram).sort
	      	   else []
	      	   fi
    in if #Diagram > 0
       then Factors##:= [real_form(inner_class(sub_datum(G,Diagram), delta), delta, tf)]
       fi
    od; Factors

{if the kth entry is (i,j), then G-simple root k belongs to ith simple factor and is #j there}
set G_root_labels(RealForm G) = [(int,int)]:
    let Sindexers = for S in simple_factorsRF(G)
    	      	    do simple_root_index(S)
		    od
    in for alpha in G.simple_roots
       do let inds = for f in Sindexers
       	   	     do f(alpha)
		     od
       	  then i = first(for j in inds do j.>= od)
       	  in (i, inds[i])
       od

{if the jth entry  of the ith list is k, then G-simple root k belongs to ith simple factor and is #j there}
set G_inverse_root_labels(RealForm G) = [[int]]:
    let Gindexer = simple_root_index(G)
    in for S in simple_factorsRF(G)
       do for alpha in S.simple_roots
       	  do Gindexer(alpha)
          od
       od

{takes a path on each simple factor of G and glues them into a path on G}
set glue_paths(RealForm G, [[int,bool]] factor_paths) = [int,bool]:
    let inverse_labels = G_inverse_root_labels(G)
    in 	for path@i in factor_paths
       	do for (j,flag) in path
	   do (inverse_labels[i][j],flag)
	   od
	od.##

set factor_paths(RealForm G, [int,bool] path) = [[int,bool]]:
    let labels = G_root_labels(G)
    then factor_paths = [[int,bool]]: for S in simple_factorsRF(G) do [] od
    then () = for (k,flag) in path
       	      do let (i,j) = labels[k]
       	      	 in factor_paths[i] #:= (j,flag)
       	      od
    in factor_paths

{projection from ratl coweight of G to coweight of S, respecting
values on roots of S}
set cowt_inclusions(RealForm G) = [(ratvec->ratvec)]:
    for S in simple_factorsRF(G)
    do (ratvec->ratvec):
    (ratvec v) : sum(G.rank,
      for xi@j in fundamental_coweights(S) do (v*S.simple_roots[j])*xi od)
    od

{projection from ratl weight of G to ratl weight of S, respecting
values on roots of S}
set wt_projections(RealForm G) = [(ratvec->ratvec)]:
    for S in simple_factorsRF(G)
    do (ratvec->ratvec):
    (ratvec gamma) : sum(G.rank,
      for xi@j in fundamental_weights(S) do (gamma*S.simple_coroots[j])*xi od)
    od

set factor_KGBs0(KGBElt x) = [KGBElt]:
    let G = x.real_form
    then SF = simple_factorsRF(G)
    then path = path(x)
    then fac_paths = factor_paths(G,path)
    in for S@i in SF {this is automatically a theta-stable Levi}
       do KGB_by_path(S,fac_paths[i])
       od
{invert previous function}
set glue_KGBs(RealForm G, [KGBElt] xis) = KGBElt:
    KGB_by_path(G, glue_paths(G, for xi in xis do path(xi) od))

{these cohom induce (on K level) to p, I think}
set factor_params0(Param p) = [Param]:
    let PIs = wt_projections(p.real_form)
    in for xj@j in factor_KGBs0(p.x)
       do parameter(xj, p.lambda - p.real_form.rho + xj.real_form.rho,
       	  		PIs[j](p.nu))
       od

{these comologically induce to mu (on K), I think}
{x is supposed to be a fundamental fiber KGBElt}
set factor_K_types0(KType mu, KGBElt x) = [KType]:
    for xj@j in factor_KGBs0(x)
    do K_types(K_highest_weight_from_K0_weight(xj, K0_param(mu, x).lambda_minus_rho))[0]
    od


{WHY DON'T LKTs of factor_params match factor_K_types???}
{In changing nu can change KGBElt of final parameter}
{In SL(2), (2,[0],[1]) has x =2, but (2,[0],[0]) has TWO x's, 0 and 1.}

set derived_info(RealForm G) = (RealForm, mat):
    let (,M) = derived_info(G.root_datum)
    in (derived(G),M)

{ lists derived groups DS of real and/or complex simple factors S.
  Matrix M maps weights for S to weights for DS. Result is (S,DS,M)}
  {because of simple_factors, roots in S and DS can be ordered differently}{NO??}
set derived_simple_factors_info(RealForm G) = [(RealForm,RealForm, mat)]:
    for S in simple_factorsRF(G)
    do let (derS,M) = {derived_cover_real_form_info(S)} derived_info(S)
    then () = if Cartan_matrix(derS) != Cartan_matrix(S) then prints("S and derS permuted!") fi 
    in (S,derS,M)
    od

set derived_simple_factorsRF(RealForm G) = [RealForm]:
    for S in simple_factorsRF(G)
    do derived(S) 
    od

set derived_paths(RealForm G, [int,bool] path) = [[int,bool]]:
    factor_paths(G,path)

set DFK_time = int: 0

set derived_factor_KGBs0(KGBElt x) = [KGBElt]:
    let G = x.real_form, start = elapsed_ms()
    then path = path(x)
    then der_paths = derived_paths(G,path)
    then answer = for derS@i in derived_simple_factorsRF(G)
       	 	  do KGB_by_path(derS,der_paths[i])
       		  od
    then () = DFK_time +:= elapsed_ms() - start
    in answer

{projection from ratl coweight of G to coweight of DS, respecting
values on roots of S}
set derived_cowt_inclusions(RealForm G) = [(ratvec->ratvec)]:
    for (S,derS,) in derived_simple_factors_info(G)
    do (ratvec->ratvec):
    (ratvec v) : sum(G.rank,
      for xi@j in fundamental_coweights(derS) do (v*S.simple_roots[j])*xi od)
    od

{projection from ratl weight of G to rational weight of DS, respecting
values on roots of S}
set derived_wt_projections(RealForm G) = [(ratvec->ratvec)]:
    for (S,derS,M) in derived_simple_factors_info(G)
    do (ratvec->ratvec):
       (ratvec gamma) : sum(derS.rank,
      for xi@j in fundamental_weights(derS) do (M*gamma*derS.simple_coroots[j])*xi od)
    od

set derived_factor_params0(Param p) = [Param]:
    let DSFinfo = derived_simple_factors_info(p.real_form)
    in for xj@j in derived_factor_KGBs0(p.x)
       do let (,DS,M) = DSFinfo[j]
       	  in parameter(xj, M*(p.lambda_minus_rho) + DS.rho, M*p.nu)
       od


set dfkiTime = int: 0

{these comologically induce to mu (on K), I think}
set derived_factor_K_types_info0(KType mu) = [(KType,mat)]:
    let start = elapsed_ms(), L = mu.real_form
    then DSFinfo = derived_simple_factors_info(L), P = projection_to_K_matrix(L)
    then Pinv = right_inverse(P)
    then derPs = for (,derS,) in DSFinfo do projection_to_K_matrix(derS) od
    then answer = for (,derS,M)@j in DSFinfo {this is automatically a theta-stable Levi}
       	 	  do (K_type(derived_factor_KGBs0(mu.x)[j], M*(mu.lambda_minus_rho)), M)
       		  od
    then () = dfkiTime +:= elapsed_ms() - start
    in answer

{these comologically induce to mu (on K), I think}
set derived_factor_K_types0(KType mu) = [KType]:
    for (muj,) in derived_factor_K_types_info0(mu)
    do muj
    od

{if jth derived_simple_factorRF(G) =dLj has rank d, then jth entry is rk G x d
matrix carrying wts on dLj to wts on G}
set derived_factor_weight_inclusions(RealForm G) = [(ratvec->ratvec)]:
    let dLs = derived_simple_factorsRF(G), Ls = simple_factorsRF(G)
    {then () = prints("dLs = ",dLs)}
    in for dL@j in dLs
       do {prints("dL = ",dL);} (ratvec->ratvec): (ratvec vj):
       	  sum(G.rank, for avee@i in dL.simple_coroots
       	      	      do {prints("avee = ",avee,", vj = ",vj);}
		      (avee*vj)*G.fundamental_weights[resorted(
		      	 for L in Ls do L.root_datum od
			 ,G)[j][i]]
		      od)
       od

{take a family of parameters on each derived simple factor of G and glue them into parameters on G,
restricting to central weight v on z(g)}
set glue_params(RealForm G, [[Param]] drfs, ratvec shift) = [Param]:
    if any(for list in drfs do (#list).= od) then return [] fi;
    let gamma_hashes = for list in drfs do make_ratvec_hash() od
    then p_hashes = for list in drfs do make_Param_hash() od
    then () = for list@j in drfs {these are the rep factors on simple factor #j}
    	      do for p in list
    	      	 do gamma_hashes[j].match(p.infinitesimal_character)
    	      	  ; p_hashes[j].match(p)
		 od
	      od
    then Ms = derived_factor_weight_inclusions(G)
    then gamma_factors_lists = for gamma_hash in gamma_hashes do gamma_hash.list() od
    then sizes = for list in gamma_factors_lists do #list od
    then gammas = for b in box(sizes)
    	 	  do shift + sum(G.rank,
		     for list@j in gamma_factors_lists
		     do Ms[j](list[b[j]])
    	 	     od)
		  od
    	 {one gamma_j from each list, move to G, sum}
    then pGs = for gamma@j in gammas
    	       do all_parameters_gamma(G,gamma)
	       od.##
{
    	       do let rdgamma = integrality_datum(G,gamma)
	       	  then tau = [int]:
	       	       for avee@k in rdgamma.simple_coroots
		       do if (avee*gamma).=
		       	  then []
			  else [k]
			  fi
		       od.## {tau = list of simple integral coroots nonzero on gamma}
	       	  in for p in all_parameters_gamma(G,gamma)
		     do if contains(tau)(tau(p))
		     	then [p]
			else []
			fi
		     od.## {these are the ones at gamma with correct tau}
	      od.##
}
    in for p in pGs
       do let derps = derived_factor_params0(p)
       	  in if all(for derpj@j in derps
	     	    do p_hashes[j].lookup(derpj).>= od)
	     then [p]
	     else []
	     fi
       od.##

{take a family of parameters on each derived simple factor of G and glue them into parameters on G}
set glue_params(RealForm G, [[Param]] drfs) = [Param]:
    glue_params(G, drfs, null(G.rank))

{one Param on each derived simple factor}{BROKEN}
set glue_params(RealForm G, [Param] drfs, ratvec shift) = Param:
    let x = glue_KGBs(G, for drf in drfs do drf.x od),  dfwis = derived_factor_weight_inclusions(G)
    then lambda = sum(G.rank, for drf@j in drfs do dfwis[j](drf.lambda) od) + shift
    then nu = sum(G.rank, for drf@j in drfs do dfwis[j](drf.nu) od) + shift
    in parameter(x,lambda,nu)
    {glue_params(G,for p in drfs do [p] od,shift)[0]}

{Here mu0 is meant to be a base K-type on G from which all targets differ by a sum of roots}

{x0 is a fundamental KGBElt on G, and derx0s its factors. There is a secret K-type mu0 on G
differing from the desired glue by a sum of roots. If dermus are its factors, then

shift = highest_weight(mu0,x0) - sum_j dfwjs[j](highest_weight(dermus[j],derx0s[j]).mu)
}
set glue_K_types([KType] dermus, [(ratvec->ratvec)] dfwjs, KGBElt x0,
    [KGBElt] derx0s, ratvec shift) = KType:
    K_type(KHighestWeight:((),x0, (sum(#shift, for dermu@j in dermus do
    		dfwjs[j](highest_weight(dermu, derx0s[j]).mu) od) + shift).numer))


set glue_K_types(RealForm G, [KType] muis, KType mu0) = KType:
    let G = mu0.real_form
    then x0 = KGB(G,0), dfwis = derived_factor_weight_inclusions(G)
    then derx0s = derived_factor_KGBs0(x0), dermu0s = derived_factor_K_types0(mu0)
    then base = highest_weight(mu0, x0).mu
    then derbases = for dermu0@j in dermu0s do highest_weight(dermu0s[j], derx0s[j]).mu od
    then root_shifts = for mui@j in muis do highest_weight(mui, derx0s[j]).mu - derbases[j] od
    in K_type(KHighestWeight:((),x0, base + sum(G.rank,
       for shift@j in root_shifts do dfwis[j](shift).numer od)))
    { let x = glue_KGBs(G, for mui in muis do mui.x od), dfwis = derived_factor_weight_inclusions(G)
    then lambda = sum(G.rank, for mui@j in muis do dfwis[j](mui.lambda - mui.real_form.rho) od) + 
    	 gamma + G.rho
    in LKTs(parameter(x,lambda,null(G.rank)))[0]}
    {K_type(KHighestWeight:((),x,lambda))}

    {LKT(glue_params(G, for mui in muis do param(mui) od, gamma))}

{??? this fails with gamma = projection on center of infinitesimal character for G ???  }
{take signatures on each derived simple factor of G and glue them into a signature on G}
{the K-type mu0 on G  meant to differ from everything in the image by a sum of roots}
set glue_sigs([KTypePol] sigs, KType mu0) = KTypePol:
    let G = mu0.real_form
    then x0 = KGB(G,0), dermu0s = derived_factor_K_types0(mu0)
    then dfwis = derived_factor_weight_inclusions(G), derx0s = derived_factor_KGBs0(x0)
    then shift = highest_weight(mu0,x0).mu - (sum(G.rank, for dermu0@j in dermu0s
    	 do dfwis[j](highest_weight(dermu0,derx0s[j]).mu) od))
    then B = box(for sig in sigs do #sig od)
    then factor_terms = for sig in sigs
    	 	      	do for c@m in sig do (c,m) od
			od
    then terms = [Split, KType]: {one term for each b in box}
    	 for b in B
    	 do let c = Split:1, ms = [KType]:[]
	    then () = for bi@i in b
		      do let (ci,mi) = factor_terms[i][bi]
	              	 then () = c*:= ci
		    	 in ms #:= mi
		      od
	    in (c, glue_K_types(ms,dfwis,x0,derx0s,shift))
	 od
    in sum(G, for (c,m) in terms do c*m od)