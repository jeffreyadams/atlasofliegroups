<basic.at
<sort.at { for |ranking @ A (A,A->bool)| }
<W_classes.at { definition of |WeylClassTable| and supporting functions }
<combinatorics.at { functions for specific classical types }
<lietypes.at

{ The purpose of this module is to group case-by-case definitions of W-class
  tables for root data with a specified simple Cartan matrix type, and give a
  definion of |class_table@RootDatum|. The latter employs the decomposition of
  the Dynkin diagram of a root datum into connected components, in order to
  build up, for a general root datum, a |WeylClassTable| built up from those for
  appropriate sub-root-data.
}


{ The following method to combine conjugacy class tables of Weyl groups for root
  subdata whose simple roots form a mutually orthogonal partition of the simple
  roots of |rd| can be given before doing any of the case-by-case stuff.
  Explicitly passing |rd| as argument allows the proper renumbering to be
  applied when passing to and from the Weyl group of the full root datum.
}
set combine(RootDatum rd,[WeylClassTable] tables) = WeylClassTable:
(  let rds = for table in tables do table.root_datum od
   , radix = for table in tables do table.n_classes od { mixed radix list }
   , tr = two_rho(rd)
in assert(for rdj@j in rds
             for i:j { iterate of all pairs |i<j| }
	     do (^simple_coroots(rds[i]) * simple_roots(rdj)).=
	     od
	  od.all,"Factors are not mutually orthogonal")
;  let reps = [[WeylElt]]: { all class representatives, lifted to |rd| }
      for table in tables
      do for w in table.class_representatives do chamber(rd,w*tr) od
      od
   , words = all_words(radix) { mixed radix representations of class numbers }
   , index = mixed_radix_nr(radix) { map from |word| to its index in |words| }
   , project_W = [(WeylElt->WeylElt)]: { projectors to component Weyl groups }
      for rdi in rds
      do let tri = two_rho(rdi) in (WeylElt w): chamber(rdi,w*tri)
      od
in W_class_table
   ( rd
   , for word in words do product(rd,for n@i in word do reps[i][n] od) od
   , (int N) int: { class size }
     for l@i in words[N] do tables[i].class_sizes[l] od.product
   , (WeylElt w) int: { class number }
        for proj@i in project_W do tables[i].class_of(proj(w)) od.index
   , (int N,int k) int:
	for n@i in words[N] do tables[i].class_power(n,k) od.index
   )
)

{				type A				}

{ get an actual WeylElt from a partition <-> conjugacy class in W}
set conjugacy_class_S(Partition P) = WeylElt:  {for GL(n)}
(  assert(is_positive(P), "P is not a partition (has non-positive entries)")
;  let (n, , simples) = Levi_A(P)
in W_elt(if =n then trivial_group else GL(n) fi,simples)
)

{ for other type A root data like SL(n), we need to work a bit harder }
set conjugacy_class_A(RootDatum rd) = (Partition->WeylElt):
   let map = test_simple_type("A",rd) in
   (Partition P) WeylElt:
(  assert(is_positive(P), "P is not a partition (has non-positive entries)")
;  let (n, , simples) = Levi_A(P)
in assert(n=#map+1,"Partition is of "+ n +" rather than "+(#map+1))
;  W_elt(rd,for s in simples do map[s] od)
)

{ The inverse operation, find cycle type of a WeylElt for GL(n). This could be
  done using |classic_permutation| and |cycle_type| from combinatorics.at, but
  knowing that we have a GL(n) element, we can be a bit more efficient.
}
set cycle_type_GL (WeylElt w) = Partition:
  let n=w.root_datum.rank in cycle_type((vec:#n)*w)

{ sometimes we can avoid sorting the cycles into decreasing length order }
set unsorted_cycle_type_GL (WeylElt w) = [int]:
  let n=w.root_datum.rank in
  for cycle in permutation_cycles((vec:#n)*w) do #cycle od

set class_table_S (int n) = WeylClassTable:
  let rd=GL(n), reps = [Partition]: partitions(n)
  then lookup = (Partition->int): index_partition(reps)
  in W_class_table(rd, for rep in reps do conjugacy_class_S(rep) od
		  , (int i)int: cycle_class_size(reps[i])
		  , (WeylElt w) int: lookup(cycle_type_GL(w))
		  , (int i,int k)int: lookup(cycle_power(reps[i],k))
		  )

set class_table_A (RootDatum rd) = WeylClassTable:
  let partitions = [Partition]: partitions(rd.semisimple_rank+1)
  , type(WeylElt w) = Partition: cycle_type(classic_permutation(w))
  , class_rep = (Partition->WeylElt): conjugacy_class_A(rd)
  then lookup = (Partition->int): index_partition(partitions)
  in W_class_table( rd, for lambda in partitions do class_rep(lambda) od
		  , (int i)int: cycle_class_size(partitions[i])
		  , (WeylElt w) int: lookup(type(w))
		  , (int i,int k)int: lookup(cycle_power(partitions[i],k))
		  )

{				types B,C				}

set BC_classes (int n) = [Signed_cycles]:
   for PQ in partition_pairs(n) do to_cycles(PQ) od

{ word representative in types B and C of conjugacy class for partition pair;
  the parts of P correspond to are cycles without flip, those of Q with flip }
set class_word_BC (Partition P,Partition Q) = [int]:
(  assert((P:=P.strip_to_partition).>, "P is not a partition")
;  assert((Q:=Q.strip_to_partition).>, "Q is not a partition")
;  let (nP,,P_gens)=Levi_A(P) { for P part, do the same as in type A }
   , (nQ,,simples)=Levi_A(Q) { for Q part we need to post-process |simples| }
then
   Q_gens = { each cycle from Q gets a sign flip when its end is sensed }
      let j=0 { position in simples } in
      for i:nQ
      do let pos=nP+i { position in [0,n) where we are }
      in if j<#simples and i=simples[j] then j+:=1; [pos] { extend our cycle }
         else { tack on a sign flip at the final element of the cycle }
	    for k:nQ-i from pos do k od## for k:nQ-1-i from pos ~do k od
	 fi
      od.##
in P_gens##Q_gens
)


{ for general type B root data, we need to look up and use the diagram order }
set conjugacy_class_B (RootDatum rd) = (BiPartition->WeylElt):
   let map = test_simple_type("B",rd) then n=#map in
   (BiPartition pair) WeylElt:
(  let size = rank(pair)
in assert(size=n,"Cycles sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word_BC(pair) do map[s] od)
)

set class_table_B (int n) = WeylClassTable:
   let rd=SO(n+n+1), classes = [BiPartition]: partition_pairs(n)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do W_elt(rd,class_word_BC(pair)) od
		, (int i)int: cycle_class_size(classes[i].to_cycles)
		, (WeylElt w) int: lookup(cycle_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

set class_table_B (RootDatum rd) = WeylClassTable:
   let classes = [BiPartition]: partition_pairs(rd.semisimple_rank)
   , type_code(WeylElt w) = [int]: signed_cycle_type_code(classic_permutation(w))
   , class_rep = (BiPartition->WeylElt): conjugacy_class_B(rd)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do class_rep(pair) od
		, (int i)int: cycle_class_size(classes[i].to_cycles)
		, (WeylElt w) int: lookup(type_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

{ for general type C root data, we need to look up and use the diagram order }
set conjugacy_class_C (RootDatum rd) = (BiPartition->WeylElt):
   let map = test_simple_type("C",rd) then n=#map in
   (BiPartition pair) WeylElt:
(  let size = rank(pair)
in assert(size=n,"Partition sizes sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word_BC(pair) do map[s] od)
)

{ in class table construction we prefer |BiPartition| over |Signed_cycles| }
set class_table_C (int n) = WeylClassTable:
   let rd=Sp(n+n), classes = [BiPartition]: partition_pairs(n)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do W_elt(rd,class_word_BC(pair)) od
		, (int i)int: cycle_class_size(classes[i].to_cycles)
		, (WeylElt w) int: lookup(cycle_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

set class_table_C (RootDatum rd) = WeylClassTable:
   let classes = [BiPartition]: partition_pairs(rd.semisimple_rank)
   , type_code(WeylElt w) = vec: signed_cycle_type_code(classic_permutation(w))
   , class_rep = (BiPartition->WeylElt): conjugacy_class_C(rd)
   then lookup = (BiPartition->int): index_bipartition(classes)
in W_class_table( rd, for pair in classes do class_rep(pair) od
		, (int i)int: cycle_class_size(classes[i].to_cycles)
		, (WeylElt w) int: lookup(type_code(w).as_bipartition)
		, (int i,int k)int:
		    cycle_power(classes[i].to_cycles,k).to_partition_pair.lookup
		)

{				type D					}


{ word representative in types D of unsplit conjugacy class for partition pair }
set class_word_D(Partition lambda,Partition mu) = [int]:
(  assert((lambda:=lambda.strip_to_partition).>, "lambda is not a partition")
;  assert((mu:=mu.strip_to_partition).>, "mu is not a partition")
;  assert(=#mu%2, "mu has an odd number of parts")
;  assert(not(=mu and =lambda%2)
	 , "mu is empty and lambda has even parts: split class")
;  let (n,,L_gens) = Levi_A(lambda), (m,,simples) =Levi_A(mu)
   ,  rise(int a,int len) = [int]: for i:len from a  do i od
   ,  fall(int a,int len) = [int]: for i:len from a ~do i od
then  sign_pair(int k,int l) = [int]: { arguments are positions in |[0,m[| }
         rise(n+l,m-1-l)##rise(n+k,m-k) { |m-k-2|, plus 2 final for signs }
       ##fall(n+k,m-2-k)##fall(n+l,m-1-l) { remainder of conjugation }
then  M_gens = { each cycle pair from |mu| get sign flips when second is done }
      let odd=false { parity of number cycles from |mu| already treated }
      , j=0 { position in |simples| }
      , k=minus_1 { variable to record end of previous cycle } in
      for i:m
      do if j<#simples and i=simples[j] then j+:=1; [n+i] { extend our cycle }
         elif odd:=not odd
	 then [] next k:=i { break cycle, save index, wait for |sign_pair| }
	 else sign_pair(k,i) { wrap up two cycles by adding signs }
	 fi
      od.##
in L_gens##M_gens
)

{ word representative in types D of split conjugacy class for partition pair }
set class_word_D(Partition lambda,bool minus) = [int]:
(  assert((lambda:=lambda.strip_to_partition).>, "lambda is not a partition")
;  assert(lambda.is_very_even, "lambda is has odd parts: not a split class")
;  let n=sum(lambda), bars = let sum=minus_1 in for k in lambda do sum+:=k od
in if minus else complement(n,bars) { just have a word for each (even) cycle }
   then complement(n,bars) ## [n-2,n-1] { add adjacent flips in last cycle }
   fi
)

set class_word(D_class c) =  [int]:
   case c
   | unsplit_class(cycles): class_word_D(cycles.to_partition_pair)
   | split_class(lambda_minus): class_word_D(lambda_minus)
   esac


set conjugacy_class_SO(D_class c) = WeylElt:
   let n=rank(c) in W_elt(SO(n+n),class_word(c))

{ for general type D root data, we need to look up and use the diagram order }
set conjugacy_class_D(RootDatum rd) = (D_class->WeylElt):
   let map = test_simple_type("D",rd) then n=#map in
   (D_class cycles) WeylElt:
(  let size = rank(cycles)
in assert(size=n,"Cycles sum to "+size+" rather than "+n)
;  W_elt(rd,for s in class_word(cycles) do map[s] od)
)

set class_table_D(int n) = WeylClassTable:
   let rd=SO(n+n), classes = [D_class]: D_classes(n)
   then lookup = (D_class->int):
      let ranked = { |ranked[i]| is index into |classes| of class ranked |i| }
         ranking(<=@(D_class,D_class))(classes)
      then list = for i in ranked do classes[i] od
      in (D_class c) int: { index in |classes| where one finds |c| }
         ranked[binary_search_first((int i)bool: c<=list[i], 0,#classes)]
in W_class_table( rd, for class in classes do conjugacy_class_SO(class) od
		, (int i)int: class_size(classes[i])
		, (WeylElt w)int: lookup(signed_permutation(w).to_D_class)
		, (int i,int k)int: lookup(cycle_power(classes[i],k))
		)

set class_table_D(RootDatum rd) = WeylClassTable:
   let classes = [D_class]: D_classes(rd.semisimple_rank)
   , class_rep = (D_class->WeylElt): conjugacy_class_D(rd)
   then lookup = (D_class->int):
      let ranked = { |ranked[i]| is index in |classes| of class ranked |i| }
         ranking(<=@(D_class,D_class))(classes)
      then list = for i in ranked do classes[i] od
      in (D_class c) int: { index in |classes| where one finds |c| }
         ranked[binary_search_first((int i)bool:c<=list[i], 0,#classes)]
in W_class_table( rd, for class in classes do class_rep(class) od
		, (int i)int: class_size(classes[i])
		, (WeylElt w)int: lookup(classic_permutation(w).to_D_class)
		, (int i,int k)int: lookup(cycle_power(classes[i],k))
		)

{				type G2					}

set ! G2_class_words = [[],[0],[1],[0,1],[0,1,0,1],[0,1,0,1,0,1]]

set class_table_G (RootDatum rd) = WeylClassTable:
  let map=test_simple_type("G",rd)
  then magic_coweight = 5*coroot(rd,map[0])+9*coroot(rd,map[1]), rho=rho(rd)\1
  then type(WeylElt w) = int:
    case magic_coweight*(w*rho) { mod 15; all collisions are conjugate }
    in die, 5, 2, die, 1, die, die, 3, 4, die, die, 2, die, 1, 0
    esac
  , reps =
      for word in G2_class_words do W_elt(rd,for bit in word do map[bit] od) od
  in W_class_table( rd, reps
		  , (int i) int: {class size} case i in 1,3,3,2,2,1 esac
		  , {classify |w|} type
		  , (int i,int k) int: {class powers}
		    case i-3 else { order 2 } case k in 0,i esac
		    in {i=3} case k in 0,3,4,5,4,3 esac
		    ,  {i=4} case k in 0,4,4 esac
		    esac
		  )

set class_table_G (int n) = WeylClassTable:
   assert(n=2,"Inexistent type G"+n); class_table_G(simply_connected("G2"))


{				type F4					}

{ orbit sizes on long respectively short roots; these characterise classes }
set class_signature_F4 (WeylElt w) = (Partition,Partition):
   let rd=root_datum(w), orbits = root_orbits(w)
   then longs = Partition:
     for c in orbits do if is_long_root(rd,c[0]) then [#c] else [] fi od.##
   , shorts = Partition:
     for c in orbits do if is_long_root(rd,c[0]) then [] else [#c] fi od.##
   in (longs.sort_to_partition,shorts.sort_to_partition)

{ list conjugacy classes in Kondo order; non standard ordering of diagram is
  allowed: |map| maps Bourbaki indices to corresponding indices in |rd| }
set classes_Kondo_F4 (RootDatum F4) = [WeylElt]:
   let map = [int]: test_simple_type("F",F4)
   then convert([int] word) = [int]: for letter in word do map[letter] od
   then a = W_elt(F4,[1].convert), b=W_elt(F4,[2,1,2].convert)
   , c=W_elt(F4,[2,3,2,1,2,3,2].convert), d=W_elt(F4,[0].convert)
   , tau =W_elt(F4,[2].convert), sigma =W_elt(F4,[2,3].convert)
   then e=(a*b*c*d)^2, z=(a*b*c*d)^3
in for w in
     [ id_W(F4)
     , z { central element, acts as $-1$ }
     , a*b
     , e
     , e*z
     , a*d*b*d*c*d
     , sigma
     , sigma*z
     , sigma*e
     , sigma*e*z
     , c*d*sigma
     , d { long root reflection }
     , d*z
     , sigma*d
     , sigma*d*z
     , a*d*b
     , tau { short root reflection }
     , tau*z
     , e*tau
     , e*tau*z
     , c*a*tau
     , tau*d
     , a*tau
     , a*tau*z
     , c*d*b*tau
     ]
   do minimal_representative(w)
   od


set class_table_F (RootDatum rd) = WeylClassTable:
   let classes = [WeylElt]: classes_Kondo_F4(rd)
   then sigs = [BiPartition]:
      for class in classes do class_signature_F4(class) od
   then N=1152 { = order_W(rd) }
   ,  lookup = (BiPartition->int):
      let ranked = ranking(<=@(BiPartition,BiPartition))(sigs)
      then list = for i in ranked do sigs[i] od { |sigs| sorted by |<=| }
      in (BiPartition sig) int: { index in |sigs| where one finds |sig| }
         ranked[binary_search_first((int i)bool: sig<=list[i], 0,#list)]
in W_class_table ( rd
		 , classes
		 , (int i) int: N\centralizer_order(classes[i])
		 , (WeylElt w) int: lookup(class_signature_F4(w))
		 , (int i,int k) int:
		   let (a,b) = sigs[i]
		   in lookup(cycle_power(a,k),cycle_power(b,k))
		 )

set class_table_F (int n) = WeylClassTable:
   assert(n=4,"Inexistent type F"+n); class_table_F(simply_connected("F4"))


{				type E6					}


{ orbit sizes on roots; these characterise conjugacy classes for W(E6) }
set class_signature_E6 (WeylElt w) = Partition:
   let rd=root_datum(w)
in for c in root_orbits(w) do #c od.sort_to_partition

set class_table_E6 (RootDatum rd) = WeylClassTable:
   let classes = [WeylElt]: assert(#test_simple_type("E",rd)=6,"Not E6")
	       ; conjugacy_class_reps(rd)
   then sigs = [Partition]:
      for w in classes do class_signature_E6(w) od
   , leq = rlex_leq_partitions@(Partition,Partition)
   then ranked = ranking(leq)(sigs) { map from rank to position in |sigs| }
   then sigs_sorted = for i in ranked do sigs[i] od
   then N=51840 { order_W("E6") }
   , lookup (Partition sig) = int: { index of |sig| in |sigs| }
      binary_lookup(leq)(sig,sigs_sorted).requisition
in W_class_table ( rd
		 , for r in ranked do classes[r] od
		 , (int i) int: N\centralizer_order(classes[ranked[i]])
		 , (WeylElt w) int: lookup(class_signature_E6(w))
		 , (int i,int k) int: lookup(cycle_power(sigs_sorted[i],k))
		 )

{ we shall do storage of the class table for one particular E6 root datum }
set !standard_datum_E6 = RootDatum: simply_connected("E6")

{ voluntarily override previous definition to memoize for |standard_datum_E6| }
set class_table_E6 = (RootDatum->WeylClassTable):
   let Wct= trivial_class_table { place holder value }
in (RootDatum rd) WeylClassTable:
   if rd != standard_datum_E6 then class_table_E6(rd) { this is not recursion! }
   elif =Wct.root_datum.rank { whether this is the first time we are called }
   then Wct:=class_table_E6(rd) { compute and store the first time }
   else Wct { any next time just return the previously computed value }
   fi

set class_table_E6 () = WeylClassTable: class_table_E6(standard_datum_E6)


{				type E7					}

{ Unlike other exceptional simple types, the class invariant of the cycle type
  of the permutation of the roots defined by a Weyl group element does not
  entirely separate conjugacy classes: three pairs of classes are ambiguous.
  In each case the type of |Levi_datum(w)| will distinguish the pairs, and
  indeed just the number of simple factors of this type will do: one member of
  the pair gives a single factor, while the other one has 2,3, or 4 factors.

  Since |Levi_datum(w)| is cheaper to compute then say |centralizer_order(w)|,
  we use this number of simple factors as additional component in order to
  characterise conjugacy classes, useful for looking up arbitrary elements |w|.
}

set_type E7_signature = (Partition,int)
set class_signature_E7 (WeylElt w) = E7_signature:
   let rd=root_datum(w)
in ( for c in root_orbits(w) do #c od.sort_to_partition
   , w.Levi_datum.Lie_type.simple_factors.#
   )

{ comparison of root cycle types first, use second component to disambiguate }
set leq_E7_signatures (E7_signature(P,m),E7_signature(Q,n)) = bool:
   case rlex_cmp_partitions(P,Q) then true in m<=n else false esac

{ Compared to other types, fast construction of a class table for E7 is a bit
  more complicated. We prepare a list |sigs_sorted| of class signatures sorted
  by |leq_E7_signatures| (so first lexicographically by the root partition type,
  then for those pairs where it is necessary by the second component), in which
  we can do binary search for the signature of a |WeylElt|. For the table of
  powers of classes, we could use this to look up powers of a class
  representative, but with a bit of effort we can manage using signatures only.

  For classes with an unambiguous root partition type, their powers will
  similarly have unambiguous types, so we can use |cycle_power@(partition,int)|
  to get the new root partition type and look it up using |binary_lookup_by|. In
  the remaining "ambiguous" classes, the even powers are unambiguous (so looking
  up the type suffices), while their odd powers are ambiguous, but retain their
  relative position (first or second) among the classes with their root
  partition type. (Most of the time these odd powers determine the base class
  itself, but for the case where the base class has order 6, the third power has
  order 2.) So to compute the |k|-th power of a class, we take the partition for
  the class, apply |cycle_power| to get the |k|-th power cycle type, and look up
  its first occurrence in |sigs_sorted|. The position found will be the value
  returned, unless the base class was the second of an ambiguous pair and |k| is
  odd, in which case we add 1 to the position. Below we hard-code the positions
  6,17,36 of the second elements of ambiguous pairs; being positions in a sorted
  list these should never change, but we include as comment code that makes
  explicit the condition by which those numbers were singled out.
}
set class_table_E7 (RootDatum rd) = WeylClassTable:
   let classes = [WeylElt]: assert(#test_simple_type("E",rd)=7,"Not E7")
	       ; conjugacy_class_reps(rd)
   then sigs = [E7_signature]: { class signatures }
      for w in classes do class_signature_E7(w) od
   then ranked =  { map from rank to position in |sigs| }
     ranking(leq_E7_signatures)(sigs)
   then sigs_sorted = [E7_signature]: for i in ranked do sigs[i] od
   then lookup_w (WeylElt w) = int:
      binary_lookup(leq_E7_signatures)
      (class_signature_E7(w),sigs_sorted).requisition
   , class_power = (int,int->int):
       let is_second = (int->bool):
          { (int i)bool: i=0 or
	       (let (prev,)=sigs_sorted[i-1],(sig,n)=sigs_sorted[i]
		in n=1 or prev!=sig) }
          is_member([6,17,36]) { so second of its ambiguity class }
       in (int i, int k) int:
          let first = int:
	     binary_lookup_by
	     ((E7_signature(sig,))Partition:sig,rlex_leq_partitions)
	     (cycle_power(fst(sigs_sorted[i]),k),sigs_sorted)
	     .requisition
          in if i.is_second and k.is_odd then first+1 else first fi
   , N=2903040 { order_W("E7") }
in W_class_table ( rd
		 , for r in ranked do classes[r] od
		 , (int i) int: N\centralizer_order(classes[ranked[i]])
		 , lookup_w
		 , class_power
		 )

{ we shall do storage of the class table for one particular E6 root datum }
set !standard_datum_E7 = RootDatum: simply_connected("E7")

{ voluntarily override previous definition to memoize for |standard_datum_E6| }
set class_table_E7 = (RootDatum->WeylClassTable):
   let Wct= trivial_class_table { place holder value }
in (RootDatum rd) WeylClassTable:
   if rd != standard_datum_E7 then class_table_E7(rd) { this is not recursion! }
   elif =Wct.root_datum.rank { whether this is the first time we are called }
   then Wct:=class_table_E7(rd) { compute and store the first time }
   else Wct { any next time just return the previously computed value }
   fi

set class_table_E7 () = WeylClassTable: class_table_E7(standard_datum_E7)


{				type E8					}


{ orbit sizes on roots; these characterise conjugacy classes for W(E8) }
set class_signature_E8 (WeylElt w) = Partition:
   let rd=root_datum(w)
in for c in root_orbits(w) do #c od.sort_to_partition

{ the code below hard-codes some tables, presumably for faster construction of
  the E8 class table. We provide equivalent code that will reproduce the data. }
set class_table_E8 (RootDatum rd) = WeylClassTable:
   let classes = [WeylElt]: assert(#test_simple_type("E",rd)=8,"Not E8")
	       ; conjugacy_class_reps(rd) { order should not matter here }
   then sigs = [Partition]: for w in classes do class_signature_E8(w) od
   , leq = rlex_leq_partitions@(Partition,Partition)
   then ranked = ranking(leq)(sigs) { map from rank to position in |sigs| }
   then sigs_sorted = for i in ranked do sigs[i] od
   then lookup (Partition sig) = int: { index of |sig| in |sigs| }
      binary_lookup(leq)(sig,sigs_sorted).requisition
   then sizes = vec:
     { for i in ranked do 696729600\centralizer_order(classes[i]) od }
     [1 { classes grouped by order, which is also maximal orbit size on roots }
     ,120,3780,37800,3150,113400,37800,3780,120,1 { order 2 }
     ,2240,268800,89600,4480 { order 3 }
     ,45360,907200,151200,2721600,907200,45360,37800
       ,453600,680400,453600,37800,5443200,907200,15120 { order 4 }
     ,580608,1161216 { order 5 }
     ,80640,1612800,268800,604800,1209600,100800,100800
       ,1209600,604800,80640,2240,2419200,3225600,4838400
       ,1612800,2419200,806400,806400,403200,14515200,4838400
       ,2419200,1612800,268800,2419200,268800,89600,4480 { order 6 }
     ,24883200 { order 7 }
     ,1814400,10886400,1814400,5443200,10886400,5443200,43545600
       ,3628800 { order 8 }
     ,6451200,12902400 { order 9 }
     ,5806080,8709120,8709120,5806080,580608,1161216 { order 10 }
     ,3628800,7257600,1209600,1209600,7257600,3628800,1209600
       ,1209600,9676800,4838400,2419200,14515200,14515200,4838400
       ,2419200,29030400,9676800,2419200 { order 12 }
     ,24883200,24883200,24883200 { order 14 }
     ,11612160,23224320 { order 15 }
     ,19353600,19353600,6451200,12902400 { order 18 }
     ,17418240,17418240,34836480 { order 20 }
     ,14515200,14515200,29030400 { order 24 }
     ,11612160,11612160,11612160,23224320 { order 30 }
     ]
   , pows = [vec]: { |pows[i]| gives class of powers 2..order\2 of class |i| }
   { for r in ranked
     do let w=classes[r] then n=order(w)
     in for i:(n-2)\2 from 2 do lookup(class_signature_E8(w^i)) od
     od
   }
   { for sig in sigs_sorted
     do let n=sig[0] { maximal cycle size equals order }
     in for k:(n-2)\2 from 2 do lookup(cycle_power(sig,k)) od
     od
   }
     [[]
     ,[],[],[],[],[],[],[],[],[]
     ,[],[],[],[]
     ,[2],[2],[2],[2],[2],[2],[4],[4],[4],[4],[4],[5],[7],[9]
     ,[28],[29]
     ,[10,1],[11,1],[12,1],[10,2],[10,3],[10,4],[10,4]
       ,[10,6],[10,7],[10,8],[10,9],[11,2],[11,4],[11,3]
       ,[11,4],[12,3],[12,4],[12,4],[13,4],[11,5],[11,6]
       ,[11,7],[11,8],[11,9],[12,6],[12,8],[12,9],[13,9]
     ,[58,58]
     ,[20,59,4],[20,60,4],[20,61,4],[22,62,4],[22,63,4],[22,64,4],[25,65,5]
       ,[27,66,9]
     ,[67,12,67],[68,12,68]
     ,[28,69,28,1],[28,70,28,2],[28,71,28,7]
       ,[28,72,28,8],[28,73,28,9],[29,74,29,9]
     ,[33,14,10,75,2],[33,15,10,76,2],[33,16,10,77,2],[33,16,10,78,2]
       ,[33,18,10,79,2],[33,19,10,80,2],[35,20,10,81,4],[35,24,10,82,4]
       ,[41,16,11,83,2],[47,20,12,84,4],[48,20,13,85,4],[47,21,12,86,4]
       ,[47,23,12,87,4],[47,24,12,88,4],[48,24,13,89,4],[51,26,11,90,7]
       ,[53,27,11,91,9],[57,27,13,92,9]
     ,[58,93,58,93,58,1],[58,94,58,94,58,8],[58,95,58,95,58,9]
     ,[96,28,96,10,28,96],[97,29,97,13,29,97]
     ,[67,32,67,98,12,98,67,1],[67,55,67,99,12,99,67,8]
       ,[67,56,67,100,12,100,67,9],[68,56,68,101,12,101,68,9]
     ,[70,102,28,14,70,102,28,102,2],[70,103,28,19,70,103,28,103,2]
       ,[74,104,29,27,74,104,29,104,9]
     ,[81,59,35,105,20,105,10,59,81,105,4],[81,61,35,106,20,106,10,61,81,106,4]
       ,[92,66,57,107,27,107,13,66,92,107,9]
     ,[96,69,96,30,28,108,96,69,10,108,28,108,96,1]
       ,[96,72,96,39,28,109,96,72,10,109,28,109,96,8]
       ,[96,73,96,40,28,110,96,73,10,110,28,110,96,9]
       ,[97,74,97,57,29,111,97,74,13,111,29,111,97,9]
     ]
in W_class_table ( rd
		 , for rank in ranked do classes[rank] od
		 , (int i) int: sizes[i]
		 , (WeylElt w) int: lookup(class_signature_E8(w))
		 , (int i,int k) int: { lookup(cycle_power(sigs_sorted[i],k)) }
		   let n=classes[ranked[i]].order, pow=pows[i] in
		   if (k%:=n)<2 then case k in 0,i esac
		   elif k<=n\2 then pow[k-2]
		   elif k=n-1 then i
		   else pow[n-k-2]
		   fi
		 )

{ we shall do storage of the class table for one particular E8 root datum }
set !standard_datum_E8 = RootDatum: simply_connected("E8")

{ voluntarily override previous definition to memoize for |standard_datum_E8| }
set class_table_E8 = (RootDatum->WeylClassTable):
   let Wct= trivial_class_table { place holder value }
in (RootDatum rd) WeylClassTable:
   if rd != standard_datum_E8 then class_table_E8(rd) { this is not recursion! }
   elif =Wct.root_datum.rank { whether this is the first time we are called }
   then Wct:=class_table_E8(rd) { compute and store the first time }
   else Wct { any next time just return the previously computed value }
   fi

set class_table_E8 () = WeylClassTable: class_table_E8(standard_datum_E8)

set class_table_E (int n) = WeylClassTable:
   case n-6
   in class_table_E6(), class_table_E7(), class_table_E8()
   else error("Inexistent type E",n)
   esac


{				The synthesis				}

set simple_class_table (LieType lt) = WeylClassTable:
(  let (letter,rank)=lt.simple_type { this also asserts that |lt| is simple }
in case ascii(letter)-ascii("A")
   in class_table_A(SL(rank+1))
   ,  class_table_B(rank)
   ,  class_table_C(rank)
   ,  class_table_D(rank)
   ,  class_table_E(rank)
   ,  class_table_F(4)
   ,  class_table_G(2)
   else error("Classification of simple types exploded!")
   esac
)

set class_table_simple (RootDatum rd,string letter,int n) = WeylClassTable:
   case ascii(letter)-ascii("A")
   in class_table_A(rd)
   ,  class_table_B(rd)
   ,  class_table_C(rd)
   ,  class_table_D(rd)
   , case n-6
     in class_table_E6(rd), class_table_E7(rd), class_table_E8(rd)
     esac
   , class_table_F(rd)
   , class_table_G(rd)
   esac

{ the name of this function highlights that it does considerable work }
set construct_class_table (RootDatum rd) = WeylClassTable:
   let (Lie_type,map) = Cartan_matrix_type(rd.Cartan_matrix)
   then simples = simple_factors(Lie_type)
   then root_data = [RootDatum]: { subdata with a single simple factor + torus }
      let offset=0 in
      for (,rank) in simples
      do sub_datum(rd,for i:rank do map[offset+i] od)  next offset+:=rank
      od
   then simple_tables = [WeylClassTable]: { tables for each of |root_data| }
      for rdi@i in root_data
      do let (letter,n)=simples[i] in class_table_simple(rdi,letter,n)
      od
in combine(rd,simple_tables)
