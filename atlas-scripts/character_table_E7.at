<basic.at
<combinatorics.at
<W_characters.at
<character_tables.at
{<nilpotent_orbits.at}
{<character_table_E7_data.at}

{ Unlike other exceptional simple types, the class invariant of the cycle type
  of the permutation of the roots defined by a Weyl group element does not
  entirely separate conjugucy classes: three pairs of classes are ambiguous.
  In each case the type of |Levi_datum(w)| will distinguish the pairs, and
  indeed just the number of simple factors of this type will do: one member of
  the pair gives a single factor, while the other one has 2,3, or 4 factors.

  Since |Levi_datum(w)| is cheaper to compute then say |centralizer_order(w)|,
  we use this number of simple factors as additional component in order to
  characterise conjugacy classes, useful for looking up arbitrary elements |w|.
}

set class_signature_E7 (WeylElt w) = (Partition,int):
   let rd=root_datum(w)
in ( for c in root_orbits(w) do #c od.sort_to_partition
   , w.Levi_datum.Lie_type.simple_factors.#
   )

{ comparison of root cycle types first, use second component to disambiguate }
set leq_E7_signatures ((Partition P,int m),(Partition Q,int n)) = bool:
   case cmp_equal_sum_partitions(P,Q) then true in m<=n else false esac

{ Compared ot other types, fast construction of a class table for E7 takes quite
  a bit of preparation effort. Having a sorted list of class signatures will
  speed up searching for elements, as in other types, but computing class powers
  is harder. In most cases using just the root permutation cycle type suffices:
  for unambiguous classes their powers are also unambiguous, and it turns out
  that even powers of ambiguous classes are unambiguous as well (the ambiguous
  classes have even element orders 2,4,6). Odd powers of ambiguous classes are
  still ambiguous; in most cases they are the ambiguous class itself, but the
  thrid powers of the ambiguous classes with element order 6 give the ambiguous
  classes with order 2, with the "one simple factor" condition unchanged. We can
  therefore avoid actually computing powers of signatures of class
  representatives. This however requires the sorted list of class signatures to
  be transformed into a sorted |list| of just permutation cycle types (for
  searching without needing to know the Levi datum), with associated to each a
  list of 1 or 2 class numbers. In most cases the number of factors is not used
  at all, but in the ambiguous cases we use whther or not that nuber equals 1.
}
set class_table_E7 (RootDatum rd) = WeylClassTable:
   let classes = [WeylElt]: assert(#test_simple_type("E",rd)=7,"Not E7")
	       ; conjugacy_class_reps(rd)
   then sigs = [Partition,int]: { class signatures; to be modified a bit below }
      for w in classes do class_signature_E7(w) od
   then N=2903040 { order_W("E7") }
   ,  (lookup_w,lookup_cyc) { define two functions that share precomputed data }
         = ((WeylElt->int),(Partition->[int])):
      let ranked = [int]:
         sort(#sigs,(int i,int j)bool: leq_E7_signatures(sigs[i],sigs[j]))
      then (list,locs) = ([Partition],[[int]]): { sorted cycle type, positions }
         let locs=[int]:[], prev= Partition:[]
	 then out = [Partition,[int]]: { grouping of |sigs[ranked[i]] values }
	    for loc@rank in ranked
	    do let (lambda,)=sigs[loc] in
	       if =rank then [] next prev:=lambda; locs:=[loc]
	       elif lambda=prev then [] next locs#:=loc
	       else [(prev,locs)] next prev:=lambda; locs:=[loc]
	       fi
	    od.##
      in out #:= (prev,locs) { attach last group; now split into (list,locs): }
      ;  ( for (lambda, ) in out do lambda od, for (,locs) in out do locs od )
      then locate(Partition lambda) = int: { position of |lambda| in |list| }
         binary_search_first
	   ((int i)bool: leq_equal_sum_partitions(lambda,list[i]), 0,#list)
   in ( { lookup_w = } (WeylElt w) int:
        let (lambda,n)=class_signature_E7(w) then locs = locs[locate(lambda)]
	in if #locs=1 or n=1 {single factor} then locs[0] else locs[1] fi
      , { lookup_cyc = } (Partition mu) [int]: locs[locate(mu)]
      )
in W_class_table ( rd
		 , classes
		 , (int i) int: N\centralizer_order(classes[i])
		 , lookup_w
		 , (int i,int k) int:
		   let (lambda,n)=sigs[i] then locs = lookup_cyc(lambda)
		   in if k.is_odd and #locs>1
		      else cycle_power(lambda,k).lookup_cyc [0] {unambiguous}
		      then { cycle type will still be ambiguous }
		         let seq = #(n>1) in { 0/1 value to disambiguate }
			 assert(locs[seq]=i); { check }
			 cycle_power(lambda,k).lookup_cyc [seq]
		      fi
		 )

{ compute class table once, on demand the first time it is needed }
set class_table_E7 = (->WeylClassTable):
   let Wct= W_class_table(adjoint("")) { placeholder |WeylClassTable| value }
in @: { function with no arguments }
   if =Wct.root_datum.rank { whether this is the first time we are called }
   then Wct:=class_table_E7(simply_connected("E7")) else Wct
   fi

{ To save space we shall list only half of the characters, in Magma ordering.
  The first is the sign character, and the missing characters are formed from
  the given ones by tensoring with this sign character. We just need to indicate
  the indices in the Magma numbering of the given characters; the tensor
  products will give the caracters at the missing indices, in increasing order.
}
set E7_positions = [int]:
[1,3,5,9,8,11,15,14,17,19,21,27,24,26,29
,31,33,35,37,41,40,43,47,46,49,51,53,55,57,59]

{ the characters in the subset |dual_map| under Magma numbering }
set rows = [vec]: { 60 entries each, broken 20|20|20 across lines }
[[1,-1,-1,1,1,-1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,1,1
 ,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1
 ,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,-1] { the sign character }
,[7,-7,5,-5,-1,1,3,-3,-1,1,4,-2,1,3,-3,3,-1,1,-3,-1
 ,1,1,-1,2,-4,2,2,-2,2,-2,-1,-2,2,0,0,1,-1,1,-1,-1
 ,1,0,-1,1,1,-1,1,-2,0,0,0,0,2,-2,0,0,0,-1,-1,1] { the refection character }
,[15,15,-5,-5,7,7,3,3,-1,-1,0,-3,3,-1,-1,1,-3,-3,1,3
 ,3,1,1,0,0,-3,-2,-2,-2,-2,3,1,1,0,0,1,1,1,1,-1
 ,-1,1,-1,-1,1,1,0,0,0,0,-2,-2,0,0,-1,-1,1,0,0,0]
,[21,-21,11,-11,5,-5,5,-5,-3,3,6,3,0,1,-1,3,3,-3,-3,1
 ,-1,1,-1,1,-6,-3,2,-2,2,-2,0,1,-1,2,-2,-2,2,-2,2,0
 ,0,0,1,-1,1,-1,0,-1,-1,1,0,0,0,0,-1,1,0,1,0,-1]
,[21,21,9,9,-3,-3,1,1,-3,-3,6,3,0,5,5,3,-1,-1,3,1
 ,1,-1,-1,1,6,3,0,0,0,0,0,3,3,-2,-2,0,0,0,0,0
 ,0,0,1,1,-1,-1,0,1,-1,-1,0,0,2,2,-1,-1,0,1,0,1]
,[27,27,15,15,3,3,7,7,3,3,9,0,0,3,3,5,1,1,5,-1
 ,-1,1,1,2,9,0,3,3,3,3,0,0,0,1,1,0,0,0,0,0
 ,0,-1,-1,-1,1,1,0,2,0,0,-1,-1,1,1,0,0,-1,-1,0,-1]
,[35,35,15,15,11,11,7,7,3,3,5,-1,2,-1,-1,1,5,5,1,3
 ,3,1,1,0,5,-1,3,-1,-1,3,2,-1,-1,1,1,0,0,2,2,0
 ,0,0,1,1,-1,-1,-1,0,0,0,1,1,-1,-1,-1,-1,0,0,-1,0]
,[35,-35,5,-5,3,-3,-5,5,3,-3,5,-1,2,7,-7,1,1,-1,-1,-1
 ,1,-1,1,0,-5,1,-1,3,-3,1,-2,-3,3,1,-1,-2,2,0,0,0
 ,0,0,-1,1,-1,1,-1,0,0,0,1,-1,1,-1,-1,1,0,0,1,0]
,[56,-56,24,-24,-8,8,8,-8,0,0,11,2,2,0,0,4,-4,4,-4,0
 ,0,0,0,1,-11,-2,3,-1,1,-3,-2,2,-2,-1,1,0,0,2,-2,0
 ,0,0,0,0,0,0,-1,-1,1,-1,1,-1,-1,1,0,0,0,1,1,-1]
,[70,-70,10,-10,-10,10,6,-6,-2,2,-5,7,1,2,-2,-2,-2,2,2,2
 ,-2,-2,2,0,5,-7,1,1,-1,-1,-1,1,-1,3,-3,-1,1,1,-1,1
 ,-1,0,0,0,0,0,1,0,0,0,1,-1,1,-1,1,-1,0,0,-1,0]
,[84,84,4,4,20,20,4,4,4,4,-6,3,3,4,4,0,0,0,0,4
 ,4,0,0,-1,-6,3,-2,2,2,-2,3,-1,-1,-2,-2,1,1,-1,-1,1
 ,1,0,0,0,0,0,0,-1,-1,-1,0,0,0,0,1,1,0,-1,0,-1]
,[105,-105,-25,25,-7,7,9,-9,1,-1,0,6,3,-3,3,3,3,-3,-3,-3
 ,3,1,-1,0,0,-6,-4,4,-4,4,-3,-2,2,0,0,1,-1,1,-1,1
 ,-1,0,1,-1,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[105,-105,35,-35,1,-1,5,-5,1,-1,15,-3,-3,5,-5,5,1,-1,-5,1
 ,-1,-1,1,0,-15,3,-1,-1,1,1,3,-1,1,-1,1,1,-1,-1,1,1
 ,-1,0,1,-1,-1,1,0,0,0,0,-1,1,1,-1,1,-1,0,0,0,0]
,[105,-105,-5,5,17,-17,-3,3,-7,7,0,6,3,-3,3,1,-3,3,-1,1
 ,-1,-1,1,0,0,-6,-2,-2,2,2,-3,-2,2,0,0,-1,1,1,-1,-1
 ,1,0,1,-1,-1,1,0,0,0,0,-2,2,0,0,0,0,0,0,0,0]
,[120,120,40,40,-8,-8,8,8,0,0,15,-6,0,0,0,4,-4,-4,4,0
 ,0,0,0,0,15,-6,1,1,1,1,0,-2,-2,-1,-1,-2,-2,-2,-2,0
 ,0,1,0,0,0,0,0,0,0,0,1,1,-1,-1,0,0,1,0,0,0]
,[168,-168,-40,40,8,-8,8,-8,8,-8,6,6,-3,0,0,0,0,0,0,0
 ,0,0,0,-2,-6,-6,2,-2,2,-2,3,-2,2,2,-2,1,-1,1,-1,-1
 ,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,-1]
,[189,189,-39,-39,21,21,1,1,-3,-3,9,0,0,-3,-3,-1,-5,-5,-1,1
 ,1,-1,-1,-1,9,0,3,3,3,3,0,0,0,1,1,0,0,0,0,0
 ,0,0,1,1,-1,-1,0,-1,1,1,-1,-1,1,1,0,0,0,-1,0,-1]
,[189,189,-51,-51,-3,-3,13,13,-3,-3,9,0,0,-3,-3,1,1,1,1,-3
 ,-3,1,1,-1,9,0,-3,-3,-3,-3,0,0,0,1,1,0,0,0,0,0
 ,0,0,1,1,1,1,0,-1,-1,-1,1,1,1,1,0,0,0,-1,0,-1]
,[189,189,21,21,-3,-3,-11,-11,-3,-3,9,0,0,9,9,1,1,1,1,1
 ,1,1,1,-1,9,0,-3,-3,-3,-3,0,0,0,1,1,0,0,0,0,0
 ,0,0,-1,-1,-1,-1,0,-1,1,1,1,1,1,1,0,0,0,-1,0,-1]
,[210,-210,-10,10,-14,14,10,-10,2,-2,-15,-6,3,6,-6,2,2,-2,-2,-2
 ,2,-2,2,0,15,6,-1,-1,1,1,-3,2,-2,1,-1,1,-1,-1,1,-1
 ,1,0,0,0,0,0,0,0,0,0,-1,1,-1,1,0,0,0,0,0,0]
,[210,210,50,50,2,2,2,2,-6,-6,15,3,0,-2,-2,2,2,2,2,-2
 ,-2,-2,-2,0,15,3,-1,-1,-1,-1,0,-1,-1,-1,-1,2,2,2,2,0
 ,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,1,1,0,0,0,0]
,[216,216,-24,-24,24,24,8,8,0,0,-9,0,0,0,0,4,-4,-4,4,0
 ,0,0,0,1,-9,0,-3,-3,-3,-3,0,0,0,-1,-1,0,0,0,0,0
 ,0,-1,0,0,0,0,0,1,1,1,1,1,-1,-1,0,0,-1,1,0,1]
,[280,280,40,40,24,24,8,8,0,0,-5,-8,-2,0,0,-4,4,4,-4,0
 ,0,0,0,0,-5,-8,1,-3,-3,1,-2,0,0,-1,-1,-2,-2,0,0,0
 ,0,0,0,0,0,0,1,0,0,0,-1,-1,1,1,0,0,0,0,1,0]
,[280,-280,40,-40,-8,8,-8,8,8,-8,10,10,1,0,0,0,0,0,0,0
 ,0,0,0,0,-10,-10,-2,2,-2,2,-1,2,-2,-2,2,-1,1,-1,1,-1
 ,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,-1,0]
,[315,-315,45,-45,-21,21,3,-3,3,-3,0,-9,0,-5,5,-3,-3,3,3,3
 ,-3,-1,1,0,0,9,0,0,0,0,0,-3,3,0,0,0,0,0,0,0
 ,0,0,1,-1,1,-1,0,0,0,0,0,0,0,0,-1,1,0,0,0,0]
,[336,-336,16,-16,16,-16,-16,16,0,0,6,-6,0,0,0,0,0,0,0,0
 ,0,0,0,1,-6,6,-2,2,-2,2,0,2,-2,2,-2,2,-2,2,-2,0
 ,0,0,0,0,0,0,0,-1,-1,1,0,0,0,0,0,0,0,1,0,-1]
,[378,378,-30,-30,-6,-6,2,2,-6,-6,-9,0,0,6,6,2,2,2,2,-2
 ,-2,2,2,-2,-9,0,3,3,3,3,0,0,0,-1,-1,0,0,0,0,0
 ,0,0,0,0,0,0,0,-2,0,0,-1,-1,-1,-1,0,0,0,1,0,1]
,[405,-405,-45,45,-27,27,-3,3,-3,3,0,0,0,-3,3,3,3,-3,-3,5
 ,-5,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 ,0,-1,-1,1,-1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0]
,[420,420,20,20,4,4,-12,-12,4,4,0,-3,3,-4,-4,0,0,0,0,-4
 ,-4,0,0,0,0,-3,-4,4,4,-4,3,1,1,0,0,-1,-1,1,1,1
 ,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0]
,[512,512,0,0,0,0,0,0,0,0,-16,8,-4,0,0,0,0,0,0,0
 ,0,0,0,2,-16,8,0,0,0,0,-4,0,0,0,0,0,0,0,0,0
 ,0,1,0,0,0,0,-1,2,0,0,0,0,0,0,0,0,1,-1,-1,-1]]

set !e7_characters = [vec]:
   let tensor ([int] x,[int] y) = [int]: for xi@i in x do xi*y[i] od
   , comp = complement(60,E7_positions)
   , result = for :60 do null(0) od { start with empty slots }
in for p@i in E7_positions
   do result[p]:=rows[i]; result[comp[i]]:=tensor(rows[i],rows[0])
   od; result

{ element order and class size, one column for each class in Magma order }

set e7_profile = mat: { shape (4,60) }
   let e7_orders_sizes = mat:
      [ 1,2,2,2,2,2,2,2,2,2,3,3,3,4,4,4,4,4,4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,6,6,6
       ,6,6,6,6,6,7,8,8,8,8,9,10,10,10,12,12,12,12,12,12,14,15,18,30
      | 1,1,63,63,315,315,945,945,3780,3780,672,2240
         ,13440,3780,3780,7560,7560,7560,7560,11340,11340,45360,45360,48384
         ,672,2240,10080,10080,10080,10080,13440,20160,20160,30240,30240,40320
       ,40320,40320,40320,120960,120960,207360,90720,90720
         ,90720,90720,161280,48384,145152,145152,60480,60480
	 ,60480,60480,120960,120960,207360,96768,161280,96768
      ]
   , sgn_index=1, reflection_index=3
in e7_orders_sizes ^ ^[e7_characters[sgn_index],e7_characters[reflection_index]]

set Magma_reorder_E7 = (->[int]): { map Magma to |class_table_E7| class nrs }
   let perm =[int]: [] { placeholder, awaiting constrution }
in @:
   if =#perm else perm { used previously computed value if present }
   then
      let Wct = class_table_E7()
      then Wct_prof = mat: { with shape (4,60) }
	 let reps=Wct.class_representatives(), sizes=Wct.class_sizes() in
	 4 # for j:Wct.n_classes
	     do [reps[j].order, sizes[j], Wct.sign[j], Wct.reflection[j] ]
	     od
      then profile_ranked = [int]: { columns |e7_profile| ranked |lex_lesseq| }
	 sort(#e7_profile
	     ,(int i,int j)bool: lex_lesseq(e7_profile[i],e7_profile[j]))
      , Wct_ranked = { columns of |Wct_prof| ranked by |lex_lesseq| }
	 sort(#Wct_prof,(int i,int j): lex_lesseq(Wct_prof[i],Wct_prof[j]))
      then ranking = [int]:  { ranking[j]|: Magma class |j| rank }
         inverse(profile_ranked)
      in perm:=compose_permutations(Wct_ranked,ranking)
   fi

set Magma_class_reps_E7() = [WeylElt]: { class representatives in Magma order }
   let reps = class_table_E7().class_representatives() in
   for j in Magma_reorder_E7() do reps[j] od

set E7_name(vec chi) = string:
   let Wct = class_table_E7(), psi = null(#chi)
   then degree = { first reorder |chi| for |Wct| into |psi| }
      for j@i in Magma_reorder_E7() do psi[j]:=chi[i] od { inverse reordering }
   ;  first(class_table_E7().root_datum.nr_of_posroots+1
           ,(int k) bool: Wct.inner(psi,Wct.sym_power_refl(k)).>
	   )
in to_string("irrep(dim:",psi[0],",deg:",degree,")")

set character_table_E7() = CharacterTable:
   let classes = [WeylElt,classical_class,string]:
      for w@j in Magma_class_reps_E7()
      do (w,null_class()
         ,let (P,n)=class_signature_E7(w) in P.compressed_string + n
	 )
      od
   ,  irreps = [classical_irrep,string,[int]]:
      for character@i in e7_characters
      do (null_irrep()
         ,case i in "trivial", "sign", "sign*reflection", "reflection"
	  else E7_name(character)
	  esac
	 ,character
	 )
      od
   in character_table(class_table_E7(),classes,irreps)
