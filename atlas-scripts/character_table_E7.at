<basic.at
<combinatorics.at
<W_characters.at
<character_tables.at
{<nilpotent_orbits.at}
{<character_table_E7_data.at}

{ Unlike other exceptional simple types, the class invariant of the cycle type
  of the permutation of the roots defined by a Weyl group element does not
  entirely separate conjugucy classes: three pairs of classes are ambiguous.
  In each case the type of |Levi_datum(w)| will distinguish the pairs, and
  indeed just the number of simple factors of this type will do: one member of
  the pair gives a single factor, while the other one has 2,3, or 4 factors.

  Since |Levi_datum(w)| is cheaper to compute then say |centralizer_order(w)|,
  we use this number of simple factors as additional component in order to
  characterise conjugacy classes, useful for looking up arbitrary elements |w|.
}

set class_signature_E7 (WeylElt w) = (Partition,int):
   let rd=root_datum(w)
in ( for c in root_orbits(w) do #c od.sort_to_partition
   , w.Levi_datum.Lie_type.simple_factors.#
   )

{ comparison of root cycle types first, use second component to disambiguate }
set leq_E7_signatures ((Partition P,int m),(Partition Q,int n)) = bool:
   case cmp_equal_sum_partitions(P,Q) then true in m<=n else false esac

{ Compared ot other types, fast construction of a class table for E7 takes quite
  a bit of preparation effort. Having a sorted list of class signatures will
  speed up searching for elements, as in other types, but computing class powers
  is harder. In most cases using just the root permutation cycle type suffices:
  for unambiguous classes their powers are also unambiguous, and it turns out
  that even powers of ambiguous classes are unambiguous as well (the ambiguous
  classes have even element orders 2,4,6). Odd powers of ambiguous classes are
  still ambiguous; in most cases they are the ambiguous class itself, but the
  thrid powers of the ambiguous classes with element order 6 give the ambiguous
  classes with order 2, with the "one simple factor" condition unchanged. We can
  therefore avoid actually computing powers of signatures of class
  representatives. This however requires the sorted list of class signatures to
  be transformed into a sorted |list| of just permutation cycle types (for
  searching without needing to know the Levi datum), with associated to each a
  list of 1 or 2 class numbers. In most cases the number of factors is not used
  at all, but in the ambiguous cases we use whther or not that nuber equals 1.
}
set class_table_E7 (RootDatum rd) = WeylClassTable:
   let classes = [WeylElt]: assert(#test_simple_type("E",rd)=7,"Not E7")
	       ; conjugacy_class_reps(rd)
   then sigs = [Partition,int]: { class signatures; to be modified a bit below }
      for w in classes do class_signature_E7(w) od
   then N=2903040 { order_W("E7") }
   ,  (lookup_w,lookup_cyc) { define two functions that share precomputed data }
         = ((WeylElt->int),(Partition->[int])):
      let ranked = [int]:
         sort(#sigs,(int i,int j)bool: leq_E7_signatures(sigs[i],sigs[j]))
      then (list,locs) = ([Partition],[[int]]): { sorted cycle type, positions }
         let locs=[int]:[], prev= Partition:[]
	 then out = [Partition,[int]]: { grouping of |sigs[ranked[i]] values }
	    for loc@rank in ranked
	    do let (lambda,)=sigs[loc] in
	       if =rank then [] next prev:=lambda; locs:=[loc]
	       elif lambda=prev then [] next locs#:=loc
	       else [(prev,locs)] next prev:=lambda; locs:=[loc]
	       fi
	    od.##
      in out #:= (prev,locs) { attach last group; now split into (list,locs): }
      ;  ( for (lambda, ) in out do lambda od, for (,locs) in out do locs od )
      then locate(Partition lambda) = int: { position of |lambda| in |list| }
         binary_search_first
	   ((int i)bool: leq_equal_sum_partitions(lambda,list[i]), 0,#list)
   in ( { lookup_w = } (WeylElt w) int:
        let (lambda,n)=class_signature_E7(w) then locs = locs[locate(lambda)]
	in if #locs=1 or n=1 {single factor} then locs[0] else locs[1] fi
      , { lookup_cyc = } (Partition mu) [int]: locs[locate(mu)]
      )
in W_class_table ( rd
		 , classes
		 , (int i) int: N\centralizer_order(classes[i])
		 , lookup_w
		 , (int i,int k) int:
		   let (lambda,n)=sigs[i] then locs = lookup_cyc(lambda)
		   in if k.is_odd and #locs>1
		      else cycle_power(lambda,k).lookup_cyc [0] {unambiguous}
		      then { cycle type will still be ambiguous }
		         let seq = #(n>1) in { 0/1 value to disambiguate }
			 assert(locs[seq]=i); { check }
			 cycle_power(lambda,k).lookup_cyc [seq]
		      fi
		 )

{ we shall do storage of the class table for one particular E6 root datum }
set !standard_datum_E7 = RootDatum: simply_connected("E7")

{ voluntarily override previous definition to memoize for |standard_datum_E6| }
set class_table_E7 = (RootDatum->WeylClassTable):
   let Wct= trivial_character_table.class_table { place holder value }
in (RootDatum rd) WeylClassTable:
   if rd != standard_datum_E7 then class_table_E7(rd) { this is not recursion! }
   elif =Wct.root_datum.rank { whether this is the first time we are called }
   then Wct:=class_table_E7(rd) { compute and store the first time }
   else Wct { any next time just return the previously computed value }
   fi

set class_table_E7() = WeylClassTable: class_table_E7(standard_datum_E7)

{ To save space we shall list only half of the characters, in Magma ordering.
  The first is the sign character, and the missing characters are formed from
  the given ones by tensoring with this sign character. We just need to indicate
  the indices in the Magma numbering of the given characters; the tensor
  products will give the caracters at the missing indices, in increasing order.
}
set E7_positions = [int]:
[1,3,5,9,8,11,15,14,17,19,21,27,24,26,29
,31,33,35,37,41,40,43,47,46,49,51,53,55,57,59]

{ the characters in the subset |dual_map| under Magma numbering }
set !e7_table = [vec]: { 60 entries each, broken 20|20|20 across lines }
[[1,-1,-1,1,1,-1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,1,1
 ,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1,1
 ,-1,1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,-1] { the sign character }
,[7,-7,5,-5,-1,1,3,-3,-1,1,4,-2,1,3,-3,3,-1,1,-3,-1
 ,1,1,-1,2,-4,2,2,-2,2,-2,-1,-2,2,0,0,1,-1,1,-1,-1
 ,1,0,-1,1,1,-1,1,-2,0,0,0,0,2,-2,0,0,0,-1,-1,1] { the refection character }
,[15,15,-5,-5,7,7,3,3,-1,-1,0,-3,3,-1,-1,1,-3,-3,1,3
 ,3,1,1,0,0,-3,-2,-2,-2,-2,3,1,1,0,0,1,1,1,1,-1
 ,-1,1,-1,-1,1,1,0,0,0,0,-2,-2,0,0,-1,-1,1,0,0,0]
,[21,-21,11,-11,5,-5,5,-5,-3,3,6,3,0,1,-1,3,3,-3,-3,1
 ,-1,1,-1,1,-6,-3,2,-2,2,-2,0,1,-1,2,-2,-2,2,-2,2,0
 ,0,0,1,-1,1,-1,0,-1,-1,1,0,0,0,0,-1,1,0,1,0,-1]
,[21,21,9,9,-3,-3,1,1,-3,-3,6,3,0,5,5,3,-1,-1,3,1
 ,1,-1,-1,1,6,3,0,0,0,0,0,3,3,-2,-2,0,0,0,0,0
 ,0,0,1,1,-1,-1,0,1,-1,-1,0,0,2,2,-1,-1,0,1,0,1]
,[27,27,15,15,3,3,7,7,3,3,9,0,0,3,3,5,1,1,5,-1
 ,-1,1,1,2,9,0,3,3,3,3,0,0,0,1,1,0,0,0,0,0
 ,0,-1,-1,-1,1,1,0,2,0,0,-1,-1,1,1,0,0,-1,-1,0,-1]
,[35,35,15,15,11,11,7,7,3,3,5,-1,2,-1,-1,1,5,5,1,3
 ,3,1,1,0,5,-1,3,-1,-1,3,2,-1,-1,1,1,0,0,2,2,0
 ,0,0,1,1,-1,-1,-1,0,0,0,1,1,-1,-1,-1,-1,0,0,-1,0]
,[35,-35,5,-5,3,-3,-5,5,3,-3,5,-1,2,7,-7,1,1,-1,-1,-1
 ,1,-1,1,0,-5,1,-1,3,-3,1,-2,-3,3,1,-1,-2,2,0,0,0
 ,0,0,-1,1,-1,1,-1,0,0,0,1,-1,1,-1,-1,1,0,0,1,0]
,[56,-56,24,-24,-8,8,8,-8,0,0,11,2,2,0,0,4,-4,4,-4,0
 ,0,0,0,1,-11,-2,3,-1,1,-3,-2,2,-2,-1,1,0,0,2,-2,0
 ,0,0,0,0,0,0,-1,-1,1,-1,1,-1,-1,1,0,0,0,1,1,-1]
,[70,-70,10,-10,-10,10,6,-6,-2,2,-5,7,1,2,-2,-2,-2,2,2,2
 ,-2,-2,2,0,5,-7,1,1,-1,-1,-1,1,-1,3,-3,-1,1,1,-1,1
 ,-1,0,0,0,0,0,1,0,0,0,1,-1,1,-1,1,-1,0,0,-1,0]
,[84,84,4,4,20,20,4,4,4,4,-6,3,3,4,4,0,0,0,0,4
 ,4,0,0,-1,-6,3,-2,2,2,-2,3,-1,-1,-2,-2,1,1,-1,-1,1
 ,1,0,0,0,0,0,0,-1,-1,-1,0,0,0,0,1,1,0,-1,0,-1]
,[105,-105,-25,25,-7,7,9,-9,1,-1,0,6,3,-3,3,3,3,-3,-3,-3
 ,3,1,-1,0,0,-6,-4,4,-4,4,-3,-2,2,0,0,1,-1,1,-1,1
 ,-1,0,1,-1,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
,[105,-105,35,-35,1,-1,5,-5,1,-1,15,-3,-3,5,-5,5,1,-1,-5,1
 ,-1,-1,1,0,-15,3,-1,-1,1,1,3,-1,1,-1,1,1,-1,-1,1,1
 ,-1,0,1,-1,-1,1,0,0,0,0,-1,1,1,-1,1,-1,0,0,0,0]
,[105,-105,-5,5,17,-17,-3,3,-7,7,0,6,3,-3,3,1,-3,3,-1,1
 ,-1,-1,1,0,0,-6,-2,-2,2,2,-3,-2,2,0,0,-1,1,1,-1,-1
 ,1,0,1,-1,-1,1,0,0,0,0,-2,2,0,0,0,0,0,0,0,0]
,[120,120,40,40,-8,-8,8,8,0,0,15,-6,0,0,0,4,-4,-4,4,0
 ,0,0,0,0,15,-6,1,1,1,1,0,-2,-2,-1,-1,-2,-2,-2,-2,0
 ,0,1,0,0,0,0,0,0,0,0,1,1,-1,-1,0,0,1,0,0,0]
,[168,-168,-40,40,8,-8,8,-8,8,-8,6,6,-3,0,0,0,0,0,0,0
 ,0,0,0,-2,-6,-6,2,-2,2,-2,3,-2,2,2,-2,1,-1,1,-1,-1
 ,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,-1]
,[189,189,-39,-39,21,21,1,1,-3,-3,9,0,0,-3,-3,-1,-5,-5,-1,1
 ,1,-1,-1,-1,9,0,3,3,3,3,0,0,0,1,1,0,0,0,0,0
 ,0,0,1,1,-1,-1,0,-1,1,1,-1,-1,1,1,0,0,0,-1,0,-1]
,[189,189,-51,-51,-3,-3,13,13,-3,-3,9,0,0,-3,-3,1,1,1,1,-3
 ,-3,1,1,-1,9,0,-3,-3,-3,-3,0,0,0,1,1,0,0,0,0,0
 ,0,0,1,1,1,1,0,-1,-1,-1,1,1,1,1,0,0,0,-1,0,-1]
,[189,189,21,21,-3,-3,-11,-11,-3,-3,9,0,0,9,9,1,1,1,1,1
 ,1,1,1,-1,9,0,-3,-3,-3,-3,0,0,0,1,1,0,0,0,0,0
 ,0,0,-1,-1,-1,-1,0,-1,1,1,1,1,1,1,0,0,0,-1,0,-1]
,[210,-210,-10,10,-14,14,10,-10,2,-2,-15,-6,3,6,-6,2,2,-2,-2,-2
 ,2,-2,2,0,15,6,-1,-1,1,1,-3,2,-2,1,-1,1,-1,-1,1,-1
 ,1,0,0,0,0,0,0,0,0,0,-1,1,-1,1,0,0,0,0,0,0]
,[210,210,50,50,2,2,2,2,-6,-6,15,3,0,-2,-2,2,2,2,2,-2
 ,-2,-2,-2,0,15,3,-1,-1,-1,-1,0,-1,-1,-1,-1,2,2,2,2,0
 ,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,1,1,0,0,0,0]
,[216,216,-24,-24,24,24,8,8,0,0,-9,0,0,0,0,4,-4,-4,4,0
 ,0,0,0,1,-9,0,-3,-3,-3,-3,0,0,0,-1,-1,0,0,0,0,0
 ,0,-1,0,0,0,0,0,1,1,1,1,1,-1,-1,0,0,-1,1,0,1]
,[280,280,40,40,24,24,8,8,0,0,-5,-8,-2,0,0,-4,4,4,-4,0
 ,0,0,0,0,-5,-8,1,-3,-3,1,-2,0,0,-1,-1,-2,-2,0,0,0
 ,0,0,0,0,0,0,1,0,0,0,-1,-1,1,1,0,0,0,0,1,0]
,[280,-280,40,-40,-8,8,-8,8,8,-8,10,10,1,0,0,0,0,0,0,0
 ,0,0,0,0,-10,-10,-2,2,-2,2,-1,2,-2,-2,2,-1,1,-1,1,-1
 ,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,-1,0]
,[315,-315,45,-45,-21,21,3,-3,3,-3,0,-9,0,-5,5,-3,-3,3,3,3
 ,-3,-1,1,0,0,9,0,0,0,0,0,-3,3,0,0,0,0,0,0,0
 ,0,0,1,-1,1,-1,0,0,0,0,0,0,0,0,-1,1,0,0,0,0]
,[336,-336,16,-16,16,-16,-16,16,0,0,6,-6,0,0,0,0,0,0,0,0
 ,0,0,0,1,-6,6,-2,2,-2,2,0,2,-2,2,-2,2,-2,2,-2,0
 ,0,0,0,0,0,0,0,-1,-1,1,0,0,0,0,0,0,0,1,0,-1]
,[378,378,-30,-30,-6,-6,2,2,-6,-6,-9,0,0,6,6,2,2,2,2,-2
 ,-2,2,2,-2,-9,0,3,3,3,3,0,0,0,-1,-1,0,0,0,0,0
 ,0,0,0,0,0,0,0,-2,0,0,-1,-1,-1,-1,0,0,0,1,0,1]
,[405,-405,-45,45,-27,27,-3,3,-3,3,0,0,0,-3,3,3,3,-3,-3,5
 ,-5,1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 ,0,-1,-1,1,-1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0]
,[420,420,20,20,4,4,-12,-12,4,4,0,-3,3,-4,-4,0,0,0,0,-4
 ,-4,0,0,0,0,-3,-4,4,4,-4,3,1,1,0,0,-1,-1,1,1,1
 ,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,0,0]
,[512,512,0,0,0,0,0,0,0,0,-16,8,-4,0,0,0,0,0,0,0
 ,0,0,0,2,-16,8,0,0,0,0,-4,0,0,0,0,0,0,0,0,0
 ,0,1,0,0,0,0,-1,2,0,0,0,0,0,0,0,0,1,-1,-1,-1]]

set !e7_characters = [vec]:
   let tensor ([int] x,[int] y) = [int]: for xi@i in x do xi*y[i] od
   , comp = complement(60,E7_positions)
   , result = for :60 do null(0) od { start with empty slots }
in for p@i in E7_positions
   do result[p]:=e7_table[i]; result[comp[i]]:=tensor(e7_table[i],e7_table[0])
   od; result

{ element order and class size, one column for each class in Magma order }

set e7_profile = mat: { shape (4,60) }
   let e7_orders_sizes = mat:
      [ 1,2,2,2,2,2,2,2,2,2,3,3,3,4,4,4,4,4,4,4,4,4,4,5,6,6,6,6,6,6,6,6,6,6,6,6
       ,6,6,6,6,6,7,8,8,8,8,9,10,10,10,12,12,12,12,12,12,14,15,18,30
      | 1,1,63,63,315,315,945,945,3780,3780,672,2240
         ,13440,3780,3780,7560,7560,7560,7560,11340,11340,45360,45360,48384
         ,672,2240,10080,10080,10080,10080,13440,20160,20160,30240,30240,40320
       ,40320,40320,40320,120960,120960,207360,90720,90720
         ,90720,90720,161280,48384,145152,145152,60480,60480
	 ,60480,60480,120960,120960,207360,96768,161280,96768
      ]
   , sgn_index=1, reflection_index=3
in e7_orders_sizes ^ ^[e7_characters[sgn_index],e7_characters[reflection_index]]

set Magma_reorder_E7(WeylClassTable Wct) = [int]: { map Magma to |Wct| numbers }
   let  Wct_prof = mat: { with shape (4,60) }
      let reps=Wct.class_representatives, sizes=Wct.class_sizes in
      4 # for j:Wct.n_classes
	  do [reps[j].order, sizes[j], Wct.sign[j], Wct.reflection[j] ]
	  od
   then profile_ranked = [int]: { columns |e7_profile| ranked |lex_lesseq| }
      sort(#e7_profile
	  ,(int i,int j)bool: lex_lesseq(e7_profile[i],e7_profile[j]))
   , Wct_ranked = { columns of |Wct_prof| ranked by |lex_lesseq| }
      sort(#Wct_prof,(int i,int j): lex_lesseq(Wct_prof[i],Wct_prof[j]))
   in compose_permutations(Wct_ranked,inverse(profile_ranked))

set character_table_E7(RootDatum rd) = CharacterTable:
   let Wct = class_table_E7(rd)
   then reordering = Magma_reorder_E7(Wct)
   then E7_name(vec chi) = string:
      let psi = null(#chi)
      then degree = { first reorder |chi| for |Wct| into |psi| }
	 for j@i in reordering do psi[j]:=chi[i] od { inverse reordering }
      ;  first(Wct.root_datum.nr_of_posroots+1
	      ,(int k) bool: Wct.inner(psi,Wct.sym_power_refl(k)).>
	      )
      in to_string("irrep(dim:",psi[0],",deg:",degree,")")
   then classes = [WeylElt,classical_class,string]:
      let reps = Wct.class_representatives
      in for j in reordering
	 do (reps[j],null_class()
	    ,let (P,n)=class_signature_E7(reps[j]) in P.compressed_string + n
	    )
	 od
   ,  irreps = [classical_irrep,string,[int]]:
      for character@i in e7_characters
      do (null_irrep()
         ,case i in "trivial", "sign", "sign*reflection", "reflection"
	  else E7_name(character)
	  esac
	 ,character
	 )
      od
   in character_table(Wct,classes,irreps)

{ voluntarily override previous definition to memoize for |standard_datum_E7| }
set character_table_E7 = (RootDatum->CharacterTable):
   let ct= trivial_character_table { place holder value }
in (RootDatum rd) CharacterTable:
   if rd != standard_datum_E7 then character_table_E7(rd) { no recursion! }
   elif =ct.root_datum.rank { whether this is the first time we are called }
   then ct:=character_table_E7(rd) { compute and store the first time }
   else ct { any next time just return the previously computed value }
   fi


set character_table_E7() = CharacterTable:
   character_table_E7(standard_datum_E7)
