<basic.at
<polynomial.at { for type |i_poly| and function |eval| }
<convert_c_form.at { final part of unitarity computation }
<facetiousBC.at { for facet structures }
<to_ht.at {for to_ht}

{need to build in shifted versions of partial_KL_block and KL_sum}
{ this file defines commands that are equivalent to the |full_deform| command
  that is now built-in; it therefore serves mainly documentation (and
  historic) purposes, and should not be required for any other scripts. In
  fact we added some initial commands that mimic the methods |KL_sum_at_s|
  and |deformation_terms| that were already originally implemented directly in
  the library, and used through the |deform| atlas command, in order to show
  after the fact how this could have been done as an atlas script
}

{meant to count invocations of a function. Do use() in the function.}
set_type [Counter = ( (void -> int) use_count, (void -> void) use)  ]

set make_counter () = Counter:
    let ticker = int:0
    in (( -> int): {use_count}@int: ticker
       ,( -> ): {use} @: let () = ticker+:=1 in ())

set to_htK(int N) = (KTypePol->KTypePol): (KTypePol P):
    let(below,) = height_split(P,N) in below

set_type ShiftData = (RealForm real_form, VertexData v_data
	 , [[FacetVertsHash]] hash_facet_inds, [[ratvec]] facet_barys
	 , [(ratvec->int)] ratLookups, [(vec->int)] intLookups
	 , vec_hash hash_up, vec_hash hash_down)

{IL_hash lists all integrality labels in the order found; up_inds[j] is the
	 location of bup for label #j in hash_up}
set_type ShiftDataFast = (RootDatum root_datum, {VertexData v_data,} vec up_inds,
	 vec down_inds, vec_hash IL_hash, vec_hash hash_up, vec_hash hash_down)

set shift_data(RealForm G) = ShiftData:
    let old_codim = facet_codim
    then () = facet_codim:=-1
    then FPPDH = facet_data_fold_hash(cofolded(G))
    then () = facet_codim:=old_codim
    then (vd,FPPh) = FPPDH
    {last two coords of F are index in hashUp and hashDown of bup, bdown}
    then FBs = for Fs@dim in FPPh
    	       do for F in Fs
	       	  do facet_bary(vd.list,F[:dim+1])
		  od
	       od
    then rat_lookups = for FB in FBs do index_in(FB) od
    then vec_lookups = for Finds@d in FPPh
    	 	       do index_in( for v in Finds
		       	  	    do v[:d+1]
				    od )
		       od
    in (G, vd, FPPh, FBs, rat_lookups, vec_lookups, hashUp, hashDown)

{identifies the facet of a dominant gamma}
set integrality_label(RootDatum G, ratvec gamma) = vec:
    let PCR = G.poscoroots
    then vals = gamma*PCR
    then x = vec: for v in vals
       	    do let r = v%1
	       in if r=0 then v.numer
		  else (r-v).numer - 1
		  fi
	    od
    in vec: for j:((#x)\3)
       	    do x[3*j] + 32 + 64*(x[3*j+1] + 32) + 4096*(x[3*j+2] + 32)
	    od # sum( for i:(#x)%3 from 3*(#x\3)
	       	      do 64^(i%3)*(x[i] + 32)
	    	      od )

{dom ratweight in the FPP for E8 or smaller gives label value between -32 and 31
 on pos coroot. So record values in threes as x_{3j} + 32, 64*(x_{3j+1}+32),
 64^2*(x_{3j+2}+32).}

{
gamma = ratvec is a ratvec for Sp(2n), often assumed dominant.

Here's the algorithm:

take each coord gamma[i] of gamma not divisible by 1/2, and replace it
by -gamma[i] if necessary so that it's in (0,1/2) mod 1.

take all integer coords gamma[i] and move their absolute values to the
the right end, in decreasing order.
]
take all half integer coords gamma[i] and move their absolute values
to the left end in decreasing order.

Rearrange the remaining coords (all congruent to some epsilon[j] in
(0,1/2) mod 1) and arrange them first in decreasing order by
epsilon[j], then (within each class) in decreasing order. Call the
result gammaSTD; it is usually NOT dominant.

The integrality datum for gammaSTD is the STANDARD pseudoLevi

SO(2a) x GL(r_last) x ... x GL(r_0) x Sp(2b),

of which there are only 2^{n+1} possibillities, and and gamma is dominant for it.

The weight bdown is constant on first a coords, next r_last coords...,
next r_0 coords, and zero on last b coords. The constant values are
chosen to ensure that gamma+bdown is DOMINANT.

The weight bup is a W-conjugate of bdown: essentially it's constant on
each collection of coordinates congruent to \pm epsilon[j], except you
change the sign if it's congruent to -epsilon.

More detailed notes follow, but they were written before the script
was, and they are maybe less correct.

---------------
sgns = n signs: ith is minus iff gamma[i] % 1 is in (1/2,1).
mods[i] = epsilon in [0,1/2];  gamma[i]%1, or 1-\epsilon if in (1/2,1).
	actually next two are sorted into three pieces, for the int coords,
	for the coords not 0 or 1/2 mod 1, and for the half-int coords
epsilonsSort = [ratvec] is a sorted list of the distinct values of mod in
	     (0,1/2).
ranges = [[vec]]; ranges[j] is the subset of [0,n) where the coordinates
     of gamma take the values \pm epsilon[j]  mod 1.
gammaSgn[i] = gamma[i]*sgns[i]
gammaRanges[j] = coords of gammaSgn in ranges[j], sorted to be decreasing
bupCoords: bupCoords[j] is a nonneg integer, to be added to all the
     coords in ranges[j] (with minus in case of -epsilon), so that
     last coord of gammaRanges[j] + bup[j] > first coord of gammaRanges[j+1]
}
set shift_countBC = make_counter()

set sgns(ratvec gamma) = [bool]:
    for r in gamma do r%1 > 1/2 od

set mods(ratvec gamma) = [rat]:
    for r@j in gamma
    do let res = r%1
       in if res=0 then 0
       	  elif res=1/2 then res
       	  elif res < 1/2 then res
       	  else 1-res
       	  fi
    od

{ increasing list of the rats in (0,1/2) for the GL factors of
  integrality datum }
set epsilonsSort(ratvec gamma) = [rat]:
    let epsilons = for r in mods(gamma)
    		   do if (r = 0) or (r=1/2) then []
		      else [r]
		      fi
		   od.##
    in if #epsilons = 0 then []
       else ((epsilons.numer).sort_u)/epsilons.denom
       fi

set rangeInt(ratvec gamma) = [int]:
    for r@i in gamma do if r%1 = 0 then [i] else [] fi od.##

set rangeHalfInt(ratvec gamma) = [int]:
    for r@i in gamma do if r%1 = 1/2 then [i] else [] fi od.##

{ one list of ints for each epsilon in the sorted list epsilonSort }
set rangesEpsilon(ratvec gamma) = [[int]]:
    let mods = mods(gamma)
    in for epsilon@j in epsilonsSort(gamma)
    do for i:#mods
    do if mods[i] = epsilon then [i] else [] fi od.##
    od

set gammaSgn(ratvec gamma) = ratvec:
    for j: #gamma do if sgns(gamma)[j] then -gamma[j]
    	   	     else gamma[j]
		     fi
		  od

{returns C-dominant integer coords, various dominant GL coords, B-dominant
 half-integer coords}
set gammaRanges(ratvec gamma) = (ratvec, [ratvec], ratvec):
    let gamma_sgn = gammaSgn(gamma)
    in ( for i in rangeInt(gamma) do abs(gamma[i]) od.sort,
    for R in rangesEpsilon(gamma) do for i in R do gamma_sgn[i] od.sort od,
    for i in rangeHalfInt(gamma) do abs(gamma[i]) od.sort)

{ always add 0 to C string. vec is constants to add to A strings. Last int
  is constant to add to D string }
set bUpCoords(ratvec gamma) = (int, vec, int):
    let c = int: 0, C=int: 0, d=int: 0
    then (gamma_int, gamma_ranges, gamma_half_int) = gammaRanges(gamma),
    	epsilons = epsilonsSort(gamma)
    then try = null(#gamma_ranges)
    then () = if #gamma_int > 0 then C:=c+rat_as_int(gamma_int~[0]) fi
    then () = if #gamma_ranges>0
    	      then try[0]:= C - floor(gamma_ranges[0][0])
	      fi
    then () = for j:#gamma_ranges -1 from 1
    	      do try[j]:= try[j-1] +  floor(gamma_ranges[j-1]~[0] -
	      	 	  gamma_ranges[j][0]) + 1
	      od
    then () = if #gamma_half_int >0
    	      then if #gamma_ranges > 0 and gamma_ranges~[0]~[0] > 0
	      {if gamma_ranges~[0]~[0] NEGATIVE, then need to use
	      	  -try~[0]}
    	      	   then d:= try~[0] + floor(gamma_ranges~[0]~[0] -
		   	    gamma_half_int[0]) + 1
		   elif #gamma_ranges > 0 {now last is negative}
    	      	   then d:= try~[0] + floor(-gamma_ranges~[0]~[0] -
		   	    gamma_half_int[0]) + 1
		   elif (#gamma_ranges = 0 and #gamma_int>0)
		   then d:=c + 1+floor(gamma_int~[0] -
		   	   gamma_half_int[0])
		   fi
	      fi
    in (c, try, d)

{computes the translation weights bup and bdown for an Sp(2n)
 infinitesimal character gamma}
{and probably also SO(2n+1)?}
set shifterC(ratvec gamma) = (vec, vec):
    let sgns = sgns(gamma)
    then () = shift_countBC.use()
    then range_int = rangeInt(gamma), range_half_int= rangeHalfInt(gamma),
    	 ranges = rangesEpsilon(gamma)
    then (c,try,d) = bUpCoords(gamma)
    then bup = vec: null(#gamma)
    then () = for R@j in ranges
    	      do for i in R
	      	 do bup[i]:= try[j]*(if sgns[i] then -1 else 1 fi)
	    	 od
	      od
    then () = for i in range_int
    	      do bup[i] := c {should mult by sgn(gamma[i], but will be pos}
	      od
    then () = for i in range_half_int
    	      do bup[i] := d
	      od
    in (bup, (for i:#range_half_int do -d od) ##
       	      (for R@j in ranges~
       	       do for i in R do -try[j] od
   	       od.##) ##
    	       (for i:#range_int do -c od)
	       )
{
set bup_hash = vec_hash: make_vec_hash()
set bdown_hash = vec_hash: make_vec_hash()
set gamma_hash = vec_hash: make_vec_hash()

set shifterBC(ratvec gamma) = (vec, vec):
    let m = gamma_hash.match( gamma.numer#gamma.denom)
    in if m = minus_1
    	 then let (bup,bdown) = shifterC(gamma)
	      in (bup,bdown);
	      bup_hash
}

set shift_dataBC(RealForm G) = ShiftData:
    let () = facet_codim:=-1
    then SFPPD = short_facet_data(G)
    then (vd,sFPP) = SFPPD
    then FBss = [[ratvec]]:
    	 for Fs@dim in sFPP
    	 do let FsNew = Fs
	    then FBs = [ratvec]:
		 for v@j in Fs
	       	 do let FB = facet_bary(vd.list,v)
		    then (bup,bdown) = shifterC(FB)
		    then MupDown=vec: [hashUp.match(bup), hashDown.match(bdown)]
		     {these need to become last two coords of F}
		    then () =  FsNew[j] := v##MupDown
		    in FB
		  od; sFPP[dim] := FsNew
	     in FBs
	 od
    then rat_lookups = for FBs in FBss do index_in(FBs) od
    then vec_lookups = for Fs@d in sFPP
    	 	       do index_in( for v in Fs
		       	  	    do v[:d+1]
				    od )
		       od
    in (G, vd, sFPP, FBss, rat_lookups, vec_lookups, hashUp, hashDown)

set shift_data_fastBC(RootDatum rd) = ShiftDataFast:
    let hash_up = make_vec_hash(), hash_down = make_vec_hash(),
    	IL_hash = make_vec_hash(), up_inds = vec:[], down_inds = vec:[]
    {then v_data = FPP_vertex_data(rd,-1)}
    then FPPbs = FPP_barycenters(rd,-1).##
    then () = for v in FPPbs
    	 do let (bup,bdown) = shifterC(v)
	    then () = IL_hash.match(integrality_label(rd,v))
	    then () = up_inds:=up_inds# hash_up.match(bup)
	    then () = down_inds:=down_inds# hash_down.match(bdown)
	    in ()
	 od
    in (rd, {vd,} up_inds, down_inds, IL_hash, hash_up, hash_down)

set shift_dataG(RealForm G) = ShiftData:
    let () = facet_codim:=-1
    then FPPDH = facet_data_fold_hash(cofolded(G))
    then (vd,FPPH) = FPPDH
    then FBss = [[ratvec]]:
    	 for Fs@dim in FPPH
    	     do for F in Fs
	       	do facet_bary(vd.list,F[:dim+1])
		od
	     od
    then rat_lookups = for FBs in FBss do index_in(FBs) od
    then vec_lookups = for Finds@d in FPPH
    	 	       do index_in( for v in Finds
		       	  	    do v[:d+1]
				    od )
		       od
    in (G, vd, FPPH, FBss, rat_lookups, vec_lookups, hashUp, hashDown)

set KL_sum_at_s(ParamPol P) = ParamPol:
    sum(P.real_form,for c@q in P do c*KL_sum_at_s(q) od)

set barycenter(SimpleAffine Affd, ratvec gamma) = ratvec:
    let FV = facet_verts(Affd,gamma)
    in (1/#FV)*sum(Affd.rank,FV)

{need function gamma -> (dim,index) to record the facet of gamma}
{walls(gamma) = ([int], G.semisimple_rank - dim)}
{better if gamma replaced by alcove center}
set coordsA(ShiftData shift_data, ratvec gamma) = (int,int):
    let G = shift_data.real_form
    then (,m) = walls(G,gamma)
    then dim = G.semisimple_rank - m
    in (m, shift_data.ratLookups[m](gamma))

set coordsB(ShiftData shift_data, ratvec gamma) = (int,int):
    let G = shift_data.real_form
    then FV = facet_verts(G,gamma)
    then ind = for v in FV do shift_data.v_data.lookup(v) od
    in (#ind-1, shift_data.intLookups[#ind-1](ind))

set coordsC(ShiftData shift_data, ratvec gamma) = (int,int):
    let G = shift_data.real_form
    then FB = facet_bary(G,gamma)
    then locs = for lookup@d in shift_data.ratLookups do lookup(FB) od
    then d = first(for m in locs do m>= 0 od)
    then m = if d = minus_1 then minus_1 else locs[d] fi
    in (d,m)

set shift_count = make_counter()


set shifts(ShiftData shift_data, ratvec gamma) = (vec, vec):
    let () = shift_count.use()
    then (d,m) = coordsB(shift_data,gamma)
    {then (d,m) = coordsC(shift_data,gamma) twice as slow for C4?}
    in if m = minus_1 then (null(#gamma), null(#gamma))
       else let v = shift_data.hash_facet_inds[d][m]
       	    in (shift_data.hash_up.index(v~[1])
	       , shift_data.hash_down.index(v~[0]))
       fi

set shifts(ShiftData shift_data, Param p) = (vec, vec):
    shifts(shift_data, p.infinitesimal_character)

set shiftsFast(ShiftDataFast shift_data_fast, ratvec gamma) = (vec, vec):
    let () = shift_count.use()
      {next vec indexes the facet of gamma}
    then (rd,up_inds,down_inds,IL_hash,hash_up,hash_down) = shift_data_fast
    then ell =integrality_label(rd,gamma)
    then j=IL_hash.lookup(ell)
    in if j>=0 then (hash_up.index(up_inds[j]),
		    hash_down.index(down_inds[j]))
       else (null(#gamma),null(#gamma))
       fi

{
What's true: if p = (x,lambda,nu) has infinitesimal character gamma,
and (bup,bdown) = shifts(gamma), then

character_formula(p) = translate_param_by(character_formula(
1*(x,lambda+bup, nu + bup),bdown)
}

{RHS does KL calculations at just 2^{rank + 1} integrality data.}

{first list is params {p[i]} in bruhat interval above p.
 mat M
 last list is pols in q f[j].
 KL pol for p[i] and p[i'] is f(M[i',i])}


set partial_KL_block(Param p, (ratvec->(vec,vec)) shifter) = ([Param],mat,[vec]):
    let (bup,bdown) = shifter(p.infinitesimal_character)
    then pUp = normal(translate_param_by(p,bup))
    then (blockUp, M, pols) = partial_KL_block(pUp)
    in (for q in blockUp do normal(translate_param_by(q,bdown)) od, M,pols)

set dual_KL_block(Param p, (ratvec->(vec,vec)) shifter) = ([Param],int,mat,[vec]):
    let (bup,bdown) = shifter(p.infinitesimal_character)
    then pUp = normal(translate_param_by(p,bup))
    then (blockUp,j,M,pols) = dual_KL_block(pUp)
    in (for q in blockUp do normal(translate_param_by(q,bdown)) od,j,M,pols)

{ replaces built-in deform}
set deformation_terms (Param p, (ratvec->(vec,vec)) shifter) = ParamPol:
  let (B,KL_mat,length) = ([Param],mat,vec):
    let (block,M,polys) = partial_KL_block(p:=normal(p), shifter)
    then l = vec: for q in block do q.length od, n=#block
    , p_1= for Q in polys do eval(Q,minus_1) od
    in
    ( block
    , for col@j in M
      do let lj=l[j] in
	 for entry@i in col do minus_1^(lj-l[i])*p_1[entry] od
      od
    , l
    )
  then nB=#B in
  if =nB or B~[0]!=p
  then null_module(p) { if |p| itself is not among survivors, return 0 }
  else { compute final column |acc| of |Q| matrix by solving linear system
         $P'*acc=e_p$ with $P'$ a matrix of Split, columns from |KL_sum_at_s| }
    let remainder = null(nB-1)#1 { start with standard basis vector for |p| }
    , solution=null(nB)
    , !opposite_parity=1-length~[0]%2 { opposite to that of |length(p)| }
    , !on_p = orientation_nr(p)
    in
    for q_ind : nB
    ~do let contrib=remainder[q_ind]*KL_mat[q_ind] in
      remainder -:= contrib
    ; if length[q_ind]%2=opposite_parity
      then solution +:= contrib
      fi
    od
  ; null_module(p)+
    for c@i in solution
    do { twist (1-s)*solution according to orientation numbers of its terms }
      let x=B[i] then (q,r)=(on_p-orientation_nr(x))\%2 in
      assert(=r,"odd orientation");
      (minus_1^q*c*one_minus_s,x) { we have |s^q*c*(1-s) = (-1)^q*c(1-s)| }
      { for the same reason we replaced |s| by |-1| in computations giving |c| }
    od
  fi

{height cutoff done crudely at end; better to do it along the way}
set deformation_terms (Param p, int max_height, (ratvec->(vec,vec)) shifter) =
    ParamPol:
  let (B,KL_mat,length) = ([Param],mat,vec):
    let (block,M,polys) = partial_KL_block(p:=normal(p), shifter)
    then l = vec: for q in block do q.length od, n=#block
    , p_1= for Q in polys do eval(Q,minus_1) od
    in
    ( block
    , for col@j in M
      do let lj=l[j] in
	 for entry@i in col do minus_1^(lj-l[i])*p_1[entry] od
      od
    , l
    )
  then nB=#B in
  if =nB or B~[0]!=p
  then null_module(p) { if |p| itself is not among survivors, return 0 }
  else { compute final column |acc| of |Q| matrix by solving linear system
         $P'*acc=e_p$ with $P'$ a matrix of Split, columns from |KL_sum_at_s| }
    let remainder = null(nB-1)#1 { start with standard basis vector for |p| }
    , solution=null(nB)
    , !opposite_parity=1-length~[0]%2 { opposite to that of |length(p)| }
    , !on_p = orientation_nr(p)
    in to_ht(max_height)(
    for q_ind : nB
    ~do let contrib=remainder[q_ind]*KL_mat[q_ind] in
      remainder -:= contrib
    ; if length[q_ind]%2=opposite_parity
      then solution +:= contrib
      fi
    od
  ; null_module(p)+
    for c@i in solution
    do { twist (1-s)*solution according to orientation numbers of its terms }
      let x=B[i] then (q,r)=(on_p-orientation_nr(x))\%2 in
      assert(=r,"odd orientation");
      (minus_1^q*c*one_minus_s,x) { we have |s^q*c*(1-s) = (-1)^q*c(1-s)| }
      { for the same reason we replaced |s| by |-1| in computations giving |c| }
    od)
  fi

set deformation_terms_by_dual (Param p, (ratvec->(vec,vec)) shifter) = ParamPol:
  assert(p.is_final,"deformation requires a final parameter");
  let (block,KL_mat,P_polys) = partial_KL_block(p,shifter)
  , (full_block,start,dual_KL_mat,dual_polys) = dual_KL_block(p,shifter)
  then pol_eval =  for P in P_polys do eval(P,minus_1) od
  , dual_pol_eval = for P in dual_polys do eval(P,minus_1) od
  , l_sg = for q in block do minus_1^length(q) od
  , to_full = (int->int):
    let map = p.null_module + for q@i in full_block do (Split:(i,1),q) od
    in (int i) int: let c=map[block[i]] in assert(!=c,"absent"); c.int_part
  then P_mat = mat:
    for col@j in KL_mat do for e@i in col do l_sg[i]*l_sg[j]*pol_eval[e] od od
  , Q_mat = mat:
    for col in ^dual_KL_mat do for e in col do dual_pol_eval[e] od od
  , opposite_parity=1-length(p)%2 { opposite to that of |length(p)| }
  then solution = sum
    ( #block { size of vectors being summed (after conversion to matrix) }
    # for q@i in block
      do if length(q)%2=opposite_parity
	 then [ Q_mat[i.to_full,start]*P_mat[i] ]
	 else []
	 fi
      od.##
    )
  , !on_p = orientation_nr(p)
in null_module(p) +
   for q@i in block
   do { twist (1-s)*solution according to orientation numbers of its terms }
     ( orientation_nr_term(on_p,q)*solution[i]*one_minus_s , q )
   od

set deformation_terms_by_dual (Param p,int max_height,
    (ratvec->(vec,vec)) shifter) = ParamPol:
(  assert(p.is_final,"deformation requires a final parameter")
;  assert(p.height<=max_height,"height bound kills term to deform")
;  let (full_block,start,dual_KL_mat,polys) = dual_KL_block(p,shifter)
   then subset = [int]:
     for q@i in full_block do if q.height<=max_height then [i] else [] fi od.##
   , ev = for P in polys do eval(P,minus_1) od
   , Q_col = vec:[] { vector variable to be assigned below }
   then Q_mat = mat: { transpose, select rows/cols from |subset|, set $q:=-1$ }
     for i in subset
     do let col = vec: for j in subset do ev[dual_KL_mat[i,j]] od
     in if i=start then Q_col:=col else col fi { store the column for |p| }
     od
   , block = [Param]: for i in subset do full_block[i] od
   then signed_P_mat = { $(-1)^{l(x,y)}P_{x,y}[q:=-1]$ for $x,y$ in |block| }
      inverse(Q_mat)
   , lp_parity=p.length%2 { parity of length that is excluded below }
   then solution = vec:
      { compute more efficiently: |signed_P_mat*diagonal(odd_levels)*Q_col|,
        where |odd_levels=vec: for q@i in block do #q.length%2!=lp_parity| }
        subset := { reuse local variable, now for selecting odd levels }
           for q@i in block do if q.length%2=lp_parity then [] else [i] fi od.##
      ; (mat: signed_P_mat.n_rows # for j in subset do signed_P_mat[j] od)
       *(vec: for i in subset do Q_col[i] od)
  , !on_p = orientation_nr(p)
in null_module(p) +
   for q@i in block
   do { twist (1-s)*solution according to orientation numbers of its terms }
     ( orientation_nr_term(on_p,q)*solution[i]*one_minus_s , q )
   od
)

set_type
[ ReductionStatus = (void reducible | Param lower )
]

{ go to next reducibility point (move even if at reducibility point) }
set reduction_at (Param p) = ReductionStatus:
   let rp=(0/1)#reducibility_points(p)
in if rp~[0]=1 then reducible()
   else lower(p*rp~[0])
   fi

set next_down (Param p) = Param:
   let rp=(0/1)#reducibility_points(p)
in assert(rp~[0]=1,"Not a reducibility: "+p.to_string); p*rp~[1]

{ use |deformation_terms_by dual| for a full deformation, in which we try to
  group all successive deformations involving a same block together }
set deform_to_height (Param p,int max_height, (ratvec->(vec,vec)) shifter) =
    KTypePol:
(  assert(p.height<=max_height,"height bound kills term to deform")
;  let G=real_form(p)
   then !K_empty=null_K_module(G), !empty=null_module(G)
in { first ensure there is a potential deformation at |p| }
   case reduction_at(p)
      | lower(q): p:=q
      | reducible(): () { keep p }
      esac
;  let queue = ParamPol: p, result = KTypePol: K_empty, lower = ParamPol:empty
in while >#queue or
       if >#lower else false
       then set (queue,lower) := height_split(lower,height(first_param(lower)))
       ; true
       fi
   do { invariant of the loop: all terms in |queue| have potential deformation }
      let (c0,q):term = first_term(queue)
   in queue:= (queue next queue:=empty) - term
   ;  if =nu(q) then result := (result next result:=K_empty) + (c0,q.K_type)
      else lower:= (lower next lower:=empty) + (c0,next_down(q))
      fi
   ;  let terms = deformation_terms_by_dual(q,max_height,shifter)
   in for c@r in terms
      do case reduction_at(r)
         | reducible():
	    queue:= (queue next queue:=empty) + (c0*c,r)
         | lower(qq): { element of initial block, but no further deformation }
	    lower:= (lower next lower:=empty) + (c0*c,qq)
         esac
      od
   od
;  result
)

{ the original version of this file started here }

set d_verbose=false

{ if at reducibility point stay there, otherwise go to next lower one }
set weak_lower (Param p) = Param:
  let (x,lambda,gamma)=%p, rp=reducibility_points(p)
  then lim = #rp
  in param(x,lambda,gamma*if lim=0 then 0 else rp[lim-1] fi)

{ go to next reducibility point (move even if at reducibility point) }
set lower (Param p) = Param:
  let (x,lambda,gamma)=%p, rp=reducibility_points(p)
  then lim = let nrp=#rp in if nrp>0 and rp[nrp-1]=1/1 then nrp-1 else nrp fi
  in  param(x,lambda,gamma*if lim=0 then 0 else rp[lim-1] fi)

set deformation (Param p, (ratvec->(vec,vec)) shifter) = (Param,ParamPol):
    { deformed Param and new terms }
    {(lower(p),deform(p))} {close to KL_sum...}
    { here |deform| may be replaced by |deformation_terms| }
    {preceding line _was_ built-in deform; want to test the change!}
    let (bup,bdown) = shifter(p.infinitesimal_character)
    in (lower(p), translate_param_by( deform( first_param(
       translate_param_by(p,bup))),bdown))

{this I think is the replacement for the built-in full_deform}
set recursive_deform (Param p, (ratvec->(vec,vec)) shifter) = KTypePol:
  if d_verbose then prints("recursive_deform with:", p) fi;
  if not is_final(p) then error("improper parameter") fi;
  let empty=null_module(real_form(p)) in
  if d_verbose { choose verbose or non-verbose version of the function }
  then rec_fun full_def (Split sc,Param p, (ratvec->(vec,vec)) shifter)
       KTypePol:
	 { |sc| will simply scale the coefficients of resulting KTypePol }
    begin
      {p := alcove_center(p);}
      if d_verbose
      then prints("full_def with: sc=", sc, ", p=", p,
      	   p.infinitesimal_character)
      fi;
      assert(is_standard(p)
	    ,"non standard parameter encountered in deformation");
      let acc=empty, at_nu0=KTypePol: sc*(p.K_type) { fully deformed |p| } in
      for factor in reducibility_points(p)
      ~do
	let p_def=p*factor { next deformation of |p| }
	then def=deformation_terms(p_def,shifter)
	     { bypass built-in |deform| here }
        in
	  prints("adding deformation term: p=", p_def, new_line,"adding:", def)
      ; acc+:=def
      od
    ; for k@q in acc { traverse the sum of the deformation terms spun off }
      do { apply |full_def| recursively to all those terms }
        at_nu0 +:= full_def(sc*k,q,shifter)
	       { gather harvest from those deformations }
      od
    ; prints("full_def complete, result:",at_nu0)
    ; at_nu0
    end
  else rec_fun full_def (Split sc,Param p, (ratvec->(vec,vec)) shifter) KTypePol:
	 { |sc| will simply scale the coefficients of resulting KTypePol }
    begin
      p := alcove_center(p);
      assert(is_standard(p),"non standard parameter in deformation");
      let acc=empty, at_nu0=KTypePol: sc*(p.K_type) { fully deformed |p| } in
      for factor in reducibility_points(p)
      ~ { direction of deformation is down, towards 0; this is not essential }
      do acc+:=deformation_terms(p*factor,shifter) od
    ; for k@q in acc { traverse the sum of the deformation terms spun off }
      do at_nu0 +:= full_def(sc*k,q,shifter) od
    ; at_nu0
    end
  fi { apply that recursive function to the initial argument: } (1,p,shifter)


{this I think is the replacement for the built-in full_deform}
set recursive_deform (Param p, int max_height, (ratvec->(vec,vec)) shifter) =
    KTypePol:
  if d_verbose then prints("recursive_deform to height with:", p) fi;
  if not is_final(p) then error("improper parameter") fi;
  let empty=null_module(real_form(p)) in
  if d_verbose { choose verbose or non-verbose version of the function }
  then rec_fun full_def (Split sc,Param p, int max_height,
       	       (ratvec->(vec,vec)) shifter) KTypePol:
	 { |sc| will simply scale the coefficients of resulting KTypePol }
    begin
      {p := alcove_center(p);}
      if d_verbose
      then prints("full_def to height with: sc=", sc, ", p=", p,
      	   p.infinitesimal_character)
      fi;
      assert(is_standard(p)
	    ,"non standard parameter encountered in deformation");
      let acc=empty, at_nu0=KTypePol: sc*(p.K_type) { fully deformed |p| } in
      for factor in reducibility_points(p)
      ~do
	let p_def=p*factor { next deformation of |p| }
	then def=deformation_terms(p_def, max_height, shifter)
	     { bypass built-in |deform| here }
        in
	  prints("adding deformation term: p=", p_def, new_line,"adding:", def)
      ; acc+:=def
      od
    ; for k@q in acc { traverse the sum of the deformation terms spun off }
      do { apply |full_def| recursively to all those terms }
        at_nu0 +:= full_def(sc*k,q,max_height,shifter)
	       { gather harvest from those deformations }
      od
    ; prints("full_def complete, result:",at_nu0)
    ; at_nu0
    end
  else rec_fun full_def (Split sc,Param p, int max_height,
       	       (ratvec->(vec,vec)) shifter) KTypePol:
	 { |sc| will simply scale the coefficients of resulting KTypePol }
    begin
      p := alcove_center(p);
      assert(is_standard(p),"non standard parameter in deformation");
      let acc=empty, at_nu0=KTypePol: sc*(p.K_type) { fully deformed |p| } in
      for factor in reducibility_points(p)
      ~ { direction of deformation is down, towards 0; this is not essential }
      do acc+:=deformation_terms(p*factor,shifter) od
    ; for k@q in acc { traverse the sum of the deformation terms spun off }
      do at_nu0 +:= full_def(sc*k,q,max_height,shifter) od
    ; at_nu0
    end
  fi { apply recursive function to initial argument: } (1,p,max_height,shifter).(to_htK(max_height))

{ code that follows is adapted from hermitian.at to do unitarity computation
  in terms of the above functions rather than built-ins
}

set oriented_KL_sum (Param p, (ratvec->(vec,vec)) shifter) = ParamPol:
   let ori_nr_p = orientation_nr(p)
   then (bup,bdown) = shifter(p.infinitesimal_character)
   in  null_module(real_form(p)) +
   for c@q in translate_param_by(KL_sum_at_s(1*translate_param_by(p,bup)),bdown)
   do (c*orientation_nr_term(ori_nr_p,q),q) od

{ untwisted |c_form_irreducible|, for efficiency; only used in equal rank case }
set c_form_irreducible (Param p, (ratvec->(vec,vec)) shifter) = KTypePol:
  let P=oriented_KL_sum(p, shifter), count=0 then nP=#P
  then
    f(Param p) = if (d_verbose and (count<11 or count%10=0 or nP-count<=10))
                 then prints("Term ",count,": ",p)
		 fi; count+:=1; recursive_deform(p, shifter)
  in if d_verbose
     then prints("Fully deforming ",nP," terms")
     fi; map(f, P)

set c_form_irreducible (Param p, int max_height, (ratvec->(vec,vec)) shifter) =
    KTypePol:
  let P=oriented_KL_sum(p, shifter), count=0 then nP=#P
  then
    f(Param p) = if (d_verbose and (count<11 or count%10=0 or nP-count<=10))
                 then prints("Term ",count,": ",p)
		 fi; count+:=1; recursive_deform(p,max_height,shifter)
  in if d_verbose
     then prints("Fully deforming ",nP," terms")
     fi; map(f, P)

{ utility: compute fixed and unfixed contributions to c-form on irreducible(p)
  no deformation is done, but orientation numbers are included;
  fixed contributions are already halved; for unfixed ones this needs to wait
}
set twisted_c_form_irreducible_contributions (Param p) =
    (ParamPol,ParamPol): { (fixed part, 2*unfixed part) }
  let G=p.real_form, ori_nr_p = orientation_nr(p)
  then fixed_terms=G.null_module, unfixed_terms=G.null_module
  in
  for c@q in (1+s)*KL_sum_at_s(p) + (1-s)*twisted_KL_sum_at_s(p)
  do if twist(q)=q
     then fixed_terms+:=(half(c)*orientation_nr_term(ori_nr_p,q),q)
     else unfixed_terms+:=(c*orientation_nr_term(ori_nr_p,q),q)
     fi
  od; (fixed_terms,unfixed_terms)

{ for now we do not have any script for the twisted deformation; use built-in }
set twisted_c_form_irreducible (Param p) = KTypePol:
( let (fixed,unfixed)=twisted_c_form_irreducible_contributions(p)
{ |1+s| divides |unfixed|, no need for |scale_extended|; take half at |nu=0| }
  , count=0
  then nf=#fixed
  then
    f(Param p) = if d_verbose and (count<11 or count%10=0 or nf-count<=10)
                 then prints("Term ",count,": ",p)
		 fi; count+:=1; twisted_full_deform(p)
  in if d_verbose then
     prints("Fully twisted deforming ",nf," terms (",#unfixed," unfixed).")
     fi
; map(f,fixed)+half(unfixed.K_type_pol)
)

{.whether J(p) admits an invariant Hermitian form.}
set is_hermitian (Param p) = bool: equivalent(twist(p),p)

set check_hermitian (Param p) = void:
  assert(p.is_hermitian
        ,"Irreducible module does not admit any invariant Hermitian form"
	)
set hermitian_form_irreducible (Param p, (ratvec->(vec,vec)) shifter) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_irreducible(p, shifter)
       { not twisted, in equal rank case this is faster }
  else check_hermitian(p); twisted_c_form_irreducible(p)
  fi.convert_cform_hermitian

set hermitian_form_irreducible (Param p, int max_height,
    (ratvec->(vec,vec)) shifter) = KTypePol:
  if is_equal_rank(real_form(p))
  then c_form_irreducible(p, max_height, shifter)
       { not twisted, in equal rank case this is faster }
  else check_hermitian(p); twisted_c_form_irreducible(p)
  fi.convert_cform_hermitian

{ compute Hermitian form on p, and report if it is unitary }
set is_unitary (Param p, (ratvec->(vec,vec)) shifter) = bool:
  p.is_hermitian and hermitian_form_irreducible(p,shifter).is_pure

set is_unitary_to_height (Param p, int max_height, (ratvec->(vec,vec)) shifter) =
    bool:
    p.is_hermitian and hermitian_form_irreducible(p,max_height,shifter).is_pure

set is_unitary_test (Param p, int med_height, int max_height,
    (ratvec->(vec,vec)) shifter) = bool:
   is_unitary_to_height(p,med_height,shifter) and
   is_unitary_to_height(p,max_height,shifter) and
   is_unitary(p,shifter)

{ NOW can come versions of facetious commands using shifter! }

set localDV(KGBElt x, ratvec lambda, ShiftData SD)  = [string]:
    let shifter = (ratvec->(vec,vec)): (ratvec v) (vec,vec): shifts(SD,v)
    then tester = (Param->bool): (Param p) bool: is_unitary(p,shifter)
    then LFD = localFD_hash(x,lambda,(SD.v_data, SD.hash_facet_inds))
    then (Lvd,,,LFverts) = LFD
    then vlistZero = for v0 in LFverts[0] do Lvd.list[v0[0]] od
    then LvdZero = to_vertex_data(vlistZero)
    then pol_nums = localKchars(LFD)
    then ((eq,gr),IUCL,CLBF) = localGraph(LFD,pol_nums)
    then statuses = [string]: for j:#eq do "?" od
    then () = statuses:=local_facet_statusU(x, lambda, LvdZero,
    	      IUCL, CLBF, statuses)
    in local_test(x, lambda, Lvd, LFverts, eq, gr, CLBF, statuses,
       tester)

{problem with next three and general ShiftData is that the shifts go outside
  the FPP, so don't get the nice KL memory saving.}
set localDV_test(KGBElt x, ratvec lambda, ShiftData SD)  = [string]:
    let shifter = (ratvec->(vec,vec)): (ratvec v) (vec,vec): shifts(SD,v)
    then hts = next_heights(parameter(x,lambda,0*lambda),2)
    then tester = (Param->bool): (Param p) bool: is_unitary_test(p,
    	 hts[0], hts[1], shifter)
    then LFD = localFD_hash(x,lambda,(SD.v_data, SD.hash_facet_inds))
    then (Lvd,,,LFverts) = LFD
    then vlistZero = for v0 in LFverts[0] do Lvd.list[v0[0]] od
    then LvdZero = to_vertex_data(vlistZero)
    then pol_nums = localKchars(LFD)
    then ((eq,gr),IUCL,CLBF) = localGraph(LFD,pol_nums)
    then statuses = [string]: for j:#eq do "?" od
    then () = statuses:=local_facet_statusU(x, lambda, LvdZero,
    	      IUCL, CLBF, statuses)
    in local_test(x, lambda, Lvd, LFverts, eq, gr, CLBF, statuses,
       tester)

set localBC_test_fast(KGBElt x, ratvec lambda, ShiftDataFast SDF)  = [string]:
    let rd = x.root_datum
    then vd = FPP_vertex_data(rd,-1)
    then shifter = (ratvec->(vec,vec)): (ratvec v) (vec,vec): shiftsFast(SDF,v)
    then hts = next_heights(parameter(x,lambda,0*lambda),2)
    then tester = (Param->bool): (Param p) bool: is_unitary_test(p,
    	 hts[0], hts[1], shifter)
    then LFD = localFDBC(x,lambda, (vd,FPP_facets(rd,vd,-1)))
    then (Lvd,,,LFverts) = LFD
    then vlistZero = for v0 in LFverts[0] do Lvd.list[v0[0]] od
    then LvdZero = to_vertex_data(vlistZero)
    then pol_nums = localKcharsBC(LFD,shifter)
    then ((eq,gr),IUCL,CLBF) = localGraph(LFD,pol_nums)
    then statuses = [string]: for j:#eq do "?" od
    then () = statuses:=local_facet_statusU(x, lambda, LvdZero,
    	      IUCL, CLBF, statuses)
    in local_test(x, lambda, Lvd, LFverts, eq, gr, CLBF, statuses,
       tester)

set sphericalDV(RealForm G) = [string]:
    let SD = shift_data(G)
    in localDV(x_open(G),G.rho,SD)

set sphericalDV_test(RealForm G) = [string]:
    let SD = shift_data(G)
    in localDV_test(x_open(G),G.rho,SD)

set sphericalBC_test_fast(RealForm G) = [string]:
    let SDF = shift_data_fastBC(G)
    in localBC_test_fast(x_open(G),G.rho,SDF)

{Only works for Sp or maybe SO(odd)}
set smallTest(RealForm G) = bool:
    let verts = FPP_vertices(G,-1)
    then Ps = for v in verts do parameter(x_open(G),G.rho,v) od
    in all(for p in Ps
       	   do is_unitary(p) = is_unitary(p,shifterC@ratvec)
	   od
	   )

set bigTest(RealForm G) = bool:
    let verts = FPP_barycenters(G,-1).##
    then Ps = for v in verts do parameter(x_open(G),G.rho,v) od
    in all(for p in Ps
       	   do is_unitary(p) = is_unitary(p,shifterC@ratvec)
	   od
	   )

set smallTimeTest(RealForm G) = void:
    let verts = FPP_vertices(G,-1)
    then Ps = for v in verts do parameter(x_open(G),G.rho,v) od
    then bools = for p in Ps
       	   do is_unitary(p,shifterC@ratvec)
	   od
    in ()

set middleTimeTest(RealForm G, int d) = void:
    let verts = FPP_barycenters(G,d,-1)
    then Ps = for v in verts do parameter(x_open(G),G.rho,v) od
    then bools = for p@j in Ps
       	       	 do is_unitary(p,shifterC@ratvec)
	   	 od
    in ()


set bigTimeTest(RealForm G) = void:
    let verts = FPP_barycenters(G,-1).##
    then Ps = for v in verts do parameter(x_open(G),G.rho,v) od
    then bools = for p in Ps
       	   do is_unitary(p,shifterC@ratvec)
	   od
    in ()

set smallTimeTestOld(RealForm G) = void:
    let verts = FPP_vertices(G,-1)
    then Ps = for v in verts do parameter(x_open(G),G.rho,v) od
    then bools = for p@j in Ps
       	       	 do is_unitary(p)
	   	 od
    in ()

set middleTimeTestOld(RealForm G, int d) = void:
    let verts = FPP_barycenters(G,d,-1)
    then Ps = for v in verts do parameter(x_open(G),G.rho,v) od
    then bools = for p@j in Ps
       	       	 do is_unitary(p)
	   	 od
    in ()

set bigTimeTestOld(RealForm G) = void:
    let verts = FPP_barycenters(G,-1).##
    then Ps = for v in verts do parameter(x_open(G),G.rho,v) od
    then bools = for p in Ps
       	   do is_unitary(p)
	   od
    in ()
