<FPP_globalDirac.at
<FPP_global.at


{This script runs (backward, for no serious reason) over a sequence of
KGBElts x in E7_s, beginning at start and ending before start +
interval. For each x, it computes the corresponding lambdas; then for
each (x,lambda) it computes the list of FPP-unitary facets of
parameters (x,lambda,*). These are assembled in LISTS = [[Param]],
with one [Param] for each x. In practice what's interesting is the
final Param's stored in Uhash.

If you replace E7_s by some small group (say F4_s) and start by
something in the middle of KGB(G) (say 100), you can quickly see what
it does.

I'm running this precise script on my laptop. After 15 minutes the job
has grown to 60 mb, and has so far analyzed 8 of the 130 lambdas for
the FIRST KGBElt. The first 8 lambdas finished probably in less than a
minute; the ninth is taking a quite a long time.

We can talk about how best to harvest the output from jobs like this,
but even if the main loop is interrupted with CTRL-C, the hash table
of Param's Uhash will remain accessible.

I'm not sure whether my little experiment proves that this is viable
idea or not. My do-them-all jobs on atlas are computing an average of
one KGBElt each 90 minutes.
}

set params(Param_hash unitary_hash)=[Param]:
 for i:unitary_hash.size() do unitary_hash.index(i) od

set FPP_unitary_hash(RealForm G, int x)=[Param]:let ()=FPP_unitary_hash([KGB(G,x)]) in params(unitary_hash)
set FPP_unitary_hash2(RealForm G, int x)=[Param]:let ()=FPP_unitary_hash2([KGB(G,x)]) in params(unitary_hash)

set FPP_unitary_hash_one_level(RealForm G, int x)=[Param]:
unitary_hash:=make_Param_hash();prints("BEFORE:",params(unitary_hash));let ()=FPP_unitary_hash_one_level([KGB(G,x)]) in params(unitary_hash)

set test_verbose=false
{coh_ind_flag:   default true, means COMPUTE cohomological induction
                 if you precompute cohomological induction, load the data file (e.g. coh_ind_E7_has.at) which should set it to false}
revert_flag:=true     {default is true: try other possibly faster ones (default is true; false: only use the given function}
deform_flag:=false    {default is false}
{global_top: should be set by file such as global_facets_E7.at}

{output flags:}
every_KGB_flag:=true
every_lambda_flag:=true
every_lambda_deets_flag:=true
test_slightly_verbose:=true
test_verbose:=true

{NOTE: extra_files is defined in FPP.py}

set global_facets_file_loaded=false   {set true at the end of global_facets_file}
set coh_ind_file_loaded=false   {set true at the end of global_facets_file}

set FPP(RealForm G,int KGB_number)=[Param]:
let vd = FPP_vertex_data(G) then
Uhash = make_Param_hash() then
()=unipotents_to_hash(G,Uhash) then
()=prints("G=", G,new_line,"KGB element: ", KGB_number) then
list=[Param]:[] then
x = KGB(G,KGB_number) then
lambdas = FPP_lambdas(x) then
() = prints("KGB #",KGB_number,":",new_line, "#lambdas=",#lambdas,
   	     	    ", #Uhash = ", Uhash.size())
then ()= ##for lambda@j in lambdas
  do prints("lambda #",j,", #Uhash = ", Uhash.size());
    local_test_GEO_hash_one_level(x,lambda, Uhash)
od
in prints("got list: ", list);list


set is_fixed(WeylElt w,KGBElt x)=bool: cross(w,x)=x
set is_fixed(KGBElt x)=bool: cross(x.real_form.w0,x)=x

set kgb_fixed(RealForm G)=[int]:
   ##for x in KGB(G) do if is_fixed(G.w0,x) then [number(x)] else [] fi od

set kgb_non_fixed(RealForm G)=
   ##for x in KGB(G) do if number(cross(G.w0,x))>number(x) then [number(x)] else [] fi od


{to write a list of Param's for a single RealForm}
{change from writeFiles.at: "<groups.at"
and if x\ne cross(w0,x) then write contragredient representation also}
set write_param_list_jda([Param] list, string listName) = void:
if #list=0
  then prints(listName,"[Param]:=[]")
else
  prints("set Nullp = U(1,0).trivial");
  prints("set ",listName,"=[Param]: for i:",#list," do Nullp od");
  prints("DOING regular",list[0].x);
  prints("LIST: ", list);
  for p@i in list
    do let (,x) = %p.x
     in prints("void:",listName,"[",i,"]:=parameter(KGB(G_temp,",x,"),",p.lambda,",",p.nu,")");
     if not is_fixed(p.x) then
        let dp=contragredient(p) in 
        prints("void:",listName,"[",i,"]:=parameter(KGB(G_temp,",number(dp.x),"),",dp.lambda,",",dp.nu,")","  {dual}")
     fi
    od
fi
