<FPP_globalDirac.at

{This script runs (backward, for no serious reason) over a sequence of
KGBElts x in E7_s, beginning at start and ending before start +
interval. For each x, it computes the corresponding lambdas; then for
each (x,lambda) it computes the list of FPP-unitary facets of
parameters (x,lambda,*). These are assembled in LISTS = [[Param]],
with one [Param] for each x. In practice what's interesting is the
final Param's stored in Uhash.

If you replace E7_s by some small group (say F4_s) and start by
something in the middle of KGB(G) (say 100), you can quickly see what
it does.

I'm running this precise script on my laptop. After 15 minutes the job
has grown to 60 mb, and has so far analyzed 8 of the 130 lambdas for
the FIRST KGBElt. The first 8 lambdas finished probably in less than a
minute; the ninth is taking a quite a long time.

We can talk about how best to harvest the output from jobs like this,
but even if the main loop is interrupted with CTRL-C, the hash table
of Param's Uhash will remain accessible.

I'm not sure whether my little experiment proves that this is viable
idea or not. My do-them-all jobs on atlas are computing an average of
one KGBElt each 90 minutes.
}
set trivial_group=compact_form(trivial_group)

set params(Param_hash unitary_hash)=[Param]:
 for i:unitary_hash.size() do unitary_hash.index(i) od

set params(Param_hash unitary_hash,KGBElt x)=[Param]:
 ##for i:unitary_hash.size() do let p=unitary_hash.index(i)  in if p.x=x then [p] else [] fi od

set params([Param] params,KGBElt x)=[Param]:
 ##for p in params do  if p.x=x then [p] else [] fi od

set params([Param] params,int kgb_number)=[Param]:
 ##for p in params do  if number(p.x)=kgb_number then [p] else [] fi od

set FPP_unitary_hash(RealForm G, int x)=[Param]:let ()=FPP_unitary_hash([KGB(G,x)]) in params(unitary_hash)
set FPP_unitary_hash2(RealForm G, int x)=[Param]:let ()=FPP_unitary_hash2([KGB(G,x)]) in params(unitary_hash)
set FPP_unitary_hash_one_level(RealForm G, int x)=[Param]:let ()=FPP_unitary_hash_one_level([KGB(G,x)]) in params(unitary_hash)
set FPP_unitary_hash_bottom_layer(RealForm G, int x)=[Param]:let ()=FPP_unitary_hash_bottom_layer([KGB(G,x)]) in params(unitary_hash)

low_KGB_frac:=2/5

{coh_ind_flag:   default true, means COMPUTE cohomological induction
                 if you precompute cohomological induction, load the data file (e.g. coh_ind_E7_has.at) which should set it to false}
coh_ind_flag:=false
revert_flag:=true     {default is true: try other possibly faster ones (default is true; false: only use the given function}
deform_flag:=false    {default is false}
{global_top: should be set by file such as global_facets_E7.at}

{output flags:}
test_verbose:=false
every_KGB_flag:=true
every_lambda_flag:=true
every_lambda_deets_flag:=true
test_slightly_verbose:=true
test_verbose:=true
facet_verbose:=true
bottom_length_frac:=1/4
{NOTE: extra_files is defined in FPP.py}

set global_facets_file_loaded=false   {set true at the end of global_facets_file}
set coh_ind_file_loaded=false   {set true at the end of global_facets_file}

{not needed or used}
set local_test_GEO_hash_one_level(KGBElt x, ratvec lambda, Param_hash Uhash) =
    [Param]:
    let G = x.real_form, pol_hash=make_KTypePol_hash()
    then vd = FPP_vertex_data(G)
    in local_test_GEO_hash_one_level(x, lambda, vd, pol_hash, Uhash)

{not needed or used}
set FPPx(RealForm G,int KGB_number)=[Param]:
let vd = FPP_vertex_data(G) then
Uhash = make_Param_hash() then
()=unipotents_to_hash(G,Uhash) then
()=prints("G=", G,new_line,"KGB element: ", KGB_number) then
list=[Param]:[] then
x = KGB(G,KGB_number) then
lambdas = FPP_lambdas(x) then
() = prints("KGB #",KGB_number,":",new_line, "#lambdas=",#lambdas,
   	     	    ", #Uhash = ", Uhash.size())
in  ##for lambda@j in lambdas
  do prints("lambda #",j,", #Uhash = ", Uhash.size());
    local_test_GEO_hash_one_level(x,lambda, Uhash)
od


set is_fixed(WeylElt w,KGBElt x)=bool: cross(w,x)=x
set is_fixed(KGBElt x)=bool: cross(x.real_form.w0,x)=x

set kgb_fixed(RealForm G)=[int]:
   ##for x in KGB(G) do if is_fixed(G.w0,x) then [number(x)] else [] fi od

set kgb_non_fixed(RealForm G)=
   ##for x in KGB(G) do if number(cross(G.w0,x))>number(x) then [number(x)] else [] fi od

set kgb_representatives(RealForm G)=kgb_fixed(G)##kgb_non_fixed(G)

set add_to_hash(Param_hash unitary_hash,[Param] params)=void:
    for p in params do unitary_hash.match(p) od


{to write a list of Param's for a single RealForm}
{change from writeFiles.at: "<groups.at"
and if x\ne cross(w0,x) then write contragredient representation also}
set write_param_list_jda([Param] parameters, string listName, int kgb_number) = void:
let list=params(parameters,kgb_number) {just those with correct x} in
if #list=0
  then prints("set ",listName,"=[Param]:[]")
else
  let G=list[0].real_form then
  x=KGB(G,kgb_number) in 
  let ()=  prints("set Nullp = trivial_group.trivial") then
  ()=prints("set ",listName,"=[Param]: for i:",#list," do Nullp od") then
  not_fixed=not is_fixed(x) in
  let ()=  for p@i in list do
   if p.x=x then
      prints("void:",listName,"[",i,"]:=parameter(KGB(G,",kgb_number,"),",p.lambda,",",p.nu,")")
  fi
  od in
  if not is_fixed(x) then 
   for p@i in list do
    if p.x=x then
       let dp=contragredient(p) in 
       prints("void:",listName,"[",i,"]:=parameter(KGB(G,",number(dp.x),"),",dp.lambda,",",dp.nu,")", "  {dual}")
    fi
   od
  fi
 fi

{add one parameter to hash, return false it was already there, true
if it was actually added}
set update(Param_hash param_hash,Param p)=bool:
    let n=param_hash.size() then
    ()=param_hash.match(p) in
    param_hash.size()>n

{add list of params to hash; return (number of new parameters, list of new parameters)}
set update(Param_hash param_hash,[Param] params)=(int,[Param]):
let rv= ##for p in params do
    if update(param_hash,p) then [p] else [] fi
    od
in (#rv,rv)

{list of parameter in hash}
set parameters(Param_hash param_hash)=[Param]:
    for i:param_hash.size() do param_hash.index(i) od

