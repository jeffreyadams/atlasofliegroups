< basic {for infinitesimal character}
< aff_cube.at {for local_FPP_extrema}
{< FPP_faces_herm.at} {for unitarity tests}
< hash.at {for hash tables}
{< FPP_localDirac.at} { for |unipotents_to_hash| }
{<K_types.at {for branch_std}}
<kl.at {for rho_C}

{set red_coroots_scr(Param p) = [vec]:
    let G = p.real_form, gamma = p.infinitesimal_character
    then pos_co = G.poscoroots
    then theta = p.x.involution
    in for alphav@j in pos_co
       do let gammaj = gamma*alphav
       	  in if is_integer(gammaj) and gammaj.>
       	     then if alphav*theta = -alphav and Cayley((G.posroots)[j],p) != p
   	     	  then [alphav] {parity real root}
	       	  else []
	       	  fi
	     elif ((theta*(gamma.numer))*alphav).<
	     then [alphav] {complex}
	     else []
	     fi
       od.##}

{should require number of -alphav*theta >= number of alphav}
set red_coroots_scr(KGBElt x) = [vec]:
    let G = x.real_form,  theta = x.involution
    then rho = G.rho, pos_co = G.poscoroots
    in for alphav@j in pos_co
       do if (alphav*theta*rho).< and poscoroot_index(G, -alphav*theta) >= j
       	  then [alphav]
	  else []
	  fi
       od.##

set move_theta_scr(WeylElt w) = ((KGBElt,ratvec) -> (KGBElt,ratvec)):
 (KGBElt x, ratvec lambda) (KGBElt,ratvec):
 let G = w.root_datum, x1 = cross(w,x) {added to next 7.29.25}
 then lambda_shift = rho_C(G,x1.involution) - w*rho_C(G, x.involution)
  then rhow = rho(G) - w*rho(G)
 then p1 = parameter(x1, w*lambda + rhow - lambda_shift, 0*lambda)
 in (p1.x, p1.lambda)

{need to study reducibility along av at int values
from int to int inclusive}
{problem arose when lambda not in FPP_lambdas(x). "Fix" assuming just that infl chars are in
convex hull of W*rho}
set range_scr(KGBElt x, ratvec lambda, vec av) = (int, int):
    let upval = av*(x.root_datum.rho) {was local_FPP_extrema(x,lambda)}
    , thplus = 1+x.involution
    {then upvals = for w in lfe do av*w od}
    then downval = av*(thplus*lambda)/2 {value at nu = 0}
    in (floor(downval), ceil(upval))

{need to study reducibility along av at int values
from int to int inclusive}
{set range_scr(KGBElt x, ratvec lambda, ratvec gamma, vec av) = (int, int):
    let thplus = 1+x.involution
    in (floor((av*thplus)*gamma/2), ceil(av*gamma))}

set ranges_scr(KGBElt x, ratvec lambda) = [(vec, (int, int))]:
    let rc = red_coroots_scr(x)
    in for av in rc
       do (av, range_scr(x,lambda,av))
       od

{set ranges_scr(KGBElt x, ratvec lambda, ratvec gamma) = [(vec, (int, int))]:
    let rc = red_coroots_scr(x)
    in for av in rc
       do (av, range_scr(x,lambda,gamma, av))
       od}

{root datum from all coroots restricting to A as multiple of av}
set Levix_scr(KGBElt x, vec av) = (RealForm,KGBElt):
    let G = x.real_form, theta = x.involution
    then pos_r = G.posroots, pos_co = G.poscoroots
    then av_min_th = av - av*theta
    then js = for bv@j in pos_co
    	      do if rank([av_min_th,bv-bv*theta]) <=1
	      	 then [j]
		 else []
		 fi
	      od.##
     then two_rho_L = sum(G.rank, for j in js do pos_r[j] od)
     then min_js = for j in js
     	  	   do if pos_co[j]*two_rho_L = 2
		      then [j]
		      else []
		      fi
		   od.##
     then rdL = root_datum(mat: for j in min_js do pos_r[j] od,
     	      		   mat: for j in min_js do pos_co[j] od, G.prefers_coroots)
     {then tfL = x.torus_factor - G.rho_check + rdL.rho_check}
     then xL = KGB_elt(rdL, theta, x.torus_factor)
    in (real_form(xL),xL)

{given a matrix of roots and a matrix of coroots, choose a maximal set of orthogonal ones}
set orthogonal_scr(mat roots, mat coroots) = ([vec],[vec]):
    let r = #(roots.^) {number of columns in root matrix}
    then entry(int p, int q) = int: 0
    then oroots = [vec]:[], perproots = [vec]: roots
    then ocoroots = oroots, perpcoroots = [vec]: coroots
    in while (#perproots).>
       do let tester = perproots~[0], cotester = perpcoroots~[0]
       	  {then () = prints("tester = ",tester,", cotester = ",cotester)}
       	  in oroots#:= tester;
       	  ocoroots#:= cotester;
	  perproots := for alpha in perproots do if (alpha*cotester).= then [alpha] else [] fi od.##;
	  perpcoroots := for av in perpcoroots do if (tester*av).= then [av] else [] fi od.##
       od;
       (oroots, ocoroots)

{given a matrix of roots and a matrix of coroots, choose sets of positive ones}
set pos_choice_scr(mat roots, mat coroots) = ([vec],[vec]):
    let (O,cO) = orthogonal_scr(roots,coroots)
    then levels = [int]: for alpha in roots
    	 	  	 do first(for cotester in cO
			    	  do (alpha*cotester).!=
				  od)
			 od
    in (for alpha@j in roots
       do if (alpha*cO[levels[j]]).>
       	  then [alpha]
	  else []
	  fi
       od.##,
       for av@j in coroots
       do if (av*O[levels[j]]).>
       	  then [av]
	  else []
	  fi
       od.##)

{given a matrix of roots and a matrix of coroots, sets of simple ones}
set simp_choice_scr(mat roots, mat coroots) = ([vec],[vec]):
    if #roots = 0 then return ([],[]) fi;
    let (PR,cPR) = pos_choice_scr(roots,coroots)
    then tworhocheck = sum(#cPR[0],cPR)
    then simplejs = for alpha@j in PR
       	 	    do if alpha*tworhocheck = 2
       	  	       then [j]
	  	       else []
	  	       fi
       		    od.##
    in (for j in simplejs
       	do PR[j]
	od,
	for j in simplejs
       	do cPR[j]
	od)

{assume x.involution has maximal -1 eigenspace a; construct restricted root datum on a}
set res_stuff_scr(KGBElt x) = ([vec],[vec]):
    let theta = x.involution, G = x.real_form
    then () = assert(@:rank(1-theta) = split_rank(G), "x was not on max split Cartan")
    then T_lower_star = mat: eigen_lattice(theta.^,-1)
    then res_coroot_hash = make_vec_hash()
    then res_root_hash = make_vec_hash()
    then () = for av@j in G.coroots
    	      do let avres = av - av*theta
		 in if avres = 2*av
		    then let resav= required_solution(T_lower_star,av) {real coroots}
		    	 in res_coroot_hash.match(resav);
		    	    res_root_hash.match(G.roots[j]*T_lower_star)
		    elif avres.= or is_coroot(G,avres) {omit imaginary and half of real}
		    then -1
		    else let resav= required_solution(T_lower_star,avres) {complex coroots}
		    	 in res_coroot_hash.match(resav);
			    res_root_hash.match(G.roots[j]*T_lower_star)
		    fi
	       od
     in (res_root_hash.list(), res_coroot_hash.list())

set res_root_datum_scr = (KGBElt -> RootDatum):
    let rfhash = make_RealForm_hash()
    then KGBhashes = [KGBElt_hash]: [] {one hash for each real form}
    then answerhash = make_RootDatum_hash()
    then answer_indices = [vec]: [] {one list of rd indices for each real form,
    	 		  	     size = KGBhash[i].size()}
    in (KGBElt -> RootDatum): (KGBElt x) RootDatum:
       let I = rfhash.size()
       then i = rfhash.match(x.real_form)
       then () = if i = I {haven't seen G before}
       	       	 then KGBhashes #:=make_KGBElt_hash();
	       	      answer_indices #:= null(0)
	  	 fi
       then J = KGBhashes[i].size(), K = answerhash.size()
       then j = KGBhashes[i].match(x)
       then () = if j = J {haven't seen x before}
       	       	 then let (roo,coroo) = res_stuff_scr(x)
    		      then (sroo,scoroo) = simp_choice_scr(roo,coroo)
    		      then k = answerhash.match(root_datum(sroo, scoroo, x.real_form.prefers_coroots))
		      in answer_indices[i] #:= k
		 fi
       in answerhash.index(answer_indices[i][j])

set res_root_datum_scr(RealForm G) = RootDatum:
    res_root_datum_scr(x_open(G))

{assume roots for L are rational linearly closed in roots for G, and
L-positive are G-positive; conjugate L to standard Levi}

{Result (w,xi). Assume is L is Levi of nonstandard REAL P at x,
carried by w from standard real Levi at z1}
set simplifier_theta_scr(RootDatum L, KGBElt x) = (WeylElt, KGBElt):
    {if old_simplifier_theta_flag then return simplifier_theta_old(L,x) fi;}
    let {start = elapsed_ms(),} rd = x.root_datum,  thetamin = (1 - x.involution)
    then S = for a in L.simple_coroots do coroot_index(rd,a) od
    then T = maximize_Levi(rd,S)
    then A = (Levi_simple_coroots(rd,T)), k = #S
    then wt_theta = thetamin*((A,vector(rd.semisimple_rank,(int i)int:#(i>=k)*2^i)/1).required_solution.numer)
    {The powers of two are just a garbage way to make it usually work. Don't know how actually to
    fix it.}
    then (w,wt_theta_dom) = from_dominant(rd,wt_theta)
    then x1 = cross(w.inverse,x)
    in {simpTimer+:= elapsed_ms() - start;}
       (w,x1)

{Result (w,xi). Assume is L is Levi of nonstandard REAL P at x,
carried by w from standard real Levi at z1}
{w needs to account for difference between xL and xLo??}
set simplifier_theta_res_scr(RealForm L, KGBElt x) = (WeylElt, KGBElt):
    {if old_simplifier_theta_flag then return simplifier_theta_old(L,x) fi;}
    let start = elapsed_ms(), rd = x.root_datum,  thetamin = (1 - x.involution), G = x.real_form
    then xL = inverse_embed_KGB(x,L)
    then xLo = x_open(L)
    then xo = embed_KGB(xLo,G)
    then thetao  = xo.involution
    then M = eigen_lattice(thetao.^,-1)
    then rdo = res_root_datum_scr(xo)
    then rdoL = res_root_datum_scr(xLo)
    then S = for a in rdoL.simple_coroots do coroot_index(rdo,a) od
    then T = maximize_Levi(rdo,S)
    then A = (Levi_simple_coroots(rdo,T)), k = #S
    then wt_theta_res = ((A,vector(rdo.semisimple_rank,(int i)int:#(i>=k))/1).required_solution.numer)
    then wt_thetao = (1-thetao)*(required_solution(M.^, wt_theta_res)) {guaranteed to cut out L}
    then (w,) = from_dominant(G,wt_thetao)
    then {x1 = cross(w.inverse,xo),} L1 = (w.inverse)*L
    then xL1 = KGB(L1, xL.number)
    then x1 = embed_KGB(xL1,G)
    in {simpTimer+:= elapsed_ms() - start;}
       (w,x1)

set standardize(KGBElt x, ratvec lambda, vec av) = (KGBElt, ratvec, vec):
    let (L,) = Levix_scr(x,av), G = x.real_form
    then (y,x1) = simplifier_theta_res_scr(L,x)
    {then () = prints("y = ",y)}
    in let (x1m,lambda1) = move_theta_scr(y.inverse)(x,lambda)
        {then () = assert(x1m = x1,"problem with move in standardize")
       then () = assert(1*parameter(x,lambda,0*lambda) = 1*parameter(x1,lambda1,0*lambda1),
       	       	 "problem with x1 and lambda1 in standardize")}
       in (x1,lambda1, av*y)

{parameter on nonstandard Levi L}
set pL_scr(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    let (L,xL) = Levix_scr(x,av), G = x.real_form, theta = x.involution
    then m = coroot_index(G,av) + #G.posroots, {lambdaL = lambda-rho(G) + rho(L)}
    	 lambda_shift = -rho(G) +rho(L) + rho_C(G,theta) - rho_C(L,theta)
    then a = roots(G)[m], lambdaL = lambda + lambda_shift
    then nu1 = (a-theta*a)
    then wt = av*nu1, shift = av*(lambdaL+theta*lambdaL)/2
    in parameter(xL,lambdaL, ((t-shift)/wt)*nu1)

{ rep on minimal real Levi through complex coroot av}
set pL1_scr(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    {if steve_old_flag then return pL1_old(x, lambda, av, t) fi;}
    let (x1,lambda1, av1) = standardize(x,lambda,av)
    in pL_scr(x1,lambda1,av1,t)

set std_quo_scr(Param p) = ParamPol:
    1*p-character_formula(1*p)

set ind_quo_scr(KGBElt x, ratvec lambda, vec av, rat t) = KTypePol:
    let pL = pL_scr(x,lambda,av,t)
    in K_type_pol(std_quo_scr(pL))

set to_ht_scr_G(RealForm G, KTypePol QL, int HT) = KTypePol:
    if HT.< then return QL fi;
    sum(QL.real_form,
	for c@tauL in QL
    	do if dominant(G,parameter(tauL).d_lambda)*(G.two_rho_check) <= HT
	   then c*tauL
	   else 0*tauL
	   fi
	od)

set test_scr(KGBElt x, ratvec lambda, vec av, rat t, int HT) = bool:
    let QL = ind_quo_scr(x,lambda,av,t)
    in if HT < 0
       then QL.!=
       else to_ht_scr_G(x.real_form,QL,HT).!=
       fi
    {to_ht_G(x.real_form, QL,HT).!=}

set red_points_scr_time = int:0

{works for HT < 0, giving all reducibility points}
{omitting the singular real roots gives 2 too many unitary in Sp(6,R)}
{Needs to be applied to deformations of an FPP parameter, which are no longer FPP!}
set red_points_scr_base(KGBElt x, ratvec lambda, vec av, int HT) = [int]:
    let start = elapsed_ms(), (m,M) = range_scr(x,lambda,av) {, thetapl = x.involution+1}
    then ans = for j:M-m+1 from m
       	       do if test_scr(x,lambda,av,j,HT) {or ((av*thetapl).= and j.=)}
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_scr_time +:= elapsed_ms() - start;
     	ans

set red_points_scr_hash_time = int:0

set red_points_scr = ((KGBElt, ratvec, vec, int) -> [int]):
    let xl_hash = make_xlambda_hash()
    then av_hashes = [vec_hash]: [] {one hash table of red coroots at each (x,lambda)}
    then hts = [[int]]: []  {one max HT for each ((x,lambda),av)}
    then answers = [[[int]]]: [] 
    in ((KGBElt, ratvec, vec, int) -> [int]): (KGBElt x, ratvec lambda, vec av, int HT) [int]:
    let N = xl_hash.size(), start = elapsed_ms()
    then n = xl_hash.match(x,lambda)
    then m = -1
    in if n=N {haven't seen (x,lambda) before}
       then av_hashes #:= make_vec_hash([av]);
       	    hts #:= [HT];
       	    answers #:= [red_points_scr_base(x,lambda,av,HT)];
	    m:=0
       else let M = av_hashes[n].size()
	    in  m := av_hashes[n].match(av);
	       if m = M {haven't seen av before}
	       then hts[n]#:=HT;
	       	    answers[n] #:= red_points_scr_base(x,lambda,av,HT)
	       else let htsn = hts[n], ansn = answers[n]
	       	    in if htsn[m] >= 0 and
		    	  (HT  < 0 or HT >= 0 and htsn[m] < HT)
		       then ansn[m] := red_points_scr_base(x,lambda,av,HT);
			      htsn[m]:=HT
		       fi;
	     	       hts[n]:=htsn;
	     	       answers[n]:=ansn
               fi {now we've updated the stored data}
	fi;
	red_points_scr_hash_time +:= elapsed_ms() - start;
    	answers[n][m]

set red_points_scr(KGBElt x,ratvec lambda, int HT) = [[int]]:
    for av in red_coroots_scr(x)
    do red_points_scr(x,lambda,av,HT)
    od

{deforming by r changes infl char to (1+th)gamma/2 + r(1-th)gamma/2}
{So solve m = av*((1+th)gamma/2) +  av*r(1-th)gamma/2)}

set rp_scr_time = int:0

set reducibility_points_scr(Param p, int HT) = [rat]:
    let gamma = p.infinitesimal_character, rc = red_coroots_scr(p.x), start = elapsed_ms()
    then for_gamma_rc = for av@j in rc do if (av*(p.nu)).!= do (av,av*(p.nu)) fi od.##
    then long = [rat]:
    	for (av,den) in for_gamma_rc
    	do let rp = red_points_scr(p.x, p.lambda, av, HT)
	{ints where av*gamma = int is bad}
	   in for m in rp do (m - av*(p.d_lambda))/den od
        od.##.sort_u
    in rp_scr_time+:= elapsed_ms() - start;
       for r in long do if r>0 and r<=1 do r fi od.##