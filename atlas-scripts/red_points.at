< basic {for infinitesimal character}
< hash.at {for hash tables}
<kl.at {for rho_C}

{should require number of -alphav*theta >= number of alphav}
set red_coroots_scr(KGBElt x) = [vec]:
    let G = x.real_form,  theta = x.involution
    then rho = G.rho, pos_co = G.poscoroots
    in for alphav@j in pos_co
       do if (alphav*theta*rho).< and poscoroot_index(G, -alphav*theta) >= j
       	  then [alphav]
	  else []
	  fi
       od.##

{need to study reducibility along av at int values
from int to int inclusive}
{This version works only for infinitesimal characters in the convex hull of W*rho
For a different (dominant) bound, replace rho by the bound}
set range_scr(KGBElt x, ratvec lambda, vec av) = (int, int):
    let upval = av*(x.root_datum.rho)
    , thplus = 1+x.involution
    then downval = av*(thplus*lambda)/2 {value at nu = 0}
    in (floor(downval), ceil(upval))

{avbd is a bound for the value of av on the infinitesimal character}
set range_scr(KGBElt x, ratvec lambda, vec av, rat avbd) = (int, int):
    let thplus = 1+x.involution
    then downval = av*(thplus*lambda)/2 {value at nu = 0}
    in (floor(downval), ceil(avbd))

set ranges_scr(KGBElt x, ratvec lambda) = [(vec, (int, int))]:
    let rc = red_coroots_scr(x)
    in for av in rc
       do (av, range_scr(x,lambda,av))
       od

{root datum from all coroots restricting to A as multiple of av}
set Levix_scr(KGBElt x, vec av) = (RealForm,KGBElt):
    let G = x.real_form, theta = x.involution
    then pos_r = G.posroots, pos_co = G.poscoroots
    then av_min_th = av - av*theta
    then js = for bv@j in pos_co
    	      do if rank([av_min_th,bv-bv*theta]) <=1
	      	 then [j]
		 else []
		 fi
	      od.##
     then two_rho_L = sum(G.rank, for j in js do pos_r[j] od)
     then min_js = for j in js
     	  	   do if pos_co[j]*two_rho_L = 2
		      then [j]
		      else []
		      fi
		   od.##
     then rdL = root_datum(mat: for j in min_js do pos_r[j] od,
     	      		   mat: for j in min_js do pos_co[j] od, G.prefers_coroots)
     {then tfL = x.torus_factor - G.rho_check + rdL.rho_check}
     then xL = KGB_elt(rdL, theta, x.torus_factor)
    in (real_form(xL),xL)



{parameter on nonstandard Levi L}
set pL_scr(KGBElt x, ratvec lambda, vec av, rat t) = Param:
    let (L,xL) = Levix_scr(x,av), G = x.real_form, theta = x.involution
    then m = coroot_index(G,av) + #G.posroots, {lambdaL = lambda-rho(G) + rho(L)}
    	 lambda_shift = -rho(G) +rho(L) + rho_C(G,theta) - rho_C(L,theta)
    then a = roots(G)[m], lambdaL = lambda + lambda_shift
    then nu1 = (a-theta*a)
    then wt = av*nu1, shift = av*(lambdaL+theta*lambdaL)/2
    in parameter(xL,lambdaL, ((t-shift)/wt)*nu1)

set std_quo_scr(Param p) = ParamPol:
    1*p-character_formula(1*p)

set ind_quo_scr(KGBElt x, ratvec lambda, vec av, rat t) = KTypePol:
    let pL = pL_scr(x,lambda,av,t)
    in K_type_pol(std_quo_scr(pL))

set to_ht_scr_G(RealForm G, KTypePol QL, int HT) = KTypePol:
    if HT.< then return QL fi;
    sum(QL.real_form,
	for c@tauL in QL
    	do if dominant(G,parameter(tauL).d_lambda)*(G.two_rho_check) <= HT
	   then c*tauL
	   else 0*tauL
	   fi
	od)

{given parameter (x,lambda,nu), non-imaginary coroot av, with gamma*av = t, nu
generic in this hyperplane, test whether standard is reducible to HT}

set test_scr(KGBElt x, ratvec lambda, vec av, rat t, int HT) = bool:
    let QL = KTypePol: ind_quo_scr(x,lambda,av,t) {lives in real Levi generated by
    	     				standard Levi and coroot av; std modulo
					Langlands factor}
    in if HT < 0
       then QL.!=
       else to_ht_scr_G(x.real_form,QL,HT).!=
       fi
    {to_ht_G(x.real_form, QL,HT).!=}

set red_points_scr_time = int:0

{works for HT < 0, giving all reducibility points}
{omitting the singular real roots gives 2 too many unitary in Sp(6,R)}
{Needs to be applied to deformations of an FPP parameter, which are no longer FPP!}
set red_points_scr_base(KGBElt x, ratvec lambda, vec av, int HT) = [int]:
    let start = elapsed_ms(), (m,M) = range_scr(x,lambda,av) {, thetapl = x.involution+1}
    then ans = for j:M-m+1 from m
       	       do if test_scr(x,lambda,av,j,HT) {or ((av*thetapl).= and j.=)}
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_scr_time +:= elapsed_ms() - start;
     	ans

{works for HT < 0, giving all reducibility points}
{omitting the singular real roots gives 2 too many unitary in Sp(6,R)}
{Needs to be applied to deformations of an FPP parameter, which are no longer FPP!}
set red_points_scr_base(KGBElt x, ratvec lambda, vec av, int HT, rat avbd) = [int]:
    let start = elapsed_ms(), (m,M) = range_scr(x,lambda,av, avbd)
    then ans = for j:M-m+1 from m
       	       do if test_scr(x,lambda,av,j,HT) {or ((av*thetapl).= and j.=)}
       	       	  then [j]
	  	  else []
	  	  fi
       	       od.##
     in red_points_scr_time +:= elapsed_ms() - start;
     	ans

set red_points_scr_hash_time = int:0

{lists integers j so gamma*av = j implies reducibility to ht}
{this version requires gamma in convex hull of W*rho}
set red_points_scr = ((KGBElt, ratvec, vec, int) -> [int]):
    let xl_hash = make_xlambda_hash()
    then av_hashes = [vec_hash]: [] {one hash table of red coroots at each (x,lambda)}
    then hts = [[int]]: []  {one max HT for each ((x,lambda),av)}
    then answers = [[[int]]]: [] 
    in ((KGBElt, ratvec, vec, int) -> [int]): (KGBElt x, ratvec lambda, vec av, int HT) [int]:
    let N = xl_hash.size(), start = elapsed_ms()
    then n = xl_hash.match(x,lambda)
    then m = -1
    in if n=N {haven't seen (x,lambda) before}
       then av_hashes #:= make_vec_hash([av]);
       	    hts #:= [HT];
       	    answers #:= [red_points_scr_base(x,lambda,av,HT)];
	    m:=0
       else let M = av_hashes[n].size()
	    in  m := av_hashes[n].match(av);
	       if m = M {haven't seen av before}
	       then hts[n]#:=HT;
	       	    answers[n] #:= red_points_scr_base(x,lambda,av,HT)
	       else let htsn = hts[n], ansn = answers[n]
	       	    in if htsn[m] >= 0 and
		    	  (HT  < 0 or HT >= 0 and htsn[m] < HT)
		       then ansn[m] := red_points_scr_base(x,lambda,av,HT);
			      htsn[m]:=HT
		       fi;
	     	       hts[n]:=htsn;
	     	       answers[n]:=ansn
               fi {now we've updated the stored data}
	fi;
	red_points_scr_hash_time +:= elapsed_ms() - start;
    	answers[n][m]

set red_points_scr_hash_avbd_time = int:0

{lists integers j so gamma*av = j implies reducibility}
set red_points_scr_avbd = ((KGBElt, ratvec, vec, int, rat) -> [int]):
    let xl_hash = make_xlambda_hash()
    then av_hashes = [vec_hash]: [] {one hash table of considered coroots at each (x,lambda)}
    then hts = [[int]]: []  {one list of computed HTs for each (x,lambda)}
    then avbds = [[rat]]: [] {one largest avbd for each ((x,lambda),av); nth list has size av_hashes[n].size()}
    then answers = [[[[int]]]]: [] {one list of computed reducibility hyperplanes for each ((x,lambda),av,HT)}
    in ((KGBElt, ratvec, vec, int, rat) -> [int]): (KGBElt x, ratvec lambda, vec av, int HT, rat avbd) [int]:
    let N = xl_hash.size(), start = elapsed_ms()
    then n = xl_hash.match(x,lambda)
    then m = -1 {location of av in av_hashes[n]}
    then h = -1 {location of HT in hts[n]}
    then all_av_flag = false {whether need to update answers for all coroots}
    in if n=N {haven't seen (x,lambda) before}
       then av_hashes #:= make_vec_hash([av]);
       	    hts #:= [HT];
	    avbds #:= [avbd];
       	    answers #:= [[red_points_scr_base(x,lambda,av,HT,avbd)]];
	    m:=0;
	    h:=0
       else h:= first(for H in hts[n] do H=HT od); {saw (x,lambda) before}
       	    	if h < 0 {haven't seen this HT before at (x,lambda)}
	    	then h:= #hts[n];
		     hts[n]#:=HT;
		     all_av_flag :=true
		     {can't yet update answers, because don't have all av's}
		fi; {now h is location of HT in hts[n]}
	    let M = av_hashes[n].size()
	    in  m := av_hashes[n].match(av);
	        if m = M {haven't seen av before at (x,lambda)}
	        then avbds[n]#:=avbd;
		     answers[n] #:= for H0 in hts[n] do red_points_scr_base(x,lambda,av,H0,avbd) od
		   {in else, if all_av_flag, need to add an answer at HT for eact av0}
	        else let ansn = answers[n] {type [[[int]]]}, avbdsn = avbds[n] {saw ((x,lambda),av) before, m < M}
	       	     in if avbd > avbdsn[m] {need to increase avbd, recompute answers for av at (x,lambda) #n}
		        then avbdsn[m] := avbd;
			     let ansnm = ansn[m]
			     in ansnm[h]:= red_points_scr_base(x,lambda,av,HT,avbd);
			     	ansn[m]:=ansnm
			fi;
			if all_av_flag {means HT is last in hts[n]}
			then for av0@m0 in av_hashes[n].list()[:M]
			     do ansn[m0] #:= red_points_scr_base(x,lambda,av0,HT,avbdsn[m0])
			     od
			fi;
	     	        avbds[n]:=avbdsn;
	     	       	answers[n]:=ansn
                fi
	fi; {now we've updated the stored data}
	red_points_scr_hash_avbd_time +:= elapsed_ms() - start;
    	answers[n][m][h]

set red_points_scr(KGBElt x,ratvec lambda, int HT) = [[int]]:
    for av in red_coroots_scr(x)
    do red_points_scr(x,lambda,av,HT)
    od

{deforming by r changes infl char to (1+th)gamma/2 + r(1-th)gamma/2}
{So solve m = av*((1+th)gamma/2) +  av*r(1-th)gamma/2)}

set rp_scr_time = int:0

{Need infinitesimal_character(p) in convex hull of W*rho + center}
set reducibility_points_scr_rho(Param p, int HT) = [rat]:
    let gamma = p.infinitesimal_character, rc = red_coroots_scr(p.x), start = elapsed_ms()
    then for_gamma_rc = for av@j in rc do if (av*(p.nu)).!= do (av,av*(p.nu)) fi od.##
    then long = [rat]:
    	for (av,den) in for_gamma_rc
    	do let rp = red_points_scr(p.x, p.lambda, av, HT)
	{ints where av*gamma' = int is bad}
	   in for m in rp do (m - av*(p.d_lambda))/den od
        od.##.sort_u
    in rp_scr_time+:= elapsed_ms() - start;
       for r in long do if r>0 and r<=1 do r fi od.##

set rp_scr_time_avbd = int:0

{Works for any infl char}
set reducibility_points_scr(Param p, int HT) = [rat]:
    let gamma = p.infinitesimal_character, rc = red_coroots_scr(p.x), start = elapsed_ms()
    then for_gamma_rc = for av@j in rc do if (av*(p.nu)).!= do (av,av*(p.nu)) fi od.##
    then long = [rat]:
    	for (av,den) in for_gamma_rc
    	do let rp = red_points_scr_avbd(p.x, p.lambda, av, HT, av*gamma)
	{ints where av*gamma' = int is bad}
	   in for m in rp do (m - av*(p.d_lambda))/den od
        od.##.sort_u
    in rp_scr_time_avbd+:= elapsed_ms() - start;
       for r in long do if r>0 and r<=1 do r fi od.##