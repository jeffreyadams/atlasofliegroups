<twisted_endoscopy.at


{SO(2n) in SO(2n+1)}
set Dn_in_Bn(int n)=
let G=SO(2*n+1) then
v=for i:n-1 do i od#n in
pseudo_Levi(G,v)

{G must be of type B_n}
set Dn_in_Bn(RootDatum G)=
let n=ss_rank(G) then
v=for i:n-1 do i od#n in
pseudo_Levi(G,v)

{SO(2n) as endoscopic group in GL(2n)}
set endoscopy_Dn(int n)=
let G=GL(2*n,R) then
delta=G.distinguished_involution then
(H_Bn,M)=endoscopic(G,delta) then
H=Dn_in_Bn(H_Bn) in
(H,M)


set endoscopic_matrix(int n)=mat:
let (H,M)=endoscopy_Dn(n) in
M


{As written, the next sctipt only works for SO(n,n)}
set ordinary_endoscopic_group(RealForm G, ratvec s)=RootDatum:
let n=#(## for i:#s do if s[i]=1 then [1] else [] fi od) then
m=#(## for i:#s do if s[i]=-1 then [-1] else [] fi od) then
v= for i:n+m do if i<n then simple_roots(SO(n,n))~[0][i] else 0 fi od then
u= for i:n+m do if i<n then 0 else simple_roots(SO(m,m))~[0][i-n] fi od then
SR=simple_roots(G) then
SCR=simple_coroots(G) then
sr=## for  i:#SR-1 do if SR[i]*s=0 then [SR[i]] else [] fi od then
scr=## for i:#SCR-1 do if SCR[i]*s=0 then [SCR[i]] else [] fi od then
A = mat: for i:#sr+2 do if i<n-1 then sr[i] else if i=n-1 then v else if i<=#sr then sr[i-1] else u fi fi fi od in
{B = mat: for i:#scr+2 do if i<n-1 then scr[i] else if i=n-1 then v else if i<=#sr then scr[i-1] else u fi fi fi od in}
{od then
B = mat: for i:#scr do scr[i] od in}
root_datum(A,A)



{set ordinary_endoscopic_matrices(RealForm G, ratvec s)=(mat,mat):
let PR=posroots(G) then
PCR=poscoroots(G) then
pr=## for  i:#PR do if PR[i]*s=0 then [PR[i]] else [] fi od then
pcr=## for i:#PCR do if PCR[i]*s=0 then [PCR[i]] else [] fi od then
A = mat: for i:#pr do pr[i] od then
B= mat:for i:#pcr do pcr[i] od in
(A,B)}


{set involution_fundamental_part(mat A)=mat:
let B=A+id_mat(#A) in
mat:for i:#B do B[i]/2\1 od}



set lift_involution(mat A, mat M, RealForm G)= mat:
let M0 = if M[0][0]=1 then M else -M fi then
n=rank(G) in
let A = if is_integer(n/2) then
mat:for i:n do if i<n/2 then M0*A[i]-M0*A[i]/2\1 else -M0*A[n-1-i]/2\1  fi od {in}
else
mat:for i:n do if i<(n-1)/2 then M*A[i]-M*A[i]/2\1 else if i=((n-1)/2) then id_mat(n)[(n-1)/2\1] else -M*A[n-1-i]/2\1  fi fi od fi
in
A*distinguished_involution(G)


{set lift_involution(mat A, mat M, RealForm G)= mat:
let n=rank(G) in
let A=mat:for i:n do if i<(n-1)/2 then M*A[i]-M*A[i]/2\1 else if i=((n-1)/2) then id_mat(n)[(n-1)/2\1] else -M*A[n-1-i]/2\1  fi fi od in
A*distinguished_involution(G)
}


{set lift_involution(mat A, mat M, RealForm G)= mat:
let n=rank(G) in
let A=mat:for i:n do if i<(n-1)/2 then M*A[i]-M*A[i]/2\1 else if i=((n-1)/2) then id_mat(n)[(n-1)/2\1] else -M*A[n-1-i]/2\1  fi fi od in
A*distinguished_involution(G)
}

{this should be called lift_involution_W or something like that}
set lift_involution_Tits(mat A, mat M,RealForm H, RealForm G)= mat:
let A0=A*distinguished_involution(H) then
M0 = if M[0][0]=1 then M else -M fi then
n=rank(G) in
if is_integer(n/2) then
mat:for i:n do if i<n/2 then M0*A0[i]-M0*A0[i]/2\1 else -M0*A0[n-1-i]/2\1  fi od {in}
else
mat:for i:n do if i<(n-1)/2 then M0*A0[i]-M0*A0[i]/2\1 else if i=((n-1)/2) then id_mat(n)[(n-1)/2\1] else -M0*A0[n-1-i]/2\1  fi fi od fi
{in
A*distinguished_involution(G)}



set lift( KGBElt_gen x_H_gen,mat M, RealForm G)=KGBElt_gen:
let tf_H_raw=x_H_gen.unnormalized_torus_factor then
theta_G=lift_involution(x_H_gen.involution,M,G) then
tf_G_raw=M*tf_H_raw then
{tf_G=(2*tf_G_raw-G.rho_check)*(1+theta_G)/2 in}
tf_G=M*(-2*tf_H_raw+rho_check(x_H_gen.real_form)) {-M*(-2*tf_H_raw+rho_check(x_H_gen.real_form))} in 
{tf_G=(M*(-2*tf_H_raw+rho_check(x_H_gen.real_form)))\1+((1+theta_G)*(-M*(-2*tf_H_raw+rho_check(x_H_gen.real_form)))/2)\1 in}
KGB_elt_gen(G.inner_class,theta_G,tf_G)
{tf_G=(M*(dual(p_H).lambda-rho(x_H_gen.real_form)))\1+((1+theta_G)*(-M*(dual(p_H).lambda-rho(x_H_gen.real_form)))/2)\1 in}
{tf_G=(M*(dual(p_H).lambda-rho(x_H_gen.real_form)))\1+((1+theta_G)*(-M*(dual(p_H).lambda-rho(x_H_gen.real_form)))/2)\1 in}



set lift(KGBElt x_H,mat M, RealForm G)=KGBElt_gen:
lift(KGB_elt_gen(x_H),M,G)





set lift_std_extended(Param p_H,mat M,RealForm G)=Param:
let E_H=E(p_H.real_form.distinguished_involution,p_H) then
x=lift(p_H.x,M,G) then
gamma_G=M*p_H.infinitesimal_character then
lambda_rho_G= (M*(p_H.lambda-rho(p_H.real_form)))\1+solve(1+x.involution,(1+x.involution)*(M*(rho(p_H.real_form))-rho(G))).requisition\1 then
{(M*(p_H.lambda-rho(p_H.real_form)))\1+((1+x.involution)*(M*p_H.infinitesimal_character-rho(G)-M*(p_H.lambda-rho(p_H.real_form)))/2)\1 {vec}  then}
theta_G=x.involution{*delta} then
g_G=G.rho_check then
l_G=null(#g_G) then {this can be replaced by M*(-2*tf_H_raw+rho_check(p_H.real_form))}
tau_G=solve(^M,E_H.tau).requisition then
t_G=solve(^M,E_H.t).requisition then
E_G=ExtParam:(
G.inner_class,
G.distinguished_involution,
gamma_G,
lambda_rho_G,
theta_G,
g_G,
l_G,
-^theta_G,
tau_G,
t_G) 
in
E_G.parameter







set lift_std(Param p_H,mat M,RealForm G)=Param:
let x=KGB_elt(lift(p_H.x,M,G)) then
lambda_G=rho(G)+(M*(p_H.lambda-rho(p_H.real_form)))+solve(1+x.involution,(1+x.involution)*(M*(rho(p_H.real_form))-rho(G))).requisition {vec}  then
nu_G=M*p_H.nu in
parameter(x,lambda_G,nu_G)


{set lift_std(Param p_H,mat M,RealForm G)=Param:
let x=KGB_elt(lift(p_H.x,M,G)) then
lambda_G=rho(G)+(M*(p_H.lambda-rho(p_H.real_form)))+solve(1+x.involution,(1+x.involution)*(M*p_H.infinitesimal_character-rho(G)-M*(p_H.lambda-rho(p_H.real_form)))).requisition {vec}  then
nu_G=M*p_H.nu in
parameter(x,lambda_G,nu_G)}


set lift_std_pp(Param p_H,mat M,RealForm G)=ParamPol:
let x=KGB_elt(lift(p_H.x,M,G)) then
lambda_G=rho(G)+(M*(p_H.lambda-rho(p_H.real_form)))+solve(1+x.involution,(1+x.involution)*(M*p_H.infinitesimal_character-rho(G)-M*(p_H.lambda-rho(p_H.real_form)))).requisition {vec}  then
nu_G=M*p_H.nu in
param_pol(parameter(x,lambda_G,nu_G))


set lift_std_Version2(Param p_H,mat M,RealForm G)=Param:
let x=KGB_elt(lift(p_H.x,M,G)) then
lambda_G=rho(G)+(M*(p_H.lambda-rho(p_H.real_form)))+((1+x.involution)*(M*rho(p_H.real_form)-rho(G))/2)\1 {vec}  then
nu_G=M*p_H.nu in
parameter(x,lambda_G,nu_G)


{set lift_std_Version2(Param p_H,mat M,RealForm G)=Param:
let x=KGB_elt(lift(p_H.x,M,G)) then
lambda_G=rho(G)+(M*(p_H.lambda-rho(p_H.real_form)))+((1+x.involution)*(M*p_H.infinitesimal_character-rho(G)-M*(p_H.lambda-rho(p_H.real_form)))/2)\1 {vec}  then
nu_G=M*p_H.nu in
parameter(x,lambda_G,nu_G)}






set lift_std_preliminary(ParamPol P,mat M,RealForm G)=ParamPol:
let rv=null_module(G) in
for (c,p) in %P do let P=lift_std_pp(p,M,G) in rv+:=c*P od;
rv




{lambda_H will not necesarrily be an integer vector, if that's the case atlas will give an error message and we should use inverse_lift_std}
set inverse_lift_std_preliminary(Param p_G,RealForm H,mat M,ratvec gamma_H)=ParamPol:
let x=KGB_elt(KGB_elt_gen(H,restrict_action(p_G.involution,M),0*rho(H))) then
lambda_H=rho(H)+(left_inverse(M)*(p_G.lambda-rho(p_G.real_form))) + solve(1+x.involution,(1+x.involution)*(gamma_H-rho(H)-(left_inverse(M)*(p_G.lambda-rho(p_G.real_form))))).requisition  then
nu_H=left_inverse(M)*p_G.nu then
p=parameter(x,lambda_H,nu_H) in
param_pol(L_packet(p))


{same as before only that infinitesimal character gamma_H is given by left_inverse(M)*p_G.infinitesimal_character}
set inverse_lift_std_preliminary(Param p_G,RealForm H,mat M)=ParamPol:
let x=KGB_elt(KGB_elt_gen(H,restrict_action(p_G.involution,M),0*rho(H))) then
lambda_H=rho(H)+(left_inverse(M)*(p_G.lambda-rho(p_G.real_form))) + solve(1+x.involution,(1+x.involution)*(left_inverse(M)*p_G.infinitesimal_character-rho(H)-(left_inverse(M)*(p_G.lambda-rho(p_G.real_form))))).requisition  then
nu_H=left_inverse(M)*p_G.nu then
p=parameter(x,lambda_H,nu_H) in
param_pol(L_packet(p))


{set inverse_lift_std_P(Param p_G,RealForm H,mat M)=[Param]:
let x=KGB_elt(KGB_elt_gen(H,restrict_action(p_G.involution,M),0*rho(H))) then
lambda_H=rho(H)+(left_inverse(M)*(p_G.lambda-rho(p_G.real_form))) + solve(1+x.involution,(1+x.involution)*(left_inverse(M)*p_G.infinitesimal_character-rho(H)-(left_inverse(M)*(p_G.lambda-rho(p_G.real_form))))).requisition  then
nu_H=left_inverse(M)*p_G.nu then
p=parameter(x,lambda_H,nu_H) in
L_packet(p)}


set index_x(KGBElt x, Param p_G, RealForm H, mat M,ratvec gamma_H)=int:
let all=all_parameters_x_gamma(x, gamma_H) in
first(for p@i in all do  finalize(lift_std(p,M,p_G.real_form))=p_G od)


set inverse_lift_std_by_search(Param p_G,RealForm H,mat M,ratvec gamma_H)=ParamPol:
let x=KGB_elt(KGB_elt_gen(H,restrict_action(p_G.involution,M),0*rho(H))) in
let n_x=x.number in
let index= for i:KGB_size(H)-n_x from n_x do 
first(for p@i in all_parameters_x_gamma(KGB(H,i), gamma_H) do  finalize(lift_std(p,M,p_G.real_form))=p_G od) od in
let i= first(for k:#index do index[k]!=-1 od) in
{let index=index_x(KGB(H)[i],p_G,H, M,gamma_H) in}
param_pol(L_packet(all_parameters_x_gamma(KGB(H,n_x+i),gamma_H)[index[i]]))


set inverse_lift_std_by_search(Param p_G,RealForm H,mat M,mat delta,ratvec gamma_H)=ParamPol:
let ()=prints("inverse lift of: ", p_G) then
y_G=y_gen(p_G) then
action_H=-^restrict_action(y_G.involution,M) then
x=KGB_elt(H,action_H,H.base_grading_vector) then
n_x=x.number then
n=KGB_size(H) in
for i:n-n_x from n_x do
 let all=all_parameters_x_gamma(KGB(H,i), gamma_H) then
 {index=first(for p@i in all do  Finalize(lift_std(p,M,p_G.real_form,delta))=p_G od) in}
 index=first(for p@i in all do  Finalize(lift_std(p,M,p_G.real_form))=p_G od) in
 if index!=-1 then
  prints("found solution with x=",i);
  {return(sign_difference(p_G,delta)*param_pol(L_packet(all[index])))}
  return(param_pol(L_packet(all[index])))
 else
  prints("no solution at x=",i)
 fi
od;
prints("inverse_lift_by_search failed");
null_module(H)

set inverse_lift_std(Param p_G,RealForm H,mat M,ratvec gamma_H)=ParamPol:
let x=KGB_elt(KGB_elt_gen(H,restrict_action(p_G.involution,M),0*rho(H))) in
let lambda=left_inverse(M)*(p_G.lambda-rho(p_G.real_form)) + solve(1+x.involution,(1+x.involution)*(gamma_H-rho(H)-(left_inverse(M)*(p_G.lambda-rho(p_G.real_form))))).requisition in
{if #all_parameters_x_gamma(x,gamma_H)>0 then}	
if is_integer(lambda) then
inverse_lift_std_preliminary(p_G,H,M) else
inverse_lift_std_by_search(p_G,H,M,gamma_H)
fi

{same as before only that infinitesimal character gamma_H is given by left_inverse(M)*p_G.infinitesimal_character}
set inverse_lift_std(Param p_G,RealForm H,mat M)=ParamPol:
let x=KGB_elt(KGB_elt_gen(H,restrict_action(p_G.involution,M),0*rho(H))) in
let lambda=left_inverse(M)*(p_G.lambda-rho(p_G.real_form)) + solve(1+x.involution,(1+x.involution)*(left_inverse(M)*p_G.infinitesimal_character-rho(H)-(left_inverse(M)*(p_G.lambda-rho(p_G.real_form))))).requisition in
{if #all_parameters_x_gamma(x,left_inverse(M)*p_G.infinitesimal_character)>0 then}	
if is_integer(lambda) then
inverse_lift_std_preliminary(p_G,H,M) else
inverse_lift_std_by_search(p_G,H,M,left_inverse(M)*p_G.infinitesimal_character)
fi


set O_action([Param] L)=[Param]:
let O=outer_automorphism_group(L[0].real_form)~[0] in
for p in L do parameter(KGB_elt(KGB_elt_gen(L[0].real_form,O*p.involution*O,p.x.torus_factor)), O*p.lambda,O*p.nu) od


set inverse_lift_std(ParamPol P,RealForm H,mat M,ratvec gamma_H)=ParamPol:
let rv=null_module(H) in
for (c,p) in %P do let P=inverse_lift_std(p,H,M,gamma_H) in rv+:=c*P od;
rv

set inverse_lift_std_orbit(ParamPol P,RealForm H,mat M,ratvec gamma_H)=ParamPol:
let rv=null_module(H) in
for (c,p) in %P do let P=inverse_lift_std(p,H,M,gamma_H) in rv+:=c*P + c*param_pol(O_action(monomials(P))) od;
rv

{same as before only that infinitesimal character gamma_H is given by left_inverse(M)*p_G.infinitesimal_character}
set inverse_lift_std_orbit(ParamPol P,RealForm H,mat M)=ParamPol:
let rv=null_module(H) in
for (c,p) in %P do let P=inverse_lift_std(p,H,M) in rv+:=c*P + c*param_pol(O_action(monomials(P))) od;
rv


set lift_std_to_twist_std(ParamPol P,mat M,RealForm G)=ParamPol:
let rv=null_module(G) then
m=monomials(P) then
PG= lift_std_preliminary(P,M,G) in 
for (c,p) in %PG do rv+:=((1/#monomials(inverse_lift_std(p,m[0].real_form,M)))*c.s_to_1)\1*p od; 
rv

set lift_irr_to_twist_std(ParamPol P,mat M,RealForm G)=ParamPol:
let rv=null_module(G) then
m=monomials(P) then
PG= lift_std_preliminary(character_formula(P),M,G) in 
for (c,p) in %PG do rv+:=((1/#monomials(inverse_lift_std(p,m[0].real_form,M)))*c.s_to_1)\1*p od; 
rv



set twisted_character_whittaker(ParamPol P, mat delta)=ParamPol:
let rv=null_module(monomials(P)[0].real_form) in
for (c,p) in %P do let P=sign_difference(p,delta)*p in rv+:=c*P  od;
rv

{Gives the distribution defining the A-packet for a classical group of type A and B. In this case ABV=Arthur.}
set A_packet_distribution_AB(Param p_H,mat M,RealForm G,mat delta)=ParamPol:
let ecf=extended_character_formula(Finalize(lift_std(p_H,M,G)),delta) in
let P=twisted_character(ecf) in
let Pw=twisted_character_whittaker(P,delta) in
composition_series(inverse_lift_std(Pw,p_H.real_form,M,p_H.infinitesimal_character)) 


{Gives the distribution defining the A-packet for a classical group of type B, C and D. For type B same answer as before, for type C and
D it gives the O_n orbit expressed as 1/2*eta^ABV_psi + 1/2*eta^ABV_\psi\circ O.}
set A_packet_distribution_BCD(Param p_H,mat M,RealForm G,mat delta)=void:
let ecf=extended_character_formula(Finalize(lift_std(p_H,M,G)),delta) in
let P=twisted_character(ecf) in
let Pw=twisted_character_whittaker(P,delta) in
let A_sum=composition_series(inverse_lift_std_orbit(Pw,p_H.real_form,M,p_H.infinitesimal_character)) in
void:for (c,p) in %A_sum do prints(1/2*c.s_to_1,"*",p) od {I need to do this since I don't know how to multiply a param_pol by 1/2}


{Gives the A-packet in the case of a classical group of type A and B}
set A_packet_AB(Param p_H,mat M,RealForm G,mat delta)=[Param]:
let ecf=extended_character_formula(Finalize(lift_std(p_H,M,G)),delta) in
let P=twisted_character(ecf) in
let Pw=twisted_character_whittaker(P,delta) in
let A_sum=composition_series(inverse_lift_std(Pw,p_H.real_form,M,p_H.infinitesimal_character)) in
monomials(A_sum)

{Gives the A-packet in the case of a classical group of type B, C and D. For C and D it gives the O(N) orbit}
set A_packet_BCD(Param p_H,mat M,RealForm G,mat delta)=[Param]:
let ecf=extended_character_formula(Finalize(lift_std(p_H,M,G)),delta) in
let P=twisted_character(ecf) in
let Pw=twisted_character_whittaker(P,delta) in
let A_sum=composition_series(inverse_lift_std_orbit(Pw,p_H.real_form,M,p_H.infinitesimal_character)) in
monomials(A_sum)


 set unipotent_A_packets(ComplexNilpotent N,RealForm H,mat M,RealForm G,mat delta)=void:
let wpp=parameters(weak_packet(N,H)) then
(,,l)=N in
let all=all_parameters_x_gamma(KGB(H)~[0],l/2) in
let wpp_in_all= ## for p in all do if first(for x in wpp do  x=p od)=-1 then [] else [p] fi od in
for p in wpp_in_all do print(A_packet_distribution_BCD(p,M,G,delta)) od


{Given a nilpotent orbit of ^H, H a classical group of type B, C or D, it returns the corresponding unipotent A-packets}
set unipotent_A_packets_BCD(RealForm H, ComplexNilpotent N)=void:
let n=rank(H) in
{let n=#columns(simple_roots(H)) in}
let G= if H=Sp(2*n,R) then GL(2*n+1,R) else GL(2*n,R) fi then
delta=distinguished_involution(G) then
(,M0)=endoscopic(G,delta) in
let M=-M0 in
let wpp=parameters(weak_packet(N,H)) then
(,,l)=N in
let all=all_parameters_x_gamma(KGB(H)~[0],l/2) in
let wpp_in_all= ## for p in all do if first(for x in wpp do  x=p od)=-1 then [] else [p] fi od in
let wpp_in_all_torusfactor0 = ## for p in wpp_in_all do if p.x.torus_factor=0*rho(H) then [p] else [] fi od in
for p in wpp_in_all_torusfactor0 do prints(A_packet_distribution_BCD(p,M,G,delta)) od


{set unipotent_A_packets_SO_odd(int n, ComplexNilpotent N)=void:
let H=SO(n,n+1) then
G=GL(2*n,R) then
delta=distinguished_involution(G) then
(,M0)=endoscopy_Dn(n) in
let M=-M0 in
let wpp=parameters(weak_packet(N,H)) then
(,,l)=N in
let all=all_parameters_x_gamma(KGB(H)~[0],l/2) in
let wpp_in_all= ## for p in all do if first(for x in wpp do  x=p od)=-1 then [] else [p] fi od in
for p in wpp_in_all do prints(A_packet_distribution_BCD(p,M,G,delta)) od}


{set unipotent_A_packets_SO_even(int n, ComplexNilpotent N)=void:
let H=SO(n,n) then
G=GL(2*n,R) then
delta=distinguished_involution(G) then
(,M0)=endoscopy_Dn(n) in
let M=-M0 in
let wpp=parameters(weak_packet(N,H)) then
(,,l)=N in
let all=all_parameters_x_gamma(KGB(H)~[0],l/2) in
let wpp_in_all= ## for p in all do if first(for x in wpp do  x=p od)=-1 then [] else [p] fi od in
for p in wpp_in_all do prints(A_packet_distribution_BCD(p,M,G,delta)) od}


{set unipotent_A_packets_Sp(int n, ComplexNilpotent N)=void:
let H=Sp(n,R) then
G=GL(n+1,R) then
delta=distinguished_involution(G) then
(,M0)=endoscopic(G,delta) in
let M=-M0 in
let wpp=parameters(weak_packet(N,H)) then
(,,l)=N in
let all=all_parameters_x_gamma(KGB(H)~[0],l/2) in
let wpp_in_all= ## for p in all do if first(for x in wpp do  x=p od)=-1 then [] else [p] fi od in
for p in wpp_in_all do prints(A_packet_distribution_AB(p,M,G,delta)) od}


{set A_packet_distribution_SO(Param p_H,mat M,RealForm G,mat delta)=ParamPol:
let ecf=extended_character_formula(Finalize(lift_std(p_H,M,G)),delta) in
let P=twisted_character(ecf) in
let Pw=twisted_character_whittaker(P,delta) in
composition_series(inverse_lift_std(Pw,p_H.real_form,M,p_H.infinitesimal_character)) }

