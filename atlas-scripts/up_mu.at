< Dirac.at {for shifters}

set_type
[up_mu_hash_table =
(  ( -> int) real_form_size {number of real forms considered}
   , ( -> vec) K_type_sizes {number of K_types for each real form}
   , ( -> ) clear
   , ((KType,int) -> [KType]) up_types {list of up K-types of length at most int}
   , ((KType,int) -> [int]) up_heights {heights from previous}
   , (KType -> (int,bool)) completion {how many steps up for best_Dirac are computed, and whether that's all}
)
]

set up_mu_time = int: 0

set make_up_mu_hash() = up_mu_hash_table:
(  let real_form_hash = make_RealForm_hash()
   then K0s = [RealForm]: [] {for each G, id comp of maximal compact}
   then Ms = [mat]: [] {for each G, projection to K matrix}
   then Mrts = [ratmat]: [] {for each G, right inverse of M}
   then muhashes = [KType_hash]:[] {for each G, list of mu's}
   then muss = [[[int]]]:[] {for each G and mu, list of indices into muhash for up_mus}
   then muDones = [[bool]]: [] {for each G, one bool for each mu, saying whether muss[i][j] is
   		  	    as long as possible}
   then clear() = void:
   	real_form_hash.clear(); K0s := []; Ms := [];
	Mrts := []; muhashes := []; muss := []; muDones := []
   then add_real_form(RealForm rf) = int:
    	let I = real_form_hash.size()
	then i = real_form_hash.match(rf)
    	then () = if i = I {haven't seen this real form before}
	      	  then let () = K0s #:= K_0(rf)
		       then () = Ms #:= projection_to_K_matrix(rf)
		       then () = Mrts #:=  ((1+rf.distinguished_involution)*right_inverse(Ms[I]))/2
		       then () = muhashes #:=make_KType_hash()
		       then () = muss #:= []
		       then () = muDones #:= []
		       then () = assert(real_form_hash.size() = #muhashes and #K0s = #muhashes and #K0s = #Ms 
	     	  	    	       and #K0s = #muss and #Mrts = #K0s, "up_mu_hash damaged")
		       in ()
		   fi
	in i
    then add_K_type(KType mu) = (int, int): {real form index, K type index}
   	 let rfnum = add_real_form(mu.real_form)
	 then KTYPENUM = muhashes[rfnum].size()
	 then ktypenum = muhashes[rfnum].match(mu)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	     	   then let () = muss[rfnum] #:= [ktypenum]
			then () = muDones[rfnum] #:= false
			then () = assert(#muss[rfnum] = muhashes[rfnum].size()
				      and #muDones[rfnum] = #muss[rfnum], "up_mu_hash damaged in akt")
			in ()
		   fi
	in (rfnum, ktypenum)
    then add_muss(KType mu, int bd) = (int,int): {real form index, K type index}
       	 let (rfnum,ktypenum) = add_K_type(mu), start_time = elapsed_ms()
	 { then () = include_imag_flag := false}
	 {then () = prints("#K-types for rf is ",muhashes[rfnum].size(),", #muss = ",#muss[rfnum])}
	 then () = if not muDones[rfnum][ktypenum] and #muss[rfnum][ktypenum] < bd
	      	   then let G = mu.real_form
		   	then M = Ms[rfnum], Mrt = Mrts[rfnum]
	      	   	then newmunums = [int]: muss[rfnum][ktypenum], uptaus = [KType]: []
			then j0 = int: -1, wtlast= vec:null(G.rank), alphaup = vec: null(G.rank), x0G = KGB(G,0)
    		   then () = while (not muDones[rfnum][newmunums~[0]])
		   	     	    and #newmunums < bd
		       	    	    and (let lastmunum = newmunums~[0]
				       	 then taulast = muhashes[rfnum].index(lastmunum)
				       	 then (shifters,newx) = shifters(taulast)
				       	 then () = x0G:=newx
				       	 then KG = K_0(x0G), rhoc = rho_c(x0G)
				       	 then () = wtlast := highest_weight(taulast,x0G).mu
				       	 then testers = for alpha in shifters
			     	       	    	      	do Mrt*M*coroot(G,alpha)
				       		      	od
					 then () =
					      uptaus := for alpha in shifters
					      	       	do let wt = M*(wtlast + alpha)
						       	   in if is_dominant(KG, wt)
							      {then [K_type(K_highest_weight_from_K0_weight(x0G,wt))]}
						       	      then let upcand = K_type(K_highest_weight_from_K0_weight(x0G,wt))
							           in if height(upcand) > height(taulast)
								      then [upcand]
								      else []
								      fi
							      else []
							      fi
						       	od.##
					 in if #uptaus > 0
					    then let () = j0 := min_loc(for uptau in uptaus
					      	   	     	  do height(uptau)
							   	  od)
						 in true
					    else let muDonesrf = muDones[rfnum]
					    	 then () = for j@i in newmunums
						      	   do muDonesrf[j] :=true
						      	   od
						 then () = muDones[rfnum] := muDonesrf
						 in false
					    fi {#uptaus > 0})
              	    	     do let (,newmunum) = add_K_type(uptaus[j0])
				then () = newmunums ##:= muss[rfnum][newmunum]
				in ()
	      	    	     od {end of "not muDones"}
		   then mussrf = muss[rfnum]
    	           {then () = mussrf[ktypenum] := newmunums}
		   then () = for j@i in newmunums
		   	     do if #mussrf[j] < #newmunums[i:]
			     	then mussrf[j] := newmunums[i:]
				fi
			     od
		   in muss[rfnum]:=mussrf
	     fi {not muDones}
	 then () =  assert(#muss[rfnum]= muhashes[rfnum].size() and #muss[rfnum] = #muDones[rfnum],
	      	    "mu_up_hash damaged in am")
	 then () = up_mu_time +:= elapsed_ms() - start_time
	 {then () = include_imag_flag:=true}
	 in (rfnum,ktypenum)

    then up_types(KType mu,int m) = [KType]: 
     	 let (rfnum, ktypenum) = add_K_type(mu)
     	 then () = while #muss[rfnum][ktypenum] < m
     	       	     and not muDones[rfnum][ktypenum]
	       	  do add_muss(mu, m)
	       	  od
         in for j in muss[rfnum][ktypenum][:min(#muss[rfnum][ktypenum],m)]
     	    do muhashes[rfnum].index(j)
	    od
    in
(  ( -> int): {real_form_size} @int: real_form_hash.size()
   , ( -> vec): {K_type_sizes} @vec:
       for muhash in muhashes
       do muhash.size()
       od
   , ( -> ): {clear} clear
   , ((KType,int) -> [KType]): {up_types} (KType mu, int m) [KType]:
     up_types(mu,m)
   , ((KType,int) -> [int]): {up_heights}  (KType mu, int m) [int]:
     let list = up_types(mu,m)
     in for tau in list do height(tau) od
   , (KType -> (int,bool)): {completion} (KType mu) (int,bool):
     let (rfnum, ktypenum) = add_K_type(mu)
     in (#muss[rfnum][ktypenum],muDones[rfnum][ktypenum])
)
)

set up_mu_hash = make_up_mu_hash()
