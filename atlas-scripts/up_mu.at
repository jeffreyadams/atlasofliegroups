< Dirac.at {for shifters}

{whether to use this function instead of shifters}
{set short_mu_flag = true}

{to get correct shifts for a standard rep p, use the the (non-final) K-type K_type(p.x, p.lambda_minus_rho)} {MOVED TO DIRAC.at}
{set short_shifts(KType mu) = [KType]:
    let x = mu.x, lambda = mu.lambda, lambdamin = mu.lambda_minus_rho, G = mu.real_form
    then theta = x.involution, rh = G.rho
    in for alpha@j in G.posroots
       do if root_index(G,theta*alpha) > j
       	     and G.poscoroots[j]*(lambda + theta*lambda) > 0 {now have cplx alpha}
	  then let tau = K_type(x,lambdamin+alpha)
	       in [KType]: if {(not tau.=)
	       	  and} is_standard(tau)
		  then monomials(1*tau) {[[tau]]}
		  else []
		  fi
	  elif theta*alpha = -alpha
	  then let y = Cayley(alpha,x)
	       then ell = (G.poscoroots[j]*lambda).numer
	       then lambda0min = if (ell%2).=
		    	       	 then lambdamin - (ell\2 - 1)*alpha
	       	    	      	 else lambdamin - ((ell-1)\2)*alpha
			      	 fi
	       then tau0 = K_type(y, lambda0min), tau1 = K_type(cross(j,y),lambda0min)
	       in [KType]: if {(not tau0.=) and} is_standard(tau0) then monomials(1*tau0) else [] fi##
		       if {(not tau1.=) and} is_standard(tau1) then monomials(1*tau1) else [] fi
	  else []
	  fi {type is [KType]}
      od.##}

set_type
[up_mu_hash_table =
(  ( -> int) real_form_size {number of real forms considered}
   , ( -> vec) K_type_sizes {number of K_types for each real form}
   , ( -> ) clear
   , ((KType,int) -> [KType]) up_types {list of up K-types of length at most int}
   , ((KType,int) -> [int]) up_heights {heights from previous}
   , (KType -> (int,bool)) completion {how many steps up for best_Dirac are computed, and whether that's all}
)
]

{Maybe the K-hash is just the zero element of each L-packet of K-types: the LKTs of anti_finalize?}
set make_up_mu_hash() = up_mu_hash_table:
(  let real_form_hash = make_RealForm_hash()
   then K0s = [RealForm]: [] {for each G, id comp of maximal compact}
   then Ms = [mat]: [] {for each G, projection to K matrix}
   then Mrts = [ratmat]: [] {for each G, right inverse of M}
   then muhashes = [KType_hash]:[] {for each G, list of mu's}
   then muss = [[[int]]]:[] {for each G and mu, list of indices into muhash for up_mus}
   then muDones = [[bool]]: [] {for each G, one bool for each mu, saying whether muss[i][j] is
   		  	    as long as possible}
   then clear() = void:
   	real_form_hash.clear(); K0s := []; Ms := [];
	Mrts := []; muhashes := []; muss := []; muDones := []
   then add_real_form(RealForm rf) = int:
    	let I = real_form_hash.size()
	then i = real_form_hash.match(rf)
    	then () = if i = I {haven't seen this real form before}
	      	  then let () = K0s #:= K_0(rf)
		       then () = Ms #:= projection_to_K_matrix(rf)
		       then () = Mrts #:=  ((1+rf.distinguished_involution)*right_inverse(Ms[I]))/2
		       then () = muhashes #:=make_KType_hash()
		       then () = muss #:= []
		       then () = muDones #:= []
		       then () = assert(real_form_hash.size() = #muhashes and #K0s = #muhashes and #K0s = #Ms 
	     	  	    	       and #K0s = #muss and #Mrts = #K0s, "up_mu_hash damaged")
		       in ()
		   fi
	in i
    then add_K_type(KType mu) = (int, int): {real form index, K type index}
   	 let rfnum = add_real_form(mu.real_form)
	 then KTYPENUM = muhashes[rfnum].size()
	 then mu0 = monomials(1*mu)[0]
	 then ktypenum = muhashes[rfnum].match(mu0)
	 then () = if ktypenum = KTYPENUM {haven't computed with mu before}
	     	   then let () = muss[rfnum] #:= [ktypenum]
			then () = muDones[rfnum] #:= false
			then () = assert(#muss[rfnum] = muhashes[rfnum].size()
				      and #muDones[rfnum] = #muss[rfnum], "up_mu_hash damaged in akt")
			in ()
		   fi
	in (rfnum, ktypenum)
    then add_muss(KType mu, int bd) = (int,int): {real form index, K type index}
       	 let (rfnum,ktypenum) = add_K_type(mu), start_time = elapsed_ms()
	 { then () = include_imag_flag := false}
	 {then () = prints("#K-types for rf is ",muhashes[rfnum].size(),", #muss = ",#muss[rfnum])}
	 then () = if not muDones[rfnum][ktypenum] and #muss[rfnum][ktypenum] < bd
	      	   then let G = mu.real_form
		   	then M = Ms[rfnum], Mrt = Mrts[rfnum]
	      	   	then newmunums = [int]: muss[rfnum][ktypenum], uptaus = [KType]: [], finished_up = false
			then j0 = int: -1, wtlast= vec:null(G.rank), alphaup = vec: null(G.rank), x0G = KGB(G,0)
    		   then () = while #newmunums < bd and not finished_up
		   	     do let lastmunum = newmunums~[0]
				then taulast = muhashes[rfnum].index(lastmunum)
			        then () = uptaus :=
					  if short_mu_flag
					  then let qlast = anti_finalize(parameter(taulast))
					  then aftaulast = K_type(qlast.x, qlast.lambda_minus_rho)
					  in short_shifts(aftaulast)
					  else let (shifters,newx) = shifters(taulast)
				       	       then () = x0G:=newx
				       	       then KG = K_0(x0G), rhoc = rho_c(x0G)
				       	       then () = wtlast := highest_weight(taulast,x0G).mu
				       	       then testers = for alpha in shifters
			     	       	    	      	      do Mrt*M*coroot(G,alpha)
				       		      	      od
					       in for alpha in shifters
					      	  do let wt = M*(wtlast + alpha)
						     in if is_dominant(KG, wt)
							then let upcand =
							     K_type(K_highest_weight_from_K0_weight(x0G,wt))
							     in if height(upcand) > height(taulast)
							     	then [upcand]
							     	else []
							 	fi {height(upcand)}
							 else []
							 fi {is_dominant}
						  od.##
					    fi
				  in if #uptaus > 0
				     then let () = j0 := if max_loc_flag
					    	     	 then max_loc (for uptau in uptaus
					      	   	     	       do height(uptau) od)
					    	     	 else min_loc (for uptau in uptaus
					      	   	     	       do height(uptau) od)
							 fi
				 	  {then () = prints("adding at ",taulast)}
					  then (,newmunum) = add_K_type(uptaus[j0])
					  then () = newmunums ##:= muss[rfnum][newmunum]
					  then () = if muDones[rfnum][newmunums~[0]]
						    then let () = finished_up :=true
						    	 then muDonesrf = muDones[rfnum]
							 then () = for j@i in newmunums
						      	   	   do muDonesrf[j] :=true
						      	   	   od
						 	 in muDones[rfnum] := muDonesrf
						     fi {muDones}
		   			  then mussrf = muss[rfnum]
    	           			  then () = mussrf[ktypenum] := newmunums
		   			  then () = for j@i in newmunums
		   	     		       	    do if #mussrf[j] < #newmunums[i:]
			     			       then mussrf[j] := newmunums[i:]
						       fi
			     			    od
		   			  then () = muss[rfnum]:=mussrf
					  in () {then () = j0:=-1; true }{we managed to get a new tau}
				      else let () = finished_up :=true
					   then muDonesrf = muDones[rfnum]
					   then () = for j@i in newmunums
						     do muDonesrf[j] :=true
						     od
					   then () = muDones[rfnum] := muDonesrf
				           {then () = prints("finishing ",taulast,
						      ", muDones[rf] = ",muDones[rfnum])}
					   in () {false }{we failed to get a new tau}
				      fi {#uptaus > 0}
			    od {#newmunums < bd}
		   then mussrf = muss[rfnum]
    	           {then () = mussrf[ktypenum] := newmunums}
		   then () = for j@i in newmunums
		   	     do if #mussrf[j] < #newmunums[i:]
			     	then mussrf[j] := newmunums[i:]
				fi
			     od
		   in muss[rfnum]:=mussrf
	     fi {not muDones}
	 then () =  assert(#muss[rfnum]= muhashes[rfnum].size() and #muss[rfnum] = #muDones[rfnum],
	      	    "mu_up_hash damaged in am")
	 then () = up_mu_time +:= elapsed_ms() - start_time
	 {then () = include_imag_flag:=true}
	 in (rfnum,ktypenum)

    then up_types(KType mu,int m) = [KType]: 
     	 let (rfnum, ktypenum) = add_K_type(mu)
     	 then () = while #muss[rfnum][ktypenum] < m
     	       	     and not muDones[rfnum][ktypenum]
	       	  do add_muss(mu, m)
	       	  od
         in for j in muss[rfnum][ktypenum][:min(#muss[rfnum][ktypenum],m)]
     	    do muhashes[rfnum].index(j)
	    od
    in
(  ( -> int): {real_form_size} @int: real_form_hash.size()
   , ( -> vec): {K_type_sizes} @vec:
       for muhash in muhashes
       do muhash.size()
       od
   , ( -> ): {clear} clear
   , ((KType,int) -> [KType]): {up_types} (KType mu, int m) [KType]:
     up_types(mu,m)
   , ((KType,int) -> [int]): {up_heights}  (KType mu, int m) [int]:
     let list = up_types(mu,m)
     in for tau in list do height(tau) od
   , (KType -> (int,bool)): {completion} (KType mu) (int,bool):
     let (rfnum, ktypenum) = add_K_type(mu)
     in (#muss[rfnum][ktypenum],muDones[rfnum][ktypenum])
)
)

set up_mu_hash = make_up_mu_hash()
