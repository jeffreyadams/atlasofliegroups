<basic.at

{ Functions for computing with Weyl group elements }

set length ((RootDatum,mat) rd_M) = int: W_elt(rd_M).length

{ whether multiplication by simple reflection lengthens or shortens M }
set lengthens (RootDatum rd, mat M, int s) = bool: { for right multiplication }
  rd.is_positive_root(M*root(rd,s))
set lengthens (RootDatum rd, int s, mat M) = bool: { for left multiplication }
  rd.is_positive_coroot(coroot(rd,s)*M)

{ write given root (assumed positive) as |w*alpha| with alpha simple }
set from_simple (RootDatum rd, vec alpha) = (WeylElt,vec):
  let r = semisimple_rank(rd), w=id_W(rd) in
  while { first find index that will make alpha shorter, which should exist }
    let i = first( r, (int i):(coroot(rd,i)*alpha).> ) in
    assert(i.>=,"Not a positive root")  { some descent must be found }
  ; alpha != root(rd,i) { this is the condition of the outer while! }
  do alpha := W_gen(rd,i)*alpha; w := w#i
  od; (w,alpha)

set root_reflection (RootDatum rd, vec alpha) = WeylElt:
  let (w,beta) = from_simple(rd,alpha) in w*W_gen(rd,root_index(rd,beta))*/w

{			--- cross action ---				}


set cross (WeylElt w,KGBElt x) = KGBElt:
  assert(w.root_datum=x.root_datum);
  for s in w.word ~do x:=cross(s,x) od; x
set cross (WeylElt w,Param p) = Param:
  assert(w.root_datum=p.root_datum);
  for s in w.word ~do p:=cross(s,p) od; p

{		--- translating to dominant gamma ---			}


{ |gamma| is integrally dominant, need to add a sum of roots to it to make it
  dominant; this does not change the integral Weyl chamber of |gamma|,
  so when acting on parameters it is another parameter with the same types of
  roots, generating an isomorphic block
  this algorithm is crude: it adds a big enough multiple of |2*rho(rd)|
}
set make_dominant_using_roots (RootDatum rd, ratvec gamma) = (ratvec,vec):
  let diff = two_rho(rd) * { minimal scalar>=0 making |gamma+diff| dominant: }
    -min(0)(gamma*simple_coroots(rd)\2)
  in (gamma+diff,diff)

set make_dominant_using_roots (RootDatum rd, vec v) = (vec{dom},vec{shift}):
  let (w,shift) = make_dominant_using_roots(rd,v) in (w\1,shift)

{ assume infinitesimal character |gamma| of |p| is integrally dominant
  translate by sum of roots to make it dominant
  return (new parameter, sum of roots)
}
set translate_to_dominant (Param p) = (Param{dom},vec{shift}):
  let (x,lambda_rho,gamma) = %p
  then  (new_gamma,shift) = make_dominant_using_roots(root_datum(p),gamma)
  in (param(x,lambda_rho+shift,new_gamma),shift)

{      ---------- integrally dominant functions -------------		}

set integrally_from_dominant ((RootDatum,ratvec)(,v):rd_v) = (WeylElt,ratvec):
  from_dominant(integrality_datum(rd_v),v)
set integrally_dominant ((RootDatum,ratvec)(,v):rd_v) = ratvec:
  dominant(integrality_datum(rd_v),v)

{ a W-invariant form on X^* (or its rational span) }

{ Each coroot alpha^v defines defines a rank-1 bilinear form on X^* by
  multiplying its evaluations at a pair of weights. Since alpha^v and -\alpha^v
  give the same form, summing over all positive coroots gives a W-invariant
  form, whose radical is the coradical of the root datum. In formula
  $$
    (\mu,\nu)=\sum_{\alpha^v\in\Delta^{\vee+}} <\alpha^v,\mu><\alpha^v\nu>
  $$
  The summation is conveniently done by multiplying a wide matrix M by ^M
}
set invariant_form_matrix (RootDatum rd) = mat: let M=poscoroots(rd) in M*^M
set invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.invariant_form_matrix in (ratvec v, ratvec w) rat: v*A*w

set nondegenerate_invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.invariant_form_matrix + (let M=radical_basis(rd) in M*^M)
  in (ratvec v, ratvec w) rat: v*A*w

{ a W-invariant form on X_*\otimes Q; not directly related to invariant_form }
set co_invariant_form_matrix (RootDatum rd) =mat: let M=posroots(rd) in M*^M
set co_invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.co_invariant_form_matrix in (ratvec v, ratvec w) rat: v*A*w

set is_elliptic (WeylElt w) = bool:
  =eigen_lattice(matrix(w),1)  { |eigen_lattice| empty means no eigenvalue 1 }

{ use complex cross actions to find a KGBElt x0 in a fiber with no C- roots
  by descending through complex descents until none are left
  return (w,x0) where x=cross(w,x0)
}
set from_no_Cminus (KGBElt x) = (WeylElt,KGBElt):
  let rd=x.root_datum then w=id_W(rd), r=rd.semisimple_rank in
  while let s = last(r, (int i)bool: =status(i,x) { complex descent } ) in s.>=
  do w:=w#s; x:=cross(s,x) od; (w,x)

set from_no_Cplus (KGBElt x) = (WeylElt,KGBElt):
  let rd=x.root_datum then w=id_W(rd), r=rd.semisimple_rank in
  while let s = last(r, (int i)bool: status(i,x)=4 { complex ascent } ) in s.>=
  do w:=w#s; x:=cross(s,x) od; (w,x)

{ the same for parameters }
set from_no_Cminus (Param p) = (WeylElt, Param):
  let (w,x0)=from_no_Cminus(p.x) then w1=w.inverse
  in (w,parameter(x0,w1*p.lambda,w1*p.nu))

set from_no_Cplus (Param p) = (WeylElt, Param):
  let (w,x0)=from_no_Cplus(p.x) then w1=w.inverse
  in (w,parameter(x0,w1*p.lambda,w1*p.nu))

set to_no_Cminus (KGBElt x) = KGBElt: let (,y)=from_no_Cminus(x) in y
set to_no_Cplus (KGBElt x) = KGBElt:  let (,y)=from_no_Cplus(x) in y
set to_no_Cminus (Param p) = Param: let (,q)=from_no_Cminus(p) in q
set to_no_Cplus (Param p) = Param:  let (,q)=from_no_Cplus(p) in q

{action of invertible matrix on RootDatum}
set *(mat M,RootDatum rd)=RootDatum:
root_datum(M*simple_roots(rd), ^inverse(M)*simple_coroots(rd))

set *(WeylElt w,RootDatum rd)=RootDatum:matrix(w)*rd

{  order of the Weyl group }
set labels_simple ((string,int)simple_type) = [int]:
   highest_root(Lie_type(simple_type).adjoint)

set labels_simple (LieType lt) = [int]:
  assert(lt.derived_is_simple,"Derived Root Datum is not simple");
  labels_simple(lt.simple_factors[0])

set labels (RootDatum rd) = [int]:
  let (lt,map)= rd.Cartan_matrix.Cartan_matrix_type
  , result = for :rd.semisimple_rank do 0 od, offset=0
  in for (,rank):pair in lt.simple_factors
     do for l@i in labels_simple(pair) do result[map[i+offset]]:=l od
     ;  offset +:=rank
     od; result

set order_W_simple ((string,int)(,rank):pair) = int:
  fac(rank)*product(labels_simple(pair))*det(Lie_type(pair).Cartan_matrix)

set order_W_simple (LieType lt) = int:
  assert(lt.derived_is_simple,"Derived Root Datum is not simple");
{ magic formula for the order of the Weyl group for a simple Lie type: }
  order_W_simple(lt.simple_factors[0])

set order_W (LieType lt) = int:
  for pair in lt.simple_factors do order_W_simple(pair) od.product
set order_W (RootDatum rd) = int: order_W(Lie_type(rd))

{ factor w into commuting factors according to simple factors of rd }
set factorize_w (WeylElt w) = [WeylElt]:
  let rd=w.root_datum then (type,map)=Cartan_matrix_type(rd.Cartan_matrix)
  then codes = simple_factors(type)
   , offset=0 { rank within |type| already seen in loop below }
in for (,rank):code in codes { traverse the simple factors }
   do let sub_map = map[offset:offset+rank] { index mapping for this factor }
      then factor_word =
       ##for s in w.word
	 do let i=find(sub_map,s) in if i.>= then [i] else [] fi
	 od
   in W_elt(rd,factor_word)
   next offset +:= rank
   od

set char_poly (WeylElt w) = vec: char_poly(matrix(w))

{    Coxeter element    }

{. Coxeter element of W .}
set coxeter_element (RootDatum rd) = WeylElt: W_elt(rd,all_simples(rd))

{. Coxeter number .}
set coxeter_number (RootDatum rd) = int:
  rat_as_int(highest_root(rd)*rho_check(rd)+1)

{. torus element representing the Coxeter Weyl group element .}
set coxeter_torus_element (RootDatum rd) = ratvec:
  rho_check(rd)/coxeter_number(rd)
