<basic.at
<simple_factors.at

{ Functions for computing with Weyl group elements }

set length ((RootDatum,mat) rd_M) = int: W_elt(rd_M).length

{ whether multiplication by simple reflection lengthens or shortens M }
set lengthens (RootDatum rd, mat M, int s) = bool: { for right multiplication }
  rd.is_positive_root(M*root(rd,s))
set lengthens (RootDatum rd, int s, mat M) = bool: { for left multiplication }
  rd.is_positive_coroot(coroot(rd,s)*M)

{ write given root (assumed positive) as |w*alpha| with alpha simple }
set from_simple (RootDatum rd, vec alpha) = (WeylElt,vec):
  let r = semisimple_rank(rd), w=id_W(rd) in
  while { first find index that will make alpha shorter, which should exist }
    let i = first( r, (int i):(coroot(rd,i)*alpha).> ) in
    assert(i.>=,"Not a positive root")  { some descent must be found }
  ; alpha != root(rd,i) { this is the condition of the outer while! }
  do alpha := W_gen(rd,i)*alpha; w := w#i
  od; (w,alpha)

set root_reflection (RootDatum rd, vec alpha) = WeylElt:
  let (w,beta) = from_simple(rd,alpha) in w*W_gen(rd,root_index(rd,beta))*/w

{			--- cross action ---				}


set cross (WeylElt w,KGBElt x) = KGBElt:
  assert(w.root_datum=x.root_datum);
  for s in w.word ~do x:=cross(s,x) od; x
set cross (WeylElt w,Param p) = Param:
  assert(w.root_datum=p.root_datum);
  for s in w.word ~do p:=cross(s,p) od; p

{		--- translating to dominant gamma ---			}


{ |gamma| is integrally dominant, need to add a sum of roots to it to make it
  dominant; this does not change the integral Weyl chamber of |gamma|,
  so when acting on parameters it is another parameter with the same types of
  roots, generating an isomorphic block
  this algorithm is crude: it adds a big enough multiple of |2*rho(rd)|
}
set make_dominant_using_roots (RootDatum rd, ratvec gamma) = (ratvec,vec):
  let diff = two_rho(rd) * { minimal scalar>=0 making |gamma+diff| dominant: }
    -min(0)(gamma*simple_coroots(rd)\2)
  in (gamma+diff,diff)

set make_dominant_using_roots (RootDatum rd, vec v) = (vec{dom},vec{shift}):
  let (w,shift) = make_dominant_using_roots(rd,v) in (w\1,shift)

{ assume infinitesimal character |gamma| of |p| is integrally dominant
  translate by sum of roots to make it dominant
  return (new parameter, sum of roots)
}
set translate_to_dominant (Param p) = (Param{dom},vec{shift}):
  let (x,lambda_rho,gamma) = %p
  then  (new_gamma,shift) = make_dominant_using_roots(root_datum(p),gamma)
  in (param(x,lambda_rho+shift,new_gamma),shift)

{      ---------- integrally dominant functions -------------		}

set integrally_from_dominant ((RootDatum,ratvec)(,v):rd_v) = (WeylElt,ratvec):
  from_dominant(integrality_datum(rd_v),v)
set integrally_dominant ((RootDatum,ratvec)(,v):rd_v) = ratvec:
  dominant(integrality_datum(rd_v),v)

{ a W-invariant form on X^* (or its rational span) }

{ Each coroot alpha^v defines defines a rank-1 bilinear form on X^* by
  multiplying its evaluations at a pair of weights. Since alpha^v and -\alpha^v
  give the same form, summing over all positive coroots gives a W-invariant
  form, whose radical is the coradical of the root datum. In formula
  $$
    (\mu,\nu)=\sum_{\alpha^v\in\Delta^{\vee+}} <\alpha^v,\mu><\alpha^v\nu>
  $$
  The summation is conveniently done by multiplying a wide matrix M by ^M
}
set invariant_form_matrix (RootDatum rd) = mat: let M=poscoroots(rd) in M*^M
set invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.invariant_form_matrix in (ratvec v, ratvec w) rat: v*A*w

set nondegenerate_invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.invariant_form_matrix + (let M=radical_basis(rd) in M*^M)
  in (ratvec v, ratvec w) rat: v*A*w

{ a W-invariant form on X_*\otimes Q; not directly related to invariant_form }
set co_invariant_form_matrix (RootDatum rd) =mat: let M=posroots(rd) in M*^M
set co_invariant_form (RootDatum rd) = (ratvec,ratvec->rat):
  let A = rd.co_invariant_form_matrix in (ratvec v, ratvec w) rat: v*A*w

set is_elliptic (WeylElt w) = bool: =kernel(1-matrix(w))  { no eigenvalue 1 }
set is_regular (WeylElt w) = bool:
  { let w0=w.root_datum.w0 in w^(w0.length\w.length)=w0 ? }
  w.length*w.order=2*w.root_datum.nr_of_posroots

{ use complex cross actions to find a KGBElt x0 in a fiber with no C- roots
  by descending through complex descents until none are left
  return (w,x0) where x=cross(w,x0)
}
set from_no_Cminus (KGBElt x) = (WeylElt,KGBElt):
  let rd=x.root_datum then w=id_W(rd), r=rd.semisimple_rank in
  while let s = last(r, (int i)bool: =status(i,x) { complex descent } ) in s.>=
  do w:=w#s; x:=cross(s,x) od; (w,x)

set from_no_Cplus (KGBElt x) = (WeylElt,KGBElt):
  let rd=x.root_datum then w=id_W(rd), r=rd.semisimple_rank in
  while let s = last(r, (int i)bool: status(i,x)=4 { complex ascent } ) in s.>=
  do w:=w#s; x:=cross(s,x) od; (w,x)

{ the same for parameters }
set from_no_Cminus (Param p) = (WeylElt, Param):
  let (w,x0)=from_no_Cminus(p.x) then w1=w.inverse
  in (w,parameter(x0,w1*p.lambda,w1*p.nu))

set from_no_Cplus (Param p) = (WeylElt, Param):
  let (w,x0)=from_no_Cplus(p.x) then w1=w.inverse
  in (w,parameter(x0,w1*p.lambda,w1*p.nu))

set to_no_Cminus (KGBElt x) = KGBElt: let (,y)=from_no_Cminus(x) in y
set to_no_Cplus (KGBElt x) = KGBElt:  let (,y)=from_no_Cplus(x) in y
set to_no_Cminus (Param p) = Param: let (,q)=from_no_Cminus(p) in q
set to_no_Cplus (Param p) = Param:  let (,q)=from_no_Cplus(p) in q

{action of invertible matrix on RootDatum}
set *(mat M,RootDatum rd)=RootDatum:
root_datum(M*simple_roots(rd), ^inverse(M)*simple_coroots(rd))

set *(WeylElt w,RootDatum rd)=RootDatum:matrix(w)*rd

{  order of the Weyl group }

set labels_simple(RootDatum rd)=[int]:
assert(is_simple(derived(rd)),"Derived Root Datum is not simple");
highest_root(adjoint(rd))

set labels(RootDatum rd)=[int]:
let (,factors)=simple_factors(rd) in 
##for f in factors do labels_simple(f) od

set order_W_simple(RootDatum rd)=int:
assert(is_simple(derived(rd)),"Derived Root Datum is not simple");
fac(ss_rank(rd))*product(labels(rd))*det(Cartan_matrix(rd))

set order_W_simple(LieType lt)=int:order_W_simple(simply_connected(lt))

set order_W(RootDatum rd)=let (,factors)=simple_factors(rd) in product(for f in factors do order_W_simple(f) od)
set order_W(LieType lt)=order_W(simply_connected(lt))

{ factor  WeylElt of rd according to simple factors of rd }

set factorize_w(WeylElt w)=[WeylElt]:
let (indices,factors)=simple_factors(w.root_datum) then
v=w.word in
for k:#factors do
 let x=##for i in v do
  let j=find(indices[k],i) in
   if j!=-1 then [j] else [] fi od
  in id_W(factors[k])##x  od

set char_poly(WeylElt w)=char_poly(matrix(w))

{    Coxeter element    }

{. Coxeter element of W .}
set coxeter_element (RootDatum rd) = WeylElt: W_elt(rd,#semisimple_rank(rd))

{. Coxeter number .}
set coxeter_number (RootDatum rd) = int:
  rat_as_int(highest_root(rd)*rho_check(rd)+1)

{. torus element representing the Coxeter Weyl group element .}
set coxeter_torus_element (RootDatum rd) = ratvec:
  rho_check(rd)/coxeter_number(rd)