<basic.at

{extracts (sub)ratvec of elements between two fixed integers, x and y}

set extract([ratvec] vertices, vec functional, int x, int y) = [ratvec]:
assert(y>=x, "first integer argument cannot be larger than the second");
##(for v in vertices do if functional*v>=x and functional*v<=y then [v] else [] fi od)

{extracts (sub)ratvec of elements less than or equal to a fixed integer x}

set extractleft([ratvec] vertices, vec functional, int x) = [ratvec]:
##(for v in vertices do if functional*v<=x then [v] else [] fi od)

{extracts (sub)ratvec of elements greater than or equal to a fixed integer x}

set extractright([ratvec] vertices, vec functional, int x) = [ratvec]:
##(for v in vertices do if functional*v>=x then [v] else [] fi od)

{given a list of rats, produces a list of all integers strictly greater than smallest and strictly smaller than largest}

set int_between([rat] list) = vec:
for i:ceil(max(list))-floor(min(list))-1 from floor(min(list))+1 do i od

{given a pair of ratvecs (x,y), a functional f, and a denominator bound N, lists all ratvecs p on the line segment xy such that
f(p) is integral and denom(f(p)) <= N} 

set new_verts(ratvec x, ratvec y, vec functional, int N) = [ratvec]:
let (a,b)=(functional*x,functional*y) then
list=int_between([a,b]) in
##(for i in list do let pi=((b-i)/(b-a))*x+((i-a)/(b-a))*y in
if denom(pi)<=N then [pi] else [] fi od)

{union of new_verts(x,y,f,N) as x and y run over a given list of ratvecs}


set new_verts([ratvec] list, vec functional, int N) = [ratvec]:
let n=#list in
##(for i:n do ##(for j:n-i-1 from i+1 do new_verts(list[i],list[j],functional,N) od) od)


set chop_big([ratvec] V, vec f) = [[ratvec]]:
let e=for v in V do f*v od then
(x,y)=(min(e),max(e)) in
if is_integer(x) then if is_integer(y) then for i:floor(y)-ceil(x) from ceil(x) do extract(V,f,i,i+1) od
                                            else ##(for i:floor(y)-ceil(x) from ceil(x) do extract(V,f,i,i+1) od,[extractright(V,f,floor(y))]) fi
                      else if is_integer(y) then ##([extractleft(V,f,ceil(x))],for i:floor(y)-ceil(x) from ceil(x) do extract(V,f,i,i+1) od)
                                            else ##(##([extractleft(V,f,ceil(x))],for i:floor(y)-ceil(x) from ceil(x) do extract(V,f,i,i+1) od),[extractright(V,f,floor(y))]) fi fi

set chop_small([ratvec] V, vec f) = [[ratvec]]:
let e=for v in V do f*v od then
I=int_between(e) in
for n in I do extract(V,f,n,n) od

{given a list V of ratvecs, a functional f, and a (sufficiently large) denominator bound N, lists all regions (convex hulls of
[ratvec]s) obtained by chopping V with integer translates of f}

set chop([ratvec] V, vec f, int N) = [[ratvec]]:
let e=for v in V do f*v od then
(x,y)=(min(e),max(e)) in
if floor(x)>=ceil(y)-1 then [V]
else let V=##(V,new_verts(V,f,N)) in
##(chop_small(V,f),chop_big(V,f)) fi

{applies chop iteratively as f runs over positive coroots of a RootDatum G}

set chop_coroots(RootDatum G, [ratvec] vertices, int N) = [[ratvec]]:
let C=poscoroots(G), output = [[ratvec]]:[vertices] in
for c in C do output:=##(for region in output do chop(region,c,N) od) od; output



