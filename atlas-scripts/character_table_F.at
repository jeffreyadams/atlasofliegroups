<character_tables.at
<nilpotent_orbits.at
<character_table_C.at

set rd_F4=simply_connected(F4)
set orbits=rd_F4.orbits

set a=W_elt (rd_F4,[1])
set b=W_elt (rd_F4,[2,1,2])
set c=W_elt (rd_F4,[2,3,2,1,2,3,2])
set d=W_elt (rd_F4,[0])
set tau=W_elt (rd_F4,[2])
set sigma=W_elt (rd_F4,[2,3])
set e=(a*b*c*d)^2
set z=(a*b*c*d)^3
set classes_Kondo_F4_0=
[
id_W(rd_F4),z,a*b,e,e*z,a*d*b*d*c*d,sigma,sigma*z,sigma*e,sigma*e*z,c*d*sigma,d,d*z,sigma*d,sigma*d*z,a*d*b,tau,tau*z,e*tau,e*tau*z,c*a*tau,tau*d,a*tau,a*tau*z,c*d*b*tau
]

set classes_Kondo_F4= {minimal length reps}
for w in classes_Kondo_F4_0 do minimal_representative(w) od

set class_centralizer_sizes_Kondo_F4=for w in classes_Kondo_F4 do w.centralizer_order od
set class_sizes_Kondo_F4=for w@i in classes_Kondo_F4 do order_W(rd_F4)\class_centralizer_sizes_Kondo_F4[i] od
set class_orders_Kondo_F4=for w in classes_Kondo_F4 do w.order od

set character_table_Kondo_F4=
[
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1],
[1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,-1],
[1,1,1,1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,1,1],
[2,2,2,2,2,2,-1,-1,-1,-1,-1,2,2,-1,-1,2,0,0,0,0,0,0,0,0,0],
[2,2,2,2,2,2,-1,-1,-1,-1,-1,-2,-2,1,1,-2,0,0,0,0,0,0,0,0,0],
[2,2,2,-1,-1,2,2,2,-1,-1,-1,0,0,0,0,0,2,2,-1,-1,2,0,0,0,0],
[2,2,2,-1,-1,2,2,2,-1,-1,-1,0,0,0,0,0,-2,-2,1,1,-2,0,0,0,0],
[4,4,4,-2,-2,4,-2,-2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[9,9,1,0,0,-3,0,0,0,0,0,3,3,0,0,-1,3,3,0,0,-1,1,1,1,-1],
[9,9,1,0,0,-3,0,0,0,0,0,3,3,0,0,-1,-3,-3,0,0,1,-1,-1,-1,1],
[9,9,1,0,0,-3,0,0,0,0,0,-3,-3,0,0,1,3,3,0,0,-1,-1,-1,-1,1],
[9,9,1,0,0,-3,0,0,0,0,0,-3,-3,0,0,1,-3,-3,0,0,1,1,1,1,-1],
[6,6,-2,0,0,2,0,0,3,3,-1,0,0,0,0,0,0,0,0,0,0,2,-2,-2,0],
[6,6,-2,0,0,2,0,0,3,3,-1,0,0,0,0,0,0,0,0,0,0,-2,2,2,0],
[12,12,-4,0,0,4,0,0,-3,-3,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
[4,-4,0,1,-1,0,1,-1,-2,2,0,2,-2,-1,1,0,2,-2,-1,1,0,0,2,-2,0],
[4,-4,0,1,-1,0,1,-1,-2,2,0,2,-2,-1,1,0,-2,2,1,-1,0,0,-2,2,0],
[4,-4,0,1,-1,0,1,-1,-2,2,0,-2,2,1,-1,0,2,-2,-1,1,0,0,-2,2,0],
[4,-4,0,1,-1,0,1,-1,-2,2,0,-2,2,1,-1,0,-2,2,1,-1,0,0,2,-2,0],
[8,-8,0,2,-2,0,-1,1,2,-2,0,4,-4,1,-1,0,0,0,0,0,0,0,0,0,0],
[8,-8,0,2,-2,0,-1,1,2,-2,0,-4,4,-1,1,0,0,0,0,0,0,0,0,0,0],
[8,-8,0,-1,1,0,2,-2,2,-2,0,0,0,0,0,0,4,-4,1,-1,0,0,0,0,0],
[8,-8,0,-1,1,0,2,-2,2,-2,0,0,0,0,0,0,-4,4,-1,1,0,0,0,0,0],
[16,-16,0,-2,2,0,-2,2,-2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
]

{when attaching names to signatures there can be 0,1 or 2 primes
primes[list_0,list_1,list_2] where list_i is the ones with i primes
}
set primes=[
[[1,1,1],[1,-1,-1],[4,0,0],[9,3,3],[9,-3,-3],[12,0,0],[4,2,2],[4,-2,-2],[16,0,0]],  {0 primes}
[[1,-1,1],[2,-2,0],[2,0,2],[9,-3,3],[4,-2,2],[8,-4,0],[8,0,4]],                     {1 prime}
[[1,1,-1],[2,2,0],[2,0,-2],[9,3,-3],[4,2,-2],[8,4,0],[8,0,-4]]                      {2 primes}
]

set primes(int n)=
{assert(n>=0 and n<=2,"invalid value of n");}
if n=0 then "" elif n=1 then "'"  elif n=2 then  "''"  else n.to_string fi

set F4_name(CharacterTable ct)=(vec->string):(vec v):string:
let dim=v[0] then
index=find(ct.characters,v) then
d=ct.degree(index) then
number_primes=first(for list in primes do find(list,ct.signature(v))!=-1 od) in
if number_primes=-1
then
 number_primes:=if sum(v)=15 then 1 elif sum(v)=19 then 2 else error("problem with signature [6,0,0]") fi
fi ;
if number_primes=0 then "phi(" + dim.to_string + "," + d.to_string +")" 
else "phi(" + dim.to_string+","+d.to_string+")"+primes(number_primes)
fi

set number_orthogonal_simple_roots(RootDatum rd,ratvec co_weight)=
count(for alpha in rd.simple_roots do alpha*co_weight=0 od)


set character_table_F4_0() = CharacterTable:
{initialize_character_table(simply_connected(F4))}
let order=1152, ncc=25 then
wct=if ct_verbose then prints("computing W_class_table") fi;
W_class_table(simply_connected(F4)) then
classes=if ct_verbose then prints("loading conjugacy classes") fi;
classes_Kondo_F4 then
{sym_powers=sym_powers_reflection(classes)
ran this once, saved output of ct.sym_powers_reflection, re-use it here:
}
sym_powers=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[4,-4,0,1,-1,0,1,-1,-2,2,0,2,-2,-1,1,0,2,-2,-1,1,0,0,2,-2,0],[10,10,2,1,1,-2,1,1,1,1,1,4,4,1,1,0,4,4,1,1,0,2,2,2,0],[20,-20,0,2,-2,0,2,-2,2,-2,0,6,-6,0,0,0,6,-6,0,0,0,0,2,-2,0],[35,35,3,2,2,3,2,2,-4,-4,0,9,9,0,0,1,9,9,0,0,1,3,3,3,-1],[56,-56,0,2,-2,0,2,-2,2,-2,0,12,-12,0,0,0,12,-12,0,0,0,0,4,-4,0],[84,84,4,3,3,-4,3,3,3,3,-1,16,16,1,1,0,16,16,1,1,0,4,4,4,0],[120,-120,0,3,-3,0,3,-3,-6,6,0,20,-20,-1,1,0,20,-20,-1,1,0,0,4,-4,0],[165,165,5,3,3,5,3,3,3,3,-1,25,25,1,1,1,25,25,1,1,1,5,5,5,1],[220,-220,0,4,-4,0,4,-4,4,-4,0,30,-30,0,0,0,30,-30,0,0,0,0,6,-6,0],[286,286,6,4,4,-6,4,4,-8,-8,0,36,36,0,0,0,36,36,0,0,0,6,6,6,0],[364,-364,0,4,-4,0,4,-4,4,-4,0,42,-42,0,0,0,42,-42,0,0,0,0,6,-6,0],[455,455,7,5,5,7,5,5,5,5,1,49,49,1,1,1,49,49,1,1,1,7,7,7,-1],[560,-560,0,5,-5,0,5,-5,-10,10,0,56,-56,-1,1,0,56,-56,-1,1,0,0,8,-8,0],[680,680,8,5,5,-8,5,5,5,5,1,64,64,1,1,0,64,64,1,1,0,8,8,8,0],[816,-816,0,6,-6,0,6,-6,6,-6,0,72,-72,0,0,0,72,-72,0,0,0,0,8,-8,0],[969,969,9,6,6,9,6,6,-12,-12,0,81,81,0,0,1,81,81,0,0,1,9,9,9,1],[1140,-1140,0,6,-6,0,6,-6,6,-6,0,90,-90,0,0,0,90,-90,0,0,0,0,10,-10,0],[1330,1330,10,7,7,-10,7,7,7,7,-1,100,100,1,1,0,100,100,1,1,0,10,10,10,0],[1540,-1540,0,7,-7,0,7,-7,-14,14,0,110,-110,-1,1,0,110,-110,-1,1,0,0,10,-10,0],[1771,1771,11,7,7,11,7,7,7,7,-1,121,121,1,1,1,121,121,1,1,1,11,11,11,-1],[2024,-2024,0,8,-8,0,8,-8,8,-8,0,132,-132,0,0,0,132,-132,0,0,0,0,12,-12,0],[2300,2300,12,8,8,-12,8,8,-16,-16,0,144,144,0,0,0,144,144,0,0,0,12,12,12,0],[2600,-2600,0,8,-8,0,8,-8,8,-8,0,156,-156,0,0,0,156,-156,0,0,0,0,12,-12,0],[2925,2925,13,9,9,13,9,9,9,9,1,169,169,1,1,1,169,169,1,1,1,13,13,13,1]]
in
  ( Lie_type(F4)    {lie_type}  
  , order    {order (of W)}
  , ncc      {n_classes}
  , (int j) classical_class: ().null_class
  , (int j) string: "" {class_label} {fill in later}
  , classes_Kondo_F4  {class_reps}
  , (int j) int: class_orders_Kondo_F4[j]
  , (int j, int p) int: first(ncc,(int i): is_conjugate(classes_Kondo_F4[i],classes_Kondo_F4[j]^p))
  , class_centralizer_sizes_Kondo_F4
  , class_sizes_Kondo_F4
  , (int j): null_irrep()
  , (int i) string: "" { irreducible representation label }  {later}
  , sym_powers
  ,[int]:[]     {degrees}
  ,[int]:[]     {fake degrees}
  , ^character_table_Kondo_F4
  )


set character_table_F4()=
let ct_0=
if ct_verbose then prints("Computing character table for F4") fi;
character_table_F4_0() then
ct=ct_0.update_degrees then
F4_names(int i)=ct.F4_name(ct.character(i)) {function} in
ct.irreducible_label:=F4_names;
if ct_verbose then prints("Done computing character table for F4") fi;
ct

{
set ct=character_table_F4()
ct:=ct.update_degrees
set F4_names(CharacterTable ct)=[string]:for i:ct.n_classes do ct.F4_name(ct.character(i)) od
set F4_names(int i)=ct.F4_names[i]
}
forget a
forget b
forget c
forget d
forget tau
forget sigma
forget e
forget z





