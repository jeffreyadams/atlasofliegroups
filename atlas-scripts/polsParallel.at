<writeFiles.at
<facetious.at

{This version should be loaded with atlas, and then executed by

atlas> >targetE8DIM.at TEST(G,DIM)

Resulting target file, when loaded into  atlas, produces a [[vec]]
GPairsSmallestDIM of size the number of DIM-dimensional
facets. Entry E = GPairsSmallestDIM[i] has E[0] equal to the facet as
a vec, and E[1:] the usual KPolData for the corresponding
K-character.}

{Progress of the job can be measured with "tail targetE8DIM"; a line
beginning

void: GPairsSmallestDIM[X]:=[[...

means that you have completed facet #X.}

set number_fundamental_facets(RealForm G)=[int]:
 for i:ss_rank(G)+1 do #facets_fundamental(G,i) od

{version of TEST with just the facets}
set facets(RealForm G, int dim) = 
    begin
let rh=G.rho
then xo = G.x_open
then vd = FPP_vertex_data (G,-1)
then () = facet_verbose:=false
{then varName = "GFacets"##to_string(dim)}
then varName = "Facets"
then E8sizes = [ 610995,   25762046, 298908428, 1566837152,4413546720,
    7147951104, 6675056640,  3344302080, 696729600]
then size = if G = E8_s then E8sizes[dim] else
    W_fund_d_facets_card(G,dim) fi
    {Might CORRECT TO #FACETS; this is an overestimate.}
then FVind = null(dim+1), zero = null(G.rank)
then bary = ratvec: zero/1, wbF = ratvec: zero/1, gamma2 = ratvec:
    zero/1, wbeta0 = zero, bup = zero, bdown = zero
then pol = null_K_module(G)
then i = int:0
{then () = write_real_form(G);
     prints("set ",varName," = [[int]]: for i:",size," do [] od")}
then facets = [FacetVerts]: facets_fundamental(G,dim)
in   for FV@k in facets
     do let bary_F=FacetBary: sum(G.rank,FV)/(dim+1)
       	then irdw = integrality_datum(G,bary_F)
	in for w in affine_orbit_ws(G,bary_F)
	   do let () = wbF := w*bary_F, iw = inverse(w)
	      then (x3,) = from_dominant(irdw, iw*G.two_rho)
	      in for tau in FPPtauRoots(G,wbF, -1)
	     	 do let () = wbeta0 := -tau + w*G.two_rho
		    then gamma2 = wbF + w*G.two_rho
		    then () = bup :=  wbeta0 +
		    	 ratvec_as_vec(w*(x3*(iw*gamma2)) - gamma2)
		    then () = FVind:= for v in (AffineCoWeylElt:(tau,w))*FV
		      	   	   do vd.lookup(v)
		      	   	   od.sort
		    then () = bary := w*bary_F + tau
		    then () = bdown := -inverse(x3)*(iw*bup)
{		    then () = pol := K_type_pol( translate_param_by(
    character_formula(1*parameter(xo,rh+bup,bary+bup)),bdown))}
{    in prints("void: ",varName,"[",i,"]:=",[int]: FVind);}
{    in prints("(" + FV[0].to_string + "," + w.to_string + "," +  FVind.to_string + ")");}
    in prints("[" + bary.to_string + "," + bup.to_string + "," + bdown.to_string +"]");
    i+:=1
	         od
	     od
	 od
	 end

set facets(RealForm G)=void:
for dim: ss_rank(G)+1 do facets(G,dim) od


set TESTclassical(RealForm G, int dim) = void:
    begin
let rh=G.rho
then xo = G.x_open
then vd = FPP_vertex_data (G,-1)
then () = facet_verbose:=false
then varName = "GFacets"##to_string(dim)
then E8sizes = [ 610995,   25762046, 298908428, 1566837152,4413546720,
    7147951104, 6675056640,  3344302080, 696729600]
then size = if G = E8_s then E8sizes[dim] else
    W_fund_d_facets_card(G,dim) fi
    {Might CORRECT TO #FACETS; this is an overestimate.}
then FVind = null(dim+1), zero = null(G.rank)
then bary = ratvec: zero/1, wbF = ratvec: zero/1
then pol = null_K_module(G)
then i = int:0
then () = write_real_form(G);
     prints("set ",varName," = [[vec]]: for i:",size," do [] od")
then facets = [FacetVerts]: facets_fundamental(G,dim)
in   for FV@k in facets
     do let bary_F=FacetBary: sum(G.rank,FV)/(dim+1)
       	in for w in affine_orbit_ws(G,bary_F)
	   do let () = wbF := w*bary_F, iw = inverse(w)
	      in for tau in FPPtauRoots(G,wbF, -1)
	     	 do let () = FVind:= for v in (AffineCoWeylElt:(tau,w))*FV
		      	   	   do vd.lookup(v)
		      	   	   od.sort
		    then () = bary := w*bary_F + tau
		    then () = pol :=
    		    	 K_type_pol(character_formula(parameter(xo, rh,bary)))
    in prints("void: ",varName,"[",i,"]:=",[[int]]: [FVind]##K_data(pol));
    i+:=1
	         od
	     od
	 od
	 end

set K_char(RealForm G,ratvec bary, vec bup, vec bdown)=
K_type_pol( translate_param_by(character_formula(1*parameter(x_open(G),G.rho+bup,bary+bup)),bdown))

set K_char(RealForm G,(ratvec bary, vec bup, vec bdown))=
K_char(G,bary,bup,bdown)

set K_char(RealForm G,[ratvec] vecs)=
K_char(G,vecs[0],ratvec_as_vec(vecs[1]),ratvec_as_vec(vecs[2]))

{
set test_facet(RealForm G, [ratvec] FV, WeylElt w,  [ratvec] facet) = void:
begin
let rh=G.rho
then dim=#facet-1
then xo = G.x_open
then vd = FPP_vertex_data (G,-1)
then bary_F=FacetBary: sum(G.rank,FV)/(dim+1)
then irdw = integrality_datum(G,bary_F)
then FVind = null(dim+1), zero = null(G.rank)
then bary = ratvec: zero/1, wbF = ratvec: zero/1, gamma2 = ratvec:
    zero/1, wbeta0 = zero, bup = zero, bdown = zero
then pol = null_K_module(G)
then i = int:0
{in for w in affine_orbit_ws(G,bary_F)}
    then () = wbF := w*bary_F, iw = inverse(w)
    then (x3,) = from_dominant(irdw, iw*G.two_rho)
    in
    for tau in FPPtauRoots(G,wbF, -1)
     do let()=prints("tau: ", tau)
     then () = wbeta0 := -tau + w*G.two_rho
     then gamma2 = wbF + w*G.two_rho
     then () = bup :=  wbeta0 + ratvec_as_vec(w*(x3*(iw*gamma2)) - gamma2)
     then () = FVind:=
      for v in (AffineCoWeylElt:(tau,w))*FV
       do vd.lookup(v)
       od.sort
     then () = bary := w*bary_F + tau
     then () = bdown := -inverse(x3)*(iw*bup)
     then () = pol := K_type_pol( translate_param_by(character_formula(1*parameter(xo,rh+bup,bary+bup)),bdown))
     in prints("void:[",i,"]:=",[[int]]: [FVind]##K_data(pol))
    od{tau}
end}