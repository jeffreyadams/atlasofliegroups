<qParamPol.at
<deform.at
<hermitian.at
set qd_verbose=false

{q version of deformation algorithm
 actually "q" is "v" in the algorithm}

{difference of two vectors of polynomials of the same length}
set poly_rows_minus([i_poly] f,[i_poly] g)=[i_poly]:([f]-[g])[0]

{compute last column of the inverse of an upper unitriangular polynomial matrix}
set last_column_mat_poly_inverse(i_poly_mat A)=[i_poly]:
{check poly_1's on the diagonal}
assert(all(for i:#A do A[i][i]=poly_1 od), "A is not upper unitriangular");
let B=transpose(A) {since i_poly_mat is given by rows, not columns}
then n=#B then
remainder=zero_poly_row(n-1)#poly_1
,solution=zero_poly_row(n) in
for j:n
~do let contrib=for i:n do convolve(remainder[j],B[j][i]) od  in
remainder :=poly_rows_minus(remainder,contrib);
solution[j]:=contrib[j] od;solution

{convert mat to i_poly_mat
caution: mat is by columns, i_poly_mat is by rows
}
set mat_as_poly_mat(mat A)=i_poly_mat:
let B=^A then
(n,m)=shape(B) in
for i:m do for j:n do vec:[B[i][j]] od od

{q-version of compress from deform.at}
set q_compress ([Param] B, mat KL_mat, [i_poly] polys, vec stops, vec survivors, mat map) =
  ([Param], i_poly_mat, [int]):
  let KL_poly_mat = i_poly_mat: transpose(for col in KL_mat do for inx in col do polys[inx] od od) then
   S=for j in survivors do KL_poly_mat[j] od then
   M=mat_as_poly_mat(map) then
   reduced_KL_poly_mat =  i_poly_mat:S*transpose(M) then
   survivor_lengths = let l=0 in
    for s in survivors do while stops[l+1]<=s do l+:=1 od; l od
  in
  ( for i in survivors do
  B[i] od { block restricted to survivors }
  , { matrix of associated P polynomials}
    for col@j in reduced_KL_poly_mat
    do
(for e@i in col do minus_1^survivor_lengths[i]*minus_1^survivor_lengths[j]*e od)
    od
  , survivor_lengths { length mapping }
  )

set vee=i_poly:[0,1]  {polynomial v}
{Q(v^{-1}), this is a Laurent polynomial so shouldn't be needed/used,
except in the subsequent function}
set Q_v_inverse(i_poly f)=reverse(f)
{v^k*Q(v^{-1}), k should be large enough so this is a polynomial}
set v_to_the_k_times_Q_v_inverse(int N,i_poly f)=null(N-degree(f))##reverse(f)

{q-version of deformation_terms, using last_column_mat_poly_inverse(KL_mat)
to compute column of inverse as polynomial in q}
set q_deformation_terms (Param Gamma) = qParamPol:
 let ()=if qd_verbose then prints("Computing q_deformation of ", Gamma) fi in
 let (B,P,length) = q_compress(partial_KL_block(Gamma:=normal(Gamma))) in  {P is the *signed* P-matrix}
 if #B=0 or B~[0]!=Gamma then [null_module(Gamma)] { if |Gamma| itself is not among survivors, return 0 }
  else
   let rv=nullqParamPol(Gamma.real_form) then
   Q_col=last_column_mat_poly_inverse(P)  {last column of Q matrix} in
   for i:#Q_col-1 do  {i <-> Phi}
    for j: #Q_col-i from i do { j <-> Xi}
     let
     Phi=B[i] then
     Xi=B[j] then
     length_diff=length(Gamma)-length(Xi) then
     P_Phi_Xi_v=P[i][j] then
     Q_Xi_Gamma_v=Q_col[j] then
     v_power_Q_Xi_Gamma_v_inverse=v_to_the_k_times_Q_v_inverse(length_diff,Q_Xi_Gamma_v) then
     on=orientation_nr(Gamma)-orientation_nr(Phi) then
     on_over_2=assert(is_even(on),"odd orientation number");on\2 then
{     sign=(-1)*(-1)^(length(Xi)-length(Phi)) then}
     sign=(-1)  { P is the signed matrix, so don't need (-1)^length_diff} then
     contrib=sign*poly_product(poly_product(vee^on_over_2,P_Phi_Xi_v),v_power_Q_Xi_Gamma_v_inverse) in
     {debugging only}
     if qd_verbose=true then
        prints(new_line,"(i,j)=(",i,",",j,")",new_line,
	"Xi: ", Xi, new_line,
        "Gamma: ", Gamma, new_line,
        "Phi: ", Phi, new_line, "Xi: ", Xi, new_line,
        "P(v): ", P_Phi_Xi_v, new_line,
	"v^*Q(v^(-1)):", Q_Xi_Gamma_v, new_line,
        "on(Gamma): ", orientation_nr(Gamma),new_line,
        "on(Phi): ", orientation_nr(Phi),new_line,
	"orientation number term=v^", on_over_2, new_line,
        "length diff: ", length_diff,new_line,
	"sign: ", sign,new_line,
	"contribution: ", poly_format(contrib,"v")) fi;
     {end debugging}
     rv+:=contrib*[Phi]
    od
   od;rv
 fi

{q version of recursive deform}
set q_recursive_deform (Param p) = qParamPol:
  if qd_verbose then prints("q_recursive_deform with:", p) fi;
  if not is_final(p) then error("improper parameter") fi;
  let empty=nullqParamPol(real_form(p)) in
  if  qd_verbose { choose verbose or non-verbose version of the function }
  then rec_fun q_full_def (i_poly sc,Param p) qParamPol:
			 { |sc| will simply scale the resulting ParamPol }
    begin
      prints("q_full_def with: sc=", sc, ", p=", p);
      assert(is_standard(p)
	    ,"non standard parameter encountered in deformation");
      let acc=empty, at_nu0=qParamPol: sc*[p.at_nu_0] { fully deformed |p| } in
      for factor in reducibility_points(p)
      ~do
	let p_def=p*factor { next deformation of |p| } then
        def=q_deformation_terms(p_def) { bypass built-in |deform| here }
        in
	  prints("adding deformation term: p=", def, new_line,"adding:", def)
      ; acc+:=def
      od
    ; for (f,q) in rearrange(acc) { traverse the sum of the deformation terms spun off }
      do { apply |q_full_def| recursively to all those terms }
        at_nu0 +:= q_full_def(convolve(sc,f),q) { gather harvest from those deformations }
      od
    ; at_nu0
    end
  else rec_fun q_full_def (i_poly sc,Param p) qParamPol:
			 { |sc| will simply scale the resulting ParamPol }
    begin
      assert(is_standard(p),"non standard parameter in deformation");
      let acc=empty, at_nu0=qParamPol: sc*[p.at_nu_0] { fully deformed |p| } in
      for factor in reducibility_points(p)
      ~ { direction of deformation is down, towards 0; this is not essential }
      do
      let qd=q_deformation_terms(p*factor) in
       acc+:=qd od
    ; for (f,q) in rearrange(acc) { traverse the sum of the deformation terms spun off }
      do at_nu0 +:= q_full_def(convolve(sc,f),q) od
    ; at_nu0
    end
  fi { apply that recursive function to the initial argument: } ([1],p)


{another identical copy of the q_recursive_deform *except* that 
the deformation is outward, which is useful for debugging}
set q_recursive_deform_reverse (Param p) = qParamPol:
  if qd_verbose then prints("q_recursive_deform with:", p) fi;
  if not is_final(p) then error("improper parameter") fi;
  let empty=nullqParamPol(real_form(p)) in
  if  qd_verbose { choose verbose or non-verbose version of the function }
  then rec_fun q_full_def (i_poly sc,Param p) qParamPol:
			 { |sc| will simply scale the resulting ParamPol }
    begin
      prints("q_full_def with: sc=", sc, ", p=", p);
      assert(is_standard(p)
	    ,"non standard parameter encountered in deformation");
      let acc=empty, at_nu0=qParamPol: sc*[p.at_nu_0] { fully deformed |p| } in
      for factor in reducibility_points(p)
      do  {ONLY change from q_recursive_deform is missing ~ here}
	let p_def=p*factor { next deformation of |p| } then
        def=q_deformation_terms(p_def) { bypass built-in |deform| here }
        in
	  prints("adding deformation term: p=", def, new_line,"adding:", def)
      ; acc+:=def
      od
    ; for (f,q) in rearrange(acc) { traverse the sum of the deformation terms spun off }
      do { apply |q_full_def| recursively to all those terms }
        at_nu0 +:= q_full_def(convolve(sc,f),q) { gather harvest from those deformations }
      od
    ; at_nu0
    end
  else rec_fun q_full_def (i_poly sc,Param p) qParamPol:
			 { |sc| will simply scale the resulting ParamPol }
    begin
      assert(is_standard(p),"non standard parameter in deformation");
      let acc=empty, at_nu0=qParamPol: sc*[p.at_nu_0] { fully deformed |p| } in
      for factor in reducibility_points(p)
      do  {ONLY change from q_recursive_deform is missing ~ here}
      let qd=q_deformation_terms(p*factor) in
       acc+:=qd od
    ; for (f,q) in rearrange(acc) { traverse the sum of the deformation terms spun off }
      do at_nu0 +:= q_full_def(convolve(sc,f),q) od
    ; at_nu0
    end
  fi { apply that recursive function to the initial argument: } ([1],p)

set print(qParamPol P, int n)=void:prints("lead term: v^",n);print(P)

{------------------ some test functions--------------------}
set qtest(Param p,int N)=void:
let qdef=q_recursive_deform(p) then
rv=branch_q(qdef,N) then
positive=all(##for i:#rv do for c@p in rv[i] do split_as_int(c)>0 od od) then
valid_evaluation_at_s=evaluate_at_s(qdef)=recursive_deform(p) then
valid_evaluation_at_1=evaluate_at_1(qdef)=p*0 in
prints(p.real_form,new_line,"N:",N,new_line,p,new_line,"q_deformation to 0: ");print(rv);prints(new_line,
"correct evaluation at v=1:",valid_evaluation_at_1,new_line,
"correct evaluation at v=s:",valid_evaluation_at_s,new_line,
"positive coefficients: ",positive,new_line);()
{(qdef,rv,valid_evaluation_at_1,valid_evaluation_at_s,positive)}

set qtest(RealForm G,int N)=void:qtest(trivial(G),N)

set runqtests()=
let groups=
[(SL(2,C),10),
(SL(3,C),15),
(SL(4,C),20),
(SO(3,1),40),
(SO(5,1),50),
(SO(7,1),80),
(Sp(4,C),20),
(complexification(G2_s),50)]
in for (G,N) in groups do qtest(G,N) od

set q_signed_P_matrix(Param Gamma)=i_poly_mat:
let (,P,) = q_compress(partial_KL_block(Gamma)) in P

set q_P_matrix(Param Gamma)=i_poly_mat:
let (,P_signed,lengths) = q_compress(partial_KL_block(Gamma)) in
for i:#P_signed do for j:#P_signed[i] do (-1)^(lengths[i]-lengths[j])*P_signed[i][j] od od

set hodge_irreducible(Param p)=
let (B,P_signed,lengths)=q_compress(partial_KL_block(p)) then
rv=nullqParamPol(p.real_form) then 
!on_p = orientation_nr(p) then
n=#B in
for i:n do 
 let   (q,r)=(on_p-orientation_nr(B[i]))\%2 then
 coeff= assert(=r,"odd orientation");poly_product(vee^q,P_signed[i][n-1]) in 
 let ()=prints(new_line,i, " ", B[i], new_line,"coeff=",coeff);print(evaluate_at_s(q_recursive_deform(B[i]))) in
rv+:=coeff*q_recursive_deform(B[i]) od;rv


set c_form_irreducible (Param p) = ParamPol:
( let ori_nr_p = orientation_nr(p), P = null_module(real_form(p)) in
  for c@q in KL_sum_at_s(p)
  do 
  let ()=prints(new_line, q, new_line, "c=",c);print(c_form_std(q)) in
P +:= c*orientation_nr_term(ori_nr_p,q)*c_form_std(q) od
; P
)
