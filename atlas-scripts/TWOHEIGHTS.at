<basic.at {for dominant}

{ The notion of height for parameter is more or less TWICE Bourbaki's height for a positive root. This file defines a general function non-negative rat-valued function HT on rational weights, which for roots is twice the Bourbaki height.

HT applied to the lambda of a Param is the atlas height; here we call that HTT.

HT applied to the nu of a Param is more or less a new invariant, here called HTA.

Always HTT(p) + HTA(p) \ge HT(p.infinitesimal character), with equality for split principal series and for discrete series.

If q is a composition factor of the standard p, then in atlas we make heavy use of the fact that HTT(q) \ge HTT(p), with equality only if p=q. It's also true that HTA(q) \le HTA(p), with equality only if p=q.
} 

set HT(RootDatum rd, ratvec v) = rat:
    2*(rd.rho_check)*(dominant(rd,v))

{.equal to height(p)/1.}
set HTT(Param p) = rat:
    let theta = ^p.x.involution, rd = p.root_datum
    in HT(rd, (1+theta)*p.lambda/2)

set HTA(Param p) = rat:
    let rd = p.root_datum in HT(rd, p.nu)

{HTT(p) = height(p)/1; HTT(p) + HTA(p) \ge HT(p.infinitesimal_char)}

{How to verify that HTA strictly decreases in composition series}
{set P = all_parameters_gamma(SO(4,3),[7,5,1]/2)}
{set BELOW = for p in P do monomials(composition_series(p)) od}
{set BELOWHTA = for j:#P do for k:#BELOW[j] do HTA(BELOW[j][k]) od od}
{all(for j:53 do all(for k:#BELOWHTA[j] -1 from 1 do BELOWHTA[j][k] < BELOWHTA[j][0] od) od)}

{
how to sort a [ratvec] by some rat-valued function on the indices

say list = [ratvec] and params = [Param] is a corresponding list of
Param's

set leq(int i, int j) = HTA(params[i] <= HTA(params[j])
set listsorter = sort(leq@(int,int))(#list)
set sortedList = for i:#list do list[listsorter[i]] od
set sortedParams = for i:#list do params[listsorter[i]] od

}
